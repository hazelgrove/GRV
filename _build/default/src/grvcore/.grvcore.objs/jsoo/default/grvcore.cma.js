// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Lang
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__Format, Stdlib__Int
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_S = "%S",
    cst_a = "%a",
    cst$23 = ")",
    cst$20 = "->",
    cst$18 = ":",
    cst$19 = "::",
    cst_2 = "<2>",
    cst$21 = "@ ",
    cst$22 = "@])",
    cst_Exp_app = "Exp_app",
    cst_Exp_app_arg = "Exp_app_arg",
    cst_Exp_app_fun = "Exp_app_fun",
    cst_Exp_case = "Exp_case",
    cst_Exp_case_cons_body = "Exp_case_cons_body",
    cst_Exp_case_head_pat = "Exp_case_head_pat",
    cst_Exp_case_nil_body = "Exp_case_nil_body",
    cst_Exp_case_scrut = "Exp_case_scrut",
    cst_Exp_case_tail_pat = "Exp_case_tail_pat",
    cst_Exp_case_type = "Exp_case_type",
    cst_Exp_cons = "Exp_cons",
    cst_Exp_cons_head = "Exp_cons_head",
    cst_Exp_cons_tail = "Exp_cons_tail",
    cst_Exp_lam = "Exp_lam",
    cst_Exp_lam_body = "Exp_lam_body",
    cst_Exp_lam_param = "Exp_lam_param",
    cst_Exp_lam_param_type = "Exp_lam_param_type",
    cst_Exp_nil = "Exp_nil",
    cst_Exp_num = "Exp_num",
    cst_Exp_plus = "Exp_plus",
    cst_Exp_plus_left = "Exp_plus_left",
    cst_Exp_plus_right = "Exp_plus_right",
    cst_Exp_times = "Exp_times",
    cst_Exp_times_left = "Exp_times_left",
    cst_Exp_times_right = "Exp_times_right",
    cst_Exp_var = "Exp_var",
    cst_Pat_var = "Pat_var",
    cst_Root_root = "Root_root",
    cst_Root_root_root = "Root_root_root",
    cst_Typ_arrow = "Typ_arrow",
    cst_Typ_arrow_arg = "Typ_arrow_arg",
    cst_Typ_arrow_result = "Typ_arrow_result",
    cst_Typ_list = "Typ_list",
    cst_Typ_list_content = "Typ_list_content",
    cst_Typ_num = "Typ_num",
    cst_arg$1 = "arg",
    cst_case$1 = "case",
    cst_exp_app = "exp_app",
    cst_exp_app_arg = "exp_app_arg",
    cst_exp_app_fun = "exp_app_fun",
    cst_exp_case = "exp_case",
    cst_exp_case_cons_body = "exp_case_cons_body",
    cst_exp_case_head_pat = "exp_case_head_pat",
    cst_exp_case_nil_body = "exp_case_nil_body",
    cst_exp_case_scrut = "exp_case_scrut",
    cst_exp_case_tail_pat = "exp_case_tail_pat",
    cst_exp_case_type = "exp_case_type",
    cst_exp_cons = "exp_cons",
    cst_exp_cons_head = "exp_cons_head",
    cst_exp_cons_tail = "exp_cons_tail",
    cst_exp_lam = "exp_lam",
    cst_exp_lam_body = "exp_lam_body",
    cst_exp_lam_param = "exp_lam_param",
    cst_exp_lam_param_type = "exp_lam_param_type",
    cst_exp_nil = "exp_nil",
    cst_exp_num = "exp_num",
    cst_exp_plus = "exp_plus",
    cst_exp_plus_left = "exp_plus_left",
    cst_exp_plus_right = "exp_plus_right",
    cst_exp_times = "exp_times",
    cst_exp_times_left = "exp_times_left",
    cst_exp_times_right = "exp_times_right",
    cst_exp_var = "exp_var",
    cst_grvcore$0 = "grvcore",
    cst_left$1 = "left",
    cst_list$1 = "list",
    cst_nil$1 = "nil",
    cst_pat_var = "pat_var",
    cst_right$1 = "right",
    cst_root$1 = "root",
    cst_root_root = "root_root",
    cst_root_root_root = "root_root_root",
    cst_typ_arrow = "typ_arrow",
    cst_typ_arrow_arg = "typ_arrow_arg",
    cst_typ_arrow_result = "typ_arrow_result",
    cst_typ_list = "typ_list",
    cst_typ_list_content = "typ_list_content",
    cst_typ_num = "typ_num",
    cst_var$1 = "var(",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = ".",
    cst$4 = cst$18,
    cst$5 = "\xce\xbb",
    cst$6 = " ",
    cst$7 = " + ",
    cst$8 = " * ",
    cst$9 = cst$19,
    cst$10 = cst$18,
    cst$11 = cst$20,
    cst$12 = cst$19,
    cst$13 = "|",
    cst$14 = cst$20,
    cst$15 = "\xe2\x86\x92",
    cst$16 = "]",
    cst$17 = "[",
    cst$0 = cst$23,
    cst$1 = cst$23,
    cst$2 = cst$23,
    cst = "",
    error_source_003 = "src/grvcore/Lang.ml.Constructor.t",
    error_source_028 = "src/grvcore/Lang.ml.Position.t",
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Format = global_data.Stdlib__Format,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    cst_Int = "Int",
    cst_end = "end",
    cst_nil$0 = cst_nil$1,
    cst_of = "of",
    cst_case$0 = cst_case$1,
    cst_Num = "Num",
    cst_list$0 = cst_list$1,
    cst_Lang_Gadt_Root_root = "Lang.Gadt.Root_root",
    _aW_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_var = "Lang.Gadt.Exp_var",
    _aY_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_lam = "Lang.Gadt.Exp_lam",
    _a0_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_app = "Lang.Gadt.Exp_app",
    _a2_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_num = "Lang.Gadt.Exp_num",
    _a4_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_plus = "Lang.Gadt.Exp_plus",
    _a6_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_times = "Lang.Gadt.Exp_times",
    _a8_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_nil = "Lang.Gadt.Exp_nil",
    _a__ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_cons = "Lang.Gadt.Exp_cons",
    _ba_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Exp_case = "Lang.Gadt.Exp_case",
    _bc_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Pat_var = "Lang.Gadt.Pat_var",
    _be_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Typ_num = "Lang.Gadt.Typ_num",
    _bg_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Typ_arrow = "Lang.Gadt.Typ_arrow",
    _bi_ = [0, [15, 0], cst_a],
    cst_Lang_Gadt_Typ_list = "Lang.Gadt.Typ_list",
    _bk_ = [0, [15, 0], cst_a],
    _bl_ = [0, cst_Typ_list],
    _bj_ = [0, cst_Typ_arrow],
    _bh_ = [0, cst_Typ_num],
    _bf_ = [0, cst_Pat_var],
    _bd_ = [0, cst_Exp_case],
    _bb_ = [0, cst_Exp_cons],
    _a$_ = [0, cst_Exp_nil],
    _a9_ = [0, cst_Exp_times],
    _a7_ = [0, cst_Exp_plus],
    _a5_ = [0, cst_Exp_num],
    _a3_ = [0, cst_Exp_app],
    _a1_ = [0, cst_Exp_lam],
    _aZ_ = [0, cst_Exp_var],
    _aX_ = [0, cst_Root_root],
    cst_Lang_Position_Root_root_ro = "Lang.Position.Root_root_root",
    cst_Lang_Position_Exp_lam_para = "Lang.Position.Exp_lam_param",
    cst_Lang_Position_Exp_lam_para$0 = "Lang.Position.Exp_lam_param_type",
    cst_Lang_Position_Exp_lam_body = "Lang.Position.Exp_lam_body",
    cst_Lang_Position_Exp_app_fun = "Lang.Position.Exp_app_fun",
    cst_Lang_Position_Exp_app_arg = "Lang.Position.Exp_app_arg",
    cst_Lang_Position_Exp_plus_lef = "Lang.Position.Exp_plus_left",
    cst_Lang_Position_Exp_plus_rig = "Lang.Position.Exp_plus_right",
    cst_Lang_Position_Exp_times_le = "Lang.Position.Exp_times_left",
    cst_Lang_Position_Exp_times_ri = "Lang.Position.Exp_times_right",
    cst_Lang_Position_Exp_cons_hea = "Lang.Position.Exp_cons_head",
    cst_Lang_Position_Exp_cons_tai = "Lang.Position.Exp_cons_tail",
    cst_Lang_Position_Exp_case_scr = "Lang.Position.Exp_case_scrut",
    cst_Lang_Position_Exp_case_nil = "Lang.Position.Exp_case_nil_body",
    cst_Lang_Position_Exp_case_hea = "Lang.Position.Exp_case_head_pat",
    cst_Lang_Position_Exp_case_tai = "Lang.Position.Exp_case_tail_pat",
    cst_Lang_Position_Exp_case_con = "Lang.Position.Exp_case_cons_body",
    cst_Lang_Position_Exp_case_typ = "Lang.Position.Exp_case_type",
    cst_Lang_Position_Typ_arrow_ar = "Lang.Position.Typ_arrow_arg",
    cst_Lang_Position_Typ_arrow_re = "Lang.Position.Typ_arrow_result",
    cst_Lang_Position_Typ_list_con = "Lang.Position.Typ_list_content",
    _D_ = [0, [15, 0], cst_a],
    _aK_ = [0, 1],
    _aL_ = [0, 2],
    _aM_ = [0, 4],
    _aN_ = [0, 6],
    _aO_ = [0, 8],
    _aP_ = [0, 10],
    _aQ_ = [0, 12],
    _aR_ = [0, 13],
    _aS_ = [0, 14],
    _aT_ = [0, 15],
    _aU_ = [0, 16],
    _aV_ = [0, 18],
    _ay_ = [0, 2],
    _az_ = [0, 3],
    _aA_ = [0, 5],
    _aB_ = [0, 7],
    _aC_ = [0, 9],
    _aD_ = [0, 11],
    _aE_ = [0, 13],
    _aF_ = [0, 14],
    _aG_ = [0, 15],
    _aH_ = [0, 16],
    _aI_ = [0, 17],
    _aJ_ = [0, 19],
    _ap_ = [0, 0],
    _aq_ = [0, 3],
    _ar_ = [0, 4],
    _as_ = [0, 6],
    _at_ = [0, 8],
    _au_ = [0, 10],
    _av_ = [0, 12],
    _aw_ = [0, 18],
    _ax_ = [0, 20],
    _ag_ = [0, 0],
    _ah_ = [0, 1],
    _ai_ = [0, 4],
    _aj_ = [0, 6],
    _ak_ = [0, 8],
    _al_ = [0, 10],
    _am_ = [0, 12],
    _an_ = [0, 18],
    _ao_ = [0, 20],
    _Z_ = [0, 0, 0],
    ___ = [0, 1, [0, 2, [0, 3, 0]]],
    _$_ = [0, 4, [0, 5, 0]],
    _aa_ = [0, 6, [0, 7, 0]],
    _ab_ = [0, 8, [0, 9, 0]],
    _ac_ = [0, 10, [0, 11, 0]],
    _ad_ = [0, 12, [0, 13, [0, 14, [0, 15, [0, 16, [0, 17, 0]]]]]],
    _ae_ = [0, 18, [0, 19, 0]],
    _af_ = [0, 20, 0],
    cst_root$0 = cst_root$1,
    cst_param = "param",
    cst_param_type = "param_type",
    cst_body = "body",
    cst_fun = "fun",
    cst_arg = cst_arg$1,
    cst_left = cst_left$1,
    cst_right = cst_right$1,
    cst_left$0 = cst_left$1,
    cst_right$0 = cst_right$1,
    cst_head = "head",
    cst_tail = "tail",
    cst_scrut = "scrut",
    cst_nil_body = "nil_body",
    cst_head_pat = "head_pat",
    cst_tail_pat = "tail_pat",
    cst_cons_body = "cons_body",
    cst_type = "type",
    cst_arg$0 = cst_arg$1,
    cst_result = "result",
    cst_content = "content",
    _E_ = [0, cst_Root_root_root],
    _F_ = [0, cst_Exp_lam_param],
    _G_ = [0, cst_Exp_lam_param_type],
    _H_ = [0, cst_Exp_lam_body],
    _I_ = [0, cst_Exp_app_fun],
    _J_ = [0, cst_Exp_app_arg],
    _K_ = [0, cst_Exp_plus_left],
    _L_ = [0, cst_Exp_plus_right],
    _M_ = [0, cst_Exp_times_left],
    _N_ = [0, cst_Exp_times_right],
    _O_ = [0, cst_Exp_cons_head],
    _P_ = [0, cst_Exp_cons_tail],
    _Q_ = [0, cst_Exp_case_scrut],
    _R_ = [0, cst_Exp_case_nil_body],
    _S_ = [0, cst_Exp_case_head_pat],
    _T_ = [0, cst_Exp_case_tail_pat],
    _U_ = [0, cst_Exp_case_cons_body],
    _V_ = [0, cst_Exp_case_type],
    _W_ = [0, cst_Typ_arrow_arg],
    _X_ = [0, cst_Typ_arrow_result],
    _Y_ = [0, cst_Typ_list_content],
    cst_Lang_Constructor_Root_root = "Lang.Constructor.Root_root",
    cst_Lang_Constructor_Exp_lam = "Lang.Constructor.Exp_lam",
    cst_Lang_Constructor_Exp_app = "Lang.Constructor.Exp_app",
    cst_Lang_Constructor_Exp_plus = "Lang.Constructor.Exp_plus",
    cst_Lang_Constructor_Exp_times = "Lang.Constructor.Exp_times",
    cst_Lang_Constructor_Exp_nil = "Lang.Constructor.Exp_nil",
    cst_Lang_Constructor_Exp_cons = "Lang.Constructor.Exp_cons",
    cst_Lang_Constructor_Exp_case = "Lang.Constructor.Exp_case",
    cst_Lang_Constructor_Typ_num = "Lang.Constructor.Typ_num",
    cst_Lang_Constructor_Typ_arrow = "Lang.Constructor.Typ_arrow",
    cst_Lang_Constructor_Typ_list = "Lang.Constructor.Typ_list",
    _f_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, [11, cst_2, 0], cst_2]],
         [11, "Lang.Constructor.Exp_var", [17, [0, cst$21, 1, 0], 0]]]],
       "(@[<2>Lang.Constructor.Exp_var@ "],
    _g_ = [0, [3, 0, 0], cst_S],
    _h_ = [0, [17, 0, [12, 41, 0]], cst$22],
    _i_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, [11, cst_2, 0], cst_2]],
         [11, "Lang.Constructor.Exp_num", [17, [0, cst$21, 1, 0], 0]]]],
       "(@[<2>Lang.Constructor.Exp_num@ "],
    _j_ = [0, [4, 0, 0, 0, 0], "%d"],
    _k_ = [0, [17, 0, [12, 41, 0]], cst$22],
    _l_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, [11, cst_2, 0], cst_2]],
         [11, "Lang.Constructor.Pat_var", [17, [0, cst$21, 1, 0], 0]]]],
       "(@[<2>Lang.Constructor.Pat_var@ "],
    _m_ = [0, [3, 0, 0], cst_S],
    _n_ = [0, [17, 0, [12, 41, 0]], cst$22],
    _o_ = [0, [15, 0], cst_a],
    cst_root = cst_root$1,
    cst_lam = "lam",
    cst_app = "app",
    cst_plus = "plus",
    cst_times = "times",
    cst_nil = cst_nil$1,
    cst_cons = "cons",
    cst_case = cst_case$1,
    cst_num = "num",
    cst_arrow = "arrow",
    cst_list = cst_list$1,
    cst_var = cst_var$1,
    cst_num$0 = "num(",
    cst_var$0 = cst_var$1,
    _p_ = [0, cst_Root_root],
    _q_ = [0, cst_Exp_lam],
    _r_ = [0, cst_Exp_app],
    _s_ = [0, cst_Exp_plus],
    _t_ = [0, cst_Exp_times],
    _u_ = [0, cst_Exp_nil],
    _v_ = [0, cst_Exp_cons],
    _w_ = [0, cst_Exp_case],
    _x_ = [0, cst_Typ_num],
    _y_ = [0, cst_Typ_arrow],
    _z_ = [0, cst_Typ_list],
    _A_ = [0, cst_Exp_var],
    _B_ = [0, cst_Exp_num],
    _C_ = [0, cst_Pat_var],
    cst_Lang_Sort_Root = "Lang.Sort.Root",
    cst_Lang_Sort_Exp = "Lang.Sort.Exp",
    cst_Lang_Sort_Pat = "Lang.Sort.Pat",
    cst_Lang_Sort_Typ = "Lang.Sort.Typ",
    _a_ = [0, [15, 0], cst_a],
    _b_ = [0, "Root"],
    _c_ = [0, "Exp"],
    _d_ = [0, "Pat"],
    _e_ = [0, "Typ"],
    cst_grvcore = cst_grvcore$0;
   function pp(fmt, param){
    switch(param){
      case 0:
       return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Sort_Root);
      case 1:
       return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Sort_Exp);
      case 2:
       return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Sort_Pat);
      default: return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Sort_Typ);
    }
   }
   function show(x){return caml_call3(Stdlib_Format[139], _a_, pp, x);}
   function equal(lhs, rhs){
    switch(lhs){
      case 0:
       if(! rhs) return 1; break;
      case 1:
       if(1 === rhs) return 1; break;
      case 2:
       if(2 === rhs) return 1; break;
      default: if(3 <= rhs) return 1;
    }
    return 0;
   }
   function compare(lhs, rhs){
    switch(lhs){
      case 0:
       if(! rhs) return 0; break;
      case 1:
       if(1 === rhs) return 0; break;
      case 2:
       if(2 === rhs) return 0; break;
      default: if(3 <= rhs) return 0;
    }
    function to_int(param){
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       default: return 3;
     }
    }
    var _co_ = to_int(rhs);
    return caml_int_compare(to_int(lhs), _co_);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _b_;
      case 1:
       return _c_;
      case 2:
       return _d_;
      default: return _e_;
    }
   }
   var Sort = [0, pp, show, equal, compare, sexp_of_t];
   function pp$0(fmt, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Root_root);
       case 1:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_lam);
       case 2:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_app);
       case 3:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_plus);
       case 4:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_times);
       case 5:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_nil);
       case 6:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_cons);
       case 7:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Exp_case);
       case 8:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Typ_num);
       case 9:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Typ_arrow);
       default:
        return caml_call2
                (Stdlib_Format[13], fmt, cst_Lang_Constructor_Typ_list);
     }
    switch(param[0]){
      case 0:
       var a0 = param[1];
       caml_call2(Stdlib_Format[135], fmt, _f_);
       caml_call1(caml_call2(Stdlib_Format[135], fmt, _g_), a0);
       return caml_call2(Stdlib_Format[135], fmt, _h_);
      case 1:
       var a0$0 = param[1];
       caml_call2(Stdlib_Format[135], fmt, _i_);
       caml_call1(caml_call2(Stdlib_Format[135], fmt, _j_), a0$0);
       return caml_call2(Stdlib_Format[135], fmt, _k_);
      default:
       var a0$1 = param[1];
       caml_call2(Stdlib_Format[135], fmt, _l_);
       caml_call1(caml_call2(Stdlib_Format[135], fmt, _m_), a0$1);
       return caml_call2(Stdlib_Format[135], fmt, _n_);
    }
   }
   function show$0(x){return caml_call3(Stdlib_Format[139], _o_, pp$0, x);}
   function equal$0(lhs, rhs){
    if(typeof lhs === "number")
     switch(lhs){
       case 0:
        if(typeof rhs === "number" && ! rhs) return 1; break;
       case 1:
        if(typeof rhs === "number" && 1 === rhs) return 1; break;
       case 2:
        if(typeof rhs === "number" && 2 === rhs) return 1; break;
       case 3:
        if(typeof rhs === "number" && 3 === rhs) return 1; break;
       case 4:
        if(typeof rhs === "number" && 4 === rhs) return 1; break;
       case 5:
        if(typeof rhs === "number" && 5 === rhs) return 1; break;
       case 6:
        if(typeof rhs === "number" && 6 === rhs) return 1; break;
       case 7:
        if(typeof rhs === "number" && 7 === rhs) return 1; break;
       case 8:
        if(typeof rhs === "number" && 8 === rhs) return 1; break;
       case 9:
        if(typeof rhs === "number" && 9 === rhs) return 1; break;
       default: if(typeof rhs === "number" && 10 <= rhs) return 1;
     }
    else
     switch(lhs[0]){
       case 0:
        if(typeof rhs !== "number" && 0 === rhs[0]){
         var rhs0 = rhs[1], lhs0 = lhs[1];
         return caml_string_equal(lhs0, rhs0);
        }
        break;
       case 1:
        if(typeof rhs !== "number" && 1 === rhs[0]){
         var rhs0$0 = rhs[1], lhs0$0 = lhs[1];
         return lhs0$0 === rhs0$0 ? 1 : 0;
        }
        break;
       default:
        if(typeof rhs !== "number" && 2 === rhs[0]){
         var rhs0$1 = rhs[1], lhs0$1 = lhs[1];
         return caml_string_equal(lhs0$1, rhs0$1);
        }
     }
    return 0;
   }
   var compare$0 = function _cn_(_cl_, _cm_){return _cn_.fun(_cl_, _cm_);};
   runtime.caml_update_dummy
    (compare$0,
     function(lhs, rhs){
      if(typeof lhs === "number")
       switch(lhs){
         case 0:
          if(typeof rhs === "number" && ! rhs) return 0; break;
         case 1:
          if(typeof rhs === "number" && 1 === rhs) return 0; break;
         case 2:
          if(typeof rhs === "number" && 2 === rhs) return 0; break;
         case 3:
          if(typeof rhs === "number" && 3 === rhs) return 0; break;
         case 4:
          if(typeof rhs === "number" && 4 === rhs) return 0; break;
         case 5:
          if(typeof rhs === "number" && 5 === rhs) return 0; break;
         case 6:
          if(typeof rhs === "number" && 6 === rhs) return 0; break;
         case 7:
          if(typeof rhs === "number" && 7 === rhs) return 0; break;
         case 8:
          if(typeof rhs === "number" && 8 === rhs) return 0; break;
         case 9:
          if(typeof rhs === "number" && 9 === rhs) return 0; break;
         default: if(typeof rhs === "number" && 10 <= rhs) return 0;
       }
      else
       switch(lhs[0]){
         case 0:
          if(typeof rhs !== "number" && 0 === rhs[0]){
           var rhs0 = rhs[1], lhs0 = lhs[1];
           return caml_string_compare(lhs0, rhs0);
          }
          break;
         case 1:
          if(typeof rhs !== "number" && 1 === rhs[0]){
           var rhs0$0 = rhs[1], lhs0$0 = lhs[1];
           return caml_int_compare(lhs0$0, rhs0$0);
          }
          break;
         default:
          if(typeof rhs !== "number" && 2 === rhs[0]){
           var rhs0$1 = rhs[1], lhs0$1 = lhs[1];
           return caml_string_compare(lhs0$1, rhs0$1);
          }
       }
      function to_int(param){
       if(typeof param === "number")
        switch(param){
          case 0:
           return 0;
          case 1:
           return 2;
          case 2:
           return 3;
          case 3:
           return 5;
          case 4:
           return 6;
          case 5:
           return 7;
          case 6:
           return 8;
          case 7:
           return 9;
          case 8:
           return 11;
          case 9:
           return 12;
          default: return 13;
        }
       switch(param[0]){case 0: return 1;case 1: return 4;default: return 10;
       }
      }
      var _ck_ = to_int(rhs);
      return caml_int_compare(to_int(lhs), _ck_);
     });
   function t_of_sexp(sexp_005){
    a:
    {
     if(0 === sexp_005[0]){
      var _cb_ = sexp_005[1], _cc_ = caml_string_compare(_cb_, cst_exp_app);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            h:
            {
             i:
             {
              j:
              {
               k:
               {
                l:
                {
                 m:
                 {
                  n:
                  {
                   if(0 <= _cc_){
                    if(0 >= _cc_) break h;
                    var _cd_ = caml_string_compare(_cb_, cst_exp_times);
                    if(0 > _cd_){
                     if(! caml_string_notequal(_cb_, cst_exp_case)) break g;
                     if(! caml_string_notequal(_cb_, cst_exp_cons)) break f;
                     if(! caml_string_notequal(_cb_, cst_exp_lam)) break e;
                     if(! caml_string_notequal(_cb_, cst_exp_nil)) break d;
                     if(! caml_string_notequal(_cb_, cst_exp_num)) break c;
                     if(caml_string_notequal(_cb_, cst_exp_plus)) break a;
                     break b;
                    }
                    if(0 < _cd_){
                     if(! caml_string_notequal(_cb_, cst_exp_var)) break n;
                     if(! caml_string_notequal(_cb_, cst_pat_var)) break m;
                     if(! caml_string_notequal(_cb_, cst_root_root)) break l;
                     if(! caml_string_notequal(_cb_, cst_typ_arrow)) break k;
                     if(! caml_string_notequal(_cb_, cst_typ_list)) break j;
                     if(caml_string_notequal(_cb_, cst_typ_num)) break a;
                     break i;
                    }
                   }
                   else{
                    var _ce_ = caml_string_compare(_cb_, cst_Exp_times);
                    if(0 > _ce_){
                     if(! caml_string_notequal(_cb_, cst_Exp_app)) break h;
                     if(! caml_string_notequal(_cb_, cst_Exp_case)) break g;
                     if(! caml_string_notequal(_cb_, cst_Exp_cons)) break f;
                     if(! caml_string_notequal(_cb_, cst_Exp_lam)) break e;
                     if(! caml_string_notequal(_cb_, cst_Exp_nil)) break d;
                     if(! caml_string_notequal(_cb_, cst_Exp_num)) break c;
                     if(caml_string_notequal(_cb_, cst_Exp_plus)) break a;
                     break b;
                    }
                    if(0 < _ce_){
                     if(! caml_string_notequal(_cb_, cst_Exp_var)) break n;
                     if(! caml_string_notequal(_cb_, cst_Pat_var)) break m;
                     if(! caml_string_notequal(_cb_, cst_Root_root)) break l;
                     if(! caml_string_notequal(_cb_, cst_Typ_arrow)) break k;
                     if(! caml_string_notequal(_cb_, cst_Typ_list)) break j;
                     if(caml_string_notequal(_cb_, cst_Typ_num)) break a;
                     break i;
                    }
                   }
                   return 4;
                  }
                  return caml_call2
                          (Sexplib0_Sexp_conv_error[5], error_source_003, sexp_005);
                 }
                 return caml_call2
                         (Sexplib0_Sexp_conv_error[5], error_source_003, sexp_005);
                }
                return 0;
               }
               return 9;
              }
              return 10;
             }
             return 8;
            }
            return 2;
           }
           return 7;
          }
          return 6;
         }
         return 1;
        }
        return 5;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_003, sexp_005);
      }
      return 3;
     }
     var _cf_ = sexp_005[1];
     if(! _cf_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
     var _cg_ = _cf_[1];
     if(0 !== _cg_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_005);
     var tag_006 = _cg_[1], _ch_ = caml_string_compare(tag_006, cst_exp_app);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             j:
             {
              k:
              {
               l:
               {
                m:
                {
                 n:
                 {
                  if(0 <= _ch_){
                   if(0 >= _ch_) break h;
                   var _ci_ = caml_string_compare(tag_006, cst_exp_times);
                   if(0 > _ci_){
                    if(! caml_string_notequal(tag_006, cst_exp_case)) break g;
                    if(! caml_string_notequal(tag_006, cst_exp_cons)) break f;
                    if(! caml_string_notequal(tag_006, cst_exp_lam)) break e;
                    if(! caml_string_notequal(tag_006, cst_exp_nil)) break d;
                    if(! caml_string_notequal(tag_006, cst_exp_num)) break c;
                    if(caml_string_notequal(tag_006, cst_exp_plus)) break a;
                    break b;
                   }
                   if(0 < _ci_){
                    if(! caml_string_notequal(tag_006, cst_exp_var)) break n;
                    if(! caml_string_notequal(tag_006, cst_pat_var)) break m;
                    if(! caml_string_notequal(tag_006, cst_root_root)) break l;
                    if(! caml_string_notequal(tag_006, cst_typ_arrow)) break k;
                    if(! caml_string_notequal(tag_006, cst_typ_list)) break j;
                    if(caml_string_notequal(tag_006, cst_typ_num)) break a;
                    break i;
                   }
                  }
                  else{
                   var _cj_ = caml_string_compare(tag_006, cst_Exp_times);
                   if(0 > _cj_){
                    if(! caml_string_notequal(tag_006, cst_Exp_app)) break h;
                    if(! caml_string_notequal(tag_006, cst_Exp_case)) break g;
                    if(! caml_string_notequal(tag_006, cst_Exp_cons)) break f;
                    if(! caml_string_notequal(tag_006, cst_Exp_lam)) break e;
                    if(! caml_string_notequal(tag_006, cst_Exp_nil)) break d;
                    if(! caml_string_notequal(tag_006, cst_Exp_num)) break c;
                    if(caml_string_notequal(tag_006, cst_Exp_plus)) break a;
                    break b;
                   }
                   if(0 < _cj_){
                    if(! caml_string_notequal(tag_006, cst_Exp_var)) break n;
                    if(! caml_string_notequal(tag_006, cst_Pat_var)) break m;
                    if(! caml_string_notequal(tag_006, cst_Root_root)) break l;
                    if(! caml_string_notequal(tag_006, cst_Typ_arrow)) break k;
                    if(! caml_string_notequal(tag_006, cst_Typ_list)) break j;
                    if(caml_string_notequal(tag_006, cst_Typ_num)) break a;
                    break i;
                   }
                  }
                  return caml_call2
                          (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
                 }
                 var sexp_args_007 = _cf_[2];
                 if(sexp_args_007 && ! sexp_args_007[2]){
                  var
                   arg0_008 = sexp_args_007[1],
                   res0_009 = caml_call1(Sexplib0_Sexp_conv[31], arg0_008);
                  return [0, res0_009];
                 }
                 return caml_call3
                         (Sexplib0_Sexp_conv_error[4],
                          error_source_003,
                          tag_006,
                          sexp_005);
                }
                var sexp_args_017 = _cf_[2];
                if(sexp_args_017 && ! sexp_args_017[2]){
                 var
                  arg0_018 = sexp_args_017[1],
                  res0_019 = caml_call1(Sexplib0_Sexp_conv[31], arg0_018);
                 return [2, res0_019];
                }
                return caml_call3
                        (Sexplib0_Sexp_conv_error[4],
                         error_source_003,
                         tag_006,
                         sexp_005);
               }
               return caml_call2
                       (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
              }
              return caml_call2
                      (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
      }
      var sexp_args_012 = _cf_[2];
      if(sexp_args_012 && ! sexp_args_012[2]){
       var
        arg0_013 = sexp_args_012[1],
        res0_014 = caml_call1(Sexplib0_Sexp_conv[34], arg0_013);
       return [1, res0_014];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_003,
               tag_006,
               sexp_005);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_005);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_005);
   }
   function sexp_of_t$0(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return _p_;
       case 1:
        return _q_;
       case 2:
        return _r_;
       case 3:
        return _s_;
       case 4:
        return _t_;
       case 5:
        return _u_;
       case 6:
        return _v_;
       case 7:
        return _w_;
       case 8:
        return _x_;
       case 9:
        return _y_;
       default: return _z_;
     }
    switch(param[0]){
      case 0:
       var
        arg0_020 = param[1],
        res0_021 = caml_call1(Sexplib0_Sexp_conv[7], arg0_020);
       return [1, [0, _A_, [0, res0_021, 0]]];
      case 1:
       var
        arg0_022 = param[1],
        res0_023 = caml_call1(Sexplib0_Sexp_conv[10], arg0_022);
       return [1, [0, _B_, [0, res0_023, 0]]];
      default:
       var
        arg0_024 = param[1],
        res0_025 = caml_call1(Sexplib0_Sexp_conv[7], arg0_024);
       return [1, [0, _C_, [0, res0_025, 0]]];
    }
   }
   function sort_of(c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 1;
       case 3:
        return 1;
       case 4:
        return 1;
       case 5:
        return 1;
       case 6:
        return 1;
       case 7:
        return 1;
       case 8:
        return 3;
       case 9:
        return 3;
       default: return 3;
     }
    switch(c[0]){case 0: return 1;case 1: return 1;default: return 2;
    }
   }
   function graphviz_label(c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return cst_root;
       case 1:
        return cst_lam;
       case 2:
        return cst_app;
       case 3:
        return cst_plus;
       case 4:
        return cst_times;
       case 5:
        return cst_nil;
       case 6:
        return cst_cons;
       case 7:
        return cst_case;
       case 8:
        return cst_num;
       case 9:
        return cst_arrow;
       default: return cst_list;
     }
    switch(c[0]){
      case 0:
       var arg0 = c[1], _b9_ = caml_call2(Stdlib[28], arg0, cst$0);
       return caml_call2(Stdlib[28], cst_var, _b9_);
      case 1:
       var
        arg0$0 = c[1],
        _b__ = caml_call1(Stdlib_Int[12], arg0$0),
        _b$_ = caml_call2(Stdlib[28], _b__, cst$1);
       return caml_call2(Stdlib[28], cst_num$0, _b$_);
      default:
       var arg0$1 = c[1], _ca_ = caml_call2(Stdlib[28], arg0$1, cst$2);
       return caml_call2(Stdlib[28], cst_var$0, _ca_);
    }
   }
   var
    Constructor =
      [0,
       pp$0,
       show$0,
       equal$0,
       compare$0,
       t_of_sexp,
       sexp_of_t$0,
       sort_of,
       graphviz_label];
   function pp$1(fmt, param){
    switch(param){
      case 0:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Root_root_ro);
      case 1:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_lam_para);
      case 2:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_lam_para$0);
      case 3:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_lam_body);
      case 4:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_app_fun);
      case 5:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_app_arg);
      case 6:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_plus_lef);
      case 7:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_plus_rig);
      case 8:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_times_le);
      case 9:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_times_ri);
      case 10:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_cons_hea);
      case 11:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_cons_tai);
      case 12:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_scr);
      case 13:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_nil);
      case 14:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_hea);
      case 15:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_tai);
      case 16:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_con);
      case 17:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Exp_case_typ);
      case 18:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Typ_arrow_ar);
      case 19:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Typ_arrow_re);
      default:
       return caml_call2
               (Stdlib_Format[13], fmt, cst_Lang_Position_Typ_list_con);
    }
   }
   function show$1(x){return caml_call3(Stdlib_Format[139], _D_, pp$1, x);}
   function equal$1(lhs, rhs){
    switch(lhs){
      case 0:
       if(! rhs) return 1; break;
      case 1:
       if(1 === rhs) return 1; break;
      case 2:
       if(2 === rhs) return 1; break;
      case 3:
       if(3 === rhs) return 1; break;
      case 4:
       if(4 === rhs) return 1; break;
      case 5:
       if(5 === rhs) return 1; break;
      case 6:
       if(6 === rhs) return 1; break;
      case 7:
       if(7 === rhs) return 1; break;
      case 8:
       if(8 === rhs) return 1; break;
      case 9:
       if(9 === rhs) return 1; break;
      case 10:
       if(10 === rhs) return 1; break;
      case 11:
       if(11 === rhs) return 1; break;
      case 12:
       if(12 === rhs) return 1; break;
      case 13:
       if(13 === rhs) return 1; break;
      case 14:
       if(14 === rhs) return 1; break;
      case 15:
       if(15 === rhs) return 1; break;
      case 16:
       if(16 === rhs) return 1; break;
      case 17:
       if(17 === rhs) return 1; break;
      case 18:
       if(18 === rhs) return 1; break;
      case 19:
       if(19 === rhs) return 1; break;
      default: if(20 <= rhs) return 1;
    }
    return 0;
   }
   function compare$1(lhs, rhs){
    switch(lhs){
      case 0:
       if(! rhs) return 0; break;
      case 1:
       if(1 === rhs) return 0; break;
      case 2:
       if(2 === rhs) return 0; break;
      case 3:
       if(3 === rhs) return 0; break;
      case 4:
       if(4 === rhs) return 0; break;
      case 5:
       if(5 === rhs) return 0; break;
      case 6:
       if(6 === rhs) return 0; break;
      case 7:
       if(7 === rhs) return 0; break;
      case 8:
       if(8 === rhs) return 0; break;
      case 9:
       if(9 === rhs) return 0; break;
      case 10:
       if(10 === rhs) return 0; break;
      case 11:
       if(11 === rhs) return 0; break;
      case 12:
       if(12 === rhs) return 0; break;
      case 13:
       if(13 === rhs) return 0; break;
      case 14:
       if(14 === rhs) return 0; break;
      case 15:
       if(15 === rhs) return 0; break;
      case 16:
       if(16 === rhs) return 0; break;
      case 17:
       if(17 === rhs) return 0; break;
      case 18:
       if(18 === rhs) return 0; break;
      case 19:
       if(19 === rhs) return 0; break;
      default: if(20 <= rhs) return 0;
    }
    function to_int(param){
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       case 9:
        return 9;
       case 10:
        return 10;
       case 11:
        return 11;
       case 12:
        return 12;
       case 13:
        return 13;
       case 14:
        return 14;
       case 15:
        return 15;
       case 16:
        return 16;
       case 17:
        return 17;
       case 18:
        return 18;
       case 19:
        return 19;
       default: return 20;
     }
    }
    var _b8_ = to_int(rhs);
    return caml_int_compare(to_int(lhs), _b8_);
   }
   function t_of_sexp$0(sexp_029){
    a:
    {
     if(0 === sexp_029[0]){
      var
       _bS_ = sexp_029[1],
       _bT_ = caml_string_compare(_bS_, cst_exp_app_arg);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            h:
            {
             i:
             {
              j:
              {
               k:
               {
                l:
                {
                 m:
                 {
                  n:
                  {
                   o:
                   {
                    p:
                    {
                     q:
                     {
                      r:
                      {
                       s:
                       {
                        t:
                        {
                         u:
                         {
                          if(0 <= _bT_){
                           if(0 >= _bT_) break f;
                           var _bU_ = caml_string_compare(_bS_, cst_exp_lam_param);
                           if(0 <= _bU_){
                            if(0 >= _bU_) break p;
                            if(! caml_string_notequal(_bS_, cst_exp_lam_param_type))
                             break o;
                            if(! caml_string_notequal(_bS_, cst_exp_plus_left)) break n;
                            if(! caml_string_notequal(_bS_, cst_exp_plus_right))
                             break m;
                            if(! caml_string_notequal(_bS_, cst_exp_times_left))
                             break l;
                            if(! caml_string_notequal(_bS_, cst_exp_times_right))
                             break u;
                            if(! caml_string_notequal(_bS_, cst_root_root_root))
                             break t;
                            if(! caml_string_notequal(_bS_, cst_typ_arrow_arg)) break s;
                            if(! caml_string_notequal(_bS_, cst_typ_arrow_result))
                             break r;
                            if(caml_string_notequal(_bS_, cst_typ_list_content))
                             break a;
                            break q;
                           }
                           var _bV_ = caml_string_compare(_bS_, cst_exp_case_tail_pat);
                           if(0 > _bV_){
                            if(! caml_string_notequal(_bS_, cst_exp_app_fun)) break e;
                            if(! caml_string_notequal(_bS_, cst_exp_case_cons_body))
                             break d;
                            if(! caml_string_notequal(_bS_, cst_exp_case_head_pat))
                             break c;
                            if(! caml_string_notequal(_bS_, cst_exp_case_nil_body))
                             break b;
                            if(caml_string_notequal(_bS_, cst_exp_case_scrut)) break a;
                            break k;
                           }
                           if(0 >= _bV_) break j;
                           if(! caml_string_notequal(_bS_, cst_exp_case_type)) break i;
                           if(! caml_string_notequal(_bS_, cst_exp_cons_head)) break h;
                           if(! caml_string_notequal(_bS_, cst_exp_cons_tail)) break g;
                           if(caml_string_notequal(_bS_, cst_exp_lam_body)) break a;
                          }
                          else{
                           var _bW_ = caml_string_compare(_bS_, cst_Exp_lam_body);
                           if(0 > _bW_){
                            var _bY_ = caml_string_compare(_bS_, cst_Exp_case_scrut);
                            if(0 <= _bY_){
                             if(0 >= _bY_) break k;
                             if(! caml_string_notequal(_bS_, cst_Exp_case_tail_pat))
                              break j;
                             if(! caml_string_notequal(_bS_, cst_Exp_case_type)) break i;
                             if(! caml_string_notequal(_bS_, cst_Exp_cons_head)) break h;
                             if(caml_string_notequal(_bS_, cst_Exp_cons_tail)) break a;
                             break g;
                            }
                            if(! caml_string_notequal(_bS_, cst_Exp_app_arg)) break f;
                            if(! caml_string_notequal(_bS_, cst_Exp_app_fun)) break e;
                            if(! caml_string_notequal(_bS_, cst_Exp_case_cons_body))
                             break d;
                            if(! caml_string_notequal(_bS_, cst_Exp_case_head_pat))
                             break c;
                            if(caml_string_notequal(_bS_, cst_Exp_case_nil_body))
                             break a;
                            break b;
                           }
                           if(0 < _bW_){
                            var _bX_ = caml_string_compare(_bS_, cst_Exp_times_right);
                            if(0 <= _bX_){
                             if(0 >= _bX_) break u;
                             if(! caml_string_notequal(_bS_, cst_Root_root_root))
                              break t;
                             if(! caml_string_notequal(_bS_, cst_Typ_arrow_arg)) break s;
                             if(! caml_string_notequal(_bS_, cst_Typ_arrow_result))
                              break r;
                             if(caml_string_notequal(_bS_, cst_Typ_list_content))
                              break a;
                             break q;
                            }
                            if(! caml_string_notequal(_bS_, cst_Exp_lam_param)) break p;
                            if(! caml_string_notequal(_bS_, cst_Exp_lam_param_type))
                             break o;
                            if(! caml_string_notequal(_bS_, cst_Exp_plus_left)) break n;
                            if(! caml_string_notequal(_bS_, cst_Exp_plus_right))
                             break m;
                            if(caml_string_notequal(_bS_, cst_Exp_times_left)) break a;
                            break l;
                           }
                          }
                          return 3;
                         }
                         return 9;
                        }
                        return 0;
                       }
                       return 18;
                      }
                      return 19;
                     }
                     return 20;
                    }
                    return 1;
                   }
                   return 2;
                  }
                  return 6;
                 }
                 return 7;
                }
                return 8;
               }
               return 12;
              }
              return 15;
             }
             return 17;
            }
            return 10;
           }
           return 11;
          }
          return 5;
         }
         return 4;
        }
        return 16;
       }
       return 14;
      }
      return 13;
     }
     var _bZ_ = sexp_029[1];
     if(! _bZ_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_028, sexp_029);
     var _b0_ = _bZ_[1];
     if(0 !== _b0_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_028, sexp_029);
     var _b1_ = _b0_[1], _b2_ = caml_string_compare(_b1_, cst_exp_app_arg);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             j:
             {
              k:
              {
               l:
               {
                m:
                {
                 n:
                 {
                  o:
                  {
                   p:
                   {
                    q:
                    {
                     r:
                     {
                      s:
                      {
                       t:
                       {
                        u:
                        {
                         if(0 <= _b2_){
                          if(0 >= _b2_) break f;
                          var _b3_ = caml_string_compare(_b1_, cst_exp_lam_param);
                          if(0 <= _b3_){
                           if(0 >= _b3_) break p;
                           if(! caml_string_notequal(_b1_, cst_exp_lam_param_type))
                            break o;
                           if(! caml_string_notequal(_b1_, cst_exp_plus_left)) break n;
                           if(! caml_string_notequal(_b1_, cst_exp_plus_right))
                            break m;
                           if(! caml_string_notequal(_b1_, cst_exp_times_left))
                            break l;
                           if(! caml_string_notequal(_b1_, cst_exp_times_right))
                            break u;
                           if(! caml_string_notequal(_b1_, cst_root_root_root))
                            break t;
                           if(! caml_string_notequal(_b1_, cst_typ_arrow_arg)) break s;
                           if(! caml_string_notequal(_b1_, cst_typ_arrow_result))
                            break r;
                           if(caml_string_notequal(_b1_, cst_typ_list_content))
                            break a;
                           break q;
                          }
                          var _b4_ = caml_string_compare(_b1_, cst_exp_case_tail_pat);
                          if(0 > _b4_){
                           if(! caml_string_notequal(_b1_, cst_exp_app_fun)) break e;
                           if(! caml_string_notequal(_b1_, cst_exp_case_cons_body))
                            break d;
                           if(! caml_string_notequal(_b1_, cst_exp_case_head_pat))
                            break c;
                           if(! caml_string_notequal(_b1_, cst_exp_case_nil_body))
                            break b;
                           if(caml_string_notequal(_b1_, cst_exp_case_scrut)) break a;
                           break k;
                          }
                          if(0 >= _b4_) break j;
                          if(! caml_string_notequal(_b1_, cst_exp_case_type)) break i;
                          if(! caml_string_notequal(_b1_, cst_exp_cons_head)) break h;
                          if(! caml_string_notequal(_b1_, cst_exp_cons_tail)) break g;
                          if(caml_string_notequal(_b1_, cst_exp_lam_body)) break a;
                         }
                         else{
                          var _b5_ = caml_string_compare(_b1_, cst_Exp_lam_body);
                          if(0 > _b5_){
                           var _b7_ = caml_string_compare(_b1_, cst_Exp_case_scrut);
                           if(0 <= _b7_){
                            if(0 >= _b7_) break k;
                            if(! caml_string_notequal(_b1_, cst_Exp_case_tail_pat))
                             break j;
                            if(! caml_string_notequal(_b1_, cst_Exp_case_type)) break i;
                            if(! caml_string_notequal(_b1_, cst_Exp_cons_head)) break h;
                            if(caml_string_notequal(_b1_, cst_Exp_cons_tail)) break a;
                            break g;
                           }
                           if(! caml_string_notequal(_b1_, cst_Exp_app_arg)) break f;
                           if(! caml_string_notequal(_b1_, cst_Exp_app_fun)) break e;
                           if(! caml_string_notequal(_b1_, cst_Exp_case_cons_body))
                            break d;
                           if(! caml_string_notequal(_b1_, cst_Exp_case_head_pat))
                            break c;
                           if(caml_string_notequal(_b1_, cst_Exp_case_nil_body))
                            break a;
                           break b;
                          }
                          if(0 < _b5_){
                           var _b6_ = caml_string_compare(_b1_, cst_Exp_times_right);
                           if(0 <= _b6_){
                            if(0 >= _b6_) break u;
                            if(! caml_string_notequal(_b1_, cst_Root_root_root))
                             break t;
                            if(! caml_string_notequal(_b1_, cst_Typ_arrow_arg)) break s;
                            if(! caml_string_notequal(_b1_, cst_Typ_arrow_result))
                             break r;
                            if(caml_string_notequal(_b1_, cst_Typ_list_content))
                             break a;
                            break q;
                           }
                           if(! caml_string_notequal(_b1_, cst_Exp_lam_param)) break p;
                           if(! caml_string_notequal(_b1_, cst_Exp_lam_param_type))
                            break o;
                           if(! caml_string_notequal(_b1_, cst_Exp_plus_left)) break n;
                           if(! caml_string_notequal(_b1_, cst_Exp_plus_right))
                            break m;
                           if(caml_string_notequal(_b1_, cst_Exp_times_left)) break a;
                           break l;
                          }
                         }
                         return caml_call2
                                 (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                        }
                        return caml_call2
                                (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                       }
                       return caml_call2
                               (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                      }
                      return caml_call2
                              (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                     }
                     return caml_call2
                             (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                    }
                    return caml_call2
                            (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                   }
                   return caml_call2
                           (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                  }
                  return caml_call2
                          (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                 }
                 return caml_call2
                         (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
                }
                return caml_call2
                        (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
               }
               return caml_call2
                       (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
              }
              return caml_call2
                      (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_028, sexp_029);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_028, sexp_029);
   }
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _E_;
      case 1:
       return _F_;
      case 2:
       return _G_;
      case 3:
       return _H_;
      case 4:
       return _I_;
      case 5:
       return _J_;
      case 6:
       return _K_;
      case 7:
       return _L_;
      case 8:
       return _M_;
      case 9:
       return _N_;
      case 10:
       return _O_;
      case 11:
       return _P_;
      case 12:
       return _Q_;
      case 13:
       return _R_;
      case 14:
       return _S_;
      case 15:
       return _T_;
      case 16:
       return _U_;
      case 17:
       return _V_;
      case 18:
       return _W_;
      case 19:
       return _X_;
      default: return _Y_;
    }
   }
   function short_name(i){
    switch(i){
      case 0:
       return cst_root$0;
      case 1:
       return cst_param;
      case 2:
       return cst_param_type;
      case 3:
       return cst_body;
      case 4:
       return cst_fun;
      case 5:
       return cst_arg;
      case 6:
       return cst_left;
      case 7:
       return cst_right;
      case 8:
       return cst_left$0;
      case 9:
       return cst_right$0;
      case 10:
       return cst_head;
      case 11:
       return cst_tail;
      case 12:
       return cst_scrut;
      case 13:
       return cst_nil_body;
      case 14:
       return cst_head_pat;
      case 15:
       return cst_tail_pat;
      case 16:
       return cst_cons_body;
      case 17:
       return cst_type;
      case 18:
       return cst_arg$0;
      case 19:
       return cst_result;
      default: return cst_content;
    }
   }
   function parent_constructor(i){
    switch(i){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 3;
      case 7:
       return 3;
      case 8:
       return 4;
      case 9:
       return 4;
      case 10:
       return 6;
      case 11:
       return 6;
      case 12:
       return 7;
      case 13:
       return 7;
      case 14:
       return 7;
      case 15:
       return 7;
      case 16:
       return 7;
      case 17:
       return 7;
      case 18:
       return 9;
      case 19:
       return 9;
      default: return 10;
    }
   }
   function child_positions(c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return _Z_;
       case 1:
        return ___;
       case 2:
        return _$_;
       case 3:
        return _aa_;
       case 4:
        return _ab_;
       case 5:
        return 0;
       case 6:
        return _ac_;
       case 7:
        return _ad_;
       case 8:
        return 0;
       case 9:
        return _ae_;
       default: return _af_;
     }
    switch(c[0]){case 0: return 0;case 1: return 0;default: return 0;
    }
   }
   function child_sort(i){
    switch(i){
      case 0:
       return 1;
      case 1:
       return 2;
      case 2:
       return 3;
      case 3:
       return 1;
      case 4:
       return 1;
      case 5:
       return 1;
      case 6:
       return 1;
      case 7:
       return 1;
      case 8:
       return 1;
      case 9:
       return 1;
      case 10:
       return 1;
      case 11:
       return 1;
      case 12:
       return 1;
      case 13:
       return 1;
      case 14:
       return 2;
      case 15:
       return 2;
      case 16:
       return 1;
      case 17:
       return 3;
      case 18:
       return 3;
      case 19:
       return 3;
      default: return 3;
    }
   }
   function default_position(c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return _ag_;
       case 1:
        return _ah_;
       case 2:
        return _ai_;
       case 3:
        return _aj_;
       case 4:
        return _ak_;
       case 5:
        return 0;
       case 6:
        return _al_;
       case 7:
        return _am_;
       case 8:
        return 0;
       case 9:
        return _an_;
       default: return _ao_;
     }
    switch(c[0]){case 0: return 0;case 1: return 0;default: return 0;
    }
   }
   function down(c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return _ap_;
       case 1:
        return _aq_;
       case 2:
        return _ar_;
       case 3:
        return _as_;
       case 4:
        return _at_;
       case 5:
        return 0;
       case 6:
        return _au_;
       case 7:
        return _av_;
       case 8:
        return 0;
       case 9:
        return _aw_;
       default: return _ax_;
     }
    switch(c[0]){case 0: return 0;case 1: return 0;default: return 0;
    }
   }
   function right(i){
    switch(i){
      case 0:
       return 0;
      case 1:
       return _ay_;
      case 2:
       return _az_;
      case 3:
       return 0;
      case 4:
       return _aA_;
      case 5:
       return 0;
      case 6:
       return _aB_;
      case 7:
       return 0;
      case 8:
       return _aC_;
      case 9:
       return 0;
      case 10:
       return _aD_;
      case 11:
       return 0;
      case 12:
       return _aE_;
      case 13:
       return _aF_;
      case 14:
       return _aG_;
      case 15:
       return _aH_;
      case 16:
       return _aI_;
      case 17:
       return 0;
      case 18:
       return _aJ_;
      case 19:
       return 0;
      default: return 0;
    }
   }
   function left(i){
    switch(i){
      case 0:
       return 0;
      case 1:
       return 0;
      case 2:
       return _aK_;
      case 3:
       return _aL_;
      case 4:
       return 0;
      case 5:
       return _aM_;
      case 6:
       return 0;
      case 7:
       return _aN_;
      case 8:
       return 0;
      case 9:
       return _aO_;
      case 10:
       return 0;
      case 11:
       return _aP_;
      case 12:
       return 0;
      case 13:
       return _aQ_;
      case 14:
       return _aR_;
      case 15:
       return _aS_;
      case 16:
       return _aT_;
      case 17:
       return _aU_;
      case 18:
       return 0;
      case 19:
       return _aV_;
      default: return 0;
    }
   }
   var
    Position =
      [0,
       pp$1,
       show$1,
       equal$1,
       compare$1,
       t_of_sexp$0,
       sexp_of_t$1,
       short_name,
       parent_constructor,
       child_positions,
       child_sort,
       default_position,
       down,
       right,
       left];
   function pp_root_root(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Root_root);
   }
   function show_root_root(x){
    return caml_call3(Stdlib_Format[139], _aW_, pp_root_root, x);
   }
   function equal_root_root(lhs, rhs){return 1;}
   function compare_root_root(lhs, rhs){return 0;}
   function sexp_of_root_root(param){return _aX_;}
   function pp_exp_var(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_var);
   }
   function show_exp_var(x){
    return caml_call3(Stdlib_Format[139], _aY_, pp_exp_var, x);
   }
   function equal_exp_var(lhs, rhs){return 1;}
   function compare_exp_var(lhs, rhs){return 0;}
   function sexp_of_exp_var(param){return _aZ_;}
   function pp_exp_lam(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_lam);
   }
   function show_exp_lam(x){
    return caml_call3(Stdlib_Format[139], _a0_, pp_exp_lam, x);
   }
   function equal_exp_lam(lhs, rhs){return 1;}
   function compare_exp_lam(lhs, rhs){return 0;}
   function sexp_of_exp_lam(param){return _a1_;}
   function pp_exp_app(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_app);
   }
   function show_exp_app(x){
    return caml_call3(Stdlib_Format[139], _a2_, pp_exp_app, x);
   }
   function equal_exp_app(lhs, rhs){return 1;}
   function compare_exp_app(lhs, rhs){return 0;}
   function sexp_of_exp_app(param){return _a3_;}
   function pp_exp_num(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_num);
   }
   function show_exp_num(x){
    return caml_call3(Stdlib_Format[139], _a4_, pp_exp_num, x);
   }
   function equal_exp_num(lhs, rhs){return 1;}
   function compare_exp_num(lhs, rhs){return 0;}
   function sexp_of_exp_num(param){return _a5_;}
   function pp_exp_plus(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_plus);
   }
   function show_exp_plus(x){
    return caml_call3(Stdlib_Format[139], _a6_, pp_exp_plus, x);
   }
   function equal_exp_plus(lhs, rhs){return 1;}
   function compare_exp_plus(lhs, rhs){return 0;}
   function sexp_of_exp_plus(param){return _a7_;}
   function pp_exp_times(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_times);
   }
   function show_exp_times(x){
    return caml_call3(Stdlib_Format[139], _a8_, pp_exp_times, x);
   }
   function equal_exp_times(lhs, rhs){return 1;}
   function compare_exp_times(lhs, rhs){return 0;}
   function sexp_of_exp_times(param){return _a9_;}
   function pp_exp_nil(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_nil);
   }
   function show_exp_nil(x){
    return caml_call3(Stdlib_Format[139], _a__, pp_exp_nil, x);
   }
   function equal_exp_nil(lhs, rhs){return 1;}
   function compare_exp_nil(lhs, rhs){return 0;}
   function sexp_of_exp_nil(param){return _a$_;}
   function pp_exp_cons(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_cons);
   }
   function show_exp_cons(x){
    return caml_call3(Stdlib_Format[139], _ba_, pp_exp_cons, x);
   }
   function equal_exp_cons(lhs, rhs){return 1;}
   function compare_exp_cons(lhs, rhs){return 0;}
   function sexp_of_exp_cons(param){return _bb_;}
   function pp_exp_case(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Exp_case);
   }
   function show_exp_case(x){
    return caml_call3(Stdlib_Format[139], _bc_, pp_exp_case, x);
   }
   function equal_exp_case(lhs, rhs){return 1;}
   function compare_exp_case(lhs, rhs){return 0;}
   function sexp_of_exp_case(param){return _bd_;}
   function pp_pat_var(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Pat_var);
   }
   function show_pat_var(x){
    return caml_call3(Stdlib_Format[139], _be_, pp_pat_var, x);
   }
   function equal_pat_var(lhs, rhs){return 1;}
   function compare_pat_var(lhs, rhs){return 0;}
   function sexp_of_pat_var(param){return _bf_;}
   function pp_typ_num(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Typ_num);
   }
   function show_typ_num(x){
    return caml_call3(Stdlib_Format[139], _bg_, pp_typ_num, x);
   }
   function equal_typ_num(lhs, rhs){return 1;}
   function compare_typ_num(lhs, rhs){return 0;}
   function sexp_of_typ_num(param){return _bh_;}
   function pp_typ_arrow(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Typ_arrow);
   }
   function show_typ_arrow(x){
    return caml_call3(Stdlib_Format[139], _bi_, pp_typ_arrow, x);
   }
   function equal_typ_arrow(lhs, rhs){return 1;}
   function compare_typ_arrow(lhs, rhs){return 0;}
   function sexp_of_typ_arrow(param){return _bj_;}
   function pp_typ_list(fmt, param){
    return caml_call2(Stdlib_Format[13], fmt, cst_Lang_Gadt_Typ_list);
   }
   function show_typ_list(x){
    return caml_call3(Stdlib_Format[139], _bk_, pp_typ_list, x);
   }
   function equal_typ_list(lhs, rhs){return 1;}
   function compare_typ_list(lhs, rhs){return 0;}
   function sexp_of_typ_list(param){return _bl_;}
   var
    Gadt =
      [0,
       pp_root_root,
       show_root_root,
       equal_root_root,
       compare_root_root,
       sexp_of_root_root,
       pp_exp_var,
       show_exp_var,
       equal_exp_var,
       compare_exp_var,
       sexp_of_exp_var,
       pp_exp_lam,
       show_exp_lam,
       equal_exp_lam,
       compare_exp_lam,
       sexp_of_exp_lam,
       pp_exp_app,
       show_exp_app,
       equal_exp_app,
       compare_exp_app,
       sexp_of_exp_app,
       pp_exp_num,
       show_exp_num,
       equal_exp_num,
       compare_exp_num,
       sexp_of_exp_num,
       pp_exp_plus,
       show_exp_plus,
       equal_exp_plus,
       compare_exp_plus,
       sexp_of_exp_plus,
       pp_exp_times,
       show_exp_times,
       equal_exp_times,
       compare_exp_times,
       sexp_of_exp_times,
       pp_exp_nil,
       show_exp_nil,
       equal_exp_nil,
       compare_exp_nil,
       sexp_of_exp_nil,
       pp_exp_cons,
       show_exp_cons,
       equal_exp_cons,
       compare_exp_cons,
       sexp_of_exp_cons,
       pp_exp_case,
       show_exp_case,
       equal_exp_case,
       compare_exp_case,
       sexp_of_exp_case,
       pp_pat_var,
       show_pat_var,
       equal_pat_var,
       compare_pat_var,
       sexp_of_pat_var,
       pp_typ_num,
       show_typ_num,
       equal_typ_num,
       compare_typ_num,
       sexp_of_typ_num,
       pp_typ_arrow,
       show_typ_arrow,
       equal_typ_arrow,
       compare_typ_arrow,
       sexp_of_typ_arrow,
       pp_typ_list,
       show_typ_list,
       equal_typ_list,
       compare_typ_list,
       sexp_of_typ_list];
   function show$2(string, arg, position, c){
    if(typeof c === "number")
     switch(c){
       case 0:
        return [0, caml_call1(position, 0), 0];
       case 1:
        var
         _bm_ = [0, caml_call1(position, 3), 0],
         _bn_ = [0, caml_call1(string, cst$3), _bm_],
         _bo_ = [0, caml_call1(position, 2), _bn_],
         _bp_ = [0, caml_call1(string, cst$4), _bo_],
         _bq_ = [0, caml_call1(position, 1), _bp_];
        return [0, caml_call1(string, cst$5), _bq_];
       case 2:
        var
         _br_ = [0, caml_call1(position, 5), 0],
         _bs_ = [0, caml_call1(string, cst$6), _br_];
        return [0, caml_call1(position, 4), _bs_];
       case 3:
        var
         _bt_ = [0, caml_call1(position, 7), 0],
         _bu_ = [0, caml_call1(string, cst$7), _bt_];
        return [0, caml_call1(position, 6), _bu_];
       case 4:
        var
         _bv_ = [0, caml_call1(position, 9), 0],
         _bw_ = [0, caml_call1(string, cst$8), _bv_];
        return [0, caml_call1(position, 8), _bw_];
       case 5:
        return [0, caml_call1(string, cst_Int), 0];
       case 6:
        var
         _bx_ = [0, caml_call1(position, 11), 0],
         _by_ = [0, caml_call1(string, cst$9), _bx_];
        return [0, caml_call1(position, 10), _by_];
       case 7:
        var
         _bz_ = [0, caml_call1(position, 17), 0],
         _bA_ = [0, caml_call1(string, cst$10), _bz_],
         _bB_ = [0, caml_call1(string, cst_end), _bA_],
         _bC_ = [0, caml_call1(position, 16), _bB_],
         _bD_ = [0, caml_call1(string, cst$11), _bC_],
         _bE_ = [0, caml_call1(position, 15), _bD_],
         _bF_ = [0, caml_call1(string, cst$12), _bE_],
         _bG_ = [0, caml_call1(position, 14), _bF_],
         _bH_ = [0, caml_call1(string, cst$13), _bG_],
         _bI_ = [0, caml_call1(position, 13), _bH_],
         _bJ_ = [0, caml_call1(string, cst$14), _bI_],
         _bK_ = [0, caml_call1(string, cst_nil$0), _bJ_],
         _bL_ = [0, caml_call1(string, cst_of), _bK_],
         _bM_ = [0, caml_call1(position, 12), _bL_];
        return [0, caml_call1(string, cst_case$0), _bM_];
       case 8:
        return [0, caml_call1(string, cst_Num), 0];
       case 9:
        var
         _bN_ = [0, caml_call1(position, 19), 0],
         _bO_ = [0, caml_call1(string, cst$15), _bN_];
        return [0, caml_call1(position, 18), _bO_];
       default:
        var
         _bP_ = [0, caml_call1(string, cst$16), 0],
         _bQ_ = [0, caml_call1(position, 20), _bP_],
         _bR_ = [0, caml_call1(string, cst$17), _bQ_];
        return [0, caml_call1(string, cst_list$0), _bR_];
     }
    switch(c[0]){
      case 0:
       var arg0 = c[1]; return [0, caml_call1(arg, arg0), 0];
      case 1:
       var arg0$0 = c[1];
       return [0, caml_call1(arg, caml_call1(Stdlib_Int[12], arg0$0)), 0];
      default: var arg0$1 = c[1]; return [0, caml_call1(arg, arg0$1), 0];
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Lang = [0, Sort, Constructor, Position, Gadt, show$2];
   runtime.caml_register_global(391, Lang, "Lang");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Uuid
//# unitInfo: Requires: Assert_failure, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__Int, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_grvcore$0 = "grvcore",
    cst_id$0 = "id",
    cst_src_grvcore_util_Uuid_ml = "src/grvcore/util/Uuid.ml",
    cst_value$0 = "value",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    error_source_017 = "src/grvcore/util/Uuid.ml.wrap",
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    t_of_sexp = Sexplib0_Sexp_conv[34],
    sexp_of_t = Sexplib0_Sexp_conv[10],
    compare = Stdlib_Int[9],
    seed = [0, 0],
    _c_ = [0, cst_value$0],
    _d_ = [0, cst_id$0],
    _b_ = [0, cst_src_grvcore_util_Uuid_ml, 25, 0],
    cst_value = cst_value$0,
    cst_id = cst_id$0,
    _a_ = [0, cst_src_grvcore_util_Uuid_ml, 14, 13],
    cst_grvcore = cst_grvcore$0;
   function next(param){seed[1] = seed[1] + 1 | 0; return seed[1];}
   function well_known(int$0){
    if(0 < int$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return int$0;
   }
   var
    to_string = Stdlib_Int[12],
    of_string = runtime.caml_int_of_string,
    Map = caml_call1(Stdlib_Map[1], [0, compare]),
    Set = caml_call1(Stdlib_Set[1], [0, compare]);
   function wrap_of_sexp(of_a_002, sexp_004){
    if(0 === sexp_004[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_017, sexp_004);
    var
     field_sexps_005 = sexp_004[1],
     id_006 = [0, 0],
     value_008 = [0, 0],
     duplicates_010 = [0, 0],
     extra_011 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_005;
       for(;;){
        if(! param) break;
        var sexp_004$0 = param[1];
        if(1 !== sexp_004$0[0]) break b;
        var _e_ = sexp_004$0[1];
        if(! _e_) break c;
        var _f_ = _e_[1];
        if(0 !== _f_[0]) break e;
        var field_sexps_014 = _e_[2], field_name_012 = _f_[1];
        if(field_sexps_014 && field_sexps_014[2]) break d;
        var
         tail_019 = param[2],
         field_sexp_013$2 =
           function(field_sexps_014){
            function field_sexp_013(param){
             if(! field_sexps_014)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_017, sexp_004);
             if(field_sexps_014[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
             var x_020 = field_sexps_014[1];
             return x_020;
            }
            return field_sexp_013;
           },
         field_sexp_013 = field_sexp_013$2(field_sexps_014);
        if(caml_string_notequal(field_name_012, cst_id$0))
         if(caml_string_notequal(field_name_012, cst_value$0)){
          if(Sexplib0_Sexp_conv[26][1])
           extra_011[1] = [0, field_name_012, extra_011[1]];
         }
         else if(value_008[1])
          duplicates_010[1] = [0, field_name_012, duplicates_010[1]];
         else{
          var
           field_sexp_013$0 = field_sexp_013(0),
           fvalue_015 = caml_call1(of_a_002, field_sexp_013$0);
          value_008[1] = [0, fvalue_015];
         }
        else if(id_006[1])
         duplicates_010[1] = [0, field_name_012, duplicates_010[1]];
        else{
         var
          field_sexp_013$1 = field_sexp_013(0),
          fvalue_016 = caml_call1(t_of_sexp, field_sexp_013$1);
         id_006[1] = [0, fvalue_016];
        }
        var param = tail_019;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_017, sexp_004$0);
    }
    if(duplicates_010[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_017,
              duplicates_010[1],
              sexp_004);
    if(extra_011[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_017,
              extra_011[1],
              sexp_004);
    var _g_ = id_006[1], match = value_008[1];
    if(_g_ && match){
     var value_009 = match[1], id_007 = _g_[1];
     return [0, id_007, value_009];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[15],
             error_source_017,
             sexp_004,
             [0,
              [0, 0 === id_006[1] ? 1 : 0, cst_id],
              [0, [0, 0 === value_008[1] ? 1 : 0, cst_value], 0]]);
   }
   function sexp_of_wrap(of_a_021, param){
    var
     value_025 = param[2],
     id_023 = param[1],
     arg_026 = caml_call1(of_a_021, value_025),
     bnds_022 = [0, [1, [0, _c_, [0, arg_026, 0]]], 0],
     arg_024 = caml_call1(sexp_of_t, id_023),
     bnds_022$0 = [0, [1, [0, _d_, [0, arg_024, 0]]], bnds_022];
    return [1, bnds_022$0];
   }
   function compare$0(u1, u2){return caml_call2(compare, u1[1], u2[1]);}
   function wrap(a){return [0, next(0), a];}
   function unwrap(u){return u[2];}
   function well_known$0(int$0, a){return [0, well_known(int$0), a];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Uuid =
      [0,
       [0,
        t_of_sexp,
        sexp_of_t,
        compare,
        next,
        well_known,
        to_string,
        of_string],
       Map,
       Set,
       sexp_of_wrap,
       wrap_of_sexp,
       compare$0,
       wrap,
       unwrap,
       well_known$0];
   runtime.caml_register_global(19, Uuid, "Uuid");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Vertex
//# unitInfo: Requires: Inline_test_config, Lang, Ppx_inline_test_lib__Runtime, Stdlib, Stdlib__List, Stdlib__Map, Stdlib__Set, Stdlib__String, Uuid
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_adding_the_same_element_tw$1 =
      "adding the same element twice produces a singleton set",
    cst_grvcore$0 = "grvcore",
    cst_src_grvcore_graph_Vertex_m$9 = "src/grvcore/graph/Vertex.ml",
    caml_equal = runtime.caml_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "}",
    cst$1 = ", ",
    cst$2 = "{",
    cst = "",
    Uuid = global_data.Uuid,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Lang = global_data.Lang,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    Inline_test_config = global_data.Inline_test_config;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    cst_src_grvcore_graph_Vertex_m = cst_src_grvcore_graph_Vertex_m$9,
    cst_root_vertex_has_id_0 = "root vertex has id 0",
    cst_src_grvcore_graph_Vertex_m$0 = cst_src_grvcore_graph_Vertex_m$9,
    cst_empty_set_has_cardinality_ = "empty set has cardinality 0",
    cst_src_grvcore_graph_Vertex_m$1 = cst_src_grvcore_graph_Vertex_m$9,
    cst_empty_set_has_no_elements = "empty set has no elements",
    cst_src_grvcore_graph_Vertex_m$2 = cst_src_grvcore_graph_Vertex_m$9,
    cst_singleton_set_has_cardinal = "singleton set has cardinality 1",
    cst_src_grvcore_graph_Vertex_m$3 = cst_src_grvcore_graph_Vertex_m$9,
    cst_singleton_set_has_one_elem = "singleton set has one element",
    cst_src_grvcore_graph_Vertex_m$4 = cst_src_grvcore_graph_Vertex_m$9,
    cst_adding_the_same_element_tw = cst_adding_the_same_element_tw$1,
    cst_src_grvcore_graph_Vertex_m$5 = cst_src_grvcore_graph_Vertex_m$9,
    cst_adding_the_same_element_tw$0 = cst_adding_the_same_element_tw$1,
    cst_src_grvcore_graph_Vertex_m$6 = cst_src_grvcore_graph_Vertex_m$9,
    cst_adding_the_same_element_th =
      "adding the same element thrice produces a singleton set",
    cst_src_grvcore_graph_Vertex_m$7 = cst_src_grvcore_graph_Vertex_m$9,
    cst_adding_and_removing_an_ele =
      "adding and removing an element produces the empty set",
    cst_src_grvcore_graph_Vertex_m$8 = cst_src_grvcore_graph_Vertex_m$9,
    cst_twice_adding_and_once_remo =
      "twice-adding and once-removing an element produces the empty set",
    cst_grvcore = cst_grvcore$0;
   function t_of_sexp(x_002){return caml_call2(Uuid[5], Lang[2][5], x_002);}
   function sexp_of_t(x_003){return caml_call2(Uuid[4], Lang[2][6], x_003);}
   var
    mk = Uuid[7],
    root = caml_call2(Uuid[9], 0, 0),
    compare = Uuid[6],
    OrderedType = [0, compare],
    Map = caml_call1(Stdlib_Map[1], OrderedType),
    Set = caml_call1(Stdlib_Set[1], OrderedType);
   function to_string(vertex){return caml_call1(Uuid[1][6], vertex[1]);}
   function set_to_string(vertexes){
    var _H_ = 0;
    function _I_(vertex, strs){return [0, to_string(vertex), strs];}
    var
     _J_ = caml_call3(Set[16], _I_, vertexes, _H_),
     _K_ = caml_call1(Stdlib_List[9], _J_),
     _L_ = caml_call1(caml_call1(Stdlib_String[6], cst$1), _K_),
     _M_ = caml_call2(Stdlib[28], _L_, cst$0);
    return caml_call2(Stdlib[28], cst$2, _M_);
   }
   function _a_(param){
    return runtime.caml_string_equal(caml_call1(Uuid[1][6], root[1]), "0");
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_root_vertex_has_id_0,
     0,
     cst_src_grvcore_graph_Vertex_m,
     30,
     0,
     65,
     _a_);
   function _b_(param){return 0 === caml_call1(Set[22], Set[1]) ? 1 : 0;}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_empty_set_has_cardinality_,
     0,
     cst_src_grvcore_graph_Vertex_m$0,
     34,
     0,
     65,
     _b_);
   function _c_(param){return 0 === caml_call1(Set[23], Set[1]) ? 1 : 0;}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_empty_set_has_no_elements,
     0,
     cst_src_grvcore_graph_Vertex_m$1,
     35,
     0,
     64,
     _c_);
   function _d_(param){
    var
     _E_ = Set[1],
     _F_ = caml_call1(mk, 2),
     _G_ = caml_call1(caml_call1(Set[4], _F_), _E_);
    return 1 === caml_call1(Set[22], _G_) ? 1 : 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_singleton_set_has_cardinal,
     0,
     cst_src_grvcore_graph_Vertex_m$2,
     37,
     0,
     94,
     _d_);
   function _e_(param){
    var
     v = caml_call1(mk, 2),
     _C_ = Set[1],
     _D_ = caml_call1(caml_call1(Set[4], v), _C_);
    return caml_equal(caml_call1(Set[23], _D_), [0, v, 0]);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_singleton_set_has_one_elem,
     0,
     cst_src_grvcore_graph_Vertex_m$3,
     40,
     0,
     109,
     _e_);
   function _f_(param){
    var
     v = caml_call1(mk, 2),
     _y_ = Set[1],
     _z_ = caml_call1(caml_call1(Set[4], v), _y_),
     vs = caml_call1(caml_call1(Set[4], v), _z_),
     _A_ = 1 === caml_call1(Set[22], vs) ? 1 : 0,
     _B_ = _A_ ? caml_equal(caml_call1(Set[23], vs), [0, v, 0]) : _A_;
    return _B_;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_adding_the_same_element_tw,
     0,
     cst_src_grvcore_graph_Vertex_m$4,
     44,
     0,
     184,
     _f_);
   function _g_(param){
    var
     v = caml_call1(mk, 2),
     _u_ = Set[1],
     _v_ = caml_call1(caml_call1(Set[4], v), _u_),
     vs = caml_call1(caml_call1(Set[4], v), _v_),
     _w_ = 1 === caml_call1(Set[22], vs) ? 1 : 0,
     _x_ = _w_ ? caml_equal(caml_call1(Set[23], vs), [0, v, 0]) : _w_;
    return _x_;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_adding_the_same_element_tw$0,
     0,
     cst_src_grvcore_graph_Vertex_m$5,
     49,
     0,
     184,
     _g_);
   function _h_(param){
    var
     v = caml_call1(mk, 2),
     _p_ = Set[1],
     _q_ = caml_call1(caml_call1(Set[4], v), _p_),
     _r_ = caml_call1(caml_call1(Set[4], v), _q_),
     vs = caml_call1(caml_call1(Set[4], v), _r_),
     _s_ = 1 === caml_call1(Set[22], vs) ? 1 : 0,
     _t_ = _s_ ? caml_equal(caml_call1(Set[23], vs), [0, v, 0]) : _s_;
    return _t_;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_adding_the_same_element_th,
     0,
     cst_src_grvcore_graph_Vertex_m$6,
     54,
     0,
     194,
     _h_);
   function _i_(param){
    var
     v = caml_call1(mk, 2),
     _n_ = Set[1],
     _o_ = caml_call1(caml_call1(Set[4], v), _n_),
     vs = caml_call1(caml_call1(Set[6], v), _o_);
    return caml_call1(Set[2], vs);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_adding_and_removing_an_ele,
     0,
     cst_src_grvcore_graph_Vertex_m$7,
     59,
     0,
     155,
     _i_);
   function _j_(param){
    var
     v = caml_call1(mk, 2),
     _k_ = Set[1],
     _l_ = caml_call1(caml_call1(Set[4], v), _k_),
     _m_ = caml_call1(caml_call1(Set[4], v), _l_),
     vs = caml_call1(caml_call1(Set[6], v), _m_);
    return caml_call1(Set[2], vs);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_twice_adding_and_once_remo,
     0,
     cst_src_grvcore_graph_Vertex_m$8,
     64,
     0,
     175,
     _j_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Vertex =
      [0, t_of_sexp, sexp_of_t, mk, root, Map, Set, to_string, set_to_string];
   runtime.caml_register_global(36, Vertex, "Vertex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Util
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Sexplib0__Sexp, Sexplib__Std, Stdlib, Stdlib__Option
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Option = global_data.Stdlib__Option,
    Sexplib_Std = global_data.Sexplib__Std,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib = global_data.Stdlib,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var cst_grvcore = cst_grvcore$0;
   function intersperse(delim, xs){
    if(xs){
     var x = xs[1];
     if(xs[2]){
      var xs$0 = xs[2];
      return [0, x, [0, delim, intersperse(delim, xs$0)]];
     }
    }
    return xs;
   }
   var List = [0, intersperse];
   function print(sexp){
    var _c_ = caml_call2(Sexplib0_Sexp[13], 0, sexp);
    return caml_call1(Stdlib[46], _c_);
   }
   function of_map(bindings, sexp_of_key, sexp_of_value){
    function _a_(param){
     var
      v = param[2],
      k = param[1],
      _b_ = [0, caml_call1(sexp_of_value, v), 0];
     return [1, [0, caml_call1(sexp_of_key, k), _b_]];
    }
    return caml_call2(Sexplib_Std[39], _a_, bindings);
   }
   var Sexp = [0, print, of_map];
   function return$0(o){return [0, o];}
   function map(f, o){return caml_call2(Stdlib_Option[7], f, o);}
   function bind(o, f){return caml_call2(Stdlib_Option[5], o, f);}
   var
    Let_syntax = [0, return$0, map, bind],
    Let_syntax$0 = [0, Let_syntax],
    Option = [0, Let_syntax$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Util = [0, List, Sexp, Option];
   runtime.caml_register_global(8, Util, "Util");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Cursor
//# unitInfo: Requires: Assert_failure, Inline_test_config, Lang, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib__Format, Uuid, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_grvcore$0 = "grvcore",
    cst_position$0 = "position",
    cst_src_grvcore_graph_Cursor_m$2 = "src/grvcore/graph/Cursor.ml",
    cst_vertex$0 = "vertex",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    error_source_015 = "src/grvcore/graph/Cursor.ml.t",
    Lang = global_data.Lang,
    Uuid = global_data.Uuid,
    Stdlib_Format = global_data.Stdlib__Format,
    Vertex = global_data.Vertex,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Inline_test_config = global_data.Inline_test_config;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _d_ = [0, [2, 0, [12, 46, [2, 0, 0]]], "%s.%s"],
    _b_ = [0, cst_position$0],
    _c_ = [0, cst_vertex$0],
    _a_ = [0, cst_src_grvcore_graph_Cursor_m$2, 1, 0],
    cst_position = cst_position$0,
    cst_vertex = cst_vertex$0,
    cst_src_grvcore_graph_Cursor_m = cst_src_grvcore_graph_Cursor_m$2,
    cst_root_cursor_has_UUID_0 = "root cursor has UUID 0",
    cst_src_grvcore_graph_Cursor_m$0 = cst_src_grvcore_graph_Cursor_m$2,
    cst_root_cursor_has_position_R = "root cursor has position Root_root_root",
    cst_src_grvcore_graph_Cursor_m$1 = cst_src_grvcore_graph_Cursor_m$2,
    cst_cursor_representation = "cursor representation",
    cst_grvcore = cst_grvcore$0;
   function t_of_sexp(sexp_002){
    if(0 === sexp_002[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_015, sexp_002);
    var
     field_sexps_003 = sexp_002[1],
     vertex_004 = [0, 0],
     position_006 = [0, 0],
     duplicates_008 = [0, 0],
     extra_009 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_003;
       for(;;){
        if(! param) break;
        var sexp_002$0 = param[1];
        if(1 !== sexp_002$0[0]) break b;
        var _j_ = sexp_002$0[1];
        if(! _j_) break c;
        var _k_ = _j_[1];
        if(0 !== _k_[0]) break e;
        var field_sexps_012 = _j_[2], field_name_010 = _k_[1];
        if(field_sexps_012 && field_sexps_012[2]) break d;
        var
         tail_017 = param[2],
         field_sexp_011$2 =
           function(field_sexps_012){
            function field_sexp_011(param){
             if(! field_sexps_012)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002);
             if(field_sexps_012[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
             var x_018 = field_sexps_012[1];
             return x_018;
            }
            return field_sexp_011;
           },
         field_sexp_011 = field_sexp_011$2(field_sexps_012);
        if(caml_string_notequal(field_name_010, cst_position$0))
         if(caml_string_notequal(field_name_010, cst_vertex$0)){
          if(Sexplib0_Sexp_conv[26][1])
           extra_009[1] = [0, field_name_010, extra_009[1]];
         }
         else if(vertex_004[1])
          duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
         else{
          var
           field_sexp_011$0 = field_sexp_011(0),
           fvalue_014 = caml_call1(Vertex[1], field_sexp_011$0);
          vertex_004[1] = [0, fvalue_014];
         }
        else if(position_006[1])
         duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
        else{
         var
          field_sexp_011$1 = field_sexp_011(0),
          fvalue_013 = caml_call1(Lang[3][5], field_sexp_011$1);
         position_006[1] = [0, fvalue_013];
        }
        var param = tail_017;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002$0);
    }
    if(duplicates_008[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_015,
              duplicates_008[1],
              sexp_002);
    if(extra_009[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_015,
              extra_009[1],
              sexp_002);
    var _l_ = vertex_004[1], match = position_006[1];
    if(_l_ && match){
     var position_007 = match[1], vertex_005 = _l_[1];
     return [0, vertex_005, position_007];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[15],
             error_source_015,
             sexp_002,
             [0,
              [0, 0 === vertex_004[1] ? 1 : 0, cst_vertex],
              [0, [0, 0 === position_006[1] ? 1 : 0, cst_position], 0]]);
   }
   function sexp_of_t(param){
    var
     position_022 = param[2],
     vertex_020 = param[1],
     arg_023 = caml_call1(Lang[3][6], position_022),
     bnds_019 = [0, [1, [0, _b_, [0, arg_023, 0]]], 0],
     arg_021 = caml_call1(Vertex[2], vertex_020),
     bnds_019$0 = [0, [1, [0, _c_, [0, arg_021, 0]]], bnds_019];
    return [1, bnds_019$0];
   }
   function to_string(cursor){
    var
     _h_ = caml_call1(Lang[3][7], cursor[2]),
     _i_ = caml_call1(Uuid[1][6], cursor[1][1]);
    return caml_call3(Stdlib_Format[138], _d_, _i_, _h_);
   }
   var root = [0, Vertex[4], 0];
   function _e_(param){
    return caml_string_equal(caml_call1(Uuid[1][6], root[1][1]), "0");
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_root_cursor_has_UUID_0,
     0,
     cst_src_grvcore_graph_Cursor_m,
     11,
     0,
     74,
     _e_);
   function _f_(param){return caml_call2(Lang[3][3], root[2], 0);}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_root_cursor_has_position_R,
     0,
     cst_src_grvcore_graph_Cursor_m$0,
     13,
     0,
     103,
     _f_);
   function _g_(param){return caml_string_equal(to_string(root), "0.root");}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_cursor_representation,
     0,
     cst_src_grvcore_graph_Cursor_m$1,
     16,
     0,
     60,
     _g_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Cursor = [0, t_of_sexp, sexp_of_t, to_string, root];
   runtime.caml_register_global(29, Cursor, "Cursor");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Edge
//# unitInfo: Requires: Assert_failure, Cursor, Lang, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__List, Stdlib__Map, Stdlib__Set, Stdlib__String, Uuid, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_grvcore$0 = "grvcore",
    cst_source$0 = "source",
    cst_target$0 = "target",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = "}",
    cst$3 = ", ",
    cst$4 = "{",
    cst$0 = " -> ",
    cst$1 = ":",
    cst = "",
    error_source_015 = "src/grvcore/graph/Edge.ml.t'",
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Vertex = global_data.Vertex,
    Lang = global_data.Lang,
    Uuid = global_data.Uuid,
    Cursor = global_data.Cursor,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _b_ = [0, cst_target$0],
    _c_ = [0, cst_source$0],
    _a_ = [0, "src/grvcore/graph/Edge.ml", 1, 0],
    cst_target = cst_target$0,
    cst_source = cst_source$0,
    cst_grvcore = cst_grvcore$0;
   function t_of_sexp(sexp_002){
    if(0 === sexp_002[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_015, sexp_002);
    var
     field_sexps_003 = sexp_002[1],
     source_004 = [0, 0],
     target_006 = [0, 0],
     duplicates_008 = [0, 0],
     extra_009 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_003;
       for(;;){
        if(! param) break;
        var sexp_002$0 = param[1];
        if(1 !== sexp_002$0[0]) break b;
        var _s_ = sexp_002$0[1];
        if(! _s_) break c;
        var _t_ = _s_[1];
        if(0 !== _t_[0]) break e;
        var field_sexps_012 = _s_[2], field_name_010 = _t_[1];
        if(field_sexps_012 && field_sexps_012[2]) break d;
        var
         tail_017 = param[2],
         field_sexp_011$2 =
           function(field_sexps_012){
            function field_sexp_011(param){
             if(! field_sexps_012)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002);
             if(field_sexps_012[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
             var x_018 = field_sexps_012[1];
             return x_018;
            }
            return field_sexp_011;
           },
         field_sexp_011 = field_sexp_011$2(field_sexps_012);
        if(caml_string_notequal(field_name_010, cst_source$0))
         if(caml_string_notequal(field_name_010, cst_target$0)){
          if(Sexplib0_Sexp_conv[26][1])
           extra_009[1] = [0, field_name_010, extra_009[1]];
         }
         else if(target_006[1])
          duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
         else{
          var
           field_sexp_011$0 = field_sexp_011(0),
           fvalue_013 = caml_call1(Vertex[1], field_sexp_011$0);
          target_006[1] = [0, fvalue_013];
         }
        else if(source_004[1])
         duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
        else{
         var
          field_sexp_011$1 = field_sexp_011(0),
          fvalue_014 = caml_call1(Cursor[1], field_sexp_011$1);
         source_004[1] = [0, fvalue_014];
        }
        var param = tail_017;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002$0);
    }
    if(duplicates_008[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_015,
              duplicates_008[1],
              sexp_002);
    if(extra_009[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_015,
              extra_009[1],
              sexp_002);
    var _u_ = source_004[1], match = target_006[1];
    if(_u_ && match){
     var target_007 = match[1], source_005 = _u_[1];
     return [0, source_005, target_007];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[15],
             error_source_015,
             sexp_002,
             [0,
              [0, 0 === source_004[1] ? 1 : 0, cst_source],
              [0, [0, 0 === target_006[1] ? 1 : 0, cst_target], 0]]);
   }
   function sexp_of_t(param){
    var
     target_022 = param[2],
     source_020 = param[1],
     arg_023 = caml_call1(Vertex[2], target_022),
     bnds_019 = [0, [1, [0, _b_, [0, arg_023, 0]]], 0],
     arg_021 = caml_call1(Cursor[2], source_020),
     bnds_019$0 = [0, [1, [0, _c_, [0, arg_021, 0]]], bnds_019];
    return [1, bnds_019$0];
   }
   function t_of_sexp$0(x_025){return caml_call2(Uuid[5], t_of_sexp, x_025);}
   function sexp_of_t$0(x_026){return caml_call2(Uuid[4], sexp_of_t, x_026);}
   function mk(source, target){
    return caml_call1(Uuid[7], [0, source, target]);
   }
   var
    compare = Uuid[6],
    OrderedType = [0, compare],
    Map = caml_call1(Stdlib_Map[1], OrderedType),
    Set = caml_call1(Stdlib_Set[1], OrderedType);
   function partition_set(edges, pivot){
    function _r_(edge){return runtime.caml_equal(edge[2][1][1], pivot);}
    return caml_call2(Set[21], _r_, edges);
   }
   function union_sets(sets){
    var
     _p_ = caml_call2(Stdlib_List[19], Set[23], sets),
     _q_ = caml_call1(Stdlib_List[13], _p_);
    return caml_call1(Set[37], _q_);
   }
   function to_string(edge){
    var
     _j_ = caml_call1(Vertex[7], edge[2][2]),
     _k_ = caml_call2(Stdlib[28], cst$0, _j_),
     _l_ = caml_call1(Lang[3][7], edge[2][1][2]),
     _m_ = caml_call2(Stdlib[28], _l_, _k_),
     _n_ = caml_call2(Stdlib[28], cst$1, _m_),
     _o_ = caml_call1(Vertex[7], edge[2][1][1]);
    return caml_call2(Stdlib[28], _o_, _n_);
   }
   function set_to_string(edges){
    var _d_ = 0;
    function _e_(edge, strs){return [0, to_string(edge), strs];}
    var
     _f_ = caml_call3(Set[16], _e_, edges, _d_),
     _g_ = caml_call1(Stdlib_List[9], _f_),
     _h_ = caml_call1(caml_call1(Stdlib_String[6], cst$3), _g_),
     _i_ = caml_call2(Stdlib[28], _h_, cst$2);
    return caml_call2(Stdlib[28], cst$4, _i_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Edge =
      [0,
       sexp_of_t,
       t_of_sexp,
       t_of_sexp$0,
       sexp_of_t$0,
       mk,
       Map,
       Set,
       partition_set,
       union_sets,
       to_string,
       set_to_string];
   runtime.caml_register_global(29, Edge, "Edge");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Edge_state
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Created = "Created",
    cst_Deleted = "Deleted",
    cst_created = "created",
    cst_deleted = "deleted",
    cst_grvcore$0 = "grvcore",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "-",
    cst$1 = "+",
    cst = "",
    error_source_003 = "src/grvcore/graph/Edge_state.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _a_ = [0, cst_Deleted],
    _b_ = [0, cst_Created],
    cst_grvcore = cst_grvcore$0;
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _c_ = sexp_004[1];
      b:
      if(caml_string_notequal(_c_, cst_Created)){
       if(caml_string_notequal(_c_, cst_Deleted)){
        if(! caml_string_notequal(_c_, cst_created)) break b;
        if(caml_string_notequal(_c_, cst_deleted)) break a;
       }
       return 1;
      }
      return 0;
     }
     var _d_ = sexp_004[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _f_ = _e_[1];
     b:
     if(caml_string_notequal(_f_, cst_Created)){
      if(caml_string_notequal(_f_, cst_Deleted)){
       if(! caml_string_notequal(_f_, cst_created)) break b;
       if(caml_string_notequal(_f_, cst_deleted)) break a;
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function to_string(param){return param ? cst$0 : cst$1;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Edge_state = [0, t_of_sexp, sexp_of_t, to_string];
   runtime.caml_register_global(18, Edge_state, "Edge_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Env
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Stdlib__Map, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Map = global_data.Stdlib__Map;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore, cst);
   var
    compare = Stdlib_String[9],
    Map = caml_call1(Stdlib_Map[1], [0, compare]),
    empty = Map[1],
    is_empty = Map[2],
    mem = Map[3],
    add = Map[4],
    update = Map[5],
    singleton = Map[6],
    remove = Map[7],
    merge = Map[8],
    union = Map[9],
    compare$0 = Map[10],
    equal = Map[11],
    iter = Map[12],
    fold = Map[13],
    for_all = Map[14],
    exists = Map[15],
    filter = Map[16],
    filter_map = Map[17],
    partition = Map[18],
    cardinal = Map[19],
    bindings = Map[20],
    min_binding = Map[21],
    min_binding_opt = Map[22],
    max_binding = Map[23],
    max_binding_opt = Map[24],
    choose = Map[25],
    choose_opt = Map[26],
    split = Map[27],
    find = Map[28],
    find_opt = Map[29],
    find_first = Map[30],
    find_first_opt = Map[31],
    find_last = Map[32],
    find_last_opt = Map[33],
    map = Map[34],
    mapi = Map[35],
    to_seq = Map[36],
    to_rev_seq = Map[37],
    to_seq_from = Map[38],
    add_seq = Map[39],
    of_seq = Map[40];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Env =
      [0,
       Map,
       empty,
       is_empty,
       mem,
       add,
       update,
       singleton,
       remove,
       merge,
       union,
       compare$0,
       equal,
       iter,
       fold,
       for_all,
       exists,
       filter,
       filter_map,
       partition,
       cardinal,
       bindings,
       min_binding,
       min_binding_opt,
       max_binding,
       max_binding_opt,
       choose,
       choose_opt,
       split,
       find,
       find_opt,
       find_first,
       find_first_opt,
       find_last,
       find_last_opt,
       map,
       mapi,
       to_seq,
       to_rev_seq,
       to_seq_from,
       add_seq,
       of_seq];
   runtime.caml_register_global(6, Env, "Env");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Error
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Stdlib, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var cst_grvcore = cst_grvcore$0;
   function error(origin, vertex){
    function _c_(message){return [1, [0, [0, origin, vertex, message], 0]];}
    return caml_call1(Stdlib_Printf[10], _c_);
   }
   function bind(o, f){
    if(0 === o[0]){var a = o[1]; return caml_call1(f, a);}
    var es = o[1];
    return [1, es];
   }
   function return$0(o){return [0, o];}
   function map(f, o){
    if(0 !== o[0]) return o;
    var a = o[1];
    return [0, caml_call1(f, a)];
   }
   function both(o1, o2){
    if(0 !== o1[0]){
     var es1 = o1[1];
     if(0 === o2[0]) return [1, es1];
     var es2$0 = o2[1];
     return [1, caml_call2(Stdlib[37], es1, es2$0)];
    }
    var o1$0 = o1[1];
    if(0 === o2[0]){var o2$0 = o2[1]; return [0, [0, o1$0, o2$0]];}
    var es2 = o2[1];
    return [1, es2];
   }
   var
    Let_syntax = [0, bind, return$0, map, both],
    bind$0 = Let_syntax[1],
    return$1 = Let_syntax[2],
    map$0 = Let_syntax[3],
    both$0 = Let_syntax[4];
   function sequence(xs){
    if(! xs) return caml_call1(return$1, 0);
    var xs$0 = xs[2], x = xs[1], let_syntax_002 = sequence(xs$0);
    function _a_(param){
     var xs = param[2], x = param[1];
     return caml_call1(return$1, [0, x, xs]);
    }
    var _b_ = caml_call2(Let_syntax[4], x, let_syntax_002);
    return caml_call2(Let_syntax[1], _b_, _a_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Error = [0, error, Let_syntax, bind$0, return$1, map$0, both$0, sequence];
   runtime.caml_register_global(6, Error, "Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Graph_action
//# unitInfo: Requires: Assert_failure, Cursor, Edge, Edge_state, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib__Format, Stdlib__Map, Stdlib__Set, Uuid
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_edge$0 = "edge",
    cst_grvcore$0 = "grvcore",
    cst_state$0 = "state",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    error_source_015 = "src/grvcore/graph/Graph_action.ml.t",
    Uuid = global_data.Uuid,
    Cursor = global_data.Cursor,
    Edge_state = global_data.Edge_state,
    Stdlib_Format = global_data.Stdlib__Format,
    Edge = global_data.Edge,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _d_ =
      [0,
       [2, 0, [12, 32, [2, 0, [11, " \xe2\x86\x92 ", [2, 0, 0]]]]],
       "%s %s \xe2\x86\x92 %s"],
    _b_ = [0, cst_state$0],
    _c_ = [0, cst_edge$0],
    _a_ = [0, "src/grvcore/graph/Graph_action.ml", 1, 0],
    cst_state = cst_state$0,
    cst_edge = cst_edge$0,
    cst_grvcore = cst_grvcore$0;
   function t_of_sexp(sexp_002){
    if(0 === sexp_002[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_015, sexp_002);
    var
     field_sexps_003 = sexp_002[1],
     edge_004 = [0, 0],
     state_006 = [0, 0],
     duplicates_008 = [0, 0],
     extra_009 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_003;
       for(;;){
        if(! param) break;
        var sexp_002$0 = param[1];
        if(1 !== sexp_002$0[0]) break b;
        var _h_ = sexp_002$0[1];
        if(! _h_) break c;
        var _i_ = _h_[1];
        if(0 !== _i_[0]) break e;
        var field_sexps_012 = _h_[2], field_name_010 = _i_[1];
        if(field_sexps_012 && field_sexps_012[2]) break d;
        var
         tail_017 = param[2],
         field_sexp_011$2 =
           function(field_sexps_012){
            function field_sexp_011(param){
             if(! field_sexps_012)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002);
             if(field_sexps_012[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
             var x_018 = field_sexps_012[1];
             return x_018;
            }
            return field_sexp_011;
           },
         field_sexp_011 = field_sexp_011$2(field_sexps_012);
        if(caml_string_notequal(field_name_010, cst_edge$0))
         if(caml_string_notequal(field_name_010, cst_state$0)){
          if(Sexplib0_Sexp_conv[26][1])
           extra_009[1] = [0, field_name_010, extra_009[1]];
         }
         else if(state_006[1])
          duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
         else{
          var
           field_sexp_011$0 = field_sexp_011(0),
           fvalue_013 = caml_call1(Edge_state[1], field_sexp_011$0);
          state_006[1] = [0, fvalue_013];
         }
        else if(edge_004[1])
         duplicates_008[1] = [0, field_name_010, duplicates_008[1]];
        else{
         var
          field_sexp_011$1 = field_sexp_011(0),
          fvalue_014 = caml_call1(Edge[3], field_sexp_011$1);
         edge_004[1] = [0, fvalue_014];
        }
        var param = tail_017;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_015, sexp_002$0);
    }
    if(duplicates_008[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_015,
              duplicates_008[1],
              sexp_002);
    if(extra_009[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_015,
              extra_009[1],
              sexp_002);
    var _j_ = edge_004[1], match = state_006[1];
    if(_j_ && match){
     var state_007 = match[1], edge_005 = _j_[1];
     return [0, edge_005, state_007];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[15],
             error_source_015,
             sexp_002,
             [0,
              [0, 0 === edge_004[1] ? 1 : 0, cst_edge],
              [0, [0, 0 === state_006[1] ? 1 : 0, cst_state], 0]]);
   }
   function sexp_of_t(param){
    var
     state_022 = param[2],
     edge_020 = param[1],
     arg_023 = caml_call1(Edge_state[2], state_022),
     bnds_019 = [0, [1, [0, _b_, [0, arg_023, 0]]], 0],
     arg_021 = caml_call1(Edge[4], edge_020),
     bnds_019$0 = [0, [1, [0, _c_, [0, arg_021, 0]]], bnds_019];
    return [1, bnds_019$0];
   }
   function to_string(edge_action){
    var
     _e_ = caml_call1(Uuid[1][6], edge_action[1][2][2][1]),
     _f_ = caml_call1(Cursor[3], edge_action[1][2][1]),
     _g_ = caml_call1(Edge_state[3], edge_action[2]);
    return caml_call4(Stdlib_Format[138], _d_, _g_, _f_, _e_);
   }
   var
    compare = runtime.caml_compare,
    OrderedType = [0, compare],
    Map = caml_call1(Stdlib_Map[1], OrderedType),
    Set = caml_call1(Stdlib_Set[1], OrderedType);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Graph_action = [0, t_of_sexp, sexp_of_t, Map, Set, to_string];
   runtime.caml_register_global(23, Graph_action, "Graph_action");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Graph
//# unitInfo: Requires: Edge, Edge_state, Ppx_inline_test_lib__Runtime, Sexplib__Std, Stdlib, Stdlib__List, Util, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_grvcore$0 = "grvcore",
    caml_equal = runtime.caml_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Edge_state = global_data.Edge_state,
    Edge = global_data.Edge,
    Stdlib = global_data.Stdlib,
    Sexplib_Std = global_data.Sexplib__Std,
    Stdlib_List = global_data.Stdlib__List,
    Util = global_data.Util,
    Vertex = global_data.Vertex,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    empty = Edge[6][1],
    add = Edge[6][4],
    cst_File_src_grvcore_graph_Gra =
      'File "src/grvcore/graph/Graph.ml", line 97, characters 23-30',
    _a_ = [0, 2],
    _b_ = [0, 1],
    cst_grvcore = cst_grvcore$0;
   function apply_action(graph, action){
    var
     old_state = caml_call2(Edge[6][29], action[1], graph),
     new_state = action[2];
    if(old_state){
     if(old_state[1]) return graph;
     if(! new_state) return graph;
    }
    else if(! new_state) return caml_call3(add, action[1], 0, graph);
    return caml_call3(add, action[1], 1, graph);
   }
   function edges(graph){
    var _V_ = caml_call1(Edge[6][20], graph);
    function _W_(_Y_){return _Y_[1];}
    var _X_ = caml_call1(caml_call1(Stdlib_List[19], _W_), _V_);
    return caml_call1(Edge[7][37], _X_);
   }
   function live_edges(graph){
    var _P_ = caml_call1(Edge[6][20], graph);
    function _Q_(param){return param[2] ? 0 : 1;}
    var _R_ = caml_call1(caml_call1(Stdlib_List[41], _Q_), _P_);
    function _S_(_U_){return _U_[1];}
    var _T_ = caml_call1(caml_call1(Stdlib_List[19], _S_), _R_);
    return caml_call1(Edge[7][37], _T_);
   }
   function parent_edges(graph, vertex){
    var _N_ = live_edges(graph);
    function _O_(edge){return caml_equal(edge[2][2], vertex);}
    return caml_call1(caml_call1(Edge[7][19], _O_), _N_);
   }
   function child_edges(graph, vertex, position){
    var _L_ = live_edges(graph);
    function _M_(edge){return caml_equal(edge[2][1], [0, vertex, position]);}
    return caml_call1(caml_call1(Edge[7][19], _M_), _L_);
   }
   function impl(edge_source, graph){
    var _H_ = Vertex[6][1], _I_ = caml_call1(edge_source, graph);
    function _J_(edge, vertexes){
     var _K_ = caml_call1(caml_call1(Vertex[6][4], edge[2][1][1]), vertexes);
     return caml_call1(caml_call1(Vertex[6][4], edge[2][2]), _K_);
    }
    return caml_call1(caml_call2(Edge[7][16], _J_, _I_), _H_);
   }
   function live_vertexes(_G_){return impl(live_edges, _G_);}
   function vertexes(_F_){return impl(edges, _F_);}
   function parent_vertexes(graph, vertex){
    var _C_ = Vertex[6][1], _D_ = parent_edges(graph, vertex);
    function _E_(e){return caml_call1(Vertex[6][4], e[2][1][1]);}
    return caml_call1(caml_call2(Edge[7][16], _E_, _D_), _C_);
   }
   function deleted(graph){
    var _y_ = vertexes(graph), _z_ = live_edges(graph);
    function _A_(edge){return caml_call1(Vertex[6][6], edge[2][2]);}
    var _B_ = caml_call1(caml_call2(Edge[7][16], _A_, _z_), _y_);
    return caml_call1(caml_call1(Vertex[6][6], Vertex[4]), _B_);
   }
   function multiparented(graph){
    var _n_ = Vertex[5][1], _o_ = live_edges(graph);
    function _p_(edge){
     function _x_(param){return param ? _a_ : _b_;}
     return caml_call2(Vertex[5][5], edge[2][2], _x_);
    }
    var _q_ = caml_call1(caml_call2(Edge[7][16], _p_, _o_), _n_);
    function _r_(param, count){return 2 === count ? 1 : 0;}
    var
     _s_ = caml_call1(caml_call1(Vertex[5][16], _r_), _q_),
     _t_ = caml_call1(Vertex[5][20], _s_);
    function _u_(_w_){return _w_[1];}
    var _v_ = caml_call1(caml_call1(Stdlib_List[19], _u_), _t_);
    return caml_call1(Vertex[6][37], _v_);
   }
   function vertex(graph, vertex_id){
    var _l_ = vertexes(graph);
    function _m_(vertex){return caml_equal(vertex[1], vertex_id);}
    return caml_call1(caml_call1(Vertex[6][34], _m_), _l_);
   }
   function sexp_of_t(graph){
    var
     _i_ = Edge_state[2],
     _j_ = Edge[4],
     _k_ = caml_call1(Edge[6][20], graph);
    return caml_call3(Util[2][2], _k_, _j_, _i_);
   }
   function t_of_sexp(sexp){
    function _c_(param){
     if(1 === param[0]){
      var _f_ = param[1];
      if(_f_){
       var _g_ = _f_[2];
       if(_g_ && ! _g_[2]){
        var
         value_sexp = _g_[1],
         key_sexp = _f_[1],
         _h_ = caml_call1(Edge_state[1], value_sexp);
        return [0, caml_call1(Edge[3], key_sexp), _h_];
       }
      }
     }
     return caml_call1(Stdlib[2], cst_File_src_grvcore_graph_Gra);
    }
    var
     _d_ = caml_call1(caml_call1(Sexplib_Std[40], _c_), sexp),
     _e_ = caml_call1(Stdlib_List[61], _d_);
    return caml_call1(Edge[6][40], _e_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Graph =
      [0,
       empty,
       add,
       apply_action,
       edges,
       live_edges,
       parent_edges,
       child_edges,
       vertexes,
       live_vertexes,
       parent_vertexes,
       deleted,
       multiparented,
       vertex,
       sexp_of_t,
       t_of_sexp];
   runtime.caml_register_global(14, Graph, "Graph");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Type
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst$1 = "@ ",
    cst$0 = "@,",
    cst_grvcore$0 = "grvcore",
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Format = global_data.Stdlib__Format,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    pp = function _k_(_i_, _j_){return _k_.fun(_i_, _j_);},
    show = function _h_(_g_){return _h_.fun(_g_);},
    _f_ = [0, [15, 0], "%a"],
    cst_Type_Unknown = "Type.Unknown",
    cst_Type_Num = "Type.Num",
    _a_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, [11, cst_2, 0], cst_2]],
         [11, "Type.Arrow (", [17, [0, cst$0, 0, 0], 0]]]],
       "(@[<2>Type.Arrow (@,"],
    _b_ = [0, [12, 44, [17, [0, cst$1, 1, 0], 0]], ",@ "],
    _c_ = [0, [17, [0, cst$0, 0, 0], [11, "))", [17, 0, 0]]], "@,))@]"],
    _d_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, [11, cst_2, 0], cst_2]],
         [11, "Type.List", [17, [0, cst$1, 1, 0], 0]]]],
       "(@[<2>Type.List@ "],
    _e_ = [0, [17, 0, [12, 41, 0]], "@])"],
    cst_grvcore = cst_grvcore$0;
   caml_update_dummy
    (pp,
     function(fmt, param){
      if(typeof param === "number")
       return 0 === param
               ? caml_call2(Stdlib_Format[13], fmt, cst_Type_Unknown)
               : caml_call2(Stdlib_Format[13], fmt, cst_Type_Num);
      if(0 === param[0]){
       var a1 = param[2], a0 = param[1];
       caml_call2(Stdlib_Format[135], fmt, _a_);
       caml_call1(caml_call1(pp, fmt), a0);
       caml_call2(Stdlib_Format[135], fmt, _b_);
       caml_call1(caml_call1(pp, fmt), a1);
       return caml_call2(Stdlib_Format[135], fmt, _c_);
      }
      var a0$0 = param[1];
      caml_call2(Stdlib_Format[135], fmt, _d_);
      caml_call1(caml_call1(pp, fmt), a0$0);
      return caml_call2(Stdlib_Format[135], fmt, _e_);
     });
   caml_update_dummy
    (show, function(x){return caml_call3(Stdlib_Format[139], _f_, pp, x);});
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Type = [0, pp, show];
   runtime.caml_register_global(13, Type, "Type");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Type_check
//# unitInfo: Requires: Edge, Env, Error, Graph, Lang, Ppx_inline_test_lib__Runtime, Stdlib, Stdlib__List, Stdlib__Printf, Type, Uuid
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Error = global_data.Error,
    Graph = global_data.Graph,
    Edge = global_data.Edge,
    Stdlib_List = global_data.Stdlib__List,
    Env = global_data.Env,
    Type = global_data.Type,
    Lang = global_data.Lang,
    Uuid = global_data.Uuid,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    error = Error[1],
    return$0 = Error[4],
    cst_File_src_grvcore_type_Type =
      'File "src/grvcore/type/Type_check.ml", line 60, characters 20-27',
    cst_File_src_grvcore_type_Type$0 =
      'File "src/grvcore/type/Type_check.ml", line 83, characters 20-27',
    _d_ = [0, 0, 0],
    _e_ =
      [0,
       [11, "expected a function type; actual type ", [2, 0, 0]],
       "expected a function type; actual type %s"],
    cst_File_src_grvcore_type_Type$2 =
      'File "src/grvcore/type/Type_check.ml", line 131, characters 18-25',
    _f_ = [0, [11, "unbound variable: ", [2, 0, 0]], "unbound variable: %s"],
    cst_File_src_grvcore_type_Type$3 =
      'File "src/grvcore/type/Type_check.ml", line 109, characters 22-29',
    cst_File_src_grvcore_type_Type$1 =
      'File "src/grvcore/type/Type_check.ml", line 150, characters 20-27',
    cst_File_src_grvcore_type_Type$5 =
      'File "src/grvcore/type/Type_check.ml", line 174, characters 17-24',
    _g_ =
      [0,
       [11, "expected a list type; actual type ", [2, 0, 0]],
       "expected a list type; actual type %s"],
    cst_File_src_grvcore_type_Type$4 =
      'File "src/grvcore/type/Type_check.ml", line 161, characters 18-25',
    cst_File_src_grvcore_type_Type$6 =
      'File "src/grvcore/type/Type_check.ml", line 205, characters 20-27',
    _b_ =
      [0,
       [2, 0, [11, ": Missing case for ", [2, 0, [11, " in ", [2, 0, 0]]]]],
       "%s: Missing case for %s in %s"],
    _c_ =
      [0,
       [2, 0, [11, ": Non-Typ vertex ", [2, 0, 0]]],
       "%s: Non-Typ vertex %s"],
    _a_ =
      [0,
       [11, "expected type ", [2, 0, [11, "; actual type ", [2, 0, 0]]]],
       "expected type %s; actual type %s"],
    cst_grvcore = cst_grvcore$0;
   function consistent(origin, vertex, expected, actual){
    function go(expected, actual){
     a:
     {
      b:
      if(typeof expected === "number"){
       if(0 === expected) return caml_call1(return$0, 0);
       if(typeof actual !== "number") break a;
       if(actual) return caml_call1(return$0, 0);
      }
      else if(0 === expected[0]){
       var expected2 = expected[2], expected1 = expected[1];
       if(typeof actual === "number"){if(0 === actual) break b;}
       else if(1 !== actual[0]){
        var
         actual2 = actual[2],
         actual1 = actual[1],
         let_syntax_001 = go(expected1, actual1),
         let_syntax_002 = go(expected2, actual2),
         _ah_ = function(param){return caml_call1(return$0, 0);},
         _ai_ = caml_call2(Error[2][4], let_syntax_001, let_syntax_002);
        return caml_call2(Error[2][1], _ai_, _ah_);
       }
       break a;
      }
      if(typeof actual === "number" && ! actual)
       return caml_call1(return$0, 0);
     }
     var _ag_ = caml_call1(Type[2], actual);
     return caml_call5
             (error, origin, vertex, _a_, caml_call1(Type[2], expected), _ag_);
    }
    return go(actual, expected);
   }
   function maybe_unknown(ts){
    if(ts && ! ts[2]){var t = ts[1]; return t;}
    return 0;
   }
   function match_fail(loc, sort, vertex){
    if(caml_call1(Lang[2][7], vertex[2]) === sort){
     var
      _ab_ = caml_call1(Uuid[1][6], vertex[1]),
      _ac_ = caml_call1(Lang[2][2], vertex[2]),
      _ad_ = caml_call4(Stdlib_Printf[4], _b_, loc, _ac_, _ab_);
     return caml_call1(Stdlib[2], _ad_);
    }
    var
     _ae_ = caml_call1(Lang[2][2], vertex[2]),
     _af_ = caml_call3(Stdlib_Printf[4], _c_, loc, _ae_);
    return caml_call1(Stdlib[2], _af_);
   }
   function eval_typ_vertex(graph, vertex){
    var ___ = vertex[2];
    if(typeof ___ === "number" && 8 <= ___)
     switch(___ - 8 | 0){
       case 0:
        return caml_call1(return$0, 1);
       case 1:
        var
         let_syntax_004 = eval_typ_cursor(graph, [0, vertex, 18]),
         let_syntax_005 = eval_typ_cursor(graph, [0, vertex, 19]),
         _$_ =
           function(param){
            var t_result = param[2], t_arg = param[1];
            return caml_call1(return$0, [0, t_arg, t_result]);
           },
         _aa_ = caml_call2(Error[2][4], let_syntax_004, let_syntax_005);
        return caml_call2(Error[2][1], _aa_, _$_);
     }
    return match_fail(cst_File_src_grvcore_type_Type, 3, vertex);
   }
   function eval_typ_cursor(graph, cursor){
    var
     _W_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]),
     edges = caml_call1(Edge[7][23], _W_);
    function go(edge){return eval_typ_vertex(graph, edge[2][2]);}
    function _X_(ts){return caml_call1(return$0, maybe_unknown(ts));}
    var
     _Y_ = caml_call2(Stdlib_List[19], go, edges),
     _Z_ = caml_call1(Error[7], _Y_);
    return caml_call2(Error[2][1], _Z_, _X_);
   }
   function ana_pat_vertex(graph, env, vertex, typ){
    var match = vertex[2];
    if(typeof match !== "number" && 2 === match[0]){
     var string = match[1];
     return caml_call1(return$0, caml_call3(Env[5], string, typ, env));
    }
    return match_fail(cst_File_src_grvcore_type_Type$0, 2, vertex);
   }
   function ana_pat_cursor(graph, env, cursor, typ){
    var
     _S_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]),
     edges = caml_call1(Edge[7][23], _S_),
     _T_ = caml_call1(return$0, env);
    function _U_(env, edge){
     function _V_(env){return ana_pat_vertex(graph, env, edge[2][2], typ);}
     return caml_call2(Error[2][1], env, _V_);
    }
    return caml_call3(Stdlib_List[25], _U_, _T_, edges);
   }
   function syn_exp_vertex(graph, env, vertex){
    var match = vertex[2];
    if(typeof match === "number")
     switch(match){
       case 1:
        var
         _E_ =
           function(typ){
            function _O_(env){
             function _Q_(body){return caml_call1(return$0, [0, typ, body]);}
             var _R_ = syn_exp_cursor(graph, env, [0, vertex, 3]);
             return caml_call2(Error[2][1], _R_, _Q_);
            }
            var _P_ = ana_pat_cursor(graph, env, [0, vertex, 1], typ);
            return caml_call2(Error[2][1], _P_, _O_);
           },
         _F_ = eval_typ_cursor(graph, [0, vertex, 2]);
        return caml_call2(Error[2][1], _F_, _E_);
       case 2:
        var
         _G_ =
           function(func){
            a:
            {
             var
              _K_ =
                function(param){
                 var result_type = param[2], param_type = param[1];
                 function _M_(param){
                  return caml_call1(return$0, result_type);
                 }
                 var
                  _N_ = ana_exp_cursor(graph, env, [0, vertex, 5], param_type);
                 return caml_call2(Error[2][1], _N_, _M_);
                };
             if(typeof func === "number"){
              if(0 === func){var _L_ = caml_call1(return$0, _d_); break a;}
             }
             else if(0 === func[0]){
              var
               result_type = func[2],
               param_type = func[1],
               _L_ = caml_call1(return$0, [0, param_type, result_type]);
              break a;
             }
             var
              _L_ =
                caml_call4
                 (error,
                  cst_File_src_grvcore_type_Type$2,
                  vertex,
                  _e_,
                  caml_call1(Type[2], func));
            }
            return caml_call2(Error[2][1], _L_, _K_);
           },
         _H_ = syn_exp_cursor(graph, env, [0, vertex, 4]);
        return caml_call2(Error[2][1], _H_, _G_);
       case 3:
        var
         let_syntax_015 = ana_exp_cursor(graph, env, [0, vertex, 6], 1),
         let_syntax_016 = ana_exp_cursor(graph, env, [0, vertex, 7], 1),
         _I_ = function(param){return caml_call1(return$0, 1);},
         _J_ = caml_call2(Error[2][4], let_syntax_015, let_syntax_016);
        return caml_call2(Error[2][1], _J_, _I_);
     }
    else
     switch(match[0]){
       case 0:
        var string = match[1], match$0 = caml_call2(Env[30], string, env);
        if(! match$0)
         return caml_call4
                 (error,
                  cst_File_src_grvcore_type_Type$3,
                  vertex,
                  _f_,
                  string);
        var t = match$0[1];
        return caml_call1(return$0, t);
       case 1:
        return caml_call1(return$0, 1);
     }
    return match_fail(cst_File_src_grvcore_type_Type$1, 1, vertex);
   }
   function ana_exp_vertex(graph, env, vertex, typ){
    var _x_ = vertex[2];
    if(typeof _x_ === "number" && 6 === _x_){
     a:
     {
      var
       _y_ =
         function(content){
          function _C_(param){return caml_call1(return$0, 0);}
          var _D_ = ana_exp_cursor(graph, env, [0, vertex, 10], content);
          return caml_call2(Error[2][1], _D_, _C_);
         };
      if(typeof typ === "number"){
       if(0 === typ){var _z_ = caml_call1(return$0, 0); break a;}
      }
      else if(1 === typ[0]){
       var t = typ[1], _z_ = caml_call1(return$0, t);
       break a;
      }
      var
       _z_ =
         caml_call4
          (error,
           cst_File_src_grvcore_type_Type$4,
           vertex,
           _g_,
           caml_call1(Type[2], typ));
     }
     return caml_call2(Error[2][1], _z_, _y_);
    }
    function _A_(typ$0){
     return consistent(cst_File_src_grvcore_type_Type$5, vertex, typ, typ$0);
    }
    var _B_ = syn_exp_vertex(graph, env, vertex);
    return caml_call2(Error[2][1], _B_, _A_);
   }
   function syn_exp_cursor(graph, env, cursor){
    var
     _t_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]),
     edges = caml_call1(Edge[7][23], _t_);
    function go(edge){return syn_exp_vertex(graph, env, edge[2][2]);}
    function _u_(ts){return caml_call1(return$0, maybe_unknown(ts));}
    var
     _v_ = caml_call2(Stdlib_List[19], go, edges),
     _w_ = caml_call1(Error[7], _v_);
    return caml_call2(Error[2][1], _w_, _u_);
   }
   function ana_exp_cursor(graph, env, cursor, typ){
    var
     _m_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]),
     edges = caml_call1(Edge[7][23], _m_);
    function _n_(param){return caml_call1(return$0, 0);}
    var _o_ = caml_call1(return$0, 0);
    function _p_(previous_result, edge){
     var let_syntax_024 = ana_exp_vertex(graph, env, edge[2][2], typ);
     function _r_(param){return caml_call1(return$0, 0);}
     var _s_ = caml_call2(Error[2][4], previous_result, let_syntax_024);
     return caml_call2(Error[2][1], _s_, _r_);
    }
    var _q_ = caml_call3(Stdlib_List[25], _p_, _o_, edges);
    return caml_call2(Error[2][1], _q_, _n_);
   }
   function syn_root_vertex(graph, env, vertex){
    var _l_ = vertex[2];
    if(typeof _l_ === "number" && ! _l_)
     return syn_exp_cursor(graph, env, [0, vertex, 0]);
    return match_fail(cst_File_src_grvcore_type_Type$6, 0, vertex);
   }
   function syn_root_cursor(graph, env, cursor){
    var
     _h_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]),
     edges = caml_call1(Edge[7][23], _h_);
    function go(edge){return syn_root_vertex(graph, env, edge[2][2]);}
    function _i_(ts){return caml_call1(return$0, maybe_unknown(ts));}
    var
     _j_ = caml_call2(Stdlib_List[19], go, edges),
     _k_ = caml_call1(Error[7], _j_);
    return caml_call2(Error[2][1], _k_, _i_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Type_check =
      [0,
       error,
       return$0,
       consistent,
       maybe_unknown,
       match_fail,
       eval_typ_vertex,
       eval_typ_cursor,
       ana_pat_vertex,
       ana_pat_cursor,
       syn_exp_vertex,
       ana_exp_vertex,
       syn_exp_cursor,
       ana_exp_cursor,
       syn_root_vertex,
       syn_root_cursor];
   runtime.caml_register_global(29, Type_check, "Type_check");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Position_map
//# unitInfo: Requires: Lang, Ppx_inline_test_lib__Runtime, Stdlib__Map, Stdlib__Option
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Option = global_data.Stdlib__Option,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Lang = global_data.Lang,
    Stdlib_Map = global_data.Stdlib__Map;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    compare = Lang[3][4],
    OrderedType = [0, compare],
    include = caml_call1(Stdlib_Map[1], OrderedType),
    empty = include[1],
    is_empty = include[2],
    mem = include[3],
    add = include[4],
    update = include[5],
    singleton = include[6],
    remove = include[7],
    merge = include[8],
    union = include[9],
    compare$0 = include[10],
    equal = include[11],
    iter = include[12],
    fold = include[13],
    for_all = include[14],
    exists = include[15],
    filter = include[16],
    filter_map = include[17],
    partition = include[18],
    cardinal = include[19],
    bindings = include[20],
    min_binding = include[21],
    min_binding_opt = include[22],
    max_binding = include[23],
    max_binding_opt = include[24],
    choose = include[25],
    choose_opt = include[26],
    split = include[27],
    find = include[28],
    find_opt = include[29],
    find_first = include[30],
    find_first_opt = include[31],
    find_last = include[32],
    find_last_opt = include[33],
    map = include[34],
    mapi = include[35],
    to_seq = include[36],
    to_rev_seq = include[37],
    to_seq_from = include[38],
    add_seq = include[39],
    of_seq = include[40],
    cst_grvcore = cst_grvcore$0;
   function get(opt, position){
    if(opt) var sth = opt[1], default$0 = sth; else var default$0 = 0;
    return function(map){
     var _b_ = caml_call2(find_opt, position, map);
     return caml_call2(Stdlib_Option[3], _b_, default$0);};
   }
   function push(position, x, map){
    var xs = get(0, position)(map), _a_ = caml_call2(remove, position, map);
    return caml_call1(caml_call2(add, position, [0, x, xs]), _a_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Position_map =
      [0,
       empty,
       is_empty,
       mem,
       add,
       update,
       singleton,
       remove,
       merge,
       union,
       compare$0,
       equal,
       iter,
       fold,
       for_all,
       exists,
       filter,
       filter_map,
       partition,
       cardinal,
       bindings,
       min_binding,
       min_binding_opt,
       max_binding,
       max_binding_opt,
       choose,
       choose_opt,
       split,
       find,
       find_opt,
       find_first,
       find_first_opt,
       find_last,
       find_last_opt,
       map,
       mapi,
       to_seq,
       to_rev_seq,
       to_seq_from,
       add_seq,
       of_seq,
       get,
       push];
   runtime.caml_register_global(7, Position_map, "Position_map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tree
//# unitInfo: Requires: Lang, Position_map, Ppx_inline_test_lib__Runtime, Stdlib, Stdlib__Format, Stdlib__List, Stdlib__String, Uuid
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_Vertex = "Vertex(",
    cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = "}",
    cst$2 = " | ",
    cst$3 = "{",
    cst$0 = "\xe2\x96\xa1",
    cst$4 = "; ",
    cst$5 = "#",
    cst = cst$6,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Lang = global_data.Lang,
    Stdlib_Format = global_data.Stdlib__Format,
    Position_map = global_data.Position_map,
    Uuid = global_data.Uuid,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _c_ = [0, [2, 0, [11, " -> ", [2, 0, 0]]], "%s -> %s"],
    _e_ = [0, [11, cst_Vertex, [2, 0, [12, 41, 0]]], "Vertex(%s)"],
    _d_ =
      [0,
       [11, cst_Vertex, [2, 0, [11, ", ", [2, 0, [12, 41, 0]]]]],
       "Vertex(%s, %s)"],
    cst_grvcore = cst_grvcore$0;
   function child(edge_id, tree){return [0, edge_id, tree];}
   var _a_ = Position_map[1];
   function _b_(children, param){
    var child_specs = param[2], position = param[1];
    function _p_(children, param){
     var tree = param[2], edge_id = param[1];
     return caml_call3
             (Position_map[42], position, [0, edge_id, tree], children);
    }
    return caml_call3(Stdlib_List[25], _p_, children, child_specs);
   }
   var child_map = caml_call2(Stdlib_List[25], _b_, _a_);
   function vertex(vertex, children){
    return [0, vertex, caml_call1(child_map, children)];
   }
   function to_string(param){
    if(0 === param[0]){
     var
      map = param[2],
      vertex = param[1],
      _f_ = caml_call1(Position_map[20], map),
      _g_ =
        function(param){
         var
          tree_children = param[2],
          position = param[1],
          match = caml_call1(Stdlib_List[1], tree_children);
         if(0 === match)
          var _j_ = cst$0;
         else if(1 === match)
          var
           child = caml_call1(Stdlib_List[5], tree_children),
           _j_ = to_string(child[2]);
         else
          var
           _l_ = function(param){var tree = param[2]; return tree;},
           childs = caml_call2(Stdlib_List[19], _l_, tree_children),
           _m_ = caml_call2(Stdlib_List[19], to_string, childs),
           _n_ = caml_call1(caml_call1(Stdlib_String[6], cst$2), _m_),
           _o_ = caml_call2(Stdlib[28], _n_, cst$1),
           _j_ = caml_call2(Stdlib[28], cst$3, _o_);
         var _k_ = caml_call1(Lang[3][7], position);
         return caml_call3(Stdlib_Format[138], _c_, _k_, _j_);
        },
      _h_ = caml_call1(caml_call1(Stdlib_List[19], _g_), _f_),
      children = caml_call1(caml_call1(Stdlib_String[6], cst$4), _h_),
      id = caml_call1(Uuid[1][6], vertex[1]);
     return runtime.caml_string_notequal(children, cst$6)
             ? caml_call3(Stdlib_Format[138], _d_, id, children)
             : caml_call2(Stdlib_Format[138], _e_, id);
    }
    var vertex$0 = param[1], _i_ = caml_call1(Uuid[1][6], vertex$0[1]);
    return caml_call2(Stdlib[28], cst$5, _i_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Tree = [0, child, child_map, vertex, to_string];
   runtime.caml_register_global(21, Tree, "Tree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: State
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var State = [0];
   runtime.caml_register_global(4, State, "State");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Editor
//# unitInfo: Requires: Cursor, Graph, Graph_action, Ppx_inline_test_lib__Runtime, Sexplib__Std, Stdlib, Stdlib__List, Uuid
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Graph_action = global_data.Graph_action,
    Cursor = global_data.Cursor,
    Graph = global_data.Graph,
    Uuid = global_data.Uuid,
    Stdlib = global_data.Stdlib,
    Sexplib_Std = global_data.Sexplib__Std,
    Stdlib_List = global_data.Stdlib__List,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    cst_File_src_grvcore_app_Edito$0 =
      'File "src/grvcore/app/Editor.ml", line 58, characters 23-30',
    cst_File_src_grvcore_app_Edito =
      'File "src/grvcore/app/Editor.ml", line 46, characters 18-25',
    cst_grvcore = cst_grvcore$0;
   function sexp_of_t(editor){
    var
     _v_ = [0, caml_call1(Sexplib_Std[6], editor[6]), 0],
     _w_ = caml_call1(Graph_action[4][23], editor[5]),
     _x_ = [0, caml_call2(Sexplib_Std[39], Graph_action[2], _w_), _v_],
     _y_ = caml_call1(Graph_action[4][23], editor[4]),
     _z_ = [0, caml_call2(Sexplib_Std[39], Graph_action[2], _y_), _x_],
     _A_ = [0, caml_call1(Cursor[2], editor[3]), _z_],
     _B_ = [0, caml_call1(Graph[14], editor[2]), _A_];
    return [1, [0, caml_call1(Uuid[1][2], editor[1]), _B_]];
   }
   function t_of_sexp(param){
    if(1 === param[0]){
     var _n_ = param[1];
     if(_n_){
      var _o_ = _n_[2];
      if(_o_){
       var _p_ = _o_[2];
       if(_p_){
        var _q_ = _p_[2];
        if(_q_){
         var _r_ = _q_[2];
         if(_r_){
          var _s_ = _r_[2];
          if(_s_ && ! _s_[2]){
           var
            show_ids_sexp = _s_[1],
            known_actions_sexp = _r_[1],
            actions_sexp = _q_[1],
            cursor_sexp = _p_[1],
            graph_sexp = _o_[1],
            id_sexp = _n_[1],
            id = caml_call1(Uuid[1][1], id_sexp),
            graph = caml_call1(Graph[15], graph_sexp),
            cursor = caml_call1(Cursor[1], cursor_sexp),
            _t_ = caml_call2(Sexplib_Std[40], Graph_action[1], actions_sexp),
            actions = caml_call1(Graph_action[4][37], _t_),
            _u_ =
              caml_call2(Sexplib_Std[40], Graph_action[1], known_actions_sexp),
            known_actions = caml_call1(Graph_action[4][37], _u_),
            show_ids = caml_call1(Sexplib_Std[7], show_ids_sexp);
           return [0, id, graph, cursor, actions, known_actions, show_ids];
          }
         }
        }
       }
      }
     }
    }
    return caml_call1(Stdlib[2], cst_File_src_grvcore_app_Edito);
   }
   function sexp_of_map(editors){
    var _k_ = caml_call1(Uuid[2][20], editors);
    function _l_(param){
     var editor = param[2], id = param[1], _m_ = [0, sexp_of_t(editor), 0];
     return [1, [0, caml_call1(Uuid[1][2], id), _m_]];
    }
    return caml_call1(caml_call1(Sexplib_Std[39], _l_), _k_);
   }
   function map_of_sexp(sexp){
    function _e_(param){
     if(1 === param[0]){
      var _h_ = param[1];
      if(_h_){
       var _i_ = _h_[2];
       if(_i_ && ! _i_[2]){
        var
         editor_sexp = _i_[1],
         id_sexp = _h_[1],
         _j_ = t_of_sexp(editor_sexp);
        return [0, caml_call1(Uuid[1][1], id_sexp), _j_];
       }
      }
     }
     return caml_call1(Stdlib[2], cst_File_src_grvcore_app_Edito$0);
    }
    var
     _f_ = caml_call1(caml_call1(Sexplib_Std[40], _e_), sexp),
     _g_ = caml_call1(Stdlib_List[61], _f_);
    return caml_call1(Uuid[2][40], _g_);
   }
   function mk(param){
    var
     _a_ = Graph_action[4][1],
     _b_ = Graph_action[4][1],
     _c_ = Cursor[4],
     _d_ = Graph[1];
    return [0, caml_call1(Uuid[1][4], 0), _d_, _c_, _b_, _a_, 0];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Editor = [0, sexp_of_t, t_of_sexp, sexp_of_map, map_of_sexp, mk];
   runtime.caml_register_global(13, Editor, "Editor");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Model
//# unitInfo: Requires: Editor, Graph_action, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib__Std, Stdlib, Stdlib__List, Uuid
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    error_source_007 = "src/grvcore/app/Model.ml.graph_action_sequence",
    Uuid = global_data.Uuid,
    Stdlib_List = global_data.Stdlib__List,
    Graph_action = global_data.Graph_action,
    Editor = global_data.Editor,
    Sexplib_Std = global_data.Sexplib__Std,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _a_ = [0, 0],
    cst_File_src_grvcore_app_Model =
      'File "src/grvcore/app/Model.ml", line 25, characters 18-25',
    cst_grvcore = cst_grvcore$0;
   function graph_action_sequence_of_sexp(x_008){
    function _s_(sexp_006){
     if(1 === sexp_006[0]){
      var _t_ = sexp_006[1];
      if(_t_){
       var _u_ = _t_[2];
       if(_u_ && ! _u_[2]){
        var
         arg1_003 = _u_[1],
         arg0_002 = _t_[1],
         res0_004 = caml_call1(Uuid[1][1], arg0_002),
         res1_005 = caml_call1(Graph_action[1], arg1_003);
        return [0, res0_004, res1_005];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[2], error_source_007, 2, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv[44], _s_, x_008);
   }
   function sexp_of_graph_action_sequence(x_013){
    function _r_(param){
     var
      arg1_010 = param[2],
      arg0_009 = param[1],
      res0_011 = caml_call1(Uuid[1][2], arg0_009),
      res1_012 = caml_call1(Graph_action[2], arg1_010);
     return [1, [0, res0_011, [0, res1_012, 0]]];
    }
    return caml_call2(Sexplib0_Sexp_conv[20], _r_, x_013);
   }
   function sexp_of_t(model){
    var
     _q_ =
       [0,
        caml_call2
         (Sexplib0_Sexp_conv[17], sexp_of_graph_action_sequence, model[2]),
        0];
    return [1, [0, caml_call1(Editor[3], model[1]), _q_]];
   }
   function t_of_sexp(param){
    if(1 === param[0]){
     var _o_ = param[1];
     if(_o_){
      var _p_ = _o_[2];
      if(_p_ && ! _p_[2]){
       var
        actions_sexp = _p_[1],
        editors_sexp = _o_[1],
        editors = caml_call1(Editor[4], editors_sexp),
        actions =
          caml_call2
           (Sexplib_Std[37], graph_action_sequence_of_sexp, actions_sexp);
       return [0, editors, actions];
      }
     }
    }
    return caml_call1(Stdlib[2], cst_File_src_grvcore_app_Model);
   }
   function mk(param){
    var
     editor1 = caml_call1(Editor[5], 0),
     editor2 = caml_call1(Editor[5], 0),
     _m_ = Uuid[2][1],
     _n_ = caml_call1(caml_call2(Uuid[2][4], editor1[1], editor1), _m_),
     editors = caml_call1(caml_call2(Uuid[2][4], editor2[1], editor2), _n_);
    return [0, editors, _a_];
   }
   function cutoff(m1, m2){return m1 === m2 ? 1 : 0;}
   function filter_editor_actions(globally_known, editor){
    var _k_ = editor[4];
    function _l_(a){
     return 1 - caml_call2(Graph_action[4][3], a, globally_known);
    }
    var actions = caml_call1(caml_call1(Graph_action[4][19], _l_), _k_);
    return [0, editor[1], editor[2], editor[3], actions, editor[5], editor[6]];
   }
   function globally_known_actions(model){
    var _e_ = caml_call1(Uuid[2][20], model[1]);
    function _f_(_j_){return _j_[2];}
    var _g_ = caml_call1(caml_call1(Stdlib_List[19], _f_), _e_);
    function _h_(param){var known_actions = param[5]; return known_actions;}
    var
     knowns = caml_call1(caml_call1(Stdlib_List[19], _h_), _g_),
     _i_ = caml_call1(Stdlib_List[5], knowns);
    return caml_call3(Stdlib_List[25], Graph_action[4][8], _i_, knowns);
   }
   function remove_known_actions(model){
    var known_actions = globally_known_actions(model), _b_ = model[1];
    function _c_(_d_){return filter_editor_actions(known_actions, _d_);}
    var editors = caml_call2(Uuid[2][34], _c_, _b_);
    return [0, editors, model[2]];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Model =
      [0,
       graph_action_sequence_of_sexp,
       sexp_of_graph_action_sequence,
       sexp_of_t,
       t_of_sexp,
       mk,
       cutoff,
       filter_editor_actions,
       globally_known_actions,
       remove_known_actions];
   runtime.caml_register_global(15, Model, "Model");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Grove
//# unitInfo: Requires: Assert_failure, Edge, Graph, Inline_test_config, Position_map, Ppx_inline_test_lib__Runtime, Stdlib, Stdlib__List, Stdlib__Option, Tree, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "\n",
    cst_D$1 = "D",
    cst_MP$1 = "MP",
    cst_R$1 = "R",
    cst_SC$1 = "SC",
    cst_grvcore$0 = "grvcore",
    cst_src_grvcore_graph_Grove_ml$10 = "src/grvcore/graph/Grove.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "\n  ",
    cst$2 = ":",
    cst$3 = cst$5,
    cst$0 = ": ",
    cst$1 = cst$5,
    cst = "",
    Vertex = global_data.Vertex,
    Stdlib_Option = global_data.Stdlib__Option,
    Edge = global_data.Edge,
    Tree = global_data.Tree,
    Position_map = global_data.Position_map,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Graph = global_data.Graph,
    Inline_test_config = global_data.Inline_test_config,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib = global_data.Stdlib;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _c_ = [0, cst_src_grvcore_graph_Grove_ml$10, 118, 8],
    _d_ = [0, cst_src_grvcore_graph_Grove_ml$10, 116, 14],
    cst_src_grvcore_graph_Grove_ml$3 = cst_src_grvcore_graph_Grove_ml$10,
    cst_multiparented = "multiparented",
    cst_src_grvcore_graph_Grove_ml$4 = cst_src_grvcore_graph_Grove_ml$10,
    cst_deleted_e01 = "deleted e01",
    cst_src_grvcore_graph_Grove_ml$5 = cst_src_grvcore_graph_Grove_ml$10,
    cst_reachable_e01_deleted_e12 = "reachable e01 deleted e12",
    cst_src_grvcore_graph_Grove_ml$6 = cst_src_grvcore_graph_Grove_ml$10,
    cst_reachable_e01_e12 = "reachable e01 e12",
    cst_src_grvcore_graph_Grove_ml$7 = cst_src_grvcore_graph_Grove_ml$10,
    cst_wreaths = "wreaths",
    cst_src_grvcore_graph_Grove_ml$0 = cst_src_grvcore_graph_Grove_ml$10,
    cst_deleted = "deleted",
    cst_src_grvcore_graph_Grove_ml$1 = cst_src_grvcore_graph_Grove_ml$10,
    cst_reachable = "reachable",
    cst_GOT = "\n\n--\nGOT:",
    cst_MP = cst_MP$1,
    cst_D = cst_D$1,
    cst_R = cst_R$1,
    cst_SC = cst_SC$1,
    cst_WANT = "\n\nWANT:",
    cst_MP$0 = cst_MP$1,
    cst_D$0 = cst_D$1,
    cst_R$0 = cst_R$1,
    cst_SC$0 = cst_SC$1,
    cst_src_grvcore_graph_Grove_ml = cst_src_grvcore_graph_Grove_ml$10,
    cst_empty_graph = "empty graph",
    cst_src_grvcore_graph_Grove_ml$2 = cst_src_grvcore_graph_Grove_ml$10,
    cst_one_vertex = "one vertex",
    cst_src_grvcore_graph_Grove_ml$8 = cst_src_grvcore_graph_Grove_ml$10,
    cst_two_vertexes = "two vertexes",
    _a_ = [0, 1],
    _b_ = [0, 0],
    cst_src_grvcore_graph_Grove_ml$9 = cst_src_grvcore_graph_Grove_ml$10,
    cst_Graph_decompose = "Graph.decompose",
    cst_grvcore = cst_grvcore$0;
   function push_edge(vertex, edge){
    function _at_(param){
     if(! param) return [0, caml_call1(Edge[7][5], edge)];
     var edges = param[1];
     return [0, caml_call2(Edge[7][4], edge, edges)];
    }
    return caml_call2(Vertex[5][5], vertex, _at_);
   }
   function push_vertex(vertex, param, in_degrees){
    var
     av = param[3],
     univ = param[2],
     multiv = param[1],
     match = caml_call2(Vertex[5][29], vertex, in_degrees);
    return match
            ? match
               [1]
              ? [0, caml_call2(Vertex[6][4], vertex, multiv), univ, av]
              : [0, multiv, caml_call2(Vertex[6][4], vertex, univ), av]
            : [0, multiv, univ, caml_call2(Vertex[6][4], vertex, av)];
   }
   function traverse_vertex(opt, _an_, vertex){
    if(opt) var sth = opt[1], seen = sth; else var seen = Vertex[6][1];
    if(_an_)
     var sth$0 = _an_[1], remaining = sth$0;
    else
     var remaining = Vertex[6][1];
    return function(children){
     if(caml_call2(Vertex[6][3], vertex, seen))
      return [0, [1, vertex], seen, remaining];
     var
      seen$0 = caml_call2(Vertex[6][4], vertex, seen),
      remaining$0 = caml_call2(Vertex[6][6], vertex, remaining),
      _ao_ = caml_call2(Vertex[5][29], vertex, children),
      edges = caml_call2(Stdlib_Option[3], _ao_, Edge[7][1]),
      _ap_ = caml_call1(Edge[7][23], edges),
      _aq_ = [0, Position_map[1], seen$0, remaining$0];
     function _ar_(param, edge){
      var
       remaining = param[3],
       seen = param[2],
       tree_children = param[1],
       match =
         traverse_vertex([0, seen], [0, remaining], edge[2][2])(children),
       remaining$0 = match[3],
       seen$0 = match[2],
       tree = match[1],
       _as_ = caml_call2(Tree[1], edge[1], tree),
       tree_children$0 =
         caml_call3(Position_map[42], edge[2][1][2], _as_, tree_children);
      return [0, tree_children$0, seen$0, remaining$0];
     }
     var
      match = caml_call1(caml_call2(Stdlib_List[25], _ar_, _aq_), _ap_),
      remaining$1 = match[3],
      seen$1 = match[2],
      children$0 = match[1];
     return [0, [0, vertex, children$0], seen$1, remaining$1];};
   }
   function traverse_vertexes(seen, remaining, vertexes, children){
    var match = caml_call1(Vertex[6][29], vertexes);
    if(! match) return [0, 0, seen, remaining];
    var
     vertex = match[1],
     match$0 = traverse_vertex([0, seen], [0, remaining], vertex)(children),
     remaining$0 = match$0[3],
     seen$0 = match$0[2],
     tree = match$0[1],
     roots = caml_call2(Vertex[6][6], vertex, vertexes),
     match$1 = traverse_vertexes(seen$0, remaining$0, roots, children),
     remaining$1 = match$1[3],
     seen$1 = match$1[2],
     trees = match$1[1];
    return [0, [0, tree, trees], seen$1, remaining$1];
   }
   function wreath_traverse(seen$1, remaining, parents, children){
    if(caml_call1(Vertex[6][2], remaining)) return 0;
    var
     vertex$1 = caml_call1(Vertex[6][24], remaining),
     seen = remaining,
     vertex = vertex$1;
    for(;;){
     if(caml_call2(Vertex[6][3], vertex, seen)){
      var
       match$0 =
         traverse_vertex([0, seen$1], [0, remaining], vertex)(children),
       remaining$0 = match$0[3],
       seen$2 = match$0[2],
       tree = match$0[1];
      return [0,
              tree,
              wreath_traverse(seen$2, remaining$0, parents, children)];
     }
     var match = caml_call2(Vertex[5][29], vertex, parents);
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var edges = match[1];
     if(1 !== caml_call1(Edge[7][22], edges))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var
      edge = caml_call1(Edge[7][24], edges),
      seen$0 = caml_call2(Vertex[6][4], vertex, seen),
      vertex$0 = edge[2][1][1],
      seen = seen$0,
      vertex = vertex$0;
    }
   }
   function decompose(graph){
    var
     all_edges = caml_call1(Graph[4], graph),
     live_edges = caml_call1(Graph[5], graph),
     _af_ = [0, Vertex[5][1], Vertex[5][1]];
    function _ag_(edge, param){
     var
      children = param[2],
      parents = param[1],
      _am_ = caml_call1(push_edge(edge[2][1][1], edge), children);
     return [0, caml_call1(push_edge(edge[2][2], edge), parents), _am_];
    }
    var
     match = caml_call1(caml_call2(Edge[7][16], _ag_, live_edges), _af_),
     children = match[2],
     parents = match[1],
     _ah_ = Vertex[5][1];
    function _ai_(edge, map){
     function _al_(param){return param ? _a_ : _b_;}
     return caml_call1(caml_call2(Vertex[5][5], edge[2][2], _al_), map);
    }
    var
     in_degrees = caml_call1(caml_call2(Edge[7][16], _ai_, live_edges), _ah_),
     _aj_ = [0, Vertex[6][1], Vertex[6][1], Vertex[6][1]];
    function _ak_(edge, param){
     var
      av = param[3],
      univ = param[2],
      multiv = param[1],
      match = push_vertex(edge[2][2], [0, multiv, univ, av], in_degrees),
      av$0 = match[3],
      univ$0 = match[2],
      multiv$0 = match[1];
     return push_vertex
             (edge[2][1][1], [0, multiv$0, univ$0, av$0], in_degrees);
    }
    var
     match$0 = caml_call1(caml_call2(Edge[7][16], _ak_, all_edges), _aj_),
     av = match$0[3],
     univ = match$0[2],
     multiv = match$0[1],
     av$0 = caml_call2(Vertex[6][6], Vertex[4], av),
     match$1 = traverse_vertexes(Vertex[6][1], univ, multiv, children),
     remaining = match$1[3],
     seen = match$1[2],
     multiparented = match$1[1],
     match$2 = traverse_vertexes(seen, remaining, av$0, children),
     remaining$0 = match$2[3],
     seen$0 = match$2[2],
     deleted = match$2[1],
     match$3 =
       traverse_vertex([0, seen$0], [0, remaining$0], Vertex[4])(children),
     remaining$1 = match$3[3],
     seen$1 = match$3[2],
     reachable = match$3[1],
     wreaths = wreath_traverse(seen$1, remaining$1, parents, children);
    return [0, [0, multiparented, deleted, reachable, wreaths], children];
   }
   function _e_(param){
    function report_tree(prefix, tree){
     var
      _ab_ = caml_call1(Tree[4], tree),
      _ac_ = caml_call2(Stdlib[28], cst$0, _ab_),
      _ad_ = caml_call2(Stdlib[28], prefix, _ac_),
      _ae_ = caml_call2(Stdlib[28], cst$1, _ad_);
     return caml_call1(Stdlib[42], _ae_);
    }
    function report_trees(prefix, trees){
     var
      _Y_ = caml_call2(Stdlib[28], prefix, cst$2),
      _Z_ = caml_call2(Stdlib[28], cst$3, _Y_);
     caml_call1(Stdlib[42], _Z_);
     function ___(tree){
      var
       _$_ = caml_call1(Tree[4], tree),
       _aa_ = caml_call2(Stdlib[28], cst$4, _$_);
      return caml_call1(Stdlib[42], _aa_);
     }
     return caml_call2(Stdlib_List[17], ___, trees);
    }
    function check_decompose(opt, _V_, _U_, _T_, graph){
     if(opt)
      var sth = opt[1], multiparented = sth;
     else
      var multiparented = 0;
     if(_V_) var sth$0 = _V_[1], deleted = sth$0; else var deleted = 0;
     if(_U_)
      var sth$1 = _U_[1], reachable = sth$1;
     else
      var reachable = [0, Vertex[4], Position_map[1]];
     if(_T_) var sth$2 = _T_[1], wreaths = sth$2; else var wreaths = 0;
     var
      got = decompose(graph)[1],
      want = [0, multiparented, deleted, reachable, wreaths],
      _W_ = runtime.caml_equal(got, want),
      _X_ =
        _W_
        ||
         (caml_call1(Stdlib[42], cst_GOT),
          report_trees(cst_MP, got[1]),
          report_trees(cst_D, got[2]),
          report_tree(cst_R, got[3]),
          report_trees(cst_SC, got[4]),
          caml_call1(Stdlib[42], cst_WANT),
          report_trees(cst_MP$0, multiparented),
          report_trees(cst_D$0, deleted),
          report_tree(cst_R$0, reachable),
          report_trees(cst_SC$0, wreaths),
          0);
     return _X_;
    }
    var
     v0 = Vertex[4],
     v1 = caml_call1(Vertex[3], 3),
     v2 = caml_call1(Vertex[3], 4),
     e01 = caml_call2(Edge[5], [0, v0, 0], v1),
     e12 = caml_call2(Edge[5], [0, v1, 6], v2),
     e12$0 = caml_call2(Edge[5], [0, v1, 7], v2),
     e21 = caml_call2(Edge[5], [0, v2, 8], v1);
    function _f_(param){return check_decompose(0, 0, 0, 0, Graph[1]);}
    caml_call8
     (Ppx_inline_test_lib_Runtime[4],
      Inline_test_config,
      cst_empty_graph,
      0,
      cst_src_grvcore_graph_Grove_ml,
      196,
      4,
      56,
      _f_);
    function _g_(param){
     function _M_(param){
      var _R_ = Graph[1], _S_ = caml_call1(caml_call2(Graph[2], e01, 1), _R_);
      return check_decompose
              (0, [0, [0, caml_call2(Tree[3], v1, 0), 0]], 0, 0, _S_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_deleted,
       0,
       cst_src_grvcore_graph_Grove_ml$0,
       202,
       8,
       142,
       _M_);
     function _N_(param){
      var
       _O_ = Graph[1],
       _P_ = caml_call1(caml_call2(Graph[2], e01, 0), _O_),
       _Q_ = caml_call2(Tree[3], v1, 0);
      return check_decompose
              (0,
               0,
               [0,
                caml_call2
                 (Tree[3], v0, [0, [0, 0, [0, [0, e01[1], _Q_], 0]], 0])],
               0,
               _P_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_reachable,
       0,
       cst_src_grvcore_graph_Grove_ml$1,
       207,
       8,
       227,
       _N_);
     return 0;
    }
    caml_call8
     (Ppx_inline_test_lib_Runtime[6],
      Inline_test_config,
      cst_one_vertex,
      0,
      cst_src_grvcore_graph_Grove_ml$2,
      198,
      4,
      505,
      _g_);
    function _h_(param){
     function _i_(param){
      var
       _G_ = Graph[1],
       _H_ = caml_call1(caml_call2(Graph[2], e01, 0), _G_),
       _I_ = caml_call1(caml_call2(Graph[2], e12, 0), _H_),
       _J_ = caml_call1(caml_call2(Graph[2], e12$0, 0), _I_),
       _K_ =
         caml_call2
          (Tree[3],
           v1,
           [0,
            [0, 6, [0, [0, e12[1], [1, v2]], 0]],
            [0, [0, 7, [0, [0, e12$0[1], [1, v2]], 0]], 0]]),
       _L_ =
         [0,
          caml_call2(Tree[3], v0, [0, [0, 0, [0, [0, e01[1], _K_], 0]], 0])];
      return check_decompose
              ([0, [0, caml_call2(Tree[3], v2, 0), 0]], 0, _L_, 0, _J_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_multiparented,
       0,
       cst_src_grvcore_graph_Grove_ml$3,
       217,
       8,
       659,
       _i_);
     function _j_(param){
      var
       _C_ = Graph[1],
       _D_ = caml_call1(caml_call2(Graph[2], e01, 1), _C_),
       _E_ = caml_call1(caml_call2(Graph[2], e12, 0), _D_),
       _F_ = caml_call2(Tree[3], v2, 0);
      return check_decompose
              (0,
               [0,
                [0,
                 caml_call2
                  (Tree[3], v1, [0, [0, 6, [0, [0, e12[1], _F_], 0]], 0]),
                 0]],
               0,
               0,
               _E_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_deleted_e01,
       0,
       cst_src_grvcore_graph_Grove_ml$4,
       236,
       8,
       279,
       _j_);
     function _k_(param){
      var
       _x_ = Graph[1],
       _y_ = caml_call1(caml_call2(Graph[2], e01, 0), _x_),
       _z_ = caml_call1(caml_call2(Graph[2], e12, 1), _y_),
       _A_ = caml_call2(Tree[3], v1, 0),
       _B_ =
         [0,
          caml_call2(Tree[3], v0, [0, [0, 0, [0, [0, e01[1], _A_], 0]], 0])];
      return check_decompose
              (0, [0, [0, caml_call2(Tree[3], v2, 0), 0]], _B_, 0, _z_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_reachable_e01_deleted_e12,
       0,
       cst_src_grvcore_graph_Grove_ml$5,
       245,
       8,
       305,
       _k_);
     function _l_(param){
      var
       _s_ = Graph[1],
       _t_ = caml_call1(caml_call2(Graph[2], e01, 0), _s_),
       _u_ = caml_call1(caml_call2(Graph[2], e12, 0), _t_),
       _v_ = caml_call2(Tree[3], v2, 0),
       _w_ = caml_call2(Tree[3], v1, [0, [0, 6, [0, [0, e12[1], _v_], 0]], 0]);
      return check_decompose
              (0,
               0,
               [0,
                caml_call2
                 (Tree[3], v0, [0, [0, 0, [0, [0, e01[1], _w_], 0]], 0])],
               0,
               _u_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_reachable_e01_e12,
       0,
       cst_src_grvcore_graph_Grove_ml$6,
       253,
       8,
       486,
       _l_);
     function _m_(param){
      var
       _n_ = Graph[1],
       _o_ = caml_call1(caml_call2(Graph[2], e01, 1), _n_),
       _p_ = caml_call1(caml_call2(Graph[2], e12, 0), _o_),
       _q_ = caml_call1(caml_call2(Graph[2], e21, 0), _p_),
       _r_ =
         caml_call2(Tree[3], v2, [0, [0, 8, [0, [0, e21[1], [1, v1]], 0]], 0]);
      return check_decompose
              (0,
               0,
               0,
               [0,
                [0,
                 caml_call2
                  (Tree[3], v1, [0, [0, 6, [0, [0, e12[1], _r_], 0]], 0]),
                 0]],
               _q_);
     }
     caml_call8
      (Ppx_inline_test_lib_Runtime[4],
       Inline_test_config,
       cst_wreaths,
       0,
       cst_src_grvcore_graph_Grove_ml$7,
       268,
       8,
       515,
       _m_);
     return 0;
    }
    caml_call8
     (Ppx_inline_test_lib_Runtime[6],
      Inline_test_config,
      cst_two_vertexes,
      0,
      cst_src_grvcore_graph_Grove_ml$8,
      215,
      4,
      2320,
      _h_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[6],
     Inline_test_config,
     cst_Graph_decompose,
     0,
     cst_src_grvcore_graph_Grove_ml$9,
     157,
     0,
     4488,
     _e_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var Grove = [0, traverse_vertex, decompose];
   runtime.caml_register_global(55, Grove, "Grove");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Formalism
//# unitInfo: Requires: Ppx_inline_test_lib__Runtime, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_grvcore$0 = "grvcore",
    caml_compare = runtime.caml_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Set = global_data.Stdlib__Set,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Stdlib_Map = global_data.Stdlib__Map;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    Sort = [0],
    _f_ = [0, 0],
    _g_ = [0, [0, [0, 0]]],
    _h_ = [0, [0, [1, 0]]],
    _i_ = [0, [0, [2, 0]]],
    _j_ = [0, [0, [3, 0]]],
    _k_ = [0, [1, [0, 0]]],
    _a_ = [0, [0, [0, 0]], [0, [0, [0, 1]], [0, [0, [0, 2]], 0]]],
    _b_ = [0, [0, [1, 0]], [0, [0, [1, 1]], 0]],
    _c_ = [0, [0, [2, 0]], [0, [0, [2, 1]], 0]],
    _d_ = [0, [0, [3, 0]], [0, [0, [3, 1]], 0]],
    _e_ = [0, [1, [0, 0]], [0, [1, [0, 1]], 0]],
    cst_grvcore = cst_grvcore$0;
   function sort(param){
    if(typeof param !== "number" && 1 === param[0]) return 2;
    return 0;
   }
   var
    Position = [0, sort],
    compare = caml_compare,
    Arity = caml_call1(Stdlib_Set[1], [0, compare]);
   function sort$0(param){
    if(typeof param !== "number")
     switch(param[0]){case 1: return 1;case 2: return 2;}
    return 0;
   }
   function arity(param){
    if(typeof param === "number") return caml_call1(Arity[5], 0);
    switch(param[0]){
      case 0:
       var _m_ = param[1];
       if(typeof _m_ === "number")
        switch(_m_){
          case 0:
           return caml_call1(Arity[37], _a_);
          case 1:
           return caml_call1(Arity[37], _b_);
          case 2:
           return caml_call1(Arity[37], _c_);
          default: return caml_call1(Arity[37], _d_);
        }
       return 0 === _m_[0] ? Arity[1] : Arity[1];
      case 1:
       return Arity[1];
      default: return param[1] ? Arity[1] : caml_call1(Arity[37], _e_);
    }
   }
   function default_position(param){
    if(typeof param === "number") return _f_;
    switch(param[0]){
      case 0:
       var _l_ = param[1];
       if(typeof _l_ === "number")
        switch(_l_){
          case 0:
           return _g_;
          case 1:
           return _h_;
          case 2:
           return _i_;
          default: return _j_;
        }
       return 0 === _l_[0] ? 0 : 0;
      case 1:
       return 0;
      default: return param[1] ? 0 : _k_;
    }
   }
   var
    Constructor = [0, sort$0, arity, default_position],
    Id = [0],
    Vertex = [0],
    Edge_state = [0],
    compare$0 = caml_compare,
    Map = caml_call1(Stdlib_Map[1], [0, compare$0]),
    Edge = [0, Map],
    Graph = [0];
   function Conflict(T){
    var
     compare = T[1],
     include = caml_call1(Stdlib_Set[1], [0, compare]),
     empty = include[1],
     is_empty = include[2],
     mem = include[3],
     add = include[4],
     singleton = include[5],
     remove = include[6],
     union = include[7],
     inter = include[8],
     disjoint = include[9],
     diff = include[10],
     compare$0 = include[11],
     equal = include[12],
     subset = include[13],
     iter = include[14],
     map = include[15],
     fold = include[16],
     for_all = include[17],
     exists = include[18],
     filter = include[19],
     filter_map = include[20],
     partition = include[21],
     cardinal = include[22],
     elements = include[23],
     min_elt = include[24],
     min_elt_opt = include[25],
     max_elt = include[26],
     max_elt_opt = include[27],
     choose = include[28],
     choose_opt = include[29],
     split = include[30],
     find = include[31],
     find_opt = include[32],
     find_first = include[33],
     find_first_opt = include[34],
     find_last = include[35],
     find_last_opt = include[36],
     of_list = include[37],
     to_seq_from = include[38],
     to_seq = include[39],
     to_rev_seq = include[40],
     add_seq = include[41],
     of_seq = include[42];
    return [0,
            empty,
            is_empty,
            mem,
            add,
            singleton,
            remove,
            union,
            inter,
            disjoint,
            diff,
            compare$0,
            equal,
            subset,
            iter,
            map,
            fold,
            for_all,
            exists,
            filter,
            filter_map,
            partition,
            cardinal,
            elements,
            min_elt,
            min_elt_opt,
            max_elt,
            max_elt_opt,
            choose,
            choose_opt,
            split,
            find,
            find_opt,
            find_first,
            find_first_opt,
            find_last,
            find_last_opt,
            of_list,
            to_seq_from,
            to_seq,
            to_rev_seq,
            add_seq,
            of_seq];
   }
   var
    compare$1 = caml_compare,
    T = [0, compare$1],
    Conflict$0 = Conflict(T),
    Pat = [0, T, Conflict$0],
    compare$2 = caml_compare,
    T$0 = [0, compare$2],
    Conflict$1 = Conflict(T$0),
    Typ = [0, T$0, Conflict$1],
    compare$3 = caml_compare,
    T$1 = [0, compare$3],
    Conflict$2 = Conflict(T$1),
    Exp = [0, T$1, Conflict$2];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Formalism =
      [0,
       Sort,
       Position,
       Arity,
       Constructor,
       Id,
       Vertex,
       Edge_state,
       Edge,
       Graph,
       Conflict,
       Pat,
       Typ,
       Exp];
   runtime.caml_register_global(17, Formalism, "Formalism");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Action
//# unitInfo: Requires: Cursor, Edge, Graph, Graph_action, Lang, Model, Ppx_inline_test_lib__Runtime, Sexplib0__Sexp_conv, Sexplib__Sexp, Stdlib, Stdlib__List, Stdlib__Option, Stdlib__Printf, Util, Uuid, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_already_recording = "(already recording)\n",
    cst_already_stopped = "(already stopped)\n",
    cst_Recording = "Recording...\n",
    cst_Stopped = "Stopped!\n",
    cst_grvcore$0 = "grvcore";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Option = global_data.Stdlib__Option,
    Uuid = global_data.Uuid,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Util = global_data.Util,
    Model = global_data.Model,
    Sexplib_Sexp = global_data.Sexplib__Sexp,
    Stdlib_List = global_data.Stdlib__List,
    Edge = global_data.Edge,
    Graph = global_data.Graph,
    Lang = global_data.Lang,
    Vertex = global_data.Vertex,
    Stdlib = global_data.Stdlib,
    Graph_action = global_data.Graph_action,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Cursor = global_data.Cursor,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_grvcore$0, cst);
   var
    _A_ = [0, [11, cst_already_recording, 0], cst_already_recording],
    _B_ = [0, [11, cst_Recording, 0], cst_Recording],
    _C_ = [0, 0],
    _D_ = [0, [11, cst_Stopped, 0], cst_Stopped],
    _E_ = [0, [11, cst_already_stopped, 0], cst_already_stopped],
    _z_ = [0, 0],
    _x_ = [0, "action"],
    _y_ = [0, "editor_id"],
    _t_ = [0, "Move"],
    _u_ = [0, "Edit"],
    _v_ = [0, "Comm"],
    _w_ = [0, "Env"],
    _k_ = [0, "Record"],
    _l_ = [0, "Report"],
    _m_ = [0, "Stop"],
    _n_ = [0, "Dump"],
    _o_ = [0, "Replay"],
    _p_ = [0, "Load"],
    _q_ = [0, "Clone"],
    _r_ = [0, "Drop"],
    _s_ = [0, "ToggleIds"],
    _j_ = [0, "Send"],
    _f_ = [0, "Destroy"],
    _g_ = [0, "Create"],
    _h_ = [0, "Restore"],
    _i_ = [0, "DropEdge"],
    _a_ = [0, "Left"],
    _b_ = [0, "Right"],
    _c_ = [0, "Up"],
    _d_ = [0, "Down"],
    _e_ = [0, "Select"],
    cst_grvcore = cst_grvcore$0;
   function sexp_of_move(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return _a_;
       case 1:
        return _b_;
       case 2:
        return _c_;
       default: return _d_;
     }
    var arg0_001 = param[1], res0_002 = caml_call1(Cursor[2], arg0_001);
    return [1, [0, _e_, [0, res0_002, 0]]];
   }
   function sexp_of_edit(param){
    if(typeof param === "number") return _f_;
    switch(param[0]){
      case 0:
       var arg0_003 = param[1], res0_004 = caml_call1(Lang[2][6], arg0_003);
       return [1, [0, _g_, [0, res0_004, 0]]];
      case 1:
       var arg0_005 = param[1], res0_006 = caml_call1(Vertex[2], arg0_005);
       return [1, [0, _h_, [0, res0_006, 0]]];
      default:
       var arg0_007 = param[1], res0_008 = caml_call1(Uuid[1][2], arg0_007);
       return [1, [0, _i_, [0, res0_008, 0]]];
    }
   }
   function sexp_of_comm(param){
    var
     arg1_010 = param[2],
     arg0_009 = param[1],
     res0_011 = caml_call2(Sexplib0_Sexp_conv[20], Graph_action[2], arg0_009),
     res1_012 = caml_call2(Sexplib0_Sexp_conv[20], Uuid[1][2], arg1_010);
    return [1, [0, _j_, [0, res0_011, [0, res1_012, 0]]]];
   }
   function sexp_of_env(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return _k_;
       case 1:
        return _l_;
       case 2:
        return _m_;
       default: return _n_;
     }
    switch(param[0]){
      case 0:
       var
        arg0_013 = param[1],
        res0_014 = caml_call1(Sexplib0_Sexp_conv[7], arg0_013);
       return [1, [0, _o_, [0, res0_014, 0]]];
      case 1:
       var
        arg0_015 = param[1],
        res0_016 = caml_call1(Sexplib0_Sexp_conv[7], arg0_015);
       return [1, [0, _p_, [0, res0_016, 0]]];
      case 2:
       var arg0_017 = param[1], res0_018 = caml_call1(Uuid[1][2], arg0_017);
       return [1, [0, _q_, [0, res0_018, 0]]];
      case 3:
       var arg0_019 = param[1], res0_020 = caml_call1(Uuid[1][2], arg0_019);
       return [1, [0, _r_, [0, res0_020, 0]]];
      default:
       var arg0_021 = param[1], res0_022 = caml_call1(Uuid[1][2], arg0_021);
       return [1, [0, _s_, [0, res0_022, 0]]];
    }
   }
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_023 = param[1], res0_024 = sexp_of_move(arg0_023);
       return [1, [0, _t_, [0, res0_024, 0]]];
      case 1:
       var arg0_025 = param[1], res0_026 = sexp_of_edit(arg0_025);
       return [1, [0, _u_, [0, res0_026, 0]]];
      case 2:
       var arg0_027 = param[1], res0_028 = sexp_of_comm(arg0_027);
       return [1, [0, _v_, [0, res0_028, 0]]];
      default:
       var arg0_029 = param[1], res0_030 = sexp_of_env(arg0_029);
       return [1, [0, _w_, [0, res0_030, 0]]];
    }
   }
   function sexp_of_t$0(param){
    var
     action_034 = param[2],
     editor_id_032 = param[1],
     arg_035 = sexp_of_t(action_034),
     bnds_031 = [0, [1, [0, _x_, [0, arg_035, 0]]], 0],
     arg_033 = caml_call1(Uuid[1][2], editor_id_032),
     bnds_031$0 = [0, [1, [0, _y_, [0, arg_033, 0]]], bnds_031];
    return [1, bnds_031$0];
   }
   function apply_graph_action(graph_action, editor){
    var
     graph = caml_call2(Graph[3], editor[2], graph_action),
     known_actions = caml_call2(Graph_action[4][4], graph_action, editor[5]),
     actions = caml_call2(Graph_action[4][4], graph_action, editor[4]);
    return [0, editor[1], graph, editor[3], actions, known_actions, editor[6]];
   }
   function record_actions(model, editor_id, graph_actions){
    var _aB_ = model[2];
    function _aC_(actions){
     function _aD_(x){return [0, editor_id, x];}
     var new_actions = caml_call2(Stdlib_List[19], _aD_, graph_actions);
     return caml_call2(Stdlib[37], new_actions, actions);
    }
    return caml_call2(Util[3][1][1][2], _aC_, _aB_);
   }
   function report_actions(actions){
    var _aA_ = caml_call1(Model[2], actions);
    return caml_call1(Util[2][1], _aA_);
   }
   function replay_actions(model, actions){
    var _av_ = [0, model];
    function _aw_(model, param){
     var graph_action = param[2], editor_id = param[1];
     function _ax_(model){
      function _ay_(editor){
       var
        editor$0 = apply_graph_action(graph_action, editor),
        editors = caml_call3(Uuid[2][4], editor_id, editor$0, model[1]),
        actions = record_actions(model, editor_id, [0, graph_action, 0]);
       return [0, [0, editors, actions]];
      }
      var _az_ = caml_call2(Uuid[2][29], editor_id, model[1]);
      return caml_call2(Util[3][1][1][3], _az_, _ay_);
     }
     return caml_call2(Util[3][1][1][3], model, _ax_);
    }
    return caml_call3(Stdlib_List[25], _aw_, _av_, actions);
   }
   function apply_move(model, editor_id, move_action){
    function _ai_(editor){
     var cursor = editor[3];
     if(typeof move_action === "number")
      switch(move_action){
        case 0:
         var
          _ak_ = caml_call1(Lang[3][14], editor[3][2]),
          _al_ = function(position){return [0, cursor[1], position];},
          cursor$0 = caml_call2(Util[3][1][1][2], _al_, _ak_);
         break;
        case 1:
         var
          _an_ = caml_call1(Lang[3][13], editor[3][2]),
          _ao_ = function(position){return [0, cursor[1], position];},
          cursor$0 = caml_call2(Util[3][1][1][2], _ao_, _an_);
         break;
        case 2:
         var
          _ap_ = caml_call2(Graph[6], editor[2], editor[3][1]),
          match = caml_call1(Edge[7][23], _ap_);
         a:
         {
          if(match && ! match[2]){
           var edge = match[1], _aq_ = [0, edge[2][1]];
           break a;
          }
          var _aq_ = 0;
         }
         var cursor$0 = _aq_;
         break;
        default:
         var
          _ar_ = caml_call3(Graph[7], editor[2], cursor[1], cursor[2]),
          match$0 = caml_call1(Edge[7][23], _ar_);
         a:
         {
          if(match$0 && ! match$0[2]){
           var
            edge$0 = match$0[1],
            vertex = edge$0[2][2],
            _at_ = caml_call1(Lang[3][12], vertex[2]),
            _au_ = function(position){return [0, vertex, position];},
            _as_ = caml_call2(Util[3][1][1][2], _au_, _at_);
           break a;
          }
          var _as_ = 0;
         }
         var cursor$0 = _as_;
      }
     else
      var cursor$1 = move_action[1], cursor$0 = [0, cursor$1];
     function _am_(cursor){
      var
       editors =
         caml_call3
          (Uuid[2][4],
           editor_id,
           [0, editor[1], editor[2], cursor, editor[4], editor[5], editor[6]],
           model[1]);
      return [0, editors, model[2]];
     }
     return caml_call2(Util[3][1][1][2], _am_, cursor$0);
    }
    var _aj_ = caml_call2(Uuid[2][29], editor_id, model[1]);
    return caml_call2(Util[3][1][1][3], _aj_, _ai_);
   }
   function apply_edit(model, editor_id, edit_action){
    function _X_(editor){
     var
      children = caml_call3(Graph[7], editor[2], editor[3][1], editor[3][2]);
     if(typeof edit_action === "number")
      var
       _Z_ = caml_call3(Graph[7], editor[2], editor[3][1], editor[3][2]),
       ___ = caml_call1(Edge[7][23], _Z_),
       _$_ = function(edge){return [0, edge, 1];},
       graph_actions = caml_call1(caml_call1(Stdlib_List[19], _$_), ___),
       move_in = 0;
     else
      switch(edit_action[0]){
        case 0:
         var
          constructor = edit_action[1],
          _aa_ = caml_call1(Lang[2][7], constructor);
         if(caml_call1(Lang[3][10], editor[3][2]) === _aa_){
          var
           vertex = caml_call1(Vertex[3], constructor),
           create_parent_edge =
             [0, [0, caml_call2(Edge[5], editor[3], vertex), 0], 0],
           match = caml_call1(Lang[3][11], constructor);
          if(match)
           var
            position = match[1],
            _ab_ = caml_call1(Edge[7][23], children),
            _ac_ =
              function(edge){
               var
                source = [0, vertex, position],
                edge$0 = caml_call2(Edge[5], source, edge[2][2]);
               return [0, edge$0, 0];
              },
            create_new_children_edges =
              caml_call1(caml_call1(Stdlib_List[19], _ac_), _ab_),
            _ad_ = caml_call1(Edge[7][23], children),
            _ae_ = function(edge){return [0, edge, 1];},
            destroy_old_children_edges =
              caml_call1(caml_call1(Stdlib_List[19], _ae_), _ad_),
            _af_ =
              caml_call2
               (Stdlib[37],
                create_new_children_edges,
                destroy_old_children_edges),
            graph_actions = caml_call2(Stdlib[37], create_parent_edge, _af_),
            move_in = 1;
          else
           var graph_actions = create_parent_edge, move_in = 0;
         }
         else
          var graph_actions = 0, move_in = 0;
         break;
        case 1:
         var
          vertex$0 = edit_action[1],
          edge = caml_call2(Edge[5], editor[3], vertex$0),
          graph_actions = [0, [0, edge, 0], 0],
          move_in = 0;
         break;
        default:
         var
          edge_id = edit_action[1],
          _ag_ = caml_call1(Graph[4], editor[2]),
          _ah_ = function(edge){return runtime.caml_equal(edge[1], edge_id);},
          match$0 = caml_call1(caml_call1(Edge[7][34], _ah_), _ag_);
         if(match$0)
          var edge$0 = match$0[1], graph_actions$0 = [0, [0, edge$0, 1], 0];
         else
          var graph_actions$0 = 0;
         var graph_actions = graph_actions$0, move_in = 0;
      }
     var
      editor$0 =
        caml_call3(Stdlib_List[26], apply_graph_action, graph_actions, editor),
      editors = caml_call3(Uuid[2][4], editor_id, editor$0, model[1]),
      actions = record_actions(model, editor$0[1], graph_actions),
      model$0 = [0, editors, actions];
     return move_in ? apply_move(model$0, editor_id, 3) : [0, model$0];
    }
    var _Y_ = caml_call2(Uuid[2][29], editor_id, model[1]);
    return caml_call2(Util[3][1][1][3], _Y_, _X_);
   }
   function apply_comm(model, editor_id, comm_action){
    var editor_ids = comm_action[2], edit_actions = comm_action[1];
    function _P_(editors_opt, editor_id){
     function _U_(editors){
      var _V_ = caml_call2(Uuid[2][29], editor_id, model[1]);
      function _W_(editor){return [0, editor, editors];}
      return caml_call2(Util[3][1][1][2], _W_, _V_);
     }
     return caml_call2(Util[3][1][1][3], editors_opt, _U_);
    }
    var _Q_ = caml_call3(Stdlib_List[25], _P_, _z_, editor_ids);
    function _R_(editors){
     function _S_(model, editor){
      var
       editor$0 =
         caml_call3(Stdlib_List[26], apply_graph_action, edit_actions, editor),
       _T_ = caml_call2(Uuid[2][7], editor$0[1], model[1]),
       editors =
         caml_call1(caml_call2(Uuid[2][4], editor$0[1], editor$0), _T_),
       model$0 = [0, editors, model[2]],
       actions = record_actions(model$0, editor_id, edit_actions);
      return [0, model$0[1], actions];
     }
     var model$0 = caml_call3(Stdlib_List[25], _S_, model, editors);
     return caml_call1(Model[9], model$0);
    }
    return caml_call2(Util[3][1][1][2], _R_, _Q_);
   }
   function apply_env(model, env_action){
    if(typeof env_action !== "number")
     switch(env_action[0]){
       case 0:
        var str = env_action[1], _I_ = caml_call1(Sexplib_Sexp[43], str);
        return replay_actions(model, caml_call1(Model[1], _I_));
       case 1:
        var str$0 = env_action[1], _J_ = caml_call1(Sexplib_Sexp[43], str$0);
        return [0, caml_call1(Model[4], _J_)];
       case 2:
        var
         editor_id = env_action[1],
         _K_ = caml_call2(Uuid[2][29], editor_id, model[1]),
         _L_ =
           function(editor){
            var
             id = caml_call1(Uuid[1][4], 0),
             editor$0 =
               [0, id, editor[2], editor[3], editor[4], editor[5], editor[6]],
             editors = caml_call3(Uuid[2][4], id, editor$0, model[1]);
            return [0, editors, model[2]];
           };
        return caml_call2(Util[3][1][1][2], _L_, _K_);
       case 3:
        var
         editor_id$0 = env_action[1],
         editors = caml_call2(Uuid[2][7], editor_id$0, model[1]);
        return [0, [0, editors, model[2]]];
       default:
        var
         editor_id$1 = env_action[1],
         _M_ = model[1],
         _N_ =
           function(editor){
            return [0,
                    editor[1],
                    editor[2],
                    editor[3],
                    editor[4],
                    editor[5],
                    1 - editor[6]];
           },
         _O_ = caml_call1(Stdlib_Option[7], _N_),
         editors$0 = caml_call1(caml_call2(Uuid[2][5], editor_id$1, _O_), _M_);
        return [0, [0, editors$0, model[2]]];
     }
    switch(env_action){
      case 0:
       return model[2]
               ? (caml_call1(Stdlib_Printf[2], _A_), 0)
               : (caml_call1(Stdlib_Printf[2], _B_), [0, [0, model[1], _C_]]);
      case 1:
       var _G_ = function(actions){report_actions(actions); return 0;};
       return caml_call2(Util[3][1][1][3], model[2], _G_);
      case 2:
       var match = model[2];
       if(match){
        var actions = match[1];
        report_actions(actions);
        caml_call1(Stdlib_Printf[2], _D_);
        return [0, [0, model[1], 0]];
       }
       caml_call1(Stdlib_Printf[2], _E_);
       return 0;
      default:
       var _H_ = caml_call1(Model[3], model);
       caml_call1(Util[2][1], _H_);
       return 0;
    }
   }
   function apply(model, action, state, param){
    var match = action[2];
    switch(match[0]){
      case 0:
       var
        move_action = match[1],
        _F_ = apply_move(model, action[1], move_action);
       break;
      case 1:
       var
        edit_action = match[1],
        _F_ = apply_edit(model, action[1], edit_action);
       break;
      case 2:
       var
        comm_action = match[1],
        _F_ = apply_comm(model, action[1], comm_action);
       break;
      default: var env_action = match[1], _F_ = apply_env(model, env_action);
    }
    return caml_call2(Stdlib_Option[3], _F_, model);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_grvcore);
   var
    Action =
      [0,
       sexp_of_move,
       sexp_of_edit,
       sexp_of_comm,
       sexp_of_env,
       sexp_of_t,
       sexp_of_t$0,
       apply_graph_action,
       record_actions,
       report_actions,
       replay_actions,
       apply_move,
       apply_edit,
       apply_comm,
       apply_env,
       apply];
   runtime.caml_register_global(50, Action, "Action");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuZ3J2Y29yZS5vYmpzL2pzb28vZGVmYXVsdC9ncnZjb3JlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJvcl9zb3VyY2VfMDAzIiwiZXJyb3Jfc291cmNlXzAyOCIsInBwIiwiZm10Iiwic2hvdyIsIngiLCJlcXVhbCIsImxocyIsInJocyIsImNvbXBhcmUiLCJ0b19pbnQiLCJzZXhwX29mX3QiLCJwcCQwIiwiYTAiLCJhMCQwIiwiYTAkMSIsInNob3ckMCIsImVxdWFsJDAiLCJyaHMwIiwibGhzMCIsInJoczAkMCIsImxoczAkMCIsInJoczAkMSIsImxoczAkMSIsImNvbXBhcmUkMCIsInRfb2Zfc2V4cCIsInNleHBfMDA1IiwidGFnXzAwNiIsInNleHBfYXJnc18wMDciLCJhcmcwXzAwOCIsInJlczBfMDA5Iiwic2V4cF9hcmdzXzAxNyIsImFyZzBfMDE4IiwicmVzMF8wMTkiLCJzZXhwX2FyZ3NfMDEyIiwiYXJnMF8wMTMiLCJyZXMwXzAxNCIsInNleHBfb2ZfdCQwIiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZzBfMDIyIiwicmVzMF8wMjMiLCJhcmcwXzAyNCIsInJlczBfMDI1Iiwic29ydF9vZiIsImMiLCJncmFwaHZpel9sYWJlbCIsImFyZzAiLCJhcmcwJDAiLCJhcmcwJDEiLCJwcCQxIiwic2hvdyQxIiwiZXF1YWwkMSIsImNvbXBhcmUkMSIsInRfb2Zfc2V4cCQwIiwic2V4cF8wMjkiLCJzZXhwX29mX3QkMSIsInNob3J0X25hbWUiLCJpIiwicGFyZW50X2NvbnN0cnVjdG9yIiwiY2hpbGRfcG9zaXRpb25zIiwiY2hpbGRfc29ydCIsImRlZmF1bHRfcG9zaXRpb24iLCJkb3duIiwicmlnaHQiLCJsZWZ0IiwicHBfcm9vdF9yb290Iiwic2hvd19yb290X3Jvb3QiLCJlcXVhbF9yb290X3Jvb3QiLCJjb21wYXJlX3Jvb3Rfcm9vdCIsInNleHBfb2Zfcm9vdF9yb290IiwicHBfZXhwX3ZhciIsInNob3dfZXhwX3ZhciIsImVxdWFsX2V4cF92YXIiLCJjb21wYXJlX2V4cF92YXIiLCJzZXhwX29mX2V4cF92YXIiLCJwcF9leHBfbGFtIiwic2hvd19leHBfbGFtIiwiZXF1YWxfZXhwX2xhbSIsImNvbXBhcmVfZXhwX2xhbSIsInNleHBfb2ZfZXhwX2xhbSIsInBwX2V4cF9hcHAiLCJzaG93X2V4cF9hcHAiLCJlcXVhbF9leHBfYXBwIiwiY29tcGFyZV9leHBfYXBwIiwic2V4cF9vZl9leHBfYXBwIiwicHBfZXhwX251bSIsInNob3dfZXhwX251bSIsImVxdWFsX2V4cF9udW0iLCJjb21wYXJlX2V4cF9udW0iLCJzZXhwX29mX2V4cF9udW0iLCJwcF9leHBfcGx1cyIsInNob3dfZXhwX3BsdXMiLCJlcXVhbF9leHBfcGx1cyIsImNvbXBhcmVfZXhwX3BsdXMiLCJzZXhwX29mX2V4cF9wbHVzIiwicHBfZXhwX3RpbWVzIiwic2hvd19leHBfdGltZXMiLCJlcXVhbF9leHBfdGltZXMiLCJjb21wYXJlX2V4cF90aW1lcyIsInNleHBfb2ZfZXhwX3RpbWVzIiwicHBfZXhwX25pbCIsInNob3dfZXhwX25pbCIsImVxdWFsX2V4cF9uaWwiLCJjb21wYXJlX2V4cF9uaWwiLCJzZXhwX29mX2V4cF9uaWwiLCJwcF9leHBfY29ucyIsInNob3dfZXhwX2NvbnMiLCJlcXVhbF9leHBfY29ucyIsImNvbXBhcmVfZXhwX2NvbnMiLCJzZXhwX29mX2V4cF9jb25zIiwicHBfZXhwX2Nhc2UiLCJzaG93X2V4cF9jYXNlIiwiZXF1YWxfZXhwX2Nhc2UiLCJjb21wYXJlX2V4cF9jYXNlIiwic2V4cF9vZl9leHBfY2FzZSIsInBwX3BhdF92YXIiLCJzaG93X3BhdF92YXIiLCJlcXVhbF9wYXRfdmFyIiwiY29tcGFyZV9wYXRfdmFyIiwic2V4cF9vZl9wYXRfdmFyIiwicHBfdHlwX251bSIsInNob3dfdHlwX251bSIsImVxdWFsX3R5cF9udW0iLCJjb21wYXJlX3R5cF9udW0iLCJzZXhwX29mX3R5cF9udW0iLCJwcF90eXBfYXJyb3ciLCJzaG93X3R5cF9hcnJvdyIsImVxdWFsX3R5cF9hcnJvdyIsImNvbXBhcmVfdHlwX2Fycm93Iiwic2V4cF9vZl90eXBfYXJyb3ciLCJwcF90eXBfbGlzdCIsInNob3dfdHlwX2xpc3QiLCJlcXVhbF90eXBfbGlzdCIsImNvbXBhcmVfdHlwX2xpc3QiLCJzZXhwX29mX3R5cF9saXN0Iiwic2hvdyQyIiwic3RyaW5nIiwiYXJnIiwicG9zaXRpb24iLCJlcnJvcl9zb3VyY2VfMDE3Iiwic2VlZCIsIm5leHQiLCJ3ZWxsX2tub3duIiwiaW50JDAiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmciLCJ3cmFwX29mX3NleHAiLCJvZl9hXzAwMiIsInNleHBfMDA0IiwiZmllbGRfc2V4cHNfMDA1IiwiaWRfMDA2IiwidmFsdWVfMDA4IiwiZHVwbGljYXRlc18wMTAiLCJleHRyYV8wMTEiLCJzZXhwXzAwNCQwIiwiZmllbGRfc2V4cHNfMDE0IiwiZmllbGRfbmFtZV8wMTIiLCJ0YWlsXzAxOSIsImZpZWxkX3NleHBfMDEzJDIiLCJmaWVsZF9zZXhwXzAxMyIsInhfMDIwIiwiZmllbGRfc2V4cF8wMTMkMCIsImZ2YWx1ZV8wMTUiLCJmaWVsZF9zZXhwXzAxMyQxIiwiZnZhbHVlXzAxNiIsInZhbHVlXzAwOSIsImlkXzAwNyIsInNleHBfb2Zfd3JhcCIsIm9mX2FfMDIxIiwidmFsdWVfMDI1IiwiaWRfMDIzIiwiYXJnXzAyNiIsImJuZHNfMDIyIiwiYXJnXzAyNCIsImJuZHNfMDIyJDAiLCJ1MSIsInUyIiwid3JhcCIsImEiLCJ1bndyYXAiLCJ1Iiwid2VsbF9rbm93biQwIiwieF8wMDIiLCJ4XzAwMyIsIm1rIiwicm9vdCIsInZlcnRleCIsInNldF90b19zdHJpbmciLCJ2ZXJ0ZXhlcyIsInN0cnMiLCJ2IiwidnMiLCJpbnRlcnNwZXJzZSIsImRlbGltIiwieHMiLCJ4cyQwIiwicHJpbnQiLCJzZXhwIiwib2ZfbWFwIiwiYmluZGluZ3MiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsdWUiLCJrIiwicmV0dXJuJDAiLCJvIiwibWFwIiwiZiIsImJpbmQiLCJlcnJvcl9zb3VyY2VfMDE1Iiwic2V4cF8wMDIiLCJmaWVsZF9zZXhwc18wMDMiLCJ2ZXJ0ZXhfMDA0IiwicG9zaXRpb25fMDA2IiwiZHVwbGljYXRlc18wMDgiLCJleHRyYV8wMDkiLCJzZXhwXzAwMiQwIiwiZmllbGRfc2V4cHNfMDEyIiwiZmllbGRfbmFtZV8wMTAiLCJ0YWlsXzAxNyIsImZpZWxkX3NleHBfMDExJDIiLCJmaWVsZF9zZXhwXzAxMSIsInhfMDE4IiwiZmllbGRfc2V4cF8wMTEkMCIsImZ2YWx1ZV8wMTQiLCJmaWVsZF9zZXhwXzAxMSQxIiwiZnZhbHVlXzAxMyIsInBvc2l0aW9uXzAwNyIsInZlcnRleF8wMDUiLCJwb3NpdGlvbl8wMjIiLCJ2ZXJ0ZXhfMDIwIiwiYXJnXzAyMyIsImJuZHNfMDE5IiwiYXJnXzAyMSIsImJuZHNfMDE5JDAiLCJjdXJzb3IiLCJzb3VyY2VfMDA0IiwidGFyZ2V0XzAwNiIsInRhcmdldF8wMDciLCJzb3VyY2VfMDA1IiwidGFyZ2V0XzAyMiIsInNvdXJjZV8wMjAiLCJ4XzAyNSIsInhfMDI2Iiwic291cmNlIiwidGFyZ2V0IiwicGFydGl0aW9uX3NldCIsImVkZ2VzIiwicGl2b3QiLCJlZGdlIiwidW5pb25fc2V0cyIsInNldHMiLCJlcnJvciIsIm9yaWdpbiIsIm1lc3NhZ2UiLCJlcyIsImJvdGgiLCJvMSIsIm8yIiwiZXMxIiwiZXMyJDAiLCJvMSQwIiwibzIkMCIsImVzMiIsImJpbmQkMCIsInJldHVybiQxIiwibWFwJDAiLCJib3RoJDAiLCJzZXF1ZW5jZSIsImxldF9zeW50YXhfMDAyIiwiZWRnZV8wMDQiLCJzdGF0ZV8wMDYiLCJzdGF0ZV8wMDciLCJlZGdlXzAwNSIsInN0YXRlXzAyMiIsImVkZ2VfMDIwIiwiZWRnZV9hY3Rpb24iLCJlbXB0eSIsImFkZCIsImFwcGx5X2FjdGlvbiIsImdyYXBoIiwiYWN0aW9uIiwib2xkX3N0YXRlIiwibmV3X3N0YXRlIiwibGl2ZV9lZGdlcyIsInBhcmVudF9lZGdlcyIsImNoaWxkX2VkZ2VzIiwiaW1wbCIsImVkZ2Vfc291cmNlIiwibGl2ZV92ZXJ0ZXhlcyIsInBhcmVudF92ZXJ0ZXhlcyIsImUiLCJkZWxldGVkIiwibXVsdGlwYXJlbnRlZCIsImNvdW50IiwidmVydGV4X2lkIiwidmFsdWVfc2V4cCIsImtleV9zZXhwIiwiYTEiLCJjb25zaXN0ZW50IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJnbyIsImV4cGVjdGVkMiIsImV4cGVjdGVkMSIsImFjdHVhbDIiLCJhY3R1YWwxIiwibGV0X3N5bnRheF8wMDEiLCJtYXliZV91bmtub3duIiwidHMiLCJ0IiwibWF0Y2hfZmFpbCIsImxvYyIsInNvcnQiLCJldmFsX3R5cF92ZXJ0ZXgiLCJsZXRfc3ludGF4XzAwNCIsImV2YWxfdHlwX2N1cnNvciIsImxldF9zeW50YXhfMDA1IiwidF9yZXN1bHQiLCJ0X2FyZyIsImFuYV9wYXRfdmVydGV4IiwiZW52IiwidHlwIiwiYW5hX3BhdF9jdXJzb3IiLCJzeW5fZXhwX3ZlcnRleCIsImJvZHkiLCJzeW5fZXhwX2N1cnNvciIsImZ1bmMiLCJyZXN1bHRfdHlwZSIsInBhcmFtX3R5cGUiLCJhbmFfZXhwX2N1cnNvciIsImxldF9zeW50YXhfMDE1IiwibGV0X3N5bnRheF8wMTYiLCJhbmFfZXhwX3ZlcnRleCIsImNvbnRlbnQiLCJ0eXAkMCIsInByZXZpb3VzX3Jlc3VsdCIsImxldF9zeW50YXhfMDI0Iiwic3luX3Jvb3RfdmVydGV4Iiwic3luX3Jvb3RfY3Vyc29yIiwiZ2V0Iiwib3B0Iiwic3RoIiwiZGVmYXVsdCQwIiwicHVzaCIsImNoaWxkIiwiZWRnZV9pZCIsInRyZWUiLCJjaGlsZHJlbiIsImNoaWxkX3NwZWNzIiwiY2hpbGRfbWFwIiwidHJlZV9jaGlsZHJlbiIsImNoaWxkcyIsImlkIiwidmVydGV4JDAiLCJlZGl0b3IiLCJzaG93X2lkc19zZXhwIiwia25vd25fYWN0aW9uc19zZXhwIiwiYWN0aW9uc19zZXhwIiwiY3Vyc29yX3NleHAiLCJncmFwaF9zZXhwIiwiaWRfc2V4cCIsImFjdGlvbnMiLCJrbm93bl9hY3Rpb25zIiwic2hvd19pZHMiLCJzZXhwX29mX21hcCIsImVkaXRvcnMiLCJtYXBfb2Zfc2V4cCIsImVkaXRvcl9zZXhwIiwiZXJyb3Jfc291cmNlXzAwNyIsImdyYXBoX2FjdGlvbl9zZXF1ZW5jZV9vZl9zZXhwIiwieF8wMDgiLCJzZXhwXzAwNiIsImFyZzFfMDAzIiwiYXJnMF8wMDIiLCJyZXMwXzAwNCIsInJlczFfMDA1Iiwic2V4cF9vZl9ncmFwaF9hY3Rpb25fc2VxdWVuY2UiLCJ4XzAxMyIsImFyZzFfMDEwIiwiYXJnMF8wMDkiLCJyZXMwXzAxMSIsInJlczFfMDEyIiwibW9kZWwiLCJlZGl0b3JzX3NleHAiLCJlZGl0b3IxIiwiZWRpdG9yMiIsImN1dG9mZiIsIm0xIiwibTIiLCJmaWx0ZXJfZWRpdG9yX2FjdGlvbnMiLCJnbG9iYWxseV9rbm93biIsImdsb2JhbGx5X2tub3duX2FjdGlvbnMiLCJrbm93bnMiLCJyZW1vdmVfa25vd25fYWN0aW9ucyIsInB1c2hfZWRnZSIsInB1c2hfdmVydGV4IiwiaW5fZGVncmVlcyIsImF2IiwidW5pdiIsIm11bHRpdiIsInRyYXZlcnNlX3ZlcnRleCIsInNlZW4iLCJzdGgkMCIsInJlbWFpbmluZyIsInNlZW4kMCIsInJlbWFpbmluZyQwIiwidHJlZV9jaGlsZHJlbiQwIiwicmVtYWluaW5nJDEiLCJzZWVuJDEiLCJjaGlsZHJlbiQwIiwidHJhdmVyc2VfdmVydGV4ZXMiLCJyb290cyIsInRyZWVzIiwid3JlYXRoX3RyYXZlcnNlIiwicGFyZW50cyIsInZlcnRleCQxIiwic2VlbiQyIiwiZGVjb21wb3NlIiwiYWxsX2VkZ2VzIiwiYXYkMCIsInVuaXYkMCIsIm11bHRpdiQwIiwicmVhY2hhYmxlIiwid3JlYXRocyIsInJlcG9ydF90cmVlIiwicHJlZml4IiwicmVwb3J0X3RyZWVzIiwiY2hlY2tfZGVjb21wb3NlIiwic3RoJDEiLCJzdGgkMiIsImdvdCIsIndhbnQiLCJ2MCIsInYxIiwidjIiLCJlMDEiLCJlMTIiLCJlMTIkMCIsImUyMSIsInNvcnQkMCIsImFyaXR5IiwiY29tcGFyZSQyIiwiY29tcGFyZSQzIiwic2V4cF9vZl9tb3ZlIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsInNleHBfb2ZfZWRpdCIsImFyZzBfMDAzIiwiYXJnMF8wMDUiLCJyZXMwXzAwNiIsImFyZzBfMDA3IiwicmVzMF8wMDgiLCJzZXhwX29mX2NvbW0iLCJzZXhwX29mX2VudiIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJhcmcwXzAxNyIsInJlczBfMDE4IiwiYXJnMF8wMTkiLCJyZXMwXzAyMCIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJhcmcwXzAyMyIsInJlczBfMDI0IiwiYXJnMF8wMjUiLCJyZXMwXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJhcmcwXzAyOSIsInJlczBfMDMwIiwiYWN0aW9uXzAzNCIsImVkaXRvcl9pZF8wMzIiLCJhcmdfMDM1IiwiYm5kc18wMzEiLCJhcmdfMDMzIiwiYm5kc18wMzEkMCIsImFwcGx5X2dyYXBoX2FjdGlvbiIsImdyYXBoX2FjdGlvbiIsInJlY29yZF9hY3Rpb25zIiwiZWRpdG9yX2lkIiwiZ3JhcGhfYWN0aW9ucyIsIm5ld19hY3Rpb25zIiwicmVwb3J0X2FjdGlvbnMiLCJyZXBsYXlfYWN0aW9ucyIsImVkaXRvciQwIiwiYXBwbHlfbW92ZSIsIm1vdmVfYWN0aW9uIiwiY3Vyc29yJDAiLCJlZGdlJDAiLCJjdXJzb3IkMSIsImFwcGx5X2VkaXQiLCJlZGl0X2FjdGlvbiIsIm1vdmVfaW4iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZV9wYXJlbnRfZWRnZSIsImNyZWF0ZV9uZXdfY2hpbGRyZW5fZWRnZXMiLCJkZXN0cm95X29sZF9jaGlsZHJlbl9lZGdlcyIsImdyYXBoX2FjdGlvbnMkMCIsIm1vZGVsJDAiLCJhcHBseV9jb21tIiwiY29tbV9hY3Rpb24iLCJlZGl0b3JfaWRzIiwiZWRpdF9hY3Rpb25zIiwiZWRpdG9yc19vcHQiLCJhcHBseV9lbnYiLCJlbnZfYWN0aW9uIiwic3RyIiwic3RyJDAiLCJlZGl0b3JfaWQkMCIsImVkaXRvcl9pZCQxIiwiZWRpdG9ycyQwIiwiYXBwbHkiLCJzdGF0ZSJdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9MYW5nLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZjb3JlL3V0aWwvVXVpZC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9ncmFwaC9WZXJ0ZXgubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvdXRpbC9VdGlsLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZjb3JlL2dyYXBoL0N1cnNvci5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9ncmFwaC9FZGdlLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZjb3JlL2dyYXBoL0VkZ2Vfc3RhdGUubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvdHlwZS9FbnYubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvdXRpbC9FcnJvci5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9ncmFwaC9HcmFwaF9hY3Rpb24ubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvZ3JhcGgvR3JhcGgubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvdHlwZS9UeXBlLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZjb3JlL3R5cGUvVHlwZV9jaGVjay5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9ncmFwaC9Qb3NpdGlvbl9tYXAubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvZ3JhcGgvVHJlZS5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9hcHAvRWRpdG9yLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZjb3JlL2FwcC9Nb2RlbC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9ncmFwaC9Hcm92ZS5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2Y29yZS9Gb3JtYWxpc20ubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydmNvcmUvYXBwL0FjdGlvbi5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBYUVBO0lBbUVBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTlFQUMsR0FBQUM7SUFBQTs7T0FBQSxPQUFBLDhCQUFBQTs7T0FBQSxPQUFBLDhCQUFBQTs7T0FBQSxPQUFBLDhCQUFBQTtlQUFBLE9BQUEsOEJBQUFBOztHQUttQztZQUxuQ0MsS0FBQUMsR0FBQSxPQUFBLG9DQUFBSCxJQUFBRyxHQUttQztZQUxuQ0MsTUFBQUMsS0FBQUM7SUFBQSxPQUFBRDs7WUFBQUMsS0FBQTs7Z0JBQUFBLEtBQUE7O2dCQUFBQSxLQUFBO3VCQUFBQSxLQUFBOztJQUFBO0dBS21DO1lBTG5DQyxRQUFBRixLQUFBQztJQUFBLE9BQUFEOztZQUFBQyxLQUFBOztnQkFBQUEsS0FBQTs7Z0JBQUFBLEtBQUE7dUJBQUFBLEtBQUE7O0lBQUEsU0FBQUU7S0FBQTs7UUFBQTs7UUFBQTs7UUFBQTtnQkFBQTs7SUFLbUM7SUFMbkMsV0FBQUEsT0FBQUY7SUFBQSxPQUFBLGlCQUFBRSxPQUFBSDtHQUttQztHQUxuQyxTQUFBSTtJ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Z0RPMUgsT0FPRDJIOztJQUxSLE9BQUEsa0NBRlMzSDtHQVFPOzs7OztPQTFQbEI2RDtPQUVBRztPQVVBTTtPQUVBQztPQVlBM2I7T0FHQTBCO09BRUl3YjtPQU9BRTtPQU1BSTtPQUdBQztPQVlBRTtPQXdDQUs7T0FnRUFTO09BK0JBSztPQWdEQU87OztFIiwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUgU29ydCA9IHN0cnVjdFxuICB0eXBlIHQgPSBcbiAgICB8IFJvb3RcbiAgICB8IEV4cFxuICAgIHwgUGF0XG4gICAgfCBUeXBcbiAgW0BAZGVyaXZpbmcgc2hvdywgZXEsIG9yZCwgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgQ29uc3RydWN0b3IgPSBzdHJ1Y3RcbiAgb3BlbiBTZXhwbGliMC5TZXhwX2NvbnZcblxuICB0eXBlIHQgPVxuICAgICgqKioqIFJvb3QgKioqKilcbiAgICB8IFJvb3Rfcm9vdFxuICAgICgqKioqIEV4cCAqKioqKVxuICAgIHwgRXhwX3ZhciBvZiAoc3RyaW5nKVxuICAgIHwgRXhwX2xhbVxuICAgIHwgRXhwX2FwcFxuICAgIHwgRXhwX251bSBvZiAoaW50KVxuICAgIHwgRXhwX3BsdXNcbiAgICB8IEV4cF90aW1lc1xuICAgIHwgRXhwX25pbFxuICAgIHwgRXhwX2NvbnNcbiAgICB8IEV4cF9jYXNlXG4gICAgKCoqKiogUGF0ICoqKiopXG4gICAgfCBQYXRfdmFyIG9mIChzdHJpbmcpXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgfCBUeXBfbnVtXG4gICAgfCBUeXBfYXJyb3dcbiAgICB8IFR5cF9saXN0XG4gIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBdXG5cbiAgKCogUmV0dXJucyB0aGUgc29ydCBvZiBhIHBhcnRpY3VsYXIgY29uc3RydWN0b3IgKilcbiAgbGV0IHNvcnRfb2YgKGMgOiB0KSA6IFNvcnQudCA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgIHwgUm9vdF9yb290IC0+IFJvb3RcbiAgICAoKioqKiBFeHAgKioqKilcbiAgICB8IEV4cF92YXIgXyAtPiBFeHBcbiAgICB8IEV4cF9sYW0gLT4gRXhwXG4gICAgfCBFeHBfYXBwIC0+IEV4cFxuICAgIHwgRXhwX251bSBfIC0+IEV4cFxuICAgIHwgRXhwX3BsdXMgLT4gRXhwXG4gICAgfCBFeHBfdGltZXMgLT4gRXhwXG4gICAgfCBFeHBfbmlsIC0+IEV4cFxuICAgIHwgRXhwX2NvbnMgLT4gRXhwXG4gICAgfCBFeHBfY2FzZSAtPiBFeHBcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICB8IFBhdF92YXIgXyAtPiBQYXRcbiAgICAoKioqKiBUeXAgKioqKilcbiAgICB8IFR5cF9udW0gLT4gVHlwXG4gICAgfCBUeXBfYXJyb3cgLT4gVHlwXG4gICAgfCBUeXBfbGlzdCAtPiBUeXBcblxuICAoKiBTcGVjaWZpZXMgdGhlIGxhYmVsIHRvIHVzZSBpbiBncmFwaHZpeiAqKVxuICBsZXQgZ3JhcGh2aXpfbGFiZWwgKGMgOiB0KSA6IHN0cmluZyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgIHwgUm9vdF9yb290IC0+IFwicm9vdFwiXG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgfCBFeHBfdmFyIChhcmcwKSAtPiBcInZhcihcIiBeIChmdW4geCAtPiB4KSBhcmcwIF4gXCIpXCJcbiAgICB8IEV4cF9sYW0gLT4gXCJsYW1cIlxuICAgIHwgRXhwX2FwcCAtPiBcImFwcFwiXG4gICAgfCBFeHBfbnVtIChhcmcwKSAtPiBcIm51bShcIiBeIEludC50b19zdHJpbmcgYXJnMCBeIFwiKVwiXG4gICAgfCBFeHBfcGx1cyAtPiBcInBsdXNcIlxuICAgIHwgRXhwX3RpbWVzIC0+IFwidGltZXNcIlxuICAgIHwgRXhwX25pbCAtPiBcIm5pbFwiXG4gICAgfCBFeHBfY29ucyAtPiBcImNvbnNcIlxuICAgIHwgRXhwX2Nhc2UgLT4gXCJjYXNlXCJcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICB8IFBhdF92YXIgKGFyZzApIC0+IFwidmFyKFwiIF4gKGZ1biB4IC0+IHgpIGFyZzAgXiBcIilcIlxuICAgICgqKioqIFR5cCAqKioqKVxuICAgIHwgVHlwX251bSAtPiBcIm51bVwiXG4gICAgfCBUeXBfYXJyb3cgLT4gXCJhcnJvd1wiXG4gICAgfCBUeXBfbGlzdCAtPiBcImxpc3RcIlxuZW5kXG5cbm1vZHVsZSBQb3NpdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgICgqKioqIFJvb3QgKioqKilcbiAgICAoKiBSb290X3Jvb3QgKilcbiAgICB8IFJvb3Rfcm9vdF9yb290XG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgKCogRXhwX3ZhciAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX2xhbSAqKVxuICAgIHwgRXhwX2xhbV9wYXJhbVxuICAgIHwgRXhwX2xhbV9wYXJhbV90eXBlXG4gICAgfCBFeHBfbGFtX2JvZHlcbiAgICAoKiBFeHBfYXBwICopXG4gICAgfCBFeHBfYXBwX2Z1blxuICAgIHwgRXhwX2FwcF9hcmdcbiAgICAoKiBFeHBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBFeHBfcGx1cyAqKVxuICAgIHwgRXhwX3BsdXNfbGVmdFxuICAgIHwgRXhwX3BsdXNfcmlnaHRcbiAgICAoKiBFeHBfdGltZXMgKilcbiAgICB8IEV4cF90aW1lc19sZWZ0XG4gICAgfCBFeHBfdGltZXNfcmlnaHRcbiAgICAoKiBFeHBfbmlsICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBFeHBfY29ucyAqKVxuICAgIHwgRXhwX2NvbnNfaGVhZFxuICAgIHwgRXhwX2NvbnNfdGFpbFxuICAgICgqIEV4cF9jYXNlICopXG4gICAgfCBFeHBfY2FzZV9zY3J1dFxuICAgIHwgRXhwX2Nhc2VfbmlsX2JvZHlcbiAgICB8IEV4cF9jYXNlX2hlYWRfcGF0XG4gICAgfCBFeHBfY2FzZV90YWlsX3BhdFxuICAgIHwgRXhwX2Nhc2VfY29uc19ib2R5XG4gICAgfCBFeHBfY2FzZV90eXBlXG4gICAgKCoqKiogUGF0ICoqKiopXG4gICAgKCogUGF0X3ZhciAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgKCogVHlwX251bSAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogVHlwX2Fycm93ICopXG4gICAgfCBUeXBfYXJyb3dfYXJnXG4gICAgfCBUeXBfYXJyb3dfcmVzdWx0XG4gICAgKCogVHlwX2xpc3QgKilcbiAgICB8IFR5cF9saXN0X2NvbnRlbnRcbiAgW0BAZGVyaXZpbmcgc2hvdywgZXEsIG9yZCwgc2V4cF1cblxuICBsZXQgc2hvcnRfbmFtZSAoaSA6IHQpIDogc3RyaW5nID1cbiAgICBtYXRjaCBpIHdpdGhcbiAgICAoKioqKiBSb290ICoqKiopXG4gICAgKCogUm9vdF9yb290ICopXG4gICAgfCBSb290X3Jvb3Rfcm9vdCAtPiBcInJvb3RcIlxuICAgICgqKioqIEV4cCAqKioqKVxuICAgICgqIEV4cF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9sYW0gKilcbiAgICB8IEV4cF9sYW1fcGFyYW0gLT4gXCJwYXJhbVwiXG4gICAgfCBFeHBfbGFtX3BhcmFtX3R5cGUgLT4gXCJwYXJhbV90eXBlXCJcbiAgICB8IEV4cF9sYW1fYm9keSAtPiBcImJvZHlcIlxuICAgICgqIEV4cF9hcHAgKilcbiAgICB8IEV4cF9hcHBfZnVuIC0+IFwiZnVuXCJcbiAgICB8IEV4cF9hcHBfYXJnIC0+IFwiYXJnXCJcbiAgICAoKiBFeHBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBFeHBfcGx1cyAqKVxuICAgIHwgRXhwX3BsdXNfbGVmdCAtPiBcImxlZnRcIlxuICAgIHwgRXhwX3BsdXNfcmlnaHQgLT4gXCJyaWdodFwiXG4gICAgKCogRXhwX3RpbWVzICopXG4gICAgfCBFeHBfdGltZXNfbGVmdCAtPiBcImxlZnRcIlxuICAgIHwgRXhwX3RpbWVzX3JpZ2h0IC0+IFwicmlnaHRcIlxuICAgICgqIEV4cF9uaWwgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9jb25zICopXG4gICAgfCBFeHBfY29uc19oZWFkIC0+IFwiaGVhZFwiXG4gICAgfCBFeHBfY29uc190YWlsIC0+IFwidGFpbFwiXG4gICAgKCogRXhwX2Nhc2UgKilcbiAgICB8IEV4cF9jYXNlX3NjcnV0IC0+IFwic2NydXRcIlxuICAgIHwgRXhwX2Nhc2VfbmlsX2JvZHkgLT4gXCJuaWxfYm9keVwiXG4gICAgfCBFeHBfY2FzZV9oZWFkX3BhdCAtPiBcImhlYWRfcGF0XCJcbiAgICB8IEV4cF9jYXNlX3RhaWxfcGF0IC0+IFwidGFpbF9wYXRcIlxuICAgIHwgRXhwX2Nhc2VfY29uc19ib2R5IC0+IFwiY29uc19ib2R5XCJcbiAgICB8IEV4cF9jYXNlX3R5cGUgLT4gXCJ0eXBlXCJcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICAoKiBQYXRfdmFyICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKioqKiBUeXAgKioqKilcbiAgICAoKiBUeXBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBUeXBfYXJyb3cgKilcbiAgICB8IFR5cF9hcnJvd19hcmcgLT4gXCJhcmdcIlxuICAgIHwgVHlwX2Fycm93X3Jlc3VsdCAtPiBcInJlc3VsdFwiXG4gICAgKCogVHlwX2xpc3QgKilcbiAgICB8IFR5cF9saXN0X2NvbnRlbnQgLT4gXCJjb250ZW50XCJcblxuICAoKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciB0aGF0IHBhcmVudHMgb2YgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uIHNob3VsZCBoYXZlICopXG4gIGxldCBwYXJlbnRfY29uc3RydWN0b3IgKGkgOiB0KSA6IENvbnN0cnVjdG9yLnQgPVxuICAgIG1hdGNoIGkgd2l0aFxuICAgICgqKioqIFJvb3QgKioqKilcbiAgICAoKiBSb290X3Jvb3QgKilcbiAgICB8IFJvb3Rfcm9vdF9yb290IC0+IFJvb3Rfcm9vdFxuICAgICgqKioqIEV4cCAqKioqKVxuICAgICgqIEV4cF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9sYW0gKilcbiAgICB8IEV4cF9sYW1fcGFyYW0gLT4gRXhwX2xhbVxuICAgIHwgRXhwX2xhbV9wYXJhbV90eXBlIC0+IEV4cF9sYW1cbiAgICB8IEV4cF9sYW1fYm9keSAtPiBFeHBfbGFtXG4gICAgKCogRXhwX2FwcCAqKVxuICAgIHwgRXhwX2FwcF9mdW4gLT4gRXhwX2FwcFxuICAgIHwgRXhwX2FwcF9hcmcgLT4gRXhwX2FwcFxuICAgICgqIEV4cF9udW0gKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9wbHVzICopXG4gICAgfCBFeHBfcGx1c19sZWZ0IC0+IEV4cF9wbHVzXG4gICAgfCBFeHBfcGx1c19yaWdodCAtPiBFeHBfcGx1c1xuICAgICgqIEV4cF90aW1lcyAqKVxuICAgIHwgRXhwX3RpbWVzX2xlZnQgLT4gRXhwX3RpbWVzXG4gICAgfCBFeHBfdGltZXNfcmlnaHQgLT4gRXhwX3RpbWVzXG4gICAgKCogRXhwX25pbCAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX2NvbnMgKilcbiAgICB8IEV4cF9jb25zX2hlYWQgLT4gRXhwX2NvbnNcbiAgICB8IEV4cF9jb25zX3RhaWwgLT4gRXhwX2NvbnNcbiAgICAoKiBFeHBfY2FzZSAqKVxuICAgIHwgRXhwX2Nhc2Vfc2NydXQgLT4gRXhwX2Nhc2VcbiAgICB8IEV4cF9jYXNlX25pbF9ib2R5IC0+IEV4cF9jYXNlXG4gICAgfCBFeHBfY2FzZV9oZWFkX3BhdCAtPiBFeHBfY2FzZVxuICAgIHwgRXhwX2Nhc2VfdGFpbF9wYXQgLT4gRXhwX2Nhc2VcbiAgICB8IEV4cF9jYXNlX2NvbnNfYm9keSAtPiBFeHBfY2FzZVxuICAgIHwgRXhwX2Nhc2VfdHlwZSAtPiBFeHBfY2FzZVxuICAgICgqKioqIFBhdCAqKioqKVxuICAgICgqIFBhdF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqKioqIFR5cCAqKioqKVxuICAgICgqIFR5cF9udW0gKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIFR5cF9hcnJvdyAqKVxuICAgIHwgVHlwX2Fycm93X2FyZyAtPiBUeXBfYXJyb3dcbiAgICB8IFR5cF9hcnJvd19yZXN1bHQgLT4gVHlwX2Fycm93XG4gICAgKCogVHlwX2xpc3QgKilcbiAgICB8IFR5cF9saXN0X2NvbnRlbnQgLT4gVHlwX2xpc3RcblxuICAoKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciB0aGF0IHBhcmVudHMgb2YgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uIHNob3VsZCBoYXZlICopXG4gIGxldCBjaGlsZF9wb3NpdGlvbnMgKGMgOiBDb25zdHJ1Y3Rvci50KSA6IHQgbGlzdCA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgIHwgUm9vdF9yb290IC0+IFtSb290X3Jvb3Rfcm9vdF1cbiAgICAoKioqKiBFeHAgKioqKilcbiAgICB8IEV4cF92YXIgXyAtPiBbXVxuICAgIHwgRXhwX2xhbSAtPiBbRXhwX2xhbV9wYXJhbTsgRXhwX2xhbV9wYXJhbV90eXBlOyBFeHBfbGFtX2JvZHldXG4gICAgfCBFeHBfYXBwIC0+IFtFeHBfYXBwX2Z1bjsgRXhwX2FwcF9hcmddXG4gICAgfCBFeHBfbnVtIF8gLT4gW11cbiAgICB8IEV4cF9wbHVzIC0+IFtFeHBfcGx1c19sZWZ0OyBFeHBfcGx1c19yaWdodF1cbiAgICB8IEV4cF90aW1lcyAtPiBbRXhwX3RpbWVzX2xlZnQ7IEV4cF90aW1lc19yaWdodF1cbiAgICB8IEV4cF9uaWwgLT4gW11cbiAgICB8IEV4cF9jb25zIC0+IFtFeHBfY29uc19oZWFkOyBFeHBfY29uc190YWlsXVxuICAgIHwgRXhwX2Nhc2UgLT4gW0V4cF9jYXNlX3NjcnV0OyBFeHBfY2FzZV9uaWxfYm9keTsgRXhwX2Nhc2VfaGVhZF9wYXQ7IEV4cF9jYXNlX3RhaWxfcGF0OyBFeHBfY2FzZV9jb25zX2JvZHk7IEV4cF9jYXNlX3R5cGVdXG4gICAgKCoqKiogUGF0ICoqKiopXG4gICAgfCBQYXRfdmFyIF8gLT4gW11cbiAgICAoKioqKiBUeXAgKioqKilcbiAgICB8IFR5cF9udW0gLT4gW11cbiAgICB8IFR5cF9hcnJvdyAtPiBbVHlwX2Fycm93X2FyZzsgVHlwX2Fycm93X3Jlc3VsdF1cbiAgICB8IFR5cF9saXN0IC0+IFtUeXBfbGlzdF9jb250ZW50XVxuXG4gICgqIFJldHVybnMgdGhlIHNvcnQgdGhhdCBjaGlsZHJlbiBvZiBhIHBhcnRpY3VsYXIgcG9zaXRpb24gc2hvdWxkIGhhdmUgKilcbiAgbGV0IGNoaWxkX3NvcnQgKGkgOiB0KSA6IFNvcnQudCA9XG4gICAgbWF0Y2ggaSB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgICgqIFJvb3Rfcm9vdCAqKVxuICAgIHwgUm9vdF9yb290X3Jvb3QgLT4gRXhwXG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgKCogRXhwX3ZhciAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX2xhbSAqKVxuICAgIHwgRXhwX2xhbV9wYXJhbSAtPiBQYXRcbiAgICB8IEV4cF9sYW1fcGFyYW1fdHlwZSAtPiBUeXBcbiAgICB8IEV4cF9sYW1fYm9keSAtPiBFeHBcbiAgICAoKiBFeHBfYXBwICopXG4gICAgfCBFeHBfYXBwX2Z1biAtPiBFeHBcbiAgICB8IEV4cF9hcHBfYXJnIC0+IEV4cFxuICAgICgqIEV4cF9udW0gKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9wbHVzICopXG4gICAgfCBFeHBfcGx1c19sZWZ0IC0+IEV4cFxuICAgIHwgRXhwX3BsdXNfcmlnaHQgLT4gRXhwXG4gICAgKCogRXhwX3RpbWVzICopXG4gICAgfCBFeHBfdGltZXNfbGVmdCAtPiBFeHBcbiAgICB8IEV4cF90aW1lc19yaWdodCAtPiBFeHBcbiAgICAoKiBFeHBfbmlsICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBFeHBfY29ucyAqKVxuICAgIHwgRXhwX2NvbnNfaGVhZCAtPiBFeHBcbiAgICB8IEV4cF9jb25zX3RhaWwgLT4gRXhwXG4gICAgKCogRXhwX2Nhc2UgKilcbiAgICB8IEV4cF9jYXNlX3NjcnV0IC0+IEV4cFxuICAgIHwgRXhwX2Nhc2VfbmlsX2JvZHkgLT4gRXhwXG4gICAgfCBFeHBfY2FzZV9oZWFkX3BhdCAtPiBQYXRcbiAgICB8IEV4cF9jYXNlX3RhaWxfcGF0IC0+IFBhdFxuICAgIHwgRXhwX2Nhc2VfY29uc19ib2R5IC0+IEV4cFxuICAgIHwgRXhwX2Nhc2VfdHlwZSAtPiBUeXBcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICAoKiBQYXRfdmFyICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKioqKiBUeXAgKioqKilcbiAgICAoKiBUeXBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBUeXBfYXJyb3cgKilcbiAgICB8IFR5cF9hcnJvd19hcmcgLT4gVHlwXG4gICAgfCBUeXBfYXJyb3dfcmVzdWx0IC0+IFR5cFxuICAgICgqIFR5cF9saXN0ICopXG4gICAgfCBUeXBfbGlzdF9jb250ZW50IC0+IFR5cFxuXG4gICgqIFNwZWNpZmllcyB3aGVyZSB0aGUgZXhpc3Rpbmcgbm9kZSBnb2VzIHdoZW4gYSBub2RlIGlzIHdyYXBwZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yICopXG4gIGxldCBkZWZhdWx0X3Bvc2l0aW9uIChjIDogQ29uc3RydWN0b3IudCkgOiB0IG9wdGlvbiA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgIHwgUm9vdF9yb290IC0+IFNvbWUgUm9vdF9yb290X3Jvb3RcbiAgICAoKioqKiBFeHAgKioqKilcbiAgICB8IEV4cF92YXIgXyAtPiBOb25lXG4gICAgfCBFeHBfbGFtIC0+IFNvbWUgRXhwX2xhbV9wYXJhbVxuICAgIHwgRXhwX2FwcCAtPiBTb21lIEV4cF9hcHBfZnVuXG4gICAgfCBFeHBfbnVtIF8gLT4gTm9uZVxuICAgIHwgRXhwX3BsdXMgLT4gU29tZSBFeHBfcGx1c19sZWZ0XG4gICAgfCBFeHBfdGltZXMgLT4gU29tZSBFeHBfdGltZXNfbGVmdFxuICAgIHwgRXhwX25pbCAtPiBOb25lXG4gICAgfCBFeHBfY29ucyAtPiBTb21lIEV4cF9jb25zX2hlYWRcbiAgICB8IEV4cF9jYXNlIC0+IFNvbWUgRXhwX2Nhc2Vfc2NydXRcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICB8IFBhdF92YXIgXyAtPiBOb25lXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgfCBUeXBfbnVtIC0+IE5vbmVcbiAgICB8IFR5cF9hcnJvdyAtPiBTb21lIFR5cF9hcnJvd19hcmdcbiAgICB8IFR5cF9saXN0IC0+IFNvbWUgVHlwX2xpc3RfY29udGVudFxuXG4gICgqIFNwZWNpZmllcyB3aGVyZSB0byBnbyB3aGVuIHRoZSBjdXJzb3IgbW92ZXMgZG93biAqKVxuICBsZXQgZG93biAoYyA6IENvbnN0cnVjdG9yLnQpIDogdCBvcHRpb24gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgICgqKioqIFJvb3QgKioqKilcbiAgICB8IFJvb3Rfcm9vdCAtPiBTb21lIFJvb3Rfcm9vdF9yb290XG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgfCBFeHBfdmFyIF8gLT4gTm9uZVxuICAgIHwgRXhwX2xhbSAtPiBTb21lIEV4cF9sYW1fYm9keVxuICAgIHwgRXhwX2FwcCAtPiBTb21lIEV4cF9hcHBfZnVuXG4gICAgfCBFeHBfbnVtIF8gLT4gTm9uZVxuICAgIHwgRXhwX3BsdXMgLT4gU29tZSBFeHBfcGx1c19sZWZ0XG4gICAgfCBFeHBfdGltZXMgLT4gU29tZSBFeHBfdGltZXNfbGVmdFxuICAgIHwgRXhwX25pbCAtPiBOb25lXG4gICAgfCBFeHBfY29ucyAtPiBTb21lIEV4cF9jb25zX2hlYWRcbiAgICB8IEV4cF9jYXNlIC0+IFNvbWUgRXhwX2Nhc2Vfc2NydXRcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICB8IFBhdF92YXIgXyAtPiBOb25lXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgfCBUeXBfbnVtIC0+IE5vbmVcbiAgICB8IFR5cF9hcnJvdyAtPiBTb21lIFR5cF9hcnJvd19hcmdcbiAgICB8IFR5cF9saXN0IC0+IFNvbWUgVHlwX2xpc3RfY29udGVudFxuXG4gICgqIFNwZWNpZmllcyB3aGVyZSB0byBnbyB3aGVuIHRoZSBjdXJzb3IgbW92ZXMgcmlnaHQgKilcbiAgbGV0IHJpZ2h0IChpIDogdCkgOiB0IG9wdGlvbiA9XG4gICAgbWF0Y2ggaSB3aXRoXG4gICAgKCoqKiogUm9vdCAqKioqKVxuICAgICgqIFJvb3Rfcm9vdCAqKVxuICAgIHwgUm9vdF9yb290X3Jvb3QgLT4gTm9uZVxuICAgICgqKioqIEV4cCAqKioqKVxuICAgICgqIEV4cF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9sYW0gKilcbiAgICB8IEV4cF9sYW1fcGFyYW0gLT4gU29tZSBFeHBfbGFtX3BhcmFtX3R5cGVcbiAgICB8IEV4cF9sYW1fcGFyYW1fdHlwZSAtPiBTb21lIEV4cF9sYW1fYm9keVxuICAgIHwgRXhwX2xhbV9ib2R5IC0+IE5vbmVcbiAgICAoKiBFeHBfYXBwICopXG4gICAgfCBFeHBfYXBwX2Z1biAtPiBTb21lIEV4cF9hcHBfYXJnXG4gICAgfCBFeHBfYXBwX2FyZyAtPiBOb25lXG4gICAgKCogRXhwX251bSAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX3BsdXMgKilcbiAgICB8IEV4cF9wbHVzX2xlZnQgLT4gU29tZSBFeHBfcGx1c19yaWdodFxuICAgIHwgRXhwX3BsdXNfcmlnaHQgLT4gTm9uZVxuICAgICgqIEV4cF90aW1lcyAqKVxuICAgIHwgRXhwX3RpbWVzX2xlZnQgLT4gU29tZSBFeHBfdGltZXNfcmlnaHRcbiAgICB8IEV4cF90aW1lc19yaWdodCAtPiBOb25lXG4gICAgKCogRXhwX25pbCAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX2NvbnMgKilcbiAgICB8IEV4cF9jb25zX2hlYWQgLT4gU29tZSBFeHBfY29uc190YWlsXG4gICAgfCBFeHBfY29uc190YWlsIC0+IE5vbmVcbiAgICAoKiBFeHBfY2FzZSAqKVxuICAgIHwgRXhwX2Nhc2Vfc2NydXQgLT4gU29tZSBFeHBfY2FzZV9uaWxfYm9keVxuICAgIHwgRXhwX2Nhc2VfbmlsX2JvZHkgLT4gU29tZSBFeHBfY2FzZV9oZWFkX3BhdFxuICAgIHwgRXhwX2Nhc2VfaGVhZF9wYXQgLT4gU29tZSBFeHBfY2FzZV90YWlsX3BhdFxuICAgIHwgRXhwX2Nhc2VfdGFpbF9wYXQgLT4gU29tZSBFeHBfY2FzZV9jb25zX2JvZHlcbiAgICB8IEV4cF9jYXNlX2NvbnNfYm9keSAtPiBTb21lIEV4cF9jYXNlX3R5cGVcbiAgICB8IEV4cF9jYXNlX3R5cGUgLT4gTm9uZVxuICAgICgqKioqIFBhdCAqKioqKVxuICAgICgqIFBhdF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqKioqIFR5cCAqKioqKVxuICAgICgqIFR5cF9udW0gKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIFR5cF9hcnJvdyAqKVxuICAgIHwgVHlwX2Fycm93X2FyZyAtPiBTb21lIFR5cF9hcnJvd19yZXN1bHRcbiAgICB8IFR5cF9hcnJvd19yZXN1bHQgLT4gTm9uZVxuICAgICgqIFR5cF9saXN0ICopXG4gICAgfCBUeXBfbGlzdF9jb250ZW50IC0+IE5vbmVcblxuICAoKiBTcGVjaWZpZXMgd2hlcmUgdG8gZ28gd2hlbiB0aGUgY3Vyc29yIG1vdmVzIGxlZnQgKilcbiAgbGV0IGxlZnQgKGkgOiB0KSA6IHQgb3B0aW9uID1cbiAgICBtYXRjaCBpIHdpdGhcbiAgICAoKioqKiBSb290ICoqKiopXG4gICAgKCogUm9vdF9yb290ICopXG4gICAgfCBSb290X3Jvb3Rfcm9vdCAtPiBOb25lXG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgKCogRXhwX3ZhciAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX2xhbSAqKVxuICAgIHwgRXhwX2xhbV9wYXJhbSAtPiBOb25lXG4gICAgfCBFeHBfbGFtX3BhcmFtX3R5cGUgLT4gU29tZSBFeHBfbGFtX3BhcmFtXG4gICAgfCBFeHBfbGFtX2JvZHkgLT4gU29tZSBFeHBfbGFtX3BhcmFtX3R5cGVcbiAgICAoKiBFeHBfYXBwICopXG4gICAgfCBFeHBfYXBwX2Z1biAtPiBOb25lXG4gICAgfCBFeHBfYXBwX2FyZyAtPiBTb21lIEV4cF9hcHBfZnVuXG4gICAgKCogRXhwX251bSAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogRXhwX3BsdXMgKilcbiAgICB8IEV4cF9wbHVzX2xlZnQgLT4gTm9uZVxuICAgIHwgRXhwX3BsdXNfcmlnaHQgLT4gU29tZSBFeHBfcGx1c19sZWZ0XG4gICAgKCogRXhwX3RpbWVzICopXG4gICAgfCBFeHBfdGltZXNfbGVmdCAtPiBOb25lXG4gICAgfCBFeHBfdGltZXNfcmlnaHQgLT4gU29tZSBFeHBfdGltZXNfbGVmdFxuICAgICgqIEV4cF9uaWwgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9jb25zICopXG4gICAgfCBFeHBfY29uc19oZWFkIC0+IE5vbmVcbiAgICB8IEV4cF9jb25zX3RhaWwgLT4gU29tZSBFeHBfY29uc19oZWFkXG4gICAgKCogRXhwX2Nhc2UgKilcbiAgICB8IEV4cF9jYXNlX3NjcnV0IC0+IE5vbmVcbiAgICB8IEV4cF9jYXNlX25pbF9ib2R5IC0+IFNvbWUgRXhwX2Nhc2Vfc2NydXRcbiAgICB8IEV4cF9jYXNlX2hlYWRfcGF0IC0+IFNvbWUgRXhwX2Nhc2VfbmlsX2JvZHlcbiAgICB8IEV4cF9jYXNlX3RhaWxfcGF0IC0+IFNvbWUgRXhwX2Nhc2VfaGVhZF9wYXRcbiAgICB8IEV4cF9jYXNlX2NvbnNfYm9keSAtPiBTb21lIEV4cF9jYXNlX3RhaWxfcGF0XG4gICAgfCBFeHBfY2FzZV90eXBlIC0+IFNvbWUgRXhwX2Nhc2VfY29uc19ib2R5XG4gICAgKCoqKiogUGF0ICoqKiopXG4gICAgKCogUGF0X3ZhciAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgKCogVHlwX251bSAqKVxuICAgICgqIC0tIGVtcHR5IC0tICopXG4gICAgKCogVHlwX2Fycm93ICopXG4gICAgfCBUeXBfYXJyb3dfYXJnIC0+IE5vbmVcbiAgICB8IFR5cF9hcnJvd19yZXN1bHQgLT4gU29tZSBUeXBfYXJyb3dfYXJnXG4gICAgKCogVHlwX2xpc3QgKilcbiAgICB8IFR5cF9saXN0X2NvbnRlbnQgLT4gTm9uZVxuZW5kXG5cbm1vZHVsZSBHYWR0ID0gc3RydWN0XG4gIFxuICB0eXBlIHJvb3RcbiAgdHlwZSByb290X3Jvb3QgPSBSb290X3Jvb3QgKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwXG4gIHR5cGUgZXhwX3ZhciA9IEV4cF92YXIgKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX2xhbSA9IEV4cF9sYW0gKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX2FwcCA9IEV4cF9hcHAgKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX251bSA9IEV4cF9udW0gKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX3BsdXMgPSBFeHBfcGx1cyAoKm9mICVzKikgW0BAZGVyaXZpbmcgc2hvdywgZXEsIG9yZCwgc2V4cF9vZl1cbiAgdHlwZSBleHBfdGltZXMgPSBFeHBfdGltZXMgKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX25pbCA9IEV4cF9uaWwgKCpvZiAlcyopIFtAQGRlcml2aW5nIHNob3csIGVxLCBvcmQsIHNleHBfb2ZdXG4gIHR5cGUgZXhwX2NvbnMgPSBFeHBfY29ucyAoKm9mICVzKikgW0BAZGVyaXZpbmcgc2hvdywgZXEsIG9yZCwgc2V4cF9vZl1cbiAgdHlwZSBleHBfY2FzZSA9IEV4cF9jYXNlICgqb2YgJXMqKSBbQEBkZXJpdmluZyBzaG93LCBlcSwgb3JkLCBzZXhwX29mXVxuICB0eXBlIHBhdFxuICB0eXBlIHBhdF92YXIgPSBQYXRfdmFyICgqb2YgJXMqKSBbQEBkZXJpdmluZyBzaG93LCBlcSwgb3JkLCBzZXhwX29mXVxuICB0eXBlIHR5cFxuICB0eXBlIHR5cF9udW0gPSBUeXBfbnVtICgqb2YgJXMqKSBbQEBkZXJpdmluZyBzaG93LCBlcSwgb3JkLCBzZXhwX29mXVxuICB0eXBlIHR5cF9hcnJvdyA9IFR5cF9hcnJvdyAoKm9mICVzKikgW0BAZGVyaXZpbmcgc2hvdywgZXEsIG9yZCwgc2V4cF9vZl1cbiAgdHlwZSB0eXBfbGlzdCA9IFR5cF9saXN0ICgqb2YgJXMqKSBbQEBkZXJpdmluZyBzaG93LCBlcSwgb3JkLCBzZXhwX29mXVxuXG4oKnR5cGUgKCdjdG9yLCAnc29ydCkgc29ydF9vZl9jdG9yID0qKVxuXG4oKlxuICBsZXQgc2hvcnRfbmFtZSAoaSA6IHQpIDogc3RyaW5nID1cbiAgICBtYXRjaCBpIHdpdGhcbiAgICAoKioqKiBSb290ICoqKiopXG4gICAgKCogUm9vdF9yb290ICopXG4gICAgfCBSb290X3Jvb3Rfcm9vdCAtPiBcInJvb3RcIlxuICAgICgqKioqIEV4cCAqKioqKVxuICAgICgqIEV4cF92YXIgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9sYW0gKilcbiAgICB8IEV4cF9sYW1fcGFyYW0gLT4gXCJwYXJhbVwiXG4gICAgfCBFeHBfbGFtX3BhcmFtX3R5cGUgLT4gXCJwYXJhbV90eXBlXCJcbiAgICB8IEV4cF9sYW1fYm9keSAtPiBcImJvZHlcIlxuICAgICgqIEV4cF9hcHAgKilcbiAgICB8IEV4cF9hcHBfZnVuIC0+IFwiZnVuXCJcbiAgICB8IEV4cF9hcHBfYXJnIC0+IFwiYXJnXCJcbiAgICAoKiBFeHBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBFeHBfcGx1cyAqKVxuICAgIHwgRXhwX3BsdXNfbGVmdCAtPiBcImxlZnRcIlxuICAgIHwgRXhwX3BsdXNfcmlnaHQgLT4gXCJyaWdodFwiXG4gICAgKCogRXhwX3RpbWVzICopXG4gICAgfCBFeHBfdGltZXNfbGVmdCAtPiBcImxlZnRcIlxuICAgIHwgRXhwX3RpbWVzX3JpZ2h0IC0+IFwicmlnaHRcIlxuICAgICgqIEV4cF9uaWwgKilcbiAgICAoKiAtLSBlbXB0eSAtLSAqKVxuICAgICgqIEV4cF9jb25zICopXG4gICAgfCBFeHBfY29uc19oZWFkIC0+IFwiaGVhZFwiXG4gICAgfCBFeHBfY29uc190YWlsIC0+IFwidGFpbFwiXG4gICAgKCogRXhwX2Nhc2UgKilcbiAgICB8IEV4cF9jYXNlX3NjcnV0IC0+IFwic2NydXRcIlxuICAgIHwgRXhwX2Nhc2VfbmlsX2JvZHkgLT4gXCJuaWxfYm9keVwiXG4gICAgfCBFeHBfY2FzZV9oZWFkX3BhdCAtPiBcImhlYWRfcGF0XCJcbiAgICB8IEV4cF9jYXNlX3RhaWxfcGF0IC0+IFwidGFpbF9wYXRcIlxuICAgIHwgRXhwX2Nhc2VfY29uc19ib2R5IC0+IFwiY29uc19ib2R5XCJcbiAgICB8IEV4cF9jYXNlX3R5cGUgLT4gXCJ0eXBlXCJcbiAgICAoKioqKiBQYXQgKioqKilcbiAgICAoKiBQYXRfdmFyICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKioqKiBUeXAgKioqKilcbiAgICAoKiBUeXBfbnVtICopXG4gICAgKCogLS0gZW1wdHkgLS0gKilcbiAgICAoKiBUeXBfYXJyb3cgKilcbiAgICB8IFR5cF9hcnJvd19hcmcgLT4gXCJhcmdcIlxuICAgIHwgVHlwX2Fycm93X3Jlc3VsdCAtPiBcInJlc3VsdFwiXG4gICAgKCogVHlwX2xpc3QgKilcbiAgICB8IFR5cF9saXN0X2NvbnRlbnQgLT4gXCJjb250ZW50XCJcbiAgICAqKVxuZW5kXG5cbigqIFNwZWNpZmllcyBob3cgdG8gc2hvdyB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgYW5kIGl0cyBjaGlsZHJlbiAqKVxubGV0IHNob3cgKHN0cmluZyA6IHN0cmluZyAtPiAnYSkgKGFyZyA6IHN0cmluZyAtPiAnYSlcbiAgICAocG9zaXRpb24gOiBQb3NpdGlvbi50IC0+ICdhKSAoYyA6IENvbnN0cnVjdG9yLnQpIDogJ2EgbGlzdCA9XG4gIG1hdGNoIGMgd2l0aFxuICAgICgqKioqIFJvb3QgKioqKilcbiAgICB8IFJvb3Rfcm9vdCAtPiBbcG9zaXRpb24gUm9vdF9yb290X3Jvb3RdXG4gICAgKCoqKiogRXhwICoqKiopXG4gICAgfCBFeHBfdmFyIChhcmcwKSAtPiBbYXJnICgoZnVuIHggLT4geCkgYXJnMCldXG4gICAgfCBFeHBfbGFtIC0+IFtzdHJpbmcgXCJcXDIwNlxcMTg3XCI7IHBvc2l0aW9uIEV4cF9sYW1fcGFyYW07IHN0cmluZyBcIjpcIjsgcG9zaXRpb24gRXhwX2xhbV9wYXJhbV90eXBlOyBzdHJpbmcgXCIuXCI7IHBvc2l0aW9uIEV4cF9sYW1fYm9keV1cbiAgICB8IEV4cF9hcHAgLT4gW3Bvc2l0aW9uIEV4cF9hcHBfZnVuOyBzdHJpbmcgXCIgXCI7IHBvc2l0aW9uIEV4cF9hcHBfYXJnXVxuICAgIHwgRXhwX251bSAoYXJnMCkgLT4gW2FyZyAoSW50LnRvX3N0cmluZyBhcmcwKV1cbiAgICB8IEV4cF9wbHVzIC0+IFtwb3NpdGlvbiBFeHBfcGx1c19sZWZ0OyBzdHJpbmcgXCIgKyBcIjsgcG9zaXRpb24gRXhwX3BsdXNfcmlnaHRdXG4gICAgfCBFeHBfdGltZXMgLT4gW3Bvc2l0aW9uIEV4cF90aW1lc19sZWZ0OyBzdHJpbmcgXCIgKiBcIjsgcG9zaXRpb24gRXhwX3RpbWVzX3JpZ2h0XVxuICAgIHwgRXhwX25pbCAtPiBbc3RyaW5nIFwiSW50XCJdXG4gICAgfCBFeHBfY29ucyAtPiBbcG9zaXRpb24gRXhwX2NvbnNfaGVhZDsgc3RyaW5nIFwiOjpcIjsgcG9zaXRpb24gRXhwX2NvbnNfdGFpbF1cbiAgICB8IEV4cF9jYXNlIC0+IFtzdHJpbmcgXCJjYXNlXCI7IHBvc2l0aW9uIEV4cF9jYXNlX3NjcnV0OyBzdHJpbmcgXCJvZlwiOyBzdHJpbmcgXCJuaWxcIjsgc3RyaW5nIFwiLT5cIjsgcG9zaXRpb24gRXhwX2Nhc2VfbmlsX2JvZHk7IHN0cmluZyBcInxcIjsgcG9zaXRpb24gRXhwX2Nhc2VfaGVhZF9wYXQ7IHN0cmluZyBcIjo6XCI7IHBvc2l0aW9uIEV4cF9jYXNlX3RhaWxfcGF0OyBzdHJpbmcgXCItPlwiOyBwb3NpdGlvbiBFeHBfY2FzZV9jb25zX2JvZHk7IHN0cmluZyBcImVuZFwiOyBzdHJpbmcgXCI6XCI7IHBvc2l0aW9uIEV4cF9jYXNlX3R5cGVdXG4gICAgKCoqKiogUGF0ICoqKiopXG4gICAgfCBQYXRfdmFyIChhcmcwKSAtPiBbYXJnICgoZnVuIHggLT4geCkgYXJnMCldXG4gICAgKCoqKiogVHlwICoqKiopXG4gICAgfCBUeXBfbnVtIC0+IFtzdHJpbmcgXCJOdW1cIl1cbiAgICB8IFR5cF9hcnJvdyAtPiBbcG9zaXRpb24gVHlwX2Fycm93X2FyZzsgc3RyaW5nIFwiXFwyMjZcXDEzNFxcMTQ2XCI7IHBvc2l0aW9uIFR5cF9hcnJvd19yZXN1bHRdXG4gICAgfCBUeXBfbGlzdCAtPiBbc3RyaW5nIFwibGlzdFwiOyBzdHJpbmcgXCJbXCI7IHBvc2l0aW9uIFR5cF9saXN0X2NvbnRlbnQ7IHN0cmluZyBcIl1cIl1cbiIsIm1vZHVsZSBJZCA9IHN0cnVjdFxuICBvcGVuIFNleHBsaWIwLlNleHBfY29udlxuXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBzZXhwXVxuXG4gIGxldCBjb21wYXJlID0gSW50LmNvbXBhcmVcbiAgbGV0IHNlZWQgOiB0IHJlZiA9IHJlZiAwXG5cbiAgbGV0IG5leHQgKCkgPVxuICAgIHNlZWQgOj0gIXNlZWQgKyAxO1xuICAgICFzZWVkXG5cbiAgbGV0IHdlbGxfa25vd24gaW50ID1cbiAgICBsZXQgKCkgPSBhc3NlcnQgKGludCA8PSAwKSBpblxuICAgIGludFxuXG4gIGxldCB0b19zdHJpbmcgPSBJbnQudG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBpbnRfb2Zfc3RyaW5nXG5lbmRcblxubW9kdWxlIE1hcCA9IE1hcC5NYWtlIChJZClcbm1vZHVsZSBTZXQgPSBTZXQuTWFrZSAoSWQpXG5cbigqIFRPRE86IHVzZSBgcHJpdmF0ZWAgdHlwZXMgZm9yIHdyYXAgKilcbnR5cGUgJ2Egd3JhcCA9IHsgaWQgOiBJZC50OyB2YWx1ZSA6ICdhIH0gW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IGNvbXBhcmUgKHUxIDogJ2Egd3JhcCkgKHUyIDogJ2Egd3JhcCkgOiBpbnQgPSBJZC5jb21wYXJlIHUxLmlkIHUyLmlkXG5sZXQgd3JhcCAoYSA6ICdhKSA6ICdhIHdyYXAgPSB7IGlkID0gSWQubmV4dCAoKTsgdmFsdWUgPSBhIH1cbmxldCB1bndyYXAgKHUgOiAnYSB3cmFwKSA6ICdhID0gdS52YWx1ZVxuXG5sZXQgd2VsbF9rbm93biAoaW50IDogaW50KSAoYSA6ICdhKSA6ICdhIHdyYXAgPVxuICB7IGlkID0gSWQud2VsbF9rbm93biBpbnQ7IHZhbHVlID0gYSB9XG5cbigqIG1vZHVsZSBFbWJlZGRlZCA9IHN0cnVjdFxuICAgICAoKiBUT0RPOiBtb2R1bGUgZGVmaW5pbmcgaG93IHRvIGV4dHJhY3QgYW4gSUQgKilcbiAgICAgKCogbW9kdWxlIEdldElkID0gc3RydWN0XG4gICAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcbiAgICAgICAgICBsZXQgaWQgKGkgOiB0KSA9IGkuaWRcbiAgICAgICAgZW5kXG4gICAgICAgIG1vZHVsZSBPcmRlcmVkVHlwZSA9IFV1aWQuT3JkZXJlZFR5cGUoR2V0SWQpICopXG4gICBlbmQgKilcbiIsInR5cGUgdCA9IExhbmcuQ29uc3RydWN0b3IudCBVdWlkLndyYXAgW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IG1rIDogTGFuZy5Db25zdHJ1Y3Rvci50IC0+IHQgPSBVdWlkLndyYXBcbmxldCByb290IDogdCA9IFV1aWQud2VsbF9rbm93biAwIExhbmcuQ29uc3RydWN0b3IuUm9vdF9yb290XG5cbm1vZHVsZSBPcmRlcmVkVHlwZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBjb21wYXJlID0gVXVpZC5jb21wYXJlXG5lbmRcblxubW9kdWxlIE1hcCA9IE1hcC5NYWtlIChPcmRlcmVkVHlwZSlcbm1vZHVsZSBTZXQgPSBTZXQuTWFrZSAoT3JkZXJlZFR5cGUpXG5cbigqIFN0cmluZyBDb252ZXJzaW9ucyAqKVxuXG5sZXQgdG9fc3RyaW5nICh2ZXJ0ZXggOiB0KSA6IHN0cmluZyA9IFV1aWQuSWQudG9fc3RyaW5nIHZlcnRleC5pZFxuXG5sZXQgc2V0X3RvX3N0cmluZyAodmVydGV4ZXMgOiBTZXQudCkgOiBzdHJpbmcgPVxuICBcIntcIlxuICBeIChTZXQuZm9sZCAoZnVuIHZlcnRleCBzdHJzIC0+IHRvX3N0cmluZyB2ZXJ0ZXggOjogc3RycykgdmVydGV4ZXMgW11cbiAgICB8PiBMaXN0LnJldiB8PiBTdHJpbmcuY29uY2F0IFwiLCBcIilcbiAgXiBcIn1cIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogVW5pdCBUZXN0c1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU29tZSB0ZXN0cyBvbiBob3cgdmVydGljZXMgd29yayAqKVxubGV0JXRlc3QgXCJyb290IHZlcnRleCBoYXMgaWQgMFwiID0gVXVpZC5JZC50b19zdHJpbmcgcm9vdC5pZCA9IFwiMFwiXG5cbigqIFNvbWUgY2hlY2tzIG9uIG91ciBhc3N1bXB0aW9ucyBhYm91dCBob3cgKHZlcnRleCkgc2V0cyB3b3JrLiAqKVxuXG5sZXQldGVzdCBcImVtcHR5IHNldCBoYXMgY2FyZGluYWxpdHkgMFwiID0gU2V0LihjYXJkaW5hbCBlbXB0eSkgPSAwXG5sZXQldGVzdCBcImVtcHR5IHNldCBoYXMgbm8gZWxlbWVudHNcIiA9IFNldC4oZWxlbWVudHMgZW1wdHkpID0gW11cblxubGV0JXRlc3QgXCJzaW5nbGV0b24gc2V0IGhhcyBjYXJkaW5hbGl0eSAxXCIgPVxuICBTZXQuKGVtcHR5IHw+IGFkZCAobWsgRXhwX2FwcCkgfD4gY2FyZGluYWwpID0gMVxuXG5sZXQldGVzdCBcInNpbmdsZXRvbiBzZXQgaGFzIG9uZSBlbGVtZW50XCIgPVxuICBsZXQgdiA9IG1rIEV4cF9hcHAgaW5cbiAgU2V0LihlbXB0eSB8PiBhZGQgdiB8PiBlbGVtZW50cykgPSBbIHYgXVxuXG5sZXQldGVzdCBcImFkZGluZyB0aGUgc2FtZSBlbGVtZW50IHR3aWNlIHByb2R1Y2VzIGEgc2luZ2xldG9uIHNldFwiID1cbiAgbGV0IHYgPSBtayBFeHBfYXBwIGluXG4gIGxldCB2cyA9IFNldC4oZW1wdHkgfD4gYWRkIHYgfD4gYWRkIHYpIGluXG4gIFNldC5jYXJkaW5hbCB2cyA9IDEgJiYgU2V0LmVsZW1lbnRzIHZzID0gWyB2IF1cblxubGV0JXRlc3QgXCJhZGRpbmcgdGhlIHNhbWUgZWxlbWVudCB0d2ljZSBwcm9kdWNlcyBhIHNpbmdsZXRvbiBzZXRcIiA9XG4gIGxldCB2ID0gbWsgRXhwX2FwcCBpblxuICBsZXQgdnMgPSBTZXQuKGVtcHR5IHw+IGFkZCB2IHw+IGFkZCB2KSBpblxuICBTZXQuY2FyZGluYWwgdnMgPSAxICYmIFNldC5lbGVtZW50cyB2cyA9IFsgdiBdXG5cbmxldCV0ZXN0IFwiYWRkaW5nIHRoZSBzYW1lIGVsZW1lbnQgdGhyaWNlIHByb2R1Y2VzIGEgc2luZ2xldG9uIHNldFwiID1cbiAgbGV0IHYgPSBtayBFeHBfYXBwIGluXG4gIGxldCB2cyA9IFNldC4oZW1wdHkgfD4gYWRkIHYgfD4gYWRkIHYgfD4gYWRkIHYpIGluXG4gIFNldC5jYXJkaW5hbCB2cyA9IDEgJiYgU2V0LmVsZW1lbnRzIHZzID0gWyB2IF1cblxubGV0JXRlc3QgXCJhZGRpbmcgYW5kIHJlbW92aW5nIGFuIGVsZW1lbnQgcHJvZHVjZXMgdGhlIGVtcHR5IHNldFwiID1cbiAgbGV0IHYgPSBtayBFeHBfYXBwIGluXG4gIGxldCB2cyA9IFNldC4oZW1wdHkgfD4gYWRkIHYgfD4gcmVtb3ZlIHYpIGluXG4gIFNldC5pc19lbXB0eSB2c1xuXG5sZXQldGVzdCBcInR3aWNlLWFkZGluZyBhbmQgb25jZS1yZW1vdmluZyBhbiBlbGVtZW50IHByb2R1Y2VzIHRoZSBlbXB0eSBzZXRcIiA9XG4gIGxldCB2ID0gbWsgRXhwX2FwcCBpblxuICBsZXQgdnMgPSBTZXQuKGVtcHR5IHw+IGFkZCB2IHw+IGFkZCB2IHw+IHJlbW92ZSB2KSBpblxuICBTZXQuaXNfZW1wdHkgdnNcbiIsIm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGxldCByZWMgaW50ZXJzcGVyc2UgKGRlbGltIDogJ2EpICh4cyA6ICdhIGxpc3QpIDogJ2EgbGlzdCA9XG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB4c1xuICAgIHwgeCA6OiB4cycgLT4geCA6OiBkZWxpbSA6OiBpbnRlcnNwZXJzZSBkZWxpbSB4cydcbmVuZFxuXG5tb2R1bGUgU2V4cCA9IHN0cnVjdFxuICBsZXQgcHJpbnQgKHNleHAgOiBTZXhwbGliMC5TZXhwLnQpIDogdW5pdCA9XG4gICAgU2V4cGxpYjAuU2V4cC50b19zdHJpbmdfaHVtIHNleHAgfD4gcHJpbnRfZW5kbGluZVxuXG4gIGxldCBvZl9tYXAgKGJpbmRpbmdzIDogKCdrICogJ3YpIGxpc3QpIChzZXhwX29mX2tleSA6ICdrIC0+IFNleHBsaWIuU2V4cC50KVxuICAgICAgKHNleHBfb2ZfdmFsdWUgOiAndiAtPiBTZXhwbGliLlNleHAudCkgOiBTZXhwbGliLlNleHAudCA9XG4gICAgU2V4cGxpYi5TdGQuc2V4cF9vZl9saXN0XG4gICAgICAoZnVuIChrLCB2KSAtPiBTZXhwbGliLlNleHAuTGlzdCBbIHNleHBfb2Zfa2V5IGs7IHNleHBfb2ZfdmFsdWUgdiBdKVxuICAgICAgYmluZGluZ3NcbmVuZFxuXG5tb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gICgqIE5vdGUgdGhhdCByZWZlcmVuY2VzIHRvIGBPcHRpb25gIGluIHRoaXMgbW9kdWxlIHJlZmVyIHRvIG9jYW1sJ3Mgb3B0aW9uICopXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gKG8gOiAnYSkgOiAnYSBvcHRpb24gPSBTb21lIG9cbiAgICAgIGxldCBtYXAgfihmIDogJ2EgLT4gJ2IpIChvIDogJ2Egb3B0aW9uKSA6ICdiIG9wdGlvbiA9IE9wdGlvbi5tYXAgZiBvXG5cbiAgICAgIGxldCBiaW5kIChvIDogJ2Egb3B0aW9uKSB+KGYgOiAnYSAtPiAnYiBvcHRpb24pIDogJ2Igb3B0aW9uID1cbiAgICAgICAgT3B0aW9uLmJpbmQgbyBmXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iLCJ0eXBlIHQgPSB7IHZlcnRleCA6IFZlcnRleC50OyBwb3NpdGlvbiA6IExhbmcuUG9zaXRpb24udCB9IFtAQGRlcml2aW5nIHNleHBdXG5cbmxldCB0b19zdHJpbmcgKGN1cnNvciA6IHQpIDogc3RyaW5nID1cbiAgRm9ybWF0LnNwcmludGYgXCIlcy4lc1wiXG4gICAgKFV1aWQuSWQudG9fc3RyaW5nIGN1cnNvci52ZXJ0ZXguaWQpXG4gICAgKExhbmcuUG9zaXRpb24uc2hvcnRfbmFtZSBjdXJzb3IucG9zaXRpb24pXG5cbmxldCByb290IDogdCA9IHsgdmVydGV4ID0gVmVydGV4LnJvb3Q7IHBvc2l0aW9uID0gUm9vdF9yb290X3Jvb3QgfVxuXG4oKiBUZXN0cyBmb3IgQ3Vyc29ycyAqKVxubGV0JXRlc3QgXCJyb290IGN1cnNvciBoYXMgVVVJRCAwXCIgPSBVdWlkLklkLnRvX3N0cmluZyByb290LnZlcnRleC5pZCA9IFwiMFwiXG5cbmxldCV0ZXN0IFwicm9vdCBjdXJzb3IgaGFzIHBvc2l0aW9uIFJvb3Rfcm9vdF9yb290XCIgPVxuICBMYW5nLlBvc2l0aW9uLmVxdWFsIHJvb3QucG9zaXRpb24gUm9vdF9yb290X3Jvb3RcblxubGV0JXRlc3QgXCJjdXJzb3IgcmVwcmVzZW50YXRpb25cIiA9IHRvX3N0cmluZyByb290ID0gXCIwLnJvb3RcIlxuIiwidHlwZSB0JyA9IHsgc291cmNlIDogQ3Vyc29yLnQ7IHRhcmdldCA6IFZlcnRleC50IH0gW0BAZGVyaXZpbmcgc2V4cF1cbnR5cGUgdCA9IHQnIFV1aWQud3JhcCBbQEBkZXJpdmluZyBzZXhwXVxuXG5sZXQgbWsgKHNvdXJjZSA6IEN1cnNvci50KSAodGFyZ2V0IDogVmVydGV4LnQpIDogdCA9XG4gIFV1aWQud3JhcCB7IHNvdXJjZTsgdGFyZ2V0IH1cblxubW9kdWxlIE9yZGVyZWRUeXBlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IGNvbXBhcmUgPSBVdWlkLmNvbXBhcmVcbmVuZFxuXG5tb2R1bGUgTWFwID0gTWFwLk1ha2UgKE9yZGVyZWRUeXBlKVxubW9kdWxlIFNldCA9IFNldC5NYWtlIChPcmRlcmVkVHlwZSlcblxubGV0IHBhcnRpdGlvbl9zZXQgKGVkZ2VzIDogU2V0LnQpIChwaXZvdCA6IFZlcnRleC50KSA6IFNldC50ICogU2V0LnQgPVxuICBTZXQucGFydGl0aW9uIChmdW4gZWRnZSAtPiBlZGdlLnZhbHVlLnNvdXJjZS52ZXJ0ZXggPSBwaXZvdCkgZWRnZXNcblxubGV0IHVuaW9uX3NldHMgKHNldHMgOiBTZXQudCBsaXN0KSA6IFNldC50ID1cbiAgTGlzdC5tYXAgU2V0LmVsZW1lbnRzIHNldHMgfD4gTGlzdC5jb25jYXQgfD4gU2V0Lm9mX2xpc3RcblxuKCogU3RyaW5nIENvbnZlcnNpb25zICopXG5cbmxldCB0b19zdHJpbmcgKGVkZ2UgOiB0KSA6IHN0cmluZyA9XG4gIFZlcnRleC50b19zdHJpbmcgZWRnZS52YWx1ZS5zb3VyY2UudmVydGV4XG4gIF4gXCI6XCJcbiAgXiBMYW5nLlBvc2l0aW9uLnNob3J0X25hbWUgZWRnZS52YWx1ZS5zb3VyY2UucG9zaXRpb25cbiAgXiBcIiAtPiBcIlxuICBeIFZlcnRleC50b19zdHJpbmcgZWRnZS52YWx1ZS50YXJnZXRcblxubGV0IHNldF90b19zdHJpbmcgKGVkZ2VzIDogU2V0LnQpIDogc3RyaW5nID1cbiAgXCJ7XCJcbiAgXiAoU2V0LmZvbGQgKGZ1biBlZGdlIHN0cnMgLT4gdG9fc3RyaW5nIGVkZ2UgOjogc3RycykgZWRnZXMgW11cbiAgICB8PiBMaXN0LnJldiB8PiBTdHJpbmcuY29uY2F0IFwiLCBcIilcbiAgXiBcIn1cIlxuIiwidHlwZSB0ID0gQ3JlYXRlZCB8IERlbGV0ZWQgW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nID0gZnVuY3Rpb24gQ3JlYXRlZCAtPiBcIitcIiB8IERlbGV0ZWQgLT4gXCItXCJcbiIsIm1vZHVsZSBNYXAgPSBNYXAuTWFrZSAoc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmVuZClcblxuaW5jbHVkZSBNYXBcbiIsInR5cGUgZXJyb3IgPSB7IG9yaWdpbiA6IHN0cmluZzsgdmVydGV4IDogVmVydGV4LnQ7IG1lc3NhZ2UgOiBzdHJpbmcgfVxudHlwZSAnYSB0ID0gU3VjY2VzcyBvZiAnYSB8IEVycm9yIG9mIGVycm9yIGxpc3RcblxubGV0IGVycm9yIChvcmlnaW4gOiBzdHJpbmcpICh2ZXJ0ZXggOiBWZXJ0ZXgudCkgOlxuICAgICgnYSwgdW5pdCwgc3RyaW5nLCAnYiB0KSBmb3JtYXQ0IC0+ICdhID1cbiAgUHJpbnRmLmtzcHJpbnRmIChmdW4gbWVzc2FnZSAtPiBFcnJvciBbIHsgb3JpZ2luOyB2ZXJ0ZXg7IG1lc3NhZ2UgfSBdKVxuXG4oKiBUT0RPOiBsZXQgd2l0aF9tZXNzYWdlICgnYSwgdW5pdCwgc3RyaW5nLCAnYiB0IC0+ICdiIHQpIGZvcm1hdDQgLT4gJ2EgPVxuICAgUHJpbnRmLmtzcHJpbnRmIChmdW4gbWVzc2FnZSB4IC0+IG1hdGNoIHggd2l0aCBTdWNjZXNzIHggLT4gU3VjY2VzcyB4IHwgRXJyb3IgZXMgLT4gTGlzdC5tYXAgKGZ1biBlIC0+IHtlIHdpdGggbWVzc2FnZSA9IH0pKSAqKVxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgYmluZCAobyA6ICdhIHQpIH4oZiA6ICdhIC0+ICdiIHQpIDogJ2IgdCA9XG4gICAgbWF0Y2ggbyB3aXRoIEVycm9yIGVzIC0+IEVycm9yIGVzIHwgU3VjY2VzcyBhIC0+IGYgYVxuXG4gIGxldCByZXR1cm4gKG8gOiAnYSkgOiAnYSB0ID0gU3VjY2VzcyBvXG5cbiAgbGV0IG1hcCB+KGYgOiAnYSAtPiAnYikgKG8gOiAnYSB0KSA6ICdiIHQgPVxuICAgIG1hdGNoIG8gd2l0aCBFcnJvciBfIC0+IG8gfCBTdWNjZXNzIGEgLT4gcmV0dXJuIChmIGEpXG5cbiAgbGV0IGJvdGggKG8xIDogJ2EgdCkgKG8yIDogJ2IgdCkgOiAoJ2EgKiAnYikgdCA9XG4gICAgbWF0Y2ggKG8xLCBvMikgd2l0aFxuICAgIHwgRXJyb3IgZXMxLCBFcnJvciBlczIgLT4gRXJyb3IgKGVzMSBAIGVzMilcbiAgICB8IEVycm9yIGVzMSwgXyAtPiBFcnJvciBlczFcbiAgICB8IF8sIEVycm9yIGVzMiAtPiBFcnJvciBlczJcbiAgICB8IFN1Y2Nlc3MgbzEsIFN1Y2Nlc3MgbzIgLT4gU3VjY2VzcyAobzEsIG8yKVxuZW5kXG5cbmluY2x1ZGUgTGV0X3N5bnRheFxuXG5sZXQgcmVjIHNlcXVlbmNlICh4cyA6ICdhIHQgbGlzdCkgOiAnYSBsaXN0IHQgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gcmV0dXJuIFtdXG4gIHwgeCA6OiB4cyAtPlxuICAgICAgbGV0JWJpbmQgeCcgPSB4IGFuZCB4cycgPSBzZXF1ZW5jZSB4cyBpblxuICAgICAgcmV0dXJuICh4JyA6OiB4cycpXG4iLCJ0eXBlIHQgPSB7IGVkZ2UgOiBFZGdlLnQ7IHN0YXRlIDogRWRnZV9zdGF0ZS50IH0gW0BAZGVyaXZpbmcgc2V4cF1cblxubGV0IHRvX3N0cmluZyAoZWRnZV9hY3Rpb24gOiB0KSA6IHN0cmluZyA9XG4gIEZvcm1hdC5zcHJpbnRmIFwiJXMgJXMg4oaSICVzXCJcbiAgICAoRWRnZV9zdGF0ZS50b19zdHJpbmcgZWRnZV9hY3Rpb24uc3RhdGUpXG4gICAgKEN1cnNvci50b19zdHJpbmcgZWRnZV9hY3Rpb24uZWRnZS52YWx1ZS5zb3VyY2UpXG4gICAgKFV1aWQuSWQudG9fc3RyaW5nIGVkZ2VfYWN0aW9uLmVkZ2UudmFsdWUudGFyZ2V0LmlkKVxuXG5tb2R1bGUgT3JkZXJlZFR5cGUgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbmVuZFxuXG5tb2R1bGUgTWFwID0gTWFwLk1ha2UgKE9yZGVyZWRUeXBlKVxubW9kdWxlIFNldCA9IFNldC5NYWtlIChPcmRlcmVkVHlwZSlcbiIsIm9wZW4gRWRnZV9zdGF0ZVxub3BlbiBFZGdlLk1hcFxuXG50eXBlIHQgPSBFZGdlX3N0YXRlLnQgRWRnZS5NYXAudFxuXG5sZXQgZW1wdHkgPSBFZGdlLk1hcC5lbXB0eVxubGV0IGFkZCA9IGFkZFxuXG5sZXQgYXBwbHlfYWN0aW9uIChncmFwaCA6IHQpIChhY3Rpb24gOiBHcmFwaF9hY3Rpb24udCkgOiB0ID1cbiAgbGV0IG9sZF9zdGF0ZSA9IGZpbmRfb3B0IGFjdGlvbi5lZGdlIGdyYXBoIGluXG4gIGxldCBuZXdfc3RhdGUgPSBhY3Rpb24uc3RhdGUgaW5cbiAgbWF0Y2ggKG9sZF9zdGF0ZSwgbmV3X3N0YXRlKSB3aXRoXG4gIHwgU29tZSBEZWxldGVkLCBfIC0+IGdyYXBoXG4gIHwgU29tZSBDcmVhdGVkLCBDcmVhdGVkIC0+IGdyYXBoXG4gIHwgKFNvbWUgQ3JlYXRlZCB8IE5vbmUpLCBEZWxldGVkIC0+IGFkZCBhY3Rpb24uZWRnZSBFZGdlX3N0YXRlLkRlbGV0ZWQgZ3JhcGhcbiAgfCBOb25lLCBDcmVhdGVkIC0+XG4gICAgICAoKiBUT0RPOiBhc3NlcnQgbm90IGFscmVhZHkgZXhpc3RzPyAqKVxuICAgICAgKCogVE9ETzogc2hvcnQgY2lyY3VpdCBpZiBkZWxldGluZyBhIG5vbi1leGlzdGFudCAqKVxuICAgICAgYWRkIGFjdGlvbi5lZGdlIEVkZ2Vfc3RhdGUuQ3JlYXRlZCBncmFwaFxuXG4oKiBFZGdlIFF1ZXJpZXMgKilcblxubGV0IGVkZ2VzIChncmFwaCA6IHQpIDogRWRnZS5TZXQudCA9XG4gIGJpbmRpbmdzIGdyYXBoIHw+IExpc3QubWFwIGZzdCB8PiBFZGdlLlNldC5vZl9saXN0XG5cbigqIEltcGxlbWVudHMganVkZ21lbnQgZm9yKilcbmxldCBsaXZlX2VkZ2VzIChncmFwaCA6IHQpIDogRWRnZS5TZXQudCA9XG4gIGJpbmRpbmdzIGdyYXBoXG4gIHw+IExpc3QuZmlsdGVyIChmdW5jdGlvbiBfLCBDcmVhdGVkIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICB8PiBMaXN0Lm1hcCBmc3QgfD4gRWRnZS5TZXQub2ZfbGlzdFxuXG5sZXQgcGFyZW50X2VkZ2VzIChncmFwaCA6IHQpICh2ZXJ0ZXggOiBWZXJ0ZXgudCkgOiBFZGdlLlNldC50ID1cbiAgbGl2ZV9lZGdlcyBncmFwaCB8PiBFZGdlLlNldC5maWx0ZXIgKGZ1biBlZGdlIC0+IGVkZ2UudmFsdWUudGFyZ2V0ID0gdmVydGV4KVxuXG5sZXQgY2hpbGRfZWRnZXMgKGdyYXBoIDogdCkgKHZlcnRleCA6IFZlcnRleC50KSAocG9zaXRpb24gOiBMYW5nLlBvc2l0aW9uLnQpIDpcbiAgICBFZGdlLlNldC50ID1cbiAgbGl2ZV9lZGdlcyBncmFwaFxuICB8PiBFZGdlLlNldC5maWx0ZXIgKGZ1biBlZGdlIC0+XG4gICAgICAgICBlZGdlLnZhbHVlLnNvdXJjZSA9IEN1cnNvci57IHZlcnRleDsgcG9zaXRpb24gfSlcblxuKCogVmVydGV4IFF1ZXJpZXMgKilcblxubGV0ICh2ZXJ0ZXhlcywgbGl2ZV92ZXJ0ZXhlcykgOiAodCAtPiBWZXJ0ZXguU2V0LnQpICogKHQgLT4gVmVydGV4LlNldC50KSA9XG4gIGxldCBpbXBsIChlZGdlX3NvdXJjZSA6IHQgLT4gRWRnZS5TZXQudCkgOiB0IC0+IFZlcnRleC5TZXQudCA9XG4gICBmdW4gZ3JhcGggLT5cbiAgICBWZXJ0ZXguU2V0LmVtcHR5XG4gICAgfD4gRWRnZS5TZXQuZm9sZFxuICAgICAgICAgKGZ1biBlZGdlIHZlcnRleGVzIC0+XG4gICAgICAgICAgIHZlcnRleGVzXG4gICAgICAgICAgIHw+IFZlcnRleC5TZXQuYWRkIGVkZ2UudmFsdWUuc291cmNlLnZlcnRleFxuICAgICAgICAgICB8PiBWZXJ0ZXguU2V0LmFkZCBlZGdlLnZhbHVlLnRhcmdldClcbiAgICAgICAgIChlZGdlX3NvdXJjZSBncmFwaClcbiAgaW5cbiAgKGltcGwgZWRnZXMsIGltcGwgbGl2ZV9lZGdlcylcblxubGV0IHBhcmVudF92ZXJ0ZXhlcyAoZ3JhcGggOiB0KSAodmVydGV4IDogVmVydGV4LnQpIDogVmVydGV4LlNldC50ID1cbiAgVmVydGV4LlNldC5lbXB0eVxuICB8PiBFZGdlLlNldC5mb2xkXG4gICAgICAgKGZ1biBlIC0+IFZlcnRleC5TZXQuYWRkIGUudmFsdWUuc291cmNlLnZlcnRleClcbiAgICAgICAocGFyZW50X2VkZ2VzIGdyYXBoIHZlcnRleClcblxubGV0IG9ycGhhbmVkIChncmFwaCA6IHQpIDogVmVydGV4LlNldC50ID1cbiAgdmVydGV4ZXMgZ3JhcGhcbiAgfD4gRWRnZS5TZXQuZm9sZFxuICAgICAgIChmdW4gZWRnZSAtPiBWZXJ0ZXguU2V0LnJlbW92ZSBlZGdlLnZhbHVlLnRhcmdldClcbiAgICAgICAobGl2ZV9lZGdlcyBncmFwaClcblxubGV0IGRlbGV0ZWQgKGdyYXBoIDogdCkgOiBWZXJ0ZXguU2V0LnQgPVxuICBvcnBoYW5lZCBncmFwaCB8PiBWZXJ0ZXguU2V0LnJlbW92ZSBWZXJ0ZXgucm9vdFxuXG5sZXQgbXVsdGlwYXJlbnRlZCAoZ3JhcGggOiB0KSA6IFZlcnRleC5TZXQudCA9XG4gICgqIGZpbmQgdGhlbSBhbGwgaW4gb25lIHBhc3MgKilcbiAgVmVydGV4Lk1hcC5lbXB0eVxuICB8PiBFZGdlLlNldC5mb2xkXG4gICAgICAgKGZ1biBlZGdlIC0+XG4gICAgICAgICBWZXJ0ZXguTWFwLnVwZGF0ZSBlZGdlLnZhbHVlLnRhcmdldCAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBOb25lIC0+IFNvbWUgMVxuICAgICAgICAgICB8IFNvbWUgXyAtPiBTb21lIDIpKVxuICAgICAgIChsaXZlX2VkZ2VzIGdyYXBoKVxuICB8PiBWZXJ0ZXguTWFwLmZpbHRlciAoZnVuIF8gY291bnQgLT4gY291bnQgPSAyKVxuICB8PiBWZXJ0ZXguTWFwLmJpbmRpbmdzIHw+IExpc3QubWFwIGZzdCB8PiBWZXJ0ZXguU2V0Lm9mX2xpc3RcblxubGV0IHZlcnRleCAoZ3JhcGggOiB0KSAodmVydGV4X2lkIDogVXVpZC5JZC50KSA6IFZlcnRleC50IG9wdGlvbiA9XG4gIHZlcnRleGVzIGdyYXBoXG4gIHw+IFZlcnRleC5TZXQuZmluZF9maXJzdF9vcHQgKGZ1biB2ZXJ0ZXggLT4gdmVydGV4LmlkID0gdmVydGV4X2lkKVxuXG4oKiBTLUV4cHJlc3Npb24gQ29udmVyc2lvbnMgKilcblxubGV0IHNleHBfb2ZfdCAoZ3JhcGggOiB0KSA6IFNleHBsaWIuU2V4cC50ID1cbiAgVXRpbC5TZXhwLm9mX21hcCAoYmluZGluZ3MgZ3JhcGgpIEVkZ2Uuc2V4cF9vZl90IEVkZ2Vfc3RhdGUuc2V4cF9vZl90XG5cbmxldCB0X29mX3NleHAgKHNleHAgOiBTZXhwbGliLlNleHAudCkgOiB0ID1cbiAgc2V4cFxuICB8PiBTZXhwbGliLlN0ZC5saXN0X29mX3NleHAgKGZ1bmN0aW9uXG4gICAgICAgfCBMaXN0IFsga2V5X3NleHA7IHZhbHVlX3NleHAgXSAtPlxuICAgICAgICAgICAoRWRnZS50X29mX3NleHAga2V5X3NleHAsIEVkZ2Vfc3RhdGUudF9vZl9zZXhwIHZhbHVlX3NleHApXG4gICAgICAgfCBfIC0+IGZhaWx3aXRoIF9fTE9DX18pXG4gIHw+IExpc3QudG9fc2VxIHw+IG9mX3NlcVxuIiwiKCogTm90ZSB0aGUgZm9sbG93aW5nIG1lYW5pbmdzIGZvciBIb2xlOlxuICAgLSBIb2xlIFtdID0gVW5rbm93biB0eXBlXG4gICAtIEhvbGUgW3QxOyB0Ml0gPSBUeXBlIGNvbmZsaWN0XG4gICAtIEhvbGUgW3RdID0gS2luZCBpbmNvbnNpc3RlbmN5XG4qKVxuXG4oKiBIb2xlIChpbnQ7IGJvb2wpIHZzIFN0cmluZyBpcyBhbiBlcnJvciAqKVxuKCogQ291bGQgZmFjdG9yIHdvcmtpbmcgcGFydHMgb2YgdHlwZXMgaW4gYSBob2xlICopXG4oKiBDb3VsZCB0cmVhdCB1c2Ugb2YgSG9sZSBhcyB1bmlvbiB0eXBlcyAqKVxuXG50eXBlIHQgPSBVbmtub3duIHwgTnVtIHwgQXJyb3cgb2YgdCAqIHQgfCBMaXN0IG9mIHQgW0BAZGVyaXZpbmcgc2hvd11cbiIsIm9wZW4gVHlwZVxubW9kdWxlIExldF9zeW50YXggPSBFcnJvci5MZXRfc3ludGF4XG5cbmxldCBlcnJvciA9IEVycm9yLmVycm9yXG5sZXQgcmV0dXJuID0gRXJyb3IucmV0dXJuXG5cbnR5cGUgdHlwZV9lbnYgPSBUeXBlLnQgRW52LnRcblxuKCogVE9ETzogZ2V0IHR5cGVzIGZvciBldmVyeXdoZXJlIHZpYSBhIE1hcCAqKVxuKCogVE9ETzogc2hvdyB0eXBlcyBhdCBjdXJzb3IsIHNlZSBIYXplbCdzIFwiQ3Vyc29yIEluZm9cIiAqKVxuXG5sZXQgY29uc2lzdGVudCAob3JpZ2luIDogc3RyaW5nKSAodmVydGV4IDogVmVydGV4LnQpIChleHBlY3RlZCA6IFR5cGUudClcbiAgICAoYWN0dWFsIDogVHlwZS50KSA6IHVuaXQgRXJyb3IudCA9XG4gIGxldCByZWMgZ28gZXhwZWN0ZWQgYWN0dWFsID1cbiAgICBtYXRjaCAoZXhwZWN0ZWQsIGFjdHVhbCkgd2l0aFxuICAgIHwgVW5rbm93biwgXyAtPiByZXR1cm4gKClcbiAgICB8IF8sIFVua25vd24gLT4gcmV0dXJuICgpXG4gICAgfCBOdW0sIE51bSAtPiByZXR1cm4gKClcbiAgICB8IEFycm93IChleHBlY3RlZDEsIGV4cGVjdGVkMiksIEFycm93IChhY3R1YWwxLCBhY3R1YWwyKSAtPlxuICAgICAgICBsZXQlYmluZCAoKSA9IGdvIGV4cGVjdGVkMSBhY3R1YWwxIGFuZCAoKSA9IGdvIGV4cGVjdGVkMiBhY3R1YWwyIGluXG4gICAgICAgIHJldHVybiAoKVxuICAgIHwgXywgXyAtPlxuICAgICAgICBlcnJvciBvcmlnaW4gdmVydGV4IFwiZXhwZWN0ZWQgdHlwZSAlczsgYWN0dWFsIHR5cGUgJXNcIiAoc2hvdyBleHBlY3RlZClcbiAgICAgICAgICAoc2hvdyBhY3R1YWwpXG4gIGluXG4gIGdvIGFjdHVhbCBleHBlY3RlZFxuXG5sZXQgbWF5YmVfdW5rbm93biAodHMgOiB0IGxpc3QpIDogdCA9IG1hdGNoIHRzIHdpdGggWyB0IF0gLT4gdCB8IF8gLT4gVW5rbm93blxuXG4oKiBUT0RPOiBhbmFseXplIGFnYWluc3QgdmVydGV4IGluc3RlYWQgb2YgdHlwZT8gKilcblxuKCogbGV0IHJlYyBjb25zaXN0ZW50X2N1cnNvciAoZ3JhcGggOiBHcmFwaHQudCkgKGN1cnNvcjEgOiBDdXJzb3IudCkgKGN1cnNvcjIgOiBDdXJzb3IudCkgKilcblxubGV0IG1hdGNoX2ZhaWwgKGxvYyA6IHN0cmluZykgKHNvcnQgOiBMYW5nLlNvcnQudCkgKHZlcnRleCA6IFZlcnRleC50KSA6ICdhID1cbiAgaWYgTGFuZy5Db25zdHJ1Y3Rvci5zb3J0X29mIHZlcnRleC52YWx1ZSA9IHNvcnQgdGhlblxuICAgIGZhaWx3aXRoXG4gICAgICAoUHJpbnRmLnNwcmludGYgXCIlczogTWlzc2luZyBjYXNlIGZvciAlcyBpbiAlc1wiIGxvY1xuICAgICAgICAgKExhbmcuQ29uc3RydWN0b3Iuc2hvdyB2ZXJ0ZXgudmFsdWUpXG4gICAgICAgICAoVXVpZC5JZC50b19zdHJpbmcgdmVydGV4LmlkKSlcbiAgZWxzZVxuICAgIGZhaWx3aXRoXG4gICAgICAoUHJpbnRmLnNwcmludGYgXCIlczogTm9uLVR5cCB2ZXJ0ZXggJXNcIiBsb2NcbiAgICAgICAgIChMYW5nLkNvbnN0cnVjdG9yLnNob3cgdmVydGV4LnZhbHVlKSlcblxuKCoqKioqKioqKioqKioqKVxuKCoqKiogVHlwZSAqKioqKVxuKCoqKioqKioqKioqKioqKVxuXG4oKiBUT0RPOiBjaGFuZ2UgJ2V2YWwnIHRvICdleHBhbmQnIChvciBvdGhlciBiZXR0ZXIgbmFtZT8pICopXG5sZXQgcmVjIGV2YWxfdHlwX3ZlcnRleCAoZ3JhcGggOiBHcmFwaC50KSAodmVydGV4IDogVmVydGV4LnQpIDogVHlwZS50IEVycm9yLnQgPVxuICBtYXRjaCB2ZXJ0ZXgudmFsdWUgd2l0aFxuICB8IFR5cF9udW0gLT4gcmV0dXJuIE51bVxuICB8IFR5cF9hcnJvdyAtPlxuICAgICAgbGV0JWJpbmQgdF9hcmcgPVxuICAgICAgICBldmFsX3R5cF9jdXJzb3IgZ3JhcGggQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiA9IFR5cF9hcnJvd19hcmcgfVxuICAgICAgYW5kIHRfcmVzdWx0ID1cbiAgICAgICAgZXZhbF90eXBfY3Vyc29yIGdyYXBoIEN1cnNvci57IHZlcnRleDsgcG9zaXRpb24gPSBUeXBfYXJyb3dfcmVzdWx0IH1cbiAgICAgIGluXG4gICAgICByZXR1cm4gKEFycm93ICh0X2FyZywgdF9yZXN1bHQpKVxuICB8IF8gLT4gbWF0Y2hfZmFpbCBfX0xPQ19fIExhbmcuU29ydC5UeXAgdmVydGV4XG5cbmFuZCBldmFsX3R5cF9jdXJzb3IgKGdyYXBoIDogR3JhcGgudCkgKGN1cnNvciA6IEN1cnNvci50KSA6IFR5cGUudCBFcnJvci50ID1cbiAgbGV0IGVkZ2VzID1cbiAgICBHcmFwaC5jaGlsZF9lZGdlcyBncmFwaCBjdXJzb3IudmVydGV4IGN1cnNvci5wb3NpdGlvbiB8PiBFZGdlLlNldC5lbGVtZW50c1xuICBpblxuICBsZXQgZ28gKGVkZ2UgOiBFZGdlLnQpID0gZXZhbF90eXBfdmVydGV4IGdyYXBoIGVkZ2UudmFsdWUudGFyZ2V0IGluXG4gIGxldCViaW5kIHRzID0gRXJyb3Iuc2VxdWVuY2UgKExpc3QubWFwIGdvIGVkZ2VzKSBpblxuICByZXR1cm4gKG1heWJlX3Vua25vd24gdHMpXG5cbigqKioqKioqKioqKioqKVxuKCoqKiogUGF0ICoqKiopXG4oKioqKioqKioqKioqKilcblxuKCogVE9ETzogc3luX3BhdF92ZXJ0ZXggKilcblxuKCogTm90ZSB0aGF0IHdlIGFkZCBhbGwgYmluZGluZ3MgaWYgdGhlcmUgaXMgYSBjb25mbGljdC4gQWxzbywgd2UgYXJlIG5vdFxuICAgY2hlY2tpbmcgZm9yIHNoYWRvd2luZyBiZXR3ZWVuIGNvbmZsaWN0aW5nIGJpbmRpbmdzLiAqKVxuXG5sZXQgcmVjIGFuYV9wYXRfdmVydGV4IChfZ3JhcGggOiBHcmFwaC50KSAoZW52IDogdHlwZV9lbnYpICh2ZXJ0ZXggOiBWZXJ0ZXgudClcbiAgICAodHlwIDogVHlwZS50KSA6IHR5cGVfZW52IEVycm9yLnQgPVxuICBtYXRjaCB2ZXJ0ZXgudmFsdWUgd2l0aFxuICB8IFBhdF92YXIgc3RyaW5nIC0+IHJldHVybiAoRW52LmFkZCBzdHJpbmcgdHlwIGVudilcbiAgfCBfIC0+IG1hdGNoX2ZhaWwgX19MT0NfXyBMYW5nLlNvcnQuUGF0IHZlcnRleFxuXG5hbmQgYW5hX3BhdF9jdXJzb3IgKGdyYXBoIDogR3JhcGgudCkgKGVudiA6IHR5cGVfZW52KSAoY3Vyc29yIDogQ3Vyc29yLnQpXG4gICAgKHR5cCA6IFR5cGUudCkgOiB0eXBlX2VudiBFcnJvci50ID1cbiAgbGV0IGVkZ2VzID1cbiAgICBHcmFwaC5jaGlsZF9lZGdlcyBncmFwaCBjdXJzb3IudmVydGV4IGN1cnNvci5wb3NpdGlvbiB8PiBFZGdlLlNldC5lbGVtZW50c1xuICBpblxuICBMaXN0LmZvbGRfbGVmdFxuICAgIChmdW4gZW52IChlZGdlIDogRWRnZS50KSAtPlxuICAgICAgbGV0JWJpbmQgZW52ID0gZW52IGluXG4gICAgICBhbmFfcGF0X3ZlcnRleCBncmFwaCBlbnYgZWRnZS52YWx1ZS50YXJnZXQgdHlwKVxuICAgIChyZXR1cm4gZW52KSBlZGdlc1xuXG4oKioqKioqKioqKioqKilcbigqKioqIEV4cCAqKioqKVxuKCoqKioqKioqKioqKiopXG5cbigqIFRPRE86IHZlcnRleGVzIHRvIHN0b3AgYXQgKilcbigqIFRPRE86IHR5cGUgbWFwICopXG4oKiBUT0RPOiBlcnJvciBtYXAgKilcblxubGV0IHJlYyBzeW5fZXhwX3ZlcnRleCAoZ3JhcGggOiBHcmFwaC50KSAoZW52IDogdHlwZV9lbnYpICh2ZXJ0ZXggOiBWZXJ0ZXgudCkgOlxuICAgIFR5cGUudCBFcnJvci50ID1cbiAgbWF0Y2ggdmVydGV4LnZhbHVlIHdpdGhcbiAgfCBFeHBfdmFyIHN0cmluZyAtPiAoXG4gICAgICBtYXRjaCBFbnYuZmluZF9vcHQgc3RyaW5nIGVudiB3aXRoXG4gICAgICB8IE5vbmUgLT4gZXJyb3IgX19MT0NfXyB2ZXJ0ZXggXCJ1bmJvdW5kIHZhcmlhYmxlOiAlc1wiIHN0cmluZ1xuICAgICAgfCBTb21lIHQgLT4gcmV0dXJuIHQpXG4gIHwgRXhwX2xhbSAtPlxuICAgICAgbGV0JWJpbmQgdHlwID1cbiAgICAgICAgZXZhbF90eXBfY3Vyc29yIGdyYXBoIEN1cnNvci57IHZlcnRleDsgcG9zaXRpb24gPSBFeHBfbGFtX3BhcmFtX3R5cGUgfVxuICAgICAgaW5cbiAgICAgIGxldCViaW5kIGVudicgPVxuICAgICAgICBhbmFfcGF0X2N1cnNvciBncmFwaCBlbnYgQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiA9IEV4cF9sYW1fcGFyYW0gfSB0eXBcbiAgICAgIGluXG4gICAgICBsZXQlYmluZCBib2R5ID1cbiAgICAgICAgc3luX2V4cF9jdXJzb3IgZ3JhcGggZW52JyBDdXJzb3IueyB2ZXJ0ZXg7IHBvc2l0aW9uID0gRXhwX2xhbV9ib2R5IH1cbiAgICAgIGluXG4gICAgICByZXR1cm4gKEFycm93ICh0eXAsIGJvZHkpKVxuICB8IEV4cF9hcHAgLT5cbiAgICAgIGxldCViaW5kIGZ1bmMgPVxuICAgICAgICBzeW5fZXhwX2N1cnNvciBncmFwaCBlbnYgQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiA9IEV4cF9hcHBfZnVuIH1cbiAgICAgIGluXG4gICAgICBsZXQlYmluZCBwYXJhbV90eXBlLCByZXN1bHRfdHlwZSA9XG4gICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICB8IFVua25vd24gLT4gcmV0dXJuIChVbmtub3duLCBVbmtub3duKVxuICAgICAgICB8IEFycm93IChwYXJhbV90eXBlLCByZXN1bHRfdHlwZSkgLT4gcmV0dXJuIChwYXJhbV90eXBlLCByZXN1bHRfdHlwZSlcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBlcnJvciBfX0xPQ19fIHZlcnRleCBcImV4cGVjdGVkIGEgZnVuY3Rpb24gdHlwZTsgYWN0dWFsIHR5cGUgJXNcIlxuICAgICAgICAgICAgICAoVHlwZS5zaG93IGZ1bmMpXG4gICAgICBpblxuICAgICAgbGV0JWJpbmQgKCkgPVxuICAgICAgICBhbmFfZXhwX2N1cnNvciBncmFwaCBlbnZcbiAgICAgICAgICBDdXJzb3IueyB2ZXJ0ZXg7IHBvc2l0aW9uID0gRXhwX2FwcF9hcmcgfVxuICAgICAgICAgIHBhcmFtX3R5cGVcbiAgICAgIGluXG4gICAgICByZXR1cm4gcmVzdWx0X3R5cGVcbiAgfCBFeHBfbnVtIF8gLT4gcmV0dXJuIE51bVxuICB8IEV4cF9wbHVzIC0+XG4gICAgICBsZXQlYmluZCAoKSA9XG4gICAgICAgIGFuYV9leHBfY3Vyc29yIGdyYXBoIGVudiBDdXJzb3IueyB2ZXJ0ZXg7IHBvc2l0aW9uID0gRXhwX3BsdXNfbGVmdCB9IE51bVxuICAgICAgYW5kICgpID1cbiAgICAgICAgYW5hX2V4cF9jdXJzb3IgZ3JhcGggZW52XG4gICAgICAgICAgQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiA9IEV4cF9wbHVzX3JpZ2h0IH1cbiAgICAgICAgICBOdW1cbiAgICAgIGluXG4gICAgICByZXR1cm4gTnVtXG4gIHwgXyAtPiBtYXRjaF9mYWlsIF9fTE9DX18gTGFuZy5Tb3J0LkV4cCB2ZXJ0ZXhcblxuYW5kIGFuYV9leHBfdmVydGV4IChncmFwaCA6IEdyYXBoLnQpIChlbnYgOiB0eXBlX2VudikgKHZlcnRleCA6IFZlcnRleC50KVxuICAgICh0eXAgOiBUeXBlLnQpIDogdW5pdCBFcnJvci50ID1cbiAgbWF0Y2ggdmVydGV4LnZhbHVlIHdpdGhcbiAgfCBFeHBfY29ucyAtPlxuICAgICAgbGV0JWJpbmQgY29udGVudCA9XG4gICAgICAgIG1hdGNoIHR5cCB3aXRoXG4gICAgICAgIHwgVW5rbm93biAtPiByZXR1cm4gVW5rbm93blxuICAgICAgICB8IExpc3QgdCAtPiByZXR1cm4gdFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGVycm9yIF9fTE9DX18gdmVydGV4IFwiZXhwZWN0ZWQgYSBsaXN0IHR5cGU7IGFjdHVhbCB0eXBlICVzXCJcbiAgICAgICAgICAgICAgKFR5cGUuc2hvdyB0eXApXG4gICAgICBpblxuICAgICAgbGV0JWJpbmQgKCkgPVxuICAgICAgICBhbmFfZXhwX2N1cnNvciBncmFwaCBlbnZcbiAgICAgICAgICBDdXJzb3IueyB2ZXJ0ZXg7IHBvc2l0aW9uID0gRXhwX2NvbnNfaGVhZCB9XG4gICAgICAgICAgY29udGVudFxuICAgICAgaW5cbiAgICAgIHJldHVybiAoKVxuICB8IF8gLT5cbiAgICAgICgqIFRPRE86IFdoZW4gd291bGQgd2Ugbm90IGp1c3QgY2FsbCBzeW4/ICopXG4gICAgICAoKiBUT0RPOiBOZWVkIHVuYW5ub3RhdGVkIGxhbWJkYSBvciBsZWZ0IG9yIHJpZ2h0IGluamVjdGlvbiAoYmFzZSBjYXNlKSBvciBsaXN0cyAoYmFzZSBjYXNlKSBvciB0dXBsZXMgKG5vIGJhc2UgY2FzZSkgKilcbiAgICAgIGxldCViaW5kIHR5cCcgPSBzeW5fZXhwX3ZlcnRleCBncmFwaCBlbnYgdmVydGV4IGluXG4gICAgICBjb25zaXN0ZW50IF9fTE9DX18gdmVydGV4IHR5cCB0eXAnXG5cbmFuZCBzeW5fZXhwX2N1cnNvciAoZ3JhcGggOiBHcmFwaC50KSAoZW52IDogdHlwZV9lbnYpIChjdXJzb3IgOiBDdXJzb3IudCkgOlxuICAgIFR5cGUudCBFcnJvci50ID1cbiAgbGV0IGVkZ2VzID1cbiAgICBHcmFwaC5jaGlsZF9lZGdlcyBncmFwaCBjdXJzb3IudmVydGV4IGN1cnNvci5wb3NpdGlvbiB8PiBFZGdlLlNldC5lbGVtZW50c1xuICBpblxuICBsZXQgZ28gKGVkZ2UgOiBFZGdlLnQpID0gc3luX2V4cF92ZXJ0ZXggZ3JhcGggZW52IGVkZ2UudmFsdWUudGFyZ2V0IGluXG4gIGxldCViaW5kIHRzID0gRXJyb3Iuc2VxdWVuY2UgKExpc3QubWFwIGdvIGVkZ2VzKSBpblxuICByZXR1cm4gKG1heWJlX3Vua25vd24gdHMpXG5cbmFuZCBhbmFfZXhwX2N1cnNvciAoZ3JhcGggOiBHcmFwaC50KSAoZW52IDogdHlwZV9lbnYpIChjdXJzb3IgOiBDdXJzb3IudClcbiAgICAodHlwIDogVHlwZS50KSA6IHVuaXQgRXJyb3IudCA9XG4gIGxldCBlZGdlcyA9XG4gICAgR3JhcGguY2hpbGRfZWRnZXMgZ3JhcGggY3Vyc29yLnZlcnRleCBjdXJzb3IucG9zaXRpb24gfD4gRWRnZS5TZXQuZWxlbWVudHNcbiAgaW5cbiAgbGV0JWJpbmQgKCkgPVxuICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAoZnVuIHByZXZpb3VzX3Jlc3VsdCAoZWRnZSA6IEVkZ2UudCkgLT5cbiAgICAgICAgbGV0JWJpbmQgKCkgPSBwcmV2aW91c19yZXN1bHRcbiAgICAgICAgYW5kICgpID0gYW5hX2V4cF92ZXJ0ZXggZ3JhcGggZW52IGVkZ2UudmFsdWUudGFyZ2V0IHR5cCBpblxuICAgICAgICByZXR1cm4gKCkpXG4gICAgICAocmV0dXJuICgpKSBlZGdlc1xuICBpblxuICByZXR1cm4gKClcblxubGV0IHN5bl9yb290X3ZlcnRleCAoZ3JhcGggOiBHcmFwaC50KSAoZW52IDogdHlwZV9lbnYpICh2ZXJ0ZXggOiBWZXJ0ZXgudCkgOlxuICAgIFR5cGUudCBFcnJvci50ID1cbiAgbWF0Y2ggdmVydGV4LnZhbHVlIHdpdGhcbiAgfCBSb290X3Jvb3QgLT5cbiAgICAgIHN5bl9leHBfY3Vyc29yIGdyYXBoIGVudiBDdXJzb3IueyB2ZXJ0ZXg7IHBvc2l0aW9uID0gUm9vdF9yb290X3Jvb3QgfVxuICB8IF8gLT4gbWF0Y2hfZmFpbCBfX0xPQ19fIExhbmcuU29ydC5Sb290IHZlcnRleFxuXG5sZXQgc3luX3Jvb3RfY3Vyc29yIChncmFwaCA6IEdyYXBoLnQpIChlbnYgOiB0eXBlX2VudikgKGN1cnNvciA6IEN1cnNvci50KSA6XG4gICAgVHlwZS50IEVycm9yLnQgPVxuICBsZXQgZWRnZXMgPVxuICAgIEdyYXBoLmNoaWxkX2VkZ2VzIGdyYXBoIGN1cnNvci52ZXJ0ZXggY3Vyc29yLnBvc2l0aW9uIHw+IEVkZ2UuU2V0LmVsZW1lbnRzXG4gIGluXG4gIGxldCBnbyAoZWRnZSA6IEVkZ2UudCkgPSBzeW5fcm9vdF92ZXJ0ZXggZ3JhcGggZW52IGVkZ2UudmFsdWUudGFyZ2V0IGluXG4gIGxldCViaW5kIHRzID0gRXJyb3Iuc2VxdWVuY2UgKExpc3QubWFwIGdvIGVkZ2VzKSBpblxuICByZXR1cm4gKG1heWJlX3Vua25vd24gdHMpXG5cbigqIFRPRE86IEltcGxlbWVudCBhbmFfcm9vdCAqKVxuIiwibW9kdWxlIE9yZGVyZWRUeXBlID0gc3RydWN0XG4gIHR5cGUgdCA9IExhbmcuUG9zaXRpb24udFxuXG4gIGxldCBjb21wYXJlID0gTGFuZy5Qb3NpdGlvbi5jb21wYXJlXG5lbmRcblxuaW5jbHVkZSBNYXAuTWFrZSAoT3JkZXJlZFR5cGUpXG5cbmxldCBnZXQgPyhkZWZhdWx0IDogJ2EgbGlzdCA9IFtdKSAocG9zaXRpb24gOiBrZXkpIChtYXAgOiAnYSBsaXN0IHQpIDogJ2EgbGlzdCA9XG4gIGZpbmRfb3B0IHBvc2l0aW9uIG1hcCB8PiBPcHRpb24udmFsdWUgfmRlZmF1bHRcblxubGV0IHB1c2ggKHBvc2l0aW9uIDoga2V5KSAoeCA6ICdhKSAobWFwIDogJ2EgbGlzdCB0KSA6ICdhIGxpc3QgdCA9XG4gIGxldCB4cyA9IGdldCBwb3NpdGlvbiBtYXAgaW5cbiAgcmVtb3ZlIHBvc2l0aW9uIG1hcCB8PiBhZGQgcG9zaXRpb24gKHggOjogeHMpXG4iLCJ0eXBlIHQgPSBWZXJ0ZXggb2YgVmVydGV4LnQgKiBjaGlsZHJlbiBQb3NpdGlvbl9tYXAudCB8IFJlZiBvZiBWZXJ0ZXgudFxuYW5kIGNoaWxkcmVuID0gY2hpbGQgbGlzdFxuYW5kIGNoaWxkID0geyBlZGdlX2lkIDogVXVpZC5JZC50OyB0cmVlIDogdCB9XG5cbmxldCBjaGlsZCAoZWRnZV9pZCA6IFV1aWQuSWQudCkgKHRyZWUgOiB0KSA6IGNoaWxkID0geyBlZGdlX2lkOyB0cmVlIH1cblxubGV0IGNoaWxkX21hcCA6XG4gICAgKExhbmcuUG9zaXRpb24udCAqIChVdWlkLklkLnQgKiB0KSBsaXN0KSBsaXN0IC0+IGNoaWxkcmVuIFBvc2l0aW9uX21hcC50ID1cbiAgTGlzdC5mb2xkX2xlZnRcbiAgICAoZnVuIGNoaWxkcmVuIChwb3NpdGlvbiwgY2hpbGRfc3BlY3MpIC0+XG4gICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAoZnVuIGNoaWxkcmVuIChlZGdlX2lkLCB0cmVlKSAtPlxuICAgICAgICAgIFBvc2l0aW9uX21hcC5wdXNoIHBvc2l0aW9uIChjaGlsZCBlZGdlX2lkIHRyZWUpIGNoaWxkcmVuKVxuICAgICAgICBjaGlsZHJlbiBjaGlsZF9zcGVjcylcbiAgICBQb3NpdGlvbl9tYXAuZW1wdHlcblxubGV0IHZlcnRleCAodmVydGV4IDogVmVydGV4LnQpXG4gICAgKGNoaWxkcmVuIDogKExhbmcuUG9zaXRpb24udCAqIChVdWlkLklkLnQgKiB0KSBsaXN0KSBsaXN0KSA6IHQgPVxuICBWZXJ0ZXggKHZlcnRleCwgY2hpbGRfbWFwIGNoaWxkcmVuKVxuXG5sZXQgcmVjIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBWZXJ0ZXggKHZlcnRleCwgbWFwKSAtPiAoXG4gICAgICBsZXQgY2hpbGRyZW4gPVxuICAgICAgICBQb3NpdGlvbl9tYXAuYmluZGluZ3MgbWFwXG4gICAgICAgIHw+IExpc3QubWFwIChmdW4gKHBvc2l0aW9uLCB0cmVlX2NoaWxkcmVuKSAtPlxuICAgICAgICAgICAgICAgRm9ybWF0LnNwcmludGYgXCIlcyAtPiAlc1wiXG4gICAgICAgICAgICAgICAgIChMYW5nLlBvc2l0aW9uLnNob3J0X25hbWUgcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgIChtYXRjaCBMaXN0Lmxlbmd0aCB0cmVlX2NoaWxkcmVuIHdpdGhcbiAgICAgICAgICAgICAgICAgfCAwIC0+IFwi4pahXCJcbiAgICAgICAgICAgICAgICAgfCAxIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBMaXN0LmhkIHRyZWVfY2hpbGRyZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgIHRvX3N0cmluZyBjaGlsZC50cmVlXG4gICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkcyA9XG4gICAgICAgICAgICAgICAgICAgICAgIExpc3QubWFwIChmdW4geyB0cmVlOyBfIH0gLT4gdHJlZSkgdHJlZV9jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgIFwie1wiXG4gICAgICAgICAgICAgICAgICAgICBeIChMaXN0Lm1hcCB0b19zdHJpbmcgY2hpbGRzIHw+IFN0cmluZy5jb25jYXQgXCIgfCBcIilcbiAgICAgICAgICAgICAgICAgICAgIF4gXCJ9XCIpKVxuICAgICAgICB8PiBTdHJpbmcuY29uY2F0IFwiOyBcIlxuICAgICAgaW5cbiAgICAgIGxldCBpZCA9IFV1aWQuSWQudG9fc3RyaW5nIHZlcnRleC5pZCBpblxuICAgICAgbWF0Y2ggY2hpbGRyZW4gd2l0aFxuICAgICAgfCBcIlwiIC0+IEZvcm1hdC5zcHJpbnRmIFwiVmVydGV4KCVzKVwiIGlkXG4gICAgICB8IF8gLT4gRm9ybWF0LnNwcmludGYgXCJWZXJ0ZXgoJXMsICVzKVwiIGlkIGNoaWxkcmVuKVxuICB8IFJlZiB2ZXJ0ZXggLT4gXCIjXCIgXiBVdWlkLklkLnRvX3N0cmluZyB2ZXJ0ZXguaWRcbiIsInR5cGUgdCA9IHtcbiAgaWQgOiBVdWlkLklkLnQ7XG4gIGdyYXBoIDogR3JhcGgudDtcbiAgY3Vyc29yIDogQ3Vyc29yLnQ7XG4gIGFjdGlvbnMgOiBHcmFwaF9hY3Rpb24uU2V0LnQ7XG4gIGtub3duX2FjdGlvbnMgOiBHcmFwaF9hY3Rpb24uU2V0LnQ7XG4gIHNob3dfaWRzIDogYm9vbDtcbn1cblxubGV0IHNleHBfb2ZfdCAoZWRpdG9yIDogdCkgOiBTZXhwbGliLlNleHAudCA9XG4gIFNleHBsaWIuU2V4cC5MaXN0XG4gICAgW1xuICAgICAgVXVpZC5JZC5zZXhwX29mX3QgZWRpdG9yLmlkO1xuICAgICAgR3JhcGguc2V4cF9vZl90IGVkaXRvci5ncmFwaDtcbiAgICAgIEN1cnNvci5zZXhwX29mX3QgZWRpdG9yLmN1cnNvcjtcbiAgICAgIFNleHBsaWIuU3RkLnNleHBfb2ZfbGlzdCBHcmFwaF9hY3Rpb24uc2V4cF9vZl90XG4gICAgICAgIChHcmFwaF9hY3Rpb24uU2V0LmVsZW1lbnRzIGVkaXRvci5hY3Rpb25zKTtcbiAgICAgIFNleHBsaWIuU3RkLnNleHBfb2ZfbGlzdCBHcmFwaF9hY3Rpb24uc2V4cF9vZl90XG4gICAgICAgIChHcmFwaF9hY3Rpb24uU2V0LmVsZW1lbnRzIGVkaXRvci5rbm93bl9hY3Rpb25zKTtcbiAgICAgIFNleHBsaWIuU3RkLnNleHBfb2ZfYm9vbCBlZGl0b3Iuc2hvd19pZHM7XG4gICAgXVxuXG5sZXQgdF9vZl9zZXhwIDogU2V4cGxpYi5TZXhwLnQgLT4gdCA9IGZ1bmN0aW9uXG4gIHwgU2V4cGxpYi5TZXhwLkxpc3RcbiAgICAgIFtcbiAgICAgICAgaWRfc2V4cDtcbiAgICAgICAgZ3JhcGhfc2V4cDtcbiAgICAgICAgY3Vyc29yX3NleHA7XG4gICAgICAgIGFjdGlvbnNfc2V4cDtcbiAgICAgICAga25vd25fYWN0aW9uc19zZXhwO1xuICAgICAgICBzaG93X2lkc19zZXhwO1xuICAgICAgXSAtPlxuICAgICAgbGV0IGlkID0gVXVpZC5JZC50X29mX3NleHAgaWRfc2V4cCBpblxuICAgICAgbGV0IGdyYXBoID0gR3JhcGgudF9vZl9zZXhwIGdyYXBoX3NleHAgaW5cbiAgICAgIGxldCBjdXJzb3IgPSBDdXJzb3IudF9vZl9zZXhwIGN1cnNvcl9zZXhwIGluXG4gICAgICBsZXQgYWN0aW9ucyA9XG4gICAgICAgIFNleHBsaWIuU3RkLmxpc3Rfb2Zfc2V4cCBHcmFwaF9hY3Rpb24udF9vZl9zZXhwIGFjdGlvbnNfc2V4cFxuICAgICAgICB8PiBHcmFwaF9hY3Rpb24uU2V0Lm9mX2xpc3RcbiAgICAgIGluXG4gICAgICBsZXQga25vd25fYWN0aW9ucyA9XG4gICAgICAgIFNleHBsaWIuU3RkLmxpc3Rfb2Zfc2V4cCBHcmFwaF9hY3Rpb24udF9vZl9zZXhwIGtub3duX2FjdGlvbnNfc2V4cFxuICAgICAgICB8PiBHcmFwaF9hY3Rpb24uU2V0Lm9mX2xpc3RcbiAgICAgIGluXG4gICAgICBsZXQgc2hvd19pZHMgPSBTZXhwbGliLlN0ZC5ib29sX29mX3NleHAgc2hvd19pZHNfc2V4cCBpblxuICAgICAgeyBpZDsgZ3JhcGg7IGN1cnNvcjsgYWN0aW9uczsga25vd25fYWN0aW9uczsgc2hvd19pZHMgfVxuICB8IF8gLT4gZmFpbHdpdGggX19MT0NfX1xuXG5sZXQgc2V4cF9vZl9tYXAgKGVkaXRvcnMgOiB0IFV1aWQuTWFwLnQpIDogU2V4cGxpYi5TZXhwLnQgPVxuICBVdWlkLk1hcC5iaW5kaW5ncyBlZGl0b3JzXG4gIHw+IFNleHBsaWIuU3RkLnNleHBfb2ZfbGlzdCAoZnVuIChpZCwgZWRpdG9yKSAtPlxuICAgICAgICAgU2V4cGxpYi5TZXhwLkxpc3QgWyBVdWlkLklkLnNleHBfb2ZfdCBpZDsgc2V4cF9vZl90IGVkaXRvciBdKVxuXG5sZXQgbWFwX29mX3NleHAgKHNleHAgOiBTZXhwbGliLlNleHAudCkgOiB0IFV1aWQuTWFwLnQgPVxuICBzZXhwXG4gIHw+IFNleHBsaWIuU3RkLmxpc3Rfb2Zfc2V4cCAoZnVuY3Rpb25cbiAgICAgICB8IFNleHBsaWIuU2V4cC5MaXN0IFsgaWRfc2V4cDsgZWRpdG9yX3NleHAgXSAtPlxuICAgICAgICAgICAoVXVpZC5JZC50X29mX3NleHAgaWRfc2V4cCwgdF9vZl9zZXhwIGVkaXRvcl9zZXhwKVxuICAgICAgIHwgXyAtPiBmYWlsd2l0aCBfX0xPQ19fKVxuICB8PiBMaXN0LnRvX3NlcSB8PiBVdWlkLk1hcC5vZl9zZXFcblxubGV0IG1rICgpIDogdCA9XG4gIHtcbiAgICBpZCA9IFV1aWQuSWQubmV4dCAoKTtcbiAgICBncmFwaCA9IEdyYXBoLmVtcHR5O1xuICAgIGN1cnNvciA9IEN1cnNvci5yb290O1xuICAgIGFjdGlvbnMgPSBHcmFwaF9hY3Rpb24uU2V0LmVtcHR5O1xuICAgIGtub3duX2FjdGlvbnMgPSBHcmFwaF9hY3Rpb24uU2V0LmVtcHR5O1xuICAgIHNob3dfaWRzID0gZmFsc2U7XG4gIH1cbiIsIm9wZW4gU2V4cGxpYjAuU2V4cF9jb252XG5cbnR5cGUgZ3JhcGhfYWN0aW9uX3NlcXVlbmNlID0gKFV1aWQuSWQudCAqIEdyYXBoX2FjdGlvbi50KSBsaXN0IFtAQGRlcml2aW5nIHNleHBdXG5cbnR5cGUgdCA9IHtcbiAgZWRpdG9ycyA6IEVkaXRvci50IFV1aWQuTWFwLnQ7XG4gIGFjdGlvbnMgOiBncmFwaF9hY3Rpb25fc2VxdWVuY2Ugb3B0aW9uO1xufVxuXG5sZXQgc2V4cF9vZl90IChtb2RlbCA6IHQpIDogU2V4cGxpYi5TZXhwLnQgPVxuICBTZXhwbGliLihcbiAgICBTZXhwLkxpc3RcbiAgICAgIFtcbiAgICAgICAgRWRpdG9yLnNleHBfb2ZfbWFwIG1vZGVsLmVkaXRvcnM7XG4gICAgICAgIHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfZ3JhcGhfYWN0aW9uX3NlcXVlbmNlIG1vZGVsLmFjdGlvbnM7XG4gICAgICBdKVxuXG5sZXQgdF9vZl9zZXhwIDogU2V4cGxpYi5TZXhwLnQgLT4gdCA9IGZ1bmN0aW9uXG4gIHwgTGlzdCBbIGVkaXRvcnNfc2V4cDsgYWN0aW9uc19zZXhwIF0gLT5cbiAgICAgIGxldCBlZGl0b3JzID0gRWRpdG9yLm1hcF9vZl9zZXhwIGVkaXRvcnNfc2V4cCBpblxuICAgICAgbGV0IGFjdGlvbnMgPVxuICAgICAgICBTZXhwbGliLlN0ZC5vcHRpb25fb2Zfc2V4cCBncmFwaF9hY3Rpb25fc2VxdWVuY2Vfb2Zfc2V4cCBhY3Rpb25zX3NleHBcbiAgICAgIGluXG4gICAgICB7IGVkaXRvcnM7IGFjdGlvbnMgfVxuICB8IF8gLT4gZmFpbHdpdGggX19MT0NfX1xuXG5sZXQgbWsgKCkgOiB0ID1cbiAgbGV0IGVkaXRvcjEgPSBFZGl0b3IubWsgKCkgaW5cbiAgbGV0IGVkaXRvcjIgPSBFZGl0b3IubWsgKCkgaW5cbiAgbGV0IGVkaXRvcnMgPVxuICAgIFV1aWQuTWFwLmVtcHR5XG4gICAgfD4gVXVpZC5NYXAuYWRkIGVkaXRvcjEuaWQgZWRpdG9yMVxuICAgIHw+IFV1aWQuTWFwLmFkZCBlZGl0b3IyLmlkIGVkaXRvcjJcbiAgaW5cbiAgeyBlZGl0b3JzOyBhY3Rpb25zID0gU29tZSBbXSB9XG5cbmxldCBjdXRvZmYgKG0xIDogdCkgKG0yIDogdCkgOiBib29sID0gbTEgPT0gbTJcblxubGV0IGZpbHRlcl9lZGl0b3JfYWN0aW9ucyAoZ2xvYmFsbHlfa25vd24gOiBHcmFwaF9hY3Rpb24uU2V0LnQpXG4gICAgKGVkaXRvciA6IEVkaXRvci50KSA6IEVkaXRvci50ID1cbiAgbGV0IGFjdGlvbnMgPVxuICAgIGVkaXRvci5hY3Rpb25zXG4gICAgfD4gR3JhcGhfYWN0aW9uLlNldC5maWx0ZXIgKGZ1biBhIC0+XG4gICAgICAgICAgIG5vdCAoR3JhcGhfYWN0aW9uLlNldC5tZW0gYSBnbG9iYWxseV9rbm93bikpXG4gIGluXG4gIHsgZWRpdG9yIHdpdGggYWN0aW9ucyB9XG5cbmxldCBnbG9iYWxseV9rbm93bl9hY3Rpb25zIChtb2RlbCA6IHQpIDogR3JhcGhfYWN0aW9uLlNldC50ID1cbiAgbGV0IGtub3ducyA9XG4gICAgVXVpZC5NYXAuYmluZGluZ3MgbW9kZWwuZWRpdG9yc1xuICAgIHw+IExpc3QubWFwIHNuZFxuICAgIHw+IExpc3QubWFwIChmdW4gRWRpdG9yLnsga25vd25fYWN0aW9uczsgXyB9IC0+IGtub3duX2FjdGlvbnMpXG4gIGluXG4gIExpc3QuZm9sZF9sZWZ0IEdyYXBoX2FjdGlvbi5TZXQuaW50ZXIgKExpc3QuaGQga25vd25zKSBrbm93bnNcblxubGV0IHJlbW92ZV9rbm93bl9hY3Rpb25zIChtb2RlbCA6IHQpIDogdCA9XG4gIGxldCBrbm93bl9hY3Rpb25zID0gZ2xvYmFsbHlfa25vd25fYWN0aW9ucyBtb2RlbCBpblxuICBsZXQgZWRpdG9ycyA9XG4gICAgVXVpZC5NYXAubWFwIChmaWx0ZXJfZWRpdG9yX2FjdGlvbnMga25vd25fYWN0aW9ucykgbW9kZWwuZWRpdG9yc1xuICBpblxuICB7IG1vZGVsIHdpdGggZWRpdG9ycyB9XG4iLCJ0eXBlIHQgPSB7XG4gIG11bHRpcGFyZW50ZWQgOiBUcmVlLnQgbGlzdDtcbiAgZGVsZXRlZCA6IFRyZWUudCBsaXN0O1xuICByZWFjaGFibGUgOiBUcmVlLnQ7XG4gIHdyZWF0aHMgOiBUcmVlLnQgbGlzdDsgKCogdW5pY3ljbGVzICopXG59XG5cbnR5cGUgaW5fZGVncmVlID0gT25lIHwgTWFueVxuXG5sZXQgcHVzaF9lZGdlICh2ZXJ0ZXggOiBWZXJ0ZXgudCkgKGVkZ2UgOiBFZGdlLnQpIDpcbiAgICBFZGdlLlNldC50IFZlcnRleC5NYXAudCAtPiBFZGdlLlNldC50IFZlcnRleC5NYXAudCA9XG4gIFZlcnRleC5NYXAudXBkYXRlIHZlcnRleCAoZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gU29tZSAoRWRnZS5TZXQuc2luZ2xldG9uIGVkZ2UpXG4gICAgfCBTb21lIGVkZ2VzIC0+IFNvbWUgKEVkZ2UuU2V0LmFkZCBlZGdlIGVkZ2VzKSlcblxuKCogdmVydGljZXMgd2l0aCBubyBsaXZlIChwYXJlbnRzfGNoaWxkcmVuKSBtYXAgdG8gTm9uZSAqKVxubGV0IGFkamFjZW5jeV9tYXBzIChsaXZlX2VkZ2VzIDogRWRnZS5TZXQudCkgOlxuICAgIEVkZ2UuU2V0LnQgVmVydGV4Lk1hcC50ICogRWRnZS5TZXQudCBWZXJ0ZXguTWFwLnQgPVxuICAoVmVydGV4Lk1hcC5lbXB0eSwgVmVydGV4Lk1hcC5lbXB0eSlcbiAgfD4gRWRnZS5TZXQuZm9sZFxuICAgICAgIChmdW4gZWRnZSAocGFyZW50cywgY2hpbGRyZW4pIC0+XG4gICAgICAgICAoIHB1c2hfZWRnZSBlZGdlLnZhbHVlLnRhcmdldCBlZGdlIHBhcmVudHMsXG4gICAgICAgICAgIHB1c2hfZWRnZSBlZGdlLnZhbHVlLnNvdXJjZS52ZXJ0ZXggZWRnZSBjaGlsZHJlbiApKVxuICAgICAgIGxpdmVfZWRnZXNcblxuKCogdmVydGljZXMgd2l0aCBpbi1kZWdyZWUgMCBtYXAgdG8gTm9uZSAqKVxubGV0IGluX2RlZ3JlZV9tYXAgKGxpdmVfZWRnZXMgOiBFZGdlLlNldC50KSA6IGluX2RlZ3JlZSBWZXJ0ZXguTWFwLnQgPVxuICBWZXJ0ZXguTWFwLmVtcHR5XG4gIHw+IEVkZ2UuU2V0LmZvbGRcbiAgICAgICAoZnVuIGVkZ2UgbWFwIC0+XG4gICAgICAgICBtYXBcbiAgICAgICAgIHw+IFZlcnRleC5NYXAudXBkYXRlIGVkZ2UudmFsdWUudGFyZ2V0IChmdW5jdGlvblxuICAgICAgICAgICAgICB8IE5vbmUgLT4gU29tZSBPbmVcbiAgICAgICAgICAgICAgfCBTb21lIChPbmUgfCBNYW55KSAtPiBTb21lIE1hbnkpKVxuICAgICAgIGxpdmVfZWRnZXNcblxubGV0IHB1c2hfdmVydGV4ICh2ZXJ0ZXggOiBWZXJ0ZXgudClcbiAgICAoKG11bHRpdiwgdW5pdiwgYXYpIDogVmVydGV4LlNldC50ICogVmVydGV4LlNldC50ICogVmVydGV4LlNldC50KVxuICAgIChpbl9kZWdyZWVzIDogaW5fZGVncmVlIFZlcnRleC5NYXAudCkgOlxuICAgIFZlcnRleC5TZXQudCAqIFZlcnRleC5TZXQudCAqIFZlcnRleC5TZXQudCA9XG4gIG1hdGNoIFZlcnRleC5NYXAuZmluZF9vcHQgdmVydGV4IGluX2RlZ3JlZXMgd2l0aFxuICB8IFNvbWUgTWFueSAtPiAoVmVydGV4LlNldC5hZGQgdmVydGV4IG11bHRpdiwgdW5pdiwgYXYpXG4gIHwgU29tZSBPbmUgLT4gKG11bHRpdiwgVmVydGV4LlNldC5hZGQgdmVydGV4IHVuaXYsIGF2KVxuICB8IE5vbmUgLT4gKG11bHRpdiwgdW5pdiwgVmVydGV4LlNldC5hZGQgdmVydGV4IGF2KVxuXG4oKiBlZGdlcyAtPiB2ZXJ0ZXggc2V0cyAqKVxubGV0IHBhcnRpdGlvbl92ZXJ0ZXhlcyAoYWxsX2VkZ2VzIDogRWRnZS5TZXQudClcbiAgICAoaW5fZGVncmVlcyA6IGluX2RlZ3JlZSBWZXJ0ZXguTWFwLnQpIDpcbiAgICBWZXJ0ZXguU2V0LnQgKiBWZXJ0ZXguU2V0LnQgKiBWZXJ0ZXguU2V0LnQgPVxuICAoVmVydGV4LlNldC5lbXB0eSwgVmVydGV4LlNldC5lbXB0eSwgVmVydGV4LlNldC5lbXB0eSlcbiAgfD4gRWRnZS5TZXQuZm9sZFxuICAgICAgIChmdW4gZWRnZSAobXVsdGl2LCB1bml2LCBhdikgLT5cbiAgICAgICAgIGxldCBtdWx0aXYsIHVuaXYsIGF2ID1cbiAgICAgICAgICAgcHVzaF92ZXJ0ZXggZWRnZS52YWx1ZS50YXJnZXQgKG11bHRpdiwgdW5pdiwgYXYpIGluX2RlZ3JlZXNcbiAgICAgICAgIGluXG4gICAgICAgICBwdXNoX3ZlcnRleCBlZGdlLnZhbHVlLnNvdXJjZS52ZXJ0ZXggKG11bHRpdiwgdW5pdiwgYXYpIGluX2RlZ3JlZXMpXG4gICAgICAgYWxsX2VkZ2VzXG5cbigqIHZlcnRleCAtPiB0cmVlICopXG5sZXQgcmVjIHRyYXZlcnNlX3ZlcnRleCA/KHNlZW4gOiBWZXJ0ZXguU2V0LnQgPSBWZXJ0ZXguU2V0LmVtcHR5KVxuICAgID8ocmVtYWluaW5nIDogVmVydGV4LlNldC50ID0gVmVydGV4LlNldC5lbXB0eSkgKHZlcnRleCA6IFZlcnRleC50KVxuICAgIChjaGlsZHJlbiA6IEVkZ2UuU2V0LnQgVmVydGV4Lk1hcC50KSA6IFRyZWUudCAqIFZlcnRleC5TZXQudCAqIFZlcnRleC5TZXQudFxuICAgID1cbiAgaWYgVmVydGV4LlNldC5tZW0gdmVydGV4IHNlZW4gdGhlbiAoUmVmIHZlcnRleCwgc2VlbiwgcmVtYWluaW5nKVxuICBlbHNlXG4gICAgbGV0IHNlZW4gPSBWZXJ0ZXguU2V0LmFkZCB2ZXJ0ZXggc2VlbiBpblxuICAgIGxldCByZW1haW5pbmcgPSBWZXJ0ZXguU2V0LnJlbW92ZSB2ZXJ0ZXggcmVtYWluaW5nIGluXG4gICAgbGV0IGVkZ2VzID1cbiAgICAgIFZlcnRleC5NYXAuZmluZF9vcHQgdmVydGV4IGNoaWxkcmVuXG4gICAgICB8PiBPcHRpb24udmFsdWUgfmRlZmF1bHQ6RWRnZS5TZXQuZW1wdHlcbiAgICBpblxuICAgIGxldCBjaGlsZHJlbiwgc2VlbiwgcmVtYWluaW5nID1cbiAgICAgIHRyYXZlcnNlX2VkZ2VzIGVkZ2VzIGNoaWxkcmVuIH5zZWVuIH5yZW1haW5pbmdcbiAgICBpblxuICAgIChWZXJ0ZXggKHZlcnRleCwgY2hpbGRyZW4pLCBzZWVuLCByZW1haW5pbmcpXG5cbigqIGVkZ2VzIC0+IHBvc2l0aW9uIG1hcCAqKVxuYW5kIHRyYXZlcnNlX2VkZ2VzIH4oc2VlbiA6IFZlcnRleC5TZXQudCkgfihyZW1haW5pbmcgOiBWZXJ0ZXguU2V0LnQpXG4gICAgKGVkZ2VzIDogRWRnZS5TZXQudCkgKGNoaWxkcmVuIDogRWRnZS5TZXQudCBWZXJ0ZXguTWFwLnQpIDpcbiAgICBUcmVlLmNoaWxkcmVuIFBvc2l0aW9uX21hcC50ICogVmVydGV4LlNldC50ICogVmVydGV4LlNldC50ID1cbiAgRWRnZS5TZXQuZWxlbWVudHMgZWRnZXNcbiAgfD4gTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuICh0cmVlX2NoaWxkcmVuLCBzZWVuLCByZW1haW5pbmcpIChlZGdlIDogRWRnZS50KSAtPlxuICAgICAgICAgbGV0IHRyZWUsIHNlZW4sIHJlbWFpbmluZyA9XG4gICAgICAgICAgIHRyYXZlcnNlX3ZlcnRleCBlZGdlLnZhbHVlLnRhcmdldCBjaGlsZHJlbiB+c2VlbiB+cmVtYWluaW5nXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IHRyZWVfY2hpbGRyZW4gPVxuICAgICAgICAgICBQb3NpdGlvbl9tYXAucHVzaCBlZGdlLnZhbHVlLnNvdXJjZS5wb3NpdGlvblxuICAgICAgICAgICAgIChUcmVlLmNoaWxkIGVkZ2UuaWQgdHJlZSkgdHJlZV9jaGlsZHJlblxuICAgICAgICAgaW5cbiAgICAgICAgICh0cmVlX2NoaWxkcmVuLCBzZWVuLCByZW1haW5pbmcpKVxuICAgICAgIChQb3NpdGlvbl9tYXAuZW1wdHksIHNlZW4sIHJlbWFpbmluZylcblxuKCogdmVydGljZXMgLT4gdHJlZXMgKilcbmxldCByZWMgdHJhdmVyc2VfdmVydGV4ZXMgfihzZWVuIDogVmVydGV4LlNldC50KSB+KHJlbWFpbmluZyA6IFZlcnRleC5TZXQudClcbiAgICAodmVydGV4ZXMgOiBWZXJ0ZXguU2V0LnQpIChjaGlsZHJlbiA6IEVkZ2UuU2V0LnQgVmVydGV4Lk1hcC50KSA6XG4gICAgVHJlZS50IGxpc3QgKiBWZXJ0ZXguU2V0LnQgKiBWZXJ0ZXguU2V0LnQgPVxuICBtYXRjaCBWZXJ0ZXguU2V0LmNob29zZV9vcHQgdmVydGV4ZXMgd2l0aFxuICB8IE5vbmUgLT4gKFtdLCBzZWVuLCByZW1haW5pbmcpXG4gIHwgU29tZSB2ZXJ0ZXggLT5cbiAgICAgIGxldCB0cmVlLCBzZWVuLCByZW1haW5pbmcgPVxuICAgICAgICB0cmF2ZXJzZV92ZXJ0ZXggdmVydGV4IGNoaWxkcmVuIH5zZWVuIH5yZW1haW5pbmdcbiAgICAgIGluXG4gICAgICBsZXQgcm9vdHMgPSBWZXJ0ZXguU2V0LnJlbW92ZSB2ZXJ0ZXggdmVydGV4ZXMgaW5cbiAgICAgIGxldCB0cmVlcywgc2VlbiwgcmVtYWluaW5nID1cbiAgICAgICAgdHJhdmVyc2VfdmVydGV4ZXMgcm9vdHMgY2hpbGRyZW4gfnNlZW4gfnJlbWFpbmluZ1xuICAgICAgaW5cbiAgICAgICh0cmVlIDo6IHRyZWVzLCBzZWVuLCByZW1haW5pbmcpXG5cbigqIHZlcnRleCAtPiB2ZXJ0ZXggKilcbmxldCByZWMgd2Fsa191cCB+KHNlZW4gOiBWZXJ0ZXguU2V0LnQpICh2ZXJ0ZXggOiBWZXJ0ZXgudClcbiAgICAocGFyZW50cyA6IEVkZ2UuU2V0LnQgVmVydGV4Lk1hcC50KSA6IFZlcnRleC50ID1cbiAgaWYgVmVydGV4LlNldC5tZW0gdmVydGV4IHNlZW4gdGhlbiB2ZXJ0ZXhcbiAgZWxzZVxuICAgIG1hdGNoIFZlcnRleC5NYXAuZmluZF9vcHQgdmVydGV4IHBhcmVudHMgd2l0aFxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFNvbWUgZWRnZXMgLT5cbiAgICAgICAgYXNzZXJ0IChFZGdlLlNldC5jYXJkaW5hbCBlZGdlcyA9IDEpO1xuICAgICAgICBsZXQgZWRnZSA9IEVkZ2UuU2V0Lm1pbl9lbHQgZWRnZXMgaW5cbiAgICAgICAgbGV0IHNlZW4gPSBWZXJ0ZXguU2V0LmFkZCB2ZXJ0ZXggc2VlbiBpblxuICAgICAgICB3YWxrX3VwIGVkZ2UudmFsdWUuc291cmNlLnZlcnRleCBwYXJlbnRzIH5zZWVuXG5cbigqIHZlcnRpY2VzIC0+IHRyZWVzICopXG5sZXQgcmVjIHdyZWF0aF90cmF2ZXJzZSB+KHNlZW4gOiBWZXJ0ZXguU2V0LnQpIChyZW1haW5pbmcgOiBWZXJ0ZXguU2V0LnQpXG4gICAgKHBhcmVudHMgOiBFZGdlLlNldC50IFZlcnRleC5NYXAudCkgKGNoaWxkcmVuIDogRWRnZS5TZXQudCBWZXJ0ZXguTWFwLnQpIDpcbiAgICBUcmVlLnQgbGlzdCA9XG4gIGlmIFZlcnRleC5TZXQuaXNfZW1wdHkgcmVtYWluaW5nIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCB2MCA9IFZlcnRleC5TZXQubWluX2VsdCByZW1haW5pbmcgaW5cbiAgICBsZXQgcm9vdCA9IHdhbGtfdXAgdjAgcGFyZW50cyB+c2VlbjpyZW1haW5pbmcgaW5cbiAgICBsZXQgdHJlZSwgc2VlbiwgcmVtYWluaW5nID1cbiAgICAgIHRyYXZlcnNlX3ZlcnRleCByb290IGNoaWxkcmVuIH5zZWVuIH5yZW1haW5pbmdcbiAgICBpblxuICAgIHRyZWUgOjogd3JlYXRoX3RyYXZlcnNlIHJlbWFpbmluZyBwYXJlbnRzIGNoaWxkcmVuIH5zZWVuXG5cbmxldCBkZWNvbXBvc2UgKGdyYXBoIDogR3JhcGgudCkgOiB0ICogRWRnZS5TZXQudCBWZXJ0ZXguTWFwLnQgPVxuICBsZXQgYWxsX2VkZ2VzID0gR3JhcGguZWRnZXMgZ3JhcGggaW5cbiAgbGV0IGxpdmVfZWRnZXMgPSBHcmFwaC5saXZlX2VkZ2VzIGdyYXBoIGluXG4gIGxldCBwYXJlbnRzLCBjaGlsZHJlbiA9IGFkamFjZW5jeV9tYXBzIGxpdmVfZWRnZXMgaW5cbiAgbGV0IGluX2RlZ3JlZXMgPSBpbl9kZWdyZWVfbWFwIGxpdmVfZWRnZXMgaW5cbiAgbGV0IG11bHRpdiwgdW5pdiwgYXYgPSBwYXJ0aXRpb25fdmVydGV4ZXMgYWxsX2VkZ2VzIGluX2RlZ3JlZXMgaW5cbiAgbGV0IGF2ID0gVmVydGV4LlNldC5yZW1vdmUgVmVydGV4LnJvb3QgYXYgaW5cbiAgbGV0IG11bHRpcGFyZW50ZWQsIHNlZW4sIHJlbWFpbmluZyA9XG4gICAgdHJhdmVyc2VfdmVydGV4ZXMgbXVsdGl2IGNoaWxkcmVuIH5zZWVuOlZlcnRleC5TZXQuZW1wdHkgfnJlbWFpbmluZzp1bml2XG4gIGluXG4gIGxldCBkZWxldGVkLCBzZWVuLCByZW1haW5pbmcgPVxuICAgIHRyYXZlcnNlX3ZlcnRleGVzIGF2IGNoaWxkcmVuIH5zZWVuIH5yZW1haW5pbmdcbiAgaW5cbiAgbGV0IHJlYWNoYWJsZSwgc2VlbiwgcmVtYWluaW5nID1cbiAgICB0cmF2ZXJzZV92ZXJ0ZXggVmVydGV4LnJvb3QgY2hpbGRyZW4gfnNlZW4gfnJlbWFpbmluZ1xuICBpblxuICBsZXQgd3JlYXRocyA9IHdyZWF0aF90cmF2ZXJzZSByZW1haW5pbmcgcGFyZW50cyBjaGlsZHJlbiB+c2VlbiBpblxuICAoeyBtdWx0aXBhcmVudGVkOyBkZWxldGVkOyByZWFjaGFibGU7IHdyZWF0aHMgfSwgY2hpbGRyZW4pXG5cbigqIFVuaXQgVGVzdHMgKilcblxubGV0JXRlc3RfbW9kdWxlIFwiR3JhcGguZGVjb21wb3NlXCIgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIGxldCBwcmludF9yZXN1bHRzID0gdHJ1ZVxuXG4gICAgbGV0IHJlcG9ydF90cmVlIChwcmVmaXggOiBzdHJpbmcpICh0cmVlIDogVHJlZS50KSA6IHVuaXQgPVxuICAgICAgcHJpbnRfc3RyaW5nIChcIlxcblwiIF4gcHJlZml4IF4gXCI6IFwiIF4gVHJlZS50b19zdHJpbmcgdHJlZSlcblxuICAgIGxldCByZXBvcnRfdHJlZXMgKHByZWZpeCA6IHN0cmluZykgKHRyZWVzIDogVHJlZS50IGxpc3QpIDogdW5pdCA9XG4gICAgICBwcmludF9zdHJpbmcgKFwiXFxuXCIgXiBwcmVmaXggXiBcIjpcIik7XG4gICAgICBMaXN0Lml0ZXIgKGZ1biB0cmVlIC0+IHByaW50X3N0cmluZyAoXCJcXG4gIFwiIF4gVHJlZS50b19zdHJpbmcgdHJlZSkpIHRyZWVzXG5cbiAgICBsZXQgY2hlY2tfZGVjb21wb3NlID8obXVsdGlwYXJlbnRlZCA6IFRyZWUudCBsaXN0ID0gW10pXG4gICAgICAgID8oZGVsZXRlZCA6IFRyZWUudCBsaXN0ID0gW10pXG4gICAgICAgID8ocmVhY2hhYmxlIDogVHJlZS50ID0gVmVydGV4IChWZXJ0ZXgucm9vdCwgUG9zaXRpb25fbWFwLmVtcHR5KSlcbiAgICAgICAgPyh3cmVhdGhzIDogVHJlZS50IGxpc3QgPSBbXSkgKGdyYXBoIDogR3JhcGgudCkgOiBib29sID1cbiAgICAgIGxldCBnb3QsIF8gPSBkZWNvbXBvc2UgZ3JhcGggaW5cbiAgICAgIGxldCB3YW50ID0geyBtdWx0aXBhcmVudGVkOyBkZWxldGVkOyByZWFjaGFibGU7IHdyZWF0aHMgfSBpblxuICAgICAgZ290ID0gd2FudFxuICAgICAgfHxcbiAgICAgIChpZiBwcmludF9yZXN1bHRzIHRoZW4gKFxuICAgICAgICAgcHJpbnRfc3RyaW5nIFwiXFxuXFxuLS1cXG5HT1Q6XCI7XG4gICAgICAgICByZXBvcnRfdHJlZXMgXCJNUFwiIGdvdC5tdWx0aXBhcmVudGVkO1xuICAgICAgICAgcmVwb3J0X3RyZWVzIFwiRFwiIGdvdC5kZWxldGVkO1xuICAgICAgICAgcmVwb3J0X3RyZWUgXCJSXCIgZ290LnJlYWNoYWJsZTtcbiAgICAgICAgIHJlcG9ydF90cmVlcyBcIlNDXCIgZ290LndyZWF0aHM7XG4gICAgICAgICBwcmludF9zdHJpbmcgXCJcXG5cXG5XQU5UOlwiO1xuICAgICAgICAgcmVwb3J0X3RyZWVzIFwiTVBcIiBtdWx0aXBhcmVudGVkO1xuICAgICAgICAgcmVwb3J0X3RyZWVzIFwiRFwiIGRlbGV0ZWQ7XG4gICAgICAgICByZXBvcnRfdHJlZSBcIlJcIiByZWFjaGFibGU7XG4gICAgICAgICByZXBvcnRfdHJlZXMgXCJTQ1wiIHdyZWF0aHMpO1xuICAgICAgIGZhbHNlKVxuXG4gICAgbGV0IHYwID0gVmVydGV4LnJvb3RcbiAgICBsZXQgdjEgPSBWZXJ0ZXgubWsgRXhwX3BsdXNcbiAgICBsZXQgdjIgPSBWZXJ0ZXgubWsgRXhwX3RpbWVzXG4gICAgbGV0IGUwMSA9IEVkZ2UubWsgQ3Vyc29yLnsgdmVydGV4ID0gdjA7IHBvc2l0aW9uID0gUm9vdF9yb290X3Jvb3QgfSB2MVxuICAgIGxldCBlMTIgPSBFZGdlLm1rIEN1cnNvci57IHZlcnRleCA9IHYxOyBwb3NpdGlvbiA9IEV4cF9wbHVzX2xlZnQgfSB2MlxuICAgIGxldCBlMTInID0gRWRnZS5tayBDdXJzb3IueyB2ZXJ0ZXggPSB2MTsgcG9zaXRpb24gPSBFeHBfcGx1c19yaWdodCB9IHYyXG4gICAgbGV0IGUyMSA9IEVkZ2UubWsgQ3Vyc29yLnsgdmVydGV4ID0gdjI7IHBvc2l0aW9uID0gRXhwX3RpbWVzX2xlZnQgfSB2MVxuICAgIGxldCV0ZXN0IFwiZW1wdHkgZ3JhcGhcIiA9IGNoZWNrX2RlY29tcG9zZSBHcmFwaC5lbXB0eVxuXG4gICAgbGV0JXRlc3RfbW9kdWxlIFwib25lIHZlcnRleFwiID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgICgqIHdlbGwtc29ydGVkIG11bHRpcGFyZW50ZWQgYW5kIHdyZWF0aHMgYXJlIGltcG9zc2libGUgKilcblxuICAgICAgICBsZXQldGVzdCBcImRlbGV0ZWRcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oZW1wdHkgfD4gYWRkIGUwMSBEZWxldGVkKVxuICAgICAgICAgICAgfmRlbGV0ZWQ6WyBUcmVlLnZlcnRleCB2MSBbXSBdXG5cbiAgICAgICAgbGV0JXRlc3QgXCJyZWFjaGFibGVcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oZW1wdHkgfD4gYWRkIGUwMSBDcmVhdGVkKVxuICAgICAgICAgICAgfnJlYWNoYWJsZTpcbiAgICAgICAgICAgICAgKFRyZWUudmVydGV4IHYwXG4gICAgICAgICAgICAgICAgIFsgKFJvb3Rfcm9vdF9yb290LCBbIChlMDEuaWQsIFRyZWUudmVydGV4IHYxIFtdKSBdKSBdKVxuICAgICAgZW5kKVxuXG4gICAgbGV0JXRlc3RfbW9kdWxlIFwidHdvIHZlcnRleGVzXCIgPVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgbGV0JXRlc3QgXCJtdWx0aXBhcmVudGVkXCIgPVxuICAgICAgICAgIGNoZWNrX2RlY29tcG9zZVxuICAgICAgICAgICAgR3JhcGguKFxuICAgICAgICAgICAgICBlbXB0eSB8PiBhZGQgZTAxIENyZWF0ZWQgfD4gYWRkIGUxMiBDcmVhdGVkIHw+IGFkZCBlMTInIENyZWF0ZWQpXG4gICAgICAgICAgICB+bXVsdGlwYXJlbnRlZDpbIFRyZWUudmVydGV4IHYyIFtdIF1cbiAgICAgICAgICAgIH5yZWFjaGFibGU6XG4gICAgICAgICAgICAgIChUcmVlLnZlcnRleCB2MFxuICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgKCBSb290X3Jvb3Rfcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgKCBlMDEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgVHJlZS52ZXJ0ZXggdjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEV4cF9wbHVzX2xlZnQsIFsgKGUxMi5pZCwgUmVmIHYyKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEV4cF9wbHVzX3JpZ2h0LCBbIChlMTInLmlkLCBSZWYgdjIpIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXSApO1xuICAgICAgICAgICAgICAgICAgICAgXSApO1xuICAgICAgICAgICAgICAgICBdKVxuXG4gICAgICAgIGxldCV0ZXN0IFwiZGVsZXRlZCBlMDFcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oZW1wdHkgfD4gYWRkIGUwMSBEZWxldGVkIHw+IGFkZCBlMTIgQ3JlYXRlZClcbiAgICAgICAgICAgIH5kZWxldGVkOlxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgVHJlZS52ZXJ0ZXggdjFcbiAgICAgICAgICAgICAgICAgIFsgKEV4cF9wbHVzX2xlZnQsIFsgKGUxMi5pZCwgVHJlZS52ZXJ0ZXggdjIgW10pIF0pIF07XG4gICAgICAgICAgICAgIF1cblxuICAgICAgICBsZXQldGVzdCBcInJlYWNoYWJsZSBlMDEgZGVsZXRlZCBlMTJcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oZW1wdHkgfD4gYWRkIGUwMSBDcmVhdGVkIHw+IGFkZCBlMTIgRGVsZXRlZClcbiAgICAgICAgICAgIH5kZWxldGVkOlsgVHJlZS52ZXJ0ZXggdjIgW10gXVxuICAgICAgICAgICAgfnJlYWNoYWJsZTpcbiAgICAgICAgICAgICAgKFRyZWUudmVydGV4IHYwXG4gICAgICAgICAgICAgICAgIFsgKFJvb3Rfcm9vdF9yb290LCBbIChlMDEuaWQsIFRyZWUudmVydGV4IHYxIFtdKSBdKSBdKVxuXG4gICAgICAgIGxldCV0ZXN0IFwicmVhY2hhYmxlIGUwMSBlMTJcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oZW1wdHkgfD4gYWRkIGUwMSBDcmVhdGVkIHw+IGFkZCBlMTIgQ3JlYXRlZClcbiAgICAgICAgICAgIH5yZWFjaGFibGU6XG4gICAgICAgICAgICAgIChUcmVlLnZlcnRleCB2MFxuICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgKCBSb290X3Jvb3Rfcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgKCBlMDEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgVHJlZS52ZXJ0ZXggdjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgKEV4cF9wbHVzX2xlZnQsIFsgKGUxMi5pZCwgVHJlZS52ZXJ0ZXggdjIgW10pIF0pIF1cbiAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgIF0gKTtcbiAgICAgICAgICAgICAgICAgXSlcblxuICAgICAgICBsZXQldGVzdCBcIndyZWF0aHNcIiA9XG4gICAgICAgICAgY2hlY2tfZGVjb21wb3NlXG4gICAgICAgICAgICBHcmFwaC4oXG4gICAgICAgICAgICAgIGVtcHR5IHw+IGFkZCBlMDEgRGVsZXRlZCB8PiBhZGQgZTEyIENyZWF0ZWQgfD4gYWRkIGUyMSBDcmVhdGVkKVxuICAgICAgICAgICAgfndyZWF0aHM6XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBUcmVlLnZlcnRleCB2MVxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAoIEV4cF9wbHVzX2xlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgKCBlMTIuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFRyZWUudmVydGV4IHYyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyAoRXhwX3RpbWVzX2xlZnQsIFsgKGUyMS5pZCwgUmVmIHYxKSBdKSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgXSApO1xuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgXVxuICAgICAgZW5kKVxuICBlbmQpXG4iLCIoKiBMYW5nICopXG5cbm1vZHVsZSBTb3J0ID0gc3RydWN0XG4gIHR5cGUgdCA9IEV4cCB8IFBhdCB8IFR5cFxuZW5kXG5cbm1vZHVsZSBQb3NpdGlvbiA9IHN0cnVjdFxuICB0eXBlIGxhbSA9IFBhcmFtIHwgVHlwZSB8IEJvZHlcbiAgdHlwZSBhcHAgPSBGdW4gfCBBcmdcbiAgdHlwZSBwbHVzID0gTGVmdCB8IFJpZ2h0XG4gIHR5cGUgdGltZXMgPSBMZWZ0IHwgUmlnaHRcbiAgdHlwZSBhcnJvdyA9IEFyZyB8IFJlc3VsdFxuICB0eXBlIGV4cCA9IExhbSBvZiBsYW0gfCBBcHAgb2YgYXBwIHwgUGx1cyBvZiBwbHVzIHwgVGltZXMgb2YgdGltZXNcbiAgdHlwZSB0eXAgPSBBcnJvdyBvZiBhcnJvd1xuICB0eXBlIHQgPSBSb290IHwgRXhwIG9mIGV4cCB8IFR5cCBvZiB0eXBcblxuICBsZXQgc29ydCA6IHQgLT4gU29ydC50ID0gZnVuY3Rpb24gUm9vdCB8IEV4cCBfIC0+IEV4cCB8IFR5cCBfIC0+IFR5cFxuZW5kXG5cbm1vZHVsZSBBcml0eSA9IFNldC5NYWtlIChzdHJ1Y3RcbiAgdHlwZSB0ID0gUG9zaXRpb24udFxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuZW5kKVxuXG5tb2R1bGUgQ29uc3RydWN0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBleHAgPSBWYXIgb2Ygc3RyaW5nIHwgTGFtIHwgQXBwIHwgTnVtIG9mIGludCB8IFBsdXMgfCBUaW1lc1xuICB0eXBlIHBhdCA9IFZhciBvZiBzdHJpbmdcbiAgdHlwZSB0eXAgPSBBcnJvdyB8IE51bVxuICB0eXBlIHQgPSBSb290IHwgRXhwIG9mIGV4cCB8IFBhdCBvZiBwYXQgfCBUeXAgb2YgdHlwXG5cbiAgbGV0IHNvcnQgOiB0IC0+IFNvcnQudCA9IGZ1bmN0aW9uXG4gICAgfCBSb290IHwgRXhwIF8gLT4gRXhwXG4gICAgfCBQYXQgXyAtPiBQYXRcbiAgICB8IFR5cCBfIC0+IFR5cFxuXG4gIGxldCBhcml0eSA6IHQgLT4gQXJpdHkudCA9IGZ1bmN0aW9uXG4gICAgfCBSb290IC0+IEFyaXR5LnNpbmdsZXRvbiBSb290XG4gICAgfCBFeHAgKFZhciBfKSAtPiBBcml0eS5lbXB0eVxuICAgIHwgRXhwIExhbSAtPlxuICAgICAgICBBcml0eS5vZl9saXN0IFsgRXhwIChMYW0gUGFyYW0pOyBFeHAgKExhbSBUeXBlKTsgRXhwIChMYW0gQm9keSkgXVxuICAgIHwgRXhwIEFwcCAtPiBBcml0eS5vZl9saXN0IFsgRXhwIChBcHAgRnVuKTsgRXhwIChBcHAgQXJnKSBdXG4gICAgfCBFeHAgUGx1cyAtPiBBcml0eS5vZl9saXN0IFsgRXhwIChQbHVzIExlZnQpOyBFeHAgKFBsdXMgUmlnaHQpIF1cbiAgICB8IEV4cCBUaW1lcyAtPiBBcml0eS5vZl9saXN0IFsgRXhwIChUaW1lcyBMZWZ0KTsgRXhwIChUaW1lcyBSaWdodCkgXVxuICAgIHwgRXhwIChOdW0gXykgLT4gQXJpdHkuZW1wdHlcbiAgICB8IFBhdCAoVmFyIF8pIC0+IEFyaXR5LmVtcHR5XG4gICAgfCBUeXAgQXJyb3cgLT4gQXJpdHkub2ZfbGlzdCBbIFR5cCAoQXJyb3cgQXJnKTsgVHlwIChBcnJvdyBSZXN1bHQpIF1cbiAgICB8IFR5cCBOdW0gLT4gQXJpdHkuZW1wdHlcblxuICBsZXQgZGVmYXVsdF9wb3NpdGlvbiA6IHQgLT4gUG9zaXRpb24udCBvcHRpb24gPSBmdW5jdGlvblxuICAgIHwgUm9vdCAtPiBTb21lIFJvb3RcbiAgICB8IEV4cCAoVmFyIF8pIC0+IE5vbmVcbiAgICB8IEV4cCBMYW0gLT4gU29tZSAoRXhwIChMYW0gUGFyYW0pKVxuICAgIHwgRXhwIEFwcCAtPiBTb21lIChFeHAgKEFwcCBGdW4pKVxuICAgIHwgRXhwIChOdW0gXykgLT4gTm9uZVxuICAgIHwgRXhwIFBsdXMgLT4gU29tZSAoRXhwIChQbHVzIExlZnQpKVxuICAgIHwgRXhwIFRpbWVzIC0+IFNvbWUgKEV4cCAoVGltZXMgTGVmdCkpXG4gICAgfCBQYXQgKFZhciBfKSAtPiBOb25lXG4gICAgfCBUeXAgQXJyb3cgLT4gU29tZSAoVHlwIChBcnJvdyBBcmcpKVxuICAgIHwgVHlwIE51bSAtPiBOb25lXG5lbmRcblxuKCogR3JhcGggKilcblxubW9kdWxlIElkID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuZW5kXG5cbm1vZHVsZSBWZXJ0ZXggPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBpZCA6IElkLnQ7IGNvbnN0cnVjdG9yIDogQ29uc3RydWN0b3IudCB9XG5lbmRcblxubW9kdWxlIEVkZ2Vfc3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUGx1cyB8IE1pbnVzXG5lbmRcblxubW9kdWxlIEVkZ2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge1xuICAgIGlkIDogSWQudDtcbiAgICBzb3VyY2UgOiBWZXJ0ZXgudDtcbiAgICBwb3NpdGlvbiA6IFBvc2l0aW9uLnQ7XG4gICAgdGFyZ2V0IDogVmVydGV4LnQ7XG4gIH1cblxuICBtb2R1bGUgTWFwID0gTWFwLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IEVkZ2Vfc3RhdGUudFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgR3JhcGggPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gRWRnZV9zdGF0ZS50IEVkZ2UuTWFwLnRcbmVuZFxuXG4oKiBUZXJtICopXG5cbm1vZHVsZSBDb25mbGljdCAoVCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbmVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgU2V0Lk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudFxuXG4gICAgbGV0IGNvbXBhcmUgPSBULmNvbXBhcmVcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBQYXQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBWYXIgb2YgR3JhcGgudCAqIHN0cmluZ1xuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSBDb25mbGljdCA9IENvbmZsaWN0IChUKVxuXG4gIHR5cGUgdCA9IFBhdCBvZiBULnQgfCBQYXRDb25mbGljdCBvZiBDb25mbGljdC50XG5lbmRcblxubW9kdWxlIFR5cCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEFycm93IG9mIEdyYXBoLnQgKiB0ICogdCB8IE51bSBvZiBHcmFwaC50XG5cbiAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIENvbmZsaWN0ID0gQ29uZmxpY3QgKFQpXG5cbiAgdHlwZSB0ID0gVHlwIG9mIFQudCB8IFR5cENvbmZsaWN0IG9mIENvbmZsaWN0LnRcbmVuZFxuXG5tb2R1bGUgRXhwID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgVmFyIG9mIEdyYXBoLnRcbiAgICAgIHwgTGFtIG9mIEdyYXBoLnQgKiBQYXQudCAqIFR5cC50ICogdFxuICAgICAgfCBBcHAgb2YgR3JhcGgudFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSBDb25mbGljdCA9IENvbmZsaWN0IChUKVxuXG4gIHR5cGUgdCA9IEV4cCBvZiBULnQgfCBFeHBDb25mbGljdCBvZiBDb25mbGljdC50XG5lbmRcbiIsInR5cGUgbW92ZSA9IExlZnQgfCBSaWdodCB8IFVwIHwgRG93biB8IFNlbGVjdCBvZiBDdXJzb3IudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG50eXBlIGVkaXQgPVxuICB8IENyZWF0ZSBvZiBMYW5nLkNvbnN0cnVjdG9yLnRcbiAgfCBEZXN0cm95XG4gIHwgUmVzdG9yZSBvZiBWZXJ0ZXgudFxuICB8IERyb3BFZGdlIG9mIFV1aWQuSWQudFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxub3BlbiBTZXhwbGliMC5TZXhwX2NvbnZcblxuKCogVE9ETzogTWFrZSBgU2VuZGAgYmUgdG8gYSBzcGVjaWZpYyBlZGl0b3IgKilcbnR5cGUgY29tbSA9IFNlbmQgb2YgR3JhcGhfYWN0aW9uLnQgbGlzdCAqIFV1aWQuSWQudCBsaXN0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgZW52ID1cbiAgfCBSZWNvcmRcbiAgfCBSZXBvcnRcbiAgfCBTdG9wXG4gIHwgUmVwbGF5IG9mIHN0cmluZ1xuICB8IER1bXBcbiAgfCBMb2FkIG9mIHN0cmluZ1xuICB8IENsb25lIG9mIFV1aWQuSWQudFxuICB8IERyb3Agb2YgVXVpZC5JZC50XG4gIHwgVG9nZ2xlSWRzIG9mIFV1aWQuSWQudFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSB0JyA9IE1vdmUgb2YgbW92ZSB8IEVkaXQgb2YgZWRpdCB8IENvbW0gb2YgY29tbSB8IEVudiBvZiBlbnZcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgdCA9IHsgZWRpdG9yX2lkIDogVXVpZC5JZC50OyBhY3Rpb24gOiB0JyB9IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBhcHBseV9ncmFwaF9hY3Rpb24gKGdyYXBoX2FjdGlvbiA6IEdyYXBoX2FjdGlvbi50KSAoZWRpdG9yIDogRWRpdG9yLnQpIDpcbiAgICBFZGl0b3IudCA9XG4gIGxldCBncmFwaCA9IEdyYXBoLmFwcGx5X2FjdGlvbiBlZGl0b3IuZ3JhcGggZ3JhcGhfYWN0aW9uIGluXG4gIGxldCBrbm93bl9hY3Rpb25zID0gR3JhcGhfYWN0aW9uLlNldC5hZGQgZ3JhcGhfYWN0aW9uIGVkaXRvci5rbm93bl9hY3Rpb25zIGluXG4gIGxldCBhY3Rpb25zID0gR3JhcGhfYWN0aW9uLlNldC5hZGQgZ3JhcGhfYWN0aW9uIGVkaXRvci5hY3Rpb25zIGluXG4gIHsgZWRpdG9yIHdpdGggZ3JhcGg7IGtub3duX2FjdGlvbnM7IGFjdGlvbnMgfVxuXG5sZXQgcmVjb3JkX2FjdGlvbnMgKG1vZGVsIDogTW9kZWwudCkgKGVkaXRvcl9pZCA6IFV1aWQuSWQudClcbiAgICAoZ3JhcGhfYWN0aW9ucyA6IEdyYXBoX2FjdGlvbi50IGxpc3QpIDogTW9kZWwuZ3JhcGhfYWN0aW9uX3NlcXVlbmNlIG9wdGlvbiA9XG4gIGxldCVtYXAuVXRpbC5PcHRpb24gYWN0aW9ucyA9IG1vZGVsLmFjdGlvbnMgaW5cbiAgbGV0IG5ld19hY3Rpb25zID0gTGlzdC5tYXAgKGZ1biB4IC0+IChlZGl0b3JfaWQsIHgpKSBncmFwaF9hY3Rpb25zIGluXG4gIG5ld19hY3Rpb25zIEAgYWN0aW9uc1xuXG5sZXQgcmVwb3J0X2FjdGlvbnMgKGFjdGlvbnMgOiBNb2RlbC5ncmFwaF9hY3Rpb25fc2VxdWVuY2UpIDogdW5pdCA9XG4gIE1vZGVsLnNleHBfb2ZfZ3JhcGhfYWN0aW9uX3NlcXVlbmNlIGFjdGlvbnMgfD4gVXRpbC5TZXhwLnByaW50XG5cbmxldCByZXBsYXlfYWN0aW9ucyAobW9kZWwgOiBNb2RlbC50KSAoYWN0aW9ucyA6IE1vZGVsLmdyYXBoX2FjdGlvbl9zZXF1ZW5jZSkgOlxuICAgIE1vZGVsLnQgb3B0aW9uID1cbiAgTGlzdC5mb2xkX2xlZnRcbiAgICAoZnVuIG1vZGVsIChlZGl0b3JfaWQsIGdyYXBoX2FjdGlvbikgLT5cbiAgICAgIGxldCViaW5kLlV0aWwuT3B0aW9uIG1vZGVsIDogTW9kZWwudCBvcHRpb24gPSBtb2RlbCBpblxuICAgICAgbGV0JWJpbmQuVXRpbC5PcHRpb24gZWRpdG9yID0gVXVpZC5NYXAuZmluZF9vcHQgZWRpdG9yX2lkIG1vZGVsLmVkaXRvcnMgaW5cbiAgICAgIGxldCBlZGl0b3IgPSBhcHBseV9ncmFwaF9hY3Rpb24gZ3JhcGhfYWN0aW9uIGVkaXRvciBpblxuICAgICAgbGV0IGVkaXRvcnMgPSBVdWlkLk1hcC5hZGQgZWRpdG9yX2lkIGVkaXRvciBtb2RlbC5lZGl0b3JzIGluXG4gICAgICBsZXQgYWN0aW9ucyA9IHJlY29yZF9hY3Rpb25zIG1vZGVsIGVkaXRvcl9pZCBbIGdyYXBoX2FjdGlvbiBdIGluXG4gICAgICBTb21lIE1vZGVsLnsgZWRpdG9yczsgYWN0aW9ucyB9KVxuICAgIChTb21lIG1vZGVsKSBhY3Rpb25zXG5cbmxldCBhcHBseV9tb3ZlIChtb2RlbCA6IE1vZGVsLnQpIChlZGl0b3JfaWQgOiBVdWlkLklkLnQpIChtb3ZlX2FjdGlvbiA6IG1vdmUpIDpcbiAgICBNb2RlbC50IE9wdGlvbi50ID1cbiAgbGV0JWJpbmQuVXRpbC5PcHRpb24gZWRpdG9yID0gVXVpZC5NYXAuZmluZF9vcHQgZWRpdG9yX2lkIG1vZGVsLmVkaXRvcnMgaW5cbiAgbGV0IGN1cnNvciA6IEN1cnNvci50ID0gZWRpdG9yLmN1cnNvciBpblxuICBsZXQgY3Vyc29yIDogQ3Vyc29yLnQgT3B0aW9uLnQgPVxuICAgIG1hdGNoIG1vdmVfYWN0aW9uIHdpdGhcbiAgICB8IExlZnQgLT5cbiAgICAgICAgbGV0JW1hcC5VdGlsLk9wdGlvbiBwb3NpdGlvbiA9XG4gICAgICAgICAgTGFuZy5Qb3NpdGlvbi5sZWZ0IGVkaXRvci5jdXJzb3IucG9zaXRpb25cbiAgICAgICAgaW5cbiAgICAgICAgeyBjdXJzb3Igd2l0aCBwb3NpdGlvbiB9XG4gICAgfCBSaWdodCAtPlxuICAgICAgICBsZXQlbWFwLlV0aWwuT3B0aW9uIHBvc2l0aW9uID1cbiAgICAgICAgICBMYW5nLlBvc2l0aW9uLnJpZ2h0IGVkaXRvci5jdXJzb3IucG9zaXRpb25cbiAgICAgICAgaW5cbiAgICAgICAgeyBjdXJzb3Igd2l0aCBwb3NpdGlvbiB9XG4gICAgfCBVcCAtPiAoXG4gICAgICAgIG1hdGNoXG4gICAgICAgICAgR3JhcGgucGFyZW50X2VkZ2VzIGVkaXRvci5ncmFwaCBlZGl0b3IuY3Vyc29yLnZlcnRleFxuICAgICAgICAgIHw+IEVkZ2UuU2V0LmVsZW1lbnRzXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBbIGVkZ2UgXSAtPiBTb21lIGVkZ2UudmFsdWUuc291cmNlXG4gICAgICAgIHwgXyAtPiBOb25lKVxuICAgIHwgRG93biAtPiAoXG4gICAgICAgIG1hdGNoXG4gICAgICAgICAgR3JhcGguY2hpbGRfZWRnZXMgZWRpdG9yLmdyYXBoIGN1cnNvci52ZXJ0ZXggY3Vyc29yLnBvc2l0aW9uXG4gICAgICAgICAgfD4gRWRnZS5TZXQuZWxlbWVudHNcbiAgICAgICAgd2l0aFxuICAgICAgICB8IFsgZWRnZSBdIC0+XG4gICAgICAgICAgICBsZXQgdmVydGV4ID0gZWRnZS52YWx1ZS50YXJnZXQgaW5cbiAgICAgICAgICAgIGxldCVtYXAuVXRpbC5PcHRpb24gcG9zaXRpb24gPSBMYW5nLlBvc2l0aW9uLmRvd24gdmVydGV4LnZhbHVlIGluXG4gICAgICAgICAgICB7IEN1cnNvci52ZXJ0ZXg7IHBvc2l0aW9uIH1cbiAgICAgICAgICAgICgqIFRPRE86IGhvdyB0byBjaG9vc2UgYmV0d2VlbiBhbWJpZ3VvdXMgY2hpbGRyZW4gKilcbiAgICAgICAgfCBfIC0+IE5vbmUpXG4gICAgfCBTZWxlY3QgY3Vyc29yIC0+IFNvbWUgY3Vyc29yXG4gIGluXG4gIGxldCVtYXAuVXRpbC5PcHRpb24gY3Vyc29yID0gY3Vyc29yIGluXG4gIGxldCBlZGl0b3JzID0gVXVpZC5NYXAuYWRkIGVkaXRvcl9pZCB7IGVkaXRvciB3aXRoIGN1cnNvciB9IG1vZGVsLmVkaXRvcnMgaW5cbiAgeyBtb2RlbCB3aXRoIGVkaXRvcnMgfVxuXG5sZXQgYXBwbHlfZWRpdCAobW9kZWwgOiBNb2RlbC50KSAoZWRpdG9yX2lkIDogVXVpZC5JZC50KSAoZWRpdF9hY3Rpb24gOiBlZGl0KSA6XG4gICAgTW9kZWwudCBPcHRpb24udCA9XG4gIGxldCViaW5kLlV0aWwuT3B0aW9uIGVkaXRvciA9IFV1aWQuTWFwLmZpbmRfb3B0IGVkaXRvcl9pZCBtb2RlbC5lZGl0b3JzIGluXG4gIGxldCBjaGlsZHJlbiA9XG4gICAgR3JhcGguY2hpbGRfZWRnZXMgZWRpdG9yLmdyYXBoIGVkaXRvci5jdXJzb3IudmVydGV4IGVkaXRvci5jdXJzb3IucG9zaXRpb25cbiAgaW5cbiAgbGV0IG1vdmVfaW4sIGdyYXBoX2FjdGlvbnMgPVxuICAgIG1hdGNoIGVkaXRfYWN0aW9uIHdpdGhcbiAgICB8IENyZWF0ZSBjb25zdHJ1Y3RvciAtPiAoXG4gICAgICAgIGlmXG4gICAgICAgICAgbm90XG4gICAgICAgICAgICAoTGFuZy5Qb3NpdGlvbi5jaGlsZF9zb3J0IGVkaXRvci5jdXJzb3IucG9zaXRpb25cbiAgICAgICAgICAgID0gTGFuZy5Db25zdHJ1Y3Rvci5zb3J0X29mIGNvbnN0cnVjdG9yKVxuICAgICAgICB0aGVuIChmYWxzZSwgW10pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgdmVydGV4ID0gVmVydGV4Lm1rIGNvbnN0cnVjdG9yIGluXG4gICAgICAgICAgbGV0IGNyZWF0ZV9wYXJlbnRfZWRnZSA9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIEdyYXBoX2FjdGlvbi5cbiAgICAgICAgICAgICAgICB7IHN0YXRlID0gQ3JlYXRlZDsgZWRnZSA9IEVkZ2UubWsgZWRpdG9yLmN1cnNvciB2ZXJ0ZXggfTtcbiAgICAgICAgICAgIF1cbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIExhbmcuUG9zaXRpb24uZGVmYXVsdF9wb3NpdGlvbiBjb25zdHJ1Y3RvciB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IChmYWxzZSwgY3JlYXRlX3BhcmVudF9lZGdlKVxuICAgICAgICAgIHwgU29tZSBwb3NpdGlvbiAtPlxuICAgICAgICAgICAgICBsZXQgY3JlYXRlX25ld19jaGlsZHJlbl9lZGdlcyA9XG4gICAgICAgICAgICAgICAgRWRnZS5TZXQuZWxlbWVudHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB8PiBMaXN0Lm1hcCAoZnVuIChlZGdlIDogRWRnZS50KSAtPlxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgc291cmNlID0gQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiB9IGluXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGdlID0gRWRnZS5tayBzb3VyY2UgZWRnZS52YWx1ZS50YXJnZXQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhfYWN0aW9uLnsgc3RhdGUgPSBDcmVhdGVkOyBlZGdlIH0pXG4gICAgICAgICAgICAgIGluXG5cbiAgICAgICAgICAgICAgbGV0IGRlc3Ryb3lfb2xkX2NoaWxkcmVuX2VkZ2VzID1cbiAgICAgICAgICAgICAgICBFZGdlLlNldC5lbGVtZW50cyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHw+IExpc3QubWFwIChmdW4gZWRnZSAtPiBHcmFwaF9hY3Rpb24ueyBzdGF0ZSA9IERlbGV0ZWQ7IGVkZ2UgfSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCB0cnVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZV9wYXJlbnRfZWRnZSBAIGNyZWF0ZV9uZXdfY2hpbGRyZW5fZWRnZXNcbiAgICAgICAgICAgICAgICBAIGRlc3Ryb3lfb2xkX2NoaWxkcmVuX2VkZ2VzICkpXG4gICAgfCBEZXN0cm95IC0+XG4gICAgICAgICggZmFsc2UsXG4gICAgICAgICAgR3JhcGguY2hpbGRfZWRnZXMgZWRpdG9yLmdyYXBoIGVkaXRvci5jdXJzb3IudmVydGV4XG4gICAgICAgICAgICBlZGl0b3IuY3Vyc29yLnBvc2l0aW9uXG4gICAgICAgICAgfD4gRWRnZS5TZXQuZWxlbWVudHNcbiAgICAgICAgICB8PiBMaXN0Lm1hcCAoZnVuIGVkZ2UgLT4gR3JhcGhfYWN0aW9uLnsgc3RhdGUgPSBEZWxldGVkOyBlZGdlIH0pIClcbiAgICB8IFJlc3RvcmUgdmVydGV4IC0+XG4gICAgICAgIGxldCBlZGdlIDogRWRnZS50ID0gRWRnZS5tayBlZGl0b3IuY3Vyc29yIHZlcnRleCBpblxuICAgICAgICAoZmFsc2UsIFsgR3JhcGhfYWN0aW9uLnsgc3RhdGUgPSBDcmVhdGVkOyBlZGdlIH0gXSlcbiAgICB8IERyb3BFZGdlIGVkZ2VfaWQgLT5cbiAgICAgICAgKCBmYWxzZSxcbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgR3JhcGguZWRnZXMgZWRpdG9yLmdyYXBoXG4gICAgICAgICAgICB8PiBFZGdlLlNldC5maW5kX2ZpcnN0X29wdCAoZnVuIGVkZ2UgLT4gZWRnZS5pZCA9IGVkZ2VfaWQpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgU29tZSBlZGdlIC0+IFsgR3JhcGhfYWN0aW9uLnsgc3RhdGUgPSBEZWxldGVkOyBlZGdlIH0gXVxuICAgICAgICAgIHwgTm9uZSAtPiBbXSApXG4gIGluXG4gIGxldCBlZGl0b3IgPSBMaXN0LmZvbGRfcmlnaHQgYXBwbHlfZ3JhcGhfYWN0aW9uIGdyYXBoX2FjdGlvbnMgZWRpdG9yIGluXG4gIGxldCBlZGl0b3JzID0gVXVpZC5NYXAuYWRkIGVkaXRvcl9pZCBlZGl0b3IgbW9kZWwuZWRpdG9ycyBpblxuICBsZXQgYWN0aW9ucyA9IHJlY29yZF9hY3Rpb25zIG1vZGVsIGVkaXRvci5pZCBncmFwaF9hY3Rpb25zIGluXG4gIGxldCBtb2RlbCA9IE1vZGVsLnsgZWRpdG9yczsgYWN0aW9ucyB9IGluXG4gIGlmIG1vdmVfaW4gdGhlbiBhcHBseV9tb3ZlIG1vZGVsIGVkaXRvcl9pZCBEb3duIGVsc2UgU29tZSBtb2RlbFxuXG5sZXQgYXBwbHlfY29tbSAobW9kZWwgOiBNb2RlbC50KSAoZWRpdG9yX2lkIDogVXVpZC5JZC50KSAoY29tbV9hY3Rpb24gOiBjb21tKSA6XG4gICAgTW9kZWwudCBPcHRpb24udCA9XG4gIG1hdGNoIGNvbW1fYWN0aW9uIHdpdGhcbiAgfCBTZW5kIChlZGl0X2FjdGlvbnMsIGVkaXRvcl9pZHMpIC0+XG4gICAgICBsZXQlbWFwLlV0aWwuT3B0aW9uIGVkaXRvcnMgPVxuICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gZWRpdG9yc19vcHQgZWRpdG9yX2lkIC0+XG4gICAgICAgICAgICBsZXQlYmluZC5VdGlsLk9wdGlvbiBlZGl0b3JzID0gZWRpdG9yc19vcHQgaW5cbiAgICAgICAgICAgIGxldCVtYXAuVXRpbC5PcHRpb24gZWRpdG9yID1cbiAgICAgICAgICAgICAgVXVpZC5NYXAuZmluZF9vcHQgZWRpdG9yX2lkIG1vZGVsLmVkaXRvcnNcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBlZGl0b3IgOjogZWRpdG9ycylcbiAgICAgICAgICAoU29tZSBbXSkgZWRpdG9yX2lkc1xuICAgICAgaW5cbiAgICAgIGxldCBtb2RlbCA9XG4gICAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biAobW9kZWwgOiBNb2RlbC50KSAoZWRpdG9yIDogRWRpdG9yLnQpIC0+XG4gICAgICAgICAgICBsZXQgZWRpdG9yID1cbiAgICAgICAgICAgICAgTGlzdC5mb2xkX3JpZ2h0IGFwcGx5X2dyYXBoX2FjdGlvbiBlZGl0X2FjdGlvbnMgZWRpdG9yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IGVkaXRvcnMgPVxuICAgICAgICAgICAgICBVdWlkLk1hcC5yZW1vdmUgZWRpdG9yLmlkIG1vZGVsLmVkaXRvcnNcbiAgICAgICAgICAgICAgfD4gVXVpZC5NYXAuYWRkIGVkaXRvci5pZCBlZGl0b3JcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgbW9kZWwgPSBNb2RlbC57IG1vZGVsIHdpdGggZWRpdG9ycyB9IGluXG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IHJlY29yZF9hY3Rpb25zIG1vZGVsIGVkaXRvcl9pZCBlZGl0X2FjdGlvbnMgaW5cbiAgICAgICAgICAgIHsgbW9kZWwgd2l0aCBhY3Rpb25zIH0pXG4gICAgICAgICAgbW9kZWwgZWRpdG9yc1xuICAgICAgaW5cbiAgICAgIE1vZGVsLnJlbW92ZV9rbm93bl9hY3Rpb25zIG1vZGVsXG5cbmxldCBhcHBseV9lbnYgKG1vZGVsIDogTW9kZWwudCkgKGVudl9hY3Rpb24gOiBlbnYpIDogTW9kZWwudCBPcHRpb24udCA9XG4gIG1hdGNoIGVudl9hY3Rpb24gd2l0aFxuICB8IFJlY29yZCAtPiAoXG4gICAgICBtYXRjaCBtb2RlbC5hY3Rpb25zIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIFByaW50Zi5wcmludGYgXCJSZWNvcmRpbmcuLi5cXG5cIjtcbiAgICAgICAgICBTb21lIHsgbW9kZWwgd2l0aCBhY3Rpb25zID0gU29tZSBbXSB9XG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICAgIFByaW50Zi5wcmludGYgXCIoYWxyZWFkeSByZWNvcmRpbmcpXFxuXCI7XG4gICAgICAgICAgTm9uZSlcbiAgfCBSZXBvcnQgLT5cbiAgICAgIGxldCViaW5kLlV0aWwuT3B0aW9uIGFjdGlvbnMgPSBtb2RlbC5hY3Rpb25zIGluXG4gICAgICByZXBvcnRfYWN0aW9ucyBhY3Rpb25zO1xuICAgICAgTm9uZVxuICB8IFN0b3AgLT4gKFxuICAgICAgbWF0Y2ggbW9kZWwuYWN0aW9ucyB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBQcmludGYucHJpbnRmIFwiKGFscmVhZHkgc3RvcHBlZClcXG5cIjtcbiAgICAgICAgICBOb25lXG4gICAgICB8IFNvbWUgYWN0aW9ucyAtPlxuICAgICAgICAgIHJlcG9ydF9hY3Rpb25zIGFjdGlvbnM7XG4gICAgICAgICAgUHJpbnRmLnByaW50ZiBcIlN0b3BwZWQhXFxuXCI7XG4gICAgICAgICAgU29tZSB7IG1vZGVsIHdpdGggYWN0aW9ucyA9IE5vbmUgfSlcbiAgfCBSZXBsYXkgc3RyIC0+XG4gICAgICBTZXhwbGliLlNleHAub2Zfc3RyaW5nIHN0ciB8PiBNb2RlbC5ncmFwaF9hY3Rpb25fc2VxdWVuY2Vfb2Zfc2V4cFxuICAgICAgfD4gcmVwbGF5X2FjdGlvbnMgbW9kZWxcbiAgfCBEdW1wIC0+XG4gICAgICBNb2RlbC5zZXhwX29mX3QgbW9kZWwgfD4gVXRpbC5TZXhwLnByaW50O1xuICAgICAgTm9uZVxuICB8IExvYWQgc3RyIC0+IFNvbWUgKE1vZGVsLnRfb2Zfc2V4cCAoU2V4cGxpYi5TZXhwLm9mX3N0cmluZyBzdHIpKVxuICB8IENsb25lIGVkaXRvcl9pZCAtPlxuICAgICAgbGV0JW1hcC5VdGlsLk9wdGlvbiBlZGl0b3IgPSBVdWlkLk1hcC5maW5kX29wdCBlZGl0b3JfaWQgbW9kZWwuZWRpdG9ycyBpblxuICAgICAgbGV0IGlkID0gVXVpZC5JZC5uZXh0ICgpIGluXG4gICAgICBsZXQgZWRpdG9yIDogRWRpdG9yLnQgPSB7IGVkaXRvciB3aXRoIGlkIH0gaW5cbiAgICAgIGxldCBlZGl0b3JzID0gVXVpZC5NYXAuYWRkIGlkIGVkaXRvciBtb2RlbC5lZGl0b3JzIGluXG4gICAgICB7IG1vZGVsIHdpdGggZWRpdG9ycyB9XG4gIHwgRHJvcCBlZGl0b3JfaWQgLT5cbiAgICAgIGxldCBlZGl0b3JzID0gVXVpZC5NYXAucmVtb3ZlIGVkaXRvcl9pZCBtb2RlbC5lZGl0b3JzIGluXG4gICAgICBTb21lIHsgbW9kZWwgd2l0aCBlZGl0b3JzIH1cbiAgfCBUb2dnbGVJZHMgZWRpdG9yX2lkIC0+XG4gICAgICBsZXQgZWRpdG9ycyA9XG4gICAgICAgIG1vZGVsLmVkaXRvcnNcbiAgICAgICAgfD4gVXVpZC5NYXAudXBkYXRlIGVkaXRvcl9pZFxuICAgICAgICAgICAgIChPcHRpb24ubWFwIChmdW4gZWRpdG9yIC0+XG4gICAgICAgICAgICAgICAgICBFZGl0b3IueyBlZGl0b3Igd2l0aCBzaG93X2lkcyA9IG5vdCBlZGl0b3Iuc2hvd19pZHMgfSkpXG4gICAgICBpblxuICAgICAgU29tZSB7IG1vZGVsIHdpdGggZWRpdG9ycyB9XG5cbmxldCBhcHBseSAobW9kZWwgOiBNb2RlbC50KSAoYWN0aW9uIDogdCkgKF9zdGF0ZSA6IFN0YXRlLnQpXG4gICAgfnNjaGVkdWxlX2FjdGlvbjooXyA6IHQgLT4gdW5pdCkgOiBNb2RlbC50ID1cbiAgT3B0aW9uLnZhbHVlXG4gICAgKG1hdGNoIGFjdGlvbi5hY3Rpb24gd2l0aFxuICAgIHwgTW92ZSBtb3ZlX2FjdGlvbiAtPiBhcHBseV9tb3ZlIG1vZGVsIGFjdGlvbi5lZGl0b3JfaWQgbW92ZV9hY3Rpb25cbiAgICB8IEVkaXQgZWRpdF9hY3Rpb24gLT4gYXBwbHlfZWRpdCBtb2RlbCBhY3Rpb24uZWRpdG9yX2lkIGVkaXRfYWN0aW9uXG4gICAgfCBDb21tIGNvbW1fYWN0aW9uIC0+IGFwcGx5X2NvbW0gbW9kZWwgYWN0aW9uLmVkaXRvcl9pZCBjb21tX2FjdGlvblxuICAgIHwgRW52IGVudl9hY3Rpb24gLT4gYXBwbHlfZW52IG1vZGVsIGVudl9hY3Rpb24pXG4gICAgfmRlZmF1bHQ6bW9kZWxcbiJdfQ==
