// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Protocol_version_header__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Protocol_version_header = [0];
   runtime.caml_register_global
    (0, Protocol_version_header, "Protocol_version_header__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__Known_protocol
//# unitInfo: Requires: Assert_failure, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Core, Core__Char, Core__Int, Core__List, Core__String, Expect_test_collector, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Krb = "Krb",
    cst_Krb_test_mode = "Krb_test_mode",
    cst_Protocol_version_header_Kn$0 =
      "Protocol_version_header__Known_protocol",
    cst_Rpc = "Rpc",
    cst_krb = "krb",
    cst_krb_test_mode = "krb_test_mode",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_rpc = "rpc",
    cst_src_known_protocol_ml$2 = "src/known_protocol.ml",
    cst_t$1 = "t",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/known_protocol.ml:50:15",
    cst = "",
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "src/known_protocol.ml.t",
    retired_krb_word = "KRB",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Char = global_data.Core__Char,
    Core_String = global_data.Core__String;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Kn$0);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Expect_test_collector[5][1], cst_src_known_protocol_ml$2);
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header$0, cst);
   var
    compare = runtime.caml_int_compare,
    _r_ = [0, cst_src_known_protocol_ml$2, 40, 2],
    _q_ = [0, cst_src_known_protocol_ml$2, 41, 2],
    _p_ = [0, cst_src_known_protocol_ml$2, 42, 2],
    _o_ = [0, cst_src_known_protocol_ml$2, 43, 2],
    _m_ = [0, cst_src_known_protocol_ml$2, 33, 2],
    _l_ = [0, cst_src_known_protocol_ml$2, 35, 2],
    cst_KRB2 = "KRB2",
    cst_KBT = "KBT",
    cst_RPC = "RPC",
    _a_ = [0, cst_Krb],
    _b_ = [0, cst_Krb_test_mode],
    _c_ = [0, cst_Rpc],
    _d_ =
      [0,
       [0, cst_Krb, 0],
       [0, [0, cst_Krb_test_mode, 0], [0, [0, cst_Rpc, 0], 0]]],
    cst_t = cst_t$1,
    cst_src_known_protocol_ml_3_0 = "src/known_protocol.ml:3:0",
    cst_t$0 = cst_t$1,
    cst_src_known_protocol_ml = cst_src_known_protocol_ml$2,
    cst_validate_magic_words = "validate magic words",
    cst_src_known_protocol_ml$0 = cst_src_known_protocol_ml$2,
    cst_magic_numbers = "magic numbers",
    cst_src_known_protocol_ml$1 = cst_src_known_protocol_ml$2,
    cst_magic_number_bin_size_is_c = "magic_number_bin_size is correct",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header_Kn = cst_Protocol_version_header_Kn$0;
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _C_ = sexp_006[1];
      b:
      if(caml_string_notequal(_C_, cst_Krb)){
       c:
       if(caml_string_notequal(_C_, cst_Krb_test_mode)){
        if(caml_string_notequal(_C_, cst_Rpc)){
         if(! caml_string_notequal(_C_, cst_krb)) break b;
         if(! caml_string_notequal(_C_, cst_krb_test_mode)) break c;
         if(caml_string_notequal(_C_, cst_rpc)) break a;
        }
        return 2;
       }
       return 1;
      }
      return 0;
     }
     var _D_ = sexp_006[1];
     if(! _D_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _E_ = _D_[1];
     if(0 !== _E_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _F_ = _E_[1];
     b:
     if(caml_string_notequal(_F_, cst_Krb)){
      c:
      if(caml_string_notequal(_F_, cst_Krb_test_mode)){
       if(caml_string_notequal(_F_, cst_Rpc)){
        if(! caml_string_notequal(_F_, cst_krb)) break b;
        if(! caml_string_notequal(_F_, cst_krb_test_mode)) break c;
        if(caml_string_notequal(_F_, cst_rpc)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var
    _e_ = caml_call1(Bin_prot_Shape[9], _d_),
    _f_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _e_], 0],
    _g_ = caml_call1(Bin_prot_Shape[4][1], cst_src_known_protocol_ml_3_0),
    group = caml_call2(Bin_prot_Shape[6], _g_, _f_),
    _h_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0);
   caml_call1(caml_call2(Bin_prot_Shape[14], group, _h_), 0);
   function magic_word(param){
    switch(param){
      case 0:
       return cst_KRB2;
      case 1:
       return cst_KBT;
      default: return cst_RPC;
    }
   }
   var magic_number_bin_size = 5;
   function gen_magic_number(word){
    function _A_(acc, c){
     return (acc * 256 | 0) + caml_call1(Core_Char[6], c) | 0;
    }
    var _B_ = caml_call1(Core_String[54], word);
    return caml_call3(Core_List[10], _B_, 0, _A_);
   }
   function magic_number(t){return gen_magic_number(magic_word(t));}
   function _i_(p){return [0, magic_number(p), p];}
   var
    _j_ = caml_call2(Core_List[72], all, _i_),
    by_magic_number = caml_call1(Core_Int[101][9], _j_);
   function _k_(param){
    var
     magic_words =
       [0, retired_krb_word, caml_call2(Core_List[72], all, magic_word)],
     magic_numbers = caml_call2(Core_List[72], magic_words, gen_magic_number);
    function _y_(n){
     var _z_ = caml_call1(Core_Int[2], 1073741823.);
     return caml_call2(Core[89], n, _z_);
    }
    if(! caml_call2(Core_List[14], magic_numbers, _y_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    if(caml_call2(Core_List[112], magic_numbers, Core_Int[91]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_validate_magic_words,
     0,
     cst_src_known_protocol_ml,
     29,
     0,
     449,
     _k_);
   function _n_(param){
    var _u_ = gen_magic_number(retired_krb_word);
    if(! caml_call2(Core[90], _u_, 4346443))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    var _v_ = magic_number(0);
    if(! caml_call2(Core[90], _v_, 843207243))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
    var _w_ = magic_number(1);
    if(! caml_call2(Core[90], _w_, 5521995))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _x_ = magic_number(2);
    if(caml_call2(Core[90], _x_, 4411474)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_magic_numbers,
     0,
     cst_src_known_protocol_ml$0,
     39,
     0,
     223,
     _n_);
   function _s_(param){
    function _t_(t){
     var
      magic_number$0 = magic_number(t),
      size = caml_call1(Core_Int[71], magic_number$0),
      sexpifier = Core[356],
      equal = 0,
      message = 0,
      here = 0;
     function comparator(a_007, b_008){
      return caml_call2(Core[352], a_007, b_008);
     }
     return caml_call8
             (Ppx_assert_lib_Runtime[2],
              pos,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              size,
              magic_number_bin_size);
    }
    caml_call2(Core_List[9], all, _t_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_magic_number_bin_size_is_c,
     0,
     cst_src_known_protocol_ml$1,
     46,
     0,
     214,
     _s_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Kn);
   var
    Protocol_version_header_Known_ =
      [0,
       compare,
       all,
       t_of_sexp,
       sexp_of_t,
       magic_number,
       by_magic_number,
       magic_number_bin_size];
   runtime.caml_register_global
    (67, Protocol_version_header_Known_, cst_Protocol_version_header_Kn$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len_intf",
    cst_protocol_version_header = "protocol_version_header";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], "src/list_with_max_len_intf.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var Protocol_version_header_List_w = [0];
   runtime.caml_register_global
    (11, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len
//# unitInfo: Requires: Base__Exn, Bin_prot__Read, Bin_prot__Shape, Core, Core__Info, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Protocol_version_header__List_with_max_len_intf, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len",
    cst_a$1 = "a",
    cst_protocol_version_header = "protocol_version_header",
    cst_t$1 = "t",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Base_Exn = global_data.Base__Exn,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], "src/list_with_max_len.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var
    _a_ = [0, "max_len"],
    _b_ = [0, "len"],
    _c_ = [0, "context"],
    cst_List_is_too_large = "List is too large",
    cst_t$0 = cst_t$1,
    cst_a = cst_a$1,
    cst_src_list_with_max_len_ml_7 = "src/list_with_max_len.ml:7:14",
    cst_a$0 = cst_a$1,
    cst_t = cst_t$1,
    cst_src_list_with_max_len_ml_7$0 = "src/list_with_max_len.ml:7:2",
    Protocol_version_header_List_w =
      [0,
       function(Config){
        var
         max_len = Config[1],
         context = Config[2],
         _d_ = caml_call1(Bin_prot_Shape[3][1], cst_a),
         _e_ =
           caml_call1(Bin_prot_Shape[4][1], cst_src_list_with_max_len_ml_7),
         _f_ = caml_call2(Bin_prot_Shape[15], _e_, _d_),
         _g_ = caml_call1(Core[410], _f_),
         _h_ = [0, caml_call1(Bin_prot_Shape[3][1], cst_a$0), 0],
         _i_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), _h_, _g_], 0],
         _j_ =
           caml_call1(Bin_prot_Shape[4][1], cst_src_list_with_max_len_ml_7$0),
         group = caml_call2(Bin_prot_Shape[6], _j_, _i_);
        function bin_shape_t(a){
         var _A_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0);
         return caml_call1
                 (caml_call2(Bin_prot_Shape[14], group, _A_), [0, a, 0]);
        }
        function bin_size_t(size_of_a, v){
         return caml_call2(Core[411], size_of_a, v);
        }
        function bin_write_t(write_a, buf, pos, v){
         return caml_call3(caml_call1(Core[412], write_a), buf, pos, v);
        }
        function bin_writer_t(bin_writer_a){
         function _w_(v){
          var _x_ = bin_writer_a[2];
          return function(_y_, _z_){return bin_write_t(_x_, v, _y_, _z_);};
         }
         return [0, function(v){return bin_size_t(bin_writer_a[1], v);}, _w_];
        }
        var bin_read_t = Core_List[150];
        function bin_read_t$0(bin_read_el, buf, pos_ref){
         try{
          var
           _v_ =
             caml_call4(Bin_prot_Read[41], max_len, bin_read_el, buf, pos_ref);
          return _v_;
         }
         catch(exn$0){
          var
           exn = caml_wrap_exception(exn$0),
           _u_ = caml_call1(Core_Info[9], context);
          return caml_call2(Base_Exn[8], exn, _u_);
         }
        }
        function bin_reader_t(bin_reader_a){
         var
          _q_ = caml_call1(bin_read_t, bin_reader_a[1]),
          _r_ = bin_reader_a[1];
         return [0,
                 function(_s_, _t_){return bin_read_t$0(_r_, _s_, _t_);},
                 _q_];
        }
        function bin_t(bin_a){
         var _o_ = bin_reader_t(bin_a[3]), _p_ = bin_writer_t(bin_a[2]);
         return [0, bin_shape_t(bin_a[1]), _p_, _o_];
        }
        function of_list_exn(l){
         var len = caml_call1(Core_List[7], l);
         if(caml_call2(Core[91], len, max_len)){
          var
           _k_ = [0, [1, [0, _a_, [0, caml_call1(Core[356], max_len), 0]]], 0],
           _l_ = [0, [1, [0, _b_, [0, caml_call1(Core[356], len), 0]]], _k_],
           _m_ =
             [0,
              [1, [0, _c_, [0, caml_call1(Core_Info[6], context), 0]]],
              _l_],
           _n_ =
             [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_List_is_too_large),
               _m_]];
          caml_call1(Core[253], _n_);
         }
         return l;
        }
        var sexp_of_t = Core_List[4];
        function t_of_sexp(t_of_a, sexp){
         var t = caml_call2(Core_List[3], t_of_a, sexp);
         return of_list_exn(t);
        }
        return [0,
                bin_shape_t,
                bin_size_t,
                bin_write_t,
                bin_read_t$0,
                bin_read_t,
                bin_writer_t,
                bin_reader_t,
                bin_t,
                t_of_sexp,
                sexp_of_t,
                of_list_exn,
                max_len];
       }];
   runtime.caml_register_global
    (28, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header
//# unitInfo: Requires: Assert_failure, Base__Or_error, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Type_class, Core, Core__Info, Core__Int, Core__List, Core__Map, Core__Or_error, Core__Set, Expect_test_collector, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Protocol_version_header__Known_protocol, Protocol_version_header__List_with_max_len, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header$0 = "Protocol_version_header",
    cst_Protocol_version_header_ne$3 =
      "[Protocol_version_header.negotiate]: conflicting magic protocol numbers",
    cst_peer_protocol = "peer_protocol",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_src_protocol_version_heade$1 = "src/protocol_version_header.ml",
    cst_t$1 = "t",
    cst_us_protocol = "us_protocol",
    cst_us_versions = "us_versions",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Protocol_version_header_Known_ =
      global_data.Protocol_version_header__Known_protocol,
    Core_Map = global_data.Core__Map,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Core_List = global_data.Core__List,
    Bin_prot_Type_class = global_data.Bin_prot__Type_class,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error,
    Core_Set = global_data.Core__Set,
    Base_Or_error = global_data.Base__Or_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Info = global_data.Core__Info,
    Protocol_version_header_List_w =
      global_data.Protocol_version_header__List_with_max_len,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header$0);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Expect_test_collector[5][1], cst_src_protocol_version_heade$1);
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header$0, cst);
   var
    context = caml_call1(Core_Info[12], cst_Protocol_version_header$0),
    Bounded_list_in_case_someone_s =
      caml_call1(Protocol_version_header_List_w[1], [0, 100, context]),
    _a_ = caml_call1(Bounded_list_in_case_someone_s[1], Core[344]),
    _b_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t$1), 0, _a_], 0],
    _c_ =
      caml_call1(Bin_prot_Shape[4][1], "src/protocol_version_header.ml:10:0"),
    group = caml_call2(Bin_prot_Shape[6], _c_, _b_),
    _d_ = caml_call1(Bin_prot_Shape[2][1], cst_t$1),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[14], group, _d_), 0),
    _y_ = [0, cst_src_protocol_version_heade$1, 145, 2],
    _x_ = [0, cst_src_protocol_version_heade$1, 146, 2],
    _w_ = [0, cst_src_protocol_version_heade$1, 147, 2],
    _l_ = [0, "Unknown"],
    _j_ = [0, cst_peer_protocol],
    _k_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$1 = cst_Protocol_version_header_ne$3,
    _g_ = [0, "protocol"],
    _h_ = [0, "peer_versions"],
    _i_ = [0, cst_us_versions],
    cst_Protocol_version_header_ne$0 =
      "[Protocol_version_header.negotiate]: no shared version numbers",
    _m_ = [0, cst_peer_protocol],
    _n_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$2 = cst_Protocol_version_header_ne$3,
    _o_ = [0, cst_us_versions],
    cst_No_magic_numbers_seen = "No magic numbers seen",
    _e_ = [0, "versions"],
    _f_ = [0, "protocols"],
    cst_Protocol_version_header_ne =
      "[Protocol_version_header.negotiate]: multiple magic numbers seen.",
    cst_t = cst_t$1,
    cst_src_protocol_version_heade = "src/protocol_version_header.ml:99:2",
    cst_t$0 = cst_t$1,
    cst_src_protocol_version_heade$0 = cst_src_protocol_version_heade$1,
    cst_bin_sizes_are_not_changed_ = "bin sizes are not changed by accident",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header = cst_Protocol_version_header$0;
   function bin_size_t(v){
    return caml_call2(Bounded_list_in_case_someone_s[2], Core[345], v);
   }
   function bin_write_t(buf, pos, v){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[3], Core[346]),
             buf,
             pos,
             v);
   }
   var bin_writer_t = [0, bin_size_t, bin_write_t];
   function bin_read_t(buf, pos_ref, vint){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[5], Core[348]),
             buf,
             pos_ref,
             vint);
   }
   function bin_read_t$0(buf, pos_ref){
    return caml_call2
            (caml_call1(Bounded_list_in_case_someone_s[4], Core[348]),
             buf,
             pos_ref);
   }
   var
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t];
   function t_of_sexp(x_002){
    return caml_call2(Bounded_list_in_case_someone_s[9], Core[357], x_002);
   }
   function sexp_of_t(x_003){
    return caml_call2(Bounded_list_in_case_someone_s[10], Core[356], x_003);
   }
   function create_exn(protocol, supported_versions){
    var
     _aa_ =
       [0,
        caml_call1(Protocol_version_header_Known_[5], protocol),
        supported_versions];
    return caml_call1(Bounded_list_in_case_someone_s[11], _aa_);
   }
   function get_protocol(t){
    function _Y_(v){
     var
      match = caml_call2(Core_Map[38], Protocol_version_header_Known_[6], v);
     if(! match) return [1, v];
     var p = match[1];
     return [0, p];
    }
    var
     match = caml_call2(Core_List[53], t, _Y_),
     versions = match[2],
     protocols = match[1];
    if(! protocols)
     return [0, [0, 0, caml_call1(Core_Int[102][57], versions)]];
    if(protocols[2]){
     var
      _Z_ =
        [0,
         [1, [0, _e_, [0, caml_call2(Core[421], Core[356], versions), 0]]],
         0],
      ___ =
        [0,
         [1,
          [0,
           _f_,
           [0,
            caml_call2
             (Core[421], Protocol_version_header_Known_[4], protocols),
            0]]],
         _Z_],
      _$_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne),
          ___]];
     return caml_call1(Core_Or_error[40], _$_);
    }
    var p = protocols[1];
    return [0, [0, [0, p], caml_call1(Core_Int[102][57], versions)]];
   }
   function negotiate(allow_legacy_peer, us, peer){
    function _D_(param){
     var us_versions = param[2], us_protocol = param[1];
     function _F_(param){
      var peer_versions = param[2], peer_protocol = param[1];
      function _H_(us_protocol){
       function _L_(peer_protocol){
        var
         _P_ =
           0
            ===
             caml_call2
              (Protocol_version_header_Known_[1], us_protocol, peer_protocol)
            ? 1
            : 0;
        if(! _P_){
         var
          _V_ =
            [0,
             [1,
              [0,
               _j_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], peer_protocol),
                0]]],
             0],
          _W_ =
            [0,
             [1,
              [0,
               _k_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], us_protocol),
                0]]],
             _V_],
          _X_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$1),
              _W_]];
         return caml_call1(Core_Or_error[40], _X_);
        }
        var
         _Q_ = caml_call2(Core_Set[15], us_versions, peer_versions),
         match = caml_call1(Core_Set[59], _Q_);
        if(match){var version = match[1]; return [0, version];}
        var
         _R_ =
           [0,
            [1,
             [0,
              _g_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            0],
         _S_ =
           [0,
            [1,
             [0, _h_, [0, caml_call1(Core_Int[102][75], peer_versions), 0]]],
            _R_],
         _T_ =
           [0,
            [1, [0, _i_, [0, caml_call1(Core_Int[102][75], us_versions), 0]]],
            _S_],
         _U_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$0),
             _T_]];
        return caml_call1(Core_Or_error[40], _U_);
       }
       if(peer_protocol)
        var x = peer_protocol[1], _M_ = caml_call1(Base_Or_error[25][1], x);
       else if(allow_legacy_peer)
        var _M_ = caml_call1(Base_Or_error[25][1], us_protocol);
       else
        var
         _N_ =
           [0,
            [1,
             [0,
              _n_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            [0, [1, [0, _m_, [0, _l_, 0]]], 0]],
         _O_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$2),
             _N_]],
         _M_ = caml_call1(Core_Or_error[40], _O_);
       return caml_call2(Base_Or_error[25][4][2], _M_, _L_);
      }
      if(us_protocol)
       var x = us_protocol[1], _I_ = caml_call1(Base_Or_error[25][1], x);
      else
       var
        _J_ =
          [0,
           [1, [0, _o_, [0, caml_call1(Core_Int[102][75], us_versions), 0]]],
           0],
        _K_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_No_magic_numbers_seen),
            _J_]],
        _I_ = caml_call1(Core[233], _K_);
      return caml_call2(Base_Or_error[25][4][2], _I_, _H_);
     }
     var _G_ = get_protocol(peer);
     return caml_call2(Base_Or_error[25][4][2], _G_, _F_);
    }
    var _E_ = get_protocol(us);
    return caml_call2(Base_Or_error[25][4][2], _E_, _D_);
   }
   function matches_magic_prefix(t, protocol){
    var
     magic_number = caml_call1(Protocol_version_header_Known_[5], protocol);
    return caml_call3(Core_List[6], t, magic_number, Core_Int[90]);
   }
   function contains_magic_prefix(protocol){
    var _A_ = bin_t[3];
    function _B_(_C_){return matches_magic_prefix(_C_, protocol);}
    return caml_call2(Bin_prot_Type_class[159], _B_, _A_);
   }
   function f(t){
    function _z_(protocol){return matches_magic_prefix(t, protocol);}
    return caml_call2(Core_List[16], Protocol_version_header_Known_[2], _z_);
   }
   var
    any_magic_prefix = caml_call2(Bin_prot_Type_class[159], f, bin_t[3]),
    _p_ = Core[344],
    _q_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _p_], 0],
    _r_ = caml_call1(Bin_prot_Shape[4][1], cst_src_protocol_version_heade),
    group$0 = caml_call2(Bin_prot_Shape[6], _r_, _q_),
    _s_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0);
   caml_call1(caml_call2(Bin_prot_Shape[14], group$0, _s_), 0);
   var
    bin_size_t$0 = Core[345],
    _t_ = Protocol_version_header_Known_[7],
    any_magic_prefix_from_six_byte =
      caml_call1(bin_size_t$0, Bounded_list_in_case_someone_s[12]) + _t_ | 0;
   function bin_read_t$1(buf, pos_ref){
    caml_call2(Bin_prot_Read[7], buf, pos_ref);
    return caml_call2(Bin_prot_Read[6], buf, pos_ref);
   }
   var bin_reader_t$0 = [0, bin_read_t$1, Core_Int[74]];
   function _u_(magic_number){
    return caml_call1
            (caml_call1(Core_Map[38], Protocol_version_header_Known_[6]),
             magic_number);
   }
   var
    any_magic_prefix_from_six_byte$0 =
      caml_call2(Bin_prot_Type_class[159], _u_, bin_reader_t$0);
   function _v_(param){
    var
     bounded_list_bin_size =
       caml_call1(Core_Int[71], Bounded_list_in_case_someone_s[12]);
    if(! caml_call2(Core[90], bounded_list_bin_size, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
    if
     (!
      caml_call2
       (Core[90],
        6,
        Protocol_version_header_Known_[7] + bounded_list_bin_size | 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
    if
     (caml_call2
       (Core[90],
        any_magic_prefix_from_six_byte,
        Protocol_version_header_Known_[7] + bounded_list_bin_size | 0))
     return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_bin_sizes_are_not_changed_,
     0,
     cst_src_protocol_version_heade$0,
     137,
     0,
     737,
     _v_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header);
   var
    Protocol_version_header =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t$0,
       bin_read_t,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       create_exn,
       negotiate,
       contains_magic_prefix,
       any_magic_prefix,
       any_magic_prefix_from_six_byte$0,
       any_magic_prefix_from_six_byte,
       [0, Protocol_version_header_List_w[1]]];
   runtime.caml_register_global
    (55, Protocol_version_header, cst_Protocol_version_header$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcm90b2NvbF92ZXJzaW9uX2hlYWRlci5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicG9zIiwiYWxsIiwiZXJyb3Jfc291cmNlXzAwNSIsInJldGlyZWRfa3JiX3dvcmQiLCJjb21wYXJlIiwidF9vZl9zZXhwIiwic2V4cF8wMDYiLCJzZXhwX29mX3QiLCJncm91cCIsIm1hZ2ljX3dvcmQiLCJtYWdpY19udW1iZXJfYmluX3NpemUiLCJnZW5fbWFnaWNfbnVtYmVyIiwid29yZCIsImFjYyIsImMiLCJtYWdpY19udW1iZXIiLCJ0IiwicCIsImJ5X21hZ2ljX251bWJlciIsIm1hZ2ljX3dvcmRzIiwibWFnaWNfbnVtYmVycyIsIm4iLCJtYWdpY19udW1iZXIkMCIsInNpemUiLCJzZXhwaWZpZXIiLCJlcXVhbCIsIm1lc3NhZ2UiLCJoZXJlIiwiY29tcGFyYXRvciIsImFfMDA3IiwiYl8wMDgiLCJiaW5fc2hhcGVfdCIsImEiLCJiaW5fc2l6ZV90Iiwic2l6ZV9vZl9hIiwidiIsImJpbl93cml0ZV90Iiwid3JpdGVfYSIsImJ1ZiIsImJpbl93cml0ZXJfdCIsImJpbl93cml0ZXJfYSIsImJpbl9yZWFkX3QiLCJiaW5fcmVhZF90JDAiLCJiaW5fcmVhZF9lbCIsInBvc19yZWYiLCJleG4kMCIsImV4biIsImJpbl9yZWFkZXJfdCIsImJpbl9yZWFkZXJfYSIsImJpbl90IiwiYmluX2EiLCJvZl9saXN0X2V4biIsImwiLCJsZW4iLCJ0X29mX2EiLCJzZXhwIiwiY29udGV4dCIsInZpbnQiLCJ4XzAwMiIsInhfMDAzIiwiY3JlYXRlX2V4biIsInByb3RvY29sIiwic3VwcG9ydGVkX3ZlcnNpb25zIiwiZ2V0X3Byb3RvY29sIiwidmVyc2lvbnMiLCJwcm90b2NvbHMiLCJuZWdvdGlhdGUiLCJhbGxvd19sZWdhY3lfcGVlciIsInVzIiwicGVlciIsInVzX3ZlcnNpb25zIiwidXNfcHJvdG9jb2wiLCJwZWVyX3ZlcnNpb25zIiwicGVlcl9wcm90b2NvbCIsInZlcnNpb24iLCJ4IiwibWF0Y2hlc19tYWdpY19wcmVmaXgiLCJjb250YWluc19tYWdpY19wcmVmaXgiLCJmIiwiYW55X21hZ2ljX3ByZWZpeCIsImdyb3VwJDAiLCJiaW5fc2l6ZV90JDAiLCJhbnlfbWFnaWNfcHJlZml4X2Zyb21fc2l4X2J5dGUiLCJiaW5fcmVhZF90JDEiLCJiaW5fcmVhZGVyX3QkMCIsImFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZSQwIiwiYm91bmRlZF9saXN0X2Jpbl9zaXplIl0sInNvdXJjZXMiOlsiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9wcm90b2NvbF92ZXJzaW9uX2hlYWRlci9rbm93bl9wcm90b2NvbC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvbGlzdF93aXRoX21heF9sZW4ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lBaURlQTs7SUEvQ2ZDO0lBQUFDO0lBd0JJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F4Qko7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FBQSxTQUFBQyxVQUFBQztJQUFBOztjQUFBQTtnQkFBQUE7Ozs7Ozs7Ozs7UUFBQTs7T0FBQTs7TUFBQTs7ZUFBQUE7O01BQUEsT0FBQTs0Q0FBQUosa0JBQUFJOzs7TUFBQSxPQUFBOzRDQUFBSixrQkFBQUk7Ozs7Ozs7Ozs7O09BQUEsT0FBQTs2Q0FBQUosa0JBQUFJOztNQUFBLE9BQUE7NENBQUFKLGtCQUFBSTs7S0FBQSxPQUFBOzJDQUFBSixrQkFBQUk7O0lBQUEsT0FBQSx3Q0FBQUosa0JBQUFJO0dBSTZDO1lBSjdD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LFdBWkZEO1lBZ0JJRSxhQUFXN0MsS0FBS007SUFDcUIsNkJBRDFCTixLQUFLTTtJQUVsQixPQUFBLDZCQUZhTixLQUFLTTtHQUVxQjtHQUl2QyxJQURFd0MscUJBTEFEO2dCQVlHcEU7SUFBZ0IsT0FBQTthQUFBO2FBQWhCQTtHQUFzRTtHQUQ3RTtJQURFc0U7TUFDRiwwQ0FOSUQ7O0lBdUJGO0tBREVFO09BQ0Y7SUFFSyxLQUFBLHFCQUhIQTtLQUdKLE1BQUE7SUFDTzs7TUFBQTs7OzRDQUpIQTtLQUlKLE1BQUE7SUFDTztNQUFBOztRQWhCTEo7NENBV0VJOztJQUtKLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F6SUZyRDtPQUFBRztPQUFBTTtPQUFBRDtPQUFLVjtPQUFMUTtPQUFBUTtPQUFBRTtPQUFBNUM7T0FBQUU7T0FHSXFEO09BeUJBTTtPQWlEQVc7T0FJQUU7T0FrQ0FNO09BTUFIOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQ29yZVxuXG50eXBlIHQgPVxuICB8IEtyYlxuICB8IEtyYl90ZXN0X21vZGVcbiAgfCBScGNcbltAQGRlcml2aW5nIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgYmluX2lvXVxuXG5sZXQgbWFnaWNfd29yZCA9IGZ1bmN0aW9uXG4gIHwgS3JiIC0+IFwiS1JCMlwiXG4gIHwgS3JiX3Rlc3RfbW9kZSAtPiBcIktCVFwiXG4gIHwgUnBjIC0+IFwiUlBDXCJcbjs7XG5cbmxldCBtYWdpY19udW1iZXJfYmluX3NpemUgPSA1XG5cbmxldCBnZW5fbWFnaWNfbnVtYmVyIHdvcmQgPVxuICBTdHJpbmcudG9fbGlzdF9yZXYgd29yZFxuICB8PiBMaXN0LmZvbGQgfmluaXQ6MCB+ZjooZnVuIGFjYyBjIC0+IChhY2MgKiAyNTYpICsgQ2hhci50b19pbnQgYylcbjs7XG5cbmxldCBtYWdpY19udW1iZXIgdCA9IGdlbl9tYWdpY19udW1iZXIgKG1hZ2ljX3dvcmQgdClcbmxldCBieV9tYWdpY19udW1iZXIgPSBJbnQuTWFwLm9mX2FsaXN0X2V4biAoTGlzdC5tYXAgYWxsIH5mOihmdW4gcCAtPiBtYWdpY19udW1iZXIgcCwgcCkpXG5cbigqIFdlIG9uY2UgbWludGVkIGEgbmV3IG1hZ2ljIG51bWJlciBmb3IgS3JiIGluIG9yZGVyIHRvIGNoYW5nZSB0aGUgcHJvdG9jb2xcbiAgIG5lZ290aWF0aW9uLiAgTGV0J3MgYmUgY2FyZWZ1bCB0aGF0IHdlIGRvbid0IHJldXNlIHRoZSBvbGQgbWFnaWMgbnVtYmVyICopXG5sZXQgcmV0aXJlZF9rcmJfd29yZCA9IFwiS1JCXCJcblxubGV0JXRlc3RfdW5pdCBcInZhbGlkYXRlIG1hZ2ljIHdvcmRzXCIgPVxuICBsZXQgbWFnaWNfd29yZHMgPSByZXRpcmVkX2tyYl93b3JkIDo6IExpc3QubWFwIGFsbCB+ZjptYWdpY193b3JkIGluXG4gIGxldCBtYWdpY19udW1iZXJzID0gTGlzdC5tYXAgbWFnaWNfd29yZHMgfmY6Z2VuX21hZ2ljX251bWJlciBpblxuICAoKiBNYWdpYyBudW1iZXJzIG11c3QgZml0IGludG8gT2NhbWwgaW50ZWdlcnMgKDMxIGJpdHMgb24gMzIgYml0IGJ1aWxkcykuICopXG4gIGFzc2VydCAoTGlzdC5mb3JfYWxsIG1hZ2ljX251bWJlcnMgfmY6KGZ1biBuIC0+IG4gPD0gSW50Lm9mX2Zsb2F0ICgoMi4gKiogMzAuKSAtLiAxLikpKTtcbiAgKCogTm8gZHVwbGljYXRlIG1hZ2ljIG51bWJlcnMgKilcbiAgYXNzZXJ0IChub3QgKExpc3QuY29udGFpbnNfZHVwIG1hZ2ljX251bWJlcnMgfmNvbXBhcmU6SW50LmNvbXBhcmUpKVxuOztcblxuKCogRW5zdXJlIHRlc3RzIGJyZWFrIGlmIHRoZSBtYWdpYyBudW1iZXJzIGFyZSBjaGFuZ2VkICopXG5sZXQldGVzdF91bml0IFwibWFnaWMgbnVtYmVyc1wiID1cbiAgYXNzZXJ0IChnZW5fbWFnaWNfbnVtYmVyIHJldGlyZWRfa3JiX3dvcmQgPSA0XzM0Nl80NDMpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBLcmIgPSA4NDNfMjA3XzI0Myk7XG4gIGFzc2VydCAobWFnaWNfbnVtYmVyIEtyYl90ZXN0X21vZGUgPSA1XzUyMV85OTUpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBScGMgPSA0XzQxMV80NzQpXG47O1xuXG5sZXQldGVzdF91bml0IFwibWFnaWNfbnVtYmVyX2Jpbl9zaXplIGlzIGNvcnJlY3RcIiA9XG4gIExpc3QuaXRlciBhbGwgfmY6KGZ1biB0IC0+XG4gICAgbGV0IG1hZ2ljX251bWJlciA9IG1hZ2ljX251bWJlciB0IGluXG4gICAgbGV0IHNpemUgPSBJbnQuYmluX3NpemVfdCBtYWdpY19udW1iZXIgaW5cbiAgICBbJXRlc3RfZXE6IGludF0gc2l6ZSBtYWdpY19udW1iZXJfYmluX3NpemUpXG47O1xuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBMaXN0X3dpdGhfbWF4X2xlbl9pbnRmXG5cbm1vZHVsZSBNYWtlIChDb25maWcgOiBDb25maWcpID0gc3RydWN0XG4gIGluY2x1ZGUgQ29uZmlnXG5cbiAgdHlwZSAnYSB0ID0gJ2EgbGlzdCBbQEBkZXJpdmluZyBiaW5fc2hhcGUsIGJpbl93cml0ZV1cblxuICBsZXQgX19iaW5fcmVhZF90X18gPSBMaXN0Ll9fYmluX3JlYWRfdF9fXG5cbiAgbGV0IGJpbl9yZWFkX3QgYmluX3JlYWRfZWwgYnVmIH5wb3NfcmVmID1cbiAgICB0cnkgQmluX3Byb3QuUmVhZC5iaW5fcmVhZF9saXN0X3dpdGhfbWF4X2xlbiB+bWF4X2xlbiBiaW5fcmVhZF9lbCBidWYgfnBvc19yZWYgd2l0aFxuICAgIHwgZXhuIC0+IEV4bi5yZXJhaXNlIGV4biAoSW5mby50b19zdHJpbmdfaHVtIGNvbnRleHQpXG4gIDs7XG5cbiAgbGV0IGJpbl9yZWFkZXJfdCAoYmluX3JlYWRlcl9hIDogJ2EgQmluX3Byb3QuVHlwZV9jbGFzcy5yZWFkZXIpID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZCA9IGJpbl9yZWFkX3QgYmluX3JlYWRlcl9hLnJlYWRcbiAgICA7IHZ0YWdfcmVhZCA9IF9fYmluX3JlYWRfdF9fIGJpbl9yZWFkZXJfYS5yZWFkXG4gICAgfVxuICA7O1xuXG4gIGxldCBiaW5fdCAoYmluX2EgOiAnYSBCaW5fcHJvdC5UeXBlX2NsYXNzLnQpID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3Muc2hhcGUgPSBiaW5fc2hhcGVfdCBiaW5fYS5zaGFwZVxuICAgIDsgd3JpdGVyID0gYmluX3dyaXRlcl90IGJpbl9hLndyaXRlclxuICAgIDsgcmVhZGVyID0gYmluX3JlYWRlcl90IGJpbl9hLnJlYWRlclxuICAgIH1cbiAgOztcblxuICBsZXQgb2ZfbGlzdF9leG4gbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBpZiBsZW4gPiBtYXhfbGVuXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJMaXN0IGlzIHRvbyBsYXJnZVwiIChjb250ZXh0IDogSW5mby50KSAobGVuIDogaW50KSAobWF4X2xlbiA6IGludCldO1xuICAgIGxcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID0gTGlzdC5zZXhwX29mX3RcblxuICBsZXQgdF9vZl9zZXhwIHRfb2ZfYSBzZXhwID1cbiAgICBsZXQgdCA9IExpc3QudF9vZl9zZXhwIHRfb2ZfYSBzZXhwIGluXG4gICAgb2ZfbGlzdF9leG4gdFxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5tb2R1bGUgS25vd25fcHJvdG9jb2wgPSBLbm93bl9wcm90b2NvbFxuXG5tb2R1bGUgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlID1cbiAgTGlzdF93aXRoX21heF9sZW4uTWFrZSAoc3RydWN0XG4gICAgbGV0IG1heF9sZW4gPSAxMDBcbiAgICBsZXQgY29udGV4dCA9IEluZm8ub2Zfc3RyaW5nIFwiUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJcIlxuICBlbmQpXG5cbnR5cGUgdCA9IGludCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUudFxuW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG5sZXQgY3JlYXRlX2V4biB+cHJvdG9jb2wgfnN1cHBvcnRlZF92ZXJzaW9ucyA9XG4gIEtub3duX3Byb3RvY29sLm1hZ2ljX251bWJlciBwcm90b2NvbCA6OiBzdXBwb3J0ZWRfdmVyc2lvbnNcbiAgfD4gQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlLm9mX2xpc3RfZXhuXG47O1xuXG5sZXQgZ2V0X3Byb3RvY29sICh0IDogdCkgPVxuICBsZXQgcHJvdG9jb2xzLCB2ZXJzaW9ucyA9XG4gICAgTGlzdC5wYXJ0aXRpb25fbWFwXG4gICAgICAodCA6PiBpbnQgbGlzdClcbiAgICAgIH5mOihmdW4gdiAtPlxuICAgICAgICBtYXRjaCBNYXAuZmluZCBLbm93bl9wcm90b2NvbC5ieV9tYWdpY19udW1iZXIgdiB3aXRoXG4gICAgICAgIHwgU29tZSBwIC0+IEZpcnN0IHBcbiAgICAgICAgfCBOb25lIC0+IFNlY29uZCB2KVxuICBpblxuICBtYXRjaCBwcm90b2NvbHMgd2l0aFxuICB8IFtdIC0+IE9rIChOb25lLCBJbnQuU2V0Lm9mX2xpc3QgdmVyc2lvbnMpXG4gIHwgWyBwIF0gLT4gT2sgKFNvbWUgcCwgSW50LlNldC5vZl9saXN0IHZlcnNpb25zKVxuICB8IF8gLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbXVsdGlwbGUgbWFnaWMgbnVtYmVycyBzZWVuLlwiXG4gICAgICAgICAgKHByb3RvY29scyA6IEtub3duX3Byb3RvY29sLnQgbGlzdClcbiAgICAgICAgICAodmVyc2lvbnMgOiBpbnQgbGlzdCldXG47O1xuXG5sZXQgbmVnb3RpYXRlIH5hbGxvd19sZWdhY3lfcGVlciB+KHVzIDogdCkgfihwZWVyIDogdCkgPVxuICBsZXQgb3BlbiBPcl9lcnJvci5MZXRfc3ludGF4IGluXG4gIGxldCViaW5kIHVzX3Byb3RvY29sLCB1c192ZXJzaW9ucyA9IGdldF9wcm90b2NvbCB1cyBpblxuICBsZXQlYmluZCBwZWVyX3Byb3RvY29sLCBwZWVyX3ZlcnNpb25zID0gZ2V0X3Byb3RvY29sIHBlZXIgaW5cbiAgbGV0JWJpbmQgdXNfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHVzX3Byb3RvY29sIHdpdGhcbiAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuICAgIHwgTm9uZSAtPiBlcnJvcl9zIFslbWVzc2FnZSBcIk5vIG1hZ2ljIG51bWJlcnMgc2VlblwiICh1c192ZXJzaW9ucyA6IEludC5TZXQudCldXG4gIGluXG4gIGxldCViaW5kIHBlZXJfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHBlZXJfcHJvdG9jb2wgd2l0aFxuICAgIHwgU29tZSB4IC0+IHJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICAoKiB3ZSBhc3N1bWUgcGVlciBpcyBzcGVha2luZyBvdXIgcHJvdG9jb2wgaWYgW2FsbG93X2xlZ2FjeV9wZWVyXSAqKVxuICAgICAgaWYgYWxsb3dfbGVnYWN5X3BlZXJcbiAgICAgIHRoZW4gcmV0dXJuIHVzX3Byb3RvY29sXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBlZXJfcHJvdG9jb2wgPSBgVW5rbm93biBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBjb25mbGljdGluZyBtYWdpYyBwcm90b2NvbCBudW1iZXJzXCJcbiAgICAgICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAgICAgKHBlZXJfcHJvdG9jb2wgOiBbIGBVbmtub3duIF0pXSlcbiAgaW5cbiAgaWYgbm90IChbJWNvbXBhcmUuZXF1YWw6IEtub3duX3Byb3RvY29sLnRdIHVzX3Byb3RvY29sIHBlZXJfcHJvdG9jb2wpXG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogY29uZmxpY3RpbmcgbWFnaWMgcHJvdG9jb2wgbnVtYmVyc1wiXG4gICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAocGVlcl9wcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXVxuICBlbHNlIChcbiAgICBsZXQgcHJvdG9jb2wgPSB1c19wcm90b2NvbCBpblxuICAgIG1hdGNoIFNldC5tYXhfZWx0IChTZXQuaW50ZXIgdXNfdmVyc2lvbnMgcGVlcl92ZXJzaW9ucykgd2l0aFxuICAgIHwgU29tZSB2ZXJzaW9uIC0+IE9rIHZlcnNpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbm8gc2hhcmVkIHZlcnNpb24gbnVtYmVyc1wiXG4gICAgICAgICAgICAodXNfdmVyc2lvbnMgOiBJbnQuU2V0LnQpXG4gICAgICAgICAgICAocGVlcl92ZXJzaW9ucyA6IEludC5TZXQudClcbiAgICAgICAgICAgIChwcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXSlcbjs7XG5cbmxldCBtYXRjaGVzX21hZ2ljX3ByZWZpeCAodCA6IHQpIH5wcm90b2NvbCA9XG4gIGxldCBtYWdpY19udW1iZXIgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXIgcHJvdG9jb2wgaW5cbiAgTGlzdC5tZW0gfmVxdWFsOkludC5lcXVhbCAodCA6PiBpbnQgbGlzdCkgbWFnaWNfbnVtYmVyXG47O1xuXG5sZXQgY29udGFpbnNfbWFnaWNfcHJlZml4IH5wcm90b2NvbCA9XG4gIEJpbl9wcm90LlR5cGVfY2xhc3MuY252X3JlYWRlciAobWF0Y2hlc19tYWdpY19wcmVmaXggfnByb3RvY29sKSBiaW5fdC5yZWFkZXJcbjs7XG5cbmxldCBhbnlfbWFnaWNfcHJlZml4ID1cbiAgbGV0IGYgdCA9XG4gICAgTGlzdC5maW5kIEtub3duX3Byb3RvY29sLmFsbCB+ZjooZnVuIHByb3RvY29sIC0+IG1hdGNoZXNfbWFnaWNfcHJlZml4IH5wcm90b2NvbCB0KVxuICBpblxuICBCaW5fcHJvdC5UeXBlX2NsYXNzLmNudl9yZWFkZXIgZiBiaW5fdC5yZWFkZXJcbjs7XG5cbm1vZHVsZSBNYWdpY19wcmVmaXhfYmluX3JlcHIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGJpbl9zaGFwZSwgYmluX3dyaXRlXVxuXG4gICgqIFRoZSBiaW4gcHJvdCByZXByZXNlbnRhdGlvbiBvZiBhIHByb3RvY29sIHZlcnNpb24gaGVhZGVyIGlzIHRoZSBzdGFuZGFyZFxuICAgICByZXByZXNlbnRhdGlvbiBmb3IgYW4gaW50IGxpc3Q6XG5cbiAgICAgfCBuYXQwIGluZGljYXRpbmcgc2l6ZSB8IGVsZW1lbnQgMCB8IGVsZW1lbnQgMSB8IC4uLlxuXG4gICAgIFtjcmVhdGVfZXhuXSB3aWxsIGFsd2F5cyBwdXQgdGhlIGtub3duIHByb3RvY29sIG1hZ2ljIG51bWJlciBhcyBcImVsZW1lbnQgMFwiLlxuXG4gICAgIFRoZSBiaW4gc2l6ZSBvZiBcIm5hdDAgaW5kaWNhdGluZyBzaXplXCIgYW5kIFwiZWxlbWVudCAwXCIgaXMgZml4ZWQgKHRoZXJlIGFyZSBleHBlY3RcbiAgICAgdGVzdHMgdG8gbWFrZSBzdXJlIHdlIG5ldmVyIGNoYW5nZSB0aGVtKS4gKilcbiAgbGV0IGJpbl9zaXplID1cbiAgICBiaW5fc2l6ZV90IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gICAgKyBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXJfYmluX3NpemVcbiAgOztcblxuICBsZXQgYmluX3JlYWRfdCBidWYgfnBvc19yZWYgPVxuICAgIGxldCAoX2xpc3RfbGVuZ3RoIDogQmluX3Byb3QuTmF0MC50KSA9IEJpbl9wcm90LlJlYWQuYmluX3JlYWRfbmF0MCBidWYgfnBvc19yZWYgaW5cbiAgICBCaW5fcHJvdC5SZWFkLmJpbl9yZWFkX2ludCBidWYgfnBvc19yZWZcbiAgOztcblxuICBsZXQgYmluX3JlYWRlcl90ID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZCA9IGJpbl9yZWFkX3Q7IHZ0YWdfcmVhZCA9IEludC5fX2Jpbl9yZWFkX3RfXyB9XG4gIDs7XG5lbmRcblxubGV0IGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXMgPVxuICBCaW5fcHJvdC5UeXBlX2NsYXNzLmNudl9yZWFkZXJcbiAgICAoZnVuIG1hZ2ljX251bWJlciAtPiAoTWFwLmZpbmQgS25vd25fcHJvdG9jb2wuYnlfbWFnaWNfbnVtYmVyKSBtYWdpY19udW1iZXIpXG4gICAgTWFnaWNfcHJlZml4X2Jpbl9yZXByLmJpbl9yZWFkZXJfdFxuOztcblxubGV0IGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXNfYmluX3NpemUgPSBNYWdpY19wcmVmaXhfYmluX3JlcHIuYmluX3NpemVcblxubW9kdWxlIEZvcl90ZXN0ID0gc3RydWN0XG4gIG1vZHVsZSBNYWtlX2xpc3Rfd2l0aF9tYXhfbGVuID0gTGlzdF93aXRoX21heF9sZW4uTWFrZVxuZW5kXG5cbmxldCV0ZXN0X3VuaXQgXCJiaW4gc2l6ZXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IGFjY2lkZW50XCIgPVxuICAoKiBFbnN1cmUgdGhlIGJpbl9zaXplIG9mIEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gICAgIGlzIGFsd2F5cyAxLiBUaGlzIG1lYW5zIHRoYXQgcmVnYXJkbGVzcyBvZiBob3cgbG9uZyB0aGUgbGlzdCBvZiB2ZXJzaW9ucyBpbiB0aGVcbiAgICAgcHJvdG9jb2wgaGVhZGVyIGlzLCB0aGUgcmVwcmVzZW50YXRpb24gd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMuIFRoZVxuICAgICByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnQganVtcHMgdG8gMyBieXRlcyBhdCB0aGUgdmFsdWUgMTI4LiAqKVxuICBsZXQgYm91bmRlZF9saXN0X2Jpbl9zaXplID1cbiAgICBJbnQuYmluX3NpemVfdCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUubWF4X2xlblxuICBpblxuICBhc3NlcnQgKGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSA9IDEpO1xuICBhc3NlcnQgKDYgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXJfYmluX3NpemUgKyBib3VuZGVkX2xpc3RfYmluX3NpemUpO1xuICBhc3NlcnQgKFxuICAgIGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXNfYmluX3NpemVcbiAgICA9IEtub3duX3Byb3RvY29sLm1hZ2ljX251bWJlcl9iaW5fc2l6ZSArIGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSlcbjs7XG4iXX0=
