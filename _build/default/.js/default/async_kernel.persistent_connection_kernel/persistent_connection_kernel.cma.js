// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Persistent_connection_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Persistent_connection_kernel = [0];
   runtime.caml_register_global
    (0, Persistent_connection_kernel, "Persistent_connection_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel__Persistent_connection_kernel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern =
      "Persistent_connection_kernel__Persistent_connection_kernel_intf",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var Persistent_connection_kernel_P = [0];
   runtime.caml_register_global
    (11, Persistent_connection_kernel_P, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel
//# unitInfo: Requires: Async_kernel, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Time_source, Base__Exn, Base__Field, Base__Random, Core, Core__Error, Core__Fn, Core__Option, Core__Or_error, Core__Sexp, Core__Time_ns, Expect_test_collector, Persistent_connection_kernel__Persistent_connection_kernel_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern = "Persistent_connection_kernel",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel = global_data.Async_kernel,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Random = global_data.Base__Random,
    Core = global_data.Core,
    Core_Fn = global_data.Core__Fn,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var
    _x_ = [0, -289386606, 0],
    _y_ = [0, -289386606, 0],
    _z_ = [0, 990972795, 0],
    _v_ = [0, -289386606, 0],
    _w_ = [0, -289386606, 0],
    _p_ = [0, "Close_started"],
    _q_ = [0, "Ok"],
    _i_ = [0, "sexp_of_address"],
    _j_ = [0, "address_equal"],
    _k_ = [0, "don't_reconnect"],
    _l_ = [0, "close_finished"],
    _m_ = [0, "close_started"],
    _n_ = [0, "event_handler"],
    _o_ = [0, "next_connect_result"],
    _r_ = [0, "conn"],
    _s_ = [0, "retry_delay"],
    _t_ = [0, "connect"],
    _u_ = [0, "get_address"],
    _g_ = [0, "on_event"],
    _h_ = [0, "server_name"],
    _b_ = [0, "Attempting_to_connect"],
    _c_ = [0, "Disconnected"],
    _d_ = [0, "Obtained_address"],
    _e_ = [0, "Failed_to_connect"],
    _f_ = [0, "Connected"],
    _a_ = [0, "<Conn.t>"],
    cst_Persistent_connection_clos = "Persistent connection closed",
    Persistent_connection_kernel =
      [0,
       function(Conn){
        var close = Conn[1], is_closed = Conn[2], close_finished = Conn[3];
        function sexp_of_t(param){return _a_;}
        function sexp_of_t$0(of_address_001, param){
         if(typeof param === "number") return 0 === param ? _b_ : _c_;
         switch(param[0]){
           case 0:
            var
             arg0_002 = param[1],
             res0_003 = caml_call1(of_address_001, arg0_002);
            return [1, [0, _d_, [0, res0_003, 0]]];
           case 1:
            var
             arg0_004 = param[1],
             res0_005 = caml_call1(Core_Error[6], arg0_004);
            return [1, [0, _e_, [0, res0_005, 0]]];
           default:
            var
             arg0_006 = param[1],
             res0_007 = caml_call1(Sexplib0_Sexp_conv[23], arg0_006);
            return [1, [0, _f_, [0, res0_007, 0]]];
         }
        }
        function log_level(param){
         if(typeof param !== "number" && 1 === param[0]) return 106380200;
         return 815031438;
        }
        function handle_event(t, event){
         var on_event = t[6][2];
         return caml_call1(on_event, event);
        }
        function abort_reconnecting_with_no_act(t){
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         caml_call2(Async_kernel_Ivar[14], t[8], 0);
         return caml_call2(Async_kernel_Ivar[14], t[4], -400989606);
        }
        function current_connection(t){
         var
          _aQ_ = caml_call1(Async_kernel_Ivar[18], t[4]),
          match = caml_call1(Async_kernel_Deferred[5], _aQ_);
         if(match){
          var match$0 = match[1];
          if(typeof match$0 !== "number"){
           var conn = match$0[2];
           return [0, conn];
          }
         }
         return 0;
        }
        function close_finished$0(t){
         return caml_call1(Async_kernel_Ivar[18], t[8]);
        }
        function is_closed$0(t){
         return caml_call1(Async_kernel_Ivar[17], t[7]);
        }
        var
         _A_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_Persistent_connection_clos),
         connected_or_failed_to_connect = caml_call1(Core_Or_error[40], _A_);
        function sexp_of_t$1(param){
         var
          conn_023 = param[4],
          next_connect_result_026 = param[5],
          don_t_reconnect_034 = param[9],
          close_finished_032 = param[8],
          close_started_030 = param[7],
          event_handler_028 = param[6],
          bnds_016 = 0;
         function _aD_(_aP_){return 0;}
         var
          arg_039 = caml_call1(Sexplib0_Sexp_conv[24], _aD_),
          bnds_016$0 = [0, [1, [0, _i_, [0, arg_039, 0]]], bnds_016];
         function _aE_(_aO_){return 0;}
         var
          arg_037 = caml_call1(Sexplib0_Sexp_conv[24], _aE_),
          bnds_016$1 = [0, [1, [0, _j_, [0, arg_037, 0]]], bnds_016$0],
          arg_035 =
            caml_call2(Async_kernel_Ivar[9], Core[518], don_t_reconnect_034),
          bnds_016$2 = [0, [1, [0, _k_, [0, arg_035, 0]]], bnds_016$1],
          arg_033 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_finished_032),
          bnds_016$3 = [0, [1, [0, _l_, [0, arg_033, 0]]], bnds_016$2],
          arg_031 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_started_030),
          bnds_016$4 = [0, [1, [0, _m_, [0, arg_031, 0]]], bnds_016$3],
          server_name_011 = event_handler_028[1],
          bnds_010 = 0;
         function _aC_(_aN_){return 0;}
         var
          arg_014 = caml_call1(Sexplib0_Sexp_conv[24], _aC_),
          bnds_010$0 = [0, [1, [0, _g_, [0, arg_014, 0]]], bnds_010],
          arg_012 = caml_call1(Core[471], server_name_011),
          bnds_010$1 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_010$0],
          arg_029 = [1, bnds_010$1],
          bnds_016$5 = [0, [1, [0, _n_, [0, arg_029, 0]]], bnds_016$4],
          _aF_ = caml_call1(Core_Or_error[13], sexp_of_t),
          arg_027 =
            caml_call2(Async_kernel_Ivar[9], _aF_, next_connect_result_026),
          bnds_016$6 = [0, [1, [0, _o_, [0, arg_027, 0]]], bnds_016$5];
         function _aG_(param){
          if(typeof param === "number") return _p_;
          var v_025 = param[2];
          return [1, [0, _q_, [0, sexp_of_t(v_025), 0]]];
         }
         var
          arg_024 = caml_call2(Async_kernel_Ivar[9], _aG_, conn_023),
          bnds_016$7 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_016$6];
         function _aH_(_aM_){return 0;}
         var
          arg_022 = caml_call1(Sexplib0_Sexp_conv[24], _aH_),
          bnds_016$8 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_016$7];
         function _aI_(_aL_){return 0;}
         var
          arg_020 = caml_call1(Sexplib0_Sexp_conv[24], _aI_),
          bnds_016$9 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_016$8];
         function _aJ_(_aK_){return 0;}
         var
          arg_018 = caml_call1(Sexplib0_Sexp_conv[24], _aJ_),
          bnds_016$10 = [0, [1, [0, _u_, [0, arg_018, 0]]], bnds_016$9];
         return [1, bnds_016$10];
        }
        function close_when_current_connection_(t){
         return caml_call2(Async_kernel_Ivar[15], t[9], 0);
        }
        function close_finished$1(param){return close_finished$0(param);}
        function is_closed$1(param){return is_closed$0(param);}
        function close$0(t){
         if(caml_call1(Async_kernel_Ivar[17], t[7]))
          return close_finished$0(t);
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         function _ay_(conn_opt){
          function _aA_(param){
           return caml_call2(Async_kernel_Ivar[14], t[8], 0);
          }
          if(typeof conn_opt === "number")
           var _aB_ = Async_kernel_Deferred[18];
          else
           var conn = conn_opt[2], _aB_ = caml_call1(close, conn);
          return caml_call2(Async_kernel[21], _aB_, _aA_);
         }
         var _az_ = caml_call1(Async_kernel_Ivar[18], t[4]);
         return caml_call2(Async_kernel[20], _az_, _ay_);
        }
        function server_name(t){return t[6][1];}
        function current_connection$0(param){return current_connection(param);
        }
        function connected_or_failed_to_connect$0(t){
         if(is_closed$0(t))
          return caml_call1(Async_kernel[19], connected_or_failed_to_connect);
         var match = current_connection(t);
         if(match){
          var x = match[1];
          if(! caml_call1(is_closed, x))
           return caml_call1(Async_kernel[19], [0, x]);
         }
         var _aq_ = 0;
         function _ar_(_ax_){return _ax_;}
         var
          _as_ = caml_call1(Async_kernel_Ivar[18], t[5]),
          _at_ = [0, caml_call2(Async_kernel[4], _as_, _ar_), _aq_];
         function _au_(param){return connected_or_failed_to_connect;}
         var
          _av_ = caml_call1(Async_kernel_Ivar[18], t[7]),
          _aw_ = [0, caml_call2(Async_kernel[4], _av_, _au_), _at_];
         return caml_call1(Async_kernel_Deferred[29], _aw_);
        }
        function connected(t){
         function loop(param){
          var
           d = caml_call1(Async_kernel_Ivar[18], t[4]),
           match = caml_call1(Async_kernel_Deferred[5], d);
          if(! match){
           var
            _ap_ =
              function(param){
               if(typeof param === "number")
                return caml_call1(Async_kernel_Deferred[19], 0);
               var conn = param[2];
               return caml_call1(Async_kernel[19], conn);
              };
           return caml_call2(Async_kernel[20], d, _ap_);
          }
          var match$0 = match[1];
          if(typeof match$0 === "number")
           return caml_call1(Async_kernel_Deferred[19], 0);
          var conn = match$0[2];
          if(! caml_call1(is_closed, conn))
           return caml_call1(Async_kernel[19], conn);
          var _ao_ = caml_call1(close_finished, conn);
          return caml_call2(Async_kernel[20], _ao_, loop);
         }
         return loop(0);
        }
        function create
        (server_name,
         on_event$0,
         retry_delay$0,
         random_state$1,
         time_source$0,
         connect,
         address,
         get_address){
         if(on_event$0)
          var sth = on_event$0[1], on_event = sth;
         else
          var on_event = function(param){return Async_kernel_Deferred[18];};
         if(random_state$1)
          var sth$0 = random_state$1[1], random_state = sth$0;
         else
          var random_state = [0, 389604849, Base_Random[18][1]];
         if(time_source$0)
          var sth$1 = time_source$0[1], time_source = sth$1;
         else
          var time_source = caml_call1(Async_kernel_Time_source[10], 0);
         var
          event_handler = [0, server_name, on_event],
          _B_ = Core[541] ? 0.1 : 10.,
          _C_ = caml_call1(Core_Time_ns[1][81], _B_),
          default_retry_delay = caml_call1(Core_Fn[1], _C_),
          non_randomized_delay =
            caml_call2(Core_Option[34], retry_delay$0, default_retry_delay);
         if(typeof random_state === "number")
          var retry_delay_span = non_randomized_delay;
         else
          var
           random_state$0 = random_state[2],
           retry_delay_span =
             function(param){
              var
               span = caml_call1(non_randomized_delay, 0),
               span$0 = caml_call1(Core_Time_ns[1][91], span),
               distance =
                 caml_call2(Base_Random[18][10], random_state$0, span$0 * 0.3),
               wait =
                 caml_call1(Base_Random[18][16], random_state$0)
                  ? span$0 + distance
                  : span$0 - distance;
              return caml_call1(Core_Time_ns[1][81], wait);
             };
         function retry_delay(param){
          var _an_ = caml_call1(retry_delay_span, 0);
          return caml_call2(Async_kernel_Time_source[29], time_source, _an_);
         }
         var
          _D_ = address[2],
          _E_ = address[1],
          _F_ = caml_call1(Async_kernel_Ivar[12], 0),
          _G_ = caml_call1(Async_kernel_Ivar[12], 0),
          _H_ = caml_call1(Async_kernel_Ivar[12], 0),
          _I_ = caml_call1(Async_kernel_Ivar[12], 0),
          t =
            [0,
             get_address,
             connect,
             retry_delay,
             caml_call1(Async_kernel_Ivar[12], 0),
             _I_,
             event_handler,
             _H_,
             _G_,
             _F_,
             _E_,
             _D_];
         function _J_(param){
          function _L_(param){
           var previous_address = [0, 0], previous_error = [0, 0];
           function _O_(param){
            if(typeof param === "number")
             return -400989606 <= param
                     ? (caml_call2
                        (Async_kernel_Ivar[14], t[4], -400989606),
                       caml_call1(Async_kernel[19], _v_))
                     : (abort_reconnecting_with_no_act
                        (t),
                       caml_call1(Async_kernel[19], _w_));
            var
             match = param[2],
             ready_to_retry_connecting = match[2],
             conn = match[1];
            caml_call2(Async_kernel_Ivar[14], t[4], [0, 17724, conn]);
            function _ad_(param){
             function _af_(param){
              t[4] = caml_call1(Async_kernel_Ivar[12], 0);
              function _ah_(param){
               function _aj_(param){
                return caml_call1(Async_kernel_Ivar[17], t[7])
                        ? (caml_call2(Async_kernel_Ivar[14], t[4], -400989606), _x_)
                        : caml_call1
                           (Async_kernel_Ivar[17], t[9])
                          ? (abort_reconnecting_with_no_act(t), _y_)
                          : _z_;
               }
               var
                _ak_ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
                _al_ =
                  [0,
                   ready_to_retry_connecting,
                   [0, caml_call1(Async_kernel_Ivar[18], t[7]), _ak_]],
                _am_ = caml_call1(Async_kernel_Deferred[23], _al_);
               return caml_call2(Async_kernel[22][3], _am_, _aj_);
              }
              var _ai_ = handle_event(t, 1);
              return caml_call2(Async_kernel[20], _ai_, _ah_);
             }
             var _ag_ = caml_call1(close_finished, conn);
             return caml_call2(Async_kernel[20], _ag_, _af_);
            }
            var _ae_ = handle_event(t, [2, conn]);
            return caml_call2(Async_kernel[20], _ae_, _ad_);
           }
           function loop(param){
            if(caml_call1(Async_kernel_Ivar[17], t[7]))
             return caml_call1(Async_kernel[19], -400989606);
            if(caml_call1(Async_kernel_Ivar[17], t[9]))
             return caml_call1(Async_kernel[19], -818917400);
            var ready_to_retry_connecting = caml_call1(t[3], 0);
            function _S_(connect_result){
             caml_call2(Async_kernel_Ivar[14], t[5], connect_result);
             t[5] = caml_call1(Async_kernel_Ivar[12], 0);
             if(0 === connect_result[0]){
              var conn = connect_result[1];
              return caml_call1
                      (Async_kernel[19],
                       [0, 17724, [0, conn, ready_to_retry_connecting]]);
             }
             var err = connect_result[1], match = previous_error[1];
             if(match)
              var
               previous_err = match[1],
               to_sexp =
                 function(e){
                  var
                   _ab_ = caml_call1(Core_Error[26], e),
                   _ac_ = caml_call1(Async_kernel_Monitor[13], _ab_);
                  return caml_call1(Base_Exn[1], _ac_);
                 },
               _V_ = to_sexp(previous_err),
               _W_ = to_sexp(err),
               same_as_previous_error = caml_call2(Core_Sexp[36], _W_, _V_);
             else
              var same_as_previous_error = 0;
             previous_error[1] = [0, err];
             function _X_(param){
              function _Z_(param){return loop(0);}
              var
               ___ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
               _$_ =
                 [0,
                  ready_to_retry_connecting,
                  [0, caml_call1(Async_kernel_Ivar[18], t[7]), ___]],
               _aa_ = caml_call1(Async_kernel_Deferred[23], _$_);
              return caml_call2(Async_kernel[20], _aa_, _Z_);
             }
             var
              _Y_ =
                same_as_previous_error
                 ? Async_kernel_Deferred[18]
                 : handle_event(t, [1, err]);
             return caml_call2(Async_kernel[20], _Y_, _X_);
            }
            function _P_(param){
             if(0 !== param[0]){
              var e = param[1];
              return caml_call1(Async_kernel[19], [1, e]);
             }
             var addr = param[1], match = previous_address[1];
             if(match)
              var
               previous_address$0 = match[1],
               same_as_previous_address =
                 caml_call2(t[10], addr, previous_address$0);
             else
              var same_as_previous_address = 0;
             previous_address[1] = [0, addr];
             function _T_(param){return caml_call1(t[2], addr);}
             var
              _U_ =
                same_as_previous_address
                 ? Async_kernel_Deferred[18]
                 : handle_event(t, [0, addr]);
             return caml_call2(Async_kernel[20], _U_, _T_);
            }
            var
             _Q_ = caml_call1(t[1], 0),
             _R_ = caml_call2(Async_kernel[20], _Q_, _P_);
            return caml_call2(Async_kernel[22][2], _R_, _S_);
           }
           var _N_ = loop(0);
           return caml_call2(Async_kernel[20], _N_, _O_);
          }
          var _M_ = handle_event(t, 0);
          return caml_call2(Async_kernel[20], _M_, _L_);
         }
         var _K_ = caml_call2(Async_kernel_Deferred[31], 0, _J_);
         caml_call1(Async_kernel[6], _K_);
         return t;
        }
        return [0,
                sexp_of_t$1,
                [0, sexp_of_t$0, log_level],
                create,
                connected,
                connected_or_failed_to_connect$0,
                current_connection$0,
                server_name,
                close$0,
                is_closed$1,
                close_finished$1,
                close_when_current_connection_];
       }];
   runtime.caml_register_global
    (69, Persistent_connection_kernel, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJzZXhwX29mX3QiLCJzZXhwX29mX3QkMCIsIm9mX2FkZHJlc3NfMDAxIiwiYXJnMF8wMDIiLCJyZXMwXzAwMyIsImFyZzBfMDA0IiwicmVzMF8wMDUiLCJhcmcwXzAwNiIsInJlczBfMDA3IiwibG9nX2xldmVsIiwiaGFuZGxlX2V2ZW50IiwidCIsImV2ZW50Iiwib25fZXZlbnQiLCJhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3QiLCJjdXJyZW50X2Nvbm5lY3Rpb24iLCJjb25uIiwiY2xvc2VfZmluaXNoZWQkMCIsImlzX2Nsb3NlZCQwIiwiY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0Iiwic2V4cF9vZl90JDEiLCJwYXJhbSIsImNvbm5fMDIzIiwibmV4dF9jb25uZWN0X3Jlc3VsdF8wMjYiLCJkb25fdF9yZWNvbm5lY3RfMDM0IiwiY2xvc2VfZmluaXNoZWRfMDMyIiwiY2xvc2Vfc3RhcnRlZF8wMzAiLCJldmVudF9oYW5kbGVyXzAyOCIsImJuZHNfMDE2IiwiYXJnXzAzOSIsImJuZHNfMDE2JDAiLCJhcmdfMDM3IiwiYm5kc18wMTYkMSIsImFyZ18wMzUiLCJibmRzXzAxNiQyIiwiYXJnXzAzMyIsImJuZHNfMDE2JDMiLCJhcmdfMDMxIiwiYm5kc18wMTYkNCIsInNlcnZlcl9uYW1lXzAxMSIsImJuZHNfMDEwIiwiYXJnXzAxNCIsImJuZHNfMDEwJDAiLCJhcmdfMDEyIiwiYm5kc18wMTAkMSIsImFyZ18wMjkiLCJibmRzXzAxNiQ1IiwiYXJnXzAyNyIsImJuZHNfMDE2JDYiLCJ2XzAyNSIsImFyZ18wMjQiLCJibmRzXzAxNiQ3IiwiYXJnXzAyMiIsImJuZHNfMDE2JDgiLCJhcmdfMDIwIiwiYm5kc18wMTYkOSIsImFyZ18wMTgiLCJibmRzXzAxNiQxMCIsImNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uXyIsImNsb3NlX2ZpbmlzaGVkJDEiLCJpc19jbG9zZWQkMSIsImNsb3NlJDAiLCJjb25uX29wdCIsInNlcnZlcl9uYW1lIiwiY3VycmVudF9jb25uZWN0aW9uJDAiLCJjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QkMCIsIngiLCJjb25uZWN0ZWQiLCJsb29wIiwiZCIsImNyZWF0ZSIsIm9uX2V2ZW50JDAiLCJyZXRyeV9kZWxheSQwIiwicmFuZG9tX3N0YXRlJDEiLCJ0aW1lX3NvdXJjZSQwIiwiY29ubmVjdCIsImFkZHJlc3MiLCJnZXRfYWRkcmVzcyIsInN0aCIsInN0aCQwIiwicmFuZG9tX3N0YXRlIiwic3RoJDEiLCJ0aW1lX3NvdXJjZSIsImV2ZW50X2hhbmRsZXIiLCJkZWZhdWx0X3JldHJ5X2RlbGF5Iiwibm9uX3JhbmRvbWl6ZWRfZGVsYXkiLCJyZXRyeV9kZWxheV9zcGFuIiwicmFuZG9tX3N0YXRlJDAiLCJzcGFuIiwic3BhbiQwIiwiZGlzdGFuY2UiLCJ3YWl0IiwicmV0cnlfZGVsYXkiLCJwcmV2aW91c19hZGRyZXNzIiwicHJldmlvdXNfZXJyb3IiLCJyZWFkeV90b19yZXRyeV9jb25uZWN0aW5nIiwiY29ubmVjdF9yZXN1bHQiLCJlcnIiLCJwcmV2aW91c19lcnIiLCJ0b19zZXhwIiwiZSIsInNhbWVfYXNfcHJldmlvdXNfZXJyb3IiLCJhZGRyIiwicHJldmlvdXNfYWRkcmVzcyQwIiwic2FtZV9hc19wcmV2aW91c19hZGRyZXNzIl0sInNvdXJjZXMiOlsiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC9wZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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OzttQkFqRFIzRixhQWVnQ0MsT0FSckJzRjthQW1ESCxPQUFBO1lBTWlCOzthQTFDckI7a0JBQ0lHO2NBQVksT0FBQSxpQ0FBWkE7O2FBRU4sSUFER0UsaUJBQ0gsUUFQQVQ7OztlQVVTVTtlQUhMQztpQkFHeUIsV0FiQzdGLE9BUzNCMkYsTUFJTUM7O2tCQUhMQzthQVBKWCwwQkFNR1M7aUNBVVcsT0FIZCxXQWhCOEIzRixNQVMzQjJGLE1BVXlCOzs7Z0JBVHhCRTs7bUJBekJOOUYsYUFlZ0NDLE9BUzNCMkY7YUFVQyxPQUFBO1lBQXdCO1lBYjlCO2FBQUEsTUFBQSxXQU5nQzNGO2FBTzVCLE1BQUE7O1dBMENzQjtXQUU1QixVQTlCUXlEO1dBNEZGLE9BQUE7VUFrQ2E7VUFyQ2pCLFVBN0hBMUQsYUFlZ0NDO1VBK0c1QixPQUFBO1NBb0NhO1NBdENoQixVQUFBO1NBREg7U0FBQSxPQTVHa0NBO1FBK1FuQjs7Z0JBakNmUztvQkExU0ZuQixhQWtCSVE7Z0JBc1NGNkQ7Z0JBRkFIO2dCQURBRjtnQkFEQUQ7Z0JBREFEO2dCQURBRjtnQkFEQUQ7Z0JBREFEO2dCQUpBRDs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbm9wZW4hIEFzeW5jX2tlcm5lbFxub3BlbiEgQXN5bmNfa2VybmVsX3JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2VcbmluY2x1ZGUgUGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbF9pbnRmXG5cbm1vZHVsZSBNYWtlIChDb25uIDogQ2xvc2FibGUpID0gc3RydWN0XG4gIG1vZHVsZSBDb25uID0gc3RydWN0XG4gICAgaW5jbHVkZSBDb25uXG5cbiAgICBsZXQgc2V4cF9vZl90IChfIDogdCkgOiBTZXhwLnQgPSBBdG9tIFwiPENvbm4udD5cIlxuICBlbmRcblxuICB0eXBlIGNvbm4gPSBDb25uLnRcblxuICBtb2R1bGUgRXZlbnQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgfCBBdHRlbXB0aW5nX3RvX2Nvbm5lY3RcbiAgICAgIHwgT2J0YWluZWRfYWRkcmVzcyBvZiAnYWRkcmVzc1xuICAgICAgfCBGYWlsZWRfdG9fY29ubmVjdCBvZiBFcnJvci50XG4gICAgICB8IENvbm5lY3RlZCBvZiAoY29ubltAc2V4cC5vcGFxdWVdKVxuICAgICAgfCBEaXNjb25uZWN0ZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdHlwZSAnYWRkcmVzcyBldmVudCA9ICdhZGRyZXNzIHRcblxuICAgIG1vZHVsZSBIYW5kbGVyID0gc3RydWN0XG4gICAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgICB7IHNlcnZlcl9uYW1lIDogc3RyaW5nXG4gICAgICAgIDsgb25fZXZlbnQgOiAnYWRkcmVzcyBldmVudCAtPiB1bml0IERlZmVycmVkLnRcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIGxldCBsb2dfbGV2ZWwgPSBmdW5jdGlvblxuICAgICAgfCBBdHRlbXB0aW5nX3RvX2Nvbm5lY3QgfCBDb25uZWN0ZWQgXyB8IERpc2Nvbm5lY3RlZCB8IE9idGFpbmVkX2FkZHJlc3MgXyAtPiBgSW5mb1xuICAgICAgfCBGYWlsZWRfdG9fY29ubmVjdCBfIC0+IGBFcnJvclxuICAgIDs7XG5cbiAgICBsZXQgaGFuZGxlIHQgeyBIYW5kbGVyLnNlcnZlcl9uYW1lID0gXzsgb25fZXZlbnQgfSA9IG9uX2V2ZW50IHRcbiAgZW5kXG5cbiAgKCogQSBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gdGhhdCBpcyBwb2x5bW9ycGhpYyBpbiB0aGUgYWRkcmVzcyB0eXBlLiAgV2UgaGlkZSBhd2F5IHRoaXNcbiAgICAgdHlwZSBsYXRlciBzaW5jZSBpdCBvbmx5IGFwcGVhcnMgaW4gdGhlIHR5cGUgb2YgW2NyZWF0ZV0uICopXG4gIG1vZHVsZSBQb2x5ID0gc3RydWN0XG4gICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgIHsgZ2V0X2FkZHJlc3MgOiB1bml0IC0+ICdhZGRyZXNzIE9yX2Vycm9yLnQgRGVmZXJyZWQudFxuICAgICAgOyBjb25uZWN0IDogJ2FkZHJlc3MgLT4gQ29ubi50IE9yX2Vycm9yLnQgRGVmZXJyZWQudFxuICAgICAgOyByZXRyeV9kZWxheSA6IHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50XG4gICAgICA7IG11dGFibGUgY29ubiA6IFsgYE9rIG9mIENvbm4udCB8IGBDbG9zZV9zdGFydGVkIF0gSXZhci50XG4gICAgICA7IG11dGFibGUgbmV4dF9jb25uZWN0X3Jlc3VsdCA6IENvbm4udCBPcl9lcnJvci50IEl2YXIudFxuICAgICAgOyBldmVudF9oYW5kbGVyIDogJ2FkZHJlc3MgRXZlbnQuSGFuZGxlci50XG4gICAgICA7IGNsb3NlX3N0YXJ0ZWQgOiB1bml0IEl2YXIudFxuICAgICAgOyBjbG9zZV9maW5pc2hlZCA6IHVuaXQgSXZhci50XG4gICAgICA7IGRvbid0X3JlY29ubmVjdCA6IHVuaXQgSXZhci50XG4gICAgICA7IGFkZHJlc3NfZXF1YWwgOiAnYWRkcmVzcyAtPiAnYWRkcmVzcyAtPiBib29sXG4gICAgICA7IHNleHBfb2ZfYWRkcmVzcyA6ICdhZGRyZXNzIC0+IFNleHAudFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICAgIGxldCBzZXJ2ZXJfbmFtZSB0ID0gdC5ldmVudF9oYW5kbGVyLnNlcnZlcl9uYW1lXG4gICAgbGV0IGhhbmRsZV9ldmVudCB0IGV2ZW50ID0gRXZlbnQuaGFuZGxlIGV2ZW50IHQuZXZlbnRfaGFuZGxlclxuXG4gICAgKCogVGhpcyBmdW5jdGlvbiBmb2N1c2VzIGluIG9uIHRoZSB0aGUgZXJyb3IgaXRzZWxmLCBkaXNjYXJkaW5nIGluZm9ybWF0aW9uIGFib3V0IHdoaWNoXG4gICAgICAgbW9uaXRvciBjYXVnaHQgdGhlIGVycm9yLCBpZiBhbnkuXG5cbiAgICAgICBJZiB3ZSBkb24ndCBkbyB0aGlzLCB3ZSBzb21ldGltZXMgZW5kIHVwIHdpdGggbm9pc3kgbG9ncyB3aGljaCByZXBvcnQgdGhlIHNhbWUgZXJyb3JcbiAgICAgICBhZ2FpbiBhbmQgYWdhaW4sIGRpZmZlcmluZyBvbmx5IGFzIHRvIHdoYXQgbW9uaXRvciBjYXVnaHQgdGhlbS4gKilcbiAgICBsZXQgc2FtZV9lcnJvciBlMSBlMiA9XG4gICAgICBsZXQgdG9fc2V4cCBlID0gRXhuLnNleHBfb2ZfdCAoTW9uaXRvci5leHRyYWN0X2V4biAoRXJyb3IudG9fZXhuIGUpKSBpblxuICAgICAgU2V4cC5lcXVhbCAodG9fc2V4cCBlMSkgKHRvX3NleHAgZTIpXG4gICAgOztcblxuICAgICgqIENvbnRpbnVlIHRyeWluZyB0byBjb25uZWN0IHVudGlsIHdlIGFyZSBhYmxlIHRvIGRvIHNvLCBpbiB3aGljaCBjYXNlIHdlIHJldHVybiBib3RoXG4gICAgICAgdGhlIG5ldyBjb25uZWN0aW9uIGFuZCBhIGRlZmVycmVkIHRoYXQgd2lsbCBiZWNvbWUgZGV0ZXJtaW5lZCBvbmNlIHdlIGFyZSByZWFkeSBmb3JcbiAgICAgICB0aGUgbmV4dCByZWNvbm5lY3Rpb24gYXR0ZW1wdC4gKilcbiAgICBsZXQgdHJ5X2Nvbm5lY3RpbmdfdW50aWxfc3VjY2Vzc2Z1bCB0ID1cbiAgICAgICgqIFdlIHRha2UgY2FyZSBub3QgdG8gc3BhbSBsb2dzIHdpdGggdGhlIHNhbWUgbWVzc2FnZSBvdmVyIGFuZCBvdmVyIGJ5IGNvbXBhcmluZ1xuICAgICAgICAgZWFjaCBsb2cgbWVzc2FnZSB0aGUgdGhlIHByZXZpb3VzIG9uZSBvZiB0aGUgc2FtZSB0eXBlLiAqKVxuICAgICAgbGV0IHByZXZpb3VzX2FkZHJlc3MgPSByZWYgTm9uZSBpblxuICAgICAgbGV0IHByZXZpb3VzX2Vycm9yID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCBjb25uZWN0ICgpID1cbiAgICAgICAgdC5nZXRfYWRkcmVzcyAoKVxuICAgICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCBFcnJvciBlIC0+IHJldHVybiAoRXJyb3IgZSlcbiAgICAgICAgfCBPayBhZGRyIC0+XG4gICAgICAgICAgbGV0IHNhbWVfYXNfcHJldmlvdXNfYWRkcmVzcyA9XG4gICAgICAgICAgICBtYXRjaCAhcHJldmlvdXNfYWRkcmVzcyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgICAgICAgIHwgU29tZSBwcmV2aW91c19hZGRyZXNzIC0+IHQuYWRkcmVzc19lcXVhbCBhZGRyIHByZXZpb3VzX2FkZHJlc3NcbiAgICAgICAgICBpblxuICAgICAgICAgIHByZXZpb3VzX2FkZHJlc3MgOj0gU29tZSBhZGRyO1xuICAgICAgICAgIChpZiBzYW1lX2FzX3ByZXZpb3VzX2FkZHJlc3NcbiAgICAgICAgICAgdGhlbiBEZWZlcnJlZC51bml0XG4gICAgICAgICAgIGVsc2UgaGFuZGxlX2V2ZW50IHQgKE9idGFpbmVkX2FkZHJlc3MgYWRkcikpXG4gICAgICAgICAgPj49IGZ1biAoKSAtPiB0LmNvbm5lY3QgYWRkclxuICAgICAgaW5cbiAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgdGhlbiByZXR1cm4gYENsb3NlX3N0YXJ0ZWRcbiAgICAgICAgZWxzZSBpZiBJdmFyLmlzX2Z1bGwgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgdGhlbiByZXR1cm4gYERvbid0X3JlY29ubmVjdFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZyA9IHQucmV0cnlfZGVsYXkgKCkgaW5cbiAgICAgICAgICBsZXQlYmluZCBjb25uZWN0X3Jlc3VsdCA9IGNvbm5lY3QgKCkgaW5cbiAgICAgICAgICBJdmFyLmZpbGwgdC5uZXh0X2Nvbm5lY3RfcmVzdWx0IGNvbm5lY3RfcmVzdWx0O1xuICAgICAgICAgIHQubmV4dF9jb25uZWN0X3Jlc3VsdCA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgICAgICAgICBtYXRjaCBjb25uZWN0X3Jlc3VsdCB3aXRoXG4gICAgICAgICAgfCBPayBjb25uIC0+IHJldHVybiAoYE9rIChjb25uLCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nKSlcbiAgICAgICAgICB8IEVycm9yIGVyciAtPlxuICAgICAgICAgICAgbGV0IHNhbWVfYXNfcHJldmlvdXNfZXJyb3IgPVxuICAgICAgICAgICAgICBtYXRjaCAhcHJldmlvdXNfZXJyb3Igd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgICAgICAgICAgfCBTb21lIHByZXZpb3VzX2VyciAtPiBzYW1lX2Vycm9yIGVyciBwcmV2aW91c19lcnJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBwcmV2aW91c19lcnJvciA6PSBTb21lIGVycjtcbiAgICAgICAgICAgIChpZiBzYW1lX2FzX3ByZXZpb3VzX2Vycm9yXG4gICAgICAgICAgICAgdGhlbiBEZWZlcnJlZC51bml0XG4gICAgICAgICAgICAgZWxzZSBoYW5kbGVfZXZlbnQgdCAoRmFpbGVkX3RvX2Nvbm5lY3QgZXJyKSlcbiAgICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAgIERlZmVycmVkLmFueVxuICAgICAgICAgICAgICBbIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgID4+PSBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICAgIGluXG4gICAgICBsb29wICgpXG4gICAgOztcblxuICAgIGxldCBhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3RpdmVfY29ubmVjdGlvbiB0ID1cbiAgICAgIEl2YXIuZmlsbCB0LmNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICBJdmFyLmZpbGwgdC5jbG9zZV9maW5pc2hlZCAoKTtcbiAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWRcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZVxuICAgICAgICAgICh0eXBlIGFkZHJlc3MpXG4gICAgICAgICAgfnNlcnZlcl9uYW1lXG4gICAgICAgICAgPyhvbl9ldmVudCA9IGZ1biBfIC0+IERlZmVycmVkLnVuaXQpXG4gICAgICAgICAgP3JldHJ5X2RlbGF5XG4gICAgICAgICAgPyhyYW5kb21fc3RhdGUgPSBgU3RhdGUgUmFuZG9tLlN0YXRlLmRlZmF1bHQpXG4gICAgICAgICAgPyh0aW1lX3NvdXJjZSA9IFRpbWVfc291cmNlLndhbGxfY2xvY2sgKCkpXG4gICAgICAgICAgfmNvbm5lY3RcbiAgICAgICAgICB+YWRkcmVzczoobW9kdWxlIEFkZHJlc3MgOiBBZGRyZXNzIHdpdGggdHlwZSB0ID0gYWRkcmVzcylcbiAgICAgICAgICBnZXRfYWRkcmVzc1xuICAgICAgPVxuICAgICAgbGV0IGV2ZW50X2hhbmRsZXIgPSB7IEV2ZW50LkhhbmRsZXIuc2VydmVyX25hbWU7IG9uX2V2ZW50IH0gaW5cbiAgICAgIGxldCBkZWZhdWx0X3JldHJ5X2RlbGF5ID1cbiAgICAgICAgRm4uY29uc3QgKFRpbWVfbnMuU3Bhbi5vZl9zZWMgKGlmIGFtX3J1bm5pbmdfdGVzdCB0aGVuIDAuMSBlbHNlIDEwLikpXG4gICAgICBpblxuICAgICAgbGV0IG5vbl9yYW5kb21pemVkX2RlbGF5ID0gT3B0aW9uLnZhbHVlIHJldHJ5X2RlbGF5IH5kZWZhdWx0OmRlZmF1bHRfcmV0cnlfZGVsYXkgaW5cbiAgICAgIGxldCByZXRyeV9kZWxheV9zcGFuID1cbiAgICAgICAgbWF0Y2ggcmFuZG9tX3N0YXRlIHdpdGhcbiAgICAgICAgfCBgTm9uX3JhbmRvbSAtPiBub25fcmFuZG9taXplZF9kZWxheVxuICAgICAgICB8IGBTdGF0ZSByYW5kb21fc3RhdGUgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIGxldCBzcGFuID0gbm9uX3JhbmRvbWl6ZWRfZGVsYXkgKCkgaW5cbiAgICAgICAgICAgIGxldCBzcGFuID0gVGltZV9ucy5TcGFuLnRvX3NlYyBzcGFuIGluXG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBSYW5kb20uU3RhdGUuZmxvYXQgcmFuZG9tX3N0YXRlIChzcGFuICouIDAuMykgaW5cbiAgICAgICAgICAgIGxldCB3YWl0ID1cbiAgICAgICAgICAgICAgaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlXG4gICAgICAgICAgICAgIHRoZW4gc3BhbiArLiBkaXN0YW5jZVxuICAgICAgICAgICAgICBlbHNlIHNwYW4gLS4gZGlzdGFuY2VcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBUaW1lX25zLlNwYW4ub2Zfc2VjIHdhaXRcbiAgICAgIGluXG4gICAgICBsZXQgcmV0cnlfZGVsYXkgKCkgPSBUaW1lX3NvdXJjZS5hZnRlciB0aW1lX3NvdXJjZSAocmV0cnlfZGVsYXlfc3BhbiAoKSkgaW5cbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBldmVudF9oYW5kbGVyXG4gICAgICAgIDsgZ2V0X2FkZHJlc3NcbiAgICAgICAgOyBjb25uZWN0XG4gICAgICAgIDsgbmV4dF9jb25uZWN0X3Jlc3VsdCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgcmV0cnlfZGVsYXlcbiAgICAgICAgOyBjb25uID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyBjbG9zZV9zdGFydGVkID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyBjbG9zZV9maW5pc2hlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgZG9uJ3RfcmVjb25uZWN0ID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyBhZGRyZXNzX2VxdWFsID0gQWRkcmVzcy5lcXVhbFxuICAgICAgICA7IHNleHBfb2ZfYWRkcmVzcyA9IEFkZHJlc3Muc2V4cF9vZl90XG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICAoKiB0aGlzIGxvb3AgZmluaXNoZXMgb25jZSBbY2xvc2UgdF0gaGFzIGJlZW4gY2FsbGVkLCBpbiB3aGljaCBjYXNlIGl0IG1ha2VzIHN1cmUgdG9cbiAgICAgICAgIGxlYXZlIFt0LmNvbm5dIGZpbGxlZCB3aXRoIFtgQ2xvc2Vfc3RhcnRlZF0uICopXG4gICAgICBkb24ndF93YWl0X2ZvclxuICAgICAgQEAgRGVmZXJyZWQucmVwZWF0X3VudGlsX2ZpbmlzaGVkICgpIChmdW4gKCkgLT5cbiAgICAgICAgaGFuZGxlX2V2ZW50IHQgQXR0ZW1wdGluZ190b19jb25uZWN0XG4gICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgdHJ5X2Nvbm5lY3RpbmdfdW50aWxfc3VjY2Vzc2Z1bCB0XG4gICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICB8IGBDbG9zZV9zdGFydGVkIC0+XG4gICAgICAgICAgSXZhci5maWxsIHQuY29ubiBgQ2xvc2Vfc3RhcnRlZDtcbiAgICAgICAgICByZXR1cm4gKGBGaW5pc2hlZCAoKSlcbiAgICAgICAgfCBgRG9uJ3RfcmVjb25uZWN0IC0+XG4gICAgICAgICAgYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0aXZlX2Nvbm5lY3Rpb24gdDtcbiAgICAgICAgICByZXR1cm4gKGBGaW5pc2hlZCAoKSlcbiAgICAgICAgfCBgT2sgKGNvbm4sIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmcpIC0+XG4gICAgICAgICAgSXZhci5maWxsIHQuY29ubiAoYE9rIGNvbm4pO1xuICAgICAgICAgIGhhbmRsZV9ldmVudCB0IChDb25uZWN0ZWQgY29ubilcbiAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgQ29ubi5jbG9zZV9maW5pc2hlZCBjb25uXG4gICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgIHQuY29ubiA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgICAgICAgICBoYW5kbGVfZXZlbnQgdCBEaXNjb25uZWN0ZWRcbiAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgKCogd2FpdHMgdW50aWwgW3JldHJ5X2RlbGF5ICgpXSB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIHRpbWUganVzdCBiZWZvcmUgd2UgbGFzdFxuICAgICAgICAgICAgIHRyaWVkIHRvIGNvbm5lY3QgcmF0aGVyIHRoYW4gdGhlIHRpbWUgd2Ugbm90aWNlZCBiZWluZyBkaXNjb25uZWN0ZWQsIHNvIHRoYXQgaWZcbiAgICAgICAgICAgICBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBkaWVzLCB3ZSB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IGltbWVkaWF0ZWx5LiAqKVxuICAgICAgICAgIGxldCVtYXAgKCkgPVxuICAgICAgICAgICAgRGVmZXJyZWQuYW55XG4gICAgICAgICAgICAgIFsgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZ1xuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgSXZhci5maWxsIHQuY29ubiBgQ2xvc2Vfc3RhcnRlZDtcbiAgICAgICAgICAgIGBGaW5pc2hlZCAoKSlcbiAgICAgICAgICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0aXZlX2Nvbm5lY3Rpb24gdDtcbiAgICAgICAgICAgIGBGaW5pc2hlZCAoKSlcbiAgICAgICAgICBlbHNlIGBSZXBlYXQgKCkpO1xuICAgICAgdFxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkIHQgPVxuICAgICAgKCogVGFrZSBjYXJlIG5vdCB0byByZXR1cm4gYSBjb25uZWN0aW9uIHRoYXQgaXMga25vd24gdG8gYmUgY2xvc2VkIGF0IHRoZSB0aW1lXG4gICAgICAgICBbY29ubmVjdGVkXSB3YXMgY2FsbGVkLiAgVGhpcyBjb3VsZCBoYXBwZW4gaW4gY2xpZW50IGNvZGUgdGhhdCBiZWhhdmVzIGxpa2VcbiAgICAgICAgIHtbXG4gICAgICAgICAgIFBlcnNpc3RlbnRfY29ubmVjdGlvbi5ScGMuY29ubmVjdGVkIHRcbiAgICAgICAgICAgPj49IGZ1biBjMSAtPlxuICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICBScGMuQ29ubmVjdGlvbi5jbG9zZV9maW5pc2hlZCBjMVxuICAgICAgICAgICAoKiBhdCB0aGlzIHBvaW50IHdlIGFyZSBpbiBhIHJhY2Ugd2l0aCB0aGUgc2FtZSBjYWxsIGluc2lkZVxuICAgICAgICAgICAgICBwZXJzaXN0ZW50X2NsaWVudC5tbCAqKVxuICAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgIFBlcnNpc3RlbnRfY29ubmVjdGlvbi5ScGMuY29ubmVjdGVkIHRcbiAgICAgICAgICAgKCogZGVwZW5kaW5nIG9uIGhvdyB0aGUgcmFjZSB0dXJucyBvdXQsIHdlIGRvbid0IHdhbnQgdG8gZ2V0IGEgY2xvc2VkIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgaGVyZSAqKVxuICAgICAgICAgICA+Pj0gZnVuIGMyIC0+XG4gICAgICAgICAgIC4uLlxuICAgICAgICAgXX1cbiAgICAgICAgIFRoaXMgZG9lc24ndCByZW1vdmUgdGhlIHJhY2UgY29uZGl0aW9uLCBidXQgaXQgbWFrZXMgaXQgbGVzcyBsaWtlbHkgdG8gaGFwcGVuLlxuICAgICAgKilcbiAgICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICAgIGxldCBkID0gSXZhci5yZWFkIHQuY29ubiBpblxuICAgICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBkXG4gICAgICAgICAgPj49IChmdW5jdGlvblxuICAgICAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICAgICAgfCBgT2sgY29ubiAtPiByZXR1cm4gY29ubilcbiAgICAgICAgfCBTb21lIGBDbG9zZV9zdGFydGVkIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgICAgIHwgU29tZSAoYE9rIGNvbm4pIC0+XG4gICAgICAgICAgaWYgQ29ubi5pc19jbG9zZWQgY29ublxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICgqIGdpdmUgdGhlIHJlY29ubmVjdGlvbiBsb29wIGEgY2hhbmNlIHRvIG92ZXJ3cml0ZSB0aGUgaXZhciAqKVxuICAgICAgICAgICAgQ29ubi5jbG9zZV9maW5pc2hlZCBjb25uID4+PSBsb29wXG4gICAgICAgICAgZWxzZSByZXR1cm4gY29ublxuICAgICAgaW5cbiAgICAgIGxvb3AgKClcbiAgICA7O1xuXG4gICAgbGV0IGN1cnJlbnRfY29ubmVjdGlvbiB0ID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKEl2YXIucmVhZCB0LmNvbm4pIHdpdGhcbiAgICAgIHwgTm9uZSB8IFNvbWUgYENsb3NlX3N0YXJ0ZWQgLT4gTm9uZVxuICAgICAgfCBTb21lIChgT2sgY29ubikgLT4gU29tZSBjb25uXG4gICAgOztcblxuICAgIGxldCBjbG9zZV9maW5pc2hlZCB0ID0gSXZhci5yZWFkIHQuY2xvc2VfZmluaXNoZWRcbiAgICBsZXQgaXNfY2xvc2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG5cbiAgICBsZXQgY2xvc2UgdCA9XG4gICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICB0aGVuXG4gICAgICAgICgqIEFub3RoZXIgY2FsbCB0byBjbG9zZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzLiAgV2FpdCBmb3IgaXQgdG8gZmluaXNoLiAqKVxuICAgICAgICBjbG9zZV9maW5pc2hlZCB0XG4gICAgICBlbHNlIChcbiAgICAgICAgSXZhci5maWxsIHQuY2xvc2Vfc3RhcnRlZCAoKTtcbiAgICAgICAgSXZhci5yZWFkIHQuY29ublxuICAgICAgICA+Pj0gZnVuIGNvbm5fb3B0IC0+XG4gICAgICAgIChtYXRjaCBjb25uX29wdCB3aXRoXG4gICAgICAgICB8IGBDbG9zZV9zdGFydGVkIC0+IERlZmVycmVkLnVuaXRcbiAgICAgICAgIHwgYE9rIGNvbm4gLT4gQ29ubi5jbG9zZSBjb25uKVxuICAgICAgICA+PnwgZnVuICgpIC0+IEl2YXIuZmlsbCB0LmNsb3NlX2ZpbmlzaGVkICgpKVxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0X2Nvbm5lY3Rpb25fY2xvc2VkID1cbiAgICAgIE9yX2Vycm9yLmVycm9yX3MgWyVtZXNzYWdlIFwiUGVyc2lzdGVudCBjb25uZWN0aW9uIGNsb3NlZFwiXVxuICAgIDs7XG5cbiAgICBsZXQgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IHQgPVxuICAgICAgaWYgaXNfY2xvc2VkIHRcbiAgICAgIHRoZW4gcmV0dXJuIGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGN1cnJlbnRfY29ubmVjdGlvbiB0IHdpdGhcbiAgICAgICAgfCBTb21lIHggd2hlbiBub3QgKENvbm4uaXNfY2xvc2VkIHgpIC0+IHJldHVybiAoT2sgeClcbiAgICAgICAgfCBTb21lIChfIDogQ29ubi50KSB8IE5vbmUgLT5cbiAgICAgICAgICBEZWZlcnJlZC5jaG9vc2VcbiAgICAgICAgICAgIFsgY2hvaWNlIChJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkKSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0X2Nvbm5lY3Rpb25fY2xvc2VkKVxuICAgICAgICAgICAgOyBjaG9pY2UgKEl2YXIucmVhZCB0Lm5leHRfY29ubmVjdF9yZXN1bHQpIEZuLmlkXG4gICAgICAgICAgICBdKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIHQgPVxuICAgICAgSXZhci5maWxsX2lmX2VtcHR5IHQuZG9uJ3RfcmVjb25uZWN0ICgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID0gVCA6ICdhZGRyZXNzIFBvbHkudCAtPiB0IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHNleHBfb2ZfdCAoVCB0KSA9IFBvbHkuc2V4cF9vZl90IHQuc2V4cF9vZl9hZGRyZXNzIHRcblxuICBsZXQgY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIChUIHQpID1cbiAgICBQb2x5LmNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCB0XG4gIDs7XG5cbiAgbGV0IGNsb3NlX2ZpbmlzaGVkIChUIHQpID0gUG9seS5jbG9zZV9maW5pc2hlZCB0XG4gIGxldCBpc19jbG9zZWQgKFQgdCkgPSBQb2x5LmlzX2Nsb3NlZCB0XG4gIGxldCBjbG9zZSAoVCB0KSA9IFBvbHkuY2xvc2UgdFxuICBsZXQgc2VydmVyX25hbWUgKFQgdCkgPSBQb2x5LnNlcnZlcl9uYW1lIHRcbiAgbGV0IGN1cnJlbnRfY29ubmVjdGlvbiAoVCB0KSA9IFBvbHkuY3VycmVudF9jb25uZWN0aW9uIHRcbiAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCAoVCB0KSA9IFBvbHkuY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IHRcbiAgbGV0IGNvbm5lY3RlZCAoVCB0KSA9IFBvbHkuY29ubmVjdGVkIHRcblxuICBsZXQgY3JlYXRlXG4gICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICA/b25fZXZlbnRcbiAgICAgICAgP3JldHJ5X2RlbGF5XG4gICAgICAgID9yYW5kb21fc3RhdGVcbiAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgIH5jb25uZWN0XG4gICAgICAgIH5hZGRyZXNzXG4gICAgICAgIGdldF9hZGRyZXNzXG4gICAgPVxuICAgIFRcbiAgICAgIChQb2x5LmNyZWF0ZVxuICAgICAgICAgfnNlcnZlcl9uYW1lXG4gICAgICAgICA/b25fZXZlbnRcbiAgICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICAgP3JhbmRvbV9zdGF0ZVxuICAgICAgICAgP3RpbWVfc291cmNlXG4gICAgICAgICB+Y29ubmVjdFxuICAgICAgICAgfmFkZHJlc3NcbiAgICAgICAgIGdldF9hZGRyZXNzKVxuICA7O1xuZW5kXG4iXX0=
