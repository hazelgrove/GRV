// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Stdio__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdio = [0];
   runtime.caml_register_global(0, Stdio, "Stdio__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__In_channel
//# unitInfo: Requires: Base, Base__Buffer, Base__Char, Base__Exn, Base__List, Base__String, Caml, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    flags = [0, 0, 0],
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Buffer = global_data.Base__Buffer,
    Stdlib = global_data.Stdlib,
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base;
   function equal(t1, t2){return caml_call2(Base[204], t1, t2);}
   var
    seek = Caml[96][4],
    pos = Caml[96][5],
    length = Caml[96][6],
    stdin = Caml[38];
   function create(opt, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    var flags$0 = binary ? [0, 6, flags] : flags;
    return caml_call3(Caml[81], flags$0, 0, file);
   }
   var close = Caml[93];
   function with_file(binary, file, f){
    var _i_ = create(binary, file);
    return caml_call3(Base_Exn[12], f, _i_, close);
   }
   function may_eof(f){
    try{var _g_ = [0, caml_call1(f, 0)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   function input(t, buf, pos, len){
    return caml_call4(Caml[84], t, buf, pos, len);
   }
   function really_input(t, buf, pos, len){
    return may_eof
            (function(param){return caml_call4(Caml[85], t, buf, pos, len);});
   }
   function really_input_exn(t, buf, pos, len){
    return caml_call4(Caml[85], t, buf, pos, len);
   }
   function input_byte(t){
    return may_eof(function(param){return caml_call1(Caml[87], t);});
   }
   function input_char(t){
    return may_eof(function(param){return caml_call1(Caml[82], t);});
   }
   function input_binary_int(t){
    return may_eof(function(param){return caml_call1(Caml[88], t);});
   }
   function unsafe_input_value(t){
    return may_eof(function(param){return caml_call1(Caml[89], t);});
   }
   function input_buffer(t, buf, len){
    return may_eof
            (function(param){
              return caml_call3(Stdlib_Buffer[22], buf, t, len);
             });
   }
   var set_binary_mode = Caml[95];
   function input_all(t){
    var buffer = caml_call1(Base_Buffer[2], 65536), chunk_size = 65536;
    try{for(;;) caml_call3(Stdlib_Buffer[22], buffer, t, chunk_size);}
    catch(_e_){
     var _d_ = caml_wrap_exception(_e_);
     if(_d_ === Stdlib[12]) return caml_call1(Base_Buffer[3], buffer);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function trim(fix_win_eol, line){
    if(! fix_win_eol) return line;
    var len = runtime.caml_ml_string_length(line);
    if(0 < len){
     var _c_ = runtime.caml_string_get(line, len - 1 | 0);
     if(caml_call2(Base_Char[15], _c_, 13))
      return caml_call3(Base_String[2], line, 0, len - 1 | 0);
    }
    return line;
   }
   function input_line(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var match = may_eof(function(param){return caml_call1(Caml[83], t);});
    if(! match) return 0;
    var line = match[1];
    return [0, trim(fix_win_eol, line)];
   }
   function input_line_exn(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var line = caml_call1(Caml[83], t);
    return trim(fix_win_eol, line);
   }
   function fold_lines(fix_win_eol, t, init, f){
    var ac = init;
    for(;;){
     var match = input_line(fix_win_eol, t);
     if(! match) return ac;
     var line = match[1], ac$0 = caml_call2(f, ac, line), ac = ac$0;
    }
   }
   function input_lines(fix_win_eol, t){
    var
     _b_ =
       fold_lines
        (fix_win_eol, t, 0, function(lines, line){return [0, line, lines];});
    return caml_call1(Base_List[38], _b_);
   }
   function iter_lines(fix_win_eol, t, f){
    return fold_lines
            (fix_win_eol,
             t,
             0,
             function(param, line){return caml_call1(f, line);});
   }
   function read_lines(fix_win_eol, fname){
    return with_file
            (0, fname, function(_a_){return input_lines(fix_win_eol, _a_);});
   }
   function read_all(fname){return with_file(0, fname, input_all);}
   var
    Stdio_In_channel =
      [0,
       equal,
       stdin,
       create,
       with_file,
       close,
       input,
       really_input,
       really_input_exn,
       input_char,
       input_byte,
       input_binary_int,
       unsafe_input_value,
       input_buffer,
       input_all,
       input_line,
       input_line_exn,
       fold_lines,
       input_lines,
       iter_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       read_lines,
       read_all];
   runtime.caml_register_global(10, Stdio_In_channel, "Stdio__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__Out_channel
//# unitInfo: Requires: Base, Base__Exn, Base__List, Caml, Stdlib__Buffer, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\n",
    flags = [0, 1, [0, 3, 0]],
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ = [0, "<stderr>"],
    _b_ = [0, "<stdout>"],
    _c_ = [0, "<Out_channel.t>"];
   function equal(t1, t2){return caml_call2(Base[204], t1, t2);}
   var
    seek = Caml[96][1],
    pos = Caml[96][2],
    length = Caml[96][3],
    stdout = Caml[39],
    stderr = Caml[40];
   function sexp_of_t(t){
    return caml_call2(Base[204], t, stderr)
            ? _a_
            : caml_call2(Base[204], t, stdout) ? _b_ : _c_;
   }
   function create(opt, _j_, _i_, _h_, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    if(_j_) var sth$0 = _j_[1], append = sth$0; else var append = 0;
    if(_i_)
     var sth$1 = _i_[1], fail_if_exists = sth$1;
    else
     var fail_if_exists = 0;
    if(_h_) var sth$2 = _h_[1], perm = sth$2; else var perm = 438;
    var
     _k_ = binary ? 6 : 7,
     flags$0 = [0, _k_, flags],
     _l_ = append ? 2 : 4,
     flags$1 = [0, _l_, flags$0],
     flags$2 = fail_if_exists ? [0, 5, flags$1] : flags$1;
    return caml_call3(Caml[62], flags$2, perm, file);
   }
   var
    set_binary_mode = Caml[78],
    flush = Caml[63],
    close = Caml[76],
    close_no_err = Caml[77];
   function output(t, buf, pos, len){
    return caml_call4(Caml[68], t, buf, pos, len);
   }
   function output_substring(t, buf, pos, len){
    return caml_call4(Caml[69], t, buf, pos, len);
   }
   var
    output_string = Caml[66],
    output_bytes = Caml[67],
    output_char = Caml[65],
    output_byte = Caml[70],
    output_binary_int = Caml[71],
    output_buffer = Stdlib_Buffer[10],
    output_value = Caml[72];
   function newline(t){return caml_call2(output_string, t, cst);}
   function output_lines(t, lines){
    function _g_(line){caml_call2(output_string, t, line); return newline(t);}
    return caml_call2(Base_List[9], lines, _g_);
   }
   var
    printf = Stdlib_Printf[2],
    eprintf = Stdlib_Printf[3],
    fprintf = Stdlib_Printf[1],
    kfprintf = Stdlib_Printf[8],
    print_string = Caml[42],
    print_endline = Caml[46],
    prerr_endline = Caml[53];
   function print_s(mach, sexp){
    var
     _f_ =
       mach
        ? caml_call1(Base[85][14], sexp)
        : caml_call2(Base[85][13], 0, sexp);
    return caml_call1(print_endline, _f_);
   }
   function eprint_s(mach, sexp){
    var
     _e_ =
       mach
        ? caml_call1(Base[85][14], sexp)
        : caml_call2(Base[85][13], 0, sexp);
    return caml_call1(prerr_endline, _e_);
   }
   function with_file(binary, append, fail_if_exists, perm, file, f){
    var _d_ = create(binary, append, fail_if_exists, perm, file);
    return caml_call3(Base_Exn[12], f, _d_, close);
   }
   function write_lines(file, lines){
    return with_file
            (0, 0, 0, 0, file, function(t){return output_lines(t, lines);});
   }
   function write_all(file, data){
    return with_file
            (0,
             0,
             0,
             0,
             file,
             function(t){return caml_call2(output_string, t, data);});
   }
   var
    Stdio_Out_channel =
      [0,
       sexp_of_t,
       equal,
       stdout,
       stderr,
       create,
       with_file,
       close,
       close_no_err,
       set_binary_mode,
       flush,
       output,
       output_string,
       output_substring,
       output_bytes,
       output_char,
       output_byte,
       output_binary_int,
       output_buffer,
       output_value,
       newline,
       output_lines,
       fprintf,
       printf,
       print_s,
       eprint_s,
       eprintf,
       kfprintf,
       print_string,
       print_endline,
       prerr_endline,
       seek,
       pos,
       length,
       write_lines,
       write_all];
   runtime.caml_register_global(11, Stdio_Out_channel, "Stdio__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio
//# unitInfo: Requires: Stdio__In_channel, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdio_In_channel = global_data.Stdio__In_channel,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    stdin = Stdio_In_channel[2],
    stdout = Stdio_Out_channel[3],
    stderr = Stdio_Out_channel[4],
    eprintf = Stdio_Out_channel[26],
    printf = Stdio_Out_channel[23],
    print_s = Stdio_Out_channel[24],
    eprint_s = Stdio_Out_channel[25],
    print_string = Stdio_Out_channel[28],
    print_endline = Stdio_Out_channel[29],
    prerr_endline = Stdio_Out_channel[30],
    Stdio =
      [0,
       stdin,
       stdout,
       stderr,
       printf,
       print_s,
       eprint_s,
       eprintf,
       print_string,
       print_endline,
       prerr_endline];
   runtime.caml_register_global(2, Stdio, "Stdio");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRpby5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZmxhZ3MiLCJlcXVhbCIsInQxIiwidDIiLCJzZWVrIiwicG9zIiwibGVuZ3RoIiwic3RkaW4iLCJjcmVhdGUiLCJvcHQiLCJmaWxlIiwic3RoIiwiYmluYXJ5IiwiZmxhZ3MkMCIsImNsb3NlIiwid2l0aF9maWxlIiwiZiIsIm1heV9lb2YiLCJpbnB1dCIsInQiLCJidWYiLCJsZW4iLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfZXhuIiwiaW5wdXRfYnl0ZSIsImlucHV0X2NoYXIiLCJpbnB1dF9iaW5hcnlfaW50IiwidW5zYWZlX2lucHV0X3ZhbHVlIiwiaW5wdXRfYnVmZmVyIiwic2V0X2JpbmFyeV9tb2RlIiwiaW5wdXRfYWxsIiwiYnVmZmVyIiwiY2h1bmtfc2l6ZSIsInRyaW0iLCJmaXhfd2luX2VvbCIsImxpbmUiLCJpbnB1dF9saW5lIiwiaW5wdXRfbGluZV9leG4iLCJmb2xkX2xpbmVzIiwiaW5pdCIsImFjIiwiYWMkMCIsImlucHV0X2xpbmVzIiwibGluZXMiLCJpdGVyX2xpbmVzIiwicmVhZF9saW5lcyIsImZuYW1lIiwicmVhZF9hbGwiLCJzdGRvdXQiLCJzdGRlcnIiLCJzZXhwX29mX3QiLCJzdGgkMCIsImFwcGVuZCIsInN0aCQxIiwiZmFpbF9pZl9leGlzdHMiLCJzdGgkMiIsInBlcm0iLCJmbGFncyQxIiwiZmxhZ3MkMiIsImZsdXNoIiwiY2xvc2Vfbm9fZXJyIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnVmZmVyIiwib3V0cHV0X3ZhbHVlIiwibmV3bGluZSIsIm91dHB1dF9saW5lcyIsInByaW50ZiIsImVwcmludGYiLCJmcHJpbnRmIiwia2ZwcmludGYiLCJwcmludF9zdHJpbmciLCJwcmludF9lbmRsaW5lIiwicHJlcnJfZW5kbGluZSIsInByaW50X3MiLCJtYWNoIiwic2V4cCIsImVwcmludF9zIiwid3JpdGVfbGluZXMiLCJ3cml0ZV9hbGwiLCJkYXRhIl0sInNvdXJjZXMiOlsiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9zdGRpby9pbl9jaGFubmVsLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9zdGRpby9vdXRfY2hhbm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQVdNQTs7Ozs7Ozs7OztZQVBGQyxNQUFPQyxJQUFRQyxJQUFLLE9BQUEsc0JBQWJELElBQVFDLElBQXFCOztJQUNwQ0M7SUFDQUM7SUFDQUM7SUFDQUM7WUFFQUMsT0FBU0MsS0FBZUM7SUFDMUIsR0FEV0QsU0FBU0UsTUFBVEYsUUFBQUcsU0FBU0QsY0FBVEM7SUFFWCxJQUFJQyxVQUZPRCxnQkFDUFosU0FBQUE7SUFFSixPQUFBLHFCQURJYSxZQUZzQkg7R0FHTztPQUcvQkk7WUFDQUMsVUFBV0gsUUFBT0YsTUFBTU07SUFBaUIsVUFQekNSLE9BT1dJLFFBQU9GO29DQUFNTSxRQUR4QkY7R0FDZ0Y7WUFFaEZHLFFBQVFEO0lBQ1YsSUFBSSxjQUFLLFdBRENBLFFBQ047Ozs0QkFDYTs7O0dBQUk7WUFHbkJFLE1BQU1DLEdBQUdDLEtBQUtmLEtBQUtnQjtJQUFNLE9BQUEscUJBQW5CRixHQUFHQyxLQUFLZixLQUFLZ0I7R0FBOEI7WUFDakRDLGFBQWFILEdBQUdDLEtBQUtmLEtBQUtnQjtJQUFNLE9BTmhDSjs2QkFNbUQsT0FBbkIscUJBQW5CRSxHQUFHQyxLQUFLZixLQUFLZ0IsS0FBd0Q7R0FBQztZQUNuRkUsaUJBQWlCSixHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQUFBLHFCQUFuQkYsR0FBR0MsS0FBS2YsS0FBS2dCO0dBQXFDO1lBQ25FRyxXQUFXTDtJQUFJLE9BUmZGLHdCQVFrQyxPQUFuQixxQkFBSkUsR0FBd0M7R0FBQztZQUNwRE0sV0FBV047SUFBSSxPQVRmRix3QkFTa0MsT0FBbkIscUJBQUpFLEdBQXdDO0dBQUM7WUFDcERPLGlCQUFpQlA7SUFBSSxPQVZyQkYsd0JBVXdDLE9BQW5CLHFCQUFKRSxHQUE4QztHQUFDO1lBQ2hFUSxtQkFBbUJSO0lBQUksT0FYdkJGLHdCQVcwQyxPQUFuQixxQkFBSkUsR0FBeUM7R0FBQztZQUM3RFMsYUFBYVQsR0FBRUMsS0FBS0M7SUFBTSxPQVoxQko7O2NBWTZDLE9BQW5CLDhCQUFYRyxLQUFGRCxHQUFPRTthQUEwRDtHQUFDO09BQy9FUTtZQUVBQyxVQUFVWDtJQUVaLElBQ0lZLFNBQVMsbUNBRFRDO0lBTUosSUFIRSxRQUFBLDhCQUZFRCxRQUhRWixHQUVSYTs7OzRCQU9hLE9BQUEsMkJBTmJEOzs7R0FNbUM7WUFHckNFLEtBQU1DLGFBQVlDO0lBQ3BCLEtBRFFELGFBT0gsT0FQZUM7UUFHZGQsb0NBSGNjO0lBSWxCLE9BRElkO0tBQ3FCLFVBQUEsd0JBSlBjLE1BR2RkO0tBQ1UsR0FBQTtNQUNULE9BQUEsMkJBTGFjLFNBR2RkOztJQUdDLE9BTmFjO0dBT1g7WUFHUEMsV0FBYTNCLEtBQW9CVTtJQUNuQyxHQURlVixTQUFjRSxNQUFkRixRQUFBeUIsY0FBY3ZCLGNBQWR1QjtJQUNULFlBdENKakIsd0JBc0N1QixPQUF6QixxQkFEbUNFLEdBQ087Z0JBQ2hDO1FBQ0hnQjtJQUFRLFdBYmJGLEtBVWFDLGFBR1JDO0dBQXFDO1lBRzFDRSxlQUFpQjVCLEtBQW9CVTtJQUN2QyxHQURtQlYsU0FBY0UsTUFBZEYsUUFBQXlCLGNBQWN2QixjQUFkdUI7SUFDUixJQUFQQyxPQUFPLHFCQUQ0QmhCO0lBRXZDLE9BbEJFYyxLQWdCaUJDLGFBQ2ZDO0dBQ2tCO1lBR3BCRyxXQUFZSixhQUFZZixHQUNib0IsTUFEc0J2QjtJQUNuQyxJQUFhd0IsS0FBQUQ7SUFDWDtLQUFNLFlBYk5ILFdBV1lGLGFBQVlmO2lCQUdkLE9BRkNxQjtLQUdTLElBQWJMLGlCQUhJTSxPQUdTLFdBSmF6QixHQUN0QndCLElBR0pMLE9BSElLLEtBQUFDOztHQUtKO1lBR1BDLFlBQWFSLGFBQVlmO0lBQ2xCOztPQVZQbUI7U0FTYUosYUFBWWYsZUFDMEJ3QixPQUFNUixNQUFRLFdBQVJBLE1BQU5RLE9BQTJCO0lBQXZFLE9BQUE7R0FBeUU7WUFHaEZDLFdBQVlWLGFBQVlmLEdBQUdIO0lBQzdCLE9BZEVzQjthQWFZSjthQUFZZjs7NkJBQ29CZ0IsTUFBUSxPQUFBLFdBRHpCbkIsR0FDaUJtQixNQUFjO0dBQUM7WUFHM0RVLFdBQVlYLGFBQVlZO0lBQVEsT0FuRWhDL0I7Z0JBbUV3QitCLHFCLE9BUnhCSixZQVFZUjtHQUFpRTtZQUM3RWEsU0FBU0QsT0FBUSxPQXBFakIvQixhQW9FUytCLE9BbkRUaEIsV0FtRDZDOzs7O09BakY3QzdCO09BSUFNO09BRUFDO09BT0FPO09BREFEO09BUUFJO09BQ0FJO09BQ0FDO09BRUFFO09BREFEO09BRUFFO09BQ0FDO09BQ0FDO09BR0FFO09Bc0JBTTtPQU1BQztPQUtBQztPQVNBSTtPQUlBRTtPQTNFQXhDO09BQ0FDO09BQ0FDO09BeUJBdUI7T0FvREFnQjtPQUNBRTs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7OztJQ3hERS9DOzs7Ozs7Ozs7O1lBekJGQyxNQUFPQyxJQUFRQyxJQUFLLE9BQUEsc0JBQWJELElBQVFDLElBQXFCOztJQUNwQ0M7SUFDQUM7SUFDQUM7SUFDQTBDO0lBQ0FDO1lBRUFDLFVBQVUvQjtJQUNaLE9BQUcsc0JBRFNBLEdBRlY4Qjs7Y0FLTSxzQkFISTlCLEdBSFY2QjtHQVE4QjtZQU05QnhDLE9BQ0lDLG9CQUlGQztJQUVKLEdBTk1ELFNBQVNFLE1BQVRGLFFBQUFHLFNBQVNELGNBQVRDO0lBTU4sWUFMZXVDLGdCQUFUQyxTQUFTRCxnQkFBVEM7SUFLTjtTQUp1QkMsZ0JBQWpCQyxpQkFBaUJEOztTQUFqQkM7SUFJTixZQUhhQyxnQkFBUEMsT0FBT0QsZ0JBQVBDO0lBSU07V0FQTjVDO0tBT0ZDLG1CQURBYjtXQUxFb0Q7S0FPRkssbUJBREE1QztLQUVBNkMsVUFQRUosd0JBTUZHLFdBQUFBO0lBRUosT0FBQSxxQkFESUMsU0FORUYsTUFDRjlDO0dBTTZCOztJQUcvQm1CO0lBQ0E4QjtJQUNBN0M7SUFDQThDO1lBQ0FDLE9BQU8xQyxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQUFBLHFCQUFuQkYsR0FBR0MsS0FBS2YsS0FBS2dCO0dBQStCO1lBQ25EeUMsaUJBQWlCM0MsR0FBR0MsS0FBS2YsS0FBS2dCO0lBQU0sT0FBQSxxQkFBbkJGLEdBQUdDLEtBQUtmLEtBQUtnQjtHQUF5Qzs7SUFDdkUwQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxRQUFRbkQsR0FBSSxPQUFBLFdBUFo0QyxlQU9RNUMsUUFBd0I7WUFFaENvRCxhQUFhcEQsR0FBRXdCO2lCQUNPUixNQUN0QixXQVhBNEIsZUFTYTVDLEdBQ1NnQixPQUF4QixPQUhFbUMsUUFFYW5ELEdBR0o7SUFGUSxPQUFBLHlCQURGd0I7R0FHTDs7SUFHVjZCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLFFBQVNDLE1BQUtDO0lBQ2hCOztPQURXRDtVQUdLLHlCQUhBQztVQUlILDRCQUpHQTtJQUlILE9BQUEsV0FQWEo7R0FPbUM7WUFHbkNLLFNBQVVGLE1BQUtDO0lBQ2pCOztPQURZRDtVQUdJLHlCQUhDQztVQUlKLDRCQUpJQTtJQUlKLE9BQUEsV0FiWEg7R0FhbUM7WUFHbkMvRCxVQUFXSCxRQUFRd0MsUUFBUUUsZ0JBQWdCRSxNQUFLOUMsTUFBTU07SUFDM0MsVUExRFhSLE9BeURXSSxRQUFRd0MsUUFBUUUsZ0JBQWdCRSxNQUFLOUM7b0NBQU1NLFFBekN0REY7R0EwQ2dGO1lBR2hGcUUsWUFBWXpFLE1BQUtpQztJQUFRLE9BSnpCNUI7eUJBSVlMLGVBQW9DUyxHQUFLLE9BaENyRG9ELGFBZ0NnRHBELEdBQS9Cd0IsT0FBd0Q7R0FBQztZQUMxRXlDLFVBQVUxRSxNQUFNMkU7SUFBTyxPQUx2QnRFOzs7OzthQUtVTDtzQkFBb0NTLEdBQUssT0FBNUIsV0ExQ3ZCNEMsZUEwQzhDNUMsR0FBOUJrRSxNQUF1RDtHQUFDOzs7O09BekV4RW5DO09BUEFqRDtPQUlBK0M7T0FDQUM7T0FhQXpDO09BeURBTztPQXpDQUQ7T0FDQThDO09BSEEvQjtPQUNBOEI7T0FHQUU7T0FFQUU7T0FEQUQ7T0FFQUU7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FRQUc7T0FGQUY7T0FRQU87T0FPQUc7T0FkQVQ7T0FFQUU7T0FDQUM7T0FDQUM7T0FDQUM7T0ExREExRTtPQUNBQztPQUNBQztPQTRFQTZFO09BQ0FDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG50eXBlIHQgPSBDYW1sLmluX2NoYW5uZWxcblxubGV0IGVxdWFsICh0MSA6IHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IHNlZWsgPSBDYW1sLkxhcmdlRmlsZS5zZWVrX2luXG5sZXQgcG9zID0gQ2FtbC5MYXJnZUZpbGUucG9zX2luXG5sZXQgbGVuZ3RoID0gQ2FtbC5MYXJnZUZpbGUuaW5fY2hhbm5lbF9sZW5ndGhcbmxldCBzdGRpbiA9IENhbWwuc3RkaW5cblxubGV0IGNyZWF0ZSA/KGJpbmFyeSA9IHRydWUpIGZpbGUgPVxuICBsZXQgZmxhZ3MgPSBbIE9wZW5fcmRvbmx5IF0gaW5cbiAgbGV0IGZsYWdzID0gaWYgYmluYXJ5IHRoZW4gT3Blbl9iaW5hcnkgOjogZmxhZ3MgZWxzZSBmbGFncyBpblxuICBDYW1sLm9wZW5faW5fZ2VuIGZsYWdzIDBvMDAwIGZpbGVcbjs7XG5cbmxldCBjbG9zZSA9IENhbWwuY2xvc2VfaW5cbmxldCB3aXRoX2ZpbGUgP2JpbmFyeSBmaWxlIH5mID0gRXhuLnByb3RlY3R4IChjcmVhdGUgP2JpbmFyeSBmaWxlKSB+ZiB+ZmluYWxseTpjbG9zZVxuXG5sZXQgbWF5X2VvZiBmID1cbiAgdHJ5IFNvbWUgKGYgKCkpIHdpdGhcbiAgfCBFbmRfb2ZfZmlsZSAtPiBOb25lXG47O1xuXG5sZXQgaW5wdXQgdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwuaW5wdXQgdCBidWYgcG9zIGxlblxubGV0IHJlYWxseV9pbnB1dCB0IH5idWYgfnBvcyB+bGVuID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwucmVhbGx5X2lucHV0IHQgYnVmIHBvcyBsZW4pXG5sZXQgcmVhbGx5X2lucHV0X2V4biB0IH5idWYgfnBvcyB+bGVuID0gQ2FtbC5yZWFsbHlfaW5wdXQgdCBidWYgcG9zIGxlblxubGV0IGlucHV0X2J5dGUgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X2J5dGUgdClcbmxldCBpbnB1dF9jaGFyIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9jaGFyIHQpXG5sZXQgaW5wdXRfYmluYXJ5X2ludCB0ID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfYmluYXJ5X2ludCB0KVxubGV0IHVuc2FmZV9pbnB1dF92YWx1ZSB0ID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfdmFsdWUgdClcbmxldCBpbnB1dF9idWZmZXIgdCBidWYgfmxlbiA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLkJ1ZmZlci5hZGRfY2hhbm5lbCBidWYgdCBsZW4pXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gQ2FtbC5zZXRfYmluYXJ5X21vZGVfaW5cblxubGV0IGlucHV0X2FsbCB0ID1cbiAgKCogV2UgdXNlIDY1NTM2IGJlY2F1c2UgdGhhdCBpcyB0aGUgc2l6ZSBvZiBPQ2FtbCdzIElPIGJ1ZmZlcnMuICopXG4gIGxldCBjaHVua19zaXplID0gNjU1MzYgaW5cbiAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgY2h1bmtfc2l6ZSBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIENhbWwuQnVmZmVyLmFkZF9jaGFubmVsIGJ1ZmZlciB0IGNodW5rX3NpemU7XG4gICAgbG9vcCAoKVxuICBpblxuICB0cnkgbG9vcCAoKSB3aXRoXG4gIHwgRW5kX29mX2ZpbGUgLT4gQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuOztcblxubGV0IHRyaW0gfmZpeF93aW5fZW9sIGxpbmUgPVxuICBpZiBmaXhfd2luX2VvbFxuICB0aGVuIChcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBsaW5lIGluXG4gICAgaWYgbGVuID4gMCAmJiBDaGFyLmVxdWFsIChTdHJpbmcuZ2V0IGxpbmUgKGxlbiAtIDEpKSAnXFxyJ1xuICAgIHRoZW4gU3RyaW5nLnN1YiBsaW5lIH5wb3M6MCB+bGVuOihsZW4gLSAxKVxuICAgIGVsc2UgbGluZSlcbiAgZWxzZSBsaW5lXG47O1xuXG5sZXQgaW5wdXRfbGluZSA/KGZpeF93aW5fZW9sID0gdHJ1ZSkgdCA9XG4gIG1hdGNoIG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X2xpbmUgdCkgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgbGluZSAtPiBTb21lICh0cmltIH5maXhfd2luX2VvbCBsaW5lKVxuOztcblxubGV0IGlucHV0X2xpbmVfZXhuID8oZml4X3dpbl9lb2wgPSB0cnVlKSB0ID1cbiAgbGV0IGxpbmUgPSBDYW1sLmlucHV0X2xpbmUgdCBpblxuICB0cmltIH5maXhfd2luX2VvbCBsaW5lXG47O1xuXG5sZXQgZm9sZF9saW5lcyA/Zml4X3dpbl9lb2wgdCB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBhYyA9XG4gICAgbWF0Y2ggaW5wdXRfbGluZSA/Zml4X3dpbl9lb2wgdCB3aXRoXG4gICAgfCBOb25lIC0+IGFjXG4gICAgfCBTb21lIGxpbmUgLT4gbG9vcCAoZiBhYyBsaW5lKVxuICBpblxuICBsb29wIGluaXRcbjs7XG5cbmxldCBpbnB1dF9saW5lcyA/Zml4X3dpbl9lb2wgdCA9XG4gIExpc3QucmV2IChmb2xkX2xpbmVzID9maXhfd2luX2VvbCB0IH5pbml0OltdIH5mOihmdW4gbGluZXMgbGluZSAtPiBsaW5lIDo6IGxpbmVzKSlcbjs7XG5cbmxldCBpdGVyX2xpbmVzID9maXhfd2luX2VvbCB0IH5mID1cbiAgZm9sZF9saW5lcyA/Zml4X3dpbl9lb2wgdCB+aW5pdDooKSB+ZjooZnVuICgpIGxpbmUgLT4gZiBsaW5lKVxuOztcblxubGV0IHJlYWRfbGluZXMgP2ZpeF93aW5fZW9sIGZuYW1lID0gd2l0aF9maWxlIGZuYW1lIH5mOihpbnB1dF9saW5lcyA/Zml4X3dpbl9lb2wpXG5sZXQgcmVhZF9hbGwgZm5hbWUgPSB3aXRoX2ZpbGUgZm5hbWUgfmY6aW5wdXRfYWxsXG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgdCA9IENhbWwub3V0X2NoYW5uZWxcblxubGV0IGVxdWFsICh0MSA6IHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IHNlZWsgPSBDYW1sLkxhcmdlRmlsZS5zZWVrX291dFxubGV0IHBvcyA9IENhbWwuTGFyZ2VGaWxlLnBvc19vdXRcbmxldCBsZW5ndGggPSBDYW1sLkxhcmdlRmlsZS5vdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBzdGRvdXQgPSBDYW1sLnN0ZG91dFxubGV0IHN0ZGVyciA9IENhbWwuc3RkZXJyXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGlmIHBoeXNfZXF1YWwgdCBzdGRlcnJcbiAgdGhlbiBTZXhwLkF0b20gXCI8c3RkZXJyPlwiXG4gIGVsc2UgaWYgcGh5c19lcXVhbCB0IHN0ZG91dFxuICB0aGVuIFNleHAuQXRvbSBcIjxzdGRvdXQ+XCJcbiAgZWxzZSBTZXhwLkF0b20gXCI8T3V0X2NoYW5uZWwudD5cIlxuOztcblxudHlwZSAnYSB3aXRoX2NyZWF0ZV9hcmdzID1cbiAgP2JpbmFyeTpib29sIC0+ID9hcHBlbmQ6Ym9vbCAtPiA/ZmFpbF9pZl9leGlzdHM6Ym9vbCAtPiA/cGVybTppbnQgLT4gJ2FcblxubGV0IGNyZWF0ZVxuICAgICAgPyhiaW5hcnkgPSB0cnVlKVxuICAgICAgPyhhcHBlbmQgPSBmYWxzZSlcbiAgICAgID8oZmFpbF9pZl9leGlzdHMgPSBmYWxzZSlcbiAgICAgID8ocGVybSA9IDBvNjY2KVxuICAgICAgZmlsZVxuICA9XG4gIGxldCBmbGFncyA9IFsgT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQgXSBpblxuICBsZXQgZmxhZ3MgPSAoaWYgYmluYXJ5IHRoZW4gT3Blbl9iaW5hcnkgZWxzZSBPcGVuX3RleHQpIDo6IGZsYWdzIGluXG4gIGxldCBmbGFncyA9IChpZiBhcHBlbmQgdGhlbiBPcGVuX2FwcGVuZCBlbHNlIE9wZW5fdHJ1bmMpIDo6IGZsYWdzIGluXG4gIGxldCBmbGFncyA9IGlmIGZhaWxfaWZfZXhpc3RzIHRoZW4gT3Blbl9leGNsIDo6IGZsYWdzIGVsc2UgZmxhZ3MgaW5cbiAgQ2FtbC5vcGVuX291dF9nZW4gZmxhZ3MgcGVybSBmaWxlXG47O1xuXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gQ2FtbC5zZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgZmx1c2ggPSBDYW1sLmZsdXNoXG5sZXQgY2xvc2UgPSBDYW1sLmNsb3NlX291dFxubGV0IGNsb3NlX25vX2VyciA9IENhbWwuY2xvc2Vfb3V0X25vZXJyXG5sZXQgb3V0cHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBDYW1sLm91dHB1dCB0IGJ1ZiBwb3MgbGVuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyB0IH5idWYgfnBvcyB+bGVuID0gQ2FtbC5vdXRwdXRfc3Vic3RyaW5nIHQgYnVmIHBvcyBsZW5cbmxldCBvdXRwdXRfc3RyaW5nID0gQ2FtbC5vdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gQ2FtbC5vdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXRfY2hhciA9IENhbWwub3V0cHV0X2NoYXJcbmxldCBvdXRwdXRfYnl0ZSA9IENhbWwub3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IENhbWwub3V0cHV0X2JpbmFyeV9pbnRcbmxldCBvdXRwdXRfYnVmZmVyID0gQ2FtbC5CdWZmZXIub3V0cHV0X2J1ZmZlclxubGV0IG91dHB1dF92YWx1ZSA9IENhbWwub3V0cHV0X3ZhbHVlXG5sZXQgbmV3bGluZSB0ID0gb3V0cHV0X3N0cmluZyB0IFwiXFxuXCJcblxubGV0IG91dHB1dF9saW5lcyB0IGxpbmVzID1cbiAgTGlzdC5pdGVyIGxpbmVzIH5mOihmdW4gbGluZSAtPlxuICAgIG91dHB1dF9zdHJpbmcgdCBsaW5lO1xuICAgIG5ld2xpbmUgdClcbjs7XG5cbmxldCBwcmludGYgPSBDYW1sLlByaW50Zi5wcmludGZcbmxldCBlcHJpbnRmID0gQ2FtbC5QcmludGYuZXByaW50ZlxubGV0IGZwcmludGYgPSBDYW1sLlByaW50Zi5mcHJpbnRmXG5sZXQga2ZwcmludGYgPSBDYW1sLlByaW50Zi5rZnByaW50ZlxubGV0IHByaW50X3N0cmluZyA9IENhbWwucHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfZW5kbGluZSA9IENhbWwucHJpbnRfZW5kbGluZVxubGV0IHByZXJyX2VuZGxpbmUgPSBDYW1sLnByZXJyX2VuZGxpbmVcblxubGV0IHByaW50X3MgP21hY2ggc2V4cCA9XG4gIHByaW50X2VuZGxpbmVcbiAgICAobWF0Y2ggbWFjaCB3aXRoXG4gICAgIHwgU29tZSAoKSAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHBcbiAgICAgfCBOb25lIC0+IFNleHAudG9fc3RyaW5nX2h1bSBzZXhwKVxuOztcblxubGV0IGVwcmludF9zID9tYWNoIHNleHAgPVxuICBwcmVycl9lbmRsaW5lXG4gICAgKG1hdGNoIG1hY2ggd2l0aFxuICAgICB8IFNvbWUgKCkgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwXG4gICAgIHwgTm9uZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gc2V4cClcbjs7XG5cbmxldCB3aXRoX2ZpbGUgP2JpbmFyeSA/YXBwZW5kID9mYWlsX2lmX2V4aXN0cyA/cGVybSBmaWxlIH5mID1cbiAgRXhuLnByb3RlY3R4IChjcmVhdGUgP2JpbmFyeSA/YXBwZW5kID9mYWlsX2lmX2V4aXN0cyA/cGVybSBmaWxlKSB+ZiB+ZmluYWxseTpjbG9zZVxuOztcblxubGV0IHdyaXRlX2xpbmVzIGZpbGUgbGluZXMgPSB3aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIHQgLT4gb3V0cHV0X2xpbmVzIHQgbGluZXMpXG5sZXQgd3JpdGVfYWxsIGZpbGUgfmRhdGEgPSB3aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIHQgLT4gb3V0cHV0X3N0cmluZyB0IGRhdGEpXG4iXX0=
