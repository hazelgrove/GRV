// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Color
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    red = '"#FF5C56"',
    orange = '"#FFB643"',
    green = '"#A4FF77"',
    blue = '"#87E2FF"',
    purple = '"#D7BBD9"',
    white = '"#FFFFFF"',
    black = '"#000000#"',
    Color = [0, red, orange, green, blue, purple, white, black];
   runtime.caml_register_global(7, Color, "Color");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Js
//# unitInfo: Requires: Js_of_ocaml__Dom, Js_of_ocaml__Dom_html, Js_of_ocaml__Js, Stdlib, Stdlib__Array, Stdlib__Int, Stdlib__Printf, Uuid
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$10 = "')",
    cst$9 = "', ",
    cst$11 = "', '",
    cst$8 = ")",
    caml_js_eval_string = runtime.caml_js_eval_string;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$7 = "') || ''",
    cst$5 = cst$8,
    cst$6 = cst$9,
    cst$3 = cst$8,
    cst$4 = cst$9,
    cst$2 = cst$10,
    cst$1 = cst$10,
    cst$0 = cst$10,
    cst = cst$10,
    Stdlib = global_data.Stdlib,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Uuid = global_data.Uuid,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Js_of_ocaml_Dom = global_data.Js_of_ocaml__Dom,
    Js_of_ocaml_Dom_html = global_data.Js_of_ocaml__Dom_html,
    Js_of_ocaml_Js = global_data.Js_of_ocaml__Js,
    null$0 = Js_of_ocaml_Js[1],
    some = Js_of_ocaml_Js[2],
    undefined$0 = Js_of_ocaml_Js[3],
    def = Js_of_ocaml_Js[4],
    Opt = Js_of_ocaml_Js[5],
    Optdef = Js_of_ocaml_Js[6],
    true$0 = Js_of_ocaml_Js[7],
    false$0 = Js_of_ocaml_Js[8],
    nfd = Js_of_ocaml_Js[9],
    nfc = Js_of_ocaml_Js[10],
    nfkd = Js_of_ocaml_Js[11],
    nfkc = Js_of_ocaml_Js[12],
    string_constr = Js_of_ocaml_Js[13],
    regExp = Js_of_ocaml_Js[14],
    regExp_withFlags = Js_of_ocaml_Js[15],
    regExp_copy = Js_of_ocaml_Js[16],
    object_keys = Js_of_ocaml_Js[17],
    array_empty = Js_of_ocaml_Js[18],
    array_length = Js_of_ocaml_Js[19],
    array_get = Js_of_ocaml_Js[20],
    array_set = Js_of_ocaml_Js[21],
    array_map = Js_of_ocaml_Js[22],
    array_mapi = Js_of_ocaml_Js[23],
    str_array = Js_of_ocaml_Js[24],
    match_result = Js_of_ocaml_Js[25],
    date_now = Js_of_ocaml_Js[26],
    date_fromTimeValue = Js_of_ocaml_Js[27],
    date_month = Js_of_ocaml_Js[28],
    date_day = Js_of_ocaml_Js[29],
    date_hour = Js_of_ocaml_Js[30],
    date_min = Js_of_ocaml_Js[31],
    date_sec = Js_of_ocaml_Js[32],
    date_ms = Js_of_ocaml_Js[33],
    date = Js_of_ocaml_Js[34],
    math = Js_of_ocaml_Js[35],
    error_constr = Js_of_ocaml_Js[36],
    Js_error = Js_of_ocaml_Js[37],
    JSON = Js_of_ocaml_Js[38],
    decodeURI = Js_of_ocaml_Js[39],
    decodeURIComponent = Js_of_ocaml_Js[40],
    encodeURI = Js_of_ocaml_Js[41],
    encodeURIComponent = Js_of_ocaml_Js[42],
    escape = Js_of_ocaml_Js[43],
    unescape = Js_of_ocaml_Js[44],
    isNaN = Js_of_ocaml_Js[45],
    parseInt = Js_of_ocaml_Js[46],
    parseFloat = Js_of_ocaml_Js[47],
    coerce = Js_of_ocaml_Js[48],
    coerce_opt = Js_of_ocaml_Js[49],
    export$0 = Js_of_ocaml_Js[50],
    export_all = Js_of_ocaml_Js[51],
    Unsafe = Js_of_ocaml_Js[52],
    string_of_error = Js_of_ocaml_Js[53],
    raise_js_error = Js_of_ocaml_Js[54],
    exn_with_js_backtrace = Js_of_ocaml_Js[55],
    js_error_of_exn = Js_of_ocaml_Js[56],
    Error = Js_of_ocaml_Js[57],
    cst_window_prompt = "window.prompt('",
    cst_selectItem = "selectItem('",
    cst_toggleItem = "toggleItem('",
    cst_fillSelection = "fillSelection('",
    cst_clearSelection = "clearSelection('",
    cst_getSelection = "getSelection('",
    _b_ =
      [0,
       [11, "drawViz('graph", [2, 0, [11, cst$11, [2, 0, [11, cst$10, 0]]]]],
       "drawViz('graph%s', '%s')"],
    _a_ =
      [0,
       [11, "setInput('", [2, 0, [11, cst$11, [2, 0, [11, cst$10, 0]]]]],
       "setInput('%s', '%s')"],
    cst_getInput = "getInput('",
    cst_0 = "')}, 0)",
    cst_setTimeout_function_refocu = "setTimeout(function(){refocus('";
   function claim_event(event){
    caml_call1(Js_of_ocaml_Dom[18], event);
    return caml_call1(Js_of_ocaml_Dom_html[116], event);
   }
   function eval_to_string(js){
    return runtime.caml_string_of_jsstring(caml_js_eval_string(js));
   }
   function eval_to_unit(js){caml_js_eval_string(js); return 0;}
   function focus(id){
    var _r_ = caml_call2(Stdlib[28], id, cst_0);
    return eval_to_unit
            (caml_call2(Stdlib[28], cst_setTimeout_function_refocu, _r_));
   }
   function get_input(id){
    var _q_ = caml_call2(Stdlib[28], id, cst);
    return eval_to_string(caml_call2(Stdlib[28], cst_getInput, _q_));
   }
   function set_input(id, value){
    return eval_to_unit(caml_call3(Stdlib_Printf[4], _a_, id, value));
   }
   function focus_input(id){focus(id); return get_input(id);}
   function draw_viz(id, dot_src){
    var _p_ = caml_call1(Uuid[1][6], id);
    return eval_to_unit(caml_call3(Stdlib_Printf[4], _b_, _p_, dot_src));
   }
   function get_selection(id){
    var
     _n_ = caml_call2(Stdlib[28], id, cst$0),
     _o_ =
       runtime.caml_js_to_array
        (caml_js_eval_string(caml_call2(Stdlib[28], cst_getSelection, _n_)));
    return caml_call1(Stdlib_Array[9], _o_);
   }
   function clear_selection(id){
    var _m_ = caml_call2(Stdlib[28], id, cst$1);
    return eval_to_unit(caml_call2(Stdlib[28], cst_clearSelection, _m_));
   }
   function fill_selection(id){
    var _l_ = caml_call2(Stdlib[28], id, cst$2);
    return eval_to_unit(caml_call2(Stdlib[28], cst_fillSelection, _l_));
   }
   function toggle_item(id, i){
    var
     _h_ = caml_call1(Stdlib_Int[12], i),
     _i_ = caml_call2(Stdlib[28], _h_, cst$3),
     _j_ = caml_call2(Stdlib[28], cst$4, _i_),
     _k_ = caml_call2(Stdlib[28], id, _j_);
    return eval_to_unit(caml_call2(Stdlib[28], cst_toggleItem, _k_));
   }
   function select_item(id, i){
    var
     _d_ = caml_call1(Stdlib_Int[12], i),
     _e_ = caml_call2(Stdlib[28], _d_, cst$5),
     _f_ = caml_call2(Stdlib[28], cst$6, _e_),
     _g_ = caml_call2(Stdlib[28], id, _f_);
    return eval_to_unit(caml_call2(Stdlib[28], cst_selectItem, _g_));
   }
   function prompt(message){
    var _c_ = caml_call2(Stdlib[28], message, cst$7);
    return eval_to_string(caml_call2(Stdlib[28], cst_window_prompt, _c_));
   }
   var
    Js =
      [0,
       null$0,
       some,
       undefined$0,
       def,
       Opt,
       Optdef,
       true$0,
       false$0,
       nfd,
       nfc,
       nfkd,
       nfkc,
       string_constr,
       regExp,
       regExp_withFlags,
       regExp_copy,
       object_keys,
       array_empty,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_now,
       date_fromTimeValue,
       date_month,
       date_day,
       date_hour,
       date_min,
       date_sec,
       date_ms,
       date,
       math,
       error_constr,
       Js_error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe,
       string_of_error,
       raise_js_error,
       exn_with_js_backtrace,
       js_error_of_exn,
       Error,
       claim_event,
       eval_to_string,
       eval_to_unit,
       focus,
       get_input,
       set_input,
       focus_input,
       draw_viz,
       get_selection,
       clear_selection,
       fill_selection,
       toggle_item,
       select_item,
       prompt];
   runtime.caml_register_global(28, Js, "Js");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Graphviz
//# unitInfo: Requires: Color, Edge, Graph, Js, Lang, Stdlib, Stdlib__Format, Stdlib__List, Stdlib__String, Uuid, Vertex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_nposition = "\\nposition: ",
    cst_nsource = "\\nsource: ",
    cst_ntarget = "\\ntarget: ",
    caml_equal = runtime.caml_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "}",
    cst$1 = ";\n",
    partial =
      [2,
       0,
       [11, cst_nposition, [2, 0, [11, cst_ntarget, [2, 0, [11, '"]', 0]]]]]],
    partial$0 =
      [11,
       '",edgeURL="#",edgetooltip="id: ',
       [2,
        0,
        [11,
         cst_nsource,
         [2,
          0,
          [11,
           cst_nposition,
           [2,
            0,
            [11,
             cst_ntarget,
             [2,
              0,
              [11, '",labeltooltip="id: ', [2, 0, [11, cst_nsource, partial]]]]]]]]]]],
    partial$1 = [11, ", color=", [2, 0, [12, 93, 0]]],
    cst = "|",
    Stdlib_String = global_data.Stdlib__String,
    Js = global_data.Js,
    Graph = global_data.Graph,
    Vertex = global_data.Vertex,
    Stdlib_List = global_data.Stdlib__List,
    Edge = global_data.Edge,
    Stdlib = global_data.Stdlib,
    Lang = global_data.Lang,
    Uuid = global_data.Uuid,
    Stdlib_Format = global_data.Stdlib__Format,
    Color = global_data.Color,
    cst_digraph_G_node_shape_Mreco =
      "digraph G {\n   node [shape=Mrecord,fontsize=11,ranksep=0];\n   edge [arrowhead=vee,fontsize=11,weight=2];\n   rankdir = LR;\n   {rank=min; n0 [shape=point]};\n   ",
    _d_ =
      [0,
       [12, 110, [2, 0, [12, 58, [2, 0, [11, " -> hole", 0]]]]],
       "n%s:%s -> hole"],
    _e_ =
      [0,
       [11,
        'hole [label="",shape=circle,style=filled,fillcolor=',
        [2, 0, [12, 93, 0]]],
       'hole [label="",shape=circle,style=filled,fillcolor=%s]'],
    _f_ = [0, 0, 0],
    _c_ =
      [0,
       [12,
        110,
        [2,
         0,
         [12,
          58,
          [2,
           0,
           [11,
            " -> n",
            [2,
             0,
             [11, " [color=", [2, 0, [11, ',label="', [2, 0, partial$0]]]]]]]]]],
       'n%s:%s -> n%s [color=%s,label="%s",edgeURL="#",edgetooltip="id: %s\\nsource: %s\\nposition: %s\\ntarget: %s",labeltooltip="id: %s\\nsource: %s\\nposition: %s\\ntarget: %s"]'],
    _b_ =
      [0,
       [12,
        110,
        [2,
         0,
         [11,
          ' [label="{',
          [2,
           0,
           [11,
            ": ",
            [2,
             0,
             [11,
              "|{",
              [2, 0, [11, '}}", style=filled, fillcolor=', [2, 0, partial$1]]]]]]]]]],
       'n%s [label="{%s: %s|{%s}}", style=filled, fillcolor=%s, color=%s]'],
    _a_ = [0, [12, 60, [2, 0, [11, "> ", [2, 0, 0]]]], "<%s> %s"];
   function vertex_color(graph, cursor, vertex){
    var parents = caml_call2(Graph[6], graph, vertex);
    function source_is_cursor(edge){
     var
      _J_ = caml_equal(edge[2][1], cursor),
      _K_ = _J_ ? caml_equal(edge[2][2], vertex) : _J_;
     return _K_;
    }
    return caml_equal(vertex, Vertex[4])
            ? Color[7]
            : caml_call1
               (Edge[7][2], parents)
              ? Color[6]
              : caml_call2
                 (Edge[7][18], source_is_cursor, parents)
                ? Color[5]
                : Color[6];
   }
   function draw_position(position){
    var name = caml_call1(Lang[3][7], position);
    return caml_call3(Stdlib_Format[138], _a_, name, name);
   }
   function draw_vertex_children(vertex){
    var
     _H_ = caml_call1(Lang[3][9], vertex[2]),
     _I_ = caml_call1(caml_call1(Stdlib_List[19], draw_position), _H_);
    return caml_call1(caml_call1(Stdlib_String[6], cst), _I_);
   }
   function draw_vertex(graph, cursor, vertex){
    var
     id = caml_call1(Uuid[1][6], vertex[1]),
     _C_ = caml_call2(Graph[6], graph, vertex),
     _D_ = 2 <= caml_call1(Edge[7][22], _C_) ? Color[2] : Color[7],
     _E_ = vertex_color(graph, cursor, vertex),
     _F_ = draw_vertex_children(vertex),
     _G_ = caml_call1(Lang[2][8], vertex[2]);
    return caml_call7(Stdlib_Format[138], _b_, id, id, _G_, _F_, _E_, _D_);
   }
   function draw_edge(graph, live, edge){
    var
     source_id = caml_call1(Uuid[1][6], edge[2][1][1][1]),
     target_id = caml_call1(Uuid[1][6], edge[2][2][1]),
     edge_id = caml_call1(Uuid[1][6], edge[1]),
     position = caml_call1(Lang[3][2], edge[2][1][2]),
     field = caml_call1(Lang[3][7], edge[2][1][2]),
     _y_ = caml_call2(Edge[7][6], edge, live);
    function _z_(e){return caml_equal(e[2][1], edge[2][1]);}
    var
     _A_ = caml_call1(caml_call1(Edge[7][19], _z_), _y_),
     num_conflicts = caml_call1(Edge[7][22], _A_),
     _B_ = caml_call2(Graph[6], graph, edge[2][2]),
     num_parents = caml_call1(Edge[7][22], _B_);
    a:
    {
     if(0 === num_conflicts && 1 === num_parents){var color = Color[7]; break a;}
     var color = 0 < num_conflicts ? Color[1] : Color[2];
    }
    return caml_call14
            (Stdlib_Format[138],
             _c_,
             source_id,
             field,
             target_id,
             color,
             edge_id,
             edge_id,
             source_id,
             position,
             target_id,
             edge_id,
             source_id,
             position,
             target_id);
   }
   function maybe_draw_cursor_hole(graph, cursor){
    var _u_ = caml_call3(Graph[7], graph, cursor[1], cursor[2]);
    if(! caml_call1(Edge[7][2], _u_)) return _f_;
    var
     _v_ = caml_call1(Lang[3][7], cursor[2]),
     _w_ = caml_call1(Uuid[1][6], cursor[1][1]),
     _x_ = [0, caml_call3(Stdlib_Format[138], _d_, _w_, _v_), 0];
    return [0, [0, caml_call2(Stdlib_Format[138], _e_, Color[5]), 0], _x_];
   }
   function draw_graph(graph, cursor){
    var
     _i_ = caml_call1(Graph[8], graph),
     _j_ = caml_call1(Vertex[6][23], _i_);
    function _k_(_t_){return draw_vertex(graph, cursor, _t_);}
    var
     nodes = caml_call1(caml_call1(Stdlib_List[19], _k_), _j_),
     live = caml_call1(Graph[5], graph),
     _l_ = caml_call1(Edge[7][23], live);
    function _m_(_s_){return draw_edge(graph, live, _s_);}
    var
     edges = caml_call1(caml_call1(Stdlib_List[19], _m_), _l_),
     match = maybe_draw_cursor_hole(graph, cursor),
     hole_edge = match[2],
     hole_node = match[1],
     _n_ = caml_call2(Stdlib[37], edges, hole_edge),
     _o_ = caml_call2(Stdlib[37], hole_node, _n_),
     _p_ = caml_call2(Stdlib[37], nodes, _o_),
     _q_ = caml_call2(Stdlib_String[6], cst$1, _p_),
     _r_ = caml_call2(Stdlib[28], _q_, cst$0);
    return caml_call2(Stdlib[28], cst_digraph_G_node_shape_Mreco, _r_);
   }
   function draw(editor){
    var
     _g_ = draw_graph(editor[2], editor[3]),
     _h_ = caml_call1(Stdlib_String[24], _g_);
    return caml_call1(caml_call1(Js[65], editor[1]), _h_);
   }
   var
    Graphviz =
      [0,
       vertex_color,
       draw_position,
       draw_vertex_children,
       draw_vertex,
       draw_edge,
       maybe_draw_cursor_hole,
       draw_graph,
       draw];
   runtime.caml_register_global(21, Graphviz, "Graphviz");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Gui
//# unitInfo: Requires: Edge, Graph, Graph_action, Js, Lang, Stdlib, Stdlib__Int, Stdlib__List, Stdlib__Option, Stdlib__String, Util, Uuid, Vertex, Virtual_dom__Effect, Virtual_dom__Node, Virtual_dom__Vdom
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_actions$1 = "actions",
    cst_editor$2 = "editor",
    caml_equal = runtime.caml_equal,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    cst$0 = cst$2,
    cst = cst$2,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Virtual_dom_Vdom = global_data.Virtual_dom__Vdom,
    Virtual_dom_Node = global_data.Virtual_dom__Node,
    Js = global_data.Js,
    Uuid = global_data.Uuid,
    Graph = global_data.Graph,
    Edge = global_data.Edge,
    Vertex = global_data.Vertex,
    Virtual_dom_Effect = global_data.Virtual_dom__Effect,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Option = global_data.Stdlib__Option,
    Lang = global_data.Lang,
    Stdlib_Int = global_data.Stdlib__Int,
    Util = global_data.Util,
    Graph_action = global_data.Graph_action,
    _g_ = [0, "selector", 0],
    _f_ = [0, "panel", 0],
    cst_edge_id_or_vertex_id = "edge_id or vertex_id",
    cst_editor$1 = cst_editor$2,
    _c_ = [0, 0],
    _a_ = [0, "selected", 0],
    _b_ = [0, "selectItem", 0],
    cst_selectItems = "selectItems",
    _d_ = [0, "select", 0],
    cst_editor$0 = cst_editor$2,
    cst_editor = cst_editor$2,
    cst_deleted = "deleted",
    cst_actions = cst_actions$1,
    cst_editors = "editors",
    cst_actions$0 = cst_actions$1,
    cst_break = "break";
   function clicks_to(ctx, cursor){
    function _aU_(event){
     caml_call1(Js[58], event);
     return caml_call1(ctx[1], [0, ctx[2][1], [0, [0, cursor]]]);
    }
    return caml_call1(Virtual_dom_Vdom[1][47], _aU_);
   }
   function selected(selection, elements){
    var _aO_ = caml_call2(Stdlib_List[55], selection, elements);
    function _aP_(_aT_){return _aT_[1];}
    var _aQ_ = caml_call1(caml_call1(Stdlib_List[41], _aP_), _aO_);
    function _aR_(_aS_){return _aS_[2];}
    return caml_call1(caml_call1(Stdlib_List[19], _aR_), _aQ_);
   }
   function send(model, editor){
    var
     _aC_ = caml_call1(Uuid[1][6], editor[1]),
     _aD_ = caml_call2(Stdlib[28], cst_actions, _aC_),
     selection = caml_call1(Js[66], _aD_);
    if(! selection) return 0;
    var
     actions = selected(selection, caml_call1(Graph_action[4][23], editor[4])),
     _aE_ = caml_call1(Uuid[2][20], model[1]);
    function _aF_(_aN_){return _aN_[2];}
    var
     _aG_ = caml_call1(caml_call1(Stdlib_List[21], _aF_), _aE_),
     _aH_ = caml_call1(Uuid[1][6], editor[1]),
     _aI_ = caml_call2(Stdlib[28], cst_editors, _aH_),
     _aM_ = selected(caml_call1(Js[66], _aI_), _aG_);
    function _aJ_(editor){return editor[1];}
    var
     editor_ids = caml_call1(caml_call1(Stdlib_List[19], _aJ_), _aM_),
     _aK_ = caml_call1(Uuid[1][6], editor[1]),
     _aL_ = caml_call2(Stdlib[28], cst_actions$0, _aK_);
    caml_call1(Js[68], _aL_);
    return [0, [2, [0, actions, editor_ids]]];
   }
   function restore(editor, deleted, vertex_id){
    if(caml_call2(Stdlib_String[8], vertex_id, cst))
     var
      _aw_ = caml_call1(Uuid[1][6], editor[1]),
      _ax_ = caml_call2(Stdlib[28], cst_deleted, _aw_),
      selection = caml_call1(Js[66], _ax_),
      vertexes = caml_call1(Vertex[6][23], deleted),
      _ay_ = selected(selection, vertexes),
      _az_ = caml_call2(Stdlib_List[8], _ay_, 0);
    else
     var
      _aB_ = caml_call1(Uuid[1][7], vertex_id),
      _az_ = caml_call2(Graph[13], editor[2], _aB_);
    function _aA_(selection){return [1, [1, selection]];}
    return caml_call2(Util[3][1][1][2], _aA_, _az_);
   }
   function base_attrs(classes, opt, id){
    if(opt) var sth = opt[1], disabled = sth; else var disabled = 0;
    var
     _as_ = disabled ? [0, Virtual_dom_Vdom[1][18], 0] : 0,
     _at_ = [0, caml_call1(Virtual_dom_Vdom[1][16], classes), 0],
     _au_ = caml_call2(Stdlib[37], _at_, _as_);
    if(id)
     var
      id$0 = id[1],
      _av_ = [0, caml_call1(Virtual_dom_Vdom[1][22], id$0), 0];
    else
     var _av_ = 0;
    return caml_call2(Stdlib[37], _av_, _au_);
   }
   function apply_action(ctx, action, tabindexes){
    if(! action) return Virtual_dom_Effect[1];
    var
     action$0 = action[1],
     _ap_ = caml_call2(Uuid[2][28], ctx[2][1], tabindexes),
     _aq_ = caml_call1(Stdlib_Int[12], _ap_),
     _ar_ = caml_call2(Stdlib[28], cst_editor, _aq_);
    caml_call1(Js[61], _ar_);
    return caml_call1(ctx[1], [0, ctx[2][1], action$0]);
   }
   function text_input(opt, _ah_, on_change){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    if(_ah_) var sth$0 = _ah_[1], disabled = sth$0; else var disabled = 0;
    return function(ctx, id, tabindexes){
     caml_call2(Js[63], id, cst$0);
     var _ai_ = 0, _aj_ = 0;
     function _ak_(param, value){
      return caml_string_notequal(value, cst$2)
              ? apply_action(ctx, caml_call1(on_change, value), tabindexes)
              : Virtual_dom_Effect[1];
     }
     var
      _al_ = [0, caml_call1(Virtual_dom_Vdom[1][45], _ak_), _aj_],
      _am_ = base_attrs(classes, [0, disabled], [0, id]),
      _an_ = caml_call2(Stdlib[37], _am_, _al_),
      _ao_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _an_)];
     return caml_call3(Virtual_dom_Node[23], 0, _ao_, _ai_);};
   }
   function button(opt, _$_, on_click){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    if(_$_) var sth$0 = _$_[1], disabled = sth$0; else var disabled = 0;
    return function(ctx, label, tabindexes){
     var _aa_ = [0, caml_call1(Virtual_dom_Node[5], label), 0], _ab_ = 0;
     function _ac_(param){
      return apply_action(ctx, caml_call1(on_click, 0), tabindexes);
     }
     var
      _ad_ = [0, caml_call1(Virtual_dom_Vdom[1][47], _ac_), _ab_],
      _ae_ = base_attrs(classes, [0, disabled], 0),
      _af_ = caml_call2(Stdlib[37], _ae_, _ad_),
      _ag_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _af_)];
     return caml_call3(Virtual_dom_Node[9], 0, _ag_, _aa_);};
   }
   function none_button(on_click, ctx, label, tabindexes){
    return button(0, 0, function(param){caml_call1(on_click, 0); return 0;})
            (ctx, label, tabindexes);
   }
   function some_button(opt, ctx){
    if(opt) var sth = opt[1], disabled = sth; else var disabled = 0;
    return function(label, tabindexes, action){
     return button(0, [0, disabled], function(param){return [0, action];})
             (ctx, label, tabindexes);};
   }
   function button_text_input(opt, disabled){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    return function(on_click, on_change, ctx, label, id, tabindexes){
     var
      disabled$0 = caml_call2(Stdlib_Option[3], disabled, 0),
      _X_ =
        [0, text_input(0, [0, disabled$0], on_change)(ctx, id, tabindexes), 0],
      _Y_ =
        [0, button(0, [0, disabled$0], on_click)(ctx, label, tabindexes), _X_],
      _Z_ = base_attrs(classes, [0, disabled$0], [0, id]),
      ___ = [0, caml_call1(Virtual_dom_Vdom[1][8], _Z_)];
     return caml_call3(Virtual_dom_Node[11], 0, ___, _Y_);};
   }
   function sorted_text_input(opt, on_change){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    return function(ctx, id, sort, tabindexes){
     var
      disabled = 1 - (caml_call1(Lang[3][10], ctx[2][3][2]) === sort ? 1 : 0);
     return text_input([0, classes], [0, disabled], on_change)
             (ctx, id, tabindexes);};
   }
   function sorted_button(opt, on_click){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    return function(ctx, label, sort, tabindexes){
     var
      disabled = 1 - (caml_call1(Lang[3][10], ctx[2][3][2]) === sort ? 1 : 0);
     return button([0, classes], [0, disabled], on_click)
             (ctx, label, tabindexes);};
   }
   function action_button(ctx, label, sort, tabindexes, id_opt, mk_action){
    return sorted_button
             (0,
              function(param){
               var match = caml_call2(Stdlib_Option[7], Js[71], id_opt);
               if(! match) return [0, caml_call1(mk_action, cst$1)];
               var str = match[1];
               if(! caml_string_notequal(str, cst$2)) return 0;
               var
                _V_ = caml_call1(Stdlib_Option[4], id_opt),
                _W_ = caml_call2(Stdlib[28], cst_editor$0, _V_);
               caml_call1(Js[61], _W_);
               return [0, caml_call1(mk_action, str)];
              })
            (ctx, label, sort, tabindexes);
   }
   function select(opt, _A_, _z_, label){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    if(_A_) var sth$0 = _A_[1], multi = sth$0; else var multi = 1;
    if(_z_) var sth$1 = _z_[1], default$0 = sth$1; else var default$0 = multi;
    return function(id, items, view_item){
     var
      _B_ = default$0 ? _a_ : 0,
      _C_ = caml_call2(Stdlib[37], _b_, _B_),
      classes$0 = caml_call2(Stdlib[37], classes, _C_);
     function select_item(i, item){
      var _O_ = caml_call1(view_item, item), _P_ = 0;
      function _Q_(param){
       if(multi) caml_call2(Js[69], id, i); else caml_call2(Js[70], id, i);
       return Virtual_dom_Effect[1];
      }
      var
       _R_ = [0, caml_call1(Virtual_dom_Vdom[1][47], _Q_), _P_],
       _S_ = base_attrs(classes$0, _c_, 0),
       _T_ = caml_call2(Stdlib[37], _S_, _R_),
       _U_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _T_)];
      return caml_call3(Virtual_dom_Node[11], 0, _U_, _O_);
     }
     if(label){
      var label$0 = label[1];
      if(caml_call2(Stdlib_String[14], label$0, 32))
       var
        _D_ = [0, caml_call1(Virtual_dom_Node[5], label$0), 0],
        heading = [0, caml_call3(Virtual_dom_Node[15], 0, 0, _D_), 0],
        classes$1 = classes$0;
      else
       var
        _N_ = [0, caml_call1(Virtual_dom_Node[5], label$0), 0],
        heading$0 = [0, caml_call3(Virtual_dom_Node[15], 0, 0, _N_), 0],
        heading = heading$0,
        classes$1 = caml_call2(Stdlib[37], classes$0, [0, label$0, 0]);
     }
     else
      var heading = 0, classes$1 = classes$0;
     var
      _E_ = caml_call2(Stdlib_List[20], select_item, items),
      _F_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_selectItems), 0],
      _G_ = [0, caml_call1(Virtual_dom_Vdom[1][22], id), _F_],
      _H_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _G_)],
      _I_ = [0, caml_call3(Virtual_dom_Node[11], 0, _H_, _E_), 0],
      _J_ = caml_call2(Stdlib[37], heading, _I_),
      _K_ = caml_call2(Stdlib[37], classes$1, _d_),
      _L_ = [0, caml_call1(Virtual_dom_Vdom[1][16], _K_), 0],
      _M_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _L_)];
     return caml_call3(Virtual_dom_Node[11], 0, _M_, _J_);};
   }
   function teleport(ctx, id, param){
    var str = caml_call1(Js[71], cst_edge_id_or_vertex_id);
    if(! caml_string_notequal(str, cst$2)) return 0;
    var
     teleport_id = caml_call1(Uuid[1][7], str),
     _t_ = caml_call2(Stdlib[28], cst_editor$1, id);
    caml_call1(Js[61], _t_);
    var _u_ = caml_call1(Graph[4], ctx[2][2]);
    function _v_(edge){return caml_equal(edge[1], teleport_id);}
    var match = caml_call2(Edge[7][34], _v_, _u_);
    if(match){var edge = match[1]; return [0, [0, [0, edge[2][1]]]];}
    var _w_ = caml_call1(Graph[8], ctx[2][2]);
    function _x_(vertex){return caml_equal(vertex[1], teleport_id);}
    var match$0 = caml_call2(Vertex[6][34], _x_, _w_);
    if(! match$0) return 0;
    var
     vertex = match$0[1],
     _y_ = caml_call2(Graph[6], ctx[2][2], vertex),
     match$1 = caml_call1(Edge[7][29], _y_);
    if(! match$1) return 0;
    var edge$0 = match$1[1];
    return [0, [0, [0, edge$0[2][1]]]];
   }
   var
    _e_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_break)],
    break$0 = caml_call3(Virtual_dom_Node[11], 0, _e_, 0);
   function panel(opt, label){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    return function(nodes){
     if(label)
      var
       label$0 = label[1],
       _o_ = [0, caml_call1(Virtual_dom_Node[5], label$0), 0],
       heading = [0, caml_call3(Virtual_dom_Node[15], 0, 0, _o_), 0];
     else
      var heading = 0;
     var
      _p_ = caml_call2(Stdlib[37], [0, break$0, 0], nodes),
      _q_ = caml_call2(Stdlib[37], heading, _p_),
      _r_ = base_attrs(caml_call2(Stdlib[37], classes, _f_), 0, 0),
      _s_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _r_)];
     return caml_call3(Virtual_dom_Node[11], 0, _s_, _q_);};
   }
   function select_panel(opt, _i_, _h_, label){
    if(opt) var sth = opt[1], classes = sth; else var classes = 0;
    if(_i_) var sth$0 = _i_[1], multi = sth$0; else var multi = 1;
    if(_h_) var sth$1 = _h_[1], default$0 = sth$1; else var default$0 = multi;
    return function(id, items, view_item, nodes){
     if(label)
      var
       label$0 = label[1],
       _j_ =
         caml_call2(Stdlib_String[14], label$0, 32)
          ? select
             ([0, classes], [0, multi], [0, default$0], [0, label$0])
            (id, items, view_item)
          : select
             (0, [0, multi], [0, default$0], [0, label$0])
            (id, items, view_item),
       selector = _j_;
     else
      var
       selector =
         select(0, [0, multi], [0, default$0], 0)(id, items, view_item);
     var
      _k_ = caml_call2(Stdlib[37], [0, break$0, 0], nodes),
      _l_ = caml_call2(Stdlib[37], [0, selector, 0], _k_),
      _m_ = caml_call2(Stdlib[37], classes, _g_),
      _n_ = [0, caml_call1(Virtual_dom_Vdom[1][16], _m_)];
     return caml_call3(Virtual_dom_Node[11], 0, _n_, _l_);};
   }
   var
    Gui =
      [0,
       clicks_to,
       selected,
       send,
       restore,
       base_attrs,
       apply_action,
       text_input,
       button,
       none_button,
       some_button,
       button_text_input,
       sorted_text_input,
       sorted_button,
       action_button,
       select,
       teleport,
       break$0,
       panel,
       select_panel];
   runtime.caml_register_global(38, Gui, "Gui");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Key
//# unitInfo: Requires: Gui, Js, Js_of_ocaml__Dom_html, Js_of_ocaml__Js, Stdlib, Stdlib__Int, Util, Uuid, Virtual_dom__Effect
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    cst_editor$4 = "editor",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Js = global_data.Js,
    Uuid = global_data.Uuid,
    Stdlib = global_data.Stdlib,
    Virtual_dom_Effect = global_data.Virtual_dom__Effect,
    Js_of_ocaml_Dom_html = global_data.Js_of_ocaml__Dom_html,
    Util = global_data.Util,
    Gui = global_data.Gui,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_editor$3 = cst_editor$4,
    _e_ = [0, [0, 0]],
    _f_ = [0, [0, 1]],
    _g_ = [0, [0, 2]],
    _h_ = [0, [0, 3]],
    _i_ = [0, [1, [0, 2]]],
    cst_deleted = "deleted",
    _j_ = [0, [1, 0]],
    _k_ = [0, [1, [0, 1]]],
    cst_num_id = "num_id",
    cst_editor$0 = cst_editor$4,
    cst_pat_id = "pat_id",
    cst_editor$1 = cst_editor$4,
    cst_var_id = "var_id",
    cst_editor$2 = cst_editor$4,
    _a_ = [0, [1, [0, 8]]],
    _b_ = [0, [1, [0, 9]]],
    _c_ = [0, [1, [0, 3]]],
    _d_ = [0, [1, [0, 4]]],
    cst_editor = cst_editor$4;
   function moveLR(editor, tabindexes, event, delta){
    caml_call1(Js[58], event);
    var match = caml_call2(Uuid[2][29], editor[1], tabindexes);
    if(match)
     var
      tabindex = match[1],
      _x_ =
        tabindex === caml_call1(Uuid[2][23], tabindexes)[2]
         ? 1
         : tabindex + delta | 0,
      _y_ = _x_;
    else
     var _y_ = 1;
    var
     _z_ = caml_call1(Stdlib_Int[12], _y_),
     _A_ = caml_call2(Stdlib[28], cst_editor, _z_);
    return caml_call1(Js[61], _A_);
   }
   function ctrl(model, editor, tabindexes, event){
    var key = caml_call1(Js_of_ocaml_Dom_html[26][1], event);
    if(19 !== key)
     return 94 === key
             ? (moveLR(editor, tabindexes, event, -1), 0)
             : 95 === key ? (moveLR(editor, tabindexes, event, 1), 0) : 0;
    var result = caml_call2(Gui[3], model, editor);
    return result ? result : (caml_call1(Js[58], event), 0);
   }
   function shift(event){
    function _v_(jstr){
     var match = runtime.caml_string_of_jsstring(jstr);
     return caml_string_notequal(match, "*")
             ? caml_string_notequal
                (match, "+")
               ? caml_string_notequal
                  (match, ">")
                 ? caml_string_notequal(match, "N") ? 0 : _a_
                 : _b_
               : _c_
             : _d_;
    }
    var _w_ = caml_call1(Js[6][10], event.key);
    return caml_call2(Util[3][1][1][3], _w_, _v_);
   }
   function base(editor, event){
    var
     id = caml_call1(Uuid[1][6], editor[1]),
     match = caml_call1(Js_of_ocaml_Dom_html[26][1], event);
    if(41 <= match){
     if(94 <= match){
      if(98 > match)
       switch(match - 94 | 0){
         case 0:
          return _e_;
         case 1:
          return _f_;
         case 2:
          return _g_;
         default: return _h_;
       }
     }
     else if(53 > match)
      switch(match - 41 | 0){
        case 0:
         return _i_;
        case 4:
         var _r_ = caml_call2(Stdlib[28], cst_deleted, id);
         caml_call1(Js[67], _r_);
         return _j_;
        case 11:
         return _k_;
      }
    }
    else{
     var switcher = match - 14 | 0;
     if(8 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var str = caml_call1(Js[71], cst_num_id);
         if(caml_string_notequal(str, cst)){
          var _s_ = caml_call2(Stdlib[28], cst_editor$0, id);
          caml_call1(Js[61], _s_);
          return [0, [1, [0, [1, runtime.caml_int_of_string(str)]]]];
         }
         caml_call1(Js[58], event);
         return 0;
        case 2:
         var str$0 = caml_call1(Js[71], cst_pat_id);
         if(caml_string_notequal(str$0, cst)){
          var _t_ = caml_call2(Stdlib[28], cst_editor$1, id);
          caml_call1(Js[61], _t_);
          return [0, [1, [0, [2, str$0]]]];
         }
         caml_call1(Js[58], event);
         return 0;
        case 8:
         var str$1 = caml_call1(Js[71], cst_var_id);
         if(caml_string_notequal(str$1, cst)){
          var _u_ = caml_call2(Stdlib[28], cst_editor$2, id);
          caml_call1(Js[61], _u_);
          return [0, [1, [0, [0, str$1]]]];
         }
         caml_call1(Js[58], event);
         return 0;
      }
    }
    return 0;
   }
   function dispatch(inject, model, editor, tabindexes, event){
    var match = event.ctrlKey | 0;
    if(event.shiftKey | 0)
     var _l_ = match ? function(param){return 0;} : shift, handle = _l_;
    else
     var
      _o_ =
        match
         ? function(_p_){return ctrl(model, editor, tabindexes, _p_);}
         : function(_q_){return base(editor, _q_);},
      handle = _o_;
    var match$0 = handle(event);
    if(! match$0) return Virtual_dom_Effect[1];
    var action = match$0[1];
    caml_call1(Js[58], event);
    var
     _m_ = caml_call1(Uuid[1][6], editor[1]),
     _n_ = caml_call2(Stdlib[28], cst_editor$3, _m_);
    caml_call1(Js[61], _n_);
    return caml_call1(inject, [0, editor[1], action]);
   }
   var Key = [0, moveLR, ctrl, shift, base, dispatch];
   runtime.caml_register_global(38, Key, "Key");
   return;
  }
  (globalThis));

//# unitInfo: Provides: View
//# unitInfo: Requires: Cursor, Graph, Graph_action, Graphviz, Grove, Gui, Js, Key, Lang, Position_map, Stdlib, Stdlib__Format, Stdlib__Int, Stdlib__List, Stdlib__Option, Util, Uuid, Vertex, Virtual_dom__Node, Virtual_dom__Vdom
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "",
    cst$10 = "(",
    cst$9 = ")",
    cst_Cursor = "Cursor",
    cst_Graph = "Graph",
    cst_deleted$1 = "deleted",
    cst_editor$1 = "editor",
    cst_editors$2 = "editors",
    cst_restore$2 = "restore",
    cst_sub$1 = "sub",
    cst_tabindex$1 = "tabindex",
    cst_vertex$2 = "vertex",
    caml_equal = runtime.caml_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$9,
    cst$4 = cst$10,
    cst$5 = " }",
    cst$6 = " | ",
    cst$7 = "{ ",
    cst$8 = cst$11,
    cst$2 = "\xe2\x96\xa1",
    cst$1 = "#",
    cst = cst$9,
    cst$0 = cst$10,
    Cursor = global_data.Cursor,
    Position_map = global_data.Position_map,
    Lang = global_data.Lang,
    Gui = global_data.Gui,
    Virtual_dom_Node = global_data.Virtual_dom__Node,
    Vertex = global_data.Vertex,
    Uuid = global_data.Uuid,
    Stdlib = global_data.Stdlib,
    Virtual_dom_Vdom = global_data.Virtual_dom__Vdom,
    Stdlib_List = global_data.Stdlib__List,
    Util = global_data.Util,
    Js = global_data.Js,
    Grove = global_data.Grove,
    Graphviz = global_data.Graphviz,
    Stdlib_Option = global_data.Stdlib__Option,
    Key = global_data.Key,
    Stdlib_Int = global_data.Stdlib__Int,
    Graph = global_data.Graph,
    Graph_action = global_data.Graph_action,
    Stdlib_Format = global_data.Stdlib__Format,
    cst_sub = cst_sub$1,
    cst_sub$0 = cst_sub$1,
    cst_vertex$1 = cst_vertex$2,
    cst_vertex$0 = cst_vertex$2,
    cst_conflict = "conflict",
    cst_1 = "-1",
    cst_tabindex$0 = cst_tabindex$1,
    _G_ = [1, [0, 1]],
    _F_ = [1, [0, 2]],
    _E_ = [1, [0, 3]],
    _D_ = [1, [0, 4]],
    _B_ = [1, [0, 8]],
    _A_ = [1, [0, 9]],
    cst_deleted$0 = cst_deleted$1,
    _y_ = [0, [1, 0]],
    cst_Replay_Recording = "Replay Recording",
    cst_Load_a_Dump = "Load a Dump",
    cst_Drop = "Drop",
    cst_Clone = "Clone",
    _o_ = [0, "Editor"],
    cst_Load = "Load",
    _p_ = [3, 3],
    cst_Dump = "Dump",
    cst_Replay = "Replay",
    _q_ = [3, 2],
    cst_Stop = "Stop",
    _r_ = [3, 1],
    cst_Report = "Report",
    _s_ = [3, 0],
    cst_Record = "Record",
    _t_ = [0, "Environment"],
    cst_Teleport = "Teleport",
    _u_ = [0, 1],
    cst_Right = "Right (\xe2\x86\x92)",
    _v_ = [0, 0],
    cst_Left = "Left (\xe2\x86\x90)",
    _w_ = [0, 3],
    cst_Down = "Down (\xe2\x86\x93)",
    _x_ = [0, 2],
    cst_Up = "Up (\xe2\x86\x91)",
    cst_Delete_delete = "Delete (delete)",
    _z_ = [0, cst_Cursor],
    cst_Arrow = "Arrow (>)",
    cst_Num_N = "Num (N)",
    _C_ = [0, "Types"],
    cst_Times = "Times (*)",
    cst_Plus = "Plus (+)",
    cst_App_space = "App (space)",
    cst_Lam = "Lam (\\)",
    _H_ = [0, "num_id"],
    cst_Num_n = "Num (n)",
    _I_ = [0, "var_id"],
    cst_Var_v = "Var (v)",
    _J_ = [0, "pat_id"],
    cst_Pat_p = "Pat (p)",
    _K_ = [0, "Patterns and Expressions"],
    cst_selectors = "selectors",
    cst_tabindex = cst_tabindex$1,
    cst_editor = cst_editor$1,
    cst_editor$0 = cst_editor$1,
    cst_unicycles = "unicycles",
    _m_ = [0, "Unicycles"],
    _n_ = [0, 0],
    cst_restore$1 = cst_restore$2,
    cst_restore = cst_restore$2,
    cst_restore$0 = cst_restore$2,
    cst_Restore = "Restore",
    cst_deleted = cst_deleted$1,
    _k_ = [0, "Deleted"],
    _l_ = [0, 0],
    cst_multiparent = "multiparent",
    _i_ = [0, "Multiparented"],
    _j_ = [0, 0],
    cst_editors$0 = cst_editors$2,
    cst_editors = cst_editors$2,
    cst_None = "None",
    cst_All = "All",
    cst_Send_ctrl_s = "Send (ctrl-s)",
    cst_editors$1 = cst_editors$2,
    _f_ = [0, "Send to Editors"],
    _g_ = [0, 1],
    _h_ = [0, [0, "Editors", 0]],
    cst_actions = "actions",
    _d_ = [0, "Actions"],
    _e_ = [0, 1],
    cst_edge_id = "edge_id",
    _b_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_Toggle_IDs = "Toggle IDs",
    cst_Show_Source = "Show Source",
    cst_Drop_Edge = "Drop Edge",
    cst_graph = "graph",
    _c_ = [0, cst_Graph],
    _a_ = [0, cst_Cursor],
    cst_hole = "hole",
    cst_vertex = cst_vertex$2,
    cst_cursor = "cursor",
    cst_errs = "errs",
    cst_chars = "chars";
   function chars(str){
    var
     _cR_ = [0, caml_call1(Virtual_dom_Node[5], str), 0],
     _cS_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_chars), 0],
     _cT_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _cS_)];
    return caml_call3(Virtual_dom_Node[32], 0, _cT_, _cR_);
   }
   function errs(str){
    var
     _cO_ = [0, caml_call1(Virtual_dom_Node[5], str), 0],
     _cP_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_errs), 0],
     _cQ_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _cP_)];
    return caml_call3(Virtual_dom_Node[32], 0, _cQ_, _cO_);
   }
   function parenthesized(node){
    var _cM_ = [0, node, [0, chars(cst), 0]], _cN_ = [0, chars(cst$0), _cM_];
    return caml_call3(Virtual_dom_Node[32], 0, 0, _cN_);
   }
   function cursor_node(node){
    var _cL_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_cursor)];
    return caml_call3(Virtual_dom_Node[32], 0, _cL_, [0, node, 0]);
   }
   function maybe_cursor_node(editor, parent, node){
    return caml_equal(parent, editor[3]) ? cursor_node(node) : node;
   }
   function ref_node(ctx, parent, id){
    var
     _cF_ = caml_call1(Uuid[1][6], id),
     _cG_ = caml_call2(Stdlib[28], cst$1, _cF_),
     _cH_ = [0, caml_call1(Virtual_dom_Node[5], _cG_), 0],
     _cI_ = [0, caml_call2(Gui[1], ctx, parent), 0],
     _cJ_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_vertex), _cI_],
     _cK_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _cJ_)];
    return caml_call3(Virtual_dom_Node[32], 0, _cK_, _cH_);
   }
   function hole_node(ctx, parent){
    var
     _cB_ = [0, chars(cst$2), 0],
     _cC_ = [0, caml_call2(Gui[1], ctx, parent), 0],
     _cD_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_hole), _cC_],
     _cE_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _cD_)];
    return caml_call3(Virtual_dom_Node[32], 0, _cE_, _cB_);
   }
   function tree_node(opt, _cz_, ctx){
    if(opt) var sth = opt[1], parent = sth; else var parent = Cursor[4];
    if(_cz_) var sth$0 = _cz_[1], at_top = sth$0; else var at_top = 1;
    return function(tree){
     if(0 === tree[0])
      var
       children = tree[2],
       vertex = tree[1],
       _cA_ = vertex_node(ctx, parent, vertex, children, at_top);
     else
      var vertex$0 = tree[1], _cA_ = ref_node(ctx, parent, vertex$0[1]);
     return maybe_cursor_node(ctx[2], parent, _cA_);};
   }
   function vertex_node(ctx, parent, vertex, children, at_top){
    var _cl_ = vertex[2];
    function _cm_(position){
     var child_specs = caml_call3(Position_map[41], 0, position, children);
     if(! child_specs){
      var _cy_ = hole_node(ctx, [0, vertex, position]);
      return maybe_cursor_node(ctx[2], [0, vertex, position], _cy_);
     }
     if(child_specs[2])
      return conflict_node(ctx, [0, vertex, position], child_specs);
     var tree = child_specs[1][2], at_top = 1 === vertex[2] ? 1 : 0;
     return tree_node([0, [0, vertex, position]], [0, at_top], ctx)(tree);
    }
    var
     _cn_ = caml_call4(Lang[5], chars, chars, _cm_, _cl_),
     _co_ = [0, caml_call2(Gui[1], ctx, parent)],
     node = caml_call3(Virtual_dom_Node[32], 0, _co_, _cn_);
    a:
    {
     if(ctx[2][6] && ! caml_equal(vertex, Vertex[4])){
      var
       _cr_ = [0, caml_call1(Virtual_dom_Node[5], cst$3), 0],
       _cs_ =
         [0,
          node,
          [0, caml_call4(Virtual_dom_Node[47], cst_sub, 0, 0, _cr_), 0]],
       _ct_ = caml_call1(Uuid[1][6], vertex[1]),
       _cu_ = caml_call2(Stdlib[28], _ct_, cst$4),
       _cv_ = [0, caml_call1(Virtual_dom_Node[5], _cu_), 0],
       _cw_ =
         [0, caml_call4(Virtual_dom_Node[47], cst_sub$0, 0, 0, _cv_), _cs_],
       _cx_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_vertex$1)],
       decorated_node = caml_call3(Virtual_dom_Node[32], 0, _cx_, _cw_);
      break a;
     }
     var
      _cp_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_vertex$0)],
      decorated_node = caml_call3(Virtual_dom_Node[32], 0, _cp_, [0, node, 0]);
    }
    if(! at_top && 0 !== parent[2]){
     var _cq_ = vertex[2];
     if(typeof _cq_ === "number")
      switch(_cq_){
        case 1:
        case 2:
        case 3:
        case 4:
        case 9:
         return parenthesized(decorated_node);
      }
     return decorated_node;
    }
    return decorated_node;
   }
   function conflict_node(ctx, parent, child_specs){
    function _b$_(child){
     var _ck_ = child[2];
     return tree_node([0, parent], 0, ctx)(_ck_);
    }
    var
     nodes = caml_call2(Stdlib_List[19], _b$_, child_specs),
     _ca_ = [0, errs(cst$5), 0],
     _cb_ = errs(cst$6),
     _cc_ = caml_call2(Util[1][1], _cb_, nodes),
     _cd_ = caml_call2(Stdlib[37], _cc_, _ca_),
     _ce_ = [0, errs(cst$7), 0],
     _cf_ = caml_call2(Stdlib[37], _ce_, _cd_),
     _cg_ = [0, caml_call2(Gui[1], ctx, parent), 0],
     _ch_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_conflict), _cg_],
     _ci_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _ch_)],
     _cj_ = caml_call3(Virtual_dom_Node[32], 0, _ci_, _cf_);
    return maybe_cursor_node(ctx[2], parent, _cj_);
   }
   function cursor_panel(ctx){
    var _b__ = [0, chars(caml_call1(Cursor[3], ctx[2][3])), 0];
    return caml_call3(Gui[18], 0, _a_, _b__);
   }
   function graph_panel(ctx, id, tabindexes){
    var
     _bX_ = 0,
     _bY_ =
       [0,
        caml_call5
         (Gui[10], 0, ctx, cst_Toggle_IDs, tabindexes, [3, [4, ctx[2][1]]]),
        0];
    function _bZ_(param){
     var _b9_ = caml_call2(Graphviz[7], ctx[2][2], ctx[2][3]);
     return caml_call2(Stdlib_Format[136], _b_, _b9_);
    }
    var
     _b0_ =
       [0, caml_call4(Gui[9], _bZ_, ctx, cst_Show_Source, tabindexes), _bY_];
    function _b1_(param){
     var str = caml_call1(Js[71], cst_edge_id);
     return runtime.caml_string_notequal(str, cst$11)
             ? [0, [1, [2, caml_call1(Uuid[1][7], str)]]]
             : 0;
    }
    var
     _b2_ =
       [0,
        caml_call6(Gui[8], 0, 0, _b1_, ctx, cst_Drop_Edge, tabindexes),
        _b0_],
     _b3_ = [0, caml_call3(Virtual_dom_Node[11], 0, 0, _b2_), _bX_],
     _b4_ = [0, Gui[17], _b3_],
     _b5_ = [0, caml_call3(Virtual_dom_Node[32], 0, 0, 0), 0],
     _b6_ = caml_call2(Stdlib[28], cst_graph, id),
     _b7_ = [0, caml_call1(Virtual_dom_Vdom[1][22], _b6_)],
     _b8_ = [0, caml_call3(Virtual_dom_Node[11], 0, _b7_, _b5_), _b4_];
    return caml_call3(Gui[18], 0, _c_, _b8_);
   }
   function actions_panel(ctx, id){
    var _bT_ = 0;
    function _bU_(graph_action){
     return [0, chars(caml_call1(Graph_action[5], graph_action)), 0];
    }
    var
     _bV_ = caml_call1(Graph_action[4][23], ctx[2][4]),
     _bW_ = caml_call2(Stdlib[28], cst_actions, id);
    return caml_call8(Gui[19], 0, _e_, 0, _d_, _bW_, _bV_, _bU_, _bT_);
   }
   function send_actions_panel(model, ctx, id, tabindexes){
    var _bD_ = 0;
    function _bE_(param){
     var _bS_ = caml_call2(Stdlib[28], cst_editors, id);
     return caml_call1(Js[67], _bS_);
    }
    var _bF_ = [0, caml_call4(Gui[9], _bE_, ctx, cst_None, tabindexes), _bD_];
    function _bG_(param){
     var _bR_ = caml_call2(Stdlib[28], cst_editors$0, id);
     return caml_call1(Js[68], _bR_);
    }
    var _bH_ = [0, caml_call4(Gui[9], _bG_, ctx, cst_All, tabindexes), _bF_];
    function _bI_(param){return caml_call2(Gui[3], model, ctx[2]);}
    var
     _bJ_ =
       [0,
        caml_call6(Gui[8], 0, 0, _bI_, ctx, cst_Send_ctrl_s, tabindexes),
        _bH_];
    function _bK_(editor_id){
     var _bQ_ = caml_call1(Uuid[1][6], editor_id);
     return [0, caml_call1(Virtual_dom_Node[5], _bQ_), 0];
    }
    var _bL_ = caml_call1(Uuid[2][20], model[1]);
    function _bM_(_bP_){return _bP_[1];}
    var
     _bN_ = caml_call2(Stdlib_List[21], _bM_, _bL_),
     _bO_ = caml_call2(Stdlib[28], cst_editors$1, id);
    return caml_call8(Gui[19], _h_, _g_, 0, _f_, _bO_, _bN_, _bK_, _bJ_);
   }
   function multiparented_panel(ctx, id, mp, children){
    var _bu_ = 0;
    function _bv_(tree){
     var
      vertex = tree[1],
      _bx_ = caml_call2(Graph[10], ctx[2][2], vertex),
      _by_ = caml_call1(Vertex[6][23], _bx_);
     function _bz_(parent_vertex){
      var
       _bB_ = [0, caml_call1(Vertex[6][5], vertex)],
       _bC_ = caml_call4(Grove[1], _bB_, 0, parent_vertex, children)[1];
      return tree_node(0, 0, ctx)(_bC_);
     }
     var _bA_ = caml_call1(caml_call1(Stdlib_List[19], _bz_), _by_);
     return [0, tree_node(0, 0, ctx)(tree), _bA_];
    }
    var _bw_ = caml_call2(Stdlib[28], cst_multiparent, id);
    return caml_call8(Gui[19], 0, _j_, 0, _i_, _bw_, mp, _bv_, _bu_);
   }
   function deleted_panel(ctx, id, tabindexes, deleted){
    function _be_(param){var v = param[1]; return v;}
    var
     _bf_ = caml_call2(Stdlib_List[19], _be_, deleted),
     d = caml_call1(Vertex[6][37], _bf_),
     _bh_ = caml_call2(Stdlib[28], cst_restore, id);
    caml_call2(Js[63], _bh_, cst$8);
    var _bg_ = 0, _bi_ = 0, _bj_ = caml_call2(Stdlib[28], cst_restore$0, id);
    function _bk_(str){return caml_call3(Gui[4], ctx[2], d, str);}
    var
     _bl_ = [0, caml_call6(Gui[7], 0, 0, _bk_, ctx, _bj_, tabindexes), _bi_];
    function _bm_(param){
     var
      _bs_ = caml_call2(Stdlib[28], cst_restore$1, id),
      _bt_ = caml_call1(Js[62], _bs_);
     return caml_call3(Gui[4], ctx[2], d, _bt_);
    }
    var
     _bn_ =
       [0, caml_call6(Gui[8], 0, 0, _bm_, ctx, cst_Restore, tabindexes), _bl_],
     _bo_ = [0, caml_call3(Gui[18], 0, 0, _bn_), _bg_];
    function _bp_(tree){
     var vertex = tree[1], _br_ = caml_call1(Lang[3][11], vertex[2]);
     return [0,
             tree_node
               ([0, [0, vertex, caml_call2(Stdlib_Option[3], _br_, 0)]],
                0,
                ctx)
              (tree),
             0];
    }
    var _bq_ = caml_call2(Stdlib[28], cst_deleted, id);
    return caml_call8(Gui[19], 0, _l_, 0, _k_, _bq_, deleted, _bp_, _bo_);
   }
   function unicycles_panel(ctx, id, sc){
    var _bb_ = 0;
    function _bc_(tree){return [0, tree_node(0, 0, ctx)(tree), 0];}
    var _bd_ = caml_call2(Stdlib[28], cst_unicycles, id);
    return caml_call8(Gui[19], 0, _n_, 0, _m_, _bd_, sc, _bc_, _bb_);
   }
   function view_editor(model, ctx, tabindexes){
    var
     id = caml_call1(Uuid[1][6], ctx[2][1]),
     match = caml_call1(Grove[2], ctx[2][2]),
     children = match[2],
     decomp = match[1];
    caml_call1(Graphviz[8], ctx[2]);
    var
     _W_ = [3, [3, ctx[2][1]]],
     _X_ = [0, caml_call1(Uuid[2][19], model[1]) < 2 ? 1 : 0],
     _Y_ = [0, caml_call5(Gui[10], _X_, ctx, cst_Drop, tabindexes, _W_), 0],
     _Z_ =
       [0,
        caml_call5
         (Gui[10], 0, ctx, cst_Clone, tabindexes, [3, [2, ctx[2][1]]]),
        _Y_],
     ___ = [0, caml_call3(Gui[18], 0, _o_, _Z_), 0],
     _$_ = 0;
    function _aa_(param){
     return [0, [3, [1, caml_call1(Js[71], cst_Load_a_Dump)]]];
    }
    var
     _ab_ =
       [0, caml_call6(Gui[8], 0, 0, _aa_, ctx, cst_Load, tabindexes), _$_],
     _ac_ = [0, caml_call5(Gui[10], 0, ctx, cst_Dump, tabindexes, _p_), _ab_];
    function _ad_(param){
     return [0, [3, [0, caml_call1(Js[71], cst_Replay_Recording)]]];
    }
    var
     _ae_ =
       [0, caml_call6(Gui[8], 0, 0, _ad_, ctx, cst_Replay, tabindexes), _ac_],
     _af_ = [0, caml_call1(Stdlib_Option[10], model[2])],
     _ag_ =
       [0, caml_call5(Gui[10], _af_, ctx, cst_Stop, tabindexes, _q_), _ae_],
     _ah_ = [0, caml_call1(Stdlib_Option[10], model[2])],
     _ai_ =
       [0, caml_call5(Gui[10], _ah_, ctx, cst_Report, tabindexes, _r_), _ag_],
     _aj_ = [0, caml_call1(Stdlib_Option[11], model[2])],
     _ak_ =
       [0, caml_call5(Gui[10], _aj_, ctx, cst_Record, tabindexes, _s_), _ai_],
     _al_ = [0, caml_call3(Gui[18], 0, _t_, _ak_), ___],
     _am_ = caml_call2(Gui[16], ctx, id),
     _an_ =
       [0, caml_call6(Gui[8], 0, 0, _am_, ctx, cst_Teleport, tabindexes), 0],
     _ao_ = [0, caml_call5(Gui[10], 0, ctx, cst_Right, tabindexes, _u_), _an_],
     _ap_ = [0, caml_call5(Gui[10], 0, ctx, cst_Left, tabindexes, _v_), _ao_],
     _aq_ = [0, caml_call5(Gui[10], 0, ctx, cst_Down, tabindexes, _w_), _ap_],
     _ar_ = [0, caml_call5(Gui[10], 0, ctx, cst_Up, tabindexes, _x_), _aq_];
    function _as_(param){
     var _ba_ = caml_call2(Stdlib[28], cst_deleted$0, id);
     caml_call1(Js[67], _ba_);
     return _y_;
    }
    var
     _at_ =
       [0,
        caml_call6(Gui[8], 0, 0, _as_, ctx, cst_Delete_delete, tabindexes),
        _ar_],
     _au_ = [0, caml_call3(Gui[18], 0, _z_, _at_), _al_],
     _av_ = 0;
    function _aw_(param){return _A_;}
    var
     _ax_ =
       [0, caml_call6(Gui[14], ctx, cst_Arrow, 3, tabindexes, 0, _aw_), _av_];
    function _ay_(param){return _B_;}
    var
     _az_ =
       [0, caml_call6(Gui[14], ctx, cst_Num_N, 3, tabindexes, 0, _ay_), _ax_],
     _aA_ = [0, caml_call3(Gui[18], 0, _C_, _az_), _au_],
     _aB_ = 0;
    function _aC_(param){return _D_;}
    var
     _aD_ =
       [0, caml_call6(Gui[14], ctx, cst_Times, 1, tabindexes, 0, _aC_), _aB_];
    function _aE_(param){return _E_;}
    var
     _aF_ =
       [0, caml_call6(Gui[14], ctx, cst_Plus, 1, tabindexes, 0, _aE_), _aD_];
    function _aG_(param){return _F_;}
    var
     _aH_ =
       [0,
        caml_call6(Gui[14], ctx, cst_App_space, 1, tabindexes, 0, _aG_),
        _aF_];
    function _aI_(param){return _G_;}
    var
     _aJ_ =
       [0, caml_call6(Gui[14], ctx, cst_Lam, 1, tabindexes, 0, _aI_), _aH_];
    function _aK_(str){return [1, [0, [1, runtime.caml_int_of_string(str)]]];}
    var
     _aL_ =
       [0,
        caml_call6(Gui[14], ctx, cst_Num_n, 1, tabindexes, _H_, _aK_),
        _aJ_];
    function _aM_(str){return [1, [0, [0, str]]];}
    var
     _aN_ =
       [0,
        caml_call6(Gui[14], ctx, cst_Var_v, 1, tabindexes, _I_, _aM_),
        _aL_];
    function _aO_(str){return [1, [0, [0, str]]];}
    var
     _aP_ =
       [0,
        caml_call6(Gui[14], ctx, cst_Pat_p, 2, tabindexes, _J_, _aO_),
        _aN_],
     _aQ_ = [0, caml_call3(Gui[18], 0, _K_, _aP_), _aA_],
     _aR_ = [0, unicycles_panel(ctx, id, decomp[4]), 0],
     _aS_ = [0, deleted_panel(ctx, id, tabindexes, decomp[2]), _aR_],
     _aT_ = [0, multiparented_panel(ctx, id, decomp[1], children), _aS_],
     _aU_ = [0, send_actions_panel(model, ctx, id, tabindexes), _aT_],
     _aV_ = [0, actions_panel(ctx, id), _aU_],
     _aW_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_selectors)],
     _aX_ = [0, caml_call3(Virtual_dom_Node[11], 0, _aW_, _aV_), _aQ_],
     _aY_ = [0, graph_panel(ctx, id, tabindexes), _aX_],
     _aZ_ = [0, cursor_panel(ctx), _aY_],
     _a0_ = [0, Gui[17], _aZ_],
     _a1_ = decomp[3],
     _a2_ = [0, tree_node(0, 0, ctx)(_a1_), _a0_],
     _a3_ = caml_call4(Key[5], ctx[1], model, ctx[2], tabindexes),
     _a4_ = [0, caml_call1(Virtual_dom_Vdom[1][66], _a3_), 0],
     _a5_ = caml_call2(Uuid[2][28], ctx[2][1], tabindexes),
     _a6_ = caml_call1(Stdlib_Int[12], _a5_),
     _a7_ = [0, caml_call2(Virtual_dom_Vdom[1][1], cst_tabindex, _a6_), _a4_],
     _a8_ = [0, caml_call1(Virtual_dom_Vdom[1][15], cst_editor), _a7_],
     _a9_ = caml_call2(Stdlib[28], cst_editor$0, id),
     _a__ = [0, caml_call1(Virtual_dom_Vdom[1][22], _a9_), _a8_],
     _a$_ = [0, caml_call1(Virtual_dom_Vdom[1][8], _a__)];
    return caml_call3(Virtual_dom_Node[11], 0, _a$_, _a2_);
   }
   function view(inject, model){
    var _L_ = caml_call1(Uuid[2][20], model[1]);
    function _M_(_V_){return _V_[2];}
    var editors = caml_call1(caml_call1(Stdlib_List[19], _M_), _L_);
    function _N_(editor){return editor[1];}
    var editor_ids = caml_call2(Stdlib_List[19], _N_, editors);
    function _O_(i){return i + 1 | 0;}
    var
     _P_ = caml_call1(Stdlib_List[1], editors),
     positions = caml_call2(Stdlib_List[10], _P_, _O_),
     _Q_ = caml_call2(Stdlib_List[55], editor_ids, positions),
     _R_ = caml_call1(Stdlib_List[61], _Q_),
     tabindexes = caml_call1(Uuid[2][40], _R_);
    function _S_(editor){
     return view_editor(model, [0, inject, editor], tabindexes);
    }
    var
     _T_ = caml_call2(Stdlib_List[19], _S_, editors),
     _U_ = [0, caml_call2(Virtual_dom_Vdom[1][1], cst_tabindex$0, cst_1)];
    return caml_call3(Virtual_dom_Node[11], 0, _U_, _T_);
   }
   var
    View =
      [0,
       chars,
       errs,
       parenthesized,
       cursor_node,
       maybe_cursor_node,
       ref_node,
       hole_node,
       tree_node,
       vertex_node,
       conflict_node,
       cursor_panel,
       graph_panel,
       actions_panel,
       send_actions_panel,
       multiparented_panel,
       deleted_panel,
       unicycles_panel,
       view_editor,
       view];
   runtime.caml_register_global(129, View, "View");
   return;
  }
  (globalThis));

//# unitInfo: Provides: App
//# unitInfo: Requires: Action, Async_kernel__Deferred, Incr_dom__Component, Incr_dom__Incr, View
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    View = global_data.View,
    Action = global_data.Action,
    Incr_dom_Component = global_data.Incr_dom__Component,
    Incr_dom_Incr = global_data.Incr_dom__Incr,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred;
   function on_startup(param, _c_){
    return caml_call1(Async_kernel_Deferred[12], 0);
   }
   function create(model, param, inject){
    function _a_(model){
     var
      view = caml_call2(View[19], inject, model),
      _b_ = [0, caml_call1(Action[15], model)];
     return caml_call5(Incr_dom_Component[6], _b_, 0, 0, model, view);
    }
    return caml_call2(Incr_dom_Incr[78][4][6], model, _a_);
   }
   var App = [0, on_startup, create];
   runtime.caml_register_global(5, App, "App");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuZ3J2d2ViLm9ianMvanNvby9kZWZhdWx0L2dydndlYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2xhaW1fZXZlbnQiLCJldmVudCIsImV2YWxfdG9fc3RyaW5nIiwianMiLCJldmFsX3RvX3VuaXQiLCJmb2N1cyIsImlkIiwiZ2V0X2lucHV0Iiwic2V0X2lucHV0IiwidmFsdWUiLCJmb2N1c19pbnB1dCIsImRyYXdfdml6IiwiZG90X3NyYyIsImdldF9zZWxlY3Rpb24iLCJjbGVhcl9zZWxlY3Rpb24iLCJmaWxsX3NlbGVjdGlvbiIsInRvZ2dsZV9pdGVtIiwiaSIsInNlbGVjdF9pdGVtIiwicHJvbXB0IiwibWVzc2FnZSIsInZlcnRleF9jb2xvciIsImdyYXBoIiwiY3Vyc29yIiwidmVydGV4IiwicGFyZW50cyIsInNvdXJjZV9pc19jdXJzb3IiLCJlZGdlIiwiZHJhd19wb3NpdGlvbiIsInBvc2l0aW9uIiwibmFtZSIsImRyYXdfdmVydGV4X2NoaWxkcmVuIiwiZHJhd192ZXJ0ZXgiLCJkcmF3X2VkZ2UiLCJsaXZlIiwic291cmNlX2lkIiwidGFyZ2V0X2lkIiwiZWRnZV9pZCIsImZpZWxkIiwiZSIsIm51bV9jb25mbGljdHMiLCJudW1fcGFyZW50cyIsImNvbG9yIiwibWF5YmVfZHJhd19jdXJzb3JfaG9sZSIsImRyYXdfZ3JhcGgiLCJub2RlcyIsImVkZ2VzIiwiaG9sZV9lZGdlIiwiaG9sZV9ub2RlIiwiZHJhdyIsImVkaXRvciIsImNsaWNrc190byIsImN0eCIsInNlbGVjdGVkIiwic2VsZWN0aW9uIiwiZWxlbWVudHMiLCJzZW5kIiwibW9kZWwiLCJhY3Rpb25zIiwiZWRpdG9yX2lkcyIsInJlc3RvcmUiLCJkZWxldGVkIiwidmVydGV4X2lkIiwidmVydGV4ZXMiLCJiYXNlX2F0dHJzIiwiY2xhc3NlcyIsIm9wdCIsInN0aCIsImRpc2FibGVkIiwiaWQkMCIsImFwcGx5X2FjdGlvbiIsImFjdGlvbiIsInRhYmluZGV4ZXMiLCJhY3Rpb24kMCIsInRleHRfaW5wdXQiLCJzdGgkMCIsImJ1dHRvbiIsImxhYmVsIiwibm9uZV9idXR0b24iLCJvbl9jbGljayIsInNvbWVfYnV0dG9uIiwiYnV0dG9uX3RleHRfaW5wdXQiLCJvbl9jaGFuZ2UiLCJkaXNhYmxlZCQwIiwic29ydGVkX3RleHRfaW5wdXQiLCJzb3J0Iiwic29ydGVkX2J1dHRvbiIsImFjdGlvbl9idXR0b24iLCJpZF9vcHQiLCJta19hY3Rpb24iLCJzdHIiLCJzZWxlY3QiLCJtdWx0aSIsInN0aCQxIiwiZGVmYXVsdCQwIiwiaXRlbXMiLCJ2aWV3X2l0ZW0iLCJjbGFzc2VzJDAiLCJpdGVtIiwibGFiZWwkMCIsImhlYWRpbmciLCJjbGFzc2VzJDEiLCJ0ZWxlcG9ydCIsInRlbGVwb3J0X2lkIiwiZWRnZSQwIiwiYnJlYWskMCIsInBhbmVsIiwic2VsZWN0X3BhbmVsIiwic2VsZWN0b3IiLCJtb3ZlTFIiLCJkZWx0YSIsInRhYmluZGV4IiwiY3RybCIsImtleSIsInJlc3VsdCIsInNoaWZ0IiwianN0ciIsImJhc2UiLCJzdHIkMCIsInN0ciQxIiwiZGlzcGF0Y2giLCJpbmplY3QiLCJoYW5kbGUiLCJjaGFycyIsImVycnMiLCJwYXJlbnRoZXNpemVkIiwibm9kZSIsImN1cnNvcl9ub2RlIiwibWF5YmVfY3Vyc29yX25vZGUiLCJwYXJlbnQiLCJyZWZfbm9kZSIsInRyZWVfbm9kZSIsImF0X3RvcCIsInRyZWUiLCJjaGlsZHJlbiIsInZlcnRleF9ub2RlIiwidmVydGV4JDAiLCJjaGlsZF9zcGVjcyIsImNvbmZsaWN0X25vZGUiLCJkZWNvcmF0ZWRfbm9kZSIsImNoaWxkIiwiY3Vyc29yX3BhbmVsIiwiZ3JhcGhfcGFuZWwiLCJhY3Rpb25zX3BhbmVsIiwiZ3JhcGhfYWN0aW9uIiwic2VuZF9hY3Rpb25zX3BhbmVsIiwiZWRpdG9yX2lkIiwibXVsdGlwYXJlbnRlZF9wYW5lbCIsIm1wIiwicGFyZW50X3ZlcnRleCIsImRlbGV0ZWRfcGFuZWwiLCJ2IiwiZCIsInVuaWN5Y2xlc19wYW5lbCIsInNjIiwidmlld19lZGl0b3IiLCJkZWNvbXAiLCJ2aWV3IiwiZWRpdG9ycyIsInBvc2l0aW9ucyIsIm9uX3N0YXJ0dXAiLCJjcmVhdGUiXSwic291cmNlcyI6WyIvd29ya3NwYWNlX3Jvb3Qvc3JjL2dydndlYi9Kcy5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2d2ViL0dyYXBodml6Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZ3ZWIvR3VpLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZ3ZWIvS2V5Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9ncnZ3ZWIvVmlldy5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZ3J2d2ViL0FwcC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFFSUEsWUFBYUM7SUFDZixnQ0FEZUE7SUFDZixPQUFBLHNDQURlQTtHQUUyQjtZQUV4Q0MsZUFBZ0JDO0lBQXdCLE9BQUEsZ0NBQVUsb0JBQWxDQTtHQUF5RDtZQUV6RUMsYUFBY0QsSUFDUixvQkFEUUEsS0FDUixTQUNOO1lBRUFFLE1BQU9DO0lBQ3lDLFVBQUEsdUJBRHpDQTtJQUNJLE9BTFhGO2FBS1c7R0FBb0Q7WUFFL0RHLFVBQVdEO0lBQ29CLFVBQUEsdUJBRHBCQTtJQUNLLE9BVmhCSixlQVVnQjtHQUF3QjtZQUV4Q00sVUFBV0YsSUFBY0c7SUFDM0IsT0FYRUwsYUFXYyxrQ0FESEUsSUFBY0c7R0FDbUM7WUFFNURDLFlBQWFKLElBVGJELE1BU2FDLEtBQ2YsT0FQRUMsVUFNYUQsSUFFSDtZQUVWSyxTQUFVTCxJQUFpQk07SUFFZ0IsVUFBQSx1QkFGakNOO0lBRVQsT0FuQkRGLGFBbUJDLHVDQUYwQlE7R0FFOEM7WUFFekVDLGNBQWVQ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QTlDLElBQWJTLGFBQWEsaUNBRGJtRztJQUVKLGFBQXFEN0ksR0FBSyxPQUFMQSxVQUFVO0lBQXJDO0tBQUEsTUFBQSwyQkFGdEI2STtLQUVBQyxZQUFZO0tBRWQsTUFBQSw0QkFIRXBHLFlBQ0FvRztLQUVGLE1BQUE7S0FERXZGLGFBQ0Y7aUJBS1F0QjtLQUFVLE9BbkdsQnlHLFlBeUZpRGxHLFdBQTFDZ0UsUUFVQ3ZFLFNBTk5zQjtJQU0rRDtJQURqRTtLQUFBLE1BQUEsaUNBUkVzRjtLQU9JLFVBQUE7SUFDTixPQUFBO0dBRVc7Ozs7T0F4UlhuQztPQUdBQztPQUdBQztPQUdBRTtPQUdBQztPQUlBRTtPQUtBbEY7T0FLSW1GO09BT0pJO09Ba0NBRztPQWNBRztPQUdBQztPQW9CQUM7T0FNQUU7T0FlQUU7T0FnQkFHO09BK0JBRztPQVFBRTtPQXlGQUU7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7O1lDOVFBRztJQUVGLE9BQUE7R0FBd0M7WUFFdENDLE9BQVF4RyxjQUVOZ0U7aUJBRVNoRTtLQUNiO01BQUlvRyxPQUFPLHFCQUhQcEMsUUFFU2hFO01BRXNDLFVBQUEsdUJBRnRDQTtLQUViLE9BQUEsNkNBRmFBLE9BQ1RvRztJQUNtRTsrQ0FON0RwRzs7aUJBSlJ1RyxZQUlBQzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJpbmNsdWRlIEpzX29mX29jYW1sLkpzXG5cbmxldCBjbGFpbV9ldmVudCAoZXZlbnQgOiAnYSB0KSA6IHVuaXQgPVxuICBKc19vZl9vY2FtbC5Eb20ucHJldmVudERlZmF1bHQgZXZlbnQ7XG4gIEpzX29mX29jYW1sLkRvbV9odG1sLnN0b3BQcm9wYWdhdGlvbiBldmVudFxuXG5sZXQgZXZhbF90b19zdHJpbmcgKGpzIDogc3RyaW5nKSA6IHN0cmluZyA9IHRvX3N0cmluZyAoVW5zYWZlLmV2YWxfc3RyaW5nIGpzKVxuXG5sZXQgZXZhbF90b191bml0IChqcyA6IHN0cmluZykgOiB1bml0ID1cbiAgbGV0IF8gPSBVbnNhZmUuZXZhbF9zdHJpbmcganMgaW5cbiAgKClcblxubGV0IGZvY3VzIChpZCA6IHN0cmluZykgOiB1bml0ID1cbiAgZXZhbF90b191bml0IChcInNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZWZvY3VzKCdcIiBeIGlkIF4gXCInKX0sIDApXCIpXG5cbmxldCBnZXRfaW5wdXQgKGlkIDogc3RyaW5nKSA6IHN0cmluZyA9XG4gIGV2YWxfdG9fc3RyaW5nIEBAIFwiZ2V0SW5wdXQoJ1wiIF4gaWQgXiBcIicpXCJcblxubGV0IHNldF9pbnB1dCAoaWQgOiBzdHJpbmcpICh2YWx1ZSA6IHN0cmluZykgOiB1bml0ID1cbiAgZXZhbF90b191bml0IEBAIFByaW50Zi5zcHJpbnRmIFwic2V0SW5wdXQoJyVzJywgJyVzJylcIiBpZCB2YWx1ZVxuXG5sZXQgZm9jdXNfaW5wdXQgKGlkIDogc3RyaW5nKSA6IHN0cmluZyA9XG4gIGZvY3VzIGlkO1xuICBnZXRfaW5wdXQgaWRcblxubGV0IGRyYXdfdml6IChpZCA6IFV1aWQuSWQudCkgKGRvdF9zcmMgOiBzdHJpbmcpIDogdW5pdCA9XG4gIGV2YWxfdG9fdW5pdFxuICBAQCBQcmludGYuc3ByaW50ZiBcImRyYXdWaXooJ2dyYXBoJXMnLCAnJXMnKVwiIChVdWlkLklkLnRvX3N0cmluZyBpZCkgZG90X3NyY1xuXG5sZXQgZ2V0X3NlbGVjdGlvbiAoaWQgOiBzdHJpbmcpIDogYm9vbCBsaXN0ID1cbiAgQXJyYXkudG9fbGlzdCBAQCB0b19hcnJheSBAQCBVbnNhZmUuZXZhbF9zdHJpbmcgKFwiZ2V0U2VsZWN0aW9uKCdcIiBeIGlkIF4gXCInKVwiKVxuXG5sZXQgY2xlYXJfc2VsZWN0aW9uIChpZCA6IHN0cmluZykgOiB1bml0ID1cbiAgZXZhbF90b191bml0IEBAIFwiY2xlYXJTZWxlY3Rpb24oJ1wiIF4gaWQgXiBcIicpXCJcblxubGV0IGZpbGxfc2VsZWN0aW9uIChpZCA6IHN0cmluZykgOiB1bml0ID1cbiAgZXZhbF90b191bml0IEBAIFwiZmlsbFNlbGVjdGlvbignXCIgXiBpZCBeIFwiJylcIlxuXG5sZXQgdG9nZ2xlX2l0ZW0gKGlkIDogc3RyaW5nKSAoaSA6IGludCkgOiB1bml0ID1cbiAgZXZhbF90b191bml0IEBAIFwidG9nZ2xlSXRlbSgnXCIgXiBpZCBeIFwiJywgXCIgXiBJbnQudG9fc3RyaW5nIGkgXiBcIilcIlxuXG5sZXQgc2VsZWN0X2l0ZW0gKGlkIDogc3RyaW5nKSAoaSA6IGludCkgOiB1bml0ID1cbiAgZXZhbF90b191bml0IEBAIFwic2VsZWN0SXRlbSgnXCIgXiBpZCBeIFwiJywgXCIgXiBJbnQudG9fc3RyaW5nIGkgXiBcIilcIlxuXG5sZXQgcHJvbXB0IChtZXNzYWdlIDogc3RyaW5nKSA6IHN0cmluZyA9XG4gIGV2YWxfdG9fc3RyaW5nIEBAIFwid2luZG93LnByb21wdCgnXCIgXiBtZXNzYWdlIF4gXCInKSB8fCAnJ1wiXG4iLCJsZXQgdmVydGV4X2NvbG9yIChncmFwaCA6IEdyYXBoLnQpIChjdXJzb3IgOiBDdXJzb3IudCkgKHZlcnRleCA6IFZlcnRleC50KSA6XG4gICAgc3RyaW5nID1cbiAgbGV0IHBhcmVudHMgPSBHcmFwaC5wYXJlbnRfZWRnZXMgZ3JhcGggdmVydGV4IGluXG4gIGxldCBzb3VyY2VfaXNfY3Vyc29yIChlZGdlIDogRWRnZS50KSA9XG4gICAgZWRnZS52YWx1ZS5zb3VyY2UgPSBjdXJzb3IgJiYgZWRnZS52YWx1ZS50YXJnZXQgPSB2ZXJ0ZXhcbiAgaW5cbiAgaWYgdmVydGV4ID0gVmVydGV4LnJvb3QgdGhlbiBDb2xvci5ibGFja1xuICBlbHNlIGlmIEVkZ2UuU2V0LmlzX2VtcHR5IHBhcmVudHMgdGhlbiBDb2xvci53aGl0ZVxuICBlbHNlIGlmIEVkZ2UuU2V0LmV4aXN0cyBzb3VyY2VfaXNfY3Vyc29yIHBhcmVudHMgdGhlbiBDb2xvci5wdXJwbGVcbiAgZWxzZSBDb2xvci53aGl0ZVxuXG5sZXQgZHJhd19wb3NpdGlvbiAocG9zaXRpb24gOiBMYW5nLlBvc2l0aW9uLnQpIDogc3RyaW5nID1cbiAgbGV0IG5hbWUgPSBMYW5nLlBvc2l0aW9uLnNob3J0X25hbWUgcG9zaXRpb24gaW5cbiAgRm9ybWF0LnNwcmludGYgXCI8JXM+ICVzXCIgbmFtZSBuYW1lXG5cbmxldCBkcmF3X3ZlcnRleF9jaGlsZHJlbiAodmVydGV4IDogVmVydGV4LnQpIDogc3RyaW5nID1cbiAgTGFuZy5Qb3NpdGlvbi5jaGlsZF9wb3NpdGlvbnMgdmVydGV4LnZhbHVlXG4gIHw+IExpc3QubWFwIGRyYXdfcG9zaXRpb24gfD4gU3RyaW5nLmNvbmNhdCBcInxcIlxuXG5sZXQgZHJhd192ZXJ0ZXggKGdyYXBoIDogR3JhcGgudCkgKGN1cnNvciA6IEN1cnNvci50KSAodmVydGV4IDogVmVydGV4LnQpIDpcbiAgICBzdHJpbmcgPVxuICBsZXQgaWQgPSBVdWlkLklkLnRvX3N0cmluZyB2ZXJ0ZXguaWQgaW5cbiAgRm9ybWF0LnNwcmludGZcbiAgICB7fG4lcyBbbGFiZWw9XCJ7JXM6ICVzfHslc319XCIsIHN0eWxlPWZpbGxlZCwgZmlsbGNvbG9yPSVzLCBjb2xvcj0lc118fSBpZCBpZFxuICAgIChMYW5nLkNvbnN0cnVjdG9yLmdyYXBodml6X2xhYmVsIHZlcnRleC52YWx1ZSlcbiAgICAoZHJhd192ZXJ0ZXhfY2hpbGRyZW4gdmVydGV4KVxuICAgICh2ZXJ0ZXhfY29sb3IgZ3JhcGggY3Vyc29yIHZlcnRleClcbiAgICBDb2xvci4oXG4gICAgICBpZiBHcmFwaC5wYXJlbnRfZWRnZXMgZ3JhcGggdmVydGV4IHw+IEVkZ2UuU2V0LmNhcmRpbmFsIDwgMiB0aGVuIGJsYWNrXG4gICAgICBlbHNlIG9yYW5nZSlcblxubGV0IGRyYXdfZWRnZSAoZ3JhcGggOiBHcmFwaC50KSAobGl2ZSA6IEVkZ2UuU2V0LnQpIChlZGdlIDogRWRnZS50KSA6IHN0cmluZyA9XG4gIGxldCBzb3VyY2VfaWQgPSBVdWlkLklkLnRvX3N0cmluZyBlZGdlLnZhbHVlLnNvdXJjZS52ZXJ0ZXguaWQgaW5cbiAgbGV0IHRhcmdldF9pZCA9IFV1aWQuSWQudG9fc3RyaW5nIGVkZ2UudmFsdWUudGFyZ2V0LmlkIGluXG4gIGxldCBlZGdlX2lkID0gVXVpZC5JZC50b19zdHJpbmcgZWRnZS5pZCBpblxuICBsZXQgcG9zaXRpb24gPSBMYW5nLlBvc2l0aW9uLnNob3cgZWRnZS52YWx1ZS5zb3VyY2UucG9zaXRpb24gaW5cbiAgbGV0IGZpZWxkID0gTGFuZy5Qb3NpdGlvbi5zaG9ydF9uYW1lIGVkZ2UudmFsdWUuc291cmNlLnBvc2l0aW9uIGluXG4gIGxldCBjb2xvciA9XG4gICAgbGV0IG51bV9jb25mbGljdHMgPVxuICAgICAgRWRnZS5TZXQuKFxuICAgICAgICByZW1vdmUgZWRnZSBsaXZlXG4gICAgICAgIHw+IGZpbHRlciAoZnVuIChlIDogRWRnZS50KSAtPiBlLnZhbHVlLnNvdXJjZSA9IGVkZ2UudmFsdWUuc291cmNlKVxuICAgICAgICB8PiBjYXJkaW5hbClcbiAgICBpblxuICAgIGxldCBudW1fcGFyZW50cyA9XG4gICAgICBFZGdlLlNldC5jYXJkaW5hbCAoR3JhcGgucGFyZW50X2VkZ2VzIGdyYXBoIGVkZ2UudmFsdWUudGFyZ2V0KVxuICAgIGluXG4gICAgaWYgbnVtX2NvbmZsaWN0cyA9IDAgJiYgbnVtX3BhcmVudHMgPSAxIHRoZW4gQ29sb3IuYmxhY2tcbiAgICBlbHNlIGlmIG51bV9jb25mbGljdHMgPiAwIHRoZW4gQ29sb3IucmVkXG4gICAgZWxzZSBDb2xvci5vcmFuZ2VcbiAgaW5cbiAgRm9ybWF0LnNwcmludGZcbiAgICB7fG4lczolcyAtPiBuJXMgW2NvbG9yPSVzLGxhYmVsPVwiJXNcIixlZGdlVVJMPVwiI1wiLGVkZ2V0b29sdGlwPVwiaWQ6ICVzXFxuc291cmNlOiAlc1xcbnBvc2l0aW9uOiAlc1xcbnRhcmdldDogJXNcIixsYWJlbHRvb2x0aXA9XCJpZDogJXNcXG5zb3VyY2U6ICVzXFxucG9zaXRpb246ICVzXFxudGFyZ2V0OiAlc1wiXXx9XG4gICAgc291cmNlX2lkIGZpZWxkIHRhcmdldF9pZCBjb2xvciBlZGdlX2lkIGVkZ2VfaWQgc291cmNlX2lkIHBvc2l0aW9uIHRhcmdldF9pZFxuICAgIGVkZ2VfaWQgc291cmNlX2lkIHBvc2l0aW9uIHRhcmdldF9pZFxuXG5sZXQgbWF5YmVfZHJhd19jdXJzb3JfaG9sZSAoZ3JhcGggOiBHcmFwaC50KSAoY3Vyc29yIDogQ3Vyc29yLnQpIDpcbiAgICBzdHJpbmcgbGlzdCAqIHN0cmluZyBsaXN0ID1cbiAgaWYgRWRnZS5TZXQuaXNfZW1wdHkgKEdyYXBoLmNoaWxkX2VkZ2VzIGdyYXBoIGN1cnNvci52ZXJ0ZXggY3Vyc29yLnBvc2l0aW9uKVxuICB0aGVuXG4gICAgKCBbXG4gICAgICAgIEZvcm1hdC5zcHJpbnRmXG4gICAgICAgICAge3xob2xlIFtsYWJlbD1cIlwiLHNoYXBlPWNpcmNsZSxzdHlsZT1maWxsZWQsZmlsbGNvbG9yPSVzXXx9XG4gICAgICAgICAgQ29sb3IucHVycGxlO1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgRm9ybWF0LnNwcmludGYgXCJuJXM6JXMgLT4gaG9sZVwiXG4gICAgICAgICAgKFV1aWQuSWQudG9fc3RyaW5nIGN1cnNvci52ZXJ0ZXguaWQpXG4gICAgICAgICAgKExhbmcuUG9zaXRpb24uc2hvcnRfbmFtZSBjdXJzb3IucG9zaXRpb24pO1xuICAgICAgXSApXG4gIGVsc2UgKFtdLCBbXSlcblxubGV0IGRyYXdfZ3JhcGggKGdyYXBoIDogR3JhcGgudCkgKGN1cnNvciA6IEN1cnNvci50KSA6IHN0cmluZyA9XG4gIGxldCBub2RlcyA9XG4gICAgR3JhcGgudmVydGV4ZXMgZ3JhcGggfD4gVmVydGV4LlNldC5lbGVtZW50c1xuICAgIHw+IExpc3QubWFwIChkcmF3X3ZlcnRleCBncmFwaCBjdXJzb3IpXG4gIGluXG4gIGxldCBlZGdlcyA9XG4gICAgbGV0IGxpdmUgPSBHcmFwaC5saXZlX2VkZ2VzIGdyYXBoIGluXG4gICAgbGl2ZSB8PiBFZGdlLlNldC5lbGVtZW50cyB8PiBMaXN0Lm1hcCAoZHJhd19lZGdlIGdyYXBoIGxpdmUpXG4gIGluXG4gIGxldCBob2xlX25vZGUsIGhvbGVfZWRnZSA9IG1heWJlX2RyYXdfY3Vyc29yX2hvbGUgZ3JhcGggY3Vyc29yIGluXG4gIHt8ZGlncmFwaCBHIHtcbiAgIG5vZGUgW3NoYXBlPU1yZWNvcmQsZm9udHNpemU9MTEscmFua3NlcD0wXTtcbiAgIGVkZ2UgW2Fycm93aGVhZD12ZWUsZm9udHNpemU9MTEsd2VpZ2h0PTJdO1xuICAgcmFua2RpciA9IExSO1xuICAge3Jhbms9bWluOyBuMCBbc2hhcGU9cG9pbnRdfTtcbiAgIHx9XG4gIF4gU3RyaW5nLmNvbmNhdCBcIjtcXG5cIiAobm9kZXMgQCBob2xlX25vZGUgQCBlZGdlcyBAIGhvbGVfZWRnZSlcbiAgXiBcIn1cIlxuXG5sZXQgZHJhdyAoZWRpdG9yIDogRWRpdG9yLnQpIDogdW5pdCA9XG4gIGRyYXdfZ3JhcGggZWRpdG9yLmdyYXBoIGVkaXRvci5jdXJzb3JcbiAgfD4gU3RyaW5nLmVzY2FwZWQgfD4gSnMuZHJhd192aXogZWRpdG9yLmlkXG4iLCJtb2R1bGUgVmRvbSA9IFZpcnR1YWxfZG9tLlZkb21cbm1vZHVsZSBOb2RlID0gVmlydHVhbF9kb20uVmRvbS5Ob2RlXG5tb2R1bGUgQXR0ciA9IFZpcnR1YWxfZG9tLlZkb20uQXR0clxubW9kdWxlIEF0dHJzID0gVmlydHVhbF9kb20uVmRvbS5BdHRyc1xuXG50eXBlIGNvbnRleHQgPSB7IGluamVjdCA6IEFjdGlvbi50IC0+IHVuaXQgVmRvbS5FZmZlY3QudDsgZWRpdG9yIDogRWRpdG9yLnQgfVxuXG5sZXQgY2xpY2tzX3RvIChjdHggOiBjb250ZXh0KSAoY3Vyc29yIDogQ3Vyc29yLnQpIDogQXR0ci50ID1cbiAgQXR0ci5vbl9jbGljayAoZnVuIGV2ZW50IC0+XG4gICAgICBKcy5jbGFpbV9ldmVudCBldmVudDtcbiAgICAgIGN0eC5pbmplY3RcbiAgICAgICAgeyBBY3Rpb24uZWRpdG9yX2lkID0gY3R4LmVkaXRvci5pZDsgYWN0aW9uID0gTW92ZSAoU2VsZWN0IGN1cnNvcikgfSlcblxubGV0IHNlbGVjdGVkIChzZWxlY3Rpb24gOiBib29sIGxpc3QpIChlbGVtZW50cyA6ICdhIGxpc3QpIDogJ2EgbGlzdCA9XG4gIExpc3QuY29tYmluZSBzZWxlY3Rpb24gZWxlbWVudHMgfD4gTGlzdC5maWx0ZXIgZnN0IHw+IExpc3QubWFwIHNuZFxuXG5sZXQgc2VuZCAobW9kZWwgOiBNb2RlbC50KSAoZWRpdG9yIDogRWRpdG9yLnQpIDogQWN0aW9uLnQnIE9wdGlvbi50ID1cbiAgbWF0Y2ggSnMuZ2V0X3NlbGVjdGlvbiAoXCJhY3Rpb25zXCIgXiBVdWlkLklkLnRvX3N0cmluZyBlZGl0b3IuaWQpIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgc2VsZWN0aW9uIC0+XG4gICAgICBsZXQgYWN0aW9ucyA6IEdyYXBoX2FjdGlvbi50IGxpc3QgPVxuICAgICAgICBHcmFwaF9hY3Rpb24uU2V0LmVsZW1lbnRzIGVkaXRvci5hY3Rpb25zIHw+IHNlbGVjdGVkIHNlbGVjdGlvblxuICAgICAgaW5cbiAgICAgIGxldCBlZGl0b3JfaWRzIDogVXVpZC5JZC50IGxpc3QgPVxuICAgICAgICBVdWlkLk1hcC5iaW5kaW5ncyBtb2RlbC5lZGl0b3JzXG4gICAgICAgIHw+IExpc3QucmV2X21hcCBzbmRcbiAgICAgICAgfD4gc2VsZWN0ZWQgKEpzLmdldF9zZWxlY3Rpb24gKFwiZWRpdG9yc1wiIF4gVXVpZC5JZC50b19zdHJpbmcgZWRpdG9yLmlkKSlcbiAgICAgICAgfD4gTGlzdC5tYXAgKGZ1biAoZWRpdG9yIDogRWRpdG9yLnQpIC0+IGVkaXRvci5pZClcbiAgICAgIGluXG4gICAgICBKcy5maWxsX3NlbGVjdGlvbiAoXCJhY3Rpb25zXCIgXiBVdWlkLklkLnRvX3N0cmluZyBlZGl0b3IuaWQpO1xuICAgICAgU29tZSAoQ29tbSAoU2VuZCAoYWN0aW9ucywgZWRpdG9yX2lkcykpKVxuXG5sZXQgcmVzdG9yZSAoZWRpdG9yIDogRWRpdG9yLnQpIChkZWxldGVkIDogVmVydGV4LlNldC50KSAodmVydGV4X2lkIDogc3RyaW5nKSA6XG4gICAgQWN0aW9uLnQnIE9wdGlvbi50ID1cbiAgbGV0JW1hcC5VdGlsLk9wdGlvbiBzZWxlY3Rpb24gOiBWZXJ0ZXgudCBvcHRpb24gPVxuICAgIGlmIFN0cmluZy5lcXVhbCB2ZXJ0ZXhfaWQgXCJcIiB0aGVuXG4gICAgICBsZXQgc2VsZWN0aW9uIDogYm9vbCBsaXN0ID1cbiAgICAgICAgSnMuZ2V0X3NlbGVjdGlvbiAoXCJkZWxldGVkXCIgXiBVdWlkLklkLnRvX3N0cmluZyBlZGl0b3IuaWQpXG4gICAgICBpblxuICAgICAgbGV0IHZlcnRleGVzIDogVmVydGV4LnQgbGlzdCA9IFZlcnRleC5TZXQuZWxlbWVudHMgZGVsZXRlZCBpblxuICAgICAgTGlzdC5udGhfb3B0IChzZWxlY3RlZCBzZWxlY3Rpb24gdmVydGV4ZXMpIDBcbiAgICBlbHNlIEdyYXBoLnZlcnRleCBlZGl0b3IuZ3JhcGggKFV1aWQuSWQub2Zfc3RyaW5nIHZlcnRleF9pZClcbiAgaW5cbiAgQWN0aW9uLkVkaXQgKFJlc3RvcmUgc2VsZWN0aW9uKVxuXG5sZXQgYmFzZV9hdHRycyB+KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCkgPyhkaXNhYmxlZCA6IGJvb2wgPSBmYWxzZSlcbiAgICAoaWQgOiBzdHJpbmcgb3B0aW9uKSA6IEF0dHIudCBsaXN0ID1cbiAgKG1hdGNoIGlkIHdpdGggTm9uZSAtPiBbXSB8IFNvbWUgaWQgLT4gWyBBdHRyLmlkIGlkIF0pXG4gIEAgWyBBdHRyLmNsYXNzZXMgY2xhc3NlcyBdXG4gIEAgaWYgZGlzYWJsZWQgdGhlbiBbIEF0dHIuZGlzYWJsZWQgXSBlbHNlIFtdXG5cbmxldCBhcHBseV9hY3Rpb24gKGN0eCA6IGNvbnRleHQpIChhY3Rpb24gOiBBY3Rpb24udCcgb3B0aW9uKVxuICAgICh0YWJpbmRleGVzIDogaW50IFV1aWQuTWFwLnQpIDogdW5pdCBWZG9tLkVmZmVjdC50ID1cbiAgbWF0Y2ggYWN0aW9uIHdpdGhcbiAgfCBOb25lIC0+IFZkb20uRWZmZWN0Lklnbm9yZVxuICB8IFNvbWUgYWN0aW9uIC0+XG4gICAgICBKcy5mb2N1c1xuICAgICAgICAoXCJlZGl0b3JcIiBeIEludC50b19zdHJpbmcgKFV1aWQuTWFwLmZpbmQgY3R4LmVkaXRvci5pZCB0YWJpbmRleGVzKSk7XG4gICAgICBjdHguaW5qZWN0IHsgZWRpdG9yX2lkID0gY3R4LmVkaXRvci5pZDsgYWN0aW9uIH1cblxubGV0IHRleHRfaW5wdXQgPyhjbGFzc2VzIDogc3RyaW5nIGxpc3QgPSBbXSkgPyhkaXNhYmxlZCA6IGJvb2wgPSBmYWxzZSlcbiAgICB+KG9uX2NoYW5nZSA6IHN0cmluZyAtPiBBY3Rpb24udCcgb3B0aW9uKSAoY3R4IDogY29udGV4dCkgKGlkIDogc3RyaW5nKVxuICAgICh0YWJpbmRleGVzIDogaW50IFV1aWQuTWFwLnQpIDogTm9kZS50ID1cbiAgSnMuc2V0X2lucHV0IGlkIFwiXCI7XG4gIE5vZGUuaW5wdXRcbiAgICB+YXR0cjpcbiAgICAgIChBdHRyLm1hbnlcbiAgICAgICAgIChiYXNlX2F0dHJzIChTb21lIGlkKSB+Y2xhc3NlcyB+ZGlzYWJsZWRcbiAgICAgICAgIEAgW1xuICAgICAgICAgICAgIEF0dHIub25fY2hhbmdlIChmdW4gXyAodmFsdWUgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICAgICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBcIlwiIC0+IFZkb20uRWZmZWN0Lklnbm9yZVxuICAgICAgICAgICAgICAgICB8IHN0ciAtPiBhcHBseV9hY3Rpb24gY3R4IChvbl9jaGFuZ2Ugc3RyKSB0YWJpbmRleGVzKTtcbiAgICAgICAgICAgXSkpXG4gICAgW11cblxubGV0IGJ1dHRvbiA/KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9IFtdKSA/KGRpc2FibGVkIDogYm9vbCA9IGZhbHNlKVxuICAgIH4ob25fY2xpY2sgOiB1bml0IC0+IEFjdGlvbi50JyBvcHRpb24pIChjdHggOiBjb250ZXh0KSAobGFiZWwgOiBzdHJpbmcpXG4gICAgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudCkgOiBOb2RlLnQgPVxuICBOb2RlLmJ1dHRvblxuICAgIH5hdHRyOlxuICAgICAgKEF0dHIubWFueVxuICAgICAgICAgKGJhc2VfYXR0cnMgTm9uZSB+Y2xhc3NlcyB+ZGlzYWJsZWRcbiAgICAgICAgIEAgW1xuICAgICAgICAgICAgIEF0dHIub25fY2xpY2sgKGZ1biBfIC0+IGFwcGx5X2FjdGlvbiBjdHggKG9uX2NsaWNrICgpKSB0YWJpbmRleGVzKTtcbiAgICAgICAgICAgXSkpXG4gICAgWyBOb2RlLnRleHQgbGFiZWwgXVxuXG5sZXQgbm9uZV9idXR0b24gfihvbl9jbGljayA6IHVuaXQgLT4gdW5pdCkgKGN0eCA6IGNvbnRleHQpIChsYWJlbCA6IHN0cmluZylcbiAgICAodGFiaW5kZXhlcyA6IGludCBVdWlkLk1hcC50KSA6IE5vZGUudCA9XG4gIGJ1dHRvbiBjdHggbGFiZWwgdGFiaW5kZXhlcyB+b25fY2xpY2s6KGZ1biAoKSAtPlxuICAgICAgb25fY2xpY2sgKCk7XG4gICAgICBOb25lKVxuXG5sZXQgc29tZV9idXR0b24gPyhkaXNhYmxlZCA6IGJvb2wgPSBmYWxzZSkgKGN0eCA6IGNvbnRleHQpIChsYWJlbCA6IHN0cmluZylcbiAgICAodGFiaW5kZXhlcyA6IGludCBVdWlkLk1hcC50KSAoYWN0aW9uIDogQWN0aW9uLnQnKSA6IE5vZGUudCA9XG4gIGJ1dHRvbiBjdHggbGFiZWwgdGFiaW5kZXhlcyB+ZGlzYWJsZWQgfm9uX2NsaWNrOihmdW4gKCkgLT4gU29tZSBhY3Rpb24pXG5cbmxldCBidXR0b25fdGV4dF9pbnB1dCA/KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9IFtdKSA/KGRpc2FibGVkIDogYm9vbCBvcHRpb24pXG4gICAgfihvbl9jbGljayA6IHVuaXQgLT4gQWN0aW9uLnQnIG9wdGlvbilcbiAgICB+KG9uX2NoYW5nZSA6IHN0cmluZyAtPiBBY3Rpb24udCcgb3B0aW9uKSAoY3R4IDogY29udGV4dCkgKGxhYmVsIDogc3RyaW5nKVxuICAgIChpZCA6IHN0cmluZykgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudCkgOiBOb2RlLnQgPVxuICBsZXQgZGlzYWJsZWQgPSBPcHRpb24udmFsdWUgZGlzYWJsZWQgfmRlZmF1bHQ6ZmFsc2UgaW5cbiAgTm9kZS5kaXZcbiAgICB+YXR0cjooQXR0ci5tYW55IChiYXNlX2F0dHJzIChTb21lIGlkKSB+Y2xhc3NlcyB+ZGlzYWJsZWQpKVxuICAgIFtcbiAgICAgIGJ1dHRvbiBjdHggbGFiZWwgdGFiaW5kZXhlcyB+ZGlzYWJsZWQgfm9uX2NsaWNrO1xuICAgICAgdGV4dF9pbnB1dCBjdHggaWQgdGFiaW5kZXhlcyB+ZGlzYWJsZWQgfm9uX2NoYW5nZTtcbiAgICBdXG5cbmxldCBzb3J0ZWRfdGV4dF9pbnB1dCA/KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9IFtdKVxuICAgIH4ob25fY2hhbmdlIDogc3RyaW5nIC0+IEFjdGlvbi50JyBvcHRpb24pIChjdHggOiBjb250ZXh0KSAoaWQgOiBzdHJpbmcpXG4gICAgKHNvcnQgOiBMYW5nLlNvcnQudCkgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudCkgOiBOb2RlLnQgPVxuICBsZXQgZGlzYWJsZWQgPVxuICAgIG5vdCAoTGFuZy5Qb3NpdGlvbi5jaGlsZF9zb3J0IGN0eC5lZGl0b3IuY3Vyc29yLnBvc2l0aW9uID0gc29ydClcbiAgaW5cbiAgdGV4dF9pbnB1dCBjdHggaWQgdGFiaW5kZXhlcyB+Y2xhc3NlcyB+ZGlzYWJsZWQgfm9uX2NoYW5nZVxuXG5sZXQgc29ydGVkX2J1dHRvbiA/KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9IFtdKVxuICAgIH4ob25fY2xpY2sgOiB1bml0IC0+IEFjdGlvbi50JyBvcHRpb24pIChjdHggOiBjb250ZXh0KSAobGFiZWwgOiBzdHJpbmcpXG4gICAgKHNvcnQgOiBMYW5nLlNvcnQudCkgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudCkgOiBOb2RlLnQgPVxuICBsZXQgZGlzYWJsZWQgPVxuICAgIG5vdCAoTGFuZy5Qb3NpdGlvbi5jaGlsZF9zb3J0IGN0eC5lZGl0b3IuY3Vyc29yLnBvc2l0aW9uID0gc29ydClcbiAgaW5cbiAgYnV0dG9uIGN0eCBsYWJlbCB0YWJpbmRleGVzIH5jbGFzc2VzIH5kaXNhYmxlZCB+b25fY2xpY2tcblxubGV0IGFjdGlvbl9idXR0b24gKGN0eCA6IGNvbnRleHQpIChsYWJlbCA6IHN0cmluZykgKHNvcnQgOiBMYW5nLlNvcnQudClcbiAgICAodGFiaW5kZXhlcyA6IGludCBVdWlkLk1hcC50KSAoaWRfb3B0IDogc3RyaW5nIG9wdGlvbilcbiAgICAobWtfYWN0aW9uIDogc3RyaW5nIC0+IEFjdGlvbi50JykgOiBOb2RlLnQgPVxuICBzb3J0ZWRfYnV0dG9uIGN0eCBsYWJlbCBzb3J0IHRhYmluZGV4ZXMgfm9uX2NsaWNrOihmdW4gKCkgLT5cbiAgICAgIG1hdGNoIE9wdGlvbi5tYXAgSnMucHJvbXB0IGlkX29wdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gU29tZSAobWtfYWN0aW9uIFwiXCIpXG4gICAgICB8IFNvbWUgXCJcIiAtPiBOb25lXG4gICAgICB8IFNvbWUgc3RyIC0+XG4gICAgICAgICAgSnMuZm9jdXMgKFwiZWRpdG9yXCIgXiBPcHRpb24uZ2V0IGlkX29wdCk7XG4gICAgICAgICAgU29tZSAobWtfYWN0aW9uIHN0cikpXG5cbmxldCBzZWxlY3QgPyhjbGFzc2VzIDogc3RyaW5nIGxpc3QgPSBbXSkgPyhtdWx0aSA6IGJvb2wgPSB0cnVlKVxuICAgID8oZGVmYXVsdCA6IGJvb2wgPSBtdWx0aSkgPyhsYWJlbCA6IHN0cmluZyBvcHRpb24pIChpZCA6IHN0cmluZylcbiAgICAoaXRlbXMgOiAnYSBsaXN0KSAodmlld19pdGVtIDogJ2EgLT4gTm9kZS50IGxpc3QpIDogTm9kZS50ID1cbiAgbGV0IGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9XG4gICAgY2xhc3NlcyBAIFsgXCJzZWxlY3RJdGVtXCIgXSBAIGlmIGRlZmF1bHQgdGhlbiBbIFwic2VsZWN0ZWRcIiBdIGVsc2UgW11cbiAgaW5cbiAgbGV0IHNlbGVjdF9pdGVtIChpIDogaW50KSAoaXRlbSA6ICdhKSA6IE5vZGUudCA9XG4gICAgTm9kZS5kaXZcbiAgICAgIH5hdHRyOlxuICAgICAgICAoQXR0ci5tYW55XG4gICAgICAgICAgIChiYXNlX2F0dHJzIE5vbmUgfmNsYXNzZXMgfmRpc2FibGVkOmZhbHNlXG4gICAgICAgICAgIEAgW1xuICAgICAgICAgICAgICAgQXR0ci5vbl9jbGljayAoZnVuIF8gLT5cbiAgICAgICAgICAgICAgICAgICBpZiBtdWx0aSB0aGVuIEpzLnRvZ2dsZV9pdGVtIGlkIGkgZWxzZSBKcy5zZWxlY3RfaXRlbSBpZCBpO1xuICAgICAgICAgICAgICAgICAgIFZkb20uRWZmZWN0Lklnbm9yZSk7XG4gICAgICAgICAgICAgXSkpXG4gICAgICAodmlld19pdGVtIGl0ZW0pXG4gIGluXG4gIGxldCBjbGFzc2VzLCBoZWFkaW5nID1cbiAgICBtYXRjaCBsYWJlbCB3aXRoXG4gICAgfCBOb25lIC0+IChjbGFzc2VzLCBbXSlcbiAgICB8IFNvbWUgbGFiZWwgd2hlbiBTdHJpbmcuY29udGFpbnMgbGFiZWwgJyAnIC0+XG4gICAgICAgIChjbGFzc2VzLCBbIE5vZGUuaDEgWyBOb2RlLnRleHQgbGFiZWwgXSBdKVxuICAgIHwgU29tZSBsYWJlbCAtPiAoY2xhc3NlcyBAIFsgbGFiZWwgXSwgWyBOb2RlLmgxIFsgTm9kZS50ZXh0IGxhYmVsIF0gXSlcbiAgaW5cbiAgTm9kZS5kaXZcbiAgICB+YXR0cjooQXR0ci5tYW55IFsgQXR0ci5jbGFzc2VzIChjbGFzc2VzIEAgWyBcInNlbGVjdFwiIF0pIF0pXG4gICAgKGhlYWRpbmdcbiAgICBAIFtcbiAgICAgICAgTm9kZS5kaXZcbiAgICAgICAgICB+YXR0cjooQXR0ci5tYW55IFsgQXR0ci5pZCBpZDsgQXR0ci5jbGFzc18gXCJzZWxlY3RJdGVtc1wiIF0pXG4gICAgICAgICAgKExpc3QubWFwaSBzZWxlY3RfaXRlbSBpdGVtcyk7XG4gICAgICBdKVxuXG5sZXQgdGVsZXBvcnQgKGN0eCA6IGNvbnRleHQpIChpZCA6IHN0cmluZykgOiB1bml0IC0+IEFjdGlvbi50JyBvcHRpb24gPVxuIGZ1biAoKSAtPlxuICBtYXRjaCBKcy5wcm9tcHQgXCJlZGdlX2lkIG9yIHZlcnRleF9pZFwiIHdpdGhcbiAgfCBcIlwiIC0+IE5vbmVcbiAgfCBzdHIgLT4gKFxuICAgICAgbGV0IHRlbGVwb3J0X2lkID0gVXVpZC5JZC5vZl9zdHJpbmcgc3RyIGluXG4gICAgICBKcy5mb2N1cyAoXCJlZGl0b3JcIiBeIGlkKTtcbiAgICAgIG1hdGNoXG4gICAgICAgIEVkZ2UuU2V0LmZpbmRfZmlyc3Rfb3B0XG4gICAgICAgICAgKGZ1biBlZGdlIC0+IGVkZ2UuaWQgPSB0ZWxlcG9ydF9pZClcbiAgICAgICAgICAoR3JhcGguZWRnZXMgY3R4LmVkaXRvci5ncmFwaClcbiAgICAgIHdpdGhcbiAgICAgIHwgU29tZSBlZGdlIC0+IFNvbWUgKE1vdmUgKFNlbGVjdCBlZGdlLnZhbHVlLnNvdXJjZSkpXG4gICAgICB8IE5vbmUgLT4gKFxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBWZXJ0ZXguU2V0LmZpbmRfZmlyc3Rfb3B0XG4gICAgICAgICAgICAgIChmdW4gdmVydGV4IC0+IHZlcnRleC5pZCA9IHRlbGVwb3J0X2lkKVxuICAgICAgICAgICAgICAoR3JhcGgudmVydGV4ZXMgY3R4LmVkaXRvci5ncmFwaClcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgdmVydGV4IC0+IChcbiAgICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgICBFZGdlLlNldC5jaG9vc2Vfb3B0IChHcmFwaC5wYXJlbnRfZWRnZXMgY3R4LmVkaXRvci5ncmFwaCB2ZXJ0ZXgpXG4gICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIGVkZ2UgLT4gU29tZSAoTW92ZSAoU2VsZWN0IGVkZ2UudmFsdWUuc291cmNlKSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmUpKSlcblxubGV0IGJyZWFrIDogTm9kZS50ID0gTm9kZS5kaXYgfmF0dHI6KEF0dHIuY2xhc3NfIFwiYnJlYWtcIikgW11cblxubGV0IHBhbmVsID8oY2xhc3NlcyA6IHN0cmluZyBsaXN0ID0gW10pID8obGFiZWwgOiBzdHJpbmcgb3B0aW9uKVxuICAgIChub2RlcyA6IE5vZGUudCBsaXN0KSA6IE5vZGUudCA9XG4gIGxldCBoZWFkaW5nID1cbiAgICBtYXRjaCBsYWJlbCB3aXRoXG4gICAgfCBTb21lIGxhYmVsIC0+IFsgTm9kZS5oMSBbIE5vZGUudGV4dCBsYWJlbCBdIF1cbiAgICB8IE5vbmUgLT4gW11cbiAgaW5cbiAgTm9kZS5kaXZcbiAgICB+YXR0cjooQXR0ci5tYW55IChiYXNlX2F0dHJzIE5vbmUgfmNsYXNzZXM6KGNsYXNzZXMgQCBbIFwicGFuZWxcIiBdKSkpXG4gICAgKGhlYWRpbmcgQCBbIGJyZWFrIF0gQCBub2RlcylcblxubGV0IHNlbGVjdF9wYW5lbCA/KGNsYXNzZXMgOiBzdHJpbmcgbGlzdCA9IFtdKSA/KG11bHRpIDogYm9vbCA9IHRydWUpXG4gICAgPyhkZWZhdWx0IDogYm9vbCA9IG11bHRpKSA/KGxhYmVsIDogc3RyaW5nIG9wdGlvbikgKGlkIDogc3RyaW5nKVxuICAgIChpdGVtcyA6ICdhIGxpc3QpICh2aWV3X2l0ZW0gOiAnYSAtPiBOb2RlLnQgbGlzdCkgKG5vZGVzIDogTm9kZS50IGxpc3QpIDpcbiAgICBOb2RlLnQgPVxuICBsZXQgc2VsZWN0b3IgPVxuICAgIG1hdGNoIGxhYmVsIHdpdGhcbiAgICB8IE5vbmUgLT4gc2VsZWN0IGlkIGl0ZW1zIHZpZXdfaXRlbSB+bXVsdGkgfmRlZmF1bHRcbiAgICB8IFNvbWUgbGFiZWwgd2hlbiBTdHJpbmcuY29udGFpbnMgbGFiZWwgJyAnIC0+XG4gICAgICAgIHNlbGVjdCBpZCBpdGVtcyB2aWV3X2l0ZW0gfm11bHRpIH5kZWZhdWx0IH5sYWJlbCB+Y2xhc3Nlc1xuICAgIHwgU29tZSBsYWJlbCAtPiBzZWxlY3QgaWQgaXRlbXMgdmlld19pdGVtIH5tdWx0aSB+ZGVmYXVsdCB+bGFiZWxcbiAgaW5cbiAgTm9kZS5kaXZcbiAgICB+YXR0cjooQXR0ci5jbGFzc2VzIChjbGFzc2VzIEAgWyBcInNlbGVjdG9yXCIgXSkpXG4gICAgKFsgc2VsZWN0b3IgXSBAIFsgYnJlYWsgXSBAIG5vZGVzKVxuIiwibW9kdWxlIERvbV9odG1sID0gSnNfb2Zfb2NhbWwuRG9tX2h0bWxcbm1vZHVsZSBWZG9tID0gVmlydHVhbF9kb20uVmRvbVxuXG5sZXQgbW92ZUxSIChlZGl0b3IgOiBFZGl0b3IudCkgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudClcbiAgICAoZXZlbnQgOiBEb21faHRtbC5rZXlib2FyZEV2ZW50IEpzLnQpIChkZWx0YSA6IGludCkgOiB1bml0ID1cbiAgSnMuY2xhaW1fZXZlbnQgZXZlbnQ7XG4gIEpzLmZvY3VzXG4gICAgKFwiZWRpdG9yXCJcbiAgICBeIEludC50b19zdHJpbmdcbiAgICAgICAgKG1hdGNoIFV1aWQuTWFwLmZpbmRfb3B0IGVkaXRvci5pZCB0YWJpbmRleGVzIHdpdGhcbiAgICAgICAgfCBTb21lIHRhYmluZGV4IC0+XG4gICAgICAgICAgICBpZiB0YWJpbmRleCA9IHNuZCAoVXVpZC5NYXAubWF4X2JpbmRpbmcgdGFiaW5kZXhlcykgdGhlbiAxXG4gICAgICAgICAgICBlbHNlIHRhYmluZGV4ICsgZGVsdGFcbiAgICAgICAgfCBOb25lIC0+IDEpKVxuXG5sZXQgY3RybCAobW9kZWwgOiBNb2RlbC50KSAoZWRpdG9yIDogRWRpdG9yLnQpICh0YWJpbmRleGVzIDogaW50IFV1aWQuTWFwLnQpXG4gICAgKGV2ZW50IDogRG9tX2h0bWwua2V5Ym9hcmRFdmVudCBKcy50KSA6IEFjdGlvbi50JyBPcHRpb24udCA9XG4gIG1hdGNoIERvbV9odG1sLktleWJvYXJkX2NvZGUub2ZfZXZlbnQgZXZlbnQgd2l0aFxuICB8IEtleVMgLT4gKFxuICAgICAgbWF0Y2ggR3VpLnNlbmQgbW9kZWwgZWRpdG9yIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIEpzLmNsYWltX2V2ZW50IGV2ZW50O1xuICAgICAgICAgIE5vbmVcbiAgICAgIHwgcmVzdWx0IC0+IHJlc3VsdClcbiAgfCBrZXkgLT4gKFxuICAgICAgbWF0Y2gga2V5IHdpdGhcbiAgICAgIHwgQXJyb3dSaWdodCAtPlxuICAgICAgICAgIG1vdmVMUiBlZGl0b3IgdGFiaW5kZXhlcyBldmVudCAxO1xuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQXJyb3dMZWZ0IC0+XG4gICAgICAgICAgbW92ZUxSIGVkaXRvciB0YWJpbmRleGVzIGV2ZW50ICgtMSk7XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBfIC0+IE5vbmUpXG5cbmxldCBzaGlmdCAoZXZlbnQgOiBEb21faHRtbC5rZXlib2FyZEV2ZW50IEpzLnQpIDogQWN0aW9uLnQnIE9wdGlvbi50ID1cbiAgbGV0JWJpbmQuVXRpbC5PcHRpb24ganN0ciA6IEpzLmpzX3N0cmluZyBKcy50IE9wdGlvbi50ID1cbiAgICBKcy5PcHRkZWYudG9fb3B0aW9uIGV2ZW50IyMua2V5XG4gIGluXG4gIG1hdGNoIEpzLnRvX3N0cmluZyBqc3RyIHdpdGhcbiAgfCBcIk5cIiAtPiBTb21lIChBY3Rpb24uRWRpdCAoQ3JlYXRlIFR5cF9udW0pKVxuICB8IFwiK1wiIC0+IFNvbWUgKEFjdGlvbi5FZGl0IChDcmVhdGUgRXhwX3BsdXMpKVxuICB8IFwiKlwiIC0+IFNvbWUgKEFjdGlvbi5FZGl0IChDcmVhdGUgRXhwX3RpbWVzKSlcbiAgfCBcIj5cIiAtPiBTb21lIChBY3Rpb24uRWRpdCAoQ3JlYXRlIFR5cF9hcnJvdykpXG4gIHwgXyAtPiBOb25lXG5cbmxldCBiYXNlIChlZGl0b3IgOiBFZGl0b3IudCkgKGV2ZW50IDogRG9tX2h0bWwua2V5Ym9hcmRFdmVudCBKcy50KSA6XG4gICAgQWN0aW9uLnQnIE9wdGlvbi50ID1cbiAgbGV0IGlkID0gVXVpZC5JZC50b19zdHJpbmcgZWRpdG9yLmlkIGluXG4gIG1hdGNoIERvbV9odG1sLktleWJvYXJkX2NvZGUub2ZfZXZlbnQgZXZlbnQgd2l0aFxuICB8IEtleU4gLT4gKFxuICAgICAgbWF0Y2ggSnMucHJvbXB0IFwibnVtX2lkXCIgd2l0aFxuICAgICAgfCBcIlwiIC0+XG4gICAgICAgICAgSnMuY2xhaW1fZXZlbnQgZXZlbnQ7XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBzdHIgLT5cbiAgICAgICAgICBKcy5mb2N1cyAoXCJlZGl0b3JcIiBeIGlkKTtcbiAgICAgICAgICBTb21lIChBY3Rpb24uRWRpdCAoQ3JlYXRlIChFeHBfbnVtIChpbnRfb2Zfc3RyaW5nIHN0cikpKSkpXG4gIHwgS2V5UCAtPiAoXG4gICAgICBtYXRjaCBKcy5wcm9tcHQgXCJwYXRfaWRcIiB3aXRoXG4gICAgICB8IFwiXCIgLT5cbiAgICAgICAgICBKcy5jbGFpbV9ldmVudCBldmVudDtcbiAgICAgICAgICBOb25lXG4gICAgICB8IHN0ciAtPlxuICAgICAgICAgIEpzLmZvY3VzIChcImVkaXRvclwiIF4gaWQpO1xuICAgICAgICAgIFNvbWUgKEVkaXQgKENyZWF0ZSAoUGF0X3ZhciBzdHIpKSkpXG4gIHwgS2V5ViAtPiAoXG4gICAgICBtYXRjaCBKcy5wcm9tcHQgXCJ2YXJfaWRcIiB3aXRoXG4gICAgICB8IFwiXCIgLT5cbiAgICAgICAgICBKcy5jbGFpbV9ldmVudCBldmVudDtcbiAgICAgICAgICBOb25lXG4gICAgICB8IHN0ciAtPlxuICAgICAgICAgIEpzLmZvY3VzIChcImVkaXRvclwiIF4gaWQpO1xuICAgICAgICAgIFNvbWUgKEVkaXQgKENyZWF0ZSAoRXhwX3ZhciBzdHIpKSkpXG4gIHwgU3BhY2UgLT4gU29tZSAoRWRpdCAoQ3JlYXRlIEV4cF9hcHApKVxuICB8IEJhY2tzbGFzaCAtPiBTb21lIChFZGl0IChDcmVhdGUgRXhwX2xhbSkpXG4gIHwgRGVsZXRlIC0+XG4gICAgICBKcy5jbGVhcl9zZWxlY3Rpb24gKFwiZGVsZXRlZFwiIF4gaWQpO1xuICAgICAgU29tZSAoRWRpdCBEZXN0cm95KVxuICB8IEFycm93VXAgLT4gU29tZSAoTW92ZSBVcClcbiAgfCBBcnJvd0Rvd24gLT4gU29tZSAoTW92ZSBEb3duKVxuICB8IEFycm93TGVmdCAtPiBTb21lIChNb3ZlIExlZnQpXG4gIHwgQXJyb3dSaWdodCAtPiBTb21lIChNb3ZlIFJpZ2h0KVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgZGlzcGF0Y2ggfihpbmplY3QgOiBBY3Rpb24udCAtPiB1bml0IFZkb20uRWZmZWN0LnQpIChtb2RlbCA6IE1vZGVsLnQpXG4gICAgKGVkaXRvciA6IEVkaXRvci50KSAodGFiaW5kZXhlcyA6IGludCBVdWlkLk1hcC50KVxuICAgIChldmVudCA6IERvbV9odG1sLmtleWJvYXJkRXZlbnQgSnMudCkgOiB1bml0IFZkb20uRWZmZWN0LnQgPVxuICBsZXQgaGFuZGxlID1cbiAgICBtYXRjaCBKcy4odG9fYm9vbCBldmVudCMjLnNoaWZ0S2V5LCB0b19ib29sIGV2ZW50IyMuY3RybEtleSkgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IGJhc2UgZWRpdG9yXG4gICAgfCB0cnVlLCBmYWxzZSAtPiBzaGlmdFxuICAgIHwgZmFsc2UsIHRydWUgLT4gY3RybCBtb2RlbCBlZGl0b3IgdGFiaW5kZXhlc1xuICAgIHwgXywgXyAtPiAoIGZ1biBfIDogQWN0aW9uLnQnIE9wdGlvbi50IC0+IE5vbmUpXG4gIGluXG4gIG1hdGNoIGhhbmRsZSBldmVudCB3aXRoXG4gIHwgU29tZSBhY3Rpb24gLT5cbiAgICAgIEpzLmNsYWltX2V2ZW50IGV2ZW50O1xuICAgICAgSnMuZm9jdXMgKFwiZWRpdG9yXCIgXiBVdWlkLklkLnRvX3N0cmluZyBlZGl0b3IuaWQpO1xuICAgICAgaW5qZWN0IHsgZWRpdG9yX2lkID0gZWRpdG9yLmlkOyBhY3Rpb24gfVxuICB8IE5vbmUgLT4gVmRvbS5FZmZlY3QuSWdub3JlXG4iLCJtb2R1bGUgVmRvbSA9IFZpcnR1YWxfZG9tLlZkb21cbm1vZHVsZSBOb2RlID0gVmlydHVhbF9kb20uVmRvbS5Ob2RlXG5tb2R1bGUgQXR0ciA9IFZpcnR1YWxfZG9tLlZkb20uQXR0clxuXG4oKiBWZG9tIE5vZGUgQ29uc3RydWN0b3JzICopXG5cbmxldCBjaGFycyAoc3RyIDogc3RyaW5nKSA6IE5vZGUudCA9XG4gIE5vZGUuc3BhbiB+YXR0cjooQXR0ci5tYW55IFsgQXR0ci5jbGFzc18gXCJjaGFyc1wiIF0pIFsgTm9kZS50ZXh0IHN0ciBdXG5cbmxldCBlcnJzIChzdHIgOiBzdHJpbmcpIDogTm9kZS50ID1cbiAgTm9kZS5zcGFuIH5hdHRyOihBdHRyLm1hbnkgWyBBdHRyLmNsYXNzXyBcImVycnNcIiBdKSBbIE5vZGUudGV4dCBzdHIgXVxuXG5sZXQgcGFyZW50aGVzaXplZCAobm9kZSA6IE5vZGUudCkgOiBOb2RlLnQgPVxuICBOb2RlLnNwYW4gWyBjaGFycyBcIihcIjsgbm9kZTsgY2hhcnMgXCIpXCIgXVxuXG5sZXQgY3Vyc29yX25vZGUgKG5vZGUgOiBOb2RlLnQpIDogTm9kZS50ID1cbiAgTm9kZS5zcGFuIH5hdHRyOihBdHRyLmNsYXNzXyBcImN1cnNvclwiKSBbIG5vZGUgXVxuXG5sZXQgbWF5YmVfY3Vyc29yX25vZGUgKGVkaXRvciA6IEVkaXRvci50KSAocGFyZW50IDogQ3Vyc29yLnQpIChub2RlIDogTm9kZS50KSA6XG4gICAgTm9kZS50ID1cbiAgaWYgcGFyZW50ID0gZWRpdG9yLmN1cnNvciB0aGVuIGN1cnNvcl9ub2RlIG5vZGUgZWxzZSBub2RlXG5cbmxldCByZWZfbm9kZSAoY3R4IDogR3VpLmNvbnRleHQpIChwYXJlbnQgOiBDdXJzb3IudCkgKGlkIDogVXVpZC5JZC50KSA6IE5vZGUudCA9XG4gIE5vZGUuc3BhblxuICAgIH5hdHRyOihBdHRyLm1hbnkgWyBBdHRyLmNsYXNzXyBcInZlcnRleFwiOyBHdWkuY2xpY2tzX3RvIGN0eCBwYXJlbnQgXSlcbiAgICBbIE5vZGUudGV4dCAoXCIjXCIgXiBVdWlkLklkLnRvX3N0cmluZyBpZCkgXVxuXG5sZXQgaG9sZV9ub2RlIChjdHggOiBHdWkuY29udGV4dCkgKHBhcmVudCA6IEN1cnNvci50KSA6IE5vZGUudCA9XG4gIE5vZGUuc3BhblxuICAgIH5hdHRyOihBdHRyLm1hbnkgWyBBdHRyLmNsYXNzXyBcImhvbGVcIjsgR3VpLmNsaWNrc190byBjdHggcGFyZW50IF0pXG4gICAgWyBjaGFycyBcIuKWoVwiIF1cblxubGV0IHJlYyB0cmVlX25vZGUgPyhwYXJlbnQgOiBDdXJzb3IudCA9IEN1cnNvci5yb290KSA/KGF0X3RvcCA6IGJvb2wgPSB0cnVlKVxuICAgIChjdHggOiBHdWkuY29udGV4dCkgKHRyZWUgOiBUcmVlLnQpIDogTm9kZS50ID1cbiAgKG1hdGNoIHRyZWUgd2l0aFxuICB8IFJlZiB2ZXJ0ZXggLT4gcmVmX25vZGUgY3R4IHBhcmVudCB2ZXJ0ZXguaWRcbiAgfCBWZXJ0ZXggKHZlcnRleCwgY2hpbGRyZW4pIC0+IHZlcnRleF9ub2RlIGN0eCBwYXJlbnQgdmVydGV4IGNoaWxkcmVuIGF0X3RvcClcbiAgfD4gbWF5YmVfY3Vyc29yX25vZGUgY3R4LmVkaXRvciBwYXJlbnRcblxuYW5kIHZlcnRleF9ub2RlIChjdHggOiBHdWkuY29udGV4dCkgKHBhcmVudCA6IEN1cnNvci50KSAodmVydGV4IDogVmVydGV4LnQpXG4gICAgKGNoaWxkcmVuIDogVHJlZS5jaGlsZHJlbiBQb3NpdGlvbl9tYXAudCkgKGF0X3RvcCA6IGJvb2wpIDogTm9kZS50ID1cbiAgbGV0IG5vZGUgPVxuICAgIE5vZGUuc3BhbiB+YXR0cjooR3VpLmNsaWNrc190byBjdHggcGFyZW50KVxuICAgICAgKExhbmcuc2hvdyBjaGFycyBjaGFyc1xuICAgICAgICAgKGZ1biBwb3NpdGlvbiAtPlxuICAgICAgICAgICBtYXRjaCBQb3NpdGlvbl9tYXAuZ2V0IHBvc2l0aW9uIGNoaWxkcmVuIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgaG9sZV9ub2RlIGN0eCB7IHZlcnRleDsgcG9zaXRpb24gfVxuICAgICAgICAgICAgICAgfD4gbWF5YmVfY3Vyc29yX25vZGUgY3R4LmVkaXRvciB7IHZlcnRleDsgcG9zaXRpb24gfVxuICAgICAgICAgICB8IFsgeyB0cmVlOyBfIH0gXSAtPlxuICAgICAgICAgICAgICAgbGV0IGF0X3RvcCA9IHZlcnRleC52YWx1ZSA9IEV4cF9sYW0gaW5cbiAgICAgICAgICAgICAgIHRyZWVfbm9kZSBjdHggdHJlZSB+YXRfdG9wIH5wYXJlbnQ6eyB2ZXJ0ZXg7IHBvc2l0aW9uIH1cbiAgICAgICAgICAgfCBjaGlsZF9zcGVjcyAtPlxuICAgICAgICAgICAgICAgY29uZmxpY3Rfbm9kZSBjdHggQ3Vyc29yLnsgdmVydGV4OyBwb3NpdGlvbiB9IGNoaWxkX3NwZWNzKVxuICAgICAgICAgdmVydGV4LnZhbHVlKVxuICBpblxuICBsZXQgZGVjb3JhdGVkX25vZGUgPVxuICAgIGlmIGN0eC5lZGl0b3Iuc2hvd19pZHMgJiYgbm90ICh2ZXJ0ZXggPSBWZXJ0ZXgucm9vdCkgdGhlblxuICAgICAgTm9kZS5zcGFuIH5hdHRyOihBdHRyLmNsYXNzXyBcInZlcnRleFwiKVxuICAgICAgICBbXG4gICAgICAgICAgTm9kZS5jcmVhdGUgXCJzdWJcIiBbIE5vZGUudGV4dCAoVXVpZC5JZC50b19zdHJpbmcgdmVydGV4LmlkIF4gXCIoXCIpIF07XG4gICAgICAgICAgbm9kZTtcbiAgICAgICAgICBOb2RlLmNyZWF0ZSBcInN1YlwiIFsgTm9kZS50ZXh0IFwiKVwiIF07XG4gICAgICAgIF1cbiAgICBlbHNlIE5vZGUuc3BhbiB+YXR0cjooQXR0ci5jbGFzc18gXCJ2ZXJ0ZXhcIikgWyBub2RlIF1cbiAgaW5cbiAgaWYgYXRfdG9wIHx8IHBhcmVudC5wb3NpdGlvbiA9IFJvb3Rfcm9vdF9yb290IHRoZW4gZGVjb3JhdGVkX25vZGVcbiAgZWxzZVxuICAgIG1hdGNoIHZlcnRleC52YWx1ZSB3aXRoXG4gICAgfCBFeHBfbGFtIHwgRXhwX2FwcCB8IEV4cF9wbHVzIHwgRXhwX3RpbWVzIHwgVHlwX2Fycm93IC0+XG4gICAgICAgIHBhcmVudGhlc2l6ZWQgZGVjb3JhdGVkX25vZGVcbiAgICB8IF8gLT4gZGVjb3JhdGVkX25vZGVcblxuYW5kIGNvbmZsaWN0X25vZGUgKGN0eCA6IEd1aS5jb250ZXh0KSAocGFyZW50IDogQ3Vyc29yLnQpXG4gICAgKGNoaWxkX3NwZWNzIDogVHJlZS5jaGlsZHJlbikgOiBOb2RlLnQgPVxuICBsZXQgbm9kZXMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChjaGlsZCA6IFRyZWUuY2hpbGQpIC0+IHRyZWVfbm9kZSBjdHggY2hpbGQudHJlZSB+cGFyZW50KVxuICAgICAgY2hpbGRfc3BlY3NcbiAgaW5cbiAgTm9kZS5zcGFuXG4gICAgfmF0dHI6KEF0dHIubWFueSBbIEF0dHIuY2xhc3NfIFwiY29uZmxpY3RcIjsgR3VpLmNsaWNrc190byBjdHggcGFyZW50IF0pXG4gICAgKFsgZXJycyBcInsgXCIgXSBAIFV0aWwuTGlzdC5pbnRlcnNwZXJzZSAoZXJycyBcIiB8IFwiKSBub2RlcyBAIFsgZXJycyBcIiB9XCIgXSlcbiAgfD4gbWF5YmVfY3Vyc29yX25vZGUgY3R4LmVkaXRvciBwYXJlbnRcblxuKCogUGFuZWxzICopXG5cbmxldCBjdXJzb3JfcGFuZWwgKGN0eCA6IEd1aS5jb250ZXh0KSA6IE5vZGUudCA9XG4gIEd1aS5wYW5lbCB+bGFiZWw6XCJDdXJzb3JcIiBbIGNoYXJzIChDdXJzb3IudG9fc3RyaW5nIGN0eC5lZGl0b3IuY3Vyc29yKSBdXG5cbmxldCBncmFwaF9wYW5lbCAoY3R4IDogR3VpLmNvbnRleHQpIChpZCA6IHN0cmluZykgKHRhYmluZGV4ZXMgOiBpbnQgVXVpZC5NYXAudClcbiAgICA6IE5vZGUudCA9XG4gIEd1aS5wYW5lbCB+bGFiZWw6XCJHcmFwaFwiXG4gICAgW1xuICAgICAgTm9kZS5kaXYgfmF0dHI6KEF0dHIuaWQgKFwiZ3JhcGhcIiBeIGlkKSkgWyBOb2RlLnNwYW4gW10gXTtcbiAgICAgIEd1aS5icmVhaztcbiAgICAgIE5vZGUuZGl2XG4gICAgICAgIFtcbiAgICAgICAgICBHdWkuYnV0dG9uIGN0eCBcIkRyb3AgRWRnZVwiIHRhYmluZGV4ZXMgfm9uX2NsaWNrOihmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggSnMucHJvbXB0IFwiZWRnZV9pZFwiIHdpdGhcbiAgICAgICAgICAgICAgfCBcIlwiIC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBzdHIgLT4gU29tZSAoRWRpdCAoRHJvcEVkZ2UgKFV1aWQuSWQub2Zfc3RyaW5nIHN0cikpKSk7XG4gICAgICAgICAgR3VpLm5vbmVfYnV0dG9uIGN0eCBcIlNob3cgU291cmNlXCIgdGFiaW5kZXhlcyB+b25fY2xpY2s6KGZ1biAoKSAtPlxuICAgICAgICAgICAgICBGb3JtYXQucHJpbnRmIFwiJXNcXG4lIVwiXG4gICAgICAgICAgICAgICAgKEdyYXBodml6LmRyYXdfZ3JhcGggY3R4LmVkaXRvci5ncmFwaCBjdHguZWRpdG9yLmN1cnNvcikpO1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJUb2dnbGUgSURzXCIgdGFiaW5kZXhlc1xuICAgICAgICAgICAgKEVudiAoVG9nZ2xlSWRzIGN0eC5lZGl0b3IuaWQpKTtcbiAgICAgICAgXTtcbiAgICBdXG5cbmxldCBhY3Rpb25zX3BhbmVsIChjdHggOiBHdWkuY29udGV4dCkgKGlkIDogc3RyaW5nKSA6IE5vZGUudCA9XG4gIEd1aS5zZWxlY3RfcGFuZWwgfmxhYmVsOlwiQWN0aW9uc1wiIH5tdWx0aTp0cnVlIChcImFjdGlvbnNcIiBeIGlkKVxuICAgIChHcmFwaF9hY3Rpb24uU2V0LmVsZW1lbnRzIGN0eC5lZGl0b3IuYWN0aW9ucylcbiAgICAoZnVuIGdyYXBoX2FjdGlvbiAtPiBbIGNoYXJzIChHcmFwaF9hY3Rpb24udG9fc3RyaW5nIGdyYXBoX2FjdGlvbikgXSlcbiAgICBbXVxuXG5sZXQgc2VuZF9hY3Rpb25zX3BhbmVsIChtb2RlbCA6IE1vZGVsLnQpIChjdHggOiBHdWkuY29udGV4dCkgKGlkIDogc3RyaW5nKVxuICAgICh0YWJpbmRleGVzIDogaW50IFV1aWQuTWFwLnQpIDogTm9kZS50ID1cbiAgR3VpLnNlbGVjdF9wYW5lbCB+bGFiZWw6XCJTZW5kIHRvIEVkaXRvcnNcIiB+bXVsdGk6dHJ1ZSB+Y2xhc3NlczpbIFwiRWRpdG9yc1wiIF1cbiAgICAoXCJlZGl0b3JzXCIgXiBpZClcbiAgICAoTGlzdC5yZXZfbWFwIGZzdCAoVXVpZC5NYXAuYmluZGluZ3MgbW9kZWwuZWRpdG9ycykpXG4gICAgKGZ1biBlZGl0b3JfaWQgLT4gWyBOb2RlLnRleHQgKFV1aWQuSWQudG9fc3RyaW5nIGVkaXRvcl9pZCkgXSlcbiAgICBbXG4gICAgICBHdWkuYnV0dG9uIGN0eCBcIlNlbmQgKGN0cmwtcylcIiB0YWJpbmRleGVzIH5vbl9jbGljazooZnVuICgpIC0+XG4gICAgICAgICAgR3VpLnNlbmQgbW9kZWwgY3R4LmVkaXRvcik7XG4gICAgICBHdWkubm9uZV9idXR0b24gY3R4IFwiQWxsXCIgdGFiaW5kZXhlcyB+b25fY2xpY2s6KGZ1biAoKSAtPlxuICAgICAgICAgIEpzLmZpbGxfc2VsZWN0aW9uIChcImVkaXRvcnNcIiBeIGlkKSk7XG4gICAgICBHdWkubm9uZV9idXR0b24gY3R4IFwiTm9uZVwiIHRhYmluZGV4ZXMgfm9uX2NsaWNrOihmdW4gKCkgLT5cbiAgICAgICAgICBKcy5jbGVhcl9zZWxlY3Rpb24gKFwiZWRpdG9yc1wiIF4gaWQpKTtcbiAgICBdXG5cbmxldCBtdWx0aXBhcmVudGVkX3BhbmVsIChjdHggOiBHdWkuY29udGV4dCkgKGlkIDogc3RyaW5nKSAobXAgOiBUcmVlLnQgbGlzdClcbiAgICAoY2hpbGRyZW4gOiBFZGdlLlNldC50IFZlcnRleC5NYXAudCkgOiBOb2RlLnQgPVxuICAoKiBUT0RPOiBmaXggYnVnZ3kgY3Vyc29yIGluc2lkZSBNdWx0aXBhcmVudGVkIGJveCAqKVxuICBHdWkuc2VsZWN0X3BhbmVsIH5sYWJlbDpcIk11bHRpcGFyZW50ZWRcIiB+bXVsdGk6ZmFsc2UgKFwibXVsdGlwYXJlbnRcIiBeIGlkKSBtcFxuICAgIChmdW4gdHJlZSAtPlxuICAgICAgbGV0IHZlcnRleCA9IG1hdGNoIHRyZWUgd2l0aCBSZWYgdiB8IFZlcnRleCAodiwgXykgLT4gdiBpblxuICAgICAgdHJlZV9ub2RlIGN0eCB0cmVlXG4gICAgICA6OiAoR3JhcGgucGFyZW50X3ZlcnRleGVzIGN0eC5lZGl0b3IuZ3JhcGggdmVydGV4XG4gICAgICAgICB8PiBWZXJ0ZXguU2V0LmVsZW1lbnRzXG4gICAgICAgICB8PiBMaXN0Lm1hcCAoZnVuIHBhcmVudF92ZXJ0ZXggLT5cbiAgICAgICAgICAgICAgICBHcm92ZS50cmF2ZXJzZV92ZXJ0ZXggcGFyZW50X3ZlcnRleCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgfnNlZW46KFZlcnRleC5TZXQuc2luZ2xldG9uIHZlcnRleClcbiAgICAgICAgICAgICAgICB8PiAoZnVuY3Rpb24gdHJlZSwgXywgXyAtPiB0cmVlKVxuICAgICAgICAgICAgICAgIHw+IHRyZWVfbm9kZSBjdHgpKSlcbiAgICBbXVxuXG5sZXQgZGVsZXRlZF9wYW5lbCAoY3R4IDogR3VpLmNvbnRleHQpIChpZCA6IHN0cmluZylcbiAgICAodGFiaW5kZXhlcyA6IGludCBVdWlkLk1hcC50KSAoZGVsZXRlZCA6IFRyZWUudCBsaXN0KSA6IE5vZGUudCA9XG4gIGxldCBkID1cbiAgICBMaXN0Lm1hcCBUcmVlLihmdW5jdGlvbiBWZXJ0ZXggKHYsIF8pIHwgUmVmIHYgLT4gdikgZGVsZXRlZFxuICAgIHw+IFZlcnRleC5TZXQub2ZfbGlzdFxuICBpblxuICBHdWkuc2VsZWN0X3BhbmVsIH5sYWJlbDpcIkRlbGV0ZWRcIiB+bXVsdGk6ZmFsc2UgKFwiZGVsZXRlZFwiIF4gaWQpIGRlbGV0ZWRcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgKFZlcnRleCAodmVydGV4LCBfKSB8IFJlZiB2ZXJ0ZXgpIGFzIHRyZWUgLT5cbiAgICAgICAgICBbXG4gICAgICAgICAgICB0cmVlX25vZGUgY3R4IHRyZWVcbiAgICAgICAgICAgICAgfnBhcmVudDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIE9wdGlvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIChMYW5nLlBvc2l0aW9uLmRlZmF1bHRfcG9zaXRpb24gdmVydGV4LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgIH5kZWZhdWx0OkxhbmcuUG9zaXRpb24uUm9vdF9yb290X3Jvb3Q7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICBdKVxuICAgIFtcbiAgICAgIChKcy5zZXRfaW5wdXQgKFwicmVzdG9yZVwiIF4gaWQpIFwiXCI7XG4gICAgICAgR3VpLnBhbmVsXG4gICAgICAgICBbXG4gICAgICAgICAgIEd1aS5idXR0b24gY3R4IFwiUmVzdG9yZVwiIHRhYmluZGV4ZXMgfm9uX2NsaWNrOihmdW4gKCkgLT5cbiAgICAgICAgICAgICAgIEd1aS5yZXN0b3JlIGN0eC5lZGl0b3IgZCAoSnMuZ2V0X2lucHV0IChcInJlc3RvcmVcIiBeIGlkKSkpO1xuICAgICAgICAgICBHdWkudGV4dF9pbnB1dCBjdHggKFwicmVzdG9yZVwiIF4gaWQpIHRhYmluZGV4ZXMgfm9uX2NoYW5nZTooZnVuIHN0ciAtPlxuICAgICAgICAgICAgICAgR3VpLnJlc3RvcmUgY3R4LmVkaXRvciBkIHN0cik7XG4gICAgICAgICBdKTtcbiAgICBdXG5cbmxldCB1bmljeWNsZXNfcGFuZWwgKGN0eCA6IEd1aS5jb250ZXh0KSAoaWQgOiBzdHJpbmcpIChzYyA6IFRyZWUudCBsaXN0KSA6XG4gICAgTm9kZS50ID1cbiAgR3VpLnNlbGVjdF9wYW5lbCB+bGFiZWw6XCJVbmljeWNsZXNcIiB+bXVsdGk6ZmFsc2UgKFwidW5pY3ljbGVzXCIgXiBpZCkgc2NcbiAgICAoZnVuIHRyZWUgLT4gWyB0cmVlX25vZGUgY3R4IHRyZWUgXSlcbiAgICBbXVxuXG4oKiBWaWV3cyAqKVxuXG5sZXQgdmlld19lZGl0b3IgKG1vZGVsIDogTW9kZWwudCkgKGN0eCA6IEd1aS5jb250ZXh0KVxuICAgICh0YWJpbmRleGVzIDogaW50IFV1aWQuTWFwLnQpIDogTm9kZS50ID1cbiAgbGV0IGlkIDogc3RyaW5nID0gVXVpZC5JZC50b19zdHJpbmcgY3R4LmVkaXRvci5pZCBpblxuICBsZXQgZGVjb21wLCBjaGlsZHJlbiA9IEdyb3ZlLmRlY29tcG9zZSBjdHguZWRpdG9yLmdyYXBoIGluXG4gIEdyYXBodml6LmRyYXcgY3R4LmVkaXRvcjtcbiAgTm9kZS5kaXZcbiAgICB+YXR0cjpcbiAgICAgIChBdHRyLm1hbnlcbiAgICAgICAgIFtcbiAgICAgICAgICAgQXR0ci5pZCAoXCJlZGl0b3JcIiBeIGlkKTtcbiAgICAgICAgICAgQXR0ci5jbGFzc18gXCJlZGl0b3JcIjtcbiAgICAgICAgICAgQXR0ci5jcmVhdGUgXCJ0YWJpbmRleFwiXG4gICAgICAgICAgICAgKEludC50b19zdHJpbmcgKFV1aWQuTWFwLmZpbmQgY3R4LmVkaXRvci5pZCB0YWJpbmRleGVzKSk7XG4gICAgICAgICAgIEF0dHIub25fa2V5ZG93blxuICAgICAgICAgICAgIChLZXkuZGlzcGF0Y2ggbW9kZWwgY3R4LmVkaXRvciB0YWJpbmRleGVzIH5pbmplY3Q6Y3R4LmluamVjdCk7XG4gICAgICAgICBdKVxuICAgIFtcbiAgICAgICgqIE1BSU4gQ09ERSBWSUVXICopXG4gICAgICB0cmVlX25vZGUgY3R4IGRlY29tcC5yZWFjaGFibGU7XG4gICAgICAoKiAtLS0tLS0tLS0tLS0tLSAqKVxuICAgICAgR3VpLmJyZWFrO1xuICAgICAgY3Vyc29yX3BhbmVsIGN0eDtcbiAgICAgIGdyYXBoX3BhbmVsIGN0eCBpZCB0YWJpbmRleGVzO1xuICAgICAgTm9kZS5kaXYgfmF0dHI6KEF0dHIuY2xhc3NfIFwic2VsZWN0b3JzXCIpXG4gICAgICAgIFtcbiAgICAgICAgICBhY3Rpb25zX3BhbmVsIGN0eCBpZDtcbiAgICAgICAgICBzZW5kX2FjdGlvbnNfcGFuZWwgbW9kZWwgY3R4IGlkIHRhYmluZGV4ZXM7XG4gICAgICAgICAgbXVsdGlwYXJlbnRlZF9wYW5lbCBjdHggaWQgZGVjb21wLm11bHRpcGFyZW50ZWQgY2hpbGRyZW47XG4gICAgICAgICAgZGVsZXRlZF9wYW5lbCBjdHggaWQgdGFiaW5kZXhlcyBkZWNvbXAuZGVsZXRlZDtcbiAgICAgICAgICB1bmljeWNsZXNfcGFuZWwgY3R4IGlkIGRlY29tcC53cmVhdGhzO1xuICAgICAgICBdO1xuICAgICAgR3VpLnBhbmVsIH5sYWJlbDpcIlBhdHRlcm5zIGFuZCBFeHByZXNzaW9uc1wiXG4gICAgICAgIFtcbiAgICAgICAgICBHdWkuYWN0aW9uX2J1dHRvbiBjdHggXCJQYXQgKHApXCIgTGFuZy5Tb3J0LlBhdCB0YWJpbmRleGVzXG4gICAgICAgICAgICAoU29tZSBcInBhdF9pZFwiKSAoZnVuIHN0ciAtPiBFZGl0IChDcmVhdGUgKEV4cF92YXIgc3RyKSkpO1xuICAgICAgICAgIEd1aS5hY3Rpb25fYnV0dG9uIGN0eCBcIlZhciAodilcIiBMYW5nLlNvcnQuRXhwIHRhYmluZGV4ZXNcbiAgICAgICAgICAgIChTb21lIFwidmFyX2lkXCIpIChmdW4gc3RyIC0+IEVkaXQgKENyZWF0ZSAoRXhwX3ZhciBzdHIpKSk7XG4gICAgICAgICAgR3VpLmFjdGlvbl9idXR0b24gY3R4IFwiTnVtIChuKVwiIExhbmcuU29ydC5FeHAgdGFiaW5kZXhlc1xuICAgICAgICAgICAgKFNvbWUgXCJudW1faWRcIikgKGZ1biBzdHIgLT5cbiAgICAgICAgICAgICAgRWRpdCAoQ3JlYXRlIChFeHBfbnVtIChpbnRfb2Zfc3RyaW5nIHN0cikpKSk7XG4gICAgICAgICAgR3VpLmFjdGlvbl9idXR0b24gY3R4IFwiTGFtIChcXFxcKVwiIExhbmcuU29ydC5FeHAgdGFiaW5kZXhlcyBOb25lXG4gICAgICAgICAgICAoZnVuIF8gLT4gRWRpdCAoQ3JlYXRlIEV4cF9sYW0pKTtcbiAgICAgICAgICBHdWkuYWN0aW9uX2J1dHRvbiBjdHggXCJBcHAgKHNwYWNlKVwiIExhbmcuU29ydC5FeHAgdGFiaW5kZXhlcyBOb25lXG4gICAgICAgICAgICAoZnVuIF8gLT4gRWRpdCAoQ3JlYXRlIEV4cF9hcHApKTtcbiAgICAgICAgICBHdWkuYWN0aW9uX2J1dHRvbiBjdHggXCJQbHVzICgrKVwiIExhbmcuU29ydC5FeHAgdGFiaW5kZXhlcyBOb25lXG4gICAgICAgICAgICAoZnVuIF8gLT4gRWRpdCAoQ3JlYXRlIEV4cF9wbHVzKSk7XG4gICAgICAgICAgR3VpLmFjdGlvbl9idXR0b24gY3R4IFwiVGltZXMgKCopXCIgTGFuZy5Tb3J0LkV4cCB0YWJpbmRleGVzIE5vbmVcbiAgICAgICAgICAgIChmdW4gXyAtPiBFZGl0IChDcmVhdGUgRXhwX3RpbWVzKSk7XG4gICAgICAgIF07XG4gICAgICBHdWkucGFuZWwgfmxhYmVsOlwiVHlwZXNcIlxuICAgICAgICBbXG4gICAgICAgICAgR3VpLmFjdGlvbl9idXR0b24gY3R4IFwiTnVtIChOKVwiIExhbmcuU29ydC5UeXAgdGFiaW5kZXhlcyBOb25lXG4gICAgICAgICAgICAoZnVuIF8gLT4gRWRpdCAoQ3JlYXRlIFR5cF9udW0pKTtcbiAgICAgICAgICBHdWkuYWN0aW9uX2J1dHRvbiBjdHggXCJBcnJvdyAoPilcIiBMYW5nLlNvcnQuVHlwIHRhYmluZGV4ZXMgTm9uZVxuICAgICAgICAgICAgKGZ1biBfIC0+IEVkaXQgKENyZWF0ZSBUeXBfYXJyb3cpKTtcbiAgICAgICAgXTtcbiAgICAgIEd1aS5wYW5lbCB+bGFiZWw6XCJDdXJzb3JcIlxuICAgICAgICBbXG4gICAgICAgICAgR3VpLmJ1dHRvbiBjdHggXCJEZWxldGUgKGRlbGV0ZSlcIiB0YWJpbmRleGVzIH5vbl9jbGljazooZnVuICgpIC0+XG4gICAgICAgICAgICAgIEpzLmNsZWFyX3NlbGVjdGlvbiAoXCJkZWxldGVkXCIgXiBpZCk7XG4gICAgICAgICAgICAgIFNvbWUgKEVkaXQgRGVzdHJveSkpO1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJVcCAo4oaRKVwiIHRhYmluZGV4ZXMgKE1vdmUgVXApO1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJEb3duICjihpMpXCIgdGFiaW5kZXhlcyAoTW92ZSBEb3duKTtcbiAgICAgICAgICBHdWkuc29tZV9idXR0b24gY3R4IFwiTGVmdCAo4oaQKVwiIHRhYmluZGV4ZXMgKE1vdmUgTGVmdCk7XG4gICAgICAgICAgR3VpLnNvbWVfYnV0dG9uIGN0eCBcIlJpZ2h0ICjihpIpXCIgdGFiaW5kZXhlcyAoTW92ZSBSaWdodCk7XG4gICAgICAgICAgR3VpLmJ1dHRvbiBjdHggXCJUZWxlcG9ydFwiIHRhYmluZGV4ZXMgfm9uX2NsaWNrOihHdWkudGVsZXBvcnQgY3R4IGlkKTtcbiAgICAgICAgXTtcbiAgICAgIEd1aS5wYW5lbCB+bGFiZWw6XCJFbnZpcm9ubWVudFwiXG4gICAgICAgIFtcbiAgICAgICAgICBHdWkuc29tZV9idXR0b24gY3R4IFwiUmVjb3JkXCIgdGFiaW5kZXhlcyAoRW52IFJlY29yZClcbiAgICAgICAgICAgIH5kaXNhYmxlZDooT3B0aW9uLmlzX3NvbWUgbW9kZWwuYWN0aW9ucyk7XG4gICAgICAgICAgR3VpLnNvbWVfYnV0dG9uIGN0eCBcIlJlcG9ydFwiIHRhYmluZGV4ZXMgKEVudiBSZXBvcnQpXG4gICAgICAgICAgICB+ZGlzYWJsZWQ6KE9wdGlvbi5pc19ub25lIG1vZGVsLmFjdGlvbnMpO1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJTdG9wXCIgdGFiaW5kZXhlcyAoRW52IFN0b3ApXG4gICAgICAgICAgICB+ZGlzYWJsZWQ6KE9wdGlvbi5pc19ub25lIG1vZGVsLmFjdGlvbnMpO1xuICAgICAgICAgIEd1aS5idXR0b24gY3R4IFwiUmVwbGF5XCIgdGFiaW5kZXhlcyB+b25fY2xpY2s6KGZ1biAoKSAtPlxuICAgICAgICAgICAgICBTb21lIChFbnYgKFJlcGxheSAoSnMucHJvbXB0IFwiUmVwbGF5IFJlY29yZGluZ1wiKSkpKTtcbiAgICAgICAgICBHdWkuc29tZV9idXR0b24gY3R4IFwiRHVtcFwiIHRhYmluZGV4ZXMgKEVudiBEdW1wKTtcbiAgICAgICAgICBHdWkuYnV0dG9uIGN0eCBcIkxvYWRcIiB0YWJpbmRleGVzIH5vbl9jbGljazooZnVuICgpIC0+XG4gICAgICAgICAgICAgIFNvbWUgKEVudiAoTG9hZCAoSnMucHJvbXB0IFwiTG9hZCBhIER1bXBcIikpKSk7XG4gICAgICAgIF07XG4gICAgICBHdWkucGFuZWwgfmxhYmVsOlwiRWRpdG9yXCJcbiAgICAgICAgW1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJDbG9uZVwiIHRhYmluZGV4ZXMgKEVudiAoQ2xvbmUgY3R4LmVkaXRvci5pZCkpO1xuICAgICAgICAgIEd1aS5zb21lX2J1dHRvbiBjdHggXCJEcm9wXCIgdGFiaW5kZXhlcyAoRW52IChEcm9wIGN0eC5lZGl0b3IuaWQpKVxuICAgICAgICAgICAgfmRpc2FibGVkOihVdWlkLk1hcC5jYXJkaW5hbCBtb2RlbC5lZGl0b3JzIDwgMik7XG4gICAgICAgIF07XG4gICAgXVxuXG5sZXQgdmlldyB+KGluamVjdCA6IEFjdGlvbi50IC0+IHVuaXQgVmRvbS5FZmZlY3QudCkgKG1vZGVsIDogTW9kZWwudCkgOiBOb2RlLnQgPVxuICBsZXQgZWRpdG9ycyA9IFV1aWQuTWFwLmJpbmRpbmdzIG1vZGVsLmVkaXRvcnMgfD4gTGlzdC5tYXAgc25kIGluXG4gIGxldCBlZGl0b3JfaWRzID0gTGlzdC5tYXAgKGZ1biAoZWRpdG9yIDogRWRpdG9yLnQpIC0+IGVkaXRvci5pZCkgZWRpdG9ycyBpblxuICBsZXQgcG9zaXRpb25zID0gTGlzdC5pbml0IChMaXN0Lmxlbmd0aCBlZGl0b3JzKSAoZnVuIGkgLT4gaSArIDEpIGluXG4gIGxldCB0YWJpbmRleGVzID1cbiAgICBMaXN0LmNvbWJpbmUgZWRpdG9yX2lkcyBwb3NpdGlvbnMgfD4gTGlzdC50b19zZXEgfD4gVXVpZC5NYXAub2Zfc2VxXG4gIGluXG4gIE5vZGUuZGl2XG4gICAgfmF0dHI6KEF0dHIuY3JlYXRlIFwidGFiaW5kZXhcIiBcIi0xXCIpXG4gICAgKExpc3QubWFwXG4gICAgICAgKGZ1biBlZGl0b3IgLT4gdmlld19lZGl0b3IgbW9kZWwgeyBpbmplY3Q7IGVkaXRvciB9IHRhYmluZGV4ZXMpXG4gICAgICAgZWRpdG9ycylcbiIsIm9wZW4gSW5jcl9kb21cbm1vZHVsZSBNb2RlbCA9IE1vZGVsXG5tb2R1bGUgQWN0aW9uID0gQWN0aW9uXG5tb2R1bGUgU3RhdGUgPSBTdGF0ZVxuXG5sZXQgb25fc3RhcnR1cCB+c2NoZWR1bGVfYWN0aW9uOihfIDogQWN0aW9uLnQgLT4gdW5pdCkgKF8gOiBNb2RlbC50KSA6XG4gICAgU3RhdGUudCBBc3luY19rZXJuZWwuRGVmZXJyZWQudCA9XG4gIEFzeW5jX2tlcm5lbC5EZWZlcnJlZC5yZXR1cm4gU3RhdGUuU3RhdGVcblxubGV0IGNyZWF0ZSAobW9kZWwgOiBNb2RlbC50IEluY3JfZG9tLkluY3IudClcbiAgICB+b2xkX21vZGVsOihfIDogTW9kZWwudCBJbmNyX2RvbS5JbmNyLnQpXG4gICAgfihpbmplY3QgOiBBY3Rpb24udCAtPiB1bml0IFZkb20uRWZmZWN0LnQpIDpcbiAgICAoQWN0aW9uLnQsIE1vZGVsLnQsIFN0YXRlLnQpIEluY3JfZG9tLkNvbXBvbmVudC50IEluY3JfZG9tLkluY3IudCA9XG4gIGxldCVtYXAuSW5jciBtb2RlbCA9IG1vZGVsIGluXG4gIGxldCB2aWV3ID0gVmlldy52aWV3IH5pbmplY3QgbW9kZWwgaW5cbiAgSW5jcl9kb20uQ29tcG9uZW50LmNyZWF0ZSBtb2RlbCB2aWV3IH5hcHBseV9hY3Rpb246KEFjdGlvbi5hcHBseSBtb2RlbClcbiJdfQ==
