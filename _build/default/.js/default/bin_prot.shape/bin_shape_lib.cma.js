// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Bin_shape_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib = [0];
   runtime.caml_register_global(0, Bin_shape_lib, "Bin_shape_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Bin_shape
//# unitInfo: Requires: Assert_failure, Base, Base__Comparator, Base__Int, Base__List, Base__Map, Base__Option, Base__Printf, Base__String, Md5_lib, Ppx_compare_lib, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Annotate = "Annotate",
    cst_Application = "Application",
    cst_Base = "Base",
    cst_Exp = "Exp",
    cst_Poly_variant = "Poly_variant",
    cst_Rec_app = "Rec_app",
    cst_Record = "Record",
    cst_Tuple = "Tuple",
    cst_Var = "Var",
    cst_Variant = "Variant",
    cst_annotate$0 = "annotate",
    cst_application$0 = "application",
    cst_base$0 = "base",
    cst_exp = "exp",
    cst_poly_variant$0 = "poly_variant",
    cst_rec_app$0 = "rec_app",
    cst_record$0 = "record",
    cst_sorted$0 = "sorted",
    cst_tuple$0 = "tuple",
    cst_var$0 = "var",
    cst_variant$0 = "variant",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_026 = "shape/src/bin_shape.ml.Sorted_table.t",
    error_source_042 = "shape/src/bin_shape.ml.Canonical_exp_constructor.t",
    error_source_206 = "shape/src/bin_shape.ml.Canonical_full.Exp1.t0",
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base = global_data.Base,
    Base_Option = global_data.Base__Option,
    Base_Map = global_data.Base__Map,
    Base_Comparator = global_data.Base__Comparator,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Printf = global_data.Base__Printf,
    Md5_lib = global_data.Md5_lib,
    sexp_of_t = Base_String[28],
    of_string = Base_String[29],
    to_string = Base_String[30],
    t_of_sexp = Base_String[27],
    sexp_of_t$0 = Base_String[28],
    of_string$0 = Base_String[29],
    to_string$0 = Base_String[30],
    compare = Base_String[37],
    _M_ = [0, "shape/src/bin_shape.ml.For_typerep.Not_a_tuple"],
    _N_ = [0, "_none_", 0, -1],
    cst_Free_type_variable_Vid = "Free type variable: '%{Vid}",
    _J_ = [0, 0],
    cst_Free_type_variable = "Free type variable: '",
    _K_ =
      [0,
       [11,
        "The shape for an inherited type is not described as a polymorphic-variant: ",
        [2, 0, 0]],
       "The shape for an inherited type is not described as a polymorphic-variant: %s"],
    cst_apply_incorrect_type_appli = "apply, incorrect type application arity",
    cst_top_level = "top-level",
    _y_ = [0, cst_Annotate],
    _z_ = [0, cst_Base],
    _A_ = [0, cst_Record],
    _B_ = [0, cst_Variant],
    _C_ = [0, cst_Tuple],
    _D_ = [0, cst_Poly_variant],
    _E_ = [0, cst_Var],
    _F_ = [0, cst_Rec_app],
    _G_ = [0, "Top_app"],
    cst_impossible_lookup_group_un =
      "impossible: lookup_group, unbound type-identifier: %{Tid}",
    _x_ = [0, 0],
    cst_impossible_lookup_group_un$0 =
      "impossible: lookup_group, unbound type-identifier: ",
    _u_ = [0, "members"],
    _v_ = [0, "loc"],
    _w_ = [0, "gid"],
    _s_ = [0, "Constr"],
    _t_ = [0, "Inherit"],
    _r_ = [0, cst_Exp],
    cst_annotate = cst_annotate$0,
    cst_base = cst_base$0,
    cst_tuple = cst_tuple$0,
    cst_record = cst_record$0,
    cst_variant = cst_variant$0,
    cst_poly_variant = cst_poly_variant$0,
    cst_application = cst_application$0,
    cst_rec_app = cst_rec_app$0,
    cst_var = cst_var$0,
    _q_ = [0, "..."],
    _h_ = [0, cst_Annotate],
    _i_ = [0, cst_Base],
    _j_ = [0, cst_Tuple],
    _k_ = [0, cst_Record],
    _l_ = [0, cst_Variant],
    _m_ = [0, cst_Poly_variant],
    _n_ = [0, cst_Application],
    _o_ = [0, cst_Rec_app],
    _p_ = [0, cst_Var],
    cst_some = "some",
    cst_none = "none",
    _g_ = [0, ""],
    _f_ =
      [0,
       [11,
        "Different shapes for duplicated polymorphic constructor: `",
        [2, 0, 0]],
       "Different shapes for duplicated polymorphic constructor: `%s"],
    _e_ = [0, 17724, 0],
    _d_ = [0, cst_sorted$0],
    _c_ = [0, "shape/src/bin_shape.ml", 33, 2],
    cst_sorted = cst_sorted$0,
    cst_Location_s = "%{Location}: %s",
    _a_ = [11, ": ", [2, 0, 0]],
    _b_ = [0, 0],
    cst_Bin_shape_lib_Bin_shape_Fo =
      "Bin_shape_lib.Bin_shape.For_typerep.Not_a_tuple";
   function eval_fail(loc, fmt){
    function _eu_(s){
     var
      _ev_ =
        [0,
         [24,
          _b_,
          function(param, custom_printf_001){
           return caml_call1(to_string, custom_printf_001);
          },
          _a_],
         cst_Location_s],
      _ew_ = caml_call3(Base_Printf[2], _ev_, loc, s);
     return caml_call1(Base[201], _ew_);
    }
    return caml_call2(Base_Printf[4], _eu_, fmt);
   }
   function equal_option(equal, a, b){
    if(a){
     if(b){var y = b[1], x = a[1]; return caml_call2(equal, x, y);}
    }
    else if(! b) return 1;
    return 0;
   }
   function create(loc, eq, xs$1){
    function _es_(param, _et_){
     var s2 = _et_[1], s1 = param[1];
     return caml_call2(Base_String[37], s1, s2);
    }
    var sorted = caml_call2(Base_List[62], xs$1, _es_);
    if(sorted){
     var
      xs$0 = sorted[2],
      match$0 = sorted[1],
      last_value$1 = match$0[2],
      last_key$1 = match$0[1],
      acc$1 = [0, [0, last_key$1, last_value$1], 0],
      acc = acc$1,
      last_key = last_key$1,
      last_value = last_value$1,
      param = xs$0;
     for(;;){
      if(! param){
       var match$1 = [0, 17724, caml_call1(Base_List[38], acc)];
       break;
      }
      var
       xs = param[2],
       match = param[1],
       last_value$0 = match[2],
       last_key$0 = match[1];
      if(caml_call2(Base_String[33], last_key, last_key$0)){
       if(! caml_call2(eq, last_value, last_value$0)){
        var match$1 = [0, -1062743954, last_key$0];
        break;
       }
       var param = xs;
      }
      else
       var
        acc$0 = [0, [0, last_key$0, last_value$0], acc],
        acc = acc$0,
        last_key = last_key$0,
        last_value = last_value$0,
        param = xs;
     }
    }
    else
     var match$1 = _e_;
    if(17724 <= match$1[1]){var sorted$0 = match$1[2]; return [0, sorted$0];}
    var s = match$1[2];
    return caml_call2(eval_fail(loc, _f_), s, 0);
   }
   function map(t, f){
    function _er_(param){
     var v = param[2], k = param[1];
     return [0, k, caml_call1(f, v)];
    }
    return [0, caml_call2(Base_List[76], t[1], _er_)];
   }
   var
    compare$0 = Md5_lib[1],
    to_binary = Md5_lib[3],
    to_hex = Md5_lib[6],
    of_hex_exn = Md5_lib[7],
    string = Md5_lib[8];
   function to_md5(t){return t;}
   function of_md5(t){return t;}
   function sexp_of_t$1(t){
    var _eq_ = caml_call1(to_hex, t);
    return caml_call1(Base[165], _eq_);
   }
   function t_of_sexp$0(s){
    return caml_call1(of_hex_exn, caml_call1(Base[164], s));
   }
   function uuid(u){return caml_call1(string, caml_call1(to_string$0, u));}
   function int$0(x){return caml_call1(string, caml_call1(Base_Int[11], x));}
   function pair(x, y){
    var _eo_ = caml_call1(to_binary, y), _ep_ = caml_call1(to_binary, x);
    return caml_call1(string, caml_call2(Base[198], _ep_, _eo_));
   }
   function list(l){
    var _en_ = caml_call2(Base_List[76], l, to_binary);
    return caml_call1(string, caml_call2(Base_String[54], _g_, _en_));
   }
   function constructor(s, l){
    var _em_ = caml_call1(to_binary, list(l));
    return caml_call1(string, caml_call2(Base[198], s, _em_));
   }
   function t_of_sexp$1(of_a_039, sexp_044){
    a:
    {
     if(0 === sexp_044[0]){
      var
       _d7_ = sexp_044[1],
       _d8_ = caml_string_compare(_d7_, cst_annotate$0);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            h:
            {
             i:
             {
              if(0 <= _d8_){
               if(0 < _d8_){
                if(! caml_string_notequal(_d7_, cst_application$0)) break i;
                if(! caml_string_notequal(_d7_, cst_base$0)) break h;
                if(! caml_string_notequal(_d7_, cst_poly_variant$0)) break g;
                if(! caml_string_notequal(_d7_, cst_rec_app$0)) break f;
                if(! caml_string_notequal(_d7_, cst_record$0)) break e;
                if(! caml_string_notequal(_d7_, cst_tuple$0)) break d;
                if(! caml_string_notequal(_d7_, cst_var$0)) break c;
                if(caml_string_notequal(_d7_, cst_variant$0)) break a;
                break b;
               }
              }
              else if(caml_string_notequal(_d7_, cst_Annotate)){
               if(! caml_string_notequal(_d7_, cst_Application)) break i;
               if(! caml_string_notequal(_d7_, cst_Base)) break h;
               if(! caml_string_notequal(_d7_, cst_Poly_variant)) break g;
               if(! caml_string_notequal(_d7_, cst_Rec_app)) break f;
               if(! caml_string_notequal(_d7_, cst_Record)) break e;
               if(! caml_string_notequal(_d7_, cst_Tuple)) break d;
               if(! caml_string_notequal(_d7_, cst_Var)) break c;
               if(caml_string_notequal(_d7_, cst_Variant)) break a;
               break b;
              }
              return caml_call2
                      (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
     }
     var _d9_ = sexp_044[1];
     if(! _d9_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_042, sexp_044);
     var _d__ = _d9_[1];
     if(0 !== _d__[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_042, sexp_044);
     var
      tag_045 = _d__[1],
      _d$_ = caml_string_compare(tag_045, cst_annotate$0);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             if(0 <= _d$_){
              if(0 < _d$_){
               if(! caml_string_notequal(tag_045, cst_application$0)) break i;
               if(! caml_string_notequal(tag_045, cst_base$0)) break h;
               if(! caml_string_notequal(tag_045, cst_poly_variant$0))
                break g;
               if(! caml_string_notequal(tag_045, cst_rec_app$0)) break f;
               if(! caml_string_notequal(tag_045, cst_record$0)) break e;
               if(! caml_string_notequal(tag_045, cst_tuple$0)) break d;
               if(! caml_string_notequal(tag_045, cst_var$0)) break c;
               if(caml_string_notequal(tag_045, cst_variant$0)) break a;
               break b;
              }
             }
             else if(caml_string_notequal(tag_045, cst_Annotate)){
              if(! caml_string_notequal(tag_045, cst_Application)) break i;
              if(! caml_string_notequal(tag_045, cst_Base)) break h;
              if(! caml_string_notequal(tag_045, cst_Poly_variant)) break g;
              if(! caml_string_notequal(tag_045, cst_Rec_app)) break f;
              if(! caml_string_notequal(tag_045, cst_Record)) break e;
              if(! caml_string_notequal(tag_045, cst_Tuple)) break d;
              if(! caml_string_notequal(tag_045, cst_Var)) break c;
              if(caml_string_notequal(tag_045, cst_Variant)) break a;
              break b;
             }
             var sexp_args_046 = _d9_[2];
             if(sexp_args_046){
              var _ef_ = sexp_args_046[2];
              if(_ef_ && ! _ef_[2]){
               var
                arg1_048 = _ef_[1],
                arg0_047 = sexp_args_046[1],
                res0_049 = caml_call1(t_of_sexp, arg0_047),
                res1_050 = caml_call1(of_a_039, arg1_048);
               return [0, res0_049, res1_050];
              }
             }
             return caml_call3
                     (Sexplib0_Sexp_conv_error[4],
                      error_source_042,
                      tag_045,
                      sexp_044);
            }
            var sexp_args_090 = _d9_[2];
            if(sexp_args_090){
             var _ee_ = sexp_args_090[2];
             if(_ee_ && ! _ee_[2]){
              var
               arg1_092 = _ee_[1],
               arg0_091 = sexp_args_090[1],
               res0_093 = caml_call1(of_a_039, arg0_091),
               res1_094 = caml_call2(Base[139], of_a_039, arg1_092);
              return [6, res0_093, res1_094];
             }
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],
                     error_source_042,
                     tag_045,
                     sexp_044);
           }
           var sexp_args_053 = _d9_[2];
           if(sexp_args_053){
            var _ed_ = sexp_args_053[2];
            if(_ed_ && ! _ed_[2]){
             var
              arg1_055 = _ed_[1],
              arg0_054 = sexp_args_053[1],
              res0_056 = caml_call1(t_of_sexp, arg0_054),
              res1_057 = caml_call2(Base[139], of_a_039, arg1_055);
             return [1, res0_056, res1_057];
            }
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],
                    error_source_042,
                    tag_045,
                    sexp_044);
          }
          var sexp_args_085 = _d9_[2];
          if(sexp_args_085 && ! sexp_args_085[2]){
           var
            arg0_086 = sexp_args_085[1],
            of_a_010 = caml_call1(Base[152], of_a_039);
           if(0 === arg0_086[0])
            var
             res0_087 =
               caml_call2
                (Sexplib0_Sexp_conv_error[16], error_source_026, arg0_086);
           else{
            var
             field_sexps_013 = arg0_086[1],
             sorted_014 = [0, 0],
             duplicates_016 = [0, 0],
             extra_017 = [0, 0];
            g:
            {
             h:
             i:
             j:
             {
              k:
              {
               var param = field_sexps_013;
               for(;;){
                if(! param) break;
                var sexp_012 = param[1];
                if(1 !== sexp_012[0]) break h;
                var _d4_ = sexp_012[1];
                if(! _d4_) break i;
                var _d5_ = _d4_[1];
                if(0 !== _d5_[0]) break k;
                var field_sexps_020 = _d4_[2], field_name_018 = _d5_[1];
                if(field_sexps_020 && field_sexps_020[2]) break j;
                var tail_029 = param[2];
                if(caml_string_notequal(field_name_018, cst_sorted$0)){
                 if(Sexplib0_Sexp_conv[26][1])
                  extra_017[1] = [0, field_name_018, extra_017[1]];
                }
                else if(sorted_014[1])
                 duplicates_016[1] = [0, field_name_018, duplicates_016[1]];
                else{
                 if(field_sexps_020){
                  if(field_sexps_020[2])
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _c_], 1);
                  var x_030 = field_sexps_020[1], field_sexp_019 = x_030;
                 }
                 else
                  var
                   field_sexp_019 =
                     caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_026, arg0_086);
                 var
                  _d6_ =
                    function(sexp_025){
                     if(1 === sexp_025[0]){
                      var _ek_ = sexp_025[1];
                      if(_ek_){
                       var _el_ = _ek_[2];
                       if(_el_ && ! _el_[2]){
                        var
                         arg1_022 = _el_[1],
                         arg0_021 = _ek_[1],
                         res0_023 = caml_call1(Base[164], arg0_021),
                         res1_024 = caml_call1(of_a_010, arg1_022);
                        return [0, res0_023, res1_024];
                       }
                      }
                     }
                     return caml_call3
                             (Sexplib0_Sexp_conv_error[2], error_source_026, 2, sexp_025);
                    },
                  fvalue_027 = caml_call2(Base[139], _d6_, field_sexp_019);
                 sorted_014[1] = [0, fvalue_027];
                }
                var param = tail_029;
               }
               break g;
              }
              break i;
             }
             caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_026, sexp_012);
            }
            if(duplicates_016[1])
             var
              res0_087 =
                caml_call3
                 (Sexplib0_Sexp_conv_error[12],
                  error_source_026,
                  duplicates_016[1],
                  arg0_086);
            else if(extra_017[1])
             var
              res0_087 =
                caml_call3
                 (Sexplib0_Sexp_conv_error[13],
                  error_source_026,
                  extra_017[1],
                  arg0_086);
            else{
             var match = sorted_014[1];
             if(match)
              var sorted_015 = match[1], res0_087 = [0, sorted_015];
             else
              var
               res0_087 =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[15],
                   error_source_026,
                   arg0_086,
                   [0, [0, 0 === sorted_014[1] ? 1 : 0, cst_sorted], 0]);
            }
           }
           return [5, res0_087];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],
                   error_source_042,
                   tag_045,
                   sexp_044);
         }
         var sexp_args_097 = _d9_[2];
         if(sexp_args_097){
          var _ec_ = sexp_args_097[2];
          if(_ec_ && ! _ec_[2]){
           var
            arg1_099 = _ec_[1],
            arg0_098 = sexp_args_097[1],
            res0_100 = caml_call1(Base[119], arg0_098),
            res1_101 = caml_call2(Base[139], of_a_039, arg1_099);
           return [7, res0_100, res1_101];
          }
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[4],
                  error_source_042,
                  tag_045,
                  sexp_044);
        }
        var sexp_args_065 = _d9_[2];
        if(sexp_args_065 && ! sexp_args_065[2]){
         var
          arg0_071 = sexp_args_065[1],
          _eb_ =
            function(sexp_070){
             if(1 === sexp_070[0]){
              var _ei_ = sexp_070[1];
              if(_ei_){
               var _ej_ = _ei_[2];
               if(_ej_ && ! _ej_[2]){
                var
                 arg1_067 = _ej_[1],
                 arg0_066 = _ei_[1],
                 res0_068 = caml_call1(Base[164], arg0_066),
                 res1_069 = caml_call1(of_a_039, arg1_067);
                return [0, res0_068, res1_069];
               }
              }
             }
             return caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_070);
            },
          res0_072 = caml_call2(Base[139], _eb_, arg0_071);
         return [3, res0_072];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       }
       var sexp_args_060 = _d9_[2];
       if(sexp_args_060 && ! sexp_args_060[2]){
        var
         arg0_061 = sexp_args_060[1],
         res0_062 = caml_call2(Base[139], of_a_039, arg0_061);
        return [2, res0_062];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_042,
                tag_045,
                sexp_044);
      }
      var sexp_args_104 = _d9_[2];
      if(sexp_args_104 && ! sexp_args_104[2]){
       var
        arg0_105 = sexp_args_104[1],
        res0_106 = caml_call1(Base[119], arg0_105);
       return [8, res0_106];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_042,
               tag_045,
               sexp_044);
     }
     var sexp_args_075 = _d9_[2];
     if(sexp_args_075 && ! sexp_args_075[2]){
      var
       arg0_081 = sexp_args_075[1],
       _ea_ =
         function(sexp_080){
          if(1 === sexp_080[0]){
           var _eg_ = sexp_080[1];
           if(_eg_){
            var _eh_ = _eg_[2];
            if(_eh_ && ! _eh_[2]){
             var
              arg1_077 = _eh_[1],
              arg0_076 = _eg_[1],
              res0_078 = caml_call1(Base[164], arg0_076),
              res1_079 = caml_call2(Base[139], of_a_039, arg1_077);
             return [0, res0_078, res1_079];
            }
           }
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_080);
         },
       res0_082 = caml_call2(Base[139], _ea_, arg0_081);
      return [4, res0_082];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_042,
              tag_045,
              sexp_044);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_042, sexp_044);
   }
   function sexp_of_t$2(of_a_108, param){
    switch(param[0]){
      case 0:
       var
        arg1_110 = param[2],
        arg0_109 = param[1],
        res0_111 = caml_call1(sexp_of_t$0, arg0_109),
        res1_112 = caml_call1(of_a_108, arg1_110);
       return [1, [0, _h_, [0, res0_111, [0, res1_112, 0]]]];
      case 1:
       var
        arg1_114 = param[2],
        arg0_113 = param[1],
        res0_115 = caml_call1(sexp_of_t$0, arg0_113),
        res1_116 = caml_call2(Base[140], of_a_108, arg1_114);
       return [1, [0, _i_, [0, res0_115, [0, res1_116, 0]]]];
      case 2:
       var
        arg0_117 = param[1],
        res0_118 = caml_call2(Base[140], of_a_108, arg0_117);
       return [1, [0, _j_, [0, res0_118, 0]]];
      case 3:
       var
        arg0_123 = param[1],
        _d2_ =
          function(param){
           var
            arg1_120 = param[2],
            arg0_119 = param[1],
            res0_121 = caml_call1(Base[165], arg0_119),
            res1_122 = caml_call1(of_a_108, arg1_120);
           return [1, [0, res0_121, [0, res1_122, 0]]];
          },
        res0_124 = caml_call2(Base[140], _d2_, arg0_123);
       return [1, [0, _k_, [0, res0_124, 0]]];
      case 4:
       var
        arg0_129 = param[1],
        _d3_ =
          function(param){
           var
            arg1_126 = param[2],
            arg0_125 = param[1],
            res0_127 = caml_call1(Base[165], arg0_125),
            res1_128 = caml_call2(Base[140], of_a_108, arg1_126);
           return [1, [0, res0_127, [0, res1_128, 0]]];
          },
        res0_130 = caml_call2(Base[140], _d3_, arg0_129);
       return [1, [0, _l_, [0, res0_130, 0]]];
      case 5:
       var
        arg0_131 = param[1],
        of_a_031 = caml_call1(Base[153], of_a_108),
        sorted_033 = arg0_131[1],
        bnds_032 = 0,
        _d1_ =
          function(param){
           var
            arg1_036 = param[2],
            arg0_035 = param[1],
            res0_037 = caml_call1(Base[165], arg0_035),
            res1_038 = caml_call1(of_a_031, arg1_036);
           return [1, [0, res0_037, [0, res1_038, 0]]];
          },
        arg_034 = caml_call2(Base[140], _d1_, sorted_033),
        bnds_032$0 = [0, [1, [0, _d_, [0, arg_034, 0]]], bnds_032],
        res0_132 = [1, bnds_032$0];
       return [1, [0, _m_, [0, res0_132, 0]]];
      case 6:
       var
        arg1_134 = param[2],
        arg0_133 = param[1],
        res0_135 = caml_call1(of_a_108, arg0_133),
        res1_136 = caml_call2(Base[140], of_a_108, arg1_134);
       return [1, [0, _n_, [0, res0_135, [0, res1_136, 0]]]];
      case 7:
       var
        arg1_138 = param[2],
        arg0_137 = param[1],
        res0_139 = caml_call1(Base[120], arg0_137),
        res1_140 = caml_call2(Base[140], of_a_108, arg1_138);
       return [1, [0, _o_, [0, res0_139, [0, res1_140, 0]]]];
      default:
       var arg0_141 = param[1], res0_142 = caml_call1(Base[120], arg0_141);
       return [1, [0, _p_, [0, res0_142, 0]]];
    }
   }
   function map$0(x, f){
    switch(x[0]){
      case 0:
       var x$0 = x[2], u = x[1]; return [0, u, caml_call1(f, x$0)];
      case 1:
       var xs = x[2], s = x[1];
       return [1, s, caml_call2(Base_List[76], xs, f)];
      case 2:
       var xs$0 = x[1]; return [2, caml_call2(Base_List[76], xs$0, f)];
      case 3:
       var
        l = x[1],
        _dW_ =
          function(param){
           var x = param[2], s = param[1];
           return [0, s, caml_call1(f, x)];
          };
       return [3, caml_call2(Base_List[76], l, _dW_)];
      case 4:
       var
        l$0 = x[1],
        _dX_ =
          function(param){
           var xs = param[2], s = param[1];
           return [0, s, caml_call2(Base_List[76], xs, f)];
          };
       return [4, caml_call2(Base_List[76], l$0, _dX_)];
      case 5:
       var t = x[1], _dY_ = Base_Option[21];
       return [5, map(t, function(_d0_){return caml_call2(_dY_, _d0_, f);})];
      case 6:
       var l$1 = x[2], x$1 = x[1], _dZ_ = caml_call2(Base_List[76], l$1, f);
       return [6, caml_call1(f, x$1), _dZ_];
      case 7:
       var l$2 = x[2], t$0 = x[1];
       return [7, t$0, caml_call2(Base_List[76], l$2, f)];
      default: var v = x[1]; return [8, v];
    }
   }
   function to_string$1(t){
    var _dV_ = sexp_of_t$2(function(param){return _q_;}, t);
    return caml_call1(Base[85][15], _dV_);
   }
   function digest_layer(param){
    switch(param[0]){
      case 0:
       var x = param[2], u = param[1];
       return constructor(cst_annotate, [0, uuid(u), [0, x, 0]]);
      case 1:
       var l = param[2], u$0 = param[1], _dL_ = [0, list(l), 0];
       return constructor(cst_base, [0, uuid(u$0), _dL_]);
      case 2:
       var l$0 = param[1]; return constructor(cst_tuple, [0, list(l$0), 0]);
      case 3:
       var
        l$1 = param[1],
        _dM_ = 0,
        _dN_ =
          function(param){
           var t = param[2], s = param[1];
           return pair(caml_call1(string, s), t);
          };
       return constructor
               (cst_record,
                [0, list(caml_call2(Base_List[76], l$1, _dN_)), _dM_]);
      case 4:
       var
        l$2 = param[1],
        _dO_ = 0,
        _dP_ =
          function(param){
           var l = param[2], s = param[1], _dU_ = list(l);
           return pair(caml_call1(string, s), _dU_);
          };
       return constructor
               (cst_variant,
                [0, list(caml_call2(Base_List[76], l$2, _dP_)), _dO_]);
      case 5:
       var
        table = param[1],
        _dQ_ = 0,
        _dR_ =
          function(param){
           var y = param[2], x$0 = param[1];
           if(y)
            var x = y[1], _dT_ = constructor(cst_some, [0, x, 0]);
           else
            var _dT_ = constructor(cst_none, 0);
           return pair(caml_call1(string, x$0), _dT_);
          };
       return constructor
               (cst_poly_variant,
                [0, list(caml_call2(Base_List[76], table[1], _dR_)), _dQ_]);
      case 6:
       var l$3 = param[2], x$0 = param[1];
       return constructor(cst_application, [0, x$0, [0, list(l$3), 0]]);
      case 7:
       var l$4 = param[2], n = param[1], _dS_ = [0, list(l$4), 0];
       return constructor(cst_rec_app, [0, int$0(n), _dS_]);
      default:
       var n$0 = param[1]; return constructor(cst_var, [0, int$0(n$0), 0]);
    }
   }
   function to_digest(param){var x = param[1]; return x;}
   function to_digest$0(x){
    switch(x[0]){
      case 0:
       var x$0 = x[1]; return digest_layer([5, x$0]);
      case 1:
       var x$1 = x[1][2]; return x$1;
      default: var x$2 = x[1]; return x$2;
    }
   }
   function equal(x, y){
    var _dK_ = to_digest$0(y);
    return 0 === caml_call2(compare$0, to_digest$0(x), _dK_) ? 1 : 0;
   }
   function opaque(x){return [2, to_digest$0(x)];}
   function create$0(x){
    var x$0 = map$0(x, to_digest$0), desc = to_string$1(x$0);
    switch(x$0[0]){
      case 0:
       return [1, [0, desc, digest_layer(x$0)]];
      case 1:
       return [1, [0, desc, digest_layer(x$0)]];
      case 5:
       var l = x$0[1]; return [0, l];
      case 6:
       return [1, [0, desc, digest_layer(x$0)]];
      case 7:
       return [1, [0, desc, digest_layer(x$0)]];
      default: return [1, [0, desc, digest_layer(x$0)]];
    }
   }
   function var$0(x){return create$0([8, x]);}
   function apply(def, l){return create$0([6, def, l]);}
   function recurse(tid, l){return create$0([7, tid, l]);}
   function get_poly_variant(x){
    if(1 === x[0]){var desc = x[1][1]; return [1, desc];}
    var l = x[1], _dH_ = Base_Option[21];
    function _dI_(x){return [2, x];}
    return [0, map(l, function(_dJ_){return caml_call2(_dH_, _dJ_, _dI_);})];
   }
   var Def = [0];
   function annotate(u, x){return create$0([0, u, x]);}
   function basetype(u, l){return create$0([1, u, l]);}
   function tuple(l){return create$0([2, l]);}
   function poly_variant(loc, l){
    return create$0
            ([5,
              create
               (loc,
                function(_dF_, _dG_){return equal_option(equal, _dF_, _dG_);},
                l)]);
   }
   function var$1(x){return create$0([8, x]);}
   function apply$0(x, l){return create$0([6, x, l]);}
   function recurse$0(t, l){return create$0([7, t, l]);}
   function define(x){return x;}
   function record(l){return create$0([3, l]);}
   function variant(l){return create$0([4, l]);}
   function create$1(e){return [0, to_digest$0(e)];}
   var
    Canonical_digest =
      [0,
       to_digest,
       [0, var$0, recurse, apply, opaque, get_poly_variant],
       Def,
       [0,
        annotate,
        basetype,
        tuple,
        poly_variant,
        var$1,
        recurse$0,
        apply$0,
        define,
        record,
        variant,
        create$1]];
   function compare_t0(a_198, b_199){
    if(caml_call2(Ppx_compare_lib[1], a_198, b_199)) return 0;
    var b_201 = b_199[1], a_200 = a_198[1];
    function cmp_a(a_202, b_203){return compare_t0(a_202, b_203);}
    if(caml_call2(Ppx_compare_lib[1], a_200, b_201)) return 0;
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          switch(a_200[0]){
            case 0:
             var a_146 = a_200[1];
             if(0 !== b_201[0]) return -1;
             var
              b_149 = b_201[2],
              b_147 = b_201[1],
              a_148 = a_200[2],
              n = caml_call2(compare, a_146, b_147);
             return 0 === n ? cmp_a(a_148, b_149) : n;
            case 1:
             var a_152 = a_200[2], a_150 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                var
                 b_153 = b_201[2],
                 b_151 = b_201[1],
                 n$0 = caml_call2(compare, a_150, b_151);
                if(0 !== n$0) return n$0;
                var
                 _dx_ = function(a_154, b_155){return cmp_a(a_154, b_155);};
                return caml_call3(Base[136], _dx_, a_152, b_153);
               default: return -1;
             }
            case 2:
             var a_156 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                var
                 b_157 = b_201[1],
                 _dy_ = function(a_158, b_159){return cmp_a(a_158, b_159);};
                return caml_call3(Base[136], _dy_, a_156, b_157);
               default: return -1;
             }
            case 3:
             var a_160 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                var
                 b_161 = b_201[1],
                 _dz_ =
                   function(a_162, b_163){
                    var
                     t_165 = a_162[2],
                     t_164 = a_162[1],
                     t_167 = b_163[2],
                     t_166 = b_163[1],
                     n = caml_call2(Base[160], t_164, t_166);
                    return 0 === n ? cmp_a(t_165, t_167) : n;
                   };
                return caml_call3(Base[136], _dz_, a_160, b_161);
               default: return -1;
             }
            case 4:
             var a_168 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                var
                 b_169 = b_201[1],
                 _dA_ =
                   function(a_170, b_171){
                    var
                     t_173 = a_170[2],
                     t_172 = a_170[1],
                     t_175 = b_171[2],
                     t_174 = b_171[1],
                     n = caml_call2(Base[160], t_172, t_174);
                    if(0 !== n) return n;
                    function _dE_(a_176, b_177){return cmp_a(a_176, b_177);}
                    return caml_call3(Base[136], _dE_, t_173, t_175);
                   };
                return caml_call3(Base[136], _dA_, a_168, b_169);
               default: return -1;
             }
            case 5:
             var a_002 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                var b_179 = b_201[1];
                if(caml_call2(Ppx_compare_lib[1], a_002, b_179)) return 0;
                var
                 _du_ = b_179[1],
                 _dv_ = a_002[1],
                 _dw_ =
                   function(a_004, b_005){
                    var
                     t_007 = a_004[2],
                     t_006 = a_004[1],
                     t_009 = b_005[2],
                     t_008 = b_005[1],
                     n = caml_call2(Base[160], t_006, t_008);
                    if(0 !== n) return n;
                    function _dD_(a_182, b_183){return cmp_a(a_182, b_183);}
                    return caml_call3(Base[149], _dD_, t_007, t_009);
                   };
                return caml_call3(Base[136], _dw_, _dv_, _du_);
               default: return -1;
             }
            case 6:
             var a_186 = a_200[2], a_184 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6:
                var
                 b_187 = b_201[2],
                 b_185 = b_201[1],
                 n$1 = cmp_a(a_184, b_185);
                if(0 !== n$1) return n$1;
                var
                 _dB_ = function(a_188, b_189){return cmp_a(a_188, b_189);};
                return caml_call3(Base[136], _dB_, a_186, b_187);
               default: return -1;
             }
            case 7:
             var a_192 = a_200[2], a_190 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6: break;
               case 7:
                var
                 b_193 = b_201[2],
                 b_191 = b_201[1],
                 n$2 = caml_call2(Base[115], a_190, b_191);
                if(0 !== n$2) return n$2;
                var
                 _dC_ = function(a_194, b_195){return cmp_a(a_194, b_195);};
                return caml_call3(Base[136], _dC_, a_192, b_193);
               default: return -1;
             }
             break;
            default:
             var a_196 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6: break;
               case 7:
                return 1;
               default:
                var b_197 = b_201[1];
                return caml_call2(Base[115], a_196, b_197);
             }
          }
          return 1;
         }
         return 1;
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
    return 1;
   }
   var t0_of_sexp = function _dt_(_ds_){return _dt_.fun(_ds_);};
   runtime.caml_update_dummy
    (t0_of_sexp,
     function(sexp_208){
      a:
      {
       if(0 === sexp_208[0]){
        var _dp_ = sexp_208[1];
        if
         (caml_string_notequal(_dp_, cst_Exp)
          && caml_string_notequal(_dp_, cst_exp))
         break a;
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_206, sexp_208);
       }
       var _dq_ = sexp_208[1];
       if(! _dq_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_206, sexp_208);
       var _dr_ = _dq_[1];
       if(0 !== _dr_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[6], error_source_206, sexp_208);
       var tag_209 = _dr_[1];
       if
        (caml_string_notequal(tag_209, cst_Exp)
         && caml_string_notequal(tag_209, cst_exp))
        break a;
       var sexp_args_210 = _dq_[2];
       if(sexp_args_210 && ! sexp_args_210[2]){
        var
         arg0_211 = sexp_args_210[1],
         res0_212 = t_of_sexp$1(t0_of_sexp, arg0_211);
        return [0, res0_212];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_206,
                tag_209,
                sexp_208);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[8], error_source_206, sexp_208);
     });
   function sexp_of_t0(param){
    var arg0_213 = param[1], res0_214 = sexp_of_t$2(sexp_of_t0, arg0_213);
    return [1, [0, _r_, [0, res0_214, 0]]];
   }
   function equal_t0(x, y){return 0 === compare_t0(x, y) ? 1 : 0;}
   function var$2(x){return [0, [8, x]];}
   function apply$1(d, xs){return [0, [6, d, xs]];}
   function recurse$1(r, xs){return [0, [7, r, xs]];}
   function get_poly_variant$0(param){
    var cc = param[1];
    if(5 !== cc[0]) return [1, to_string$1(cc)];
    var tab = cc[1];
    return [0, tab];
   }
   function opaque$0(t){return t;}
   function to_digest$1(param){
    var e = param[1];
    return digest_layer(map$0(e, to_digest$1));
   }
   function to_digest$2(e){return to_digest$1(e);}
   function annotate$0(u, x){return [0, [0, u, x]];}
   function basetype$0(u, xs){return [0, [1, u, xs]];}
   function tuple$0(xs){return [0, [2, xs]];}
   function poly_variant$0(loc, xs){
    return [0,
            [5,
             create
              (loc,
               function(_dn_, _do_){
                return equal_option(equal_t0, _dn_, _do_);
               },
               xs)]];
   }
   function var$3(n){return [0, [8, n]];}
   function recurse$2(r, xs){return recurse$1(r, xs);}
   function apply$2(d, xs){return apply$1(d, xs);}
   function define$0(x){return x;}
   function record$0(xs){return [0, [3, xs]];}
   function variant$0(xs){return [0, [4, xs]];}
   function create$2(exp){return exp;}
   var
    Create =
      [0,
       annotate$0,
       basetype$0,
       tuple$0,
       poly_variant$0,
       var$3,
       recurse$2,
       apply$2,
       define$0,
       record$0,
       variant$0,
       create$2];
   function to_string_hum(t){
    var _dm_ = sexp_of_t0(t);
    return caml_call2(Base[85][13], 0, _dm_);
   }
   var
    Def$0 = [0],
    Exp1 = [0, var$2, recurse$1, apply$1, opaque$0, get_poly_variant$0],
    sexp_of_t$3 = Base_String[28],
    of_string$1 = Base_String[29],
    to_string$2 = Base_String[30],
    symbol = Base_String[33],
    compare$1 = Base_String[37],
    equal$0 = Base_String[121],
    sexp_of_t$4 = Base_String[28],
    of_string$2 = Base_String[29],
    to_string$3 = Base_String[30],
    comparator = Base_String[45],
    compare$2 = Base[115],
    sexp_of_t$5 = Base[120],
    r = [0, 0];
   function create$3(loc, trips){
    var gid = r[1];
    r[1] = 1 + gid | 0;
    function _dl_(param){
     var t = param[3], vs = param[2], x = param[1];
     return [0, x, [0, vs, t]];
    }
    var members = caml_call2(Base_List[76], trips, _dl_);
    return [0, gid, loc, members];
   }
   function lookup(g, tid){
    var match = caml_call3(Base_List[129][5], g[3], symbol, tid);
    if(match){var scheme = match[1]; return scheme;}
    var
     _di_ = 0,
     _dj_ = 0,
     _dk_ =
       [0,
        [11,
         cst_impossible_lookup_group_un$0,
         [24,
          _x_,
          function(param, custom_printf_285){
           return caml_call1(to_string$2, custom_printf_285);
          },
          _dj_]],
        cst_impossible_lookup_group_un];
    return caml_call2(eval_fail(g[2], _dk_), tid, _di_);
   }
   function annotate$1(v0, v1){return [0, v0, v1];}
   function basetype$1(v0, v1){return [1, v0, v1];}
   function record$1(v0){return [2, v0];}
   function variant$1(v0){return [3, v0];}
   function tuple$1(v0){return [4, v0];}
   function rec_app(v0, v1){return [7, v0, v1];}
   function top_app(v0, v1, v2){return [8, v0, v1, v2];}
   function sexp_of_t$6(param){
    switch(param[0]){
      case 0:
       var
        arg1_287 = param[2],
        arg0_286 = param[1],
        res0_288 = caml_call1(sexp_of_t$0, arg0_286),
        res1_289 = sexp_of_t$6(arg1_287);
       return [1, [0, _y_, [0, res0_288, [0, res1_289, 0]]]];
      case 1:
       var
        arg1_291 = param[2],
        arg0_290 = param[1],
        res0_292 = caml_call1(sexp_of_t$0, arg0_290),
        res1_293 = caml_call2(Base[140], sexp_of_t$6, arg1_291);
       return [1, [0, _z_, [0, res0_292, [0, res1_293, 0]]]];
      case 2:
       var
        arg0_298 = param[1],
        _df_ =
          function(param){
           var
            arg1_295 = param[2],
            arg0_294 = param[1],
            res0_296 = caml_call1(Base[165], arg0_294),
            res1_297 = sexp_of_t$6(arg1_295);
           return [1, [0, res0_296, [0, res1_297, 0]]];
          },
        res0_299 = caml_call2(Base[140], _df_, arg0_298);
       return [1, [0, _A_, [0, res0_299, 0]]];
      case 3:
       var
        arg0_304 = param[1],
        _dg_ =
          function(param){
           var
            arg1_301 = param[2],
            arg0_300 = param[1],
            res0_302 = caml_call1(Base[165], arg0_300),
            res1_303 = caml_call2(Base[140], sexp_of_t$6, arg1_301);
           return [1, [0, res0_302, [0, res1_303, 0]]];
          },
        res0_305 = caml_call2(Base[140], _dg_, arg0_304);
       return [1, [0, _B_, [0, res0_305, 0]]];
      case 4:
       var
        arg0_306 = param[1],
        res0_307 = caml_call2(Base[140], sexp_of_t$6, arg0_306);
       return [1, [0, _C_, [0, res0_307, 0]]];
      case 5:
       var
        arg0_312 = param[1],
        arg1_309 = arg0_312[2],
        arg0_308 = arg0_312[1],
        res0_310 = caml_call1(sexp_of_t, arg0_308),
        _dh_ =
          function(param){
           if(-59723313 <= param[1]){
            var
             v_245 = param[2],
             arg1_247 = v_245[2],
             arg0_246 = v_245[1],
             res0_248 = caml_call1(Base[165], arg0_246),
             res1_249 = caml_call2(Base[153], sexp_of_t$6, arg1_247);
            return [1, [0, _s_, [0, [1, [0, res0_248, [0, res1_249, 0]]], 0]]];
           }
           var
            v_250 = param[2],
            arg1_252 = v_250[2],
            arg0_251 = v_250[1],
            res0_253 = caml_call1(sexp_of_t, arg0_251),
            res1_254 = sexp_of_t$6(arg1_252);
           return [1, [0, _t_, [0, [1, [0, res0_253, [0, res1_254, 0]]], 0]]];
          },
        res1_311 = caml_call2(Base[140], _dh_, arg1_309),
        res0_313 = [1, [0, res0_310, [0, res1_311, 0]]];
       return [1, [0, _D_, [0, res0_313, 0]]];
      case 6:
       var
        arg0_318 = param[1],
        arg1_315 = arg0_318[2],
        arg0_314 = arg0_318[1],
        res0_316 = caml_call1(sexp_of_t, arg0_314),
        res1_317 = caml_call1(sexp_of_t$4, arg1_315),
        res0_319 = [1, [0, res0_316, [0, res1_317, 0]]];
       return [1, [0, _E_, [0, res0_319, 0]]];
      case 7:
       var
        arg1_321 = param[2],
        arg0_320 = param[1],
        res0_322 = caml_call1(sexp_of_t$3, arg0_320),
        res1_323 = caml_call2(Base[140], sexp_of_t$6, arg1_321);
       return [1, [0, _F_, [0, res0_322, [0, res1_323, 0]]]];
      default:
       var
        arg2_326 = param[3],
        arg1_325 = param[2],
        arg0_324 = param[1],
        members_275 = arg0_324[3],
        loc_273 = arg0_324[2],
        gid_271 = arg0_324[1],
        bnds_270 = 0,
        _de_ =
          function(param){
           var
            arg1_282 = param[2],
            arg0_281 = param[1],
            res0_283 = caml_call1(sexp_of_t$3, arg0_281),
            arg1_278 = arg1_282[2],
            arg0_277 = arg1_282[1],
            res0_279 = caml_call2(Base[140], sexp_of_t$4, arg0_277),
            res1_280 = sexp_of_t$6(arg1_278),
            res1_284 = [1, [0, res0_279, [0, res1_280, 0]]];
           return [1, [0, res0_283, [0, res1_284, 0]]];
          },
        arg_276 = caml_call2(Base[140], _de_, members_275),
        bnds_270$0 = [0, [1, [0, _u_, [0, arg_276, 0]]], bnds_270],
        arg_274 = caml_call1(sexp_of_t, loc_273),
        bnds_270$1 = [0, [1, [0, _v_, [0, arg_274, 0]]], bnds_270$0],
        arg_272 = caml_call1(sexp_of_t$5, gid_271),
        bnds_270$2 = [0, [1, [0, _w_, [0, arg_272, 0]]], bnds_270$1],
        res0_327 = [1, bnds_270$2],
        res1_328 = caml_call1(sexp_of_t$3, arg1_325),
        res2_329 = caml_call2(Base[140], sexp_of_t$6, arg2_326);
       return [1, [0, _G_, [0, res0_327, [0, res1_328, [0, res2_329, 0]]]]];
    }
   }
   function constr(s, t){return [0, -59723313, [0, s, t]];}
   function inherit(loc, t){return [0, -72987685, [0, loc, t]];}
   function var$4(loc, t){return [6, [0, loc, t]];}
   function poly_variant$1(loc, xs){return [5, [0, loc, xs]];}
   function is_cyclic_0(via_VR, group, tid){
    var set = [0, 0];
    function visited(tid){
     return caml_call3(Base_List[6], set[1], tid, equal$0);
    }
    function trav(param){
     var param$0 = param;
     for(;;){
      switch(param$0[0]){
        case 0:
         var t = param$0[2], param$0 = t; continue;
        case 1:
         var ts = param$0[2]; break;
        case 2:
         var xs = param$0[1];
         if(! via_VR) return 0;
         var _db_ = function(param){var t = param[2]; return trav(t);};
         return caml_call2(Base_List[9], xs, _db_);
        case 3:
         var xs$0 = param$0[1];
         if(! via_VR) return 0;
         var
          _dc_ =
            function(param){
             var ts = param[2];
             return caml_call2(Base_List[9], ts, trav);
            };
         return caml_call2(Base_List[9], xs$0, _dc_);
        case 4:
         var ts = param$0[1]; break;
        case 5:
         var
          cs = param$0[1][2],
          _dd_ =
            function(param){
             if(-59723313 > param[1]){
              var t$0 = param[2][2];
              return trav(t$0);
             }
             var match = param[2][2];
             if(! match) return 0;
             var t = match[1];
             return trav(t);
            };
         return caml_call2(Base_List[9], cs, _dd_);
        case 6:
         return 0;
        case 7:
         var ts$0 = param$0[2], tid = param$0[1];
         if(! visited(tid)){set[1] = [0, tid, set[1]]; trav_tid(tid);}
         return caml_call2(Base_List[9], ts$0, trav);
        default: var ts = param$0[3];
      }
      return caml_call2(Base_List[9], ts, trav);
     }
    }
    function trav_tid(tid){
     var body = lookup(group, tid)[2];
     return trav(body);
    }
    trav_tid(tid);
    var res = visited(tid);
    return res;
   }
   var _H_ = 1, _I_ = 0;
   function Evaluation(Canonical){
    var func = Base_List[10], _P_ = caml_call1(Base_Map[6], [0, comparator]);
    function _Q_(t, param){
     var v = param[2], k = param[1];
     return caml_call3(Base_Map[28], t, k, v);
    }
    function create(_da_){return caml_call3(func, _da_, _P_, _Q_);}
    function lookup$0(t, k){return caml_call2(Base_Map[36], t, k);}
    var Venv = [0, lookup$0, create];
    function compare(a_330, b_331){
     var
      t_333 = a_330[2],
      t_332 = a_330[1],
      t_335 = b_331[2],
      t_334 = b_331[1],
      n = caml_call2(compare$2, t_332, t_334);
     return 0 === n ? caml_call2(compare$1, t_333, t_335) : n;
    }
    function sexp_of_t(param){
     var
      arg1_337 = param[2],
      arg0_336 = param[1],
      res0_338 = caml_call1(sexp_of_t$5, arg0_336),
      res1_339 = caml_call1(sexp_of_t$3, arg1_337);
     return [1, [0, res0_338, [0, res1_339, 0]]];
    }
    var
     T = [0, compare, sexp_of_t],
     include = caml_call1(Base_Comparator[5], T),
     comparator$0 = include[1];
    function find(t, k){return caml_call2(Base_Map[36], t, k);}
    var empty = caml_call1(Base_Map[6], [0, comparator$0]);
    function extend(t, k, v){return caml_call3(Base_Map[28], t, k, v);}
    var Tenv = [0, find, empty, extend];
    function return$0(x, param, tenv){return x;}
    function bind(t, f, depth, tenv){
     var x = caml_call2(t, depth, tenv);
     return caml_call2(caml_call1(f, x), depth, tenv);
    }
    function look_env(key, param, tenv){
     var result = Tenv[1].call(null, tenv, key);
     function _c$_(param){var x = param[2]; return [0, x];}
     return caml_call2(Base_Option[21], result, _c$_);
    }
    function extend_new_tid(key, def_t, depth, tenv){
     var
      value = [0, -271630457, depth],
      tenv$0 = Tenv[3].call(null, tenv, key, value);
     return [1, caml_call2(def_t, depth + 1 | 0, tenv$0)];
    }
    function exec(t){return caml_call2(t, 0, Tenv[2]);}
    var
     Defining = [0, return$0, bind, look_env, extend_new_tid, exec],
     symbol_bind = Defining[2],
     return$1 = Defining[1];
    function sequence_defining(xs, f){
     function loop(acc_ys, param){
      if(param){
       var
        xs = param[2],
        x = param[1],
        _c0_ = function(y){return loop([0, y, acc_ys], xs);},
        _c1_ = caml_call1(f, x);
       return function(_c7_, _c8_){
        var _c__ = _c8_, _c9_ = _c7_;
        return symbol_bind(_c1_, _c0_, _c9_, _c__);};
      }
      var _c2_ = caml_call1(Base_List[38], acc_ys);
      return function(_c3_, _c4_){
       var _c6_ = _c4_, _c5_ = _c3_;
       return return$1(_c2_, _c5_, _c6_);};
     }
     return loop(0, xs);
    }
    function _R_(group, venv, t){
     switch(t[0]){
       case 0:
        var
         t$0 = t[2],
         s = t[1],
         _bi_ =
           function(v){
            var _cV_ = caml_call2(Canonical[4][1], s, v);
            return function(_cW_, _cX_){
             var _cZ_ = _cX_, _cY_ = _cW_;
             return return$1(_cV_, _cY_, _cZ_);};
           },
         _bj_ = _R_(group, venv, t$0);
        return function(_cR_, _cS_){
         var _cU_ = _cS_, _cT_ = _cR_;
         return symbol_bind(_bj_, _bi_, _cT_, _cU_);};
       case 1:
        var
         ts = t[2],
         s$0 = t[1],
         _bk_ =
           function(vs){
            var _cM_ = caml_call2(Canonical[4][2], s$0, vs);
            return function(_cN_, _cO_){
             var _cQ_ = _cO_, _cP_ = _cN_;
             return return$1(_cM_, _cP_, _cQ_);};
           },
         _bl_ = eval_list(group, venv, ts);
        return function(_cI_, _cJ_){
         var _cL_ = _cJ_, _cK_ = _cI_;
         return symbol_bind(_bl_, _bk_, _cK_, _cL_);};
       case 2:
        var
         binds = t[1],
         _bm_ =
           function(binds){
            var _cD_ = caml_call1(Canonical[4][9], binds);
            return function(_cE_, _cF_){
             var _cH_ = _cF_, _cG_ = _cE_;
             return return$1(_cD_, _cG_, _cH_);};
           },
         _bn_ =
           sequence_defining
            (binds,
             function(param){
              var x = param[2], s = param[1];
              function _cs_(y){
               var _cy_ = [0, s, y];
               return function(_cz_, _cA_){
                var _cC_ = _cA_, _cB_ = _cz_;
                return return$1(_cy_, _cB_, _cC_);};
              }
              var _ct_ = _R_(group, venv, x);
              return function(_cu_, _cv_){
               var _cx_ = _cv_, _cw_ = _cu_;
               return symbol_bind(_ct_, _cs_, _cw_, _cx_);};
             });
        return function(_co_, _cp_){
         var _cr_ = _cp_, _cq_ = _co_;
         return symbol_bind(_bn_, _bm_, _cq_, _cr_);};
       case 3:
        var
         alts = t[1],
         _bo_ =
           function(alts){
            var _cj_ = caml_call1(Canonical[4][10], alts);
            return function(_ck_, _cl_){
             var _cn_ = _cl_, _cm_ = _ck_;
             return return$1(_cj_, _cm_, _cn_);};
           },
         _bp_ =
           sequence_defining
            (alts,
             function(param){
              var xs = param[2], s = param[1];
              function _b__(ys){
               var _ce_ = [0, s, ys];
               return function(_cf_, _cg_){
                var _ci_ = _cg_, _ch_ = _cf_;
                return return$1(_ce_, _ch_, _ci_);};
              }
              var _b$_ = eval_list(group, venv, xs);
              return function(_ca_, _cb_){
               var _cd_ = _cb_, _cc_ = _ca_;
               return symbol_bind(_b$_, _b__, _cc_, _cd_);};
             });
        return function(_b6_, _b7_){
         var _b9_ = _b7_, _b8_ = _b6_;
         return symbol_bind(_bp_, _bo_, _b8_, _b9_);};
       case 4:
        var
         ts$0 = t[1],
         _bq_ =
           function(vs){
            var _b1_ = caml_call1(Canonical[4][3], vs);
            return function(_b2_, _b3_){
             var _b5_ = _b3_, _b4_ = _b2_;
             return return$1(_b1_, _b4_, _b5_);};
           },
         _br_ = eval_list(group, venv, ts$0);
        return function(_bX_, _bY_){
         var _b0_ = _bY_, _bZ_ = _bX_;
         return symbol_bind(_br_, _bq_, _bZ_, _b0_);};
       case 5:
        var
         match = t[1],
         cs = match[2],
         loc = match[1],
         _bs_ =
           function(xss){
            var
             _bR_ = caml_call1(Base_List[138], xss),
             _bS_ = caml_call2(Canonical[4][4], loc, _bR_);
            return function(_bT_, _bU_){
             var _bW_ = _bU_, _bV_ = _bT_;
             return return$1(_bS_, _bV_, _bW_);};
           },
         _bt_ =
           sequence_defining
            (cs, function(_bQ_){return eval_poly_constr(group, venv, _bQ_);});
        return function(_bM_, _bN_){
         var _bP_ = _bN_, _bO_ = _bM_;
         return symbol_bind(_bt_, _bs_, _bO_, _bP_);};
       case 6:
        var
         match$0 = t[1],
         vid = match$0[2],
         loc$0 = match$0[1],
         match$1 = Venv[1].call(null, venv, vid);
        if(match$1){
         var x = match$1[1];
         return function(_bI_, _bJ_){
          var _bL_ = _bJ_, _bK_ = _bI_;
          return return$1(x, _bK_, _bL_);};
        }
        var _bu_ = 0, _bv_ = 0;
        return caml_call2
                (eval_fail
                  (loc$0,
                   [0,
                    [11,
                     cst_Free_type_variable,
                     [24,
                      _J_,
                      function(param, custom_printf_340){
                       return caml_call1(to_string$3, custom_printf_340);
                      },
                      _bv_]],
                    cst_Free_type_variable_Vid]),
                 vid,
                 _bu_);
       case 7:
        var
         args = t[2],
         tid = t[1],
         _bw_ = function(args){return eval_app(group, tid, args);},
         _bx_ = eval_list(group, venv, args);
        return function(_bE_, _bF_){
         var _bH_ = _bF_, _bG_ = _bE_;
         return symbol_bind(_bx_, _bw_, _bG_, _bH_);};
       default:
        var
         args$0 = t[3],
         tid$0 = t[2],
         in_group = t[1],
         _by_ = function(args){return eval_app(in_group, tid$0, args);},
         _bz_ = eval_list(group, venv, args$0);
        return function(_bA_, _bB_){
         var _bD_ = _bB_, _bC_ = _bA_;
         return symbol_bind(_bz_, _by_, _bC_, _bD_);};
     }
    }
    function eval_list(group, venv, ts){
     return sequence_defining
             (ts, function(_bh_){return _R_(group, venv, _bh_);});
    }
    function eval_poly_constr(group, venv, c){
     if(-59723313 > c[1]){
      var
       match$0 = c[2],
       t$0 = match$0[2],
       loc = match$0[1],
       _aV_ =
         function(v){
          var match = caml_call1(Canonical[2][5], v);
          if(0 === match[0]){
           var tab = match[1], _bc_ = tab[1];
           return function(_bd_, _be_){
            var _bg_ = _be_, _bf_ = _bd_;
            return return$1(_bc_, _bf_, _bg_);};
          }
          var desc = match[1];
          return caml_call2(eval_fail(loc, _K_), desc, 0);
         },
       _aW_ = _R_(group, venv, t$0);
      return function(_a__, _a$_){
       var _bb_ = _a$_, _ba_ = _a__;
       return symbol_bind(_aW_, _aV_, _ba_, _bb_);};
     }
     var _aR_ = c[2], match = _aR_[2], s = _aR_[1];
     if(match){
      var
       t = match[1],
       _aS_ =
         function(v){
          var _a5_ = [0, [0, s, [0, caml_call1(Canonical[2][4], v)]], 0];
          return function(_a6_, _a7_){
           var _a9_ = _a7_, _a8_ = _a6_;
           return return$1(_a5_, _a8_, _a9_);};
         },
       _aT_ = _R_(group, venv, t);
      return function(_a1_, _a2_){
       var _a4_ = _a2_, _a3_ = _a1_;
       return symbol_bind(_aT_, _aS_, _a3_, _a4_);};
     }
     var _aU_ = [0, [0, s, 0], 0];
     return function(_aX_, _aY_){
      var _a0_ = _aY_, _aZ_ = _aX_;
      return return$1(_aU_, _aZ_, _a0_);};
    }
    function eval_definition(group, formals, body){
     function _aE_(i, x){return [0, x, caml_call1(Canonical[2][1], i)];}
     var
      _aF_ = caml_call2(Base_List[96], formals, _aE_),
      venv = Venv[2].call(null, _aF_);
     function _aG_(v){
      var _aM_ = caml_call1(Canonical[4][8], v);
      return function(_aN_, _aO_){
       var _aQ_ = _aO_, _aP_ = _aN_;
       return return$1(_aM_, _aP_, _aQ_);};
     }
     var _aH_ = _R_(group, venv, body);
     return function(_aI_, _aJ_){
      var _aL_ = _aJ_, _aK_ = _aI_;
      return symbol_bind(_aH_, _aG_, _aK_, _aL_);};
    }
    function eval_app(group, tid, args){
     var
      gid = group[1],
      match = lookup(group, tid),
      body = match[2],
      formals = match[1];
     switch(body[0]){
       case 2:
       case 3:
        var record_or_normal_variant = 1; break;
       default: var record_or_normal_variant = 0;
     }
     var
      cyclic = is_cyclic_0(_H_, group, tid),
      cyclic_no_VR = is_cyclic_0(_I_, group, tid);
     a:
     {
      if(record_or_normal_variant && cyclic) break a;
      if(! cyclic_no_VR){
       var match$0 = caml_call2(Base_List[94], formals, args);
       if(match$0)
        var x = match$0[1], venv = Venv[2].call(null, x);
       else
        var venv = caml_call1(Base[201], cst_apply_incorrect_type_appli);
       return _R_(group, venv, body);
      }
     }
     function _T_(param){
      if(0 === param[0]){
       var r = param[1], _au_ = caml_call2(Canonical[2][2], r, args);
       return function(_aA_, _aB_){
        var _aD_ = _aB_, _aC_ = _aA_;
        return return$1(_au_, _aC_, _aD_);};
      }
      var def = param[1], _av_ = caml_call2(Canonical[2][3], def, args);
      return function(_aw_, _ax_){
       var _az_ = _ax_, _ay_ = _aw_;
       return return$1(_av_, _ay_, _az_);};
     }
     function _U_(param){
      if(param){
       var recurse = param[1];
       return function(_aq_, _ar_){
        var _at_ = _ar_, _as_ = _aq_;
        return return$1(recurse, _as_, _at_);};
      }
      var
       _aj_ = eval_definition(group, formals, body),
       _ak_ = [0, gid, tid],
       _al_ = Defining[4];
      return function(_am_, _an_){
       var _ap_ = _an_, _ao_ = _am_;
       return _al_(_ak_, _aj_, _ao_, _ap_);};
     }
     var _V_ = [0, gid, tid], _W_ = Defining[3];
     function _X_(_af_, _ag_){
      var _ai_ = _ag_, _ah_ = _af_;
      return _W_(_V_, _ah_, _ai_);
     }
     function _Y_(_ab_, _ac_){
      var _ae_ = _ac_, _ad_ = _ab_;
      return symbol_bind(_X_, _U_, _ad_, _ae_);
     }
     return function(_Z_, ___){
      var _aa_ = ___, _$_ = _Z_;
      return symbol_bind(_Y_, _T_, _$_, _aa_);};
    }
    function eval$0(t){
     var
      group = create$3(caml_call1(of_string, cst_top_level), 0),
      venv = Venv[2].call(null, 0),
      _S_ = _R_(group, venv, t),
      v = Defining[5].call(null, _S_);
     return caml_call1(Canonical[4][11], v);
    }
    return [0, , , , , , , , , , , , eval$0];
   }
   var
    Exp = [0],
    include = Evaluation([0, to_digest$2, Exp1, Def$0, Create]),
    eval$0 = include[12],
    Evaluation_to_digest = Evaluation(Canonical_digest);
   function eval_to_digest(exp){
    var _O_ = Evaluation_to_digest[12].call(null, exp);
    return caml_call1(Canonical_digest[1], _O_);
   }
   function eval_to_digest_string(exp){
    return caml_call1(to_hex, eval_to_digest(exp));
   }
   var
    Not_a_tuple =
      [248, cst_Bin_shape_lib_Bin_shape_Fo, runtime.caml_fresh_oo_id(0)];
   function _L_(param){
    if(param[1] !== Not_a_tuple)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
    var arg0_341 = param[2], res0_342 = sexp_of_t$6(arg0_341);
    return [1, [0, _M_, [0, res0_342, 0]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Not_a_tuple, _L_);
   function deconstruct_tuple_exn(t){
    if(4 !== t[0]) throw caml_maybe_attach_backtrace([0, Not_a_tuple, t], 1);
    var ts = t[1];
    return ts;
   }
   var
    Bin_shape_lib_Bin_shape =
      [0,
       sexp_of_t$6,
       [0, of_string$1],
       [0, of_string$2],
       [0, of_string],
       [0, of_string$0],
       create$3,
       tuple$1,
       record$1,
       variant$1,
       constr,
       inherit,
       poly_variant$1,
       rec_app,
       top_app,
       var$4,
       basetype$1,
       annotate$1,
       [0, compare$0, t_of_sexp$0, sexp_of_t$1, to_hex, to_md5, of_md5],
       [0,
        compare_t0,
        sexp_of_t0,
        to_string_hum,
        to_digest$2,
        Exp,
        Def$0,
        [0,
         Create[1],
         Create[2],
         Create[3],
         Create[4],
         Create[5],
         Create[7],
         Create[6],
         Create[8],
         Create[9],
         Create[10],
         Create[11]]],
       eval$0,
       eval_to_digest,
       eval_to_digest_string,
       [0, deconstruct_tuple_exn]];
   runtime.caml_register_global
    (133, Bin_shape_lib_Bin_shape, "Bin_shape_lib__Bin_shape");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Std
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib_Std = [0];
   runtime.caml_register_global(0, Bin_shape_lib_Std, "Bin_shape_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiaW5fc2hhcGVfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJvcl9zb3VyY2VfMDI2IiwiZXJyb3Jfc291cmNlXzA0MiIsImVycm9yX3NvdXJjZV8yMDYiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJ0X29mX3NleHAiLCJzZXhwX29mX3QkMCIsIm9mX3N0cmluZyQwIiwidG9fc3RyaW5nJDAiLCJjb21wYXJlIiwiZXZhbF9mYWlsIiwibG9jIiwiZm10IiwicyIsImN1c3RvbV9wcmludGZfMDAxIiwiZXF1YWxfb3B0aW9uIiwiZXF1YWwiLCJhIiwiYiIsInkiLCJ4IiwiY3JlYXRlIiwiZXEiLCJ4cyQxIiwiczIiLCJzMSIsInNvcnRlZCIsInhzJDAiLCJsYXN0X3ZhbHVlJDEiLCJsYXN0X2tleSQxIiwiYWNjIiwibGFzdF9rZXkiLCJsYXN0X3ZhbHVlIiwieHMiLCJsYXN0X3ZhbHVlJDAiLCJsYXN0X2tleSQwIiwic29ydGVkJDAiLCJtYXAiLCJ0IiwiZiIsInYiLCJrIiwidG9fbWQ1Iiwib2ZfbWQ1Iiwic2V4cF9vZl90JDEiLCJ0X29mX3NleHAkMCIsInV1aWQiLCJ1IiwiaW50JDAiLCJwYWlyIiwibGlzdCIsImwiLCJjb25zdHJ1Y3RvciIsInRfb2Zfc2V4cCQxIiwib2ZfYV8wMzkiLCJzZXhwXzA0NCIsInRhZ18wNDUiLCJzZXhwX2FyZ3NfMDQ2IiwiYXJnMV8wNDgiLCJhcmcwXzA0NyIsInJlczBfMDQ5IiwicmVzMV8wNTAiLCJzZXhwX2FyZ3NfMDkwIiwiYXJnMV8wOTIiLCJhcmcwXzA5MSIsInJlczBfMDkzIiwicmVzMV8wOTQiLCJzZXhwX2FyZ3NfMDUzIiwiYXJnMV8wNTUiLCJhcmcwXzA1NCIsInJlczBfMDU2IiwicmVzMV8wNTciLCJzZXhwX2FyZ3NfMDg1IiwiYXJnMF8wODYiLCJvZl9hXzAxMCIsInJlczBfMDg3IiwiZmllbGRfc2V4cHNfMDEzIiwic29ydGVkXzAxNCIsImR1cGxpY2F0ZXNfMDE2IiwiZXh0cmFfMDE3Iiwic2V4cF8wMTIiLCJmaWVsZF9zZXhwc18wMjAiLCJmaWVsZF9uYW1lXzAxOCIsInRhaWxfMDI5IiwieF8wMzAiLCJmaWVsZF9zZXhwXzAxOSIsInNleHBfMDI1IiwiYXJnMV8wMjIiLCJhcmcwXzAyMSIsInJlczBfMDIzIiwicmVzMV8wMjQiLCJmdmFsdWVfMDI3Iiwic29ydGVkXzAxNSIsInNleHBfYXJnc18wOTciLCJhcmcxXzA5OSIsImFyZzBfMDk4IiwicmVzMF8xMDAiLCJyZXMxXzEwMSIsInNleHBfYXJnc18wNjUiLCJhcmcwXzA3MSIsInNleHBfMDcwIiwiYXJnMV8wNjciLCJhcmcwXzA2NiIsInJlczBfMDY4IiwicmVzMV8wNjkiLCJyZXMwXzA3MiIsInNleHBfYXJnc18wNjAiLCJhcmcwXzA2MSIsInJlczBfMDYyIiwic2V4cF9hcmdzXzEwNCIsImFyZzBfMTA1IiwicmVzMF8xMDYiLCJzZXhwX2FyZ3NfMDc1IiwiYXJnMF8wODEiLCJzZXhwXzA4MCIsImFyZzFfMDc3IiwiYXJnMF8wNzYiLCJyZXMwXzA3OCIsInJlczFfMDc5IiwicmVzMF8wODIiLCJzZXhwX29mX3QkMiIsIm9mX2FfMTA4IiwiYXJnMV8xMTAiLCJhcmcwXzEwOSIsInJlczBfMTExIiwicmVzMV8xMTIiLCJhcmcxXzExNCIsImFyZzBfMTEzIiwicmVzMF8xMTUiLCJyZXMxXzExNiIsImFyZzBfMTE3IiwicmVzMF8xMTgiLCJhcmcwXzEyMyIsImFyZzFfMTIwIiwiYXJnMF8xMTkiLCJyZXMwXzEyMSIsInJlczFfMTIyIiwicmVzMF8xMjQiLCJhcmcwXzEyOSIsImFyZzFfMTI2IiwiYXJnMF8xMjUiLCJyZXMwXzEyNyIsInJlczFfMTI4IiwicmVzMF8xMzAiLCJhcmcwXzEzMSIsIm9mX2FfMDMxIiwic29ydGVkXzAzMyIsImJuZHNfMDMyIiwiYXJnMV8wMzYiLCJhcmcwXzAzNSIsInJlczBfMDM3IiwicmVzMV8wMzgiLCJhcmdfMDM0IiwiYm5kc18wMzIkMCIsInJlczBfMTMyIiwiYXJnMV8xMzQiLCJhcmcwXzEzMyIsInJlczBfMTM1IiwicmVzMV8xMzYiLCJhcmcxXzEzOCIsImFyZzBfMTM3IiwicmVzMF8xMzkiLCJyZXMxXzE0MCIsImFyZzBfMTQxIiwicmVzMF8xNDIiLCJtYXAkMCIsIngkMCIsImwkMCIsImwkMSIsIngkMSIsImwkMiIsInQkMCIsInRvX3N0cmluZyQxIiwiZGlnZXN0X2xheWVyIiwidSQwIiwidGFibGUiLCJsJDMiLCJsJDQiLCJuIiwibiQwIiwidG9fZGlnZXN0IiwidG9fZGlnZXN0JDAiLCJ4JDIiLCJvcGFxdWUiLCJjcmVhdGUkMCIsImRlc2MiLCJ2YXIkMCIsImFwcGx5IiwiZGVmIiwicmVjdXJzZSIsInRpZCIsImdldF9wb2x5X3ZhcmlhbnQiLCJhbm5vdGF0ZSIsImJhc2V0eXBlIiwidHVwbGUiLCJwb2x5X3ZhcmlhbnQiLCJ2YXIkMSIsImFwcGx5JDAiLCJyZWN1cnNlJDAiLCJkZWZpbmUiLCJyZWNvcmQiLCJ2YXJpYW50IiwiY3JlYXRlJDEiLCJlIiwiY29tcGFyZV90MCIsImFfMTk4IiwiYl8xOTkiLCJiXzIwMSIsImFfMjAwIiwiY21wX2EiLCJhXzIwMiIsImJfMjAzIiwiYV8xNDYiLCJiXzE0OSIsImJfMTQ3IiwiYV8xNDgiLCJhXzE1MiIsImFfMTUwIiwiYl8xNTMiLCJiXzE1MSIsImFfMTU0IiwiYl8xNTUiLCJhXzE1NiIsImJfMTU3IiwiYV8xNTgiLCJiXzE1OSIsImFfMTYwIiwiYl8xNjEiLCJhXzE2MiIsImJfMTYzIiwidF8xNjUiLCJ0XzE2NCIsInRfMTY3IiwidF8xNjYiLCJhXzE2OCIsImJfMTY5IiwiYV8xNzAiLCJiXzE3MSIsInRfMTczIiwidF8xNzIiLCJ0XzE3NSIsInRfMTc0IiwiYV8xNzYiLCJiXzE3NyIsImFfMDAyIiwiYl8xNzkiLCJhXzAwNCIsImJfMDA1IiwidF8wMDciLCJ0XzAwNiIsInRfMDA5IiwidF8wMDgiLCJhXzE4MiIsImJfMTgzIiwiYV8xODYiLCJhXzE4NCIsImJfMTg3IiwiYl8xODUiLCJuJDEiLCJhXzE4OCIsImJfMTg5IiwiYV8xOTIiLCJhXzE5MCIsImJfMTkzIiwiYl8xOTEiLCJuJDIiLCJhXzE5NCIsImJfMTk1IiwiYV8xOTYiLCJiXzE5NyIsInQwX29mX3NleHAiLCJzZXhwXzIwOCIsInRhZ18yMDkiLCJzZXhwX2FyZ3NfMjEwIiwiYXJnMF8yMTEiLCJyZXMwXzIxMiIsInNleHBfb2ZfdDAiLCJhcmcwXzIxMyIsInJlczBfMjE0IiwiZXF1YWxfdDAiLCJ2YXIkMiIsImFwcGx5JDEiLCJkIiwicmVjdXJzZSQxIiwiciIsImdldF9wb2x5X3ZhcmlhbnQkMCIsImNjIiwidGFiIiwib3BhcXVlJDAiLCJ0b19kaWdlc3QkMSIsInRvX2RpZ2VzdCQyIiwiYW5ub3RhdGUkMCIsImJhc2V0eXBlJDAiLCJ0dXBsZSQwIiwicG9seV92YXJpYW50JDAiLCJ2YXIkMyIsInJlY3Vyc2UkMiIsImFwcGx5JDIiLCJkZWZpbmUkMCIsInJlY29yZCQwIiwidmFyaWFudCQwIiwiY3JlYXRlJDIiLCJleHAiLCJ0b19zdHJpbmdfaHVtIiwic2V4cF9vZl90JDMiLCJvZl9zdHJpbmckMSIsInRvX3N0cmluZyQyIiwic3ltYm9sIiwiY29tcGFyZSQxIiwiZXF1YWwkMCIsInNleHBfb2ZfdCQ0Iiwib2Zfc3RyaW5nJDIiLCJ0b19zdHJpbmckMyIsImNvbXBhcmF0b3IiLCJjb21wYXJlJDIiLCJzZXhwX29mX3QkNSIsImNyZWF0ZSQzIiwidHJpcHMiLCJnaWQiLCJ2cyIsIm1lbWJlcnMiLCJsb29rdXAiLCJnIiwic2NoZW1lIiwiY3VzdG9tX3ByaW50Zl8yODUiLCJhbm5vdGF0ZSQxIiwidjAiLCJ2MSIsImJhc2V0eXBlJDEiLCJyZWNvcmQkMSIsInZhcmlhbnQkMSIsInR1cGxlJDEiLCJyZWNfYXBwIiwidG9wX2FwcCIsInYyIiwic2V4cF9vZl90JDYiLCJhcmcxXzI4NyIsImFyZzBfMjg2IiwicmVzMF8yODgiLCJyZXMxXzI4OSIsImFyZzFfMjkxIiwiYXJnMF8yOTAiLCJyZXMwXzI5MiIsInJlczFfMjkzIiwiYXJnMF8yOTgiLCJhcmcxXzI5NSIsImFyZzBfMjk0IiwicmVzMF8yOTYiLCJyZXMxXzI5NyIsInJlczBfMjk5IiwiYXJnMF8zMDQiLCJhcmcxXzMwMSIsImFyZzBfMzAwIiwicmVzMF8zMDIiLCJyZXMxXzMwMyIsInJlczBfMzA1IiwiYXJnMF8zMDYiLCJyZXMwXzMwNyIsImFyZzBfMzEyIiwiYXJnMV8zMDkiLCJhcmcwXzMwOCIsInJlczBfMzEwIiwidl8yNDUiLCJhcmcxXzI0NyIsImFyZzBfMjQ2IiwicmVzMF8yNDgiLCJyZXMxXzI0OSIsInZfMjUwIiwiYXJnMV8yNTIiLCJhcmcwXzI1MSIsInJlczBfMjUzIiwicmVzMV8yNTQiLCJyZXMxXzMxMSIsInJlczBfMzEzIiwiYXJnMF8zMTgiLCJhcmcxXzMxNSIsImFyZzBfMzE0IiwicmVzMF8zMTYiLCJyZXMxXzMxNyIsInJlczBfMzE5IiwiYXJnMV8zMjEiLCJhcmcwXzMyMCIsInJlczBfMzIyIiwicmVzMV8zMjMiLCJhcmcyXzMyNiIsImFyZzFfMzI1IiwiYXJnMF8zMjQiLCJtZW1iZXJzXzI3NSIsImxvY18yNzMiLCJnaWRfMjcxIiwiYm5kc18yNzAiLCJhcmcxXzI4MiIsImFyZzBfMjgxIiwicmVzMF8yODMiLCJhcmcxXzI3OCIsImFyZzBfMjc3IiwicmVzMF8yNzkiLCJyZXMxXzI4MCIsInJlczFfMjg0IiwiYXJnXzI3NiIsImJuZHNfMjcwJDAiLCJhcmdfMjc0IiwiYm5kc18yNzAkMSIsImFyZ18yNzIiLCJibmRzXzI3MCQyIiwicmVzMF8zMjciLCJyZXMxXzMyOCIsInJlczJfMzI5IiwiY29uc3RyIiwiaW5oZXJpdCIsInZhciQ0IiwicG9seV92YXJpYW50JDEiLCJpc19jeWNsaWNfMCIsInZpYV9WUiIsImdyb3VwIiwic2V0IiwidmlzaXRlZCIsInRyYXYiLCJ0cyIsImNzIiwidHMkMCIsInRyYXZfdGlkIiwiYm9keSIsInJlcyIsImxvb2t1cCQwIiwiYV8zMzAiLCJiXzMzMSIsInRfMzMzIiwidF8zMzIiLCJ0XzMzNSIsInRfMzM0IiwiYXJnMV8zMzciLCJhcmcwXzMzNiIsInJlczBfMzM4IiwicmVzMV8zMzkiLCJmaW5kIiwiZW1wdHkiLCJleHRlbmQiLCJyZXR1cm4kMCIsInRlbnYiLCJiaW5kIiwiZGVwdGgiLCJsb29rX2VudiIsImtleSIsInJlc3VsdCIsImV4dGVuZF9uZXdfdGlkIiwiZGVmX3QiLCJ2YWx1ZSIsInRlbnYkMCIsImV4ZWMiLCJzeW1ib2xfYmluZCIsInJldHVybiQxIiwic2VxdWVuY2VfZGVmaW5pbmciLCJsb29wIiwiYWNjX3lzIiwidmVudiIsInMkMCIsImV2YWxfbGlzdCIsImJpbmRzIiwiYWx0cyIsInlzIiwieHNzIiwiZXZhbF9wb2x5X2NvbnN0ciIsInZpZCIsImxvYyQwIiwiY3VzdG9tX3ByaW50Zl8zNDAiLCJhcmdzIiwiZXZhbF9hcHAiLCJhcmdzJDAiLCJ0aWQkMCIsImluX2dyb3VwIiwiYyIsImV2YWxfZGVmaW5pdGlvbiIsImZvcm1hbHMiLCJpIiwicmVjb3JkX29yX25vcm1hbF92YXJpYW50IiwiY3ljbGljIiwiY3ljbGljX25vX1ZSIiwiZXZhbCQwIiwiZXZhbF90b19kaWdlc3QiLCJldmFsX3RvX2RpZ2VzdF9zdHJpbmciLCJkZWNvbnN0cnVjdF90dXBsZV9leG4iXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jpbl9wcm90L3NoYXBlL2Jpbl9zaGFwZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvb2NhbWwvc3RyaW5nLm1saSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lBZ0NFQTtJQW1FQUM7SUFtT0VDOzs7Ozs7Ozs7Ozs7OztJQ3JUSUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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U0F5R1d0UTs7TUFFOEI7T0FBQSxPQXZCekMyUixnQkFNRTFELE9BRUUyRCxTQUFTbkQ7T0FlaUIsV0FoQjFCeEcsS0FESWhJOztNQWlCaUM7OztLQUFxQztLQUoxRCxJQUFBLFVBWmhCZ0ksS0FESWhJO0tBYU47Ozs7S0FBQTs7YUF4R0ZvUTs7S0E2R007O2FBN0dOQTtJQXNIdUI7YUFJdkI0QixPQUNFeGI7S0FDRjtNQUFJd1gsUUFoUkpsRyxTQWdSa0IsV0NodEJoQnpUO01EaXRCRW9jO01BQ2tCLFVBRmxCekMsT0FDQXlDLE1BRkZqYTtNQUdFRTtLQUNKLE9BQUEsNkJBRElBO0lBQ3FCO0lBek5hLGlDQW9OdENzYjs7R0FZUztJQUFBOzZCQTVhTDVMO0lBZ2FKNEw7O1lBcUJGQyxlQUFlakw7SUFBbUMsOENBQW5DQTtJQUFtQyxPQUFBO0dBQStCO1lBQ2pGa0wsc0JBQXNCbEw7SUFBTSxPQUFjLG1CQUQxQ2lMLGVBQ3NCakw7R0FBd0M7R0FHaEU7Ozs7STs7d0NBaFZPaUM7Ozs7WUFrVkhrSixzQkFBc0IzYjtJQUN4QixTQUR3QkEsTUFHakIsTUFBQSw2Q0FIaUJBO1FBRWhCNFgsS0FGZ0I1WDtJQUVWLE9BQU40WDtHQUNvQjs7OztPQXJWdkJuRjtXQ3ZaRDlCO1dBQUFNO1dBQUFwVDtXQUFBSTtPRGdjRnFUO09BZEplO09BQUFGO09BQUFDO09Ba0JJOEU7T0FDQUM7T0FFQUU7T0FyQkovRTtPQUFBQztPQW9CSTZFO09BRUFsRjtPQXRCSkg7c0JBaFhJeFIsYUFEQUQscUJBRkFGLFFBQ0FDOztRQTRPSmlLO1FBQUF3RTtRQUlBMkI7UUFGUWI7Ozs7Ozs7Ozs7Ozs7OztPQWdhSjRMO09BcUJGQztPQUNBQztXQUtFQzs7OztFOzs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2VcblxubW9kdWxlIExvY2F0aW9uIDogc2lnXG4gIGluY2x1ZGUgSWRlbnRpZmlhYmxlLlNcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuZW5kXG5cbm1vZHVsZSBVdWlkIDogc2lnXG4gIGluY2x1ZGUgSWRlbnRpZmlhYmxlLlNcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuZW5kXG5cbmxldCBldmFsX2ZhaWwgbG9jIGZtdCA9XG4gIFByaW50Zi5rc3ByaW50ZiAoZnVuIHMgLT4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmICFcIiV7TG9jYXRpb259OiAlc1wiIGxvYyBzKSkgZm10XG47O1xuXG5sZXQgZXF1YWxfb3B0aW9uIGVxdWFsIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFNvbWUgXywgTm9uZSB8IE5vbmUsIFNvbWUgXyAtPiBmYWxzZVxuICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCwgU29tZSB5IC0+IGVxdWFsIHggeVxuOztcblxubW9kdWxlIFNvcnRlZF90YWJsZSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICB2YWwgY3JlYXRlIDogTG9jYXRpb24udCAtPiBlcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKHN0cmluZyAqICdhKSBsaXN0IC0+ICdhIHRcbiAgdmFsIGV4cG9zZSA6ICdhIHQgLT4gKHN0cmluZyAqICdhKSBsaXN0XG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0geyBzb3J0ZWQgOiAoc3RyaW5nICogJ2EpIGxpc3QgfSBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGxldCBtZXJnZV9jaGVja19hZGphY2VudF9kdXBzXG4gICAgOiAgZXE6KCdhIC0+ICdhIC0+IGJvb2wpIC0+IChzdHJpbmcgKiAnYSkgbGlzdFxuICAgICAgLT4gWyBgT2sgb2YgKHN0cmluZyAqICdhKSBsaXN0IHwgYE1pc21hdGNoIG9mIHN0cmluZyBdXG4gICAgPVxuICAgIGZ1biB+ZXEgLT5cbiAgICBsZXQgcmVjIGxvb3AgYWNjIH5sYXN0X2tleSB+bGFzdF92YWx1ZSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGBPayAoTGlzdC5yZXYgYWNjKVxuICAgICAgfCAoa2V5LCB2YWx1ZSkgOjogeHMgLT5cbiAgICAgICAgaWYgU3RyaW5nLihsYXN0X2tleSA9IGtleSlcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmIGVxIGxhc3RfdmFsdWUgdmFsdWUgdGhlbiBsb29wIGFjYyB+bGFzdF9rZXkgfmxhc3RfdmFsdWUgeHMgZWxzZSBgTWlzbWF0Y2gga2V5XG4gICAgICAgIGVsc2UgbG9vcCAoKGtleSwgdmFsdWUpIDo6IGFjYykgfmxhc3Rfa2V5OmtleSB+bGFzdF92YWx1ZTp2YWx1ZSB4c1xuICAgIGluXG4gICAgZnVuY3Rpb25cbiAgICB8IFtdIC0+IGBPayBbXVxuICAgIHwgKGtleSwgdmFsdWUpIDo6IHhzIC0+IGxvb3AgWyBrZXksIHZhbHVlIF0gfmxhc3Rfa2V5OmtleSB+bGFzdF92YWx1ZTp2YWx1ZSB4c1xuICA7O1xuXG4gIGxldCBjcmVhdGUgbG9jIH5lcSB4cyA9XG4gICAgbGV0IHNvcnRlZCA9IExpc3Quc29ydCB+Y29tcGFyZTooZnVuIChzMSwgXykgKHMyLCBfKSAtPiBTdHJpbmcuY29tcGFyZSBzMSBzMikgeHMgaW5cbiAgICBtYXRjaCBtZXJnZV9jaGVja19hZGphY2VudF9kdXBzIH5lcSBzb3J0ZWQgd2l0aFxuICAgIHwgYE9rIHNvcnRlZCAtPiB7IHNvcnRlZCB9XG4gICAgfCBgTWlzbWF0Y2ggcyAtPlxuICAgICAgZXZhbF9mYWlsIGxvYyBcIkRpZmZlcmVudCBzaGFwZXMgZm9yIGR1cGxpY2F0ZWQgcG9seW1vcnBoaWMgY29uc3RydWN0b3I6IGAlc1wiIHMgKClcbiAgOztcblxuICBsZXQgZXhwb3NlIHQgPSB0LnNvcnRlZFxuICBsZXQgbWFwIHQgfmYgPSB7IHNvcnRlZCA9IExpc3QubWFwIHQuc29ydGVkIH5mOihmdW4gKGssIHYpIC0+IGssIGYgdikgfVxuZW5kXG5cbm1vZHVsZSBEaWdlc3QgOiBzaWdcbiAgdHlwZSB0ID0gTWQ1X2xpYi50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgdmFsIHRvX21kNSA6IHQgLT4gTWQ1X2xpYi50XG4gIHZhbCBvZl9tZDUgOiBNZDVfbGliLnQgLT4gdFxuICB2YWwgdG9faGV4IDogdCAtPiBzdHJpbmdcbiAgdmFsIGNvbnN0cnVjdG9yIDogc3RyaW5nIC0+IHQgbGlzdCAtPiB0XG4gIHZhbCBsaXN0IDogdCBsaXN0IC0+IHRcbiAgdmFsIHBhaXIgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgdmFsIHV1aWQgOiBVdWlkLnQgLT4gdFxuICB2YWwgaW50IDogaW50IC0+IHRcbiAgdmFsIG9wdGlvbiA6IHQgb3B0aW9uIC0+IHRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIE1kNV9saWJcblxuICBsZXQgdG9fbWQ1IHQgPSB0XG4gIGxldCBvZl9tZDUgdCA9IHRcbiAgbGV0IHNleHBfb2ZfdCB0ID0gdCB8PiB0b19oZXggfD4gc2V4cF9vZl9zdHJpbmdcbiAgbGV0IHRfb2Zfc2V4cCBzID0gcyB8PiBzdHJpbmdfb2Zfc2V4cCB8PiBvZl9oZXhfZXhuXG4gIGxldCB1dWlkIHUgPSBzdHJpbmcgKFV1aWQudG9fc3RyaW5nIHUpXG4gIGxldCBpbnQgeCA9IHN0cmluZyAoSW50LnRvX3N0cmluZyB4KVxuICBsZXQgcGFpciB4IHkgPSBzdHJpbmcgKHRvX2JpbmFyeSB4IF4gdG9fYmluYXJ5IHkpXG4gIGxldCBsaXN0IGwgPSBzdHJpbmcgKFN0cmluZy5jb25jYXQgfnNlcDpcIlwiIChMaXN0Lm1hcCB+Zjp0b19iaW5hcnkgbCkpXG4gIGxldCBjb25zdHJ1Y3RvciBzIGwgPSBzdHJpbmcgKHMgXiB0b19iaW5hcnkgKGxpc3QgbCkpXG5cbiAgbGV0IG9wdGlvbiA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IGNvbnN0cnVjdG9yIFwibm9uZVwiIFtdXG4gICAgfCBTb21lIHggLT4gY29uc3RydWN0b3IgXCJzb21lXCIgWyB4IF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3RvciA9IHN0cnVjdFxuICAoKiBbJ2EgdF0gaXMgYSBub24tcmVjdXJzaXZlIHR5cGUsIHVzZWQgdG8gcmVwcmVzZW50IDEtbGF5ZXIgb2YgZXhwcmVzc2lvbi4gIFRoZVxuICAgICByZWN1cnNpdmUga25vdCBpcyB0aWVkIGJlbG93IGluIFtDYW5vbmljYWxfZnVsbC5FeHAudF0uICopXG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBBbm5vdGF0ZSBvZiBVdWlkLnQgKiAnYVxuICAgIHwgQmFzZSBvZiBVdWlkLnQgKiAnYSBsaXN0XG4gICAgfCBUdXBsZSBvZiAnYSBsaXN0XG4gICAgfCBSZWNvcmQgb2YgKHN0cmluZyAqICdhKSBsaXN0XG4gICAgfCBWYXJpYW50IG9mIChzdHJpbmcgKiAnYSBsaXN0KSBsaXN0XG4gICAgKCogUG9seW1vcnBoaWMgdmFyaWFudHMgYXJlIGluc2Vuc2l0aXZlIHRvIHRoZSBvcmRlciB0aGUgY29uc3RydWN0b3JzIGFyZSBsaXN0ZWQgKilcbiAgICB8IFBvbHlfdmFyaWFudCBvZiAnYSBvcHRpb24gU29ydGVkX3RhYmxlLnRcbiAgICAoKiBMZWZ0LWhhbmQtc2lkZSBvZiBbQXBwbGljYXRpb25dIGlzIGEgcG90ZW50aWFsbHkgcmVjdXJzaXZlIGRlZmluaXRpb246IGl0XG4gICAgICAgY2FuIHJlZmVyIHRvIGl0c2VsZiB1c2luZyBbUmVjX2FwcCAoaSwgXyldIHdoZXJlIFtpXSBpcyB0aGUgZGVwdGggb2YgdGhpc1xuICAgICAgIGFwcGxpY2F0aW9uIG5vZGUgKGhvdyBtYW55IGFwcGxpY2F0aW9uIG5vZGVzIGFyZSBhYm92ZSBpdCkuXG4gICAgICAgSXQgYWxzbyBoYXMgaXRzIG93biBzY29wZSBvZiB0eXBlIHZhcmlhYmxlcyBzbyBpdCBjYW4gbm90IHJlZmVyIHRvIHR5cGUgdmFyaWFibGVzXG4gICAgICAgb2YgdGhlIGVuY2xvc2luZyBzY29wZS5cbiAgICAqKVxuICAgIHwgQXBwbGljYXRpb24gb2YgJ2EgKiAnYSBsaXN0XG4gICAgfCBSZWNfYXBwIG9mIGludCAqICdhIGxpc3RcbiAgICB8IFZhciBvZiBpbnRcbiAgW0BAZGVyaXZpbmcgc2V4cCwgY29tcGFyZV1cblxuICBsZXQgbWFwIHggfmYgPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgQW5ub3RhdGUgKHUsIHgpIC0+IEFubm90YXRlICh1LCBmIHgpXG4gICAgfCBCYXNlIChzLCB4cykgLT4gQmFzZSAocywgTGlzdC5tYXAgfmYgeHMpXG4gICAgfCBUdXBsZSB4cyAtPiBUdXBsZSAoTGlzdC5tYXAgfmYgeHMpXG4gICAgfCBSZWNvcmQgbCAtPiBSZWNvcmQgKExpc3QubWFwIGwgfmY6KGZ1biAocywgeCkgLT4gcywgZiB4KSlcbiAgICB8IFZhcmlhbnQgbCAtPiBWYXJpYW50IChMaXN0Lm1hcCBsIH5mOihmdW4gKHMsIHhzKSAtPiBzLCBMaXN0Lm1hcCB+ZiB4cykpXG4gICAgfCBQb2x5X3ZhcmlhbnQgdCAtPiBQb2x5X3ZhcmlhbnQgKFNvcnRlZF90YWJsZS5tYXAgdCB+ZjooT3B0aW9uLm1hcCB+ZikpXG4gICAgfCBBcHBsaWNhdGlvbiAoeCwgbCkgLT4gQXBwbGljYXRpb24gKGYgeCwgTGlzdC5tYXAgfmYgbClcbiAgICB8IFJlY19hcHAgKHQsIGwpIC0+IFJlY19hcHAgKHQsIExpc3QubWFwIH5mIGwpXG4gICAgfCBWYXIgdiAtPiBWYXIgdlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgdCA9IFNleHAudG9fc3RyaW5nIChzZXhwX29mX3QgKGZ1biBfIC0+IEF0b20gXCIuLi5cIikgdClcbmVuZFxuXG5tb2R1bGUgQ3JlYXRlX2RpZ2VzdCA6IHNpZ1xuICAoKiBEaWdlc3QgdmFyaW91cyBleHByZXNzaW9uIGZvcm1zICopXG5cbiAgdmFsIGRpZ2VzdF9sYXllciA6IERpZ2VzdC50IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudCAtPiBEaWdlc3QudFxuZW5kID0gc3RydWN0XG4gIGxldCBkaWdlc3RfbGF5ZXIgPSBmdW5jdGlvblxuICAgIHwgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5Bbm5vdGF0ZSAodSwgeCkgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvciBcImFubm90YXRlXCIgWyBEaWdlc3QudXVpZCB1OyB4IF1cbiAgICB8IEJhc2UgKHUsIGwpIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcImJhc2VcIiBbIERpZ2VzdC51dWlkIHU7IERpZ2VzdC5saXN0IGwgXVxuICAgIHwgVHVwbGUgbCAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJ0dXBsZVwiIFsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBSZWNvcmQgbCAtPlxuICAgICAgRGlnZXN0LmNvbnN0cnVjdG9yXG4gICAgICAgIFwicmVjb3JkXCJcbiAgICAgICAgWyBEaWdlc3QubGlzdCAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCB0KSAtPiBEaWdlc3QucGFpciAoRGlnZXN0LnN0cmluZyBzKSB0KSkgXVxuICAgIHwgVmFyaWFudCBsIC0+XG4gICAgICBEaWdlc3QuY29uc3RydWN0b3JcbiAgICAgICAgXCJ2YXJpYW50XCJcbiAgICAgICAgWyBEaWdlc3QubGlzdFxuICAgICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1biAocywgbCkgLT4gRGlnZXN0LnBhaXIgKERpZ2VzdC5zdHJpbmcgcykgKERpZ2VzdC5saXN0IGwpKSlcbiAgICAgICAgXVxuICAgIHwgUG9seV92YXJpYW50IHRhYmxlIC0+XG4gICAgICBEaWdlc3QuY29uc3RydWN0b3JcbiAgICAgICAgXCJwb2x5X3ZhcmlhbnRcIlxuICAgICAgICBbIERpZ2VzdC5saXN0XG4gICAgICAgICAgICAoTGlzdC5tYXAgKFNvcnRlZF90YWJsZS5leHBvc2UgdGFibGUpIH5mOihmdW4gKHgsIHkpIC0+XG4gICAgICAgICAgICAgICBEaWdlc3QucGFpciAoRGlnZXN0LnN0cmluZyB4KSAoRGlnZXN0Lm9wdGlvbiB5KSkpXG4gICAgICAgIF1cbiAgICB8IEFwcGxpY2F0aW9uICh4LCBsKSAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJhcHBsaWNhdGlvblwiIFsgeDsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBSZWNfYXBwIChuLCBsKSAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJyZWNfYXBwXCIgWyBEaWdlc3QuaW50IG47IERpZ2VzdC5saXN0IGwgXVxuICAgIHwgVmFyIG4gLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwidmFyXCIgWyBEaWdlc3QuaW50IG4gXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBWaXNpYmlsaXR5ID0gc3RydWN0XG4gIHR5cGUgdmlzaWJsZSA9IFZpc2libGVcbiAgdHlwZSBvcGFxdWUgPSBPcGFxdWVcblxuICBsZXQgXyA9IFZpc2libGVcbiAgbGV0IF8gPSBPcGFxdWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBDYW5vbmljYWwgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2RpZ2VzdCA6IHQgLT4gRGlnZXN0LnRcblxuICBtb2R1bGUgRXhwMSA6IHNpZ1xuICAgIHR5cGUgXyB0XG5cbiAgICB2YWwgdmFyIDogaW50IC0+IF8gdFxuICAgIHZhbCByZWN1cnNlIDogaW50IC0+IF8gdCBsaXN0IC0+IF8gdFxuICAgIHZhbCBhcHBseSA6ICdhIHQgLT4gJ2EgdCBsaXN0IC0+IF8gdFxuICAgIHZhbCBvcGFxdWUgOiBfIHQgLT4gVmlzaWJpbGl0eS5vcGFxdWUgdFxuXG4gICAgdmFsIGdldF9wb2x5X3ZhcmlhbnRcbiAgICAgIDogIFZpc2liaWxpdHkudmlzaWJsZSB0XG4gICAgICAtPiAoVmlzaWJpbGl0eS5vcGFxdWUgdCBvcHRpb24gU29ydGVkX3RhYmxlLnQsIHN0cmluZykgUmVzdWx0LnRcbiAgZW5kXG5cbiAgbW9kdWxlIERlZiA6IHNpZ1xuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnRcbiAgZW5kXG5cbiAgbW9kdWxlIENyZWF0ZSA6IHNpZ1xuICAgIHZhbCBhbm5vdGF0ZSA6IFV1aWQudCAtPiBfIEV4cDEudCAtPiBfIEV4cDEudFxuICAgIHZhbCBiYXNldHlwZSA6IFV1aWQudCAtPiBfIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHR1cGxlIDogXyBFeHAxLnQgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCBwb2x5X3ZhcmlhbnQgOiBMb2NhdGlvbi50IC0+IChzdHJpbmcgKiBfIEV4cDEudCBvcHRpb24pIGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgdmFyIDogaW50IC0+IF8gRXhwMS50XG4gICAgdmFsIHJlY3Vyc2UgOiBpbnQgLT4gXyBFeHAxLnQgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCBhcHBseSA6ICdhIEV4cDEudCAtPiAnYSBFeHAxLnQgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCBkZWZpbmUgOiBWaXNpYmlsaXR5LnZpc2libGUgRXhwMS50IC0+IERlZi50XG4gICAgdmFsIHJlY29yZCA6IChzdHJpbmcgKiBfIEV4cDEudCkgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCB2YXJpYW50IDogKHN0cmluZyAqIF8gRXhwMS50IGxpc3QpIGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgY3JlYXRlIDogXyBFeHAxLnQgLT4gdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ2Fub25pY2FsX2RpZ2VzdCA6IENhbm9uaWNhbCA9IHN0cnVjdFxuICB0eXBlIHQgPSBDYW5vbmljYWwgb2YgRGlnZXN0LnRcblxuICBsZXQgdG9fZGlnZXN0IChDYW5vbmljYWwgeCkgPSB4XG5cbiAgbW9kdWxlIENEID0gQ3JlYXRlX2RpZ2VzdFxuXG4gIG1vZHVsZSBFeHAxID0gc3RydWN0XG4gICAgdHlwZSBvcGFxdWUgPSBEaWdlc3QudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHwgUG9seV92YXJpYW50IG9mIG9wYXF1ZSBvcHRpb24gU29ydGVkX3RhYmxlLnRcbiAgICAgIHwgTm9uX3BvbHlfdmFyaWFudCBvZiAoc3RyaW5nICogb3BhcXVlKVxuICAgICAgfCBPcGFxdWUgOiBvcGFxdWUgLT4gVmlzaWJpbGl0eS5vcGFxdWUgdFxuXG4gICAgbGV0IHRvX2RpZ2VzdCAodHlwZSBhKSAoeCA6IGEgdCkgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IE9wYXF1ZSB4IC0+IHhcbiAgICAgIHwgTm9uX3BvbHlfdmFyaWFudCAoXywgeCkgLT4geFxuICAgICAgfCBQb2x5X3ZhcmlhbnQgeCAtPiBDRC5kaWdlc3RfbGF5ZXIgKFBvbHlfdmFyaWFudCB4KVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgKHR5cGUgYSkgKHggOiBhIHQpICh5IDogYSB0KSA9XG4gICAgICBEaWdlc3QuY29tcGFyZSAodG9fZGlnZXN0IHgpICh0b19kaWdlc3QgeSkgPSAwXG4gICAgOztcblxuICAgIGxldCBvcGFxdWUgeCA9IE9wYXF1ZSAodG9fZGlnZXN0IHgpXG5cbiAgICBsZXQgY3JlYXRlIHggPVxuICAgICAgbGV0IHggPSBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLm1hcCB+Zjp0b19kaWdlc3QgeCBpblxuICAgICAgbGV0IGRlc2MgPSBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLnRvX3N0cmluZyB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5Qb2x5X3ZhcmlhbnQgbCAtPiBQb2x5X3ZhcmlhbnQgbFxuICAgICAgfCBCYXNlIF8gLT4gTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IEFubm90YXRlIF8gLT5cbiAgICAgICAgKCogSXQncyB1bnNhZmUgdG8gdXNlIGRlcml2aW5nIGJpbl9pbyB3aGVuIGluaGVyaXRpbmcgZnJvbSBhIHBvbHltb3JwaGljIHZhcmlhbnRcbiAgICAgICAgICAgdGhhdCBoYXMgYSBjdXN0b20gYmluX2lvLiAgSWYgd2UgZm9yYmlkIHRoYXQsIHdlIGNhbiBoYXBwaWx5IHJlamVjdCBoZXJlXG4gICAgICAgICAgIGFueXRoaW5nIHRoYXQncyBhbm5vdGF0ZWQuICopXG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgICAgfCBBcHBsaWNhdGlvbiBfIC0+XG4gICAgICAgICgqIEFwcGxpY2F0aW9uIGNhbiByZWFsbHkgYmUgYSBwb2x5LXZhcmlhbnQgeW91IGNhbiBpbmhlcml0IGZyb20hICBCdXQgaXQncyBhXG4gICAgICAgICAgIHJhcmUgc2l0dWF0aW9uIHRoYXQgbW9zdGx5IChvbmx5PykgYXJpc2VzIHdpdGggaW5oZXJpdGFuY2UgZnJvbSByZWN1cnNpdmVcbiAgICAgICAgICAgcG9seW1vcnBpYyB2YXJpYW50cywgd2hpY2ggd2UndmUgbm90IHNlZW4gYW55d2hlcmUgeWV0LiAgU28gd2UgcmVqZWN0IGl0LiAqKVxuICAgICAgICBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICAgIHwgUmVjX2FwcCBfIC0+XG4gICAgICAgICgqIFlvdSBjYW4gb25seSBnZXQgdGhlIFtSZWNfYXBwXSBjb25zdHJ1Y3RvciBmb3IgdHlwZS1yZWZlcmVuY2VzIHdpdGhpbiB0aGVcbiAgICAgICAgICAgbXV0dWFsIGdyb3VwIGJlaW5nIGRlZmluZWQuIFJlZmVyZW5jZXMgd2hpY2hcbiAgICAgICAgICAgZm9sbG93IGFmdGVyIHRoZSBjdXJyZW50IGdyb3VwIHdpbGwgYWx3YXlzIGJlIFtBcHBsaWNhdGlvbl1zLlxuXG4gICAgICAgICAgIEFuZCBzaW5jZSBvY2FtbCByZWplY3RzIHJlZmVyZW5jZXMgaW4gYGluaGVyaXRhbmNlJyBwb3NpdGlvbiB0byB0eXBlcyB3aXRoaW5cbiAgICAgICAgICAgdGhlIGN1cnJlbnQgZ3JvdXAgKHNlZSBleGFtcGxlKSB3aXRoOlxuXG4gICAgICAgICAgIEVycm9yOiBUaGUgdHlwZSBjb25zdHJ1Y3RvciB0XG4gICAgICAgICAgIGlzIG5vdCB5ZXQgY29tcGxldGVseSBkZWZpbmVkXG5cbiAgICAgICAgICAgdGhlbiBpdHMgb2sgdG8gc2F5IHRoYXQgYSByZWMtYXBwIGlzIHNvbWV0aGluZyB0aGF0IGNhbid0IGJlIGluaGVyaXRlZCBmcm9tIGFuZFxuICAgICAgICAgICByZXR1cm4gW05vbl9wb2x5X3ZhcmlhbnRdLlxuXG4gICAgICAgICAgIEFuZCB1bmxpa2UgdGhlIFtBcHBsaWNhdGlvbl0gY2FzZSwgaXQgc2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIHNlZVxuICAgICAgICAgICBhbiBlcnJvciBtZXNzYWdlIHdpdGggdGhlIFtkZXNjXSA9IFtSZWNfYXBwXS5cblxuICAgICAgICAgICBFeGFtcGxlOiBbdHlwZSB0ID0gW2BhIG9mIFsgfCB0XSBdXVxuICAgICAgICAgICBIZXJlLCBbfCB0XSB3b3VsZCBiZSBhbiBleGFtcGxlIG9mIGluaGVyaXRhbmNlIGZyb20gYSBSZWNfYXBwLCB3aGljaFxuICAgICAgICAgICBpcyByZWplY3RlZCBieSB0aGUgY29tcGlsZXIuXG4gICAgICAgICopXG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgICAgfCBWYXIgXyB8IFR1cGxlIF8gfCBSZWNvcmQgXyB8IFZhcmlhbnQgXyAtPlxuICAgICAgICBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICA7O1xuXG4gICAgbGV0IHZhciB4ID0gY3JlYXRlIChWYXIgeClcbiAgICBsZXQgYXBwbHkgZGVmIGwgPSBjcmVhdGUgKEFwcGxpY2F0aW9uIChkZWYsIGwpKVxuICAgIGxldCByZWN1cnNlIHRpZCBsID0gY3JlYXRlIChSZWNfYXBwICh0aWQsIGwpKVxuXG4gICAgbGV0IGdldF9wb2x5X3ZhcmlhbnQgKHggOiBWaXNpYmlsaXR5LnZpc2libGUgdCkgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIF8pIC0+IEVycm9yIGRlc2NcbiAgICAgIHwgUG9seV92YXJpYW50IGwgLT4gT2sgKFNvcnRlZF90YWJsZS5tYXAgfmY6KE9wdGlvbi5tYXAgfmY6KGZ1biB4IC0+IE9wYXF1ZSB4KSkgbClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRGVmID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVmlzaWJpbGl0eS52aXNpYmxlIEV4cDEudFxuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlID0gc3RydWN0XG4gICAgbGV0IGFubm90YXRlIHUgeCA9IEV4cDEuY3JlYXRlIChBbm5vdGF0ZSAodSwgeCkpXG4gICAgbGV0IGJhc2V0eXBlIHUgbCA9IEV4cDEuY3JlYXRlIChCYXNlICh1LCBsKSlcbiAgICBsZXQgdHVwbGUgbCA9IEV4cDEuY3JlYXRlIChUdXBsZSBsKVxuXG4gICAgbGV0IHBvbHlfdmFyaWFudCBsb2MgbCA9XG4gICAgICBFeHAxLmNyZWF0ZSAoUG9seV92YXJpYW50IChTb3J0ZWRfdGFibGUuY3JlYXRlIGxvYyB+ZXE6KGVxdWFsX29wdGlvbiBFeHAxLmVxdWFsKSBsKSlcbiAgICA7O1xuXG4gICAgbGV0IHZhciB4ID0gRXhwMS5jcmVhdGUgKFZhciB4KVxuICAgIGxldCBhcHBseSB4IGwgPSBFeHAxLmNyZWF0ZSAoQXBwbGljYXRpb24gKHgsIGwpKVxuICAgIGxldCByZWN1cnNlIHQgbCA9IEV4cDEuY3JlYXRlIChSZWNfYXBwICh0LCBsKSlcbiAgICBsZXQgZGVmaW5lIHggPSB4XG4gICAgbGV0IHJlY29yZCBsID0gRXhwMS5jcmVhdGUgKFJlY29yZCBsKVxuICAgIGxldCB2YXJpYW50IGwgPSBFeHAxLmNyZWF0ZSAoVmFyaWFudCBsKVxuICAgIGxldCBjcmVhdGUgZSA9IENhbm9uaWNhbCAoRXhwMS50b19kaWdlc3QgZSlcbiAgZW5kXG5lbmRcblxubW9kdWxlIENhbm9uaWNhbF9mdWxsIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGluY2x1ZGUgQ2Fub25pY2FsIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgdG9fc3RyaW5nX2h1bSA6IHQgLT4gc3RyaW5nXG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIENEID0gQ3JlYXRlX2RpZ2VzdFxuXG4gIG1vZHVsZSBFeHAxID0gc3RydWN0XG4gICAgdHlwZSB0MCA9IEV4cCBvZiB0MCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICAgIGxldCBlcXVhbF90MCB4IHkgPSBjb21wYXJlX3QwIHggeSA9IDBcblxuICAgIHR5cGUgJ2EgdCA9IHQwIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgICBsZXQgdmFyIHggPSBFeHAgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuVmFyIHgpXG4gICAgbGV0IGFwcGx5IGQgeHMgPSBFeHAgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuQXBwbGljYXRpb24gKGQsIHhzKSlcbiAgICBsZXQgcmVjdXJzZSByIHhzID0gRXhwIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlJlY19hcHAgKHIsIHhzKSlcblxuICAgIGxldCBwb2x5X3ZhcmlhbnQgbG9jIHhzID1cbiAgICAgIEV4cFxuICAgICAgICAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5Qb2x5X3ZhcmlhbnRcbiAgICAgICAgICAgKFNvcnRlZF90YWJsZS5jcmVhdGUgbG9jIH5lcTooZXF1YWxfb3B0aW9uIGVxdWFsX3QwKSB4cykpXG4gICAgOztcblxuICAgIGxldCBnZXRfcG9seV92YXJpYW50ID0gZnVuY3Rpb25cbiAgICAgIHwgRXhwIChQb2x5X3ZhcmlhbnQgdGFiKSAtPiBPayB0YWJcbiAgICAgIHwgRXhwIGNjIC0+IEVycm9yIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLnRvX3N0cmluZyBjYylcbiAgICA7O1xuXG4gICAgbGV0IG9wYXF1ZSB0ID0gdFxuXG4gICAgbGV0IHJlYyB0b19kaWdlc3QgPSBmdW5jdGlvblxuICAgICAgfCBFeHAgZSAtPiBDRC5kaWdlc3RfbGF5ZXIgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IubWFwIH5mOnRvX2RpZ2VzdCBlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBEZWYgPSBzdHJ1Y3RcbiAgICAoKiBBIFtEZWYudF0gaXMgYW4gZXhwcmVzc2lvbiB3aGljaCBtYXkgYmUgYXBwbGllZCAqKVxuICAgIHR5cGUgdCA9IEV4cDEudDAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cbiAgZW5kXG5cbiAgKCogQSBjYW5vbmljYWwgc2hhcGUgW3RdIGlzIGFuIFtFeHAxLnRdLiAqKVxuICB0eXBlIHQgPSBFeHAxLnQwIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgbGV0IHRvX2RpZ2VzdCBlID0gRXhwMS50b19kaWdlc3QgZVxuXG4gIG1vZHVsZSBDcmVhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgYW5ub3RhdGUgdSB4ID0gRXhwMS5FeHAgKEFubm90YXRlICh1LCB4KSlcbiAgICBsZXQgYmFzZXR5cGUgdSB4cyA9IEV4cDEuRXhwIChCYXNlICh1LCB4cykpXG4gICAgbGV0IHR1cGxlIHhzID0gRXhwMS5FeHAgKFR1cGxlIHhzKVxuICAgIGxldCBwb2x5X3ZhcmlhbnQgbG9jIHhzID0gRXhwMS5wb2x5X3ZhcmlhbnQgbG9jIHhzXG4gICAgbGV0IHZhciBuID0gRXhwMS5FeHAgKFZhciBuKVxuICAgIGxldCByZWN1cnNlIHIgeHMgPSBFeHAxLnJlY3Vyc2UgciB4c1xuICAgIGxldCBhcHBseSBkIHhzID0gRXhwMS5hcHBseSBkIHhzXG4gICAgbGV0IGRlZmluZSB4ID0geFxuICAgIGxldCByZWNvcmQgeHMgPSBFeHAxLkV4cCAoUmVjb3JkIHhzKVxuICAgIGxldCB2YXJpYW50IHhzID0gRXhwMS5FeHAgKFZhcmlhbnQgeHMpXG4gICAgbGV0IGNyZWF0ZSBleHAgPSBleHBcbiAgZW5kXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gdCA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl90IHQpXG5lbmRcblxubW9kdWxlIFRpZCA6IHNpZ1xuICBpbmNsdWRlIElkZW50aWZpYWJsZS5TXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdHJpbmdcbmVuZFxuXG5tb2R1bGUgVmlkIDogc2lnXG4gIGluY2x1ZGUgSWRlbnRpZmlhYmxlLlNcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuZW5kXG5cbm1vZHVsZSBHaWQgOiBzaWdcbiAgKCogdW5pcXVlIGdyb3VwLWlkLCB1c2VkIGFzIGtleSBmb3IgVGVudiBiZWxvdyAqKVxuICB0eXBlIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IHIgPSByZWYgMFxuXG4gIGxldCBjcmVhdGUgKCkgPVxuICAgIGxldCB1ID0gIXIgaW5cbiAgICByIDo9IDEgKyB1O1xuICAgIHVcbiAgOztcbmVuZFxuXG5tb2R1bGUgRXhwcmVzc2lvbiA9IHN0cnVjdFxuICB0eXBlICd0IHBvbHlfY29uc3RyID1cbiAgICBbIGBDb25zdHIgb2Ygc3RyaW5nICogJ3Qgb3B0aW9uXG4gICAgfCBgSW5oZXJpdCBvZiBMb2NhdGlvbi50ICogJ3RcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbW9kdWxlIEdyb3VwIDogc2lnXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICB2YWwgY3JlYXRlIDogTG9jYXRpb24udCAtPiAoVGlkLnQgKiBWaWQudCBsaXN0ICogJ2EpIGxpc3QgLT4gJ2EgdFxuICAgIHZhbCBpZCA6ICdhIHQgLT4gR2lkLnRcbiAgICB2YWwgbG9va3VwIDogJ2EgdCAtPiBUaWQudCAtPiBWaWQudCBsaXN0ICogJ2FcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgZ2lkIDogR2lkLnRcbiAgICAgIDsgbG9jIDogTG9jYXRpb24udFxuICAgICAgOyBtZW1iZXJzIDogKFRpZC50ICogKFZpZC50IGxpc3QgKiAnYSkpIGxpc3RcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgbGV0IGNyZWF0ZSBsb2MgdHJpcHMgPVxuICAgICAgbGV0IGdpZCA9IEdpZC5jcmVhdGUgKCkgaW5cbiAgICAgIGxldCBtZW1iZXJzID0gTGlzdC5tYXAgdHJpcHMgfmY6KGZ1biAoeCwgdnMsIHQpIC0+IHgsICh2cywgdCkpIGluXG4gICAgICB7IGdpZDsgbG9jOyBtZW1iZXJzIH1cbiAgICA7O1xuXG4gICAgbGV0IGlkIGcgPSBnLmdpZFxuXG4gICAgbGV0IGxvb2t1cCBnIHRpZCA9XG4gICAgICBtYXRjaCBMaXN0LkFzc29jLmZpbmQgZy5tZW1iZXJzIH5lcXVhbDpUaWQuKCA9ICkgdGlkIHdpdGhcbiAgICAgIHwgU29tZSBzY2hlbWUgLT4gc2NoZW1lXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgZXZhbF9mYWlsXG4gICAgICAgICAgZy5sb2NcbiAgICAgICAgICAhXCJpbXBvc3NpYmxlOiBsb29rdXBfZ3JvdXAsIHVuYm91bmQgdHlwZS1pZGVudGlmaWVyOiAle1RpZH1cIlxuICAgICAgICAgIHRpZFxuICAgICAgICAgICgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB8IEFubm90YXRlIG9mIFV1aWQudCAqIHRcbiAgICB8IEJhc2Ugb2YgVXVpZC50ICogdCBsaXN0XG4gICAgfCBSZWNvcmQgb2YgKHN0cmluZyAqIHQpIGxpc3RcbiAgICB8IFZhcmlhbnQgb2YgKHN0cmluZyAqIHQgbGlzdCkgbGlzdFxuICAgIHwgVHVwbGUgb2YgdCBsaXN0XG4gICAgfCBQb2x5X3ZhcmlhbnQgb2YgKExvY2F0aW9uLnQgKiB0IHBvbHlfY29uc3RyIGxpc3QpXG4gICAgfCBWYXIgb2YgKExvY2F0aW9uLnQgKiBWaWQudClcbiAgICB8IFJlY19hcHAgb2YgVGlkLnQgKiB0IGxpc3RcbiAgICB8IFRvcF9hcHAgb2YgdCBHcm91cC50ICogVGlkLnQgKiB0IGxpc3RcbiAgW0BAZGVyaXZpbmcgdmFyaWFudHMsIHNleHBfb2ZdXG5cbiAgdHlwZSBncm91cCA9IHQgR3JvdXAudFxuXG4gIGxldCBncm91cCA9IEdyb3VwLmNyZWF0ZVxuXG4gIHR5cGUgcG9seV92YXJpYW50X3JvdyA9IHQgcG9seV9jb25zdHJcblxuICBsZXQgY29uc3RyIHMgdCA9IGBDb25zdHIgKHMsIHQpXG4gIGxldCBpbmhlcml0XyBsb2MgdCA9IGBJbmhlcml0IChsb2MsIHQpXG4gIGxldCB2YXIgbG9jIHQgPSBWYXIgKGxvYywgdClcbiAgbGV0IHBvbHlfdmFyaWFudCBsb2MgeHMgPSBQb2x5X3ZhcmlhbnQgKGxvYywgeHMpXG4gIGxldCBiYXNldHlwZSA9IGJhc2VcblxuICAoKiBcIlZSXCIgc3RhbmRzIGZvciBcInZhcmlhbnQgb3IgcmVjb3JkXCIgKilcblxuICBsZXQgaXNfY3ljbGljXzAgfih2aWFfVlIgOiBib29sKSA6IGdyb3VwIC0+IFRpZC50IC0+IGJvb2wgPVxuICAgIGZ1biBncm91cCB0aWQgLT5cbiAgICBsZXQgc2V0ID0gcmVmIFtdIGluXG4gICAgbGV0IHZpc2l0ZWQgdGlkID0gTGlzdC5tZW0gIXNldCB0aWQgfmVxdWFsOlRpZC5lcXVhbCBpblxuICAgIGxldCBhZGQgdGlkID0gc2V0IDo9IHRpZCA6OiAhc2V0IGluXG4gICAgbGV0IHJlYyB0cmF2ID0gZnVuY3Rpb25cbiAgICAgICgqIFdlIGxvb2sgZm9yIGN5Y2xlcyBieSB0cmF2ZXJzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdHlwZS1leHByZXNzaW9ucyAqKVxuICAgICAgfCBBbm5vdGF0ZSAoXywgdCkgLT4gdHJhdiB0XG4gICAgICB8IEJhc2UgKF8sIHRzKSB8IFR1cGxlIHRzIHwgVG9wX2FwcCAoXywgXywgdHMpIC0+IExpc3QuaXRlciB0cyB+Zjp0cmF2XG4gICAgICAoKiAuLmluY2x1ZGluZyBwb2x5LXZhcmlhbnRzICopXG4gICAgICB8IFBvbHlfdmFyaWFudCAoXywgY3MpIC0+XG4gICAgICAgIExpc3QuaXRlciBjcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IGBDb25zdHIgKF8sIE5vbmUpIC0+ICgpXG4gICAgICAgICAgfCBgQ29uc3RyIChfLCBTb21lIHQpIC0+IHRyYXYgdFxuICAgICAgICAgIHwgYEluaGVyaXQgKF9sb2MsIHQpIC0+IHRyYXYgdClcbiAgICAgICgqIC4uIGFuZCByZWNvcmRzICYgKG5vcm1hbCkgdmFyaWFudHMgKilcbiAgICAgIHwgUmVjb3JkIHhzIC0+IGlmIHZpYV9WUiB0aGVuIExpc3QuaXRlciB4cyB+ZjooZnVuIChfLCB0KSAtPiB0cmF2IHQpIGVsc2UgKClcbiAgICAgIHwgVmFyaWFudCB4cyAtPlxuICAgICAgICBpZiB2aWFfVlIgdGhlbiBMaXN0Lml0ZXIgeHMgfmY6KGZ1biAoXywgdHMpIC0+IExpc3QuaXRlciB+Zjp0cmF2IHRzKSBlbHNlICgpXG4gICAgICAoKiBXZSBkb250IGZvbGxvdyB0eXBlLXZhcnMgKilcbiAgICAgIHwgVmFyIF8gLT4gKClcbiAgICAgICgqIHRyYXZlcnNlIChyZWN1cnNpdmUpIHR5cGUtYXBwcyB3aGVuIGZpcnN0IGVuY291bnRlcmVkICopXG4gICAgICB8IFJlY19hcHAgKHRpZCwgdHMpIC0+XG4gICAgICAgIGlmIHZpc2l0ZWQgdGlkXG4gICAgICAgIHRoZW4gKClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYWRkIHRpZDtcbiAgICAgICAgICB0cmF2X3RpZCB0aWQpO1xuICAgICAgICBMaXN0Lml0ZXIgdHMgfmY6dHJhdlxuICAgIGFuZCB0cmF2X3RpZCB0aWQgPVxuICAgICAgbGV0IF8sIGJvZHkgPSBHcm91cC5sb29rdXAgZ3JvdXAgdGlkIGluXG4gICAgICB0cmF2IGJvZHlcbiAgICBpblxuICAgIHRyYXZfdGlkIHRpZDtcbiAgICBsZXQgcmVzID0gdmlzaXRlZCB0aWQgaW5cbiAgICAoKmxldCBfc3MgPSBTdHJpbmcuY29uY2F0IH5zZXA6XCIsXCIgKExpc3QubWFwICghc2V0KSB+Zjooc3ByaW50ZiAhXCIle1RpZH1cIikpIGluKilcbiAgICAoKlByaW50Zi5wcmludGYgIVwiaXNfY3lsaWM6ICV7VGlkfSAtLT4gKCVzKSAlYiAgLS0gJXMlIVwiIHRpZCBfc3MgcmVzIChHcm91cC5sb2MgZ3JvdXApOyopXG4gICAgcmVzXG4gIDs7XG5cbiAgbGV0IGlzX2N5Y2xpYyA9IGlzX2N5Y2xpY18wIH52aWFfVlI6dHJ1ZVxuICBsZXQgaXNfY3ljbGljX3dpdGhfbm9faW50ZXJ2ZW5pbmdfVlIgPSBpc19jeWNsaWNfMCB+dmlhX1ZSOmZhbHNlXG5lbmRcblxuaW5jbHVkZSBFeHByZXNzaW9uXG5cbm1vZHVsZSBFdmFsdWF0aW9uIChDYW5vbmljYWwgOiBDYW5vbmljYWwpID0gc3RydWN0XG4gICgqIFtWZW52LnRdXG4gICAgIEVudmlyb25tZW50IGZvciByZXNvbHZpbmcgdHlwZS12YXJzICopXG4gIG1vZHVsZSBWZW52IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgbG9va3VwIDogdCAtPiBWaWQudCAtPiBWaXNpYmlsaXR5LnZpc2libGUgQ2Fub25pY2FsLkV4cDEudCBvcHRpb25cbiAgICB2YWwgY3JlYXRlIDogKFZpZC50ICogVmlzaWJpbGl0eS52aXNpYmxlIENhbm9uaWNhbC5FeHAxLnQpIGxpc3QgLT4gdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBWaXNpYmlsaXR5LnZpc2libGUgQ2Fub25pY2FsLkV4cDEudCBNYXAuTShWaWQpLnRcblxuICAgIGxldCBjcmVhdGUgPVxuICAgICAgTGlzdC5mb2xkXG4gICAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBWaWQpKVxuICAgICAgICB+ZjooZnVuIHQgKGssIHYpIC0+IE1hcC5zZXQgfmtleTprIH5kYXRhOnYgdClcbiAgICA7O1xuXG4gICAgbGV0IGxvb2t1cCB0IGsgPSBNYXAuZmluZCB0IGtcbiAgZW5kXG5cbiAgbW9kdWxlIEFwcGxpY2FuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IFJlY3Vyc2lvbl9sZXZlbCBvZiBpbnRcbiAgICAgIHwgRGVmaW5pdGlvbiBvZiBDYW5vbmljYWwuRGVmLnRcbiAgZW5kXG5cbiAgKCogW1RlbnYudF1cbiAgICAgRW52aXJvbm1lbnQgZm9yIHJlc29sdmluZyB0eXBlLWRlZmluaXRpb25zICopXG4gIG1vZHVsZSBUZW52IDogc2lnXG4gICAgdHlwZSBrZXkgPSBHaWQudCAqIFRpZC50XG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZmluZCA6IHQgLT4ga2V5IC0+IFsgYFJlY3Vyc2lvbl9sZXZlbCBvZiBpbnQgXSBvcHRpb25cbiAgICB2YWwgZW1wdHkgOiB0XG4gICAgdmFsIGV4dGVuZCA6IHQgLT4ga2V5IC0+IFsgYFJlY3Vyc2lvbl9sZXZlbCBvZiBpbnQgXSAtPiB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEdpZC50ICogVGlkLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbiAgICAgIGVuZFxuXG4gICAgICBpbmNsdWRlIFRcbiAgICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuICAgIGVuZFxuXG4gICAgdHlwZSBrZXkgPSBLZXkudFxuICAgIHR5cGUgdCA9IFsgYFJlY3Vyc2lvbl9sZXZlbCBvZiBpbnQgXSBNYXAuTShLZXkpLnRcblxuICAgIGxldCBmaW5kIHQgayA9IE1hcC5maW5kIHQga1xuICAgIGxldCBlbXB0eSA9IE1hcC5lbXB0eSAobW9kdWxlIEtleSlcbiAgICBsZXQgZXh0ZW5kIHQgayB2ID0gTWFwLnNldCB+a2V5OmsgfmRhdGE6diB0XG4gIGVuZFxuXG4gICgqIFtEZWZpbmluZy50XVxuICAgICBNb25hZCBmb3IgbWFuYWdpbmcgdW4tcm9sbGluZyBkZXB0aCwgYW5kIG1haW50YWluZyBhIFtUZW52LnRdICopXG4gIG1vZHVsZSBEZWZpbmluZyA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgICB2YWwgYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcbiAgICB2YWwgbG9va19lbnYgOiBUZW52LmtleSAtPiBBcHBsaWNhbmQudCBvcHRpb24gdFxuICAgIHZhbCBleHRlbmRfbmV3X3RpZCA6IFRlbnYua2V5IC0+IENhbm9uaWNhbC5EZWYudCB0IC0+IEFwcGxpY2FuZC50IHRcbiAgICB2YWwgZXhlYyA6ICdhIHQgLT4gJ2FcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gZGVwdGg6aW50IC0+IFRlbnYudCAtPiAnYVxuXG4gICAgbGV0IHJldHVybiB4IH5kZXB0aDpfIF90ZW52ID0geFxuXG4gICAgbGV0IGJpbmQgdCBmIH5kZXB0aCB0ZW52ID1cbiAgICAgIGxldCB4ID0gdCB+ZGVwdGggdGVudiBpblxuICAgICAgKGYgeCkgfmRlcHRoIHRlbnZcbiAgICA7O1xuXG4gICAgbGV0IGxvb2tfZW52IGtleSB+ZGVwdGg6XyB0ZW52ID1cbiAgICAgIGxldCByZXN1bHQgPSBUZW52LmZpbmQgdGVudiBrZXkgaW5cbiAgICAgIE9wdGlvbi5tYXAgfmY6KGZ1biAoYFJlY3Vyc2lvbl9sZXZlbCB4KSAtPiBBcHBsaWNhbmQuUmVjdXJzaW9uX2xldmVsIHgpIHJlc3VsdFxuICAgIDs7XG5cbiAgICBsZXQgZXh0ZW5kX25ld190aWQga2V5IGRlZl90IH5kZXB0aCB0ZW52ID1cbiAgICAgIEFwcGxpY2FuZC5EZWZpbml0aW9uXG4gICAgICAgIChsZXQgdmFsdWUgPSBgUmVjdXJzaW9uX2xldmVsIGRlcHRoIGluXG4gICAgICAgICBsZXQgdGVudiA9IFRlbnYuZXh0ZW5kIHRlbnYga2V5IHZhbHVlIGluXG4gICAgICAgICBkZWZfdCB+ZGVwdGg6KGRlcHRoICsgMSkgdGVudilcbiAgICA7O1xuXG4gICAgbGV0IGV4ZWMgdCA9IHQgfmRlcHRoOjAgVGVudi5lbXB0eVxuICBlbmRcblxuICB0eXBlICdhIGRlZmluaW5nID0gJ2EgRGVmaW5pbmcudFxuXG4gIGxldCAoID4+PSApID0gRGVmaW5pbmcuYmluZFxuICBsZXQgcmV0dXJuID0gRGVmaW5pbmcucmV0dXJuXG5cbiAgbGV0IHNlcXVlbmNlX2RlZmluaW5nIDogJ2EgbGlzdCAtPiBmOignYSAtPiAnYiBkZWZpbmluZykgLT4gJ2IgbGlzdCBkZWZpbmluZyA9XG4gICAgZnVuIHhzIH5mIC0+XG4gICAgbGV0IHJlYyBsb29wIGFjY195cyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgYWNjX3lzKVxuICAgICAgfCB4IDo6IHhzIC0+IGYgeCA+Pj0gZnVuIHkgLT4gbG9vcCAoeSA6OiBhY2NfeXMpIHhzXG4gICAgaW5cbiAgICBsb29wIFtdIHhzXG4gIDs7XG5cbiAgKCpcbiAgICAgU2hhcGUgZXZhbHVhdGlvbi5cblxuICAgICBTaGFwZXMgYXJlIGV2YWx1YXRlZCB0byBjYW5vbmljYWwtc2hhcGUgKGV4cHJlc3Npb25zKSwgd2l0aCBhZGRpdGlvbmFsIGRlZnMgY29sbGVjdGVkXG4gICAgIGluIHRoZSBbZGVmaW5pbmddIG1vbmFkLCB3aGljaCBhbHNvIG1hbmFnZXMgZ2VuZXJhdGlvbi9tYXBwaW5nIHRvIFtDYW5vbmljYWwuVGlkLnRdXG5cbiAgICAgVGhlcmUgaXMgZG93bndhcmRzIGNvbnRleHQgb2YgW2dyb3VwXSBhbmQgW1ZlbnYudF1cbiAgICAgVGhlIChjdXJyZW50KSBbZ3JvdXBdIGNoYW5nZXMgd2hlbiB0aGUgY2FzZSBmb3IgW1RvcF9hcHBdIGNhbGxzIFtldmFsX2FwcF0uXG5cbiAgICAgVGhlIGN1cnJlbnQgW1ZlbnYudF0gaXMgYWJhbmRvbmVkIHdoZW4gW2V2YWxfYXBwXSBpcyBjYWxsZWQsIGFuZCB0aGVuIHJlLWNyZWF0ZWQgYWZ0ZXJcbiAgICAgdGhlIGRlY2lzaW9uIGhhcyBiZWVuIG1hZGUgdG8gZWl0aGVyIGlubGluZSB0aGUgdHlwZS1hcHBsaWNhdGlvbiwgb3IgbWFrZSBhIHJlZmVyZW5jZVxuICAgICB0byBhIHR5cGUtZGVmaW5pdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCBtb3N0IG9uY2UgZm9yIGVhY2ggKEdpZC50ICogVGlkLnQpLlxuXG4gICAgIFdlIG1ha2UgYSB0eXBlLWRlZmluaXRpb24gYWx3YXlzIGZvciBSZWNvcmRzIGFuZCBWYXJpYW50cywgYW5kIGluIGFkZGl0aW9uIGZvciBhbnlcbiAgICAgb3RoZXIgY3ljbGljIHR5cGUtZGVmaW5pdGlvbi5cbiAgKilcblxuICBsZXQgcmVjIGV2YWwgOiBncm91cCAtPiBWZW52LnQgLT4gdCAtPiBWaXNpYmlsaXR5LnZpc2libGUgQ2Fub25pY2FsLkV4cDEudCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIHZlbnYgdCAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFJlY29yZCBiaW5kcyAtPlxuICAgICAgICBzZXF1ZW5jZV9kZWZpbmluZyBiaW5kcyB+ZjooZnVuIChzLCB4KSAtPlxuICAgICAgICAgIGV2YWwgZ3JvdXAgdmVudiB4ID4+PSBmdW4geSAtPiByZXR1cm4gKHMsIHkpKVxuICAgICAgICA+Pj0gZnVuIGJpbmRzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5yZWNvcmQgYmluZHMpXG4gICAgICB8IFZhcmlhbnQgYWx0cyAtPlxuICAgICAgICBzZXF1ZW5jZV9kZWZpbmluZyBhbHRzIH5mOihmdW4gKHMsIHhzKSAtPlxuICAgICAgICAgIGV2YWxfbGlzdCBncm91cCB2ZW52IHhzID4+PSBmdW4geXMgLT4gcmV0dXJuIChzLCB5cykpXG4gICAgICAgID4+PSBmdW4gYWx0cyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUudmFyaWFudCBhbHRzKVxuICAgICAgfCBWYXIgKGxvYywgdmlkKSAtPlxuICAgICAgICAobWF0Y2ggVmVudi5sb29rdXAgdmVudiB2aWQgd2l0aFxuICAgICAgICAgfCBTb21lIHggLT4gcmV0dXJuIHhcbiAgICAgICAgIHwgTm9uZSAtPiBldmFsX2ZhaWwgbG9jICFcIkZyZWUgdHlwZSB2YXJpYWJsZTogJyV7VmlkfVwiIHZpZCAoKSlcbiAgICAgIHwgQW5ub3RhdGUgKHMsIHQpIC0+XG4gICAgICAgIGV2YWwgZ3JvdXAgdmVudiB0ID4+PSBmdW4gdiAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUuYW5ub3RhdGUgcyB2KVxuICAgICAgfCBCYXNlIChzLCB0cykgLT5cbiAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgdHMgPj49IGZ1biB2cyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUuYmFzZXR5cGUgcyB2cylcbiAgICAgIHwgVHVwbGUgdHMgLT4gZXZhbF9saXN0IGdyb3VwIHZlbnYgdHMgPj49IGZ1biB2cyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUudHVwbGUgdnMpXG4gICAgICB8IFRvcF9hcHAgKGluX2dyb3VwLCB0aWQsIGFyZ3MpIC0+XG4gICAgICAgIGV2YWxfbGlzdCBncm91cCB2ZW52IGFyZ3NcbiAgICAgICAgPj49IGZ1biBhcmdzIC0+XG4gICAgICAgICgqIGFyZ3MgZXZhbHVhdGVkIGluIGN1cnJlbnQgZ3JvdXAgKilcbiAgICAgICAgZXZhbF9hcHAgaW5fZ3JvdXAgdGlkIGFyZ3NcbiAgICAgICgqIGdyb3VwIGNoYW5nZWQgaGVyZSAqKVxuICAgICAgfCBSZWNfYXBwICh0aWQsIGFyZ3MpIC0+XG4gICAgICAgIGV2YWxfbGlzdCBncm91cCB2ZW52IGFyZ3MgPj49IGZ1biBhcmdzIC0+IGV2YWxfYXBwIGdyb3VwIHRpZCBhcmdzXG4gICAgICB8IFBvbHlfdmFyaWFudCAobG9jLCBjcykgLT5cbiAgICAgICAgc2VxdWVuY2VfZGVmaW5pbmcgfmY6KGV2YWxfcG9seV9jb25zdHIgZ3JvdXAgdmVudikgY3NcbiAgICAgICAgPj49IGZ1biB4c3MgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLnBvbHlfdmFyaWFudCBsb2MgKExpc3QuY29uY2F0IHhzcykpXG5cbiAgYW5kIGV2YWxfbGlzdCA6IGdyb3VwIC0+IFZlbnYudCAtPiB0IGxpc3QgLT4gXyBDYW5vbmljYWwuRXhwMS50IGxpc3QgZGVmaW5pbmcgPVxuICAgIGZ1biBncm91cCB2ZW52IHRzIC0+IHNlcXVlbmNlX2RlZmluaW5nIHRzIH5mOihldmFsIGdyb3VwIHZlbnYpXG5cbiAgYW5kIGV2YWxfcG9seV9jb25zdHJcbiAgICA6ICBncm91cCAtPiBWZW52LnQgLT4gdCBwb2x5X2NvbnN0clxuICAgICAgLT4gKHN0cmluZyAqIFZpc2liaWxpdHkub3BhcXVlIENhbm9uaWNhbC5FeHAxLnQgb3B0aW9uKSBsaXN0IGRlZmluaW5nXG4gICAgPVxuICAgIGZ1biBncm91cCB2ZW52IGMgLT5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCBgQ29uc3RyIChzLCBOb25lKSAtPiByZXR1cm4gWyBzLCBOb25lIF1cbiAgICAgIHwgYENvbnN0ciAocywgU29tZSB0KSAtPlxuICAgICAgICBldmFsIGdyb3VwIHZlbnYgdCA+Pj0gZnVuIHYgLT4gcmV0dXJuIFsgcywgU29tZSAoQ2Fub25pY2FsLkV4cDEub3BhcXVlIHYpIF1cbiAgICAgIHwgYEluaGVyaXQgKGxvYywgdCkgLT5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IHRcbiAgICAgICAgPj49IGZ1biB2IC0+XG4gICAgICAgIChtYXRjaCBDYW5vbmljYWwuRXhwMS5nZXRfcG9seV92YXJpYW50IHYgd2l0aFxuICAgICAgICAgfCBPayB0YWIgLT4gcmV0dXJuIChTb3J0ZWRfdGFibGUuZXhwb3NlIHRhYilcbiAgICAgICAgIHwgRXJyb3IgZGVzYyAtPlxuICAgICAgICAgICBldmFsX2ZhaWxcbiAgICAgICAgICAgICBsb2NcbiAgICAgICAgICAgICBcIlRoZSBzaGFwZSBmb3IgYW4gaW5oZXJpdGVkIHR5cGUgaXMgbm90IGRlc2NyaWJlZCBhcyBhIHBvbHltb3JwaGljLXZhcmlhbnQ6ICVzXCJcbiAgICAgICAgICAgICBkZXNjXG4gICAgICAgICAgICAgKCkpXG5cbiAgYW5kIGV2YWxfZGVmaW5pdGlvbiA6IGdyb3VwIC0+IFZpZC50IGxpc3QgLT4gdCAtPiBDYW5vbmljYWwuRGVmLnQgZGVmaW5pbmcgPVxuICAgIGZ1biBncm91cCBmb3JtYWxzIGJvZHkgLT5cbiAgICAgIGxldCB2ZW52ID0gVmVudi5jcmVhdGUgKExpc3QubWFwaSBmb3JtYWxzIH5mOihmdW4gaSB4IC0+IHgsIENhbm9uaWNhbC5FeHAxLnZhciBpKSkgaW5cbiAgICAgIGV2YWwgZ3JvdXAgdmVudiBib2R5ID4+PSBmdW4gdiAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUuZGVmaW5lIHYpXG5cbiAgYW5kIGV2YWxfYXBwIDogZ3JvdXAgLT4gVGlkLnQgLT4gXyBDYW5vbmljYWwuRXhwMS50IGxpc3QgLT4gXyBDYW5vbmljYWwuRXhwMS50IGRlZmluaW5nID1cbiAgICBmdW4gZ3JvdXAgdGlkIGFyZ3MgLT5cbiAgICAgIGxldCBnaWQgPSBHcm91cC5pZCBncm91cCBpblxuICAgICAgbGV0IGZvcm1hbHMsIGJvZHkgPSBHcm91cC5sb29rdXAgZ3JvdXAgdGlkIGluXG4gICAgICBsZXQgcmVjb3JkX29yX25vcm1hbF92YXJpYW50ID1cbiAgICAgICAgbWF0Y2ggYm9keSB3aXRoXG4gICAgICAgIHwgUmVjb3JkIF8gfCBWYXJpYW50IF8gLT4gdHJ1ZVxuICAgICAgICB8IFR1cGxlIF8gfCBBbm5vdGF0ZSBfIHwgQmFzZSBfIHwgUG9seV92YXJpYW50IF8gfCBWYXIgXyB8IFJlY19hcHAgXyB8IFRvcF9hcHAgXyAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICBpblxuICAgICAgbGV0IGN5Y2xpYyA9IGlzX2N5Y2xpYyBncm91cCB0aWQgaW5cbiAgICAgIGxldCBjeWNsaWNfbm9fVlIgPSBpc19jeWNsaWNfd2l0aF9ub19pbnRlcnZlbmluZ19WUiBncm91cCB0aWQgaW5cbiAgICAgIGlmIChyZWNvcmRfb3Jfbm9ybWFsX3ZhcmlhbnQgJiYgY3ljbGljKSB8fCBjeWNsaWNfbm9fVlJcbiAgICAgIHRoZW5cbiAgICAgICAgRGVmaW5pbmcubG9va19lbnYgKGdpZCwgdGlkKVxuICAgICAgICA+Pj0gKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTb21lIHJlY3Vyc2UgLT4gcmV0dXJuIHJlY3Vyc2VcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIERlZmluaW5nLmV4dGVuZF9uZXdfdGlkIChnaWQsIHRpZCkgKGV2YWxfZGVmaW5pdGlvbiBncm91cCBmb3JtYWxzIGJvZHkpKVxuICAgICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCBSZWN1cnNpb25fbGV2ZWwgciAtPiByZXR1cm4gKENhbm9uaWNhbC5FeHAxLnJlY3Vyc2UgciBhcmdzKVxuICAgICAgICB8IERlZmluaXRpb24gZGVmIC0+IHJldHVybiAoQ2Fub25pY2FsLkV4cDEuYXBwbHkgZGVmIGFyZ3MpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHZlbnYgPVxuICAgICAgICAgIG1hdGNoIExpc3QuemlwIGZvcm1hbHMgYXJncyB3aXRoXG4gICAgICAgICAgfCBPayB4IC0+IFZlbnYuY3JlYXRlIHhcbiAgICAgICAgICB8IFVuZXF1YWxfbGVuZ3RocyAtPiBmYWlsd2l0aCBcImFwcGx5LCBpbmNvcnJlY3QgdHlwZSBhcHBsaWNhdGlvbiBhcml0eVwiXG4gICAgICAgIGluXG4gICAgICAgIGV2YWwgZ3JvdXAgdmVudiBib2R5KVxuICA7O1xuXG4gICgqIHRvcCBsZXZlbCBlbnRyeSBwb2ludCBmb3IgZXZhbHVhdGlvbiAqKVxuICBsZXQgZXZhbCA6IHQgLT4gQ2Fub25pY2FsLnQgPVxuICAgIGZ1biB0IC0+XG4gICAgICBsZXQgZ3JvdXAgPSBncm91cCAoTG9jYXRpb24ub2Zfc3RyaW5nIFwidG9wLWxldmVsXCIpIFtdIGluXG4gICAgICBsZXQgdmVudiA9IFZlbnYuY3JlYXRlIFtdIGluXG4gICAgICBsZXQgdiA9IERlZmluaW5nLmV4ZWMgKGV2YWwgZ3JvdXAgdmVudiB0KSBpblxuICAgICAgQ2Fub25pY2FsLkNyZWF0ZS5jcmVhdGUgdlxuICA7O1xuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWwgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDYW5vbmljYWxfZnVsbFxuXG4gIG1vZHVsZSBFeHAgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBWaXNpYmlsaXR5LnZpc2libGUgRXhwMS50XG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgRXZhbHVhdGlvbiAoQ2Fub25pY2FsX2Z1bGwpXG5tb2R1bGUgQ2Fub25pY2FsX3NlbGVjdGVkID0gQ2Fub25pY2FsX2RpZ2VzdFxubW9kdWxlIEV2YWx1YXRpb25fdG9fZGlnZXN0ID0gRXZhbHVhdGlvbiAoQ2Fub25pY2FsX3NlbGVjdGVkKVxuXG5sZXQgZXZhbF90b19kaWdlc3QgZXhwID0gQ2Fub25pY2FsX3NlbGVjdGVkLnRvX2RpZ2VzdCAoRXZhbHVhdGlvbl90b19kaWdlc3QuZXZhbCBleHApXG5sZXQgZXZhbF90b19kaWdlc3Rfc3RyaW5nIGV4cCA9IERpZ2VzdC50b19oZXggKGV2YWxfdG9fZGlnZXN0IGV4cClcblxubW9kdWxlIEZvcl90eXBlcmVwID0gc3RydWN0XG4gIGV4Y2VwdGlvbiBOb3RfYV90dXBsZSBvZiB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGRlY29uc3RydWN0X3R1cGxlX2V4biB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFR1cGxlIHRzIC0+IHRzXG4gICAgfCBfIC0+IHJhaXNlIChOb3RfYV90dXBsZSB0KVxuICA7O1xuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE5PVEU6XG4gICBJZiB0aGlzIGZpbGUgaXMgc3RyaW5nTGFiZWxzLm1saSwgcnVuIHRvb2xzL3N5bmNfc3RkbGliX2RvY3MgYWZ0ZXIgZWRpdGluZ1xuICAgaXQgdG8gZ2VuZXJhdGUgc3RyaW5nLm1saS5cblxuICAgSWYgdGhpcyBmaWxlIGlzIHN0cmluZy5tbGksIGRvIG5vdCBlZGl0IGl0IGRpcmVjdGx5IC0tIGVkaXRcbiAgIHN0cmluZ0xhYmVscy5tbGkgaW5zdGVhZC5cbiAqKVxuXG4oKiogU3RyaW5ncy5cblxuICAgIEEgc3RyaW5nIFtzXSBvZiBsZW5ndGggW25dIGlzIGFuIGluZGV4YWJsZSBhbmQgaW1tdXRhYmxlIHNlcXVlbmNlXG4gICAgb2YgW25dIGJ5dGVzLiBGb3IgaGlzdG9yaWNhbCByZWFzb25zIHRoZXNlIGJ5dGVzIGFyZSByZWZlcnJlZCB0b1xuICAgIGFzIGNoYXJhY3RlcnMuXG5cbiAgICBUaGUgc2VtYW50aWNzIG9mIHN0cmluZyBmdW5jdGlvbnMgaXMgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgIGluZGljZXMgYW5kIHBvc2l0aW9ucy4gVGhlc2UgYXJlIGRlcGljdGVkIGFuZCBkZXNjcmliZWRcbiAgICBhcyBmb2xsb3dzLlxuXG57dlxucG9zaXRpb25zICAwICAgMSAgIDIgICAzICAgNCAgICBuLTEgICAgblxuICAgICAgICAgICArLS0tKy0tLSstLS0rLS0tKyAgICAgKy0tLS0tK1xuICBpbmRpY2VzICB8IDAgfCAxIHwgMiB8IDMgfCAuLi4gfCBuLTEgfFxuICAgICAgICAgICArLS0tKy0tLSstLS0rLS0tKyAgICAgKy0tLS0tK1xudn1cbiAgICB7dWxcbiAgICB7LSBBbiB7ZSBpbmRleH0gW2ldIG9mIFtzXSBpcyBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBcXFtbMF07W24tMV1cXF0uXG4gICAgICAgSXQgcmVwcmVzZW50cyB0aGUgW2lddGggYnl0ZSAoY2hhcmFjdGVyKSBvZiBbc10gd2hpY2ggY2FuIGJlXG4gICAgICAgYWNjZXNzZWQgdXNpbmcgdGhlIGNvbnN0YW50IHRpbWUgc3RyaW5nIGluZGV4aW5nIG9wZXJhdG9yXG4gICAgICAgW3MuW2ldXS59XG4gICAgey0gQSB7ZSBwb3NpdGlvbn0gW2ldIG9mIFtzXSBpcyBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgICAgIFxcW1swXTtbbl1cXF0uIEl0IHJlcHJlc2VudHMgZWl0aGVyIHRoZSBwb2ludCBhdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAgICAgdGhlIHN0cmluZywgb3IgdGhlIHBvaW50IGJldHdlZW4gdHdvIGluZGljZXMsIG9yIHRoZSBwb2ludCBhdFxuICAgICAgIHRoZSBlbmQgb2YgdGhlIHN0cmluZy4gVGhlIFtpXXRoIGJ5dGUgaW5kZXggaXMgYmV0d2VlbiBwb3NpdGlvblxuICAgICAgIFtpXSBhbmQgW2krMV0ufX1cblxuICAgIFR3byBpbnRlZ2VycyBbc3RhcnRdIGFuZCBbbGVuXSBhcmUgc2FpZCB0byBkZWZpbmUgYSB7ZSB2YWxpZFxuICAgIHN1YnN0cmluZ30gb2YgW3NdIGlmIFtsZW4gPj0gMF0gYW5kIFtzdGFydF0sIFtzdGFydCtsZW5dIGFyZVxuICAgIHBvc2l0aW9ucyBvZiBbc10uXG5cbiAgICB7YiBVbmljb2RlIHRleHQufSBTdHJpbmdzIGJlaW5nIGFyYml0cmFyeSBzZXF1ZW5jZXMgb2YgYnl0ZXMsIHRoZXlcbiAgICBjYW4gaG9sZCBhbnkga2luZCBvZiB0ZXh0dWFsIGVuY29kaW5nLiBIb3dldmVyIHRoZSByZWNvbW1lbmRlZFxuICAgIGVuY29kaW5nIGZvciBzdG9yaW5nIFVuaWNvZGUgdGV4dCBpbiBPQ2FtbCBzdHJpbmdzIGlzIFVURi04LiBUaGlzXG4gICAgaXMgdGhlIGVuY29kaW5nIHVzZWQgYnkgVW5pY29kZSBlc2NhcGVzIGluIHN0cmluZyBsaXRlcmFscy4gRm9yXG4gICAgZXhhbXBsZSB0aGUgc3RyaW5nIFtcIlxcdXsxRjQyQn1cIl0gaXMgdGhlIFVURi04IGVuY29kaW5nIG9mIHRoZVxuICAgIFVuaWNvZGUgY2hhcmFjdGVyIFUrMUY0MkIuXG5cbiAgICB7YiBQYXN0IG11dGFiaWxpdHkufSBCZWZvcmUgT0NhbWwgNC4wMiwgc3RyaW5ncyB1c2VkIHRvIGJlIG1vZGlmaWFibGUgaW5cbiAgICBwbGFjZSBsaWtlIHshQnl0ZXMudH0gbXV0YWJsZSBzZXF1ZW5jZXMgb2YgYnl0ZXMuXG4gICAgT0NhbWwgNCBoYWQgdmFyaW91cyBjb21waWxlciBmbGFncyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHN1cHBvcnQgdGhlXG4gICAgdHJhbnNpdGlvbiBwZXJpb2QgZnJvbSBtdXRhYmxlIHRvIGltbXV0YWJsZSBzdHJpbmdzLlxuICAgIFRob3NlIG9wdGlvbnMgYXJlIG5vIGxvbmdlciBhdmFpbGFibGUsIGFuZCBzdHJpbmdzIGFyZSBub3cgYWx3YXlzXG4gICAgaW1tdXRhYmxlLlxuXG4gICAgVGhlIGxhYmVsZWQgdmVyc2lvbiBvZiB0aGlzIG1vZHVsZSBjYW4gYmUgdXNlZCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gICAgeyFTdGRMYWJlbHN9IG1vZHVsZS5cbiopXG5cbigqKiB7MTpzdHJpbmdzIFN0cmluZ3N9ICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuKCoqIFRoZSB0eXBlIGZvciBzdHJpbmdzLiAqKVxuXG52YWwgbWFrZSA6IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuKCoqIFttYWtlIG4gY10gaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIFtuXSB3aXRoIGVhY2ggaW5kZXggaG9sZGluZyB0aGVcbiAgICBjaGFyYWN0ZXIgW2NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW24gPCAwXSBvciBbbiA+IF17IVN5cy5tYXhfc3RyaW5nX2xlbmd0aH0uICopXG5cbnZhbCBpbml0IDogaW50IC0+IChpbnQgLT4gY2hhcikgLT4gc3RyaW5nXG4oKiogW2luaXQgbiBmXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW25dIHdpdGggaW5kZXhcbiAgICBbaV0gaG9sZGluZyB0aGUgY2hhcmFjdGVyIFtmIGldIChjYWxsZWQgaW4gaW5jcmVhc2luZyBpbmRleCBvcmRlcikuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS5cbiAgICBAc2luY2UgNC4wMi4wICopXG5cbnZhbCBlbXB0eSA6IHN0cmluZ1xuKCoqIFRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgb2ZfYnl0ZXMgOiBieXRlcyAtPiBzdHJpbmdcbigqKiBSZXR1cm4gYSBuZXcgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuIGJ5dGVcbiAgICBzZXF1ZW5jZS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCB0b19ieXRlcyA6IHN0cmluZyAtPiBieXRlc1xuKCoqIFJldHVybiBhIG5ldyBieXRlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuXG4gICAgc3RyaW5nLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuKCoqIFtsZW5ndGggc10gaXMgdGhlIGxlbmd0aCAobnVtYmVyIG9mIGJ5dGVzL2NoYXJhY3RlcnMpIG9mIFtzXS4gKilcblxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbigqKiBbZ2V0IHMgaV0gaXMgdGhlIGNoYXJhY3RlciBhdCBpbmRleCBbaV0gaW4gW3NdLiBUaGlzIGlzIHRoZSBzYW1lXG4gICAgYXMgd3JpdGluZyBbcy5baV1dLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIG5vdCBhbiBpbmRleCBvZiBbc10uICopXG5cbigqKiB7MTpjb25jYXQgQ29uY2F0ZW5hdGluZ31cblxuICAgIHtiIE5vdGUufSBUaGUgeyFTdGRsaWIuKCBeICl9IGJpbmFyeSBvcGVyYXRvciBjb25jYXRlbmF0ZXMgdHdvXG4gICAgc3RyaW5ncy4gKilcblxudmFsIGNvbmNhdCA6IHN0cmluZyAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbigqKiBbY29uY2F0IHNlcCBzc10gY29uY2F0ZW5hdGVzIHRoZSBsaXN0IG9mIHN0cmluZ3MgW3NzXSwgaW5zZXJ0aW5nXG4gICAgdGhlIHNlcGFyYXRvciBzdHJpbmcgW3NlcF0gYmV0d2VlbiBlYWNoLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhhblxuICAgIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy4gKilcblxudmFsIGNhdCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW2NhdCBzMSBzMl0gY29uY2F0ZW5hdGVzIHMxIGFuZCBzMiAoW3MxIF4gczJdKS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIHRoZSByZXN1bHQgaXMgbG9uZ2VyIHRoYW5cbiAgICB7IVN5cy5tYXhfc3RyaW5nX2xlbmd0aH0gYnl0ZXMuXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG4oKiogezE6cHJlZGljYXRlcyBQcmVkaWNhdGVzIGFuZCBjb21wYXJpc29uc30gKilcblxudmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbigqKiBbZXF1YWwgczAgczFdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbczBdIGFuZCBbczFdIGFyZSBjaGFyYWN0ZXItd2lzZVxuICAgIGVxdWFsLlxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuKCoqIFtjb21wYXJlIHMwIHMxXSBzb3J0cyBbczBdIGFuZCBbczFdIGluIGxleGljb2dyYXBoaWNhbCBvcmRlci4gW2NvbXBhcmVdXG4gICAgYmVoYXZlcyBsaWtlIHshU3RkbGliLmNvbXBhcmV9IG9uIHN0cmluZ3MgYnV0IG1heSBiZSBtb3JlIGVmZmljaWVudC4gKilcblxudmFsIHN0YXJ0c193aXRoIDpcbiAgcHJlZml4ICgqIGNvbW1lbnQgdGh3YXJ0cyB0b29scy9zeW5jX3N0ZGxpYl9kb2NzICopIDpzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2xcbigqKiBbc3RhcnRzX3dpdGggXVt+cHJlZml4IHNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbc10gc3RhcnRzIHdpdGhcbiAgICBbcHJlZml4XS5cblxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGVuZHNfd2l0aCA6XG4gIHN1ZmZpeCAoKiBjb21tZW50IHRod2FydHMgdG9vbHMvc3luY19zdGRsaWJfZG9jcyAqKSA6c3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4oKiogW2VuZHNfd2l0aCBdW35zdWZmaXggc10gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtzXSBlbmRzIHdpdGggW3N1ZmZpeF0uXG5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBjb250YWluc19mcm9tIDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGJvb2xcbigqKiBbY29udGFpbnNfZnJvbSBzIHN0YXJ0IGNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbY10gYXBwZWFycyBpbiBbc11cbiAgICBhZnRlciBwb3NpdGlvbiBbc3RhcnRdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3N0YXJ0XSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCByY29udGFpbnNfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBib29sXG4oKiogW3Jjb250YWluc19mcm9tIHMgc3RvcCBjXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW2NdIGFwcGVhcnMgaW4gW3NdXG4gICAgYmVmb3JlIHBvc2l0aW9uIFtzdG9wKzFdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3N0b3AgPCAwXSBvciBbc3RvcCsxXSBpcyBub3QgYSB2YWxpZFxuICAgIHBvc2l0aW9uIGluIFtzXS4gKilcblxudmFsIGNvbnRhaW5zIDogc3RyaW5nIC0+IGNoYXIgLT4gYm9vbFxuKCoqIFtjb250YWlucyBzIGNdIGlzIHshU3RyaW5nLmNvbnRhaW5zX2Zyb219WyBzIDAgY10uICopXG5cbigqKiB7MTpleHRyYWN0IEV4dHJhY3Rpbmcgc3Vic3RyaW5nc30gKilcblxudmFsIHN1YiA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHN0cmluZ1xuKCoqIFtzdWIgcyBwb3MgbGVuXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW2xlbl0sIGNvbnRhaW5pbmcgdGhlXG4gICAgc3Vic3RyaW5nIG9mIFtzXSB0aGF0IHN0YXJ0cyBhdCBwb3NpdGlvbiBbcG9zXSBhbmQgaGFzIGxlbmd0aFxuICAgIFtsZW5dLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3Bvc10gYW5kIFtsZW5dIGRvIG5vdCBkZXNpZ25hdGUgYSB2YWxpZFxuICAgIHN1YnN0cmluZyBvZiBbc10uICopXG5cbnZhbCBzcGxpdF9vbl9jaGFyIDogY2hhciAtPiBzdHJpbmcgLT4gc3RyaW5nIGxpc3RcbigqKiBbc3BsaXRfb25fY2hhciBzZXAgc10gaXMgdGhlIGxpc3Qgb2YgYWxsIChwb3NzaWJseSBlbXB0eSlcbiAgICBzdWJzdHJpbmdzIG9mIFtzXSB0aGF0IGFyZSBkZWxpbWl0ZWQgYnkgdGhlIGNoYXJhY3RlciBbc2VwXS5cblxuICAgIFRoZSBmdW5jdGlvbidzIHJlc3VsdCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzOlxuICAgIHt1bFxuICAgIHstIFRoZSBsaXN0IGlzIG5vdCBlbXB0eS59XG4gICAgey0gQ29uY2F0ZW5hdGluZyBpdHMgZWxlbWVudHMgdXNpbmcgW3NlcF0gYXMgYSBzZXBhcmF0b3IgcmV0dXJucyBhXG4gICAgICBzdHJpbmcgZXF1YWwgdG8gdGhlIGlucHV0IChbY29uY2F0IChtYWtlIDEgc2VwKVxuICAgICAgKHNwbGl0X29uX2NoYXIgc2VwIHMpID0gc10pLn1cbiAgICB7LSBObyBzdHJpbmcgaW4gdGhlIHJlc3VsdCBjb250YWlucyB0aGUgW3NlcF0gY2hhcmFjdGVyLn19XG5cbiAgICBAc2luY2UgNC4wNC4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG4oKiogezE6dHJhbnNmb3JtaW5nIFRyYW5zZm9ybWluZ30gKilcblxudmFsIG1hcCA6IChjaGFyIC0+IGNoYXIpIC0+IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbWFwIGYgc10gaXMgdGhlIHN0cmluZyByZXN1bHRpbmcgZnJvbSBhcHBseWluZyBbZl0gdG8gYWxsIHRoZVxuICAgIGNoYXJhY3RlcnMgb2YgW3NdIGluIGluY3JlYXNpbmcgb3JkZXIuXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbnZhbCBtYXBpIDogKGludCAtPiBjaGFyIC0+IGNoYXIpIC0+IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbWFwaSBmIHNdIGlzIGxpa2UgeyFtYXB9IGJ1dCB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciBpcyBhbHNvXG4gICAgcGFzc2VkIHRvIFtmXS5cblxuICAgIEBzaW5jZSA0LjAyLjAgKilcblxudmFsIGZvbGRfbGVmdCA6ICgnYSAtPiBjaGFyIC0+ICdhKSAtPiAnYSAtPiBzdHJpbmcgLT4gJ2FcbigqKiBbZm9sZF9sZWZ0IGYgeCBzXSBjb21wdXRlcyBbZiAoLi4uIChmIChmIHggcy5bMF0pIHMuWzFdKSAuLi4pIHMuW24tMV1dLFxuICAgIHdoZXJlIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgW3NdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGZvbGRfcmlnaHQgOiAoY2hhciAtPiAnYSAtPiAnYSkgLT4gc3RyaW5nIC0+ICdhIC0+ICdhXG4oKiogW2ZvbGRfcmlnaHQgZiBzIHhdIGNvbXB1dGVzIFtmIHMuWzBdIChmIHMuWzFdICggLi4uIChmIHMuW24tMV0geCkgLi4uKSldLFxuICAgIHdoZXJlIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgW3NdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGZvcl9hbGwgOiAoY2hhciAtPiBib29sKSAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtmb3JfYWxsIHAgc10gY2hlY2tzIGlmIGFsbCBjaGFyYWN0ZXJzIGluIFtzXSBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUgW3BdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGV4aXN0cyA6IChjaGFyIC0+IGJvb2wpIC0+IHN0cmluZyAtPiBib29sXG4oKiogW2V4aXN0cyBwIHNdIGNoZWNrcyBpZiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIG9mIFtzXSBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZVxuICAgIFtwXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCB0cmltIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt0cmltIHNdIGlzIFtzXSB3aXRob3V0IGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuIFdoaXRlc3BhY2VcbiAgICBjaGFyYWN0ZXJzIGFyZTogWycgJ10sIFsnXFx4MEMnXSAoZm9ybSBmZWVkKSwgWydcXG4nXSwgWydcXHInXSwgYW5kIFsnXFx0J10uXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbnZhbCBlc2NhcGVkIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFtlc2NhcGVkIHNdIGlzIFtzXSB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBlc2NhcGVcbiAgICBzZXF1ZW5jZXMsIGZvbGxvd2luZyB0aGUgbGV4aWNhbCBjb252ZW50aW9ucyBvZiBPQ2FtbC5cblxuICAgIEFsbCBjaGFyYWN0ZXJzIG91dHNpZGUgdGhlIFVTLUFTQ0lJIHByaW50YWJsZSByYW5nZSBcXFsweDIwOzB4N0VcXF0gYXJlXG4gICAgZXNjYXBlZCwgYXMgd2VsbCBhcyBiYWNrc2xhc2ggKDB4MkYpIGFuZCBkb3VibGUtcXVvdGUgKDB4MjIpLlxuXG4gICAgVGhlIGZ1bmN0aW9uIHshU2NhbmYudW5lc2NhcGVkfSBpcyBhIGxlZnQgaW52ZXJzZSBvZiBbZXNjYXBlZF0sXG4gICAgaS5lLiBbU2NhbmYudW5lc2NhcGVkIChlc2NhcGVkIHMpID0gc10gZm9yIGFueSBzdHJpbmcgW3NdICh1bmxlc3NcbiAgICBbZXNjYXBlZCBzXSBmYWlscykuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiB0aGUgcmVzdWx0IGlzIGxvbmdlciB0aGFuXG4gICAgeyFTeXMubWF4X3N0cmluZ19sZW5ndGh9IGJ5dGVzLiAqKVxuXG52YWwgdXBwZXJjYXNlX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt1cHBlcmNhc2VfYXNjaWkgc10gaXMgW3NdIHdpdGggYWxsIGxvd2VyY2FzZSBsZXR0ZXJzXG4gICAgdHJhbnNsYXRlZCB0byB1cHBlcmNhc2UsIHVzaW5nIHRoZSBVUy1BU0NJSSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxudmFsIGxvd2VyY2FzZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbG93ZXJjYXNlX2FzY2lpIHNdIGlzIFtzXSB3aXRoIGFsbCB1cHBlcmNhc2UgbGV0dGVycyB0cmFuc2xhdGVkXG4gICAgdG8gbG93ZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCBjYXBpdGFsaXplX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFtjYXBpdGFsaXplX2FzY2lpIHNdIGlzIFtzXSB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvXG4gICAgdXBwZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCB1bmNhcGl0YWxpemVfYXNjaWkgOiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW3VuY2FwaXRhbGl6ZV9hc2NpaSBzXSBpcyBbc10gd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIHNldCB0byBsb3dlcmNhc2UsXG4gICAgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG4oKiogezE6dHJhdmVyc2luZyBUcmF2ZXJzaW5nfSAqKVxuXG52YWwgaXRlciA6IChjaGFyIC0+IHVuaXQpIC0+IHN0cmluZyAtPiB1bml0XG4oKiogW2l0ZXIgZiBzXSBhcHBsaWVzIGZ1bmN0aW9uIFtmXSBpbiB0dXJuIHRvIGFsbCB0aGUgY2hhcmFjdGVycyBvZiBbc10uXG4gICAgSXQgaXMgZXF1aXZhbGVudCB0byBbZiBzLlswXTsgZiBzLlsxXTsgLi4uOyBmIHMuW2xlbmd0aCBzIC0gMV07ICgpXS4gKilcblxudmFsIGl0ZXJpIDogKGludCAtPiBjaGFyIC0+IHVuaXQpIC0+IHN0cmluZyAtPiB1bml0XG4oKiogW2l0ZXJpXSBpcyBsaWtlIHshaXRlcn0sIGJ1dCB0aGUgZnVuY3Rpb24gaXMgYWxzbyBnaXZlbiB0aGVcbiAgICBjb3JyZXNwb25kaW5nIGNoYXJhY3RlciBpbmRleC5cblxuICAgIEBzaW5jZSA0LjAwLjAgKilcblxuKCoqIHsxOnNlYXJjaGluZyBTZWFyY2hpbmd9ICopXG5cbnZhbCBpbmRleF9mcm9tIDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGludFxuKCoqIFtpbmRleF9mcm9tIHMgaSBjXSBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgW2NdIGluXG4gICAgW3NdIGFmdGVyIHBvc2l0aW9uIFtpXS5cblxuICAgIEByYWlzZSBOb3RfZm91bmQgaWYgW2NdIGRvZXMgbm90IG9jY3VyIGluIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0uXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS4gKilcblxuXG52YWwgaW5kZXhfZnJvbV9vcHQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtpbmRleF9mcm9tX29wdCBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIFtjXVxuICAgIGluIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0gKGlmIGFueSkuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaV0gaXMgbm90IGEgdmFsaWQgcG9zaXRpb24gaW4gW3NdLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCByaW5kZXhfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnRcbigqKiBbcmluZGV4X2Zyb20gcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIFtjXSBpblxuICAgIFtzXSBiZWZvcmUgcG9zaXRpb24gW2krMV0uXG5cbiAgICBAcmFpc2UgTm90X2ZvdW5kIGlmIFtjXSBkb2VzIG5vdCBvY2N1ciBpbiBbc10gYmVmb3JlIHBvc2l0aW9uIFtpKzFdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpKzFdIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS4gKilcblxudmFsIHJpbmRleF9mcm9tX29wdCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnQgb3B0aW9uXG4oKiogW3JpbmRleF9mcm9tX29wdCBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgW2NdXG4gICAgaW4gW3NdIGJlZm9yZSBwb3NpdGlvbiBbaSsxXSAoaWYgYW55KS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpKzFdIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgaW5kZXggOiBzdHJpbmcgLT4gY2hhciAtPiBpbnRcbigqKiBbaW5kZXggcyBjXSBpcyB7IVN0cmluZy5pbmRleF9mcm9tfVsgcyAwIGNdLiAqKVxuXG52YWwgaW5kZXhfb3B0IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtpbmRleF9vcHQgcyBjXSBpcyB7IVN0cmluZy5pbmRleF9mcm9tX29wdH1bIHMgMCBjXS5cblxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCByaW5kZXggOiBzdHJpbmcgLT4gY2hhciAtPiBpbnRcbigqKiBbcmluZGV4IHMgY10gaXMgeyFTdHJpbmcucmluZGV4X2Zyb219WyBzIChsZW5ndGggcyAtIDEpIGNdLiAqKVxuXG52YWwgcmluZGV4X29wdCA6IHN0cmluZyAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbcmluZGV4X29wdCBzIGNdIGlzIHshU3RyaW5nLnJpbmRleF9mcm9tX29wdH1bIHMgKGxlbmd0aCBzIC0gMSkgY10uXG5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG4oKiogezEgU3RyaW5ncyBhbmQgU2VxdWVuY2VzfSAqKVxuXG52YWwgdG9fc2VxIDogdCAtPiBjaGFyIFNlcS50XG4oKiogW3RvX3NlcSBzXSBpcyBhIHNlcXVlbmNlIG1hZGUgb2YgdGhlIHN0cmluZydzIGNoYXJhY3RlcnMgaW5cbiAgICBpbmNyZWFzaW5nIG9yZGVyLiBJbiBbXCJ1bnNhZmUtc3RyaW5nXCJdIG1vZGUsIG1vZGlmaWNhdGlvbnMgb2YgdGhlIHN0cmluZ1xuICAgIGR1cmluZyBpdGVyYXRpb24gd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIHNlcXVlbmNlLlxuXG4gICAgQHNpbmNlIDQuMDcgKilcblxudmFsIHRvX3NlcWkgOiB0IC0+IChpbnQgKiBjaGFyKSBTZXEudFxuKCoqIFt0b19zZXFpIHNdIGlzIGxpa2UgeyF0b19zZXF9IGJ1dCBhbHNvIHR1cGxlcyB0aGUgY29ycmVzcG9uZGluZyBpbmRleC5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbnZhbCBvZl9zZXEgOiBjaGFyIFNlcS50IC0+IHRcbigqKiBbb2Zfc2VxIHNdIGlzIGEgc3RyaW5nIG1hZGUgb2YgdGhlIHNlcXVlbmNlJ3MgY2hhcmFjdGVycy5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbigqKiB7MTp1dGYgVVRGIGRlY29kaW5nIGFuZCB2YWxpZGF0aW9uc31cblxuICAgIEBzaW5jZSA0LjE0ICopXG5cbigqKiB7Mjp1dGZfOCBVVEYtOH0gKilcblxudmFsIGdldF91dGZfOF91Y2hhciA6IHQgLT4gaW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbigqKiBbZ2V0X3V0Zl84X3VjaGFyIGIgaV0gZGVjb2RlcyBhbiBVVEYtOCBjaGFyYWN0ZXIgYXQgaW5kZXggW2ldIGluXG4gICAgW2JdLiAqKVxuXG52YWwgaXNfdmFsaWRfdXRmXzggOiB0IC0+IGJvb2xcbigqKiBbaXNfdmFsaWRfdXRmXzggYl0gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtiXSBjb250YWlucyB2YWxpZFxuICAgIFVURi04IGRhdGEuICopXG5cbigqKiB7Mjp1dGZfMTZiZSBVVEYtMTZCRX0gKilcblxudmFsIGdldF91dGZfMTZiZV91Y2hhciA6IHQgLT4gaW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbigqKiBbZ2V0X3V0Zl8xNmJlX3VjaGFyIGIgaV0gZGVjb2RlcyBhbiBVVEYtMTZCRSBjaGFyYWN0ZXIgYXQgaW5kZXhcbiAgICBbaV0gaW4gW2JdLiAqKVxuXG52YWwgaXNfdmFsaWRfdXRmXzE2YmUgOiB0IC0+IGJvb2xcbigqKiBbaXNfdmFsaWRfdXRmXzE2YmUgYl0gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtiXSBjb250YWlucyB2YWxpZFxuICAgIFVURi0xNkJFIGRhdGEuICopXG5cbigqKiB7Mjp1dGZfMTZsZSBVVEYtMTZMRX0gKilcblxudmFsIGdldF91dGZfMTZsZV91Y2hhciA6IHQgLT4gaW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbigqKiBbZ2V0X3V0Zl8xNmxlX3VjaGFyIGIgaV0gZGVjb2RlcyBhbiBVVEYtMTZMRSBjaGFyYWN0ZXIgYXQgaW5kZXhcbiAgICBbaV0gaW4gW2JdLiAqKVxuXG52YWwgaXNfdmFsaWRfdXRmXzE2bGUgOiB0IC0+IGJvb2xcbigqKiBbaXNfdmFsaWRfdXRmXzE2bGUgYl0gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtiXSBjb250YWlucyB2YWxpZFxuICAgIFVURi0xNkxFIGRhdGEuICopXG5cbnZhbCBibGl0IDpcbiAgc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbigqKiBbYmxpdCBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5dIGNvcGllcyBbbGVuXSBieXRlc1xuICAgIGZyb20gdGhlIHN0cmluZyBbc3JjXSwgc3RhcnRpbmcgYXQgaW5kZXggW3NyY19wb3NdLFxuICAgIHRvIGJ5dGUgc2VxdWVuY2UgW2RzdF0sIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBudW1iZXIgW2RzdF9wb3NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3NyY19wb3NdIGFuZCBbbGVuXSBkbyBub3RcbiAgICBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbc3JjXSwgb3IgaWYgW2RzdF9wb3NdIGFuZCBbbGVuXVxuICAgIGRvIG5vdCBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbZHN0XS4gKilcblxuKCoqIHsxIEJpbmFyeSBkZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuKCoqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBzZWN0aW9uIGJpbmFyeSBkZWNvZGUgaW50ZWdlcnMgZnJvbSBzdHJpbmdzLlxuXG4gICAgQWxsIGZvbGxvd2luZyBmdW5jdGlvbnMgcmFpc2UgW0ludmFsaWRfYXJndW1lbnRdIGlmIHRoZSBjaGFyYWN0ZXJzXG4gICAgbmVlZGVkIGF0IGluZGV4IFtpXSB0byBkZWNvZGUgdGhlIGludGVnZXIgYXJlIG5vdCBhdmFpbGFibGUuXG5cbiAgICBMaXR0bGUtZW5kaWFuIChyZXNwLiBiaWctZW5kaWFuKSBlbmNvZGluZyBtZWFucyB0aGF0IGxlYXN0XG4gICAgKHJlc3AuIG1vc3QpIHNpZ25pZmljYW50IGJ5dGVzIGFyZSBzdG9yZWQgZmlyc3QuICBCaWctZW5kaWFuIGlzXG4gICAgYWxzbyBrbm93biBhcyBuZXR3b3JrIGJ5dGUgb3JkZXIuICBOYXRpdmUtZW5kaWFuIGVuY29kaW5nIGlzXG4gICAgZWl0aGVyIGxpdHRsZS1lbmRpYW4gb3IgYmlnLWVuZGlhbiBkZXBlbmRpbmcgb24geyFTeXMuYmlnX2VuZGlhbn0uXG5cbiAgICAzMi1iaXQgYW5kIDY0LWJpdCBpbnRlZ2VycyBhcmUgcmVwcmVzZW50ZWQgYnkgdGhlIFtpbnQzMl0gYW5kXG4gICAgW2ludDY0XSB0eXBlcywgd2hpY2ggY2FuIGJlIGludGVycHJldGVkIGVpdGhlciBhcyBzaWduZWQgb3JcbiAgICB1bnNpZ25lZCBudW1iZXJzLlxuXG4gICAgOC1iaXQgYW5kIDE2LWJpdCBpbnRlZ2VycyBhcmUgcmVwcmVzZW50ZWQgYnkgdGhlIFtpbnRdIHR5cGUsXG4gICAgd2hpY2ggaGFzIG1vcmUgYml0cyB0aGFuIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBUaGVzZSBleHRyYSBiaXRzXG4gICAgYXJlIHNpZ24tZXh0ZW5kZWQgKG9yIHplcm8tZXh0ZW5kZWQpIGZvciBmdW5jdGlvbnMgd2hpY2ggZGVjb2RlIDgtYml0XG4gICAgb3IgMTYtYml0IGludGVnZXJzIGFuZCByZXByZXNlbnRlZCB0aGVtIHdpdGggW2ludF0gdmFsdWVzLlxuKilcblxudmFsIGdldF91aW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF91aW50OCBiIGldIGlzIFtiXSdzIHVuc2lnbmVkIDgtYml0IGludGVnZXIgc3RhcnRpbmcgYXQgY2hhcmFjdGVyXG4gICAgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X2ludDggYiBpXSBpcyBbYl0ncyBzaWduZWQgOC1iaXQgaW50ZWdlciBzdGFydGluZyBhdCBjaGFyYWN0ZXJcbiAgICBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X3VpbnQxNl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF91aW50MTZfbmUgYiBpXSBpcyBbYl0ncyBuYXRpdmUtZW5kaWFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfdWludDE2X2JlIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQxNl9iZSBiIGldIGlzIFtiXSdzIGJpZy1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF91aW50MTZfbGUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfdWludDE2X2xlIGIgaV0gaXMgW2JdJ3MgbGl0dGxlLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X2ludDE2X25lIGIgaV0gaXMgW2JdJ3MgbmF0aXZlLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQxNl9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF9pbnQxNl9iZSBiIGldIGlzIFtiXSdzIGJpZy1lbmRpYW4gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MTZfbGUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50MTZfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIHNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDMyX25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMlxuKCoqIFtnZXRfaW50MzJfbmUgYiBpXSBpcyBbYl0ncyBuYXRpdmUtZW5kaWFuIDMyLWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBoYXNoIDogdCAtPiBpbnRcbigqKiBBbiB1bnNlZWRlZCBoYXNoIGZ1bmN0aW9uIGZvciBzdHJpbmdzLCB3aXRoIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBhc1xuICAgIHshSGFzaHRibC5oYXNofS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50XG4gICAgdG8gdGhlIGZ1bmN0b3IgeyFIYXNodGJsLk1ha2V9LlxuXG4gICAgQHNpbmNlIDUuMC4wICopXG5cbnZhbCBzZWVkZWRfaGFzaCA6IGludCAtPiB0IC0+IGludFxuKCoqIEEgc2VlZGVkIGhhc2ggZnVuY3Rpb24gZm9yIHN0cmluZ3MsIHdpdGggdGhlIHNhbWUgb3V0cHV0IHZhbHVlIGFzXG4gICAgeyFIYXNodGJsLnNlZWRlZF9oYXNofS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmUgcGFzc2VkIGFzXG4gICAgYXJndW1lbnQgdG8gdGhlIGZ1bmN0b3IgeyFIYXNodGJsLk1ha2VTZWVkZWR9LlxuXG4gICAgQHNpbmNlIDUuMC4wICopXG5cbnZhbCBnZXRfaW50MzJfYmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyXG4oKiogW2dldF9pbnQzMl9iZSBiIGldIGlzIFtiXSdzIGJpZy1lbmRpYW4gMzItYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQzMl9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzJcbigqKiBbZ2V0X2ludDMyX2xlIGIgaV0gaXMgW2JdJ3MgbGl0dGxlLWVuZGlhbiAzMi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDY0X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NFxuKCoqIFtnZXRfaW50NjRfbmUgYiBpXSBpcyBbYl0ncyBuYXRpdmUtZW5kaWFuIDY0LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50NjRfYmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0XG4oKiogW2dldF9pbnQ2NF9iZSBiIGldIGlzIFtiXSdzIGJpZy1lbmRpYW4gNjQtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQ2NF9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjRcbigqKiBbZ2V0X2ludDY0X2xlIGIgaV0gaXMgW2JdJ3MgbGl0dGxlLWVuZGlhbiA2NC1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG4oKiovKiopXG5cbigqIFRoZSBmb2xsb3dpbmcgaXMgZm9yIHN5c3RlbSB1c2Ugb25seS4gRG8gbm90IGNhbGwgZGlyZWN0bHkuICopXG5cbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gIHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPlxuICAgIHVuaXQgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuIl19
