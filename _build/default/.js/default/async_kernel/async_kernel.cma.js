// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Async_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Async_kernel = [0];
   runtime.caml_register_global(0, Async_kernel, "Async_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_ns
//# unitInfo: Requires: Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_ns$0 = "Async_kernel__Time_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/time_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    typerep_of_t = Core_Time_ns_alternate_sexp[1],
    typename_of_t = Core_Time_ns_alternate_sexp[2],
    bin_size_t = Core_Time_ns_alternate_sexp[3],
    bin_write_t = Core_Time_ns_alternate_sexp[4],
    bin_read_t = Core_Time_ns_alternate_sexp[5],
    bin_read_t$0 = Core_Time_ns_alternate_sexp[6],
    bin_shape_t = Core_Time_ns_alternate_sexp[7],
    bin_writer_t = Core_Time_ns_alternate_sexp[8],
    bin_reader_t = Core_Time_ns_alternate_sexp[9],
    bin_t = Core_Time_ns_alternate_sexp[10],
    quickcheck_generator = Core_Time_ns_alternate_sexp[11],
    quickcheck_observer = Core_Time_ns_alternate_sexp[12],
    quickcheck_shrinker = Core_Time_ns_alternate_sexp[13],
    gen_incl = Core_Time_ns_alternate_sexp[14],
    gen_uniform_incl = Core_Time_ns_alternate_sexp[15],
    is_earlier = Core_Time_ns_alternate_sexp[16],
    is_later = Core_Time_ns_alternate_sexp[17],
    of_date_ofday = Core_Time_ns_alternate_sexp[18],
    of_date_ofday_precise = Core_Time_ns_alternate_sexp[19],
    to_date_ofday = Core_Time_ns_alternate_sexp[20],
    to_date_ofday_precise = Core_Time_ns_alternate_sexp[21],
    to_date = Core_Time_ns_alternate_sexp[22],
    to_ofday = Core_Time_ns_alternate_sexp[23],
    reset_date_cache = Core_Time_ns_alternate_sexp[24],
    convert = Core_Time_ns_alternate_sexp[25],
    utc_offset = Core_Time_ns_alternate_sexp[26],
    to_filename_string = Core_Time_ns_alternate_sexp[27],
    of_filename_string = Core_Time_ns_alternate_sexp[28],
    to_string_abs = Core_Time_ns_alternate_sexp[29],
    to_string_abs_trimmed = Core_Time_ns_alternate_sexp[30],
    to_string_abs_parts = Core_Time_ns_alternate_sexp[31],
    to_string_trimmed = Core_Time_ns_alternate_sexp[32],
    to_sec_string = Core_Time_ns_alternate_sexp[33],
    to_sec_string_with_zone = Core_Time_ns_alternate_sexp[34],
    of_localized_string = Core_Time_ns_alternate_sexp[35],
    of_string_gen = Core_Time_ns_alternate_sexp[36],
    to_string_iso8601_basic = Core_Time_ns_alternate_sexp[37],
    occurrence = Core_Time_ns_alternate_sexp[38],
    of_string = Core_Time_ns_alternate_sexp[39],
    of_string_with_utc_offset = Core_Time_ns_alternate_sexp[40],
    to_string = Core_Time_ns_alternate_sexp[41],
    to_string_utc = Core_Time_ns_alternate_sexp[42],
    epoch = Core_Time_ns_alternate_sexp[43],
    min_value_representable = Core_Time_ns_alternate_sexp[44],
    max_value_representable = Core_Time_ns_alternate_sexp[45],
    min_value_for_1us_rounding = Core_Time_ns_alternate_sexp[46],
    max_value_for_1us_rounding = Core_Time_ns_alternate_sexp[47],
    min_value = Core_Time_ns_alternate_sexp[48],
    max_value = Core_Time_ns_alternate_sexp[49],
    now = Core_Time_ns_alternate_sexp[50],
    add = Core_Time_ns_alternate_sexp[51],
    add_saturating = Core_Time_ns_alternate_sexp[52],
    sub_saturating = Core_Time_ns_alternate_sexp[53],
    sub = Core_Time_ns_alternate_sexp[54],
    next = Core_Time_ns_alternate_sexp[55],
    prev = Core_Time_ns_alternate_sexp[56],
    diff = Core_Time_ns_alternate_sexp[57],
    abs_diff = Core_Time_ns_alternate_sexp[58],
    to_span_since_epoch = Core_Time_ns_alternate_sexp[59],
    of_span_since_epoch = Core_Time_ns_alternate_sexp[60],
    to_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[61],
    of_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[62],
    to_int_ns_since_epoch = Core_Time_ns_alternate_sexp[63],
    of_int_ns_since_epoch = Core_Time_ns_alternate_sexp[64],
    next_multiple = Core_Time_ns_alternate_sexp[65],
    prev_multiple = Core_Time_ns_alternate_sexp[66],
    random = Core_Time_ns_alternate_sexp[67],
    of_time = Core_Time_ns_alternate_sexp[68],
    to_time = Core_Time_ns_alternate_sexp[69],
    to_time_float_round_nearest = Core_Time_ns_alternate_sexp[70],
    to_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[71],
    of_time_float_round_nearest = Core_Time_ns_alternate_sexp[72],
    of_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[73],
    arg_type = Core_Time_ns_alternate_sexp[74],
    get_sexp_zone = Core_Time_ns_alternate_sexp[75],
    interruptible_pause = Core_Time_ns_alternate_sexp[76],
    of_date_ofday_zoned = Core_Time_ns_alternate_sexp[77],
    of_string_abs = Core_Time_ns_alternate_sexp[78],
    of_string_fix_proto = Core_Time_ns_alternate_sexp[79],
    pause = Core_Time_ns_alternate_sexp[80],
    pause_forever = Core_Time_ns_alternate_sexp[81],
    pp = Core_Time_ns_alternate_sexp[82],
    set_sexp_zone = Core_Time_ns_alternate_sexp[83],
    sexp_of_t_abs = Core_Time_ns_alternate_sexp[84],
    t_of_sexp_abs = Core_Time_ns_alternate_sexp[85],
    to_date_ofday_zoned = Core_Time_ns_alternate_sexp[86],
    to_ofday_zoned = Core_Time_ns_alternate_sexp[87],
    to_string_fix_proto = Core_Time_ns_alternate_sexp[88],
    hash_fold_t = Core_Time_ns_alternate_sexp[89],
    hash = Core_Time_ns_alternate_sexp[90],
    t_of_sexp = Core_Time_ns_alternate_sexp[91],
    sexp_of_t = Core_Time_ns_alternate_sexp[92],
    t_sexp_grammar = Core_Time_ns_alternate_sexp[93],
    symbol = Core_Time_ns_alternate_sexp[94],
    symbol$0 = Core_Time_ns_alternate_sexp[95],
    symbol$1 = Core_Time_ns_alternate_sexp[96],
    symbol$2 = Core_Time_ns_alternate_sexp[97],
    symbol$3 = Core_Time_ns_alternate_sexp[98],
    symbol$4 = Core_Time_ns_alternate_sexp[99],
    equal = Core_Time_ns_alternate_sexp[100],
    compare = Core_Time_ns_alternate_sexp[101],
    min = Core_Time_ns_alternate_sexp[102],
    max = Core_Time_ns_alternate_sexp[103],
    ascending = Core_Time_ns_alternate_sexp[104],
    descending = Core_Time_ns_alternate_sexp[105],
    between = Core_Time_ns_alternate_sexp[106],
    clamp_exn = Core_Time_ns_alternate_sexp[107],
    clamp = Core_Time_ns_alternate_sexp[108],
    comparator = Core_Time_ns_alternate_sexp[109],
    validate_lbound = Core_Time_ns_alternate_sexp[110],
    validate_ubound = Core_Time_ns_alternate_sexp[111],
    validate_bound = Core_Time_ns_alternate_sexp[112],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_ns = cst_Async_kernel_Time_ns$0;
   function after(t, span){
    var result = caml_call2(add, t, span);
    if
     (caml_call2(Core_Time_ns[1][18], span, Core_Time_ns[1][75])
      && caml_call2(symbol$3, result, t))
     return max_value_for_1us_rounding;
    return result;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_ns);
   var
    Async_kernel_Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after];
   runtime.caml_register_global
    (13, Async_kernel_Time_ns, cst_Async_kernel_Time_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Debug
//# unitInfo: Requires: Async_kernel__Time_ns, Async_kernel_config, Core, Core__Sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Debug$0 = "Async_kernel__Debug",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_config = global_data.Async_kernel_config,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Debug$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/debug.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    include = Async_kernel_config[14],
    clock = include[1],
    fd = include[2],
    file_descr_watcher = include[3],
    finalizers = include[4],
    interruptor = include[5],
    monitor = include[6],
    monitor_send_exn = include[7],
    parallel = include[8],
    reader = include[9],
    scheduler = include[10],
    shutdown = include[11],
    thread_pool = include[12],
    thread_safe = include[13],
    writer = include[14],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Debug = cst_Async_kernel_Debug$0;
   function log(arg2_003, arg3_004, sexp_of_a){
    var
     arg1_002 = caml_call1(Async_kernel_Time_ns[50], 0),
     arg0_001 = caml_call1(Async_kernel_config[31][1], 0),
     res0_005 = caml_call1(Core_Sexp[90], arg0_001),
     res1_006 = caml_call1(Async_kernel_Time_ns[92], arg1_002),
     res2_007 = caml_call1(Core[471], arg2_003),
     res3_008 = caml_call1(sexp_of_a, arg3_004),
     _b_ =
       caml_call2
        (Core_Sexp[81],
         0,
         [1, [0, res0_005, [0, res1_006, [0, res2_007, [0, res3_008, 0]]]]]);
    return caml_call2(Core[231], _a_, _b_);
   }
   function log_string(message){return log(message, 0, Core[518]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Debug);
   var
    Async_kernel_Debug =
      [0,
       clock,
       fd,
       file_descr_watcher,
       finalizers,
       interruptor,
       monitor,
       monitor_send_exn,
       parallel,
       reader,
       scheduler,
       shutdown,
       thread_pool,
       thread_safe,
       writer,
       log,
       log_string];
   runtime.caml_register_global
    (16, Async_kernel_Debug, cst_Async_kernel_Debug$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Import
//# unitInfo: Requires: Core, Core__Debug, Core__Int, Core__Sexp, Core__String, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Import$0 = "Async_kernel__Import",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Debug = global_data.Core__Debug,
    Core_Time_ns = global_data.Core__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    include = Core_Int[99],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    concat = Core_String[32],
    eprint = Core_Debug[1],
    eprint_s = Core_Debug[3],
    eprints = Core_Debug[2],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Import = cst_Async_kernel_Import$0;
   function print_s(sexp){
    var _b_ = caml_call2(Core_Sexp[81], 0, sexp);
    return caml_call2(Core[250], _a_, _b_);
   }
   var sec = Core_Time_ns[1][81], Thread = [0], Unix = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Import);
   var
    Async_kernel_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       concat,
       eprint,
       eprint_s,
       eprints,
       print_s,
       sec,
       Thread,
       Unix];
   runtime.caml_register_global
    (18, Async_kernel_Import, cst_Async_kernel_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Priority
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Priority$0 = "Async_kernel__Priority",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Priority$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/priority.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, "Low"],
    _b_ = [0, "Normal"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Priority = cst_Async_kernel_Priority$0;
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Priority);
   var Async_kernel_Priority = [0, sexp_of_t, 0, 1];
   runtime.caml_register_global
    (13, Async_kernel_Priority, cst_Async_kernel_Priority$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Types
//# unitInfo: Requires: CamlinternalMod, Core__Unique_id, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Types$0 = "Async_kernel__Types",
    cst_async_kernel$0 = "async_kernel",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    CamlinternalMod = global_data.CamlinternalMod,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    Cell =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 37, 2], [0, [0]]),
    Handler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 42, 2], [0, [0]]),
    Ivar =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 51, 2], [0, [0, [0, [0]]]]),
    Deferred =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 56, 2], [0, [0]]),
    Execution_context =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 66, 2], [0, [0]]),
    Forwarding =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 74, 2], [0, [0]]),
    Monitor =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 88, 2], [0, [0]]),
    Tail =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 93, 2], [0, [0]]),
    Stream =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 102, 2], [0, [0]]);
   caml_call3(CamlinternalMod[2], [0, [0]], Cell, Cell);
   caml_call3(CamlinternalMod[2], [0, [0]], Handler, Handler);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]]]], Ivar, Ivar);
   caml_call3(CamlinternalMod[2], [0, [0]], Deferred, Deferred);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Execution_context, Execution_context);
   caml_call3(CamlinternalMod[2], [0, [0]], Forwarding, Forwarding);
   caml_call3(CamlinternalMod[2], [0, [0]], Monitor, Monitor);
   caml_call3(CamlinternalMod[2], [0, [0]], Tail, Tail);
   caml_call3(CamlinternalMod[2], [0, [0]], Stream, Stream);
   var
    _a_ = [0, [0, [0, [0]], [0, [0]]]],
    _b_ = [0, cst_src_types_ml, 155, 2],
    _c_ = [0, [0]],
    _d_ = [0, cst_src_types_ml, 160, 2],
    _e_ = [0, [0]],
    _f_ = [0, cst_src_types_ml, 166, 2],
    _g_ = [0, [0]],
    _h_ = [0, cst_src_types_ml, 171, 2],
    _i_ = [0, [0]],
    _j_ = [0, cst_src_types_ml, 176, 2],
    _k_ = [0, [0]],
    _l_ = [0, cst_src_types_ml, 188, 2],
    _m_ = [0, [0]],
    _n_ = [0, cst_src_types_ml, 198, 2],
    _o_ = [0, [0]],
    _p_ = [0, cst_src_types_ml, 233, 2],
    _q_ = [0, [0]],
    _r_ = [0, cst_src_types_ml, 238, 2],
    _s_ = [0, [0]],
    _t_ = [0, cst_src_types_ml, 256, 2],
    _u_ = [0, [0, [0, [0]]]],
    _v_ = [0, cst_src_types_ml, 270, 2],
    _w_ = [0, [0, [0, [0]], [0, [0]]]],
    _x_ = [0, [0]],
    _y_ = [0, [0]],
    _z_ = [0, [0]],
    _A_ = [0, [0]],
    _B_ = [0, [0]],
    _C_ = [0, [0]],
    _D_ = [0, [0]],
    _E_ = [0, [0]],
    _F_ = [0, [0]],
    _G_ = [0, [0, [0, [0]]]],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Types = cst_Async_kernel_Types$0;
   function to_repr(t){return t;}
   function of_repr(t){return t;}
   var
    Bvar = [0, of_repr, to_repr],
    Event = caml_call2(CamlinternalMod[1], _b_, _a_),
    External_job = caml_call2(CamlinternalMod[1], _d_, _c_),
    Job = caml_call2(CamlinternalMod[1], _f_, _e_),
    Job_or_event = caml_call2(CamlinternalMod[1], _h_, _g_),
    Job_pool = caml_call2(CamlinternalMod[1], _j_, _i_),
    Job_queue = caml_call2(CamlinternalMod[1], _l_, _k_),
    Jobs = caml_call2(CamlinternalMod[1], _n_, _m_),
    Scheduler = caml_call2(CamlinternalMod[1], _p_, _o_),
    Cycle_hook = caml_call2(CamlinternalMod[1], _r_, _q_),
    Time_source = caml_call2(CamlinternalMod[1], _t_, _s_),
    Very_low_priority_worker = caml_call2(CamlinternalMod[1], _v_, _u_),
    Cycle_hook_handle = caml_call1(Core_Unique_id[2], [0]),
    Time_source_id = caml_call1(Core_Unique_id[2], [0]);
   caml_call3(CamlinternalMod[2], _w_, Event, Event);
   caml_call3(CamlinternalMod[2], _x_, External_job, External_job);
   caml_call3(CamlinternalMod[2], _y_, Job, Job);
   caml_call3(CamlinternalMod[2], _z_, Job_or_event, Job_or_event);
   caml_call3(CamlinternalMod[2], _A_, Job_pool, Job_pool);
   caml_call3(CamlinternalMod[2], _B_, Job_queue, Job_queue);
   caml_call3(CamlinternalMod[2], _C_, Jobs, Jobs);
   caml_call3(CamlinternalMod[2], _D_, Scheduler, Scheduler);
   caml_call3(CamlinternalMod[2], _E_, Cycle_hook, Cycle_hook);
   caml_call3(CamlinternalMod[2], _F_, Time_source, Time_source);
   caml_call3
    (CamlinternalMod[2],
     _G_,
     Very_low_priority_worker,
     Very_low_priority_worker);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Types);
   var
    Async_kernel_Types =
      [0,
       Cell,
       Handler,
       Ivar,
       Deferred,
       Execution_context,
       Forwarding,
       Monitor,
       Tail,
       Stream,
       Bvar,
       Event,
       External_job,
       Job,
       Job_or_event,
       Job_pool,
       Job_queue,
       Jobs,
       Scheduler,
       Cycle_hook,
       Cycle_hook_handle,
       Time_source_id,
       Time_source,
       Very_low_priority_worker];
   runtime.caml_register_global
    (73, Async_kernel_Types, cst_Async_kernel_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor0
//# unitInfo: Requires: Async_kernel__Debug, Base__Field, Core, Core__Bag, Core__Info, Core__List, Core__Sexp, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monitor0$0 = "Async_kernel__Monitor0",
    cst_async_kernel$0 = "async_kernel",
    cst_forwarding$0 = "forwarding",
    cst_handlers_for_all_errors$0 = "handlers_for_all_errors",
    cst_has_seen_error$0 = "has_seen_error",
    cst_here$0 = "here",
    cst_id$1 = "id",
    cst_name$0 = "name",
    cst_next_error$0 = "next_error",
    cst_tails_for_all_errors$0 = "tails_for_all_errors";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_name$0,
       [0,
        cst_here$0,
        [0,
         cst_id$1,
         [0,
          cst_next_error$0,
          [0,
           cst_handlers_for_all_errors$0,
           [0,
            cst_tails_for_all_errors$0,
            [0, cst_has_seen_error$0, [0, cst_forwarding$0, 0]]]]]]]],
    Core = global_data.Core,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Core_Info = global_data.Core__Info,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/monitor0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    debug = Async_kernel_Debug[6],
    cst_id$0 = cst_id$1,
    cst_created_monitor = "created monitor",
    cst_forwarding = cst_forwarding$0,
    cst_has_seen_error = cst_has_seen_error$0,
    cst_tails_for_all_errors = cst_tails_for_all_errors$0,
    cst_handlers_for_all_errors = cst_handlers_for_all_errors$0,
    cst_next_error = cst_next_error$0,
    cst_id = cst_id$1,
    cst_here = cst_here$0,
    cst_name = cst_name$0,
    _q_ = [0, "main"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor0 = cst_Async_kernel_Monitor0$0;
   function forwarding(r){return r[8];}
   function set_forwarding(r, v){r[8] = v; return 0;}
   function has_seen_error(r){return r[7];}
   function set_has_seen_error(r, v){r[7] = v; return 0;}
   function tails_for_all_errors(r){return r[6];}
   function set_tails_for_all_errors(r, v){r[6] = v; return 0;}
   function handlers_for_all_errors(r){return r[5];}
   function set_handlers_for_all_errors(r, v){r[5] = v; return 0;}
   function next_error(r){return r[4];}
   function set_next_error(r, v){r[4] = v; return 0;}
   function id(r){return r[3];}
   function here(r){return r[2];}
   function name(r){return r[1];}
   function _a_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _b_ = [0, set_forwarding],
    forwarding$0 =
      [0, function(param){return 0;}, cst_forwarding, _b_, forwarding, _a_];
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _d_ = [0, set_has_seen_error],
    has_seen_error$0 =
      [0,
       function(param){return 0;},
       cst_has_seen_error,
       _d_,
       has_seen_error,
       _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _f_ = [0, set_tails_for_all_errors],
    tails_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_tails_for_all_errors,
       _f_,
       tails_for_all_errors,
       _e_];
   function _g_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _h_ = [0, set_handlers_for_all_errors],
    handlers_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_handlers_for_all_errors,
       _h_,
       handlers_for_all_errors,
       _g_];
   function _i_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _j_ = [0, set_next_error],
    next_error$0 =
      [0, function(param){return 0;}, cst_next_error, _j_, next_error, _i_];
   function _k_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var _l_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _l_, id, _k_];
   function _m_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _n_ = 0,
    here$0 = [0, function(param){return 0;}, cst_here, _n_, here, _m_];
   function _o_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _p_ = 0,
    name$0 = [0, function(param){return 0;}, cst_name, _p_, name, _o_];
   function make_creator
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun,
    compile_acc){
    var
     match = caml_call2(name_fun, name$0, compile_acc),
     compile_acc$0 = match[2],
     name_gen = match[1],
     match$0 = caml_call2(here_fun, here$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     here_gen = match$0[1],
     match$1 = caml_call2(id_fun, id$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     id_gen = match$1[1],
     match$2 = caml_call2(next_error_fun, next_error$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     next_error_gen = match$2[1],
     match$3 =
       caml_call2
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     handlers_for_all_errors_gen = match$3[1],
     match$4 =
       caml_call2
        (tails_for_all_errors_fun, tails_for_all_errors$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     tails_for_all_errors_gen = match$4[1],
     match$5 = caml_call2(has_seen_error_fun, has_seen_error$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     has_seen_error_gen = match$5[1],
     match$6 = caml_call2(forwarding_fun, forwarding$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     forwarding_gen = match$6[1];
    return [0,
            function(acc){
             var
              name = caml_call1(name_gen, acc),
              here = caml_call1(here_gen, acc),
              id = caml_call1(id_gen, acc),
              next_error = caml_call1(next_error_gen, acc),
              handlers_for_all_errors =
                caml_call1(handlers_for_all_errors_gen, acc),
              tails_for_all_errors = caml_call1(tails_for_all_errors_gen, acc),
              has_seen_error = caml_call1(has_seen_error_gen, acc),
              forwarding = caml_call1(forwarding_gen, acc);
             return [0,
                     name,
                     here,
                     id,
                     next_error,
                     handlers_for_all_errors,
                     tails_for_all_errors,
                     has_seen_error,
                     forwarding];
            },
            compile_acc$7];
   }
   function create
   (name,
    here,
    id,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    return [0,
            name,
            here,
            id,
            next_error,
            handlers_for_all_errors,
            tails_for_all_errors,
            has_seen_error,
            forwarding];
   }
   function map
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _aE_ = caml_call1(forwarding_fun, forwarding$0),
     _aF_ = caml_call1(has_seen_error_fun, has_seen_error$0),
     _aG_ = caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _aH_ = caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _aI_ = caml_call1(next_error_fun, next_error$0),
     _aJ_ = caml_call1(id_fun, id$0),
     _aK_ = caml_call1(here_fun, here$0);
    return [0,
            caml_call1(name_fun, name$0),
            _aK_,
            _aJ_,
            _aI_,
            _aH_,
            _aG_,
            _aF_,
            _aE_];
   }
   function iter
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call1(name_fun, name$0);
    caml_call1(here_fun, here$0);
    caml_call1(id_fun, id$0);
    caml_call1(next_error_fun, next_error$0);
    caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0);
    caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0);
    caml_call1(has_seen_error_fun, has_seen_error$0);
    return caml_call1(forwarding_fun, forwarding$0);
   }
   function fold
   (init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    return caml_call2
            (forwarding_fun,
             caml_call2
              (has_seen_error_fun,
               caml_call2
                (tails_for_all_errors_fun,
                 caml_call2
                  (handlers_for_all_errors_fun,
                   caml_call2
                    (next_error_fun,
                     caml_call2
                      (id_fun,
                       caml_call2
                        (here_fun, caml_call2(name_fun, init, name$0), here$0),
                       id$0),
                     next_error$0),
                   handlers_for_all_errors$0),
                 tails_for_all_errors$0),
               has_seen_error$0),
             forwarding$0);
   }
   function map_poly(record){
    var
     _ax_ = [0, caml_call1(record[1], forwarding$0), 0],
     _ay_ = [0, caml_call1(record[1], has_seen_error$0), _ax_],
     _az_ = [0, caml_call1(record[1], tails_for_all_errors$0), _ay_],
     _aA_ = [0, caml_call1(record[1], handlers_for_all_errors$0), _az_],
     _aB_ = [0, caml_call1(record[1], next_error$0), _aA_],
     _aC_ = [0, caml_call1(record[1], id$0), _aB_],
     _aD_ = [0, caml_call1(record[1], here$0), _aC_];
    return [0, caml_call1(record[1], name$0), _aD_];
   }
   function for_all
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _aq_ = caml_call1(name_fun, name$0),
     _ar_ = _aq_ ? caml_call1(here_fun, here$0) : _aq_,
     _as_ = _ar_ ? caml_call1(id_fun, id$0) : _ar_,
     _at_ = _as_ ? caml_call1(next_error_fun, next_error$0) : _as_,
     _au_ =
       _at_
        ? caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0)
        : _at_,
     _av_ =
       _au_
        ? caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0)
        : _au_,
     _aw_ = _av_ ? caml_call1(has_seen_error_fun, has_seen_error$0) : _av_;
    return _aw_ ? caml_call1(forwarding_fun, forwarding$0) : _aw_;
   }
   function exists
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _ap_ = caml_call1(name_fun, name$0),
     _aj_ = _ap_ || caml_call1(here_fun, here$0),
     _ak_ = _aj_ || caml_call1(id_fun, id$0),
     _al_ = _ak_ || caml_call1(next_error_fun, next_error$0),
     _am_ =
       _al_
       || caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _an_ =
       _am_ || caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _ao_ = _an_ || caml_call1(has_seen_error_fun, has_seen_error$0);
    return _ao_ ? _ao_ : caml_call1(forwarding_fun, forwarding$0);
   }
   function to_list
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _ac_ = [0, caml_call1(forwarding_fun, forwarding$0), 0],
     _ad_ = [0, caml_call1(has_seen_error_fun, has_seen_error$0), _ac_],
     _ae_ =
       [0, caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0), _ad_],
     _af_ =
       [0,
        caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
        _ae_],
     _ag_ = [0, caml_call1(next_error_fun, next_error$0), _af_],
     _ah_ = [0, caml_call1(id_fun, id$0), _ag_],
     _ai_ = [0, caml_call1(here_fun, here$0), _ah_];
    return [0, caml_call1(name_fun, name$0), _ai_];
   }
   function iter$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call3(name_fun, name$0, record, record[1]);
    caml_call3(here_fun, here$0, record, record[2]);
    caml_call3(id_fun, id$0, record, record[3]);
    caml_call3(next_error_fun, next_error$0, record, record[4]);
    caml_call3
     (handlers_for_all_errors_fun,
      handlers_for_all_errors$0,
      record,
      record[5]);
    caml_call3
     (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]);
    caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _X_ = record[8],
     _Y_ = record[7],
     _Z_ = record[6],
     ___ = record[5],
     _$_ = record[4],
     _aa_ = record[3],
     _ab_ = record[2];
    return caml_call4
            (forwarding_fun,
             caml_call4
              (has_seen_error_fun,
               caml_call4
                (tails_for_all_errors_fun,
                 caml_call4
                  (handlers_for_all_errors_fun,
                   caml_call4
                    (next_error_fun,
                     caml_call4
                      (id_fun,
                       caml_call4
                        (here_fun,
                         caml_call4(name_fun, init, name$0, record, record[1]),
                         here$0,
                         record,
                         _ab_),
                       id$0,
                       record,
                       _aa_),
                     next_error$0,
                     record,
                     _$_),
                   handlers_for_all_errors$0,
                   record,
                   ___),
                 tails_for_all_errors$0,
                 record,
                 _Z_),
               has_seen_error$0,
               record,
               _Y_),
             forwarding$0,
             record,
             _X_);
   }
   function for_all$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _Q_ = caml_call3(name_fun, name$0, record, record[1]),
     _R_ = _Q_ ? caml_call3(here_fun, here$0, record, record[2]) : _Q_,
     _S_ = _R_ ? caml_call3(id_fun, id$0, record, record[3]) : _R_,
     _T_ =
       _S_ ? caml_call3(next_error_fun, next_error$0, record, record[4]) : _S_,
     _U_ =
       _T_
        ? caml_call3
          (handlers_for_all_errors_fun,
           handlers_for_all_errors$0,
           record,
           record[5])
        : _T_,
     _V_ =
       _U_
        ? caml_call3
          (tails_for_all_errors_fun,
           tails_for_all_errors$0,
           record,
           record[6])
        : _U_,
     _W_ =
       _V_
        ? caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7])
        : _V_;
    return _W_
            ? caml_call3(forwarding_fun, forwarding$0, record, record[8])
            : _W_;
   }
   function exists$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _P_ = caml_call3(name_fun, name$0, record, record[1]),
     _J_ = _P_ || caml_call3(here_fun, here$0, record, record[2]),
     _K_ = _J_ || caml_call3(id_fun, id$0, record, record[3]),
     _L_ = _K_ || caml_call3(next_error_fun, next_error$0, record, record[4]),
     _M_ =
       _L_
       ||
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
     _N_ =
       _M_
       ||
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _O_ =
       _N_
       || caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return _O_
            ? _O_
            : caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function to_list$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _C_ = [0, caml_call3(forwarding_fun, forwarding$0, record, record[8]), 0],
     _D_ =
       [0,
        caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
        _C_],
     _E_ =
       [0,
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
        _D_],
     _F_ =
       [0,
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
        _E_],
     _G_ =
       [0, caml_call3(next_error_fun, next_error$0, record, record[4]), _F_],
     _H_ = [0, caml_call3(id_fun, id$0, record, record[3]), _G_],
     _I_ = [0, caml_call3(here_fun, here$0, record, record[2]), _H_];
    return [0, caml_call3(name_fun, name$0, record, record[1]), _I_];
   }
   function map$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _v_ = caml_call3(forwarding_fun, forwarding$0, record, record[8]),
     _w_ = caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
     _x_ =
       caml_call3
        (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _y_ =
       caml_call3
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         record,
         record[5]),
     _z_ = caml_call3(next_error_fun, next_error$0, record, record[4]),
     _A_ = caml_call3(id_fun, id$0, record, record[3]),
     _B_ = caml_call3(here_fun, here$0, record, record[2]);
    return [0,
            caml_call3(name_fun, name$0, record, record[1]),
            _B_,
            _A_,
            _z_,
            _y_,
            _x_,
            _w_,
            _v_];
   }
   function set_all_mutable_fields
   (record,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[4] = next_error;
    record$0[5] = handlers_for_all_errors;
    record$0[6] = tails_for_all_errors;
    record$0[7] = has_seen_error;
    record$0[8] = forwarding;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       forwarding$0,
       has_seen_error$0,
       tails_for_all_errors$0,
       handlers_for_all_errors$0,
       next_error$0,
       id$0,
       here$0,
       name$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function description(t){
    var match = t[2];
    if(! match) return caml_call1(Core_Info[6], t[1]);
    var
     here = match[1],
     _u_ = [0, caml_call1(Core_Source_code_position[1], here), 0];
    return [1, [0, caml_call1(Core_Info[6], t[1]), _u_]];
   }
   function descriptions(t$1){
    var t = t$1, ac = 0;
    for(;;){
     var ac$0 = [0, description(t), ac], match = t[8];
     if(typeof match === "number") return caml_call1(Core_List[34], ac$0);
     var t$0 = match[1], t = t$0, ac = ac$0;
    }
   }
   function sexp_of_t(t){
    var x_001 = descriptions(t);
    return caml_call2(Core[421], Core_Sexp[90], x_001);
   }
   var r = [0, 0];
   function next_id(param){r[1]++; return r[1];}
   function create_with_parent(here, info, name, parent){
    var id = next_id(0);
    if(info){
     var i = info[1];
     if(name)
      var s = name[1], _r_ = caml_call2(Core_Info[20], i, s);
     else
      var _r_ = i;
     var name$0 = _r_;
    }
    else if(name)
     var s$0 = name[1], name$0 = caml_call1(Core_Info[12], s$0);
    else
     var
      _t_ =
        function(x_002){
         return caml_call2(Sexp_hidden_in_test[10], Core[356], x_002);
        },
      name$0 = caml_call5(Core_Info[17], 0, 0, cst_id$0, id, _t_);
    if(parent)
     var parent$0 = parent[1], _s_ = [0, parent$0];
    else
     var _s_ = 1;
    var
     t = [0, name$0, here, id, [0, 0], caml_call1(Core_Bag[22], 0), 0, 0, _s_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_created_monitor, t, sexp_of_t);
    return t;
   }
   var main = create_with_parent(0, 0, _q_, 0);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor0);
   var
    Async_kernel_Monitor0 =
      [0,
       debug,
       forwarding,
       set_forwarding,
       has_seen_error,
       set_has_seen_error,
       tails_for_all_errors,
       set_tails_for_all_errors,
       handlers_for_all_errors,
       set_handlers_for_all_errors,
       next_error,
       set_next_error,
       id,
       here,
       name,
       Fields,
       description,
       descriptions,
       sexp_of_t,
       next_id,
       create_with_parent,
       main];
   runtime.caml_register_global
    (32, Async_kernel_Monitor0, cst_Async_kernel_Monitor0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Execution_context
//# unitInfo: Requires: Async_kernel__Monitor0, Async_kernel__Priority, Base__Backtrace, Base__Field, Core, Core__Option, Core__Univ_map, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Execution_con$0 = "Async_kernel__Execution_context",
    cst_async_kernel$0 = "async_kernel",
    cst_backtrace_history$0 = "backtrace_history",
    cst_local_storage$0 = "local_storage",
    cst_monitor$0 = "monitor",
    cst_priority$0 = "priority";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_monitor$0,
       [0,
        cst_priority$0,
        [0, cst_local_storage$0, [0, cst_backtrace_history$0, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Univ_map = global_data.Core__Univ_map,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Execution_con$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/execution_context.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _i_ = [0, cst_backtrace_history$0],
    _j_ = [0, cst_local_storage$0],
    _k_ = [0, cst_priority$0],
    _l_ = [0, cst_monitor$0],
    cst_backtrace_history = cst_backtrace_history$0,
    cst_local_storage = cst_local_storage$0,
    cst_priority = cst_priority$0,
    cst_monitor = cst_monitor$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Execution_con = cst_Async_kernel_Execution_con$0;
   function backtrace_history(r){return r[4];}
   function local_storage(r){return r[3];}
   function priority(r){return r[2];}
   function monitor(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _b_ = 0,
    backtrace_history$0 =
      [0,
       function(param){return 0;},
       cst_backtrace_history,
       _b_,
       backtrace_history,
       _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _d_ = 0,
    local_storage$0 =
      [0,
       function(param){return 0;},
       cst_local_storage,
       _d_,
       local_storage,
       _c_];
   function _e_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _f_ = 0,
    priority$0 =
      [0, function(param){return 0;}, cst_priority, _f_, priority, _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _h_ = 0,
    monitor$0 =
      [0, function(param){return 0;}, cst_monitor, _h_, monitor, _g_];
   function make_creator
   (monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun,
    compile_acc){
    var
     match = caml_call2(monitor_fun, monitor$0, compile_acc),
     compile_acc$0 = match[2],
     monitor_gen = match[1],
     match$0 = caml_call2(priority_fun, priority$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     priority_gen = match$0[1],
     match$1 = caml_call2(local_storage_fun, local_storage$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     local_storage_gen = match$1[1],
     match$2 =
       caml_call2(backtrace_history_fun, backtrace_history$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     backtrace_history_gen = match$2[1];
    return [0,
            function(acc){
             var
              monitor = caml_call1(monitor_gen, acc),
              priority = caml_call1(priority_gen, acc),
              local_storage = caml_call1(local_storage_gen, acc),
              backtrace_history = caml_call1(backtrace_history_gen, acc);
             return [0, monitor, priority, local_storage, backtrace_history];
            },
            compile_acc$3];
   }
   function create(monitor, priority, local_storage, backtrace_history){return [0, monitor, priority, local_storage, backtrace_history];
   }
   function map
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _U_ = caml_call1(backtrace_history_fun, backtrace_history$0),
     _V_ = caml_call1(local_storage_fun, local_storage$0),
     _W_ = caml_call1(priority_fun, priority$0);
    return [0, caml_call1(monitor_fun, monitor$0), _W_, _V_, _U_];
   }
   function iter
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    caml_call1(monitor_fun, monitor$0);
    caml_call1(priority_fun, priority$0);
    caml_call1(local_storage_fun, local_storage$0);
    return caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function fold
   (init, monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    return caml_call2
            (backtrace_history_fun,
             caml_call2
              (local_storage_fun,
               caml_call2
                (priority_fun,
                 caml_call2(monitor_fun, init, monitor$0),
                 priority$0),
               local_storage$0),
             backtrace_history$0);
   }
   function map_poly(record){
    var
     _R_ = [0, caml_call1(record[1], backtrace_history$0), 0],
     _S_ = [0, caml_call1(record[1], local_storage$0), _R_],
     _T_ = [0, caml_call1(record[1], priority$0), _S_];
    return [0, caml_call1(record[1], monitor$0), _T_];
   }
   function for_all
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _O_ = caml_call1(monitor_fun, monitor$0),
     _P_ = _O_ ? caml_call1(priority_fun, priority$0) : _O_,
     _Q_ = _P_ ? caml_call1(local_storage_fun, local_storage$0) : _P_;
    return _Q_ ? caml_call1(backtrace_history_fun, backtrace_history$0) : _Q_;
   }
   function exists
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _N_ = caml_call1(monitor_fun, monitor$0),
     _L_ = _N_ || caml_call1(priority_fun, priority$0),
     _M_ = _L_ || caml_call1(local_storage_fun, local_storage$0);
    return _M_ ? _M_ : caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function to_list
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _I_ = [0, caml_call1(backtrace_history_fun, backtrace_history$0), 0],
     _J_ = [0, caml_call1(local_storage_fun, local_storage$0), _I_],
     _K_ = [0, caml_call1(priority_fun, priority$0), _J_];
    return [0, caml_call1(monitor_fun, monitor$0), _K_];
   }
   function iter$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    caml_call3(monitor_fun, monitor$0, record, record[1]);
    caml_call3(priority_fun, priority$0, record, record[2]);
    caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return caml_call3
            (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function fold$0
   (record,
    init,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var _F_ = record[4], _G_ = record[3], _H_ = record[2];
    return caml_call4
            (backtrace_history_fun,
             caml_call4
              (local_storage_fun,
               caml_call4
                (priority_fun,
                 caml_call4(monitor_fun, init, monitor$0, record, record[1]),
                 priority$0,
                 record,
                 _H_),
               local_storage$0,
               record,
               _G_),
             backtrace_history$0,
             record,
             _F_);
   }
   function for_all$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _C_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _D_ = _C_ ? caml_call3(priority_fun, priority$0, record, record[2]) : _C_,
     _E_ =
       _D_
        ? caml_call3(local_storage_fun, local_storage$0, record, record[3])
        : _D_;
    return _E_
            ? caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4])
            : _E_;
   }
   function exists$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _B_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _z_ = _B_ || caml_call3(priority_fun, priority$0, record, record[2]),
     _A_ =
       _z_
       || caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return _A_
            ? _A_
            : caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function to_list$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _w_ =
       [0,
        caml_call3
         (backtrace_history_fun, backtrace_history$0, record, record[4]),
        0],
     _x_ =
       [0,
        caml_call3(local_storage_fun, local_storage$0, record, record[3]),
        _w_],
     _y_ = [0, caml_call3(priority_fun, priority$0, record, record[2]), _x_];
    return [0, caml_call3(monitor_fun, monitor$0, record, record[1]), _y_];
   }
   function map$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _t_ =
       caml_call3
        (backtrace_history_fun, backtrace_history$0, record, record[4]),
     _u_ = caml_call3(local_storage_fun, local_storage$0, record, record[3]),
     _v_ = caml_call3(priority_fun, priority$0, record, record[2]);
    return [0,
            caml_call3(monitor_fun, monitor$0, record, record[1]),
            _v_,
            _u_,
            _t_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields];
   function sexp_of_t(param){
    var
     backtrace_history_008 = param[4],
     local_storage_006 = param[3],
     priority_004 = param[2],
     monitor_002 = param[1],
     arg_009 = caml_call2(Core[421], Base_Backtrace[1], backtrace_history_008),
     bnds_001 = [0, [1, [0, _i_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Core_Univ_map[2], local_storage_006),
     bnds_001$0 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Async_kernel_Priority[1], priority_004),
     bnds_001$1 = [0, [1, [0, _k_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 = caml_call1(Async_kernel_Monitor0[18], monitor_002),
     bnds_001$2 = [0, [1, [0, _l_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   var
    main =
      [0,
       Async_kernel_Monitor0[21],
       Async_kernel_Priority[2],
       Core_Univ_map[4],
       0];
   function create_like(monitor, priority, local_storage, t){
    var
     monitor$0 = caml_call2(Core_Option[34], monitor, t[1]),
     _r_ = t[4],
     _s_ = caml_call2(Core_Option[34], local_storage, t[3]);
    return [0,
            monitor$0,
            caml_call2(Core_Option[34], priority, t[2]),
            _s_,
            _r_];
   }
   function find_local(t, key){
    return caml_call2(Core_Univ_map[10], t[3], key);
   }
   function with_local(t, key, data){
    var _o_ = t[4];
    function _p_(param){return data;}
    var _q_ = caml_call3(Core_Univ_map[14], t[3], key, _p_);
    return [0, t[1], t[2], _q_, _o_];
   }
   function record_backtrace(t){
    var _m_ = t[4], _n_ = [0, caml_call2(Base_Backtrace[2], 0, 0), _m_];
    return [0, t[1], t[2], t[3], _n_];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Execution_con);
   var
    Async_kernel_Execution_context =
      [0,
       backtrace_history,
       local_storage,
       priority,
       monitor,
       [0,
        names,
        backtrace_history$0,
        local_storage$0,
        priority$0,
        monitor$0,
        fold,
        make_creator,
        create,
        map,
        iter,
        for_all,
        exists,
        to_list,
        map_poly,
        Direct],
       sexp_of_t,
       invariant,
       main,
       create_like,
       find_local,
       with_local,
       record_backtrace];
   runtime.caml_register_global
    (27, Async_kernel_Execution_context, cst_Async_kernel_Execution_con$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__External_job
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_External_job$0 = "Async_kernel__External_job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_External_job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/external_job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, "<job>"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_External_job = cst_Async_kernel_External_job$0;
   function sexp_of_t(param){return _a_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_External_job);
   var Async_kernel_External_job = [0, sexp_of_t];
   runtime.caml_register_global
    (12, Async_kernel_External_job, cst_Async_kernel_External_job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_pool
//# unitInfo: Requires: Async_kernel__Execution_context, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_pool$0 = "Async_kernel__Job_pool",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_pool$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/job_pool.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    dummy_e = Async_kernel_Execution_context[8],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_pool = cst_Async_kernel_Job_pool$0;
   function dummy_f(_g_){return 0;}
   var dummy_a = 0;
   function sexp_of_slots(x_001){
    var _c_ = Sexplib0_Sexp_conv[23];
    function _d_(param){
     function _e_(_f_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _e_);
    }
    return caml_call4
            (Tuple_pool[1][5],
             Async_kernel_Execution_context[6],
             _d_,
             _c_,
             x_001);
   }
   function sexp_of_t(x_002){
    return caml_call2(Tuple_pool[4], sexp_of_slots, x_002);
   }
   function invariant(t){
    function _a_(_b_){return 0;}
    return caml_call2(Tuple_pool[5], _a_, t);
   }
   function create(param){
    return caml_call3
            (Tuple_pool[9],
             Tuple_pool[1][19],
             1,
             [0, dummy_e, dummy_f, dummy_a]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_pool);
   var
    Async_kernel_Job_pool = [0, sexp_of_slots, sexp_of_t, invariant, create];
   runtime.caml_register_global
    (14, Async_kernel_Job_pool, cst_Async_kernel_Job_pool$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job
//# unitInfo: Requires: Async_kernel__Job_pool, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job$0 = "Async_kernel__Job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job = cst_Async_kernel_Job$0;
   function sexp_of_t(x_001){
    return caml_call2(Tuple_pool[3][1], Async_kernel_Job_pool[1], x_001);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job);
   var Async_kernel_Job = [0, sexp_of_t];
   runtime.caml_register_global(13, Async_kernel_Job, cst_Async_kernel_Job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event$0 = "Async_kernel__Job_or_event",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_or_event = cst_Async_kernel_Job_or_event$0;
   function of_event(event){return event;}
   function of_job(job){return job;}
   function is_event(t){return caml_call1(Stdlib_Obj[1], t);}
   function is_job(t){return typeof t === "number" ? 1 : 0;}
   function kind(t){return is_event(t) ? 0 : 1;}
   function project(param, job_or_event){return job_or_event;}
   var Match = [0, kind, project];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event);
   var
    Async_kernel_Job_or_event = [0, of_event, of_job, is_event, is_job, Match];
   runtime.caml_register_global
    (13, Async_kernel_Job_or_event, cst_Async_kernel_Job_or_event$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event_ = "Async_kernel__Job_or_event_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event_);
   var Async_kernel_Job_or_event_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Job_or_event_intf, cst_Async_kernel_Job_or_event_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler0
//# unitInfo: Requires: Async_kernel__Types, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler0$0 = "Async_kernel__Scheduler0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/scheduler0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler0 = cst_Async_kernel_Scheduler0$0;
   function events(t){return t[19][4];}
   function set_execution_context(t, execution_context){
    var
     _a_ = 1 - caml_call2(Core[246], t[7], execution_context),
     _b_ = _a_ ? (t[7] = execution_context, 0) : _a_;
    return _b_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler0);
   var Async_kernel_Scheduler0 = [0, events, set_execution_context];
   runtime.caml_register_global
    (12, Async_kernel_Scheduler0, cst_Async_kernel_Scheduler0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_queue
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Scheduler0, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Int, Core__Uniform_array, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_queue$0 = "Async_kernel__Job_queue",
    cst_async_kernel$0 = "async_kernel",
    cst_front$0 = "front",
    cst_jobs$0 = "jobs",
    cst_jobs_left_this_cycle$0 = "jobs_left_this_cycle",
    cst_length$0 = "length",
    cst_mask$0 = "mask",
    cst_num_jobs_run$0 = "num_jobs_run",
    cst_src_job_queue_ml = "src/job_queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Uniform_array = global_data.Core__Uniform_array,
    Base_Backtrace = global_data.Base__Backtrace,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_queue$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_job_queue_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    dummy_e = Async_kernel_Execution_context[8],
    _D_ = [0, 0],
    _B_ = [0, "t"],
    _C_ = [0, "n"],
    cst_Jobs_set_jobs_left_this_cy =
      "Jobs.set_jobs_left_this_cycle got negative number",
    _z_ = [0, cst_src_job_queue_ml, 39, 48],
    _y_ = [0, cst_src_job_queue_ml, 41, 44],
    _x_ = [0, cst_src_job_queue_ml, 51, 11],
    _w_ = [0, cst_src_job_queue_ml, 52, 11],
    _v_ = [0, cst_src_job_queue_ml, 55, 11],
    _u_ = [0, cst_src_job_queue_ml, 56, 11],
    _t_ = [0, cst_src_job_queue_ml, 59, 11],
    _s_ = [0, cst_src_job_queue_ml, 60, 11],
    _A_ = [0, cst_src_job_queue_ml, 36, 1334, 1356],
    _m_ = [0, cst_length$0],
    _n_ = [0, cst_front$0],
    _o_ = [0, cst_mask$0],
    _p_ = [0, cst_jobs$0],
    _q_ = [0, cst_jobs_left_this_cycle$0],
    _r_ = [0, cst_num_jobs_run$0],
    cst_length = cst_length$0,
    cst_front = cst_front$0,
    cst_mask = cst_mask$0,
    cst_jobs = cst_jobs$0,
    cst_jobs_left_this_cycle = cst_jobs_left_this_cycle$0,
    cst_num_jobs_run = cst_num_jobs_run$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_queue = cst_Async_kernel_Job_queue$0;
   function dummy_f(_T_){return 0;}
   var dummy_a = 0;
   function length(r){return r[6];}
   function set_length(r, v){r[6] = v; return 0;}
   function front(r){return r[5];}
   function set_front(r, v){r[5] = v; return 0;}
   function mask(r){return r[4];}
   function set_mask(r, v){r[4] = v; return 0;}
   function jobs(r){return r[3];}
   function set_jobs(r, v){r[3] = v; return 0;}
   function jobs_left_this_cycle(r){return r[2];}
   function set_jobs_left_this_cycle(r, v){r[2] = v; return 0;}
   function num_jobs_run(r){return r[1];}
   function set_num_jobs_run(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v];}
   var
    _b_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _b_, length, _a_];
   function _c_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}
   var
    _d_ = [0, set_front],
    front$0 = [0, function(param){return 0;}, cst_front, _d_, front, _c_];
   function _e_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _f_ = [0, set_mask],
    mask$0 = [0, function(param){return 0;}, cst_mask, _f_, mask, _e_];
   function _g_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _h_ = [0, set_jobs],
    jobs$0 = [0, function(param){return 0;}, cst_jobs, _h_, jobs, _g_];
   function _i_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6]];}
   var
    _j_ = [0, set_jobs_left_this_cycle],
    jobs_left_this_cycle$0 =
      [0,
       function(param){return 0;},
       cst_jobs_left_this_cycle,
       _j_,
       jobs_left_this_cycle,
       _i_];
   function _k_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _l_ = [0, set_num_jobs_run],
    num_jobs_run$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_run,
       _l_,
       num_jobs_run,
       _k_];
   function sexp_of_t(param){
    var
     num_jobs_run_002 = param[1],
     jobs_left_this_cycle_004 = param[2],
     jobs_006 = param[3],
     mask_008 = param[4],
     front_010 = param[5],
     length_012 = param[6],
     arg_013 = caml_call1(Core[356], length_012),
     bnds_001 = [0, [1, [0, _m_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Core[356], front_010),
     bnds_001$0 = [0, [1, [0, _n_, [0, arg_011, 0]]], bnds_001],
     arg_009 = caml_call1(Core[356], mask_008),
     bnds_001$1 = [0, [1, [0, _o_, [0, arg_009, 0]]], bnds_001$0],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], jobs_006),
     bnds_001$2 = [0, [1, [0, _p_, [0, arg_007, 0]]], bnds_001$1],
     arg_005 = caml_call1(Core[356], jobs_left_this_cycle_004),
     bnds_001$3 = [0, [1, [0, _q_, [0, arg_005, 0]]], bnds_001$2],
     arg_003 = caml_call1(Core[356], num_jobs_run_002),
     bnds_001$4 = [0, [1, [0, _r_, [0, arg_003, 0]]], bnds_001$3];
    return [1, bnds_001$4];
   }
   function offset(t, i){return ((t[5] + i | 0) & t[4]) * 3 | 0;}
   function capacity(t){return t[4] + 1 | 0;}
   function invariant(t){
    function _K_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      length_fun =
        check
         (function(length){
           if(! caml_call2(Async_kernel_Import[1], length, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
           var _S_ = capacity(t);
           if(caml_call2(Async_kernel_Import[2], length, _S_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
          }),
      front_fun =
        check
         (function(front){
           if(! caml_call2(Async_kernel_Import[1], front, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
           var _R_ = capacity(t);
           if(caml_call2(Async_kernel_Import[5], front, _R_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
          }),
      mask_fun =
        check
         (function(mask){
           var capacity = mask + 1 | 0;
           if(! caml_call1(Core_Int[48], capacity))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
           var _Q_ = caml_call1(Core_Uniform_array[18], t[3]);
           if(caml_call2(Async_kernel_Import[3], capacity * 3 | 0, _Q_))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          }),
      jobs_fun =
        check
         (function(jobs){
           var _M_ = t[6] - 1 | 0, _L_ = 0;
           if(_M_ >= 0){
            var i = _L_;
            for(;;){
             var
              _N_ = offset(t, i),
              _O_ = caml_call2(Core_Uniform_array[19], jobs, _N_);
             caml_call1(Async_kernel_Execution_context[7], _O_);
             var _P_ = i + 1 | 0;
             if(_M_ === i) break;
             var i = _P_;
            }
           }
           return 0;
          }),
      jobs_left_this_cycle_fun =
        check
         (function(jobs_left_this_cycle){
           if(caml_call2(Async_kernel_Import[1], jobs_left_this_cycle, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
          }),
      num_jobs_run_fun =
        check
         (function(num_jobs_run){
           if(caml_call2(Async_kernel_Import[1], num_jobs_run, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
          });
     caml_call1(num_jobs_run_fun, num_jobs_run$0);
     caml_call1(jobs_left_this_cycle_fun, jobs_left_this_cycle$0);
     caml_call1(jobs_fun, jobs$0);
     caml_call1(mask_fun, mask$0);
     caml_call1(front_fun, front$0);
     return caml_call1(length_fun, length$0);
    }
    return caml_call4(Base_Invariant[1], _A_, t, sexp_of_t, _K_);
   }
   function create_array(capacity){
    return caml_call1(Core_Uniform_array[43], capacity * 3 | 0);
   }
   function create(param){return [0, 0, 0, create_array(1), 0, 0, 0];}
   function clear(t){t[5] = 0; t[6] = 0; t[2] = 0; return 0;}
   function set(t, i, execution_context, f, a){
    var offset$0 = offset(t, i);
    caml_call3(Core_Uniform_array[22], t[3], offset$0, execution_context);
    caml_call3(Core_Uniform_array[22], t[3], offset$0 + 1 | 0, f);
    return caml_call3(Core_Uniform_array[22], t[3], offset$0 + 2 | 0, a);
   }
   function enqueue(t, execution_context, f, a){
    var _J_ = capacity(t);
    if(caml_call2(Async_kernel_Import[3], t[6], _J_)){
     var
      old_capacity = capacity(t),
      new_capacity = old_capacity * 2 | 0,
      old_jobs = t[3],
      old_front = t[5],
      len1 =
        caml_call2(Core_Int[92], t[6], old_capacity - old_front | 0) * 3 | 0,
      len2 = (t[6] * 3 | 0) - len1 | 0,
      new_jobs = create_array(new_capacity);
     caml_call5
      (Core_Uniform_array[36], old_jobs, old_front * 3 | 0, new_jobs, 0, len1);
     caml_call5(Core_Uniform_array[36], old_jobs, 0, new_jobs, len1, len2);
     t[4] = new_capacity - 1 | 0;
     t[3] = new_jobs;
     t[5] = 0;
    }
    set(t, t[6], execution_context, f, a);
    t[6] = t[6] + 1 | 0;
    return 0;
   }
   function set_jobs_left_this_cycle$0(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _G_ = [0, [1, [0, _B_, [0, sexp_of_t(t), 0]]], 0],
      _H_ = [0, [1, [0, _C_, [0, caml_call1(Core[356], n), 0]]], _G_],
      _I_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Jobs_set_jobs_left_this_cy),
          _H_]];
     caml_call1(Core[253], _I_);
    }
    t[2] = n;
    return 0;
   }
   function can_run_a_job(t){
    var _F_ = caml_call2(Async_kernel_Import[4], t[6], 0);
    return _F_ ? caml_call2(Async_kernel_Import[4], t[2], 0) : _F_;
   }
   function run_job(t, scheduler, execution_context, f, a){
    t[1] = t[1] + 1 | 0;
    caml_call2(Async_kernel_Scheduler0[2], scheduler, execution_context);
    return caml_call1(f, a);
   }
   function run_external_jobs(t, scheduler){
    var external_jobs = scheduler[20];
    for(;;){
     var _E_ = caml_call1(Thread_safe_queue[4], external_jobs);
     if(! caml_call2(Async_kernel_Import[4], _E_, 0)) return;
     var
      match = caml_call1(Thread_safe_queue[6], external_jobs),
      a = match[3],
      f = match[2],
      execution_context = match[1];
     run_job(t, scheduler, execution_context, f, a);
    }
   }
   function run_jobs(t, scheduler){
    try{
     run_external_jobs(t, scheduler);
     for(;;){
      if(! can_run_a_job(t)) return _D_;
      var
       this_job = offset(t, 0),
       execution_context = caml_call2(Core_Uniform_array[20], t[3], this_job),
       f = caml_call2(Core_Uniform_array[20], t[3], this_job + 1 | 0),
       a = caml_call2(Core_Uniform_array[20], t[3], this_job + 2 | 0);
      set(t, 0, dummy_e, dummy_f, dummy_a);
      t[5] = (t[5] + 1 | 0) & t[4];
      t[6] = t[6] - 1 | 0;
      t[2] = t[2] - 1 | 0;
      run_job(t, scheduler, execution_context, f, a);
      run_external_jobs(t, scheduler);
     }
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0);
     return [1, [0, exn, backtrace]];
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_queue);
   var
    Async_kernel_Job_queue =
      [0,
       sexp_of_t,
       invariant,
       create,
       enqueue,
       clear,
       set_jobs_left_this_cycle$0,
       can_run_a_job,
       length,
       run_jobs,
       num_jobs_run];
   runtime.caml_register_global
    (49, Async_kernel_Job_queue, cst_Async_kernel_Job_queue$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source0
//# unitInfo: Requires: Assert_failure, Async_kernel__Job_or_event, Async_kernel__Scheduler0, Async_kernel__Time_ns, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Error, Core__List, Core__Or_error, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t$0 =
      "Async_kernel__Synchronous_time_source0",
    cst_advance_errors$0 = "advance_errors",
    cst_alarm$0 = "alarm",
    cst_am_advancing$0 = "am_advancing",
    cst_async_kernel$0 = "async_kernel",
    cst_at$0 = "at",
    cst_callback$0 = "callback",
    cst_events$0 = "events",
    cst_execution_context$0 = "execution_context",
    cst_fired_events$0 = "fired_events",
    cst_handle_fired$0 = "handle_fired",
    cst_id$0 = "id",
    cst_interval$0 = "interval",
    cst_is_wall_clock$0 = "is_wall_clock",
    cst_most_recently_fired$0 = "most_recently_fired",
    cst_next_fired$0 = "next_fired",
    cst_now = "now",
    cst_prev_fired$0 = "prev_fired",
    cst_scheduler$0 = "scheduler",
    cst_src_synchronous_time_sourc$0 = "src/synchronous_time_source0.ml",
    cst_status$0 = "status",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$3 = "src/synchronous_time_source0.ml:341:32",
    pos$2 = "src/synchronous_time_source0.ml:340:32",
    pos$1 = "src/synchronous_time_source0.ml:187:30",
    pos$0 = "src/synchronous_time_source0.ml:205:32",
    pos = "src/synchronous_time_source0.ml:215:32",
    cst = "",
    names =
      [0,
       cst_alarm$0,
       [0,
        cst_at$0,
        [0,
         cst_callback$0,
         [0,
          cst_execution_context$0,
          [0,
           cst_interval$0,
           [0, cst_next_fired$0, [0, cst_prev_fired$0, [0, cst_status$0, 0]]]]]]]],
    names$0 =
      [0,
       cst_id$0,
       [0,
        cst_advance_errors$0,
        [0,
         cst_am_advancing$0,
         [0,
          cst_events$0,
          [0,
           cst_fired_events$0,
           [0,
            cst_most_recently_fired$0,
            [0,
             cst_handle_fired$0,
             [0, cst_is_wall_clock$0, [0, cst_scheduler$0, 0]]]]]]]]],
    Timing_wheel = global_data.Timing_wheel,
    Core_Error = global_data.Core__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Or_error = global_data.Core__Or_error,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Async_kernel_Job_or_event = global_data.Async_kernel__Job_or_event,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_synchronous_time_sourc$0);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    typerep_of_t = Async_kernel_Time_ns[1],
    typename_of_t = Async_kernel_Time_ns[2],
    bin_size_t = Async_kernel_Time_ns[3],
    bin_write_t = Async_kernel_Time_ns[4],
    bin_read_t = Async_kernel_Time_ns[5],
    bin_read_t$0 = Async_kernel_Time_ns[6],
    bin_shape_t = Async_kernel_Time_ns[7],
    bin_writer_t = Async_kernel_Time_ns[8],
    bin_reader_t = Async_kernel_Time_ns[9],
    bin_t = Async_kernel_Time_ns[10],
    quickcheck_generator = Async_kernel_Time_ns[11],
    quickcheck_observer = Async_kernel_Time_ns[12],
    quickcheck_shrinker = Async_kernel_Time_ns[13],
    gen_incl = Async_kernel_Time_ns[14],
    gen_uniform_incl = Async_kernel_Time_ns[15],
    is_earlier = Async_kernel_Time_ns[16],
    is_later = Async_kernel_Time_ns[17],
    of_date_ofday = Async_kernel_Time_ns[18],
    of_date_ofday_precise = Async_kernel_Time_ns[19],
    to_date_ofday = Async_kernel_Time_ns[20],
    to_date_ofday_precise = Async_kernel_Time_ns[21],
    to_date = Async_kernel_Time_ns[22],
    to_ofday = Async_kernel_Time_ns[23],
    reset_date_cache = Async_kernel_Time_ns[24],
    convert = Async_kernel_Time_ns[25],
    utc_offset = Async_kernel_Time_ns[26],
    to_filename_string = Async_kernel_Time_ns[27],
    of_filename_string = Async_kernel_Time_ns[28],
    to_string_abs = Async_kernel_Time_ns[29],
    to_string_abs_trimmed = Async_kernel_Time_ns[30],
    to_string_abs_parts = Async_kernel_Time_ns[31],
    to_string_trimmed = Async_kernel_Time_ns[32],
    to_sec_string = Async_kernel_Time_ns[33],
    to_sec_string_with_zone = Async_kernel_Time_ns[34],
    of_localized_string = Async_kernel_Time_ns[35],
    of_string_gen = Async_kernel_Time_ns[36],
    to_string_iso8601_basic = Async_kernel_Time_ns[37],
    occurrence = Async_kernel_Time_ns[38],
    of_string = Async_kernel_Time_ns[39],
    of_string_with_utc_offset = Async_kernel_Time_ns[40],
    to_string = Async_kernel_Time_ns[41],
    to_string_utc = Async_kernel_Time_ns[42],
    epoch = Async_kernel_Time_ns[43],
    min_value_representable = Async_kernel_Time_ns[44],
    max_value_representable = Async_kernel_Time_ns[45],
    min_value_for_1us_rounding = Async_kernel_Time_ns[46],
    max_value_for_1us_rounding = Async_kernel_Time_ns[47],
    min_value = Async_kernel_Time_ns[48],
    max_value = Async_kernel_Time_ns[49],
    now = Async_kernel_Time_ns[50],
    add = Async_kernel_Time_ns[51],
    add_saturating = Async_kernel_Time_ns[52],
    sub_saturating = Async_kernel_Time_ns[53],
    sub = Async_kernel_Time_ns[54],
    next = Async_kernel_Time_ns[55],
    prev = Async_kernel_Time_ns[56],
    diff = Async_kernel_Time_ns[57],
    abs_diff = Async_kernel_Time_ns[58],
    to_span_since_epoch = Async_kernel_Time_ns[59],
    of_span_since_epoch = Async_kernel_Time_ns[60],
    to_int63_ns_since_epoch = Async_kernel_Time_ns[61],
    of_int63_ns_since_epoch = Async_kernel_Time_ns[62],
    to_int_ns_since_epoch = Async_kernel_Time_ns[63],
    of_int_ns_since_epoch = Async_kernel_Time_ns[64],
    next_multiple = Async_kernel_Time_ns[65],
    prev_multiple = Async_kernel_Time_ns[66],
    random = Async_kernel_Time_ns[67],
    of_time = Async_kernel_Time_ns[68],
    to_time = Async_kernel_Time_ns[69],
    to_time_float_round_nearest = Async_kernel_Time_ns[70],
    to_time_float_round_nearest_mi = Async_kernel_Time_ns[71],
    of_time_float_round_nearest = Async_kernel_Time_ns[72],
    of_time_float_round_nearest_mi = Async_kernel_Time_ns[73],
    arg_type = Async_kernel_Time_ns[74],
    get_sexp_zone = Async_kernel_Time_ns[75],
    interruptible_pause = Async_kernel_Time_ns[76],
    of_date_ofday_zoned = Async_kernel_Time_ns[77],
    of_string_abs = Async_kernel_Time_ns[78],
    of_string_fix_proto = Async_kernel_Time_ns[79],
    pause = Async_kernel_Time_ns[80],
    pause_forever = Async_kernel_Time_ns[81],
    pp = Async_kernel_Time_ns[82],
    set_sexp_zone = Async_kernel_Time_ns[83],
    sexp_of_t_abs = Async_kernel_Time_ns[84],
    t_of_sexp_abs = Async_kernel_Time_ns[85],
    to_date_ofday_zoned = Async_kernel_Time_ns[86],
    to_ofday_zoned = Async_kernel_Time_ns[87],
    to_string_fix_proto = Async_kernel_Time_ns[88],
    hash_fold_t = Async_kernel_Time_ns[89],
    hash = Async_kernel_Time_ns[90],
    t_of_sexp = Async_kernel_Time_ns[91],
    t_sexp_grammar = Async_kernel_Time_ns[93],
    symbol = Async_kernel_Time_ns[94],
    symbol$0 = Async_kernel_Time_ns[95],
    symbol$1 = Async_kernel_Time_ns[96],
    symbol$2 = Async_kernel_Time_ns[97],
    symbol$3 = Async_kernel_Time_ns[98],
    symbol$4 = Async_kernel_Time_ns[99],
    equal = Async_kernel_Time_ns[100],
    compare = Async_kernel_Time_ns[101],
    min = Async_kernel_Time_ns[102],
    max = Async_kernel_Time_ns[103],
    ascending = Async_kernel_Time_ns[104],
    descending = Async_kernel_Time_ns[105],
    between = Async_kernel_Time_ns[106],
    clamp_exn = Async_kernel_Time_ns[107],
    clamp = Async_kernel_Time_ns[108],
    comparator = Async_kernel_Time_ns[109],
    validate_lbound = Async_kernel_Time_ns[110],
    validate_ubound = Async_kernel_Time_ns[111],
    validate_bound = Async_kernel_Time_ns[112],
    after = Async_kernel_Time_ns[113],
    _ao_ = [0, 0],
    cst_cannot_call_advance_by_ala =
      "cannot call [advance_by_alarms] or [advance_directly] from callback",
    _an_ = [0, cst_src_synchronous_time_sourc$0, 633, 48],
    _am_ = [0, 0],
    cst_cannot_schedule_an_event_w = "cannot schedule an event with status",
    _al_ = [0, "reason"],
    cst_Synchronous_time_source_ab =
      "[Synchronous_time_source.abort_exn] cannot abort event",
    _ai_ = [0, "Ok"],
    _aj_ = [0, "Currently_happening"],
    _ak_ = [0, "Previously_unscheduled"],
    _ag_ = [0, "alarm_precision"],
    _ah_ = [0, "span"],
    cst_interval_span_smaller_than =
      "interval span smaller than alarm precision",
    _ae_ = [0, "_"],
    _ad_ = [0, cst_src_synchronous_time_sourc$0, 339, 17],
    _ac_ = [0, cst_src_synchronous_time_sourc$0, 346, 15],
    _ab_ = [0, cst_src_synchronous_time_sourc$0, 350, 17],
    _aa_ = [0, cst_src_synchronous_time_sourc$0, 362, 29],
    _af_ = [0, cst_src_synchronous_time_sourc$0, 323, 11243, 11267],
    _Z_ = [0, cst_now],
    cst_wall_clock = "wall_clock",
    ___ = [0, cst_events$0],
    _$_ = [0, cst_now],
    cst_Job_t = "<Job.t>",
    _E_ = [0, "event"],
    _F_ = [0, "to_"],
    _G_ = [0, "from"],
    cst_bug_set_status_transition_ =
      "bug -- set_status transition not allowed",
    cst_src_synchronous_time_sourc = "src/synchronous_time_source0.ml:226:12",
    _C_ = [0, cst_src_synchronous_time_sourc$0, 206, 17],
    _B_ = [0, cst_src_synchronous_time_sourc$0, 216, 17],
    _D_ = [0, cst_src_synchronous_time_sourc$0, 182, 5945, 5971],
    cst_Synchronous_time_source_Ev =
      "[Synchronous_time_source.Event.Option.value_exn None]",
    _k_ = [1, 0],
    _h_ = [0, cst_interval$0],
    _i_ = [0, cst_at$0],
    _j_ = [0, cst_status$0],
    _d_ = [0, "Fired"],
    _e_ = [0, "Happening"],
    _f_ = [0, "Scheduled"],
    _g_ = [0, "Unscheduled"],
    _b_ = [0, 13, [0, 6, [0, 6, [0, 5, 0]]]],
    cst_status = cst_status$0,
    cst_prev_fired = cst_prev_fired$0,
    cst_next_fired = cst_next_fired$0,
    cst_interval = cst_interval$0,
    cst_execution_context = cst_execution_context$0,
    cst_callback = cst_callback$0,
    cst_at = cst_at$0,
    cst_alarm = cst_alarm$0,
    cst_scheduler = cst_scheduler$0,
    cst_is_wall_clock = cst_is_wall_clock$0,
    cst_handle_fired = cst_handle_fired$0,
    cst_most_recently_fired = cst_most_recently_fired$0,
    cst_fired_events = cst_fired_events$0,
    cst_events = cst_events$0,
    cst_am_advancing = cst_am_advancing$0,
    cst_advance_errors = cst_advance_errors$0,
    cst_id = cst_id$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Synchronous_t = cst_Async_kernel_Synchronous_t$0;
   function sexp_of_t(t){
    var
     _d8_ = caml_call1(to_span_since_epoch, t),
     _d9_ =
       runtime.core_time_ns_format
        (caml_call1(Core_Time_ns[1][91], _d8_), "%Y-%m-%dT%H:%M:%S%z");
    return caml_call1(Core[471], _d9_);
   }
   var
    Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after,
       sexp_of_t],
    include = Timing_wheel[5],
    sexp_of_t$0 = include[1],
    null$0 = include[2],
    at = include[3],
    interval_num = include[4],
    value = include[5];
   function is_null(t){
    var _d7_ = caml_call1(null$0, 0);
    return caml_call2(Core[246], t, _d7_);
   }
   var
    Alarm = [0, sexp_of_t$0, null$0, at, interval_num, value, is_null],
    _a_ = caml_call2(Timing_wheel[1][13], Timing_wheel[1][10], 3),
    _c_ = [0, caml_call2(Timing_wheel[7][5], 0, _b_)],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _c_, _a_, 0),
    compare$0 = runtime.caml_int_compare;
   function equal$0(_d6_, _d5_){return _d6_ === _d5_ ? 1 : 0;}
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _d_;
      case 1:
       return _e_;
      case 2:
       return _f_;
      default: return _g_;
    }
   }
   function transition_is_allowed(from, to){
    a:
    {
     switch(from){
       case 0:
        if(1 !== to && 3 > to) break a; break;
       case 1:
        if(2 > to) break a; break;
       case 2:
        if(1 >= to - 1 >>> 0) break a; break;
       default: if(1 === to || 3 <= to) break a;
     }
     return 1;
    }
    return 0;
   }
   var Status = [0, compare$0, equal$0, sexp_of_t$1, transition_is_allowed];
   function sexp_of_event(param){
    var at = param[2], interval = param[5], status = param[8], match = 0;
    if(interval)
     var
      v = interval[1],
      _d3_ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], v), 0]]], match];
    else
     var _d3_ = match;
    var _d4_ = [0, [1, [0, _i_, [0, caml_call1(Time_ns[113], at), 0]]], _d3_];
    return [1,
            [0, [1, [0, _j_, [0, caml_call1(Status[3], status), 0]]], _d4_]];
   }
   var Event_is_block = [0], none = 0;
   function some(_d2_){return _d2_;}
   function is_none(t){return caml_call2(Core[246], t, none);}
   function is_some(t){return 1 - is_none(t);}
   function first_some(t1, t2){return is_some(t1) ? t1 : t2;}
   function unsafe_value(_d1_){return _d1_;}
   var
    Optional_syntax = [0, is_none, unsafe_value],
    Optional_syntax$0 = [0, Optional_syntax];
   function sexp_of_t$2(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return _k_;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return sexp_of_event(event);
   }
   function value$0(ppx_optional_e_0, default$0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0))
     return default$0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function value_exn(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)){
     var
      _d0_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_Ev);
     return caml_call1(Core[253], _d0_);
    }
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function to_option(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return 0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return [0, event];
   }
   function of_option(param){
    if(! param) return none;
    var event = param[1];
    return event;
   }
   var
    Option =
      [0,
       Event_is_block,
       none,
       some,
       is_none,
       is_some,
       first_some,
       Optional_syntax$0,
       sexp_of_t$2,
       value$0,
       value_exn,
       to_option,
       of_option];
   function status(r){return r[8];}
   function set_status(r, v){r[8] = v; return 0;}
   function prev_fired(r){return r[7];}
   function set_prev_fired(r, v){r[7] = v; return 0;}
   function next_fired(r){return r[6];}
   function set_next_fired(r, v){r[6] = v; return 0;}
   function interval(r){return r[5];}
   function set_interval(r, v){r[5] = v; return 0;}
   function execution_context(r){return r[4];}
   function callback(r){return r[3];}
   function at$0(r){return r[2];}
   function set_at(r, v){r[2] = v; return 0;}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _l_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _m_ = [0, set_status],
    status$0 = [0, function(param){return 0;}, cst_status, _m_, status, _l_];
   function _n_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _o_ = [0, set_prev_fired],
    prev_fired$0 =
      [0, function(param){return 0;}, cst_prev_fired, _o_, prev_fired, _n_];
   function _p_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _q_ = [0, set_next_fired],
    next_fired$0 =
      [0, function(param){return 0;}, cst_next_fired, _q_, next_fired, _p_];
   function _r_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _s_ = [0, set_interval],
    interval$0 =
      [0, function(param){return 0;}, cst_interval, _s_, interval, _r_];
   function _t_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _u_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _u_,
       execution_context,
       _t_];
   function _v_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _w_ = 0,
    callback$0 =
      [0, function(param){return 0;}, cst_callback, _w_, callback, _v_];
   function _x_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _y_ = [0, set_at],
    at$1 = [0, function(param){return 0;}, cst_at, _y_, at$0, _x_];
   function _z_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _A_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _A_, alarm, _z_];
   function make_creator
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun,
    compile_acc){
    var
     match = caml_call2(alarm_fun, alarm$0, compile_acc),
     compile_acc$0 = match[2],
     alarm_gen = match[1],
     match$0 = caml_call2(at_fun, at$1, compile_acc$0),
     compile_acc$1 = match$0[2],
     at_gen = match$0[1],
     match$1 = caml_call2(callback_fun, callback$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     callback_gen = match$1[1],
     match$2 =
       caml_call2(execution_context_fun, execution_context$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     execution_context_gen = match$2[1],
     match$3 = caml_call2(interval_fun, interval$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     interval_gen = match$3[1],
     match$4 = caml_call2(next_fired_fun, next_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     next_fired_gen = match$4[1],
     match$5 = caml_call2(prev_fired_fun, prev_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     prev_fired_gen = match$5[1],
     match$6 = caml_call2(status_fun, status$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     status_gen = match$6[1];
    return [0,
            function(acc){
             var
              alarm = caml_call1(alarm_gen, acc),
              at = caml_call1(at_gen, acc),
              callback = caml_call1(callback_gen, acc),
              execution_context = caml_call1(execution_context_gen, acc),
              interval = caml_call1(interval_gen, acc),
              next_fired = caml_call1(next_fired_gen, acc),
              prev_fired = caml_call1(prev_fired_gen, acc),
              status = caml_call1(status_gen, acc);
             return [0,
                     alarm,
                     at,
                     callback,
                     execution_context,
                     interval,
                     next_fired,
                     prev_fired,
                     status];
            },
            compile_acc$7];
   }
   function create
   (alarm,
    at,
    callback,
    execution_context,
    interval,
    next_fired,
    prev_fired,
    status){
    return [0,
            alarm,
            at,
            callback,
            execution_context,
            interval,
            next_fired,
            prev_fired,
            status];
   }
   function map
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dT_ = caml_call1(status_fun, status$0),
     _dU_ = caml_call1(prev_fired_fun, prev_fired$0),
     _dV_ = caml_call1(next_fired_fun, next_fired$0),
     _dW_ = caml_call1(interval_fun, interval$0),
     _dX_ = caml_call1(execution_context_fun, execution_context$0),
     _dY_ = caml_call1(callback_fun, callback$0),
     _dZ_ = caml_call1(at_fun, at$1);
    return [0,
            caml_call1(alarm_fun, alarm$0),
            _dZ_,
            _dY_,
            _dX_,
            _dW_,
            _dV_,
            _dU_,
            _dT_];
   }
   function iter
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call1(alarm_fun, alarm$0);
    caml_call1(at_fun, at$1);
    caml_call1(callback_fun, callback$0);
    caml_call1(execution_context_fun, execution_context$0);
    caml_call1(interval_fun, interval$0);
    caml_call1(next_fired_fun, next_fired$0);
    caml_call1(prev_fired_fun, prev_fired$0);
    return caml_call1(status_fun, status$0);
   }
   function fold
   (init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    return caml_call2
            (status_fun,
             caml_call2
              (prev_fired_fun,
               caml_call2
                (next_fired_fun,
                 caml_call2
                  (interval_fun,
                   caml_call2
                    (execution_context_fun,
                     caml_call2
                      (callback_fun,
                       caml_call2
                        (at_fun, caml_call2(alarm_fun, init, alarm$0), at$1),
                       callback$0),
                     execution_context$0),
                   interval$0),
                 next_fired$0),
               prev_fired$0),
             status$0);
   }
   function map_poly(record){
    var
     _dM_ = [0, caml_call1(record[1], status$0), 0],
     _dN_ = [0, caml_call1(record[1], prev_fired$0), _dM_],
     _dO_ = [0, caml_call1(record[1], next_fired$0), _dN_],
     _dP_ = [0, caml_call1(record[1], interval$0), _dO_],
     _dQ_ = [0, caml_call1(record[1], execution_context$0), _dP_],
     _dR_ = [0, caml_call1(record[1], callback$0), _dQ_],
     _dS_ = [0, caml_call1(record[1], at$1), _dR_];
    return [0, caml_call1(record[1], alarm$0), _dS_];
   }
   function for_all
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dF_ = caml_call1(alarm_fun, alarm$0),
     _dG_ = _dF_ ? caml_call1(at_fun, at$1) : _dF_,
     _dH_ = _dG_ ? caml_call1(callback_fun, callback$0) : _dG_,
     _dI_ =
       _dH_ ? caml_call1(execution_context_fun, execution_context$0) : _dH_,
     _dJ_ = _dI_ ? caml_call1(interval_fun, interval$0) : _dI_,
     _dK_ = _dJ_ ? caml_call1(next_fired_fun, next_fired$0) : _dJ_,
     _dL_ = _dK_ ? caml_call1(prev_fired_fun, prev_fired$0) : _dK_;
    return _dL_ ? caml_call1(status_fun, status$0) : _dL_;
   }
   function exists
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dE_ = caml_call1(alarm_fun, alarm$0),
     _dy_ = _dE_ || caml_call1(at_fun, at$1),
     _dz_ = _dy_ || caml_call1(callback_fun, callback$0),
     _dA_ = _dz_ || caml_call1(execution_context_fun, execution_context$0),
     _dB_ = _dA_ || caml_call1(interval_fun, interval$0),
     _dC_ = _dB_ || caml_call1(next_fired_fun, next_fired$0),
     _dD_ = _dC_ || caml_call1(prev_fired_fun, prev_fired$0);
    return _dD_ ? _dD_ : caml_call1(status_fun, status$0);
   }
   function to_list
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dr_ = [0, caml_call1(status_fun, status$0), 0],
     _ds_ = [0, caml_call1(prev_fired_fun, prev_fired$0), _dr_],
     _dt_ = [0, caml_call1(next_fired_fun, next_fired$0), _ds_],
     _du_ = [0, caml_call1(interval_fun, interval$0), _dt_],
     _dv_ = [0, caml_call1(execution_context_fun, execution_context$0), _du_],
     _dw_ = [0, caml_call1(callback_fun, callback$0), _dv_],
     _dx_ = [0, caml_call1(at_fun, at$1), _dw_];
    return [0, caml_call1(alarm_fun, alarm$0), _dx_];
   }
   function iter$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call3(alarm_fun, alarm$0, record, record[1]);
    caml_call3(at_fun, at$1, record, record[2]);
    caml_call3(callback_fun, callback$0, record, record[3]);
    caml_call3(execution_context_fun, execution_context$0, record, record[4]);
    caml_call3(interval_fun, interval$0, record, record[5]);
    caml_call3(next_fired_fun, next_fired$0, record, record[6]);
    caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return caml_call3(status_fun, status$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dk_ = record[8],
     _dl_ = record[7],
     _dm_ = record[6],
     _dn_ = record[5],
     _do_ = record[4],
     _dp_ = record[3],
     _dq_ = record[2];
    return caml_call4
            (status_fun,
             caml_call4
              (prev_fired_fun,
               caml_call4
                (next_fired_fun,
                 caml_call4
                  (interval_fun,
                   caml_call4
                    (execution_context_fun,
                     caml_call4
                      (callback_fun,
                       caml_call4
                        (at_fun,
                         caml_call4(alarm_fun, init, alarm$0, record, record[1]),
                         at$1,
                         record,
                         _dq_),
                       callback$0,
                       record,
                       _dp_),
                     execution_context$0,
                     record,
                     _do_),
                   interval$0,
                   record,
                   _dn_),
                 next_fired$0,
                 record,
                 _dm_),
               prev_fired$0,
               record,
               _dl_),
             status$0,
             record,
             _dk_);
   }
   function for_all$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dd_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _de_ = _dd_ ? caml_call3(at_fun, at$1, record, record[2]) : _dd_,
     _df_ =
       _de_ ? caml_call3(callback_fun, callback$0, record, record[3]) : _de_,
     _dg_ =
       _df_
        ? caml_call3
          (execution_context_fun, execution_context$0, record, record[4])
        : _df_,
     _dh_ =
       _dg_ ? caml_call3(interval_fun, interval$0, record, record[5]) : _dg_,
     _di_ =
       _dh_
        ? caml_call3(next_fired_fun, next_fired$0, record, record[6])
        : _dh_,
     _dj_ =
       _di_
        ? caml_call3(prev_fired_fun, prev_fired$0, record, record[7])
        : _di_;
    return _dj_ ? caml_call3(status_fun, status$0, record, record[8]) : _dj_;
   }
   function exists$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _dc_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _c8_ = _dc_ || caml_call3(at_fun, at$1, record, record[2]),
     _c9_ = _c8_ || caml_call3(callback_fun, callback$0, record, record[3]),
     _c__ =
       _c9_
       ||
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
     _c$_ = _c__ || caml_call3(interval_fun, interval$0, record, record[5]),
     _da_ =
       _c$_ || caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _db_ =
       _da_ || caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return _db_ ? _db_ : caml_call3(status_fun, status$0, record, record[8]);
   }
   function to_list$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _c1_ = [0, caml_call3(status_fun, status$0, record, record[8]), 0],
     _c2_ =
       [0, caml_call3(prev_fired_fun, prev_fired$0, record, record[7]), _c1_],
     _c3_ =
       [0, caml_call3(next_fired_fun, next_fired$0, record, record[6]), _c2_],
     _c4_ = [0, caml_call3(interval_fun, interval$0, record, record[5]), _c3_],
     _c5_ =
       [0,
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
        _c4_],
     _c6_ = [0, caml_call3(callback_fun, callback$0, record, record[3]), _c5_],
     _c7_ = [0, caml_call3(at_fun, at$1, record, record[2]), _c6_];
    return [0, caml_call3(alarm_fun, alarm$0, record, record[1]), _c7_];
   }
   function map$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cU_ = caml_call3(status_fun, status$0, record, record[8]),
     _cV_ = caml_call3(prev_fired_fun, prev_fired$0, record, record[7]),
     _cW_ = caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _cX_ = caml_call3(interval_fun, interval$0, record, record[5]),
     _cY_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[4]),
     _cZ_ = caml_call3(callback_fun, callback$0, record, record[3]),
     _c0_ = caml_call3(at_fun, at$1, record, record[2]);
    return [0,
            caml_call3(alarm_fun, alarm$0, record, record[1]),
            _c0_,
            _cZ_,
            _cY_,
            _cX_,
            _cW_,
            _cV_,
            _cU_];
   }
   function set_all_mutable_fields
   (record, alarm, at, interval, next_fired, prev_fired, status){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = alarm;
    record$0[2] = at;
    record$0[5] = interval;
    record$0[6] = next_fired;
    record$0[7] = prev_fired;
    record$0[8] = status;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       status$0,
       prev_fired$0,
       next_fired$0,
       interval$0,
       execution_context$0,
       callback$0,
       at$1,
       alarm$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function invariant(t){
    function _cC_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     function _cD_(_cT_){return 0;}
     var
      _cE_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
           var
            prev_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_013, b_014){
            return caml_call2(Status[1], a_013, b_014);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _cR_ = prev_fired[6], _cS_ = caml_call1(Option[3], t);
           if(caml_call2(Core[246], _cS_, _cR_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
          }),
      _cF_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
           var
            next_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_009, b_010){
            return caml_call2(Status[1], a_009, b_010);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _cP_ = next_fired[7], _cQ_ = caml_call1(Option[3], t);
           if(caml_call2(Core[246], _cQ_, _cP_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
          });
     function _cG_(_cO_){return 0;}
     function _cH_(_cN_){return 0;}
     function _cI_(_cM_){return 0;}
     function _cJ_(_cL_){return 0;}
     var
      _cK_ =
        check
         (function(alarm){
           var
            got = caml_call1(Alarm[6], alarm),
            expect = 2 === t[8] ? 0 : 1,
            sexpifier = Core[305],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_005, b_006){
            return caml_call2(Core[301], a_005, b_006);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$1,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     return caml_call8
             (Fields[13], _cK_, _cJ_, _cI_, _cH_, _cG_, _cF_, _cE_, _cD_);
    }
    return caml_call4(Base_Invariant[1], _D_, t, sexp_of_event, _cC_);
   }
   function set_status$0(t, to){
    var from = t[8];
    if(1 - caml_call2(Status[4], from, to)){
     var
      _cx_ = [0, [1, [0, _E_, [0, sexp_of_event(t), 0]]], 0],
      _cy_ = [0, [1, [0, _F_, [0, caml_call1(Status[3], to), 0]]], _cx_],
      _cz_ = [0, [1, [0, _G_, [0, caml_call1(Status[3], from), 0]]], _cy_],
      _cA_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_bug_set_status_transition_),
         _cz_],
      _cB_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_src_synchronous_time_sourc),
          _cA_]];
     caml_call1(Core[253], _cB_);
    }
    t[8] = to;
    return 0;
   }
   function set_status_if(is, t, to){
    var _cw_ = caml_call2(Status[2], is, t[8]);
    return _cw_ ? set_status$0(t, to) : _cw_;
   }
   var
    Event =
      [0,
       Status,
       sexp_of_event,
       Option,
       status,
       prev_fired,
       set_prev_fired,
       next_fired,
       set_next_fired,
       interval,
       set_interval,
       execution_context,
       callback,
       at$0,
       set_at,
       alarm,
       set_alarm,
       Fields,
       sexp_of_event,
       invariant,
       set_status$0,
       set_status_if,
       at$0],
    of_event = Async_kernel_Job_or_event[1],
    of_job = Async_kernel_Job_or_event[2],
    is_event = Async_kernel_Job_or_event[3],
    is_job = Async_kernel_Job_or_event[4],
    Match = Async_kernel_Job_or_event[5];
   function sexp_of_t$3(t){
    var
     k = caml_call1(Async_kernel_Job_or_event[5][1], t),
     match = caml_call2(Async_kernel_Job_or_event[5][2], k, t);
    return k
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_Job_t)
            : caml_call1(Event[18], match);
   }
   var
    Job_or_event = [0, of_event, of_job, is_event, is_job, Match, sexp_of_t$3];
   function scheduler(r){return r[9];}
   function is_wall_clock(r){return r[8];}
   function handle_fired(r){return r[7];}
   function most_recently_fired(r){return r[6];}
   function set_most_recently_fired(r, v){r[6] = v; return 0;}
   function fired_events(r){return r[5];}
   function set_fired_events(r, v){r[5] = v; return 0;}
   function events(r){return r[4];}
   function am_advancing(r){return r[3];}
   function set_am_advancing(r, v){r[3] = v; return 0;}
   function advance_errors(r){return r[2];}
   function set_advance_errors(r, v){r[2] = v; return 0;}
   function id(r){return r[1];}
   function _H_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v];
   }
   var
    _I_ = 0,
    scheduler$0 =
      [0, function(param){return 0;}, cst_scheduler, _I_, scheduler, _H_];
   function _J_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9]];
   }
   var
    _K_ = 0,
    is_wall_clock$0 =
      [0,
       function(param){return 0;},
       cst_is_wall_clock,
       _K_,
       is_wall_clock,
       _J_];
   function _L_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9]];
   }
   var
    _M_ = 0,
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       _M_,
       handle_fired,
       _L_];
   function _N_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9]];
   }
   var
    _O_ = [0, set_most_recently_fired],
    most_recently_fired$0 =
      [0,
       function(param){return 0;},
       cst_most_recently_fired,
       _O_,
       most_recently_fired,
       _N_];
   function _P_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9]];
   }
   var
    _Q_ = [0, set_fired_events],
    fired_events$0 =
      [0,
       function(param){return 0;},
       cst_fired_events,
       _Q_,
       fired_events,
       _P_];
   function _R_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _S_ = 0,
    events$0 = [0, function(param){return 0;}, cst_events, _S_, events, _R_];
   function _T_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _U_ = [0, set_am_advancing],
    am_advancing$0 =
      [0,
       function(param){return 0;},
       cst_am_advancing,
       _U_,
       am_advancing,
       _T_];
   function _V_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _W_ = [0, set_advance_errors],
    advance_errors$0 =
      [0,
       function(param){return 0;},
       cst_advance_errors,
       _W_,
       advance_errors,
       _V_];
   function _X_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var _Y_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _Y_, id, _X_];
   function make_creator$0
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun,
    compile_acc){
    var
     match = caml_call2(id_fun, id$0, compile_acc),
     compile_acc$0 = match[2],
     id_gen = match[1],
     match$0 = caml_call2(advance_errors_fun, advance_errors$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     advance_errors_gen = match$0[1],
     match$1 = caml_call2(am_advancing_fun, am_advancing$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     am_advancing_gen = match$1[1],
     match$2 = caml_call2(events_fun, events$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     events_gen = match$2[1],
     match$3 = caml_call2(fired_events_fun, fired_events$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     fired_events_gen = match$3[1],
     match$4 =
       caml_call2
        (most_recently_fired_fun, most_recently_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     most_recently_fired_gen = match$4[1],
     match$5 = caml_call2(handle_fired_fun, handle_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     handle_fired_gen = match$5[1],
     match$6 = caml_call2(is_wall_clock_fun, is_wall_clock$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     is_wall_clock_gen = match$6[1],
     match$7 = caml_call2(scheduler_fun, scheduler$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     scheduler_gen = match$7[1];
    return [0,
            function(acc){
             var
              id = caml_call1(id_gen, acc),
              advance_errors = caml_call1(advance_errors_gen, acc),
              am_advancing = caml_call1(am_advancing_gen, acc),
              events = caml_call1(events_gen, acc),
              fired_events = caml_call1(fired_events_gen, acc),
              most_recently_fired = caml_call1(most_recently_fired_gen, acc),
              handle_fired = caml_call1(handle_fired_gen, acc),
              is_wall_clock = caml_call1(is_wall_clock_gen, acc),
              scheduler = caml_call1(scheduler_gen, acc);
             return [0,
                     id,
                     advance_errors,
                     am_advancing,
                     events,
                     fired_events,
                     most_recently_fired,
                     handle_fired,
                     is_wall_clock,
                     scheduler];
            },
            compile_acc$8];
   }
   function create$0
   (id,
    advance_errors,
    am_advancing,
    events,
    fired_events,
    most_recently_fired,
    handle_fired,
    is_wall_clock,
    scheduler){
    return [0,
            id,
            advance_errors,
            am_advancing,
            events,
            fired_events,
            most_recently_fired,
            handle_fired,
            is_wall_clock,
            scheduler];
   }
   function map$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _co_ = caml_call1(scheduler_fun, scheduler$0),
     _cp_ = caml_call1(is_wall_clock_fun, is_wall_clock$0),
     _cq_ = caml_call1(handle_fired_fun, handle_fired$0),
     _cr_ = caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _cs_ = caml_call1(fired_events_fun, fired_events$0),
     _ct_ = caml_call1(events_fun, events$0),
     _cu_ = caml_call1(am_advancing_fun, am_advancing$0),
     _cv_ = caml_call1(advance_errors_fun, advance_errors$0);
    return [0,
            caml_call1(id_fun, id$0),
            _cv_,
            _cu_,
            _ct_,
            _cs_,
            _cr_,
            _cq_,
            _cp_,
            _co_];
   }
   function iter$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call1(id_fun, id$0);
    caml_call1(advance_errors_fun, advance_errors$0);
    caml_call1(am_advancing_fun, am_advancing$0);
    caml_call1(events_fun, events$0);
    caml_call1(fired_events_fun, fired_events$0);
    caml_call1(most_recently_fired_fun, most_recently_fired$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return caml_call1(scheduler_fun, scheduler$0);
   }
   function fold$1
   (init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    return caml_call2
            (scheduler_fun,
             caml_call2
              (is_wall_clock_fun,
               caml_call2
                (handle_fired_fun,
                 caml_call2
                  (most_recently_fired_fun,
                   caml_call2
                    (fired_events_fun,
                     caml_call2
                      (events_fun,
                       caml_call2
                        (am_advancing_fun,
                         caml_call2
                          (advance_errors_fun,
                           caml_call2(id_fun, init, id$0),
                           advance_errors$0),
                         am_advancing$0),
                       events$0),
                     fired_events$0),
                   most_recently_fired$0),
                 handle_fired$0),
               is_wall_clock$0),
             scheduler$0);
   }
   function map_poly$0(record){
    var
     _cg_ = [0, caml_call1(record[1], scheduler$0), 0],
     _ch_ = [0, caml_call1(record[1], is_wall_clock$0), _cg_],
     _ci_ = [0, caml_call1(record[1], handle_fired$0), _ch_],
     _cj_ = [0, caml_call1(record[1], most_recently_fired$0), _ci_],
     _ck_ = [0, caml_call1(record[1], fired_events$0), _cj_],
     _cl_ = [0, caml_call1(record[1], events$0), _ck_],
     _cm_ = [0, caml_call1(record[1], am_advancing$0), _cl_],
     _cn_ = [0, caml_call1(record[1], advance_errors$0), _cm_];
    return [0, caml_call1(record[1], id$0), _cn_];
   }
   function for_all$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _b__ = caml_call1(id_fun, id$0),
     _b$_ = _b__ ? caml_call1(advance_errors_fun, advance_errors$0) : _b__,
     _ca_ = _b$_ ? caml_call1(am_advancing_fun, am_advancing$0) : _b$_,
     _cb_ = _ca_ ? caml_call1(events_fun, events$0) : _ca_,
     _cc_ = _cb_ ? caml_call1(fired_events_fun, fired_events$0) : _cb_,
     _cd_ =
       _cc_
        ? caml_call1(most_recently_fired_fun, most_recently_fired$0)
        : _cc_,
     _ce_ = _cd_ ? caml_call1(handle_fired_fun, handle_fired$0) : _cd_,
     _cf_ = _ce_ ? caml_call1(is_wall_clock_fun, is_wall_clock$0) : _ce_;
    return _cf_ ? caml_call1(scheduler_fun, scheduler$0) : _cf_;
   }
   function exists$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _b9_ = caml_call1(id_fun, id$0),
     _b2_ = _b9_ || caml_call1(advance_errors_fun, advance_errors$0),
     _b3_ = _b2_ || caml_call1(am_advancing_fun, am_advancing$0),
     _b4_ = _b3_ || caml_call1(events_fun, events$0),
     _b5_ = _b4_ || caml_call1(fired_events_fun, fired_events$0),
     _b6_ = _b5_ || caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _b7_ = _b6_ || caml_call1(handle_fired_fun, handle_fired$0),
     _b8_ = _b7_ || caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return _b8_ ? _b8_ : caml_call1(scheduler_fun, scheduler$0);
   }
   function to_list$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bU_ = [0, caml_call1(scheduler_fun, scheduler$0), 0],
     _bV_ = [0, caml_call1(is_wall_clock_fun, is_wall_clock$0), _bU_],
     _bW_ = [0, caml_call1(handle_fired_fun, handle_fired$0), _bV_],
     _bX_ =
       [0, caml_call1(most_recently_fired_fun, most_recently_fired$0), _bW_],
     _bY_ = [0, caml_call1(fired_events_fun, fired_events$0), _bX_],
     _bZ_ = [0, caml_call1(events_fun, events$0), _bY_],
     _b0_ = [0, caml_call1(am_advancing_fun, am_advancing$0), _bZ_],
     _b1_ = [0, caml_call1(advance_errors_fun, advance_errors$0), _b0_];
    return [0, caml_call1(id_fun, id$0), _b1_];
   }
   function iter$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call3(id_fun, id$0, record, record[1]);
    caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    caml_call3(am_advancing_fun, am_advancing$0, record, record[3]);
    caml_call3(events_fun, events$0, record, record[4]);
    caml_call3(fired_events_fun, fired_events$0, record, record[5]);
    caml_call3
     (most_recently_fired_fun, most_recently_fired$0, record, record[6]);
    caml_call3(handle_fired_fun, handle_fired$0, record, record[7]);
    caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function fold$2
   (record,
    init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bM_ = record[9],
     _bN_ = record[8],
     _bO_ = record[7],
     _bP_ = record[6],
     _bQ_ = record[5],
     _bR_ = record[4],
     _bS_ = record[3],
     _bT_ = record[2];
    return caml_call4
            (scheduler_fun,
             caml_call4
              (is_wall_clock_fun,
               caml_call4
                (handle_fired_fun,
                 caml_call4
                  (most_recently_fired_fun,
                   caml_call4
                    (fired_events_fun,
                     caml_call4
                      (events_fun,
                       caml_call4
                        (am_advancing_fun,
                         caml_call4
                          (advance_errors_fun,
                           caml_call4(id_fun, init, id$0, record, record[1]),
                           advance_errors$0,
                           record,
                           _bT_),
                         am_advancing$0,
                         record,
                         _bS_),
                       events$0,
                       record,
                       _bR_),
                     fired_events$0,
                     record,
                     _bQ_),
                   most_recently_fired$0,
                   record,
                   _bP_),
                 handle_fired$0,
                 record,
                 _bO_),
               is_wall_clock$0,
               record,
               _bN_),
             scheduler$0,
             record,
             _bM_);
   }
   function for_all$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bE_ = caml_call3(id_fun, id$0, record, record[1]),
     _bF_ =
       _bE_
        ? caml_call3(advance_errors_fun, advance_errors$0, record, record[2])
        : _bE_,
     _bG_ =
       _bF_
        ? caml_call3(am_advancing_fun, am_advancing$0, record, record[3])
        : _bF_,
     _bH_ = _bG_ ? caml_call3(events_fun, events$0, record, record[4]) : _bG_,
     _bI_ =
       _bH_
        ? caml_call3(fired_events_fun, fired_events$0, record, record[5])
        : _bH_,
     _bJ_ =
       _bI_
        ? caml_call3
          (most_recently_fired_fun, most_recently_fired$0, record, record[6])
        : _bI_,
     _bK_ =
       _bJ_
        ? caml_call3(handle_fired_fun, handle_fired$0, record, record[7])
        : _bJ_,
     _bL_ =
       _bK_
        ? caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8])
        : _bK_;
    return _bL_
            ? caml_call3(scheduler_fun, scheduler$0, record, record[9])
            : _bL_;
   }
   function exists$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bD_ = caml_call3(id_fun, id$0, record, record[1]),
     _bw_ =
       _bD_
       || caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
     _bx_ =
       _bw_ || caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _by_ = _bx_ || caml_call3(events_fun, events$0, record, record[4]),
     _bz_ =
       _by_ || caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _bA_ =
       _bz_
       ||
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _bB_ =
       _bA_ || caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _bC_ =
       _bB_
       || caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return _bC_
            ? _bC_
            : caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function to_list$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bo_ = [0, caml_call3(scheduler_fun, scheduler$0, record, record[9]), 0],
     _bp_ =
       [0,
        caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
        _bo_],
     _bq_ =
       [0,
        caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
        _bp_],
     _br_ =
       [0,
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
        _bq_],
     _bs_ =
       [0,
        caml_call3(fired_events_fun, fired_events$0, record, record[5]),
        _br_],
     _bt_ = [0, caml_call3(events_fun, events$0, record, record[4]), _bs_],
     _bu_ =
       [0,
        caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
        _bt_],
     _bv_ =
       [0,
        caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
        _bu_];
    return [0, caml_call3(id_fun, id$0, record, record[1]), _bv_];
   }
   function map$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bg_ = caml_call3(scheduler_fun, scheduler$0, record, record[9]),
     _bh_ = caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
     _bi_ = caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _bj_ =
       caml_call3
        (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _bk_ = caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _bl_ = caml_call3(events_fun, events$0, record, record[4]),
     _bm_ = caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _bn_ =
       caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    return [0,
            caml_call3(id_fun, id$0, record, record[1]),
            _bn_,
            _bm_,
            _bl_,
            _bk_,
            _bj_,
            _bi_,
            _bh_,
            _bg_];
   }
   function set_all_mutable_fields$0
   (record, advance_errors, am_advancing, fired_events, most_recently_fired){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[2] = advance_errors;
    record$0[3] = am_advancing;
    record$0[5] = fired_events;
    record$0[6] = most_recently_fired;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       scheduler$0,
       is_wall_clock$0,
       handle_fired$0,
       most_recently_fired$0,
       fired_events$0,
       events$0,
       am_advancing$0,
       advance_errors$0,
       id$0,
       make_creator$0,
       create$0,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0];
   function sexp_of_t$4(param, _a7_){
    var
     events = _a7_[4],
     is_wall_clock = _a7_[8],
     now = caml_call1(Timing_wheel[11], events);
    if(is_wall_clock){
     var _a8_ = [0, [1, [0, _Z_, [0, caml_call1(Time_ns[113], now), 0]]], 0];
     return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock), _a8_]];
    }
    var all_events = [0, 0];
    function _a9_(alarm){
     var _be_ = all_events[1], _bf_ = caml_call2(Alarm[5], events, alarm);
     all_events[1] = [0, [0, caml_call2(Alarm[3], events, alarm), _bf_], _be_];
     return 0;
    }
    caml_call2(Timing_wheel[15], events, _a9_);
    function _a__(_bd_){return _bd_[2];}
    function _a$_(param, _bc_){
     var at2 = _bc_[1], at1 = param[1];
     return caml_call2(Time_ns[100], at1, at2);
    }
    var
     _ba_ = caml_call2(Core_List[58], all_events[1], _a$_),
     events$0 = caml_call2(Core_List[72], _ba_, _a__),
     _bb_ =
       [0,
        [1,
         [0, ___, [0, caml_call2(Core[421], Job_or_event[6], events$0), 0]]],
        0];
    return [1,
            [0, [1, [0, _$_, [0, caml_call1(Time_ns[113], now), 0]]], _bb_]];
   }
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function is_in_fired_events(t, target_event){
    var current$1 = t[5], ppx_optional_e_0 = current$1;
    for(;;){
     if(caml_call1(Event[3][7][1][1], ppx_optional_e_0)) return 0;
     var
      current = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
      _a6_ = caml_call2(Core[246], current, target_event);
     if(_a6_) return _a6_;
     var current$0 = current[6], ppx_optional_e_0 = current$0;
    }
   }
   function invariant_with_jobs(job_invariant, t){
    function _aL_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     function _aN_(_a5_){return 0;}
     function _aO_(_a4_){return 0;}
     function _aP_(_a3_){return 0;}
     var
      _aQ_ =
        check
         (function(most_recently_fired){
           if(caml_call1(Event[3][7][1][1], most_recently_fired)) return 0;
           var event = caml_call1(Event[3][7][1][2], most_recently_fired);
           if(is_in_fired_events(t, event)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
          }),
      _aR_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Event[3][7][1][1], ppx_optional_e_0)) return 0;
           var
            current$1 = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
            current = current$1;
           for(;;){
            var _a2_ = timing_wheel_now(t);
            if(! caml_call2(Time_ns[94], current[2], _a2_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
            var ppx_optional_e_0$0 = current[6];
            if(caml_call1(Event[3][7][1][1], ppx_optional_e_0$0)) return 0;
            var current$0 = caml_call1(Event[3][7][1][2], ppx_optional_e_0$0);
            if(! caml_call2(Time_ns[94], current[2], current$0[2]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
            var current = current$0;
           }
          }),
      _aS_ =
        check
         (function(events){
           function _aZ_(_a1_){return 0;}
           caml_call2(Timing_wheel[6], _aZ_, events);
           function _a0_(alarm){
            var
             job_or_event = caml_call2(Alarm[5], events, alarm),
             k = caml_call1(Job_or_event[5][1], job_or_event),
             event = caml_call2(Job_or_event[5][2], k, job_or_event);
            if(k) return caml_call1(job_invariant, event);
            if(! caml_call2(Core[246], alarm, event[1]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ad_], 1);
            var
             got = event[2],
             expect = caml_call2(Alarm[3], events, alarm),
             sexpifier = Time_ns[113],
             equal = 0,
             message = 0,
             here = 0;
            function comparator(a_017, b_018){
             return caml_call2(Time_ns[100], a_017, b_018);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$2,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              got);
            var
             got$0 = event[8],
             sexpifier$0 = Event[1][3],
             expect$0 = 2,
             equal$0 = 0,
             message$0 = 0,
             here$0 = 0;
            function comparator$0(a_019, b_020){
             return caml_call2(Event[1][1], a_019, b_020);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$3,
              sexpifier$0,
              comparator$0,
              here$0,
              message$0,
              equal$0,
              expect$0,
              got$0);
            return caml_call1(Event[19], event);
           }
           return caml_call2(Timing_wheel[15], events, _a0_);
          });
     function _aT_(_aY_){return 0;}
     function _aU_(_aX_){return 0;}
     function _aV_(_aW_){return 0;}
     return caml_call9
             (Fields$0[14],
              _aV_,
              _aU_,
              _aT_,
              _aS_,
              _aR_,
              _aQ_,
              _aP_,
              _aO_,
              _aN_);
    }
    function _aM_(x_016){
     return sexp_of_t$4(function(param){return _ae_;}, x_016);
    }
    return caml_call4(Base_Invariant[1], _af_, t, _aM_, _aL_);
   }
   function invariant$0(t){
    return invariant_with_jobs(function(param){return 0;}, t);
   }
   var
    T1 =
      [0,
       Event,
       Job_or_event,
       scheduler,
       is_wall_clock,
       handle_fired,
       most_recently_fired,
       set_most_recently_fired,
       fired_events,
       set_fired_events,
       events,
       am_advancing,
       set_am_advancing,
       advance_errors,
       set_advance_errors,
       id,
       Fields$0,
       sexp_of_t$4,
       timing_wheel_now,
       is_in_fired_events,
       invariant_with_jobs,
       invariant$0];
   function sexp_of_t$5(x_021){return caml_call2(T1[17], Core[171], x_021);}
   var invariant$1 = T1[21], invariant_with_jobs$0 = T1[20];
   function sexp_of_t$6(x_022){return caml_call2(T1[17], Core[202], x_022);}
   var Read_write = [0, sexp_of_t$6, invariant$1, invariant_with_jobs$0];
   function id$1(t){return t[1];}
   function is_wall_clock$1(t){return t[8];}
   function length(t){return caml_call1(Timing_wheel[14], t[4]);}
   function max_allowed_alarm_time(t){
    return caml_call1(Timing_wheel[22], t[4]);
   }
   function read_only(t){return t;}
   function fire(t, event){
    caml_call2(T1[1][20], event, 0);
    event[1] = caml_call1(Alarm[2], 0);
    var ppx_optional_e_0 = t[6];
    a:
    {
     if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
      var
       most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
      if(caml_call2(Time_ns[94], most_recently_fired[2], event[2])){
       var
        most_recently_fired$0 =
          caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
       event[7] = caml_call1(T1[1][3][3], most_recently_fired$0);
       event[6] = most_recently_fired$0[6];
       break a;
      }
     }
     event[7] = T1[1][3][2];
     event[6] = t[5];
    }
    t[6] = caml_call1(T1[1][3][3], event);
    for(;;){
     var ppx_optional_e_0$0 = event[6];
     if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
      var continue$0 = 0;
     else{
      var
       next$0 = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0),
       continue$1 = caml_call2(Time_ns[94], next$0[2], event[2]);
      if(continue$1){event[7] = event[6]; event[6] = next$0[6];}
      var continue$0 = continue$1;
     }
     if(! continue$0) break;
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = caml_call1(T1[1][3][3], event);
    }
    var ppx_optional_e_0$2 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$2)){t[5] = caml_call1(T1[1][3][3], event); return 0;}
    var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$2);
    prev[6] = caml_call1(T1[1][3][3], event);
    return 0;
   }
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function next_alarm_runs_at(t){
    return caml_call1(T1[1][3][5], t[5])
            ? [0, caml_call1(T1[18], t)]
            : caml_call1(Timing_wheel[38], t[4]);
   }
   function now$0(t){
    return t[8] ? caml_call1(Time_ns[50], 0) : caml_call1(T1[18], t);
   }
   var timing_wheel_now$0 = T1[18];
   function schedule(t, event){
    caml_call2(T1[1][20], event, 2);
    var _aK_ = caml_call1(T1[2][1], event);
    event[1] = caml_call3(Timing_wheel[25], t[4], event[2], _aK_);
    return 0;
   }
   function remove_from_fired(t, event, new_status){
    var ppx_optional_e_0 = t[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
     var
      most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
     if(caml_call2(Core[246], event, most_recently_fired))
      t[6] = caml_call2(T1[1][3][6], event[6], event[7]);
    }
    var ppx_optional_e_0$0 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
     t[5] = event[6];
    else{
     var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0);
     prev[6] = event[6];
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = event[7];
    }
    event[6] = T1[1][3][2];
    event[7] = T1[1][3][2];
    return caml_call2(T1[1][20], event, new_status);
   }
   var
    include$0 = T1[1],
    Status$0 = include$0[1],
    sexp_of_event$0 = include$0[2],
    Option$0 = include$0[3],
    status$1 = include$0[4],
    prev_fired$1 = include$0[5],
    set_prev_fired$0 = include$0[6],
    next_fired$1 = include$0[7],
    set_next_fired$0 = include$0[8],
    interval$1 = include$0[9],
    set_interval$0 = include$0[10],
    execution_context$1 = include$0[11],
    callback$1 = include$0[12],
    set_at$0 = include$0[14],
    alarm$1 = include$0[15],
    set_alarm$0 = include$0[16],
    Fields$1 = include$0[17],
    sexp_of_t$7 = include$0[18],
    invariant$2 = include$0[19],
    set_status$1 = include$0[20],
    set_status_if$0 = include$0[21],
    scheduled_at = include$0[22];
   function create_internal(t, at, interval, callback){
    var _aH_ = T1[1][3][2], _aI_ = T1[1][3][2], _aJ_ = t[9][7];
    return [0,
            caml_call1(Alarm[2], 0),
            at,
            callback,
            _aJ_,
            interval,
            _aI_,
            _aH_,
            3];
   }
   function add$0(t, event){
    var _aG_ = caml_call1(timing_wheel_now$0, t);
    return caml_call2(Time_ns[94], event[2], _aG_)
            ? fire(t, event)
            : schedule(t, event);
   }
   function create_and_add(t, at, interval, callback){
    var event = create_internal(t, at, interval, callback);
    add$0(t, event);
    return event;
   }
   function at$2(t, at, callback){return create_and_add(t, at, 0, callback);}
   function after$0(t, span, callback){
    var _aF_ = now$0(t);
    return create_and_add
            (t, caml_call2(Time_ns[112], _aF_, span), 0, callback);
   }
   function require_span_at_least_alarm_pr(t, span){
    var
     alarm_precision$0 = alarm_precision(t),
     _aB_ = caml_call2(Core_Time_ns[1][19], span, alarm_precision$0);
    if(! _aB_) return _aB_;
    var
     _aC_ =
       [0,
        [1,
         [0, _ag_, [0, caml_call1(Core_Time_ns[1][10], alarm_precision$0), 0]]],
        0],
     _aD_ =
       [0,
        [1, [0, _ah_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]],
        _aC_],
     _aE_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_interval_span_smaller_than),
         _aD_]];
    return caml_call1(Core[253], _aE_);
   }
   function at_intervals(t, span, callback){
    require_span_at_least_alarm_pr(t, span);
    return create_and_add(t, now$0(t), [0, span], callback);
   }
   function sexp_of_t$8(param){
    switch(param){
      case 0:
       return _ai_;
      case 1:
       return _aj_;
      default: return _ak_;
    }
   }
   var Abort_result = [0, sexp_of_t$8];
   function abort(t, event){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); return 0;
      case 1:
       return event[5] ? (event[5] = 0, 0) : 1;
      case 2:
       caml_call2(T1[1][20], event, 3);
       caml_call2(Timing_wheel[28], t[4], event[1]);
       event[1] = caml_call1(Alarm[2], 0);
       return 0;
      default: return 2;
    }
   }
   function abort_if_possible(t, event){abort(t, event); return 0;}
   function abort_exn(t, event){
    var reason = abort(t, event);
    if(! reason) return 0;
    var
     _az_ =
       [0, [1, [0, _al_, [0, caml_call1(Abort_result[1], reason), 0]]], 0],
     _aA_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_ab),
         _az_]];
    return caml_call1(Core[253], _aA_);
   }
   function create$1(t, callback){
    return create_internal(t, Time_ns[43], 0, callback);
   }
   function schedule_at_internal(t, event, at, interval){
    var status = event[8];
    if(3 <= status){
     event[2] = at;
     event[5] = interval;
     add$0(t, event);
     return _am_;
    }
    var
     _ax_ = [0, caml_call1(T1[1][1][3], status), 0],
     _ay_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_schedule_an_event_w),
         _ax_]];
    return caml_call1(Core_Or_error[40], _ay_);
   }
   function schedule_at(t, event, at){
    return schedule_at_internal(t, event, at, 0);
   }
   function schedule_after(t, event, span){
    var _aw_ = now$0(t);
    return schedule_at(t, event, caml_call2(Time_ns[112], _aw_, span));
   }
   function schedule_at_intervals(t, event, span){
    require_span_at_least_alarm_pr(t, span);
    return schedule_at_internal(t, event, now$0(t), [0, span]);
   }
   function reschedule_at(t, event, at){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); event[2] = at; return add$0(t, event);
      case 1:
       event[2] = at; return add$0(t, event);
      case 2:
       event[2] = at;
       var _av_ = caml_call1(timing_wheel_now$0, t);
       return caml_call2(Time_ns[96], at, _av_)
               ? caml_call3(Timing_wheel[29], t[4], event[1], at)
               : (caml_call2
                  (Timing_wheel[28], t[4], event[1]),
                 fire(t, event));
      default: event[2] = at; event[5] = 0; return add$0(t, event);
    }
   }
   function reschedule_after(t, event, span){
    var _au_ = now$0(t);
    return reschedule_at(t, event, caml_call2(Time_ns[112], _au_, span));
   }
   var
    Event$0 =
      [0,
       Status$0,
       sexp_of_event$0,
       Option$0,
       status$1,
       prev_fired$1,
       set_prev_fired$0,
       next_fired$1,
       set_next_fired$0,
       interval$1,
       set_interval$0,
       execution_context$1,
       callback$1,
       set_at$0,
       alarm$1,
       set_alarm$0,
       Fields$1,
       sexp_of_t$7,
       invariant$2,
       set_status$1,
       set_status_if$0,
       scheduled_at,
       create_internal,
       add$0,
       create_and_add,
       at$2,
       after$0,
       require_span_at_least_alarm_pr,
       at_intervals,
       Abort_result,
       abort,
       abort_if_possible,
       abort_exn,
       create$1,
       schedule_at_internal,
       schedule_at,
       schedule_after,
       schedule_at_intervals,
       reschedule_at,
       reschedule_after];
   function run_after(t, span, callback){
    caml_call3(Event$0[26], t, span, callback);
    return 0;
   }
   function run_at(t, at, callback){
    caml_call3(Event$0[25], t, at, callback);
    return 0;
   }
   function run_at_intervals(t, span, callback){
    caml_call3(Event$0[28], t, span, callback);
    return 0;
   }
   function run_fired_events(t, send_exn){
    var current_execution_context = t[9][7];
    for(;;){
     var ppx_optional_e_0 = t[5];
     if(caml_call1(Event$0[3][7][1][1], ppx_optional_e_0))
      var _ar_ = 0;
     else{
      var event = caml_call1(Event$0[3][7][1][2], ppx_optional_e_0);
      if(event[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
      remove_from_fired(t, event, 1);
      caml_call2(Async_kernel_Scheduler0[2], t[9], event[4]);
      a:
      {
       try{caml_call1(event[3], 0);}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(send_exn){
         var
          send_exn$0 = send_exn[1],
          backtrace = caml_call1(Base_Backtrace[6][4], 0);
         caml_call3
          (send_exn$0, event[4][1], [0, [0, 936718974, backtrace]], exn);
        }
        else{
         var _as_ = t[2];
         t[2] = [0, caml_call2(Core_Error[25], 0, exn), _as_];
        }
        caml_call3(Event$0[20], 1, event, 3);
        break a;
       }
       var match = event[5];
       if(match){
        var interval = match[1];
        if(caml_call2(Event$0[1][2], 1, event[8])){
         var _at_ = caml_call1(timing_wheel_now$0, t);
         event[2] = caml_call5(Time_ns[65], 0, event[2], _at_, interval, 0);
         schedule(t, event);
        }
       }
       else
        caml_call3(Event$0[20], 1, event, 3);
      }
      var _ar_ = 1;
     }
     if(! _ar_)
      return caml_call2
              (Async_kernel_Scheduler0[2], t[9], current_execution_context);
    }
   }
   function advance_clock(t, to, send_exn){
    caml_call3(Timing_wheel[20], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function fire_past_alarms(t, send_exn){
    caml_call2(Timing_wheel[21], t[4], t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_internal(t, to, send_exn){
    advance_clock(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function prepare_to_advance(t, send_exn){
    if(t[3]){
     var
      _aq_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_advance_by_ala);
     caml_call1(Core[253], _aq_);
    }
    t[3] = 1;
    if(t[2]) t[2] = 0;
    return run_fired_events(t, send_exn);
   }
   function finish_advancing(t){
    t[3] = 0;
    var errors = t[2];
    return errors
            ? (t[2] = 0, [1, caml_call2(Core_Error[24], 0, errors)])
            : _ao_;
   }
   function advance_by_alarms(t, to){
    prepare_to_advance(t, 0);
    var continue$0 = [0, 1], send_exn = 0;
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var min_alarm_time = caml_call1(Timing_wheel[37], t[4]);
      if(caml_call2(Time_ns[93], min_alarm_time, to))
       continue$0[1] = 0;
      else
       advance_internal(t, min_alarm_time, send_exn);
     }
    }
   }
   function advance_by_max_alarms_in_each_(t, to){
    prepare_to_advance(t, 0);
    var continue$0 = [0, 1], send_exn = 0;
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var next_alarm_fires_at = caml_call1(Timing_wheel[39], t[4]);
      if(caml_call2(Time_ns[93], next_alarm_fires_at, to))
       continue$0[1] = 0;
      else
       advance_internal(t, caml_call1(Timing_wheel[36], t[4]), send_exn);
     }
    }
   }
   function advance_directly(t, to){
    prepare_to_advance(t, 0);
    advance_internal(t, to, 0);
    return finish_advancing(t);
   }
   function duration_of(t, f){
    var
     start = now$0(t),
     result = caml_call1(f, 0),
     _ap_ = now$0(t),
     duration = caml_call2(Time_ns[57], _ap_, start);
    return [0, result, duration];
   }
   function max_alarm_time_in_min_timing_w(t){
    return caml_call1(Timing_wheel[34], t[4]);
   }
   function has_events_to_run(t){return caml_call1(Event$0[3][5], t[5]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    Async_kernel_Synchronous_time_ =
      [0,
       Time_ns,
       Alarm,
       default_timing_wheel_config,
       T1,
       sexp_of_t$5,
       invariant$1,
       invariant_with_jobs$0,
       Read_write,
       id$1,
       is_wall_clock$1,
       length,
       max_allowed_alarm_time,
       read_only,
       fire,
       alarm_precision,
       next_alarm_fires_at,
       next_alarm_runs_at,
       now$0,
       timing_wheel_now$0,
       schedule,
       remove_from_fired,
       Event$0,
       run_after,
       run_at,
       run_at_intervals,
       run_fired_events,
       advance_clock,
       fire_past_alarms,
       advance_internal,
       prepare_to_advance,
       finish_advancing,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       duration_of,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (102, Async_kernel_Synchronous_time_, cst_Async_kernel_Synchronous_t$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler1
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__External_job, Async_kernel__Import, Async_kernel__Job_pool, Async_kernel__Job_queue, Async_kernel__Scheduler0, Async_kernel__Synchronous_time_source0, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Exn, Base__Field, Base__Invariant, Core, Core__Deque, Core__Error, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Result, Core__Sexp, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue, Timing_wheel, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler1$0 = "Async_kernel__Scheduler1",
    cst_async_kernel$0 = "async_kernel",
    cst_check_access$0 = "check_access",
    cst_check_invariants$0 = "check_invariants",
    cst_current_execution_context$0 = "current_execution_context",
    cst_cycle_count$0 = "cycle_count",
    cst_cycle_start$0 = "cycle_start",
    cst_event_added_hook$0 = "event_added_hook",
    cst_exec$0 = "exec",
    cst_execution_context$0 = "execution_context",
    cst_external_jobs$0 = "external_jobs",
    cst_in_cycle$0 = "in_cycle",
    cst_job_pool$0 = "job_pool",
    cst_job_queued_hook$0 = "job_queued_hook",
    cst_last_cycle_num_jobs$0 = "last_cycle_num_jobs",
    cst_last_cycle_time$0 = "last_cycle_time",
    cst_low_priority_jobs$0 = "low_priority_jobs",
    cst_main_execution_context$0 = "main_execution_context",
    cst_max_num_jobs_per_priority_$0 = "max_num_jobs_per_priority_per_cycle",
    cst_normal_priority_jobs$0 = "normal_priority_jobs",
    cst_record_backtraces$0 = "record_backtraces",
    cst_run_every_cycle_end$0 = "run_every_cycle_end",
    cst_run_every_cycle_end_state$0 = "run_every_cycle_end_state",
    cst_run_every_cycle_start$0 = "run_every_cycle_start",
    cst_run_every_cycle_start_stat$0 = "run_every_cycle_start_state",
    cst_src_scheduler1_ml = "src/scheduler1.ml",
    cst_thread_safe_external_job_h$0 = "thread_safe_external_job_hook",
    cst_time_source$0 = "time_source",
    cst_total_cycle_time$0 = "total_cycle_time",
    cst_uncaught_exn$0 = "uncaught_exn",
    cst_very_low_priority_workers$0 = "very_low_priority_workers",
    cst_yield$0 = "yield",
    cst_yield_until_no_jobs_remain$0 = "yield_until_no_jobs_remain",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call28
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27){
    return (f.l >= 0 ? f.l : f.l = f.length) == 28
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26,
                a27]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names = [0, cst_execution_context$0, [0, cst_exec$0, 0]],
    names$0 =
      caml_list_of_js_array
       ([cst_check_access$0,
         cst_job_pool$0,
         cst_normal_priority_jobs$0,
         cst_low_priority_jobs$0,
         cst_very_low_priority_workers$0,
         cst_main_execution_context$0,
         cst_current_execution_context$0,
         cst_uncaught_exn$0,
         cst_cycle_count$0,
         cst_cycle_start$0,
         cst_in_cycle$0,
         cst_run_every_cycle_start$0,
         cst_run_every_cycle_start_stat$0,
         cst_run_every_cycle_end$0,
         cst_run_every_cycle_end_state$0,
         cst_last_cycle_time$0,
         cst_last_cycle_num_jobs$0,
         cst_total_cycle_time$0,
         cst_time_source$0,
         cst_external_jobs$0,
         cst_thread_safe_external_job_h$0,
         cst_job_queued_hook$0,
         cst_event_added_hook$0,
         cst_yield$0,
         cst_yield_until_no_jobs_remain$0,
         cst_check_invariants$0,
         cst_max_num_jobs_per_priority_$0,
         cst_record_backtraces$0]),
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Core_Int = global_data.Core__Int,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_List = global_data.Core__List,
    Tuple_pool = global_data.Tuple_pool,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_External_job = global_data.Async_kernel__External_job,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core_Result = global_data.Core__Result;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    events = Async_kernel_Scheduler0[1],
    set_execution_context = Async_kernel_Scheduler0[2],
    debug = Async_kernel_Debug[10],
    _aU_ = [0, 0],
    _aV_ = [0, 0],
    cst_got_uncaught_exn = "got_uncaught_exn",
    _aT_ = [0, cst_src_scheduler1_ml, 170, 40],
    _aS_ = [0, cst_src_scheduler1_ml, 171, 46],
    _aR_ = [0, cst_src_scheduler1_ml, 187, 43],
    _aQ_ = [0, cst_src_scheduler1_ml, 191, 14],
    _aO_ = [0, "t"],
    _aP_ = [0, "exn"],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _aN_ = [0, cst_src_scheduler1_ml, 153, 2],
    cst_unhandled_exception = "unhandled exception",
    _al_ = [0, cst_record_backtraces$0],
    _am_ = [0, cst_max_num_jobs_per_priority_$0],
    _an_ = [0, cst_check_invariants$0],
    _ao_ = [0, cst_yield_until_no_jobs_remain$0],
    _ap_ = [0, cst_yield$0],
    _aq_ = [0, cst_event_added_hook$0],
    _ar_ = [0, cst_job_queued_hook$0],
    _as_ = [0, cst_thread_safe_external_job_h$0],
    _at_ = [0, cst_external_jobs$0],
    _au_ = [0, cst_time_source$0],
    _av_ = [0, cst_total_cycle_time$0],
    _aw_ = [0, cst_last_cycle_num_jobs$0],
    _ax_ = [0, cst_last_cycle_time$0],
    _ay_ = [0, cst_run_every_cycle_end_state$0],
    _az_ = [0, cst_run_every_cycle_end$0],
    _aA_ = [0, cst_run_every_cycle_start_stat$0],
    _aB_ = [0, cst_run_every_cycle_start$0],
    _aC_ = [0, cst_in_cycle$0],
    _aD_ = [0, cst_cycle_start$0],
    _aE_ = [0, cst_cycle_count$0],
    _aF_ = [0, cst_uncaught_exn$0],
    _aG_ = [0, cst_current_execution_context$0],
    _aH_ = [0, cst_main_execution_context$0],
    _aI_ = [0, cst_very_low_priority_workers$0],
    _aJ_ = [0, cst_low_priority_jobs$0],
    _aK_ = [0, cst_normal_priority_jobs$0],
    _aL_ = [0, cst_job_pool$0],
    _aM_ = [0, cst_check_access$0],
    _i_ = [0, cst_src_scheduler1_ml, 51, 1645, 1669],
    _g_ = [0, cst_exec$0],
    _h_ = [0, cst_execution_context$0],
    _a_ = [0, "Not_finished"],
    _b_ = [0, "Finished"],
    cst_exec = cst_exec$0,
    cst_execution_context = cst_execution_context$0,
    cst_record_backtraces = cst_record_backtraces$0,
    cst_max_num_jobs_per_priority_ = cst_max_num_jobs_per_priority_$0,
    cst_check_invariants = cst_check_invariants$0,
    cst_yield_until_no_jobs_remain = cst_yield_until_no_jobs_remain$0,
    cst_yield = cst_yield$0,
    cst_event_added_hook = cst_event_added_hook$0,
    cst_job_queued_hook = cst_job_queued_hook$0,
    cst_thread_safe_external_job_h = cst_thread_safe_external_job_h$0,
    cst_external_jobs = cst_external_jobs$0,
    cst_time_source = cst_time_source$0,
    cst_total_cycle_time = cst_total_cycle_time$0,
    cst_last_cycle_num_jobs = cst_last_cycle_num_jobs$0,
    cst_last_cycle_time = cst_last_cycle_time$0,
    cst_run_every_cycle_end_state = cst_run_every_cycle_end_state$0,
    cst_run_every_cycle_end = cst_run_every_cycle_end$0,
    cst_run_every_cycle_start_stat = cst_run_every_cycle_start_stat$0,
    cst_run_every_cycle_start = cst_run_every_cycle_start$0,
    cst_in_cycle = cst_in_cycle$0,
    cst_cycle_start = cst_cycle_start$0,
    cst_cycle_count = cst_cycle_count$0,
    cst_uncaught_exn = cst_uncaught_exn$0,
    cst_current_execution_context = cst_current_execution_context$0,
    cst_main_execution_context = cst_main_execution_context$0,
    cst_very_low_priority_workers = cst_very_low_priority_workers$0,
    cst_low_priority_jobs = cst_low_priority_jobs$0,
    cst_normal_priority_jobs = cst_normal_priority_jobs$0,
    cst_job_pool = cst_job_pool$0,
    cst_check_access = cst_check_access$0,
    cst_Async_cannot_create_its_ra = "Async cannot create its raw scheduler",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler1 = cst_Async_kernel_Scheduler1$0;
   function create_with_cell(cell){return [0, cell];}
   function create(param){return [0, 0];}
   function create_full(a){return [0, [2, a]];}
   var Ivar = [0, create_with_cell, create, create_full];
   function create$0(param){
    var _ht_ = [0, 0, caml_call1(Ivar[2], 0)];
    return caml_call1(Async_kernel_Types[10][1], _ht_);
   }
   var Bvar = [0, create$0];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   var Exec_result = [0, sexp_of_t];
   function exec(r){return r[2];}
   function execution_context(r){return r[1];}
   function _c_(r, v){return [0, r[1], v];}
   var
    _d_ = 0,
    exec$0 = [0, function(param){return 0;}, cst_exec, _d_, exec, _c_];
   function _e_(r, v){return [0, v, r[2]];}
   var
    _f_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _f_,
       execution_context,
       _e_];
   function make_creator(execution_context_fun, exec_fun, compile_acc){
    var
     match =
       caml_call2(execution_context_fun, execution_context$0, compile_acc),
     compile_acc$0 = match[2],
     execution_context_gen = match[1],
     match$0 = caml_call2(exec_fun, exec$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     exec_gen = match$0[1];
    return [0,
            function(acc){
             var
              execution_context = caml_call1(execution_context_gen, acc),
              exec = caml_call1(exec_gen, acc);
             return [0, execution_context, exec];
            },
            compile_acc$1];
   }
   function create$1(execution_context, exec){return [0, execution_context, exec];
   }
   function map(execution_context_fun, exec_fun){
    var _hs_ = caml_call1(exec_fun, exec$0);
    return [0, caml_call1(execution_context_fun, execution_context$0), _hs_];
   }
   function iter(execution_context_fun, exec_fun){
    caml_call1(execution_context_fun, execution_context$0);
    return caml_call1(exec_fun, exec$0);
   }
   function fold(init, execution_context_fun, exec_fun){
    return caml_call2
            (exec_fun,
             caml_call2(execution_context_fun, init, execution_context$0),
             exec$0);
   }
   function map_poly(record){
    var _hr_ = [0, caml_call1(record[1], exec$0), 0];
    return [0, caml_call1(record[1], execution_context$0), _hr_];
   }
   function for_all(execution_context_fun, exec_fun){
    var _hq_ = caml_call1(execution_context_fun, execution_context$0);
    return _hq_ ? caml_call1(exec_fun, exec$0) : _hq_;
   }
   function exists(execution_context_fun, exec_fun){
    var _hp_ = caml_call1(execution_context_fun, execution_context$0);
    return _hp_ ? _hp_ : caml_call1(exec_fun, exec$0);
   }
   function to_list(execution_context_fun, exec_fun){
    var _ho_ = [0, caml_call1(exec_fun, exec$0), 0];
    return [0, caml_call1(execution_context_fun, execution_context$0), _ho_];
   }
   function iter$0(record, execution_context_fun, exec_fun){
    caml_call3(execution_context_fun, execution_context$0, record, record[1]);
    return caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function fold$0(record, init, execution_context_fun, exec_fun){
    var _hn_ = record[2];
    return caml_call4
            (exec_fun,
             caml_call4
              (execution_context_fun,
               init,
               execution_context$0,
               record,
               record[1]),
             exec$0,
             record,
             _hn_);
   }
   function for_all$0(record, execution_context_fun, exec_fun){
    var
     _hm_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _hm_ ? caml_call3(exec_fun, exec$0, record, record[2]) : _hm_;
   }
   function exists$0(record, execution_context_fun, exec_fun){
    var
     _hl_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _hl_ ? _hl_ : caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function to_list$0(record, execution_context_fun, exec_fun){
    var _hk_ = [0, caml_call3(exec_fun, exec$0, record, record[2]), 0];
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _hk_];
   }
   function map$0(record, execution_context_fun, exec_fun){
    var _hj_ = caml_call3(exec_fun, exec$0, record, record[2]);
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _hj_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       exec$0,
       execution_context$0,
       make_creator,
       create$1,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function sexp_of_t$0(param){
    var execution_context_002 = param[1], bnds_001 = 0;
    function _hh_(_hi_){return 0;}
    var
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], _hh_),
     bnds_001$0 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_001],
     arg_003 =
       caml_call1(Async_kernel_Execution_context[6], execution_context_002),
     bnds_001$1 = [0, [1, [0, _h_, [0, arg_003, 0]]], bnds_001$0];
    return [1, bnds_001$1];
   }
   function invariant(t){
    function _hd_(param){
     function _hf_(_hg_){return 0;}
     var
      f = Async_kernel_Execution_context[7],
      _he_ = caml_call2(Base_Invariant[2], t, f);
     return caml_call2(Fields[7], _he_, _hf_);
    }
    return caml_call4(Base_Invariant[1], _i_, t, sexp_of_t$0, _hd_);
   }
   var
    Very_low_priority_worker =
      [0,
       Exec_result,
       exec,
       execution_context,
       Fields,
       sexp_of_t$0,
       invariant];
   function record_backtraces(r){return r[28];}
   function set_record_backtraces(r, v){r[28] = v; return 0;}
   function max_num_jobs_per_priority_per_(r){return r[27];}
   function set_max_num_jobs_per_priority_(r, v){r[27] = v; return 0;}
   function check_invariants(r){return r[26];}
   function set_check_invariants(r, v){r[26] = v; return 0;}
   function yield_until_no_jobs_remain(r){return r[25];}
   function set_yield_until_no_jobs_remain(r, v){r[25] = v; return 0;}
   function yield$0(r){return r[24];}
   function set_yield(r, v){r[24] = v; return 0;}
   function event_added_hook(r){return r[23];}
   function set_event_added_hook(r, v){r[23] = v; return 0;}
   function job_queued_hook(r){return r[22];}
   function set_job_queued_hook(r, v){r[22] = v; return 0;}
   function thread_safe_external_job_hook(r){return r[21];}
   function set_thread_safe_external_job_h(r, v){r[21] = v; return 0;}
   function external_jobs(r){return r[20];}
   function time_source(r){return r[19];}
   function set_time_source(r, v){r[19] = v; return 0;}
   function total_cycle_time(r){return r[18];}
   function set_total_cycle_time(r, v){r[18] = v; return 0;}
   function last_cycle_num_jobs(r){return r[17];}
   function set_last_cycle_num_jobs(r, v){r[17] = v; return 0;}
   function last_cycle_time(r){return r[16];}
   function set_last_cycle_time(r, v){r[16] = v; return 0;}
   function run_every_cycle_end_state(r){return r[15];}
   function run_every_cycle_end(r){return r[14];}
   function set_run_every_cycle_end(r, v){r[14] = v; return 0;}
   function run_every_cycle_start_state(r){return r[13];}
   function run_every_cycle_start(r){return r[12];}
   function set_run_every_cycle_start(r, v){r[12] = v; return 0;}
   function in_cycle(r){return r[11];}
   function set_in_cycle(r, v){r[11] = v; return 0;}
   function cycle_start(r){return r[10];}
   function set_cycle_start(r, v){r[10] = v; return 0;}
   function cycle_count(r){return r[9];}
   function set_cycle_count(r, v){r[9] = v; return 0;}
   function uncaught_exn_unwrapped(r){return r[8];}
   function set_uncaught_exn(r, v){r[8] = v; return 0;}
   function current_execution_context(r){return r[7];}
   function set_current_execution_context(r, v){r[7] = v; return 0;}
   function main_execution_context(r){return r[6];}
   function set_main_execution_context(r, v){r[6] = v; return 0;}
   function very_low_priority_workers(r){return r[5];}
   function low_priority_jobs(r){return r[4];}
   function normal_priority_jobs(r){return r[3];}
   function job_pool(r){return r[2];}
   function set_job_pool(r, v){r[2] = v; return 0;}
   function check_access(r){return r[1];}
   function set_check_access(r, v){r[1] = v; return 0;}
   function _j_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            v];
   }
   var
    _k_ = [0, set_record_backtraces],
    record_backtraces$0 =
      [0,
       function(param){return 0;},
       cst_record_backtraces,
       _k_,
       record_backtraces,
       _j_];
   function _l_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v,
            r[28]];
   }
   var
    _m_ = [0, set_max_num_jobs_per_priority_],
    max_num_jobs_per_priority_per_$0 =
      [0,
       function(param){return 0;},
       cst_max_num_jobs_per_priority_,
       _m_,
       max_num_jobs_per_priority_per_,
       _l_];
   function _n_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v,
            r[27],
            r[28]];
   }
   var
    _o_ = [0, set_check_invariants],
    check_invariants$0 =
      [0,
       function(param){return 0;},
       cst_check_invariants,
       _o_,
       check_invariants,
       _n_];
   function _p_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27],
            r[28]];
   }
   var
    _q_ = [0, set_yield_until_no_jobs_remain],
    yield_until_no_jobs_remain$0 =
      [0,
       function(param){return 0;},
       cst_yield_until_no_jobs_remain,
       _q_,
       yield_until_no_jobs_remain,
       _p_];
   function _r_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _s_ = [0, set_yield],
    yield$1 = [0, function(param){return 0;}, cst_yield, _s_, yield$0, _r_];
   function _t_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _u_ = [0, set_event_added_hook],
    event_added_hook$0 =
      [0,
       function(param){return 0;},
       cst_event_added_hook,
       _u_,
       event_added_hook,
       _t_];
   function _v_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _w_ = [0, set_job_queued_hook],
    job_queued_hook$0 =
      [0,
       function(param){return 0;},
       cst_job_queued_hook,
       _w_,
       job_queued_hook,
       _v_];
   function _x_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _y_ = [0, set_thread_safe_external_job_h],
    thread_safe_external_job_hook$0 =
      [0,
       function(param){return 0;},
       cst_thread_safe_external_job_h,
       _y_,
       thread_safe_external_job_hook,
       _x_];
   function _z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _A_ = 0,
    external_jobs$0 =
      [0,
       function(param){return 0;},
       cst_external_jobs,
       _A_,
       external_jobs,
       _z_];
   function _B_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _C_ = [0, set_time_source],
    time_source$0 =
      [0, function(param){return 0;}, cst_time_source, _C_, time_source, _B_];
   function _D_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _E_ = [0, set_total_cycle_time],
    total_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_total_cycle_time,
       _E_,
       total_cycle_time,
       _D_];
   function _F_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _G_ = [0, set_last_cycle_num_jobs],
    last_cycle_num_jobs$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_num_jobs,
       _G_,
       last_cycle_num_jobs,
       _F_];
   function _H_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _I_ = [0, set_last_cycle_time],
    last_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_time,
       _I_,
       last_cycle_time,
       _H_];
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _K_ = 0,
    run_every_cycle_end_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end_state,
       _K_,
       run_every_cycle_end_state,
       _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _M_ = [0, set_run_every_cycle_end],
    run_every_cycle_end$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end,
       _M_,
       run_every_cycle_end,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _O_ = 0,
    run_every_cycle_start_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start_stat,
       _O_,
       run_every_cycle_start_state,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Q_ = [0, set_run_every_cycle_start],
    run_every_cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start,
       _Q_,
       run_every_cycle_start,
       _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _S_ = [0, set_in_cycle],
    in_cycle$0 =
      [0, function(param){return 0;}, cst_in_cycle, _S_, in_cycle, _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _U_ = [0, set_cycle_start],
    cycle_start$0 =
      [0, function(param){return 0;}, cst_cycle_start, _U_, cycle_start, _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _W_ = [0, set_cycle_count],
    cycle_count$0 =
      [0, function(param){return 0;}, cst_cycle_count, _W_, cycle_count, _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Y_ = [0, set_uncaught_exn],
    uncaught_exn =
      [0,
       function(param){return 0;},
       cst_uncaught_exn,
       _Y_,
       uncaught_exn_unwrapped,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    ___ = [0, set_current_execution_context],
    current_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_current_execution_context,
       ___,
       current_execution_context,
       _Z_];
   function _$_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _aa_ = [0, set_main_execution_context],
    main_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_main_execution_context,
       _aa_,
       main_execution_context,
       _$_];
   function _ab_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ac_ = 0,
    very_low_priority_workers$0 =
      [0,
       function(param){return 0;},
       cst_very_low_priority_workers,
       _ac_,
       very_low_priority_workers,
       _ab_];
   function _ad_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ae_ = 0,
    low_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_low_priority_jobs,
       _ae_,
       low_priority_jobs,
       _ad_];
   function _af_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ag_ = 0,
    normal_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_normal_priority_jobs,
       _ag_,
       normal_priority_jobs,
       _af_];
   function _ah_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ai_ = [0, set_job_pool],
    job_pool$0 =
      [0, function(param){return 0;}, cst_job_pool, _ai_, job_pool, _ah_];
   function _aj_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ak_ = [0, set_check_access],
    check_access$0 =
      [0,
       function(param){return 0;},
       cst_check_access,
       _ak_,
       check_access,
       _aj_];
   function make_creator$0
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun,
    compile_acc){
    var
     match = caml_call2(check_access_fun, check_access$0, compile_acc),
     compile_acc$0 = match[2],
     check_access_gen = match[1],
     match$0 = caml_call2(job_pool_fun, job_pool$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     job_pool_gen = match$0[1],
     match$1 =
       caml_call2
        (normal_priority_jobs_fun, normal_priority_jobs$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     normal_priority_jobs_gen = match$1[1],
     match$2 =
       caml_call2(low_priority_jobs_fun, low_priority_jobs$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     low_priority_jobs_gen = match$2[1],
     match$3 =
       caml_call2
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     very_low_priority_workers_gen = match$3[1],
     match$4 =
       caml_call2
        (main_execution_context_fun, main_execution_context$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     main_execution_context_gen = match$4[1],
     match$5 =
       caml_call2
        (current_execution_context_fun,
         current_execution_context$0,
         compile_acc$5),
     compile_acc$6 = match$5[2],
     current_execution_context_gen = match$5[1],
     match$6 = caml_call2(uncaught_exn_fun, uncaught_exn, compile_acc$6),
     compile_acc$7 = match$6[2],
     uncaught_exn_gen = match$6[1],
     match$7 = caml_call2(cycle_count_fun, cycle_count$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     cycle_count_gen = match$7[1],
     match$8 = caml_call2(cycle_start_fun, cycle_start$0, compile_acc$8),
     compile_acc$9 = match$8[2],
     cycle_start_gen = match$8[1],
     match$9 = caml_call2(in_cycle_fun, in_cycle$0, compile_acc$9),
     compile_acc$10 = match$9[2],
     in_cycle_gen = match$9[1],
     match$10 =
       caml_call2
        (run_every_cycle_start_fun, run_every_cycle_start$0, compile_acc$10),
     compile_acc$11 = match$10[2],
     run_every_cycle_start_gen = match$10[1],
     match$11 =
       caml_call2
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         compile_acc$11),
     compile_acc$12 = match$11[2],
     run_every_cycle_start_state_ge = match$11[1],
     match$12 =
       caml_call2
        (run_every_cycle_end_fun, run_every_cycle_end$0, compile_acc$12),
     compile_acc$13 = match$12[2],
     run_every_cycle_end_gen = match$12[1],
     match$13 =
       caml_call2
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         compile_acc$13),
     compile_acc$14 = match$13[2],
     run_every_cycle_end_state_gen = match$13[1],
     match$14 =
       caml_call2(last_cycle_time_fun, last_cycle_time$0, compile_acc$14),
     compile_acc$15 = match$14[2],
     last_cycle_time_gen = match$14[1],
     match$15 =
       caml_call2
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, compile_acc$15),
     compile_acc$16 = match$15[2],
     last_cycle_num_jobs_gen = match$15[1],
     match$16 =
       caml_call2(total_cycle_time_fun, total_cycle_time$0, compile_acc$16),
     compile_acc$17 = match$16[2],
     total_cycle_time_gen = match$16[1],
     match$17 = caml_call2(time_source_fun, time_source$0, compile_acc$17),
     compile_acc$18 = match$17[2],
     time_source_gen = match$17[1],
     match$18 = caml_call2(external_jobs_fun, external_jobs$0, compile_acc$18),
     compile_acc$19 = match$18[2],
     external_jobs_gen = match$18[1],
     match$19 =
       caml_call2
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         compile_acc$19),
     compile_acc$20 = match$19[2],
     thread_safe_external_job_hook_$0 = match$19[1],
     match$20 =
       caml_call2(job_queued_hook_fun, job_queued_hook$0, compile_acc$20),
     compile_acc$21 = match$20[2],
     job_queued_hook_gen = match$20[1],
     match$21 =
       caml_call2(event_added_hook_fun, event_added_hook$0, compile_acc$21),
     compile_acc$22 = match$21[2],
     event_added_hook_gen = match$21[1],
     match$22 = caml_call2(yield_fun, yield$1, compile_acc$22),
     compile_acc$23 = match$22[2],
     yield_gen = match$22[1],
     match$23 =
       caml_call2
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         compile_acc$23),
     compile_acc$24 = match$23[2],
     yield_until_no_jobs_remain_gen = match$23[1],
     match$24 =
       caml_call2(check_invariants_fun, check_invariants$0, compile_acc$24),
     compile_acc$25 = match$24[2],
     check_invariants_gen = match$24[1],
     match$25 =
       caml_call2
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         compile_acc$25),
     compile_acc$26 = match$25[2],
     max_num_jobs_per_priority_per_$1 = match$25[1],
     match$26 =
       caml_call2(record_backtraces_fun, record_backtraces$0, compile_acc$26),
     compile_acc$27 = match$26[2],
     record_backtraces_gen = match$26[1];
    return [0,
            function(acc){
             var
              check_access = caml_call1(check_access_gen, acc),
              job_pool = caml_call1(job_pool_gen, acc),
              normal_priority_jobs = caml_call1(normal_priority_jobs_gen, acc),
              low_priority_jobs = caml_call1(low_priority_jobs_gen, acc),
              very_low_priority_workers =
                caml_call1(very_low_priority_workers_gen, acc),
              main_execution_context =
                caml_call1(main_execution_context_gen, acc),
              current_execution_context =
                caml_call1(current_execution_context_gen, acc),
              uncaught_exn = caml_call1(uncaught_exn_gen, acc),
              cycle_count = caml_call1(cycle_count_gen, acc),
              cycle_start = caml_call1(cycle_start_gen, acc),
              in_cycle = caml_call1(in_cycle_gen, acc),
              run_every_cycle_start =
                caml_call1(run_every_cycle_start_gen, acc),
              run_every_cycle_start_state =
                caml_call1(run_every_cycle_start_state_ge, acc),
              run_every_cycle_end = caml_call1(run_every_cycle_end_gen, acc),
              run_every_cycle_end_state =
                caml_call1(run_every_cycle_end_state_gen, acc),
              last_cycle_time = caml_call1(last_cycle_time_gen, acc),
              last_cycle_num_jobs = caml_call1(last_cycle_num_jobs_gen, acc),
              total_cycle_time = caml_call1(total_cycle_time_gen, acc),
              time_source = caml_call1(time_source_gen, acc),
              external_jobs = caml_call1(external_jobs_gen, acc),
              thread_safe_external_job_hook =
                caml_call1(thread_safe_external_job_hook_$0, acc),
              job_queued_hook = caml_call1(job_queued_hook_gen, acc),
              event_added_hook = caml_call1(event_added_hook_gen, acc),
              yield$0 = caml_call1(yield_gen, acc),
              yield_until_no_jobs_remain =
                caml_call1(yield_until_no_jobs_remain_gen, acc),
              check_invariants = caml_call1(check_invariants_gen, acc),
              max_num_jobs_per_priority_per_ =
                caml_call1(max_num_jobs_per_priority_per_$1, acc),
              record_backtraces = caml_call1(record_backtraces_gen, acc);
             return [0,
                     check_access,
                     job_pool,
                     normal_priority_jobs,
                     low_priority_jobs,
                     very_low_priority_workers,
                     main_execution_context,
                     current_execution_context,
                     uncaught_exn,
                     cycle_count,
                     cycle_start,
                     in_cycle,
                     run_every_cycle_start,
                     run_every_cycle_start_state,
                     run_every_cycle_end,
                     run_every_cycle_end_state,
                     last_cycle_time,
                     last_cycle_num_jobs,
                     total_cycle_time,
                     time_source,
                     external_jobs,
                     thread_safe_external_job_hook,
                     job_queued_hook,
                     event_added_hook,
                     yield$0,
                     yield_until_no_jobs_remain,
                     check_invariants,
                     max_num_jobs_per_priority_per_,
                     record_backtraces];
            },
            compile_acc$27];
   }
   function create$2
   (check_access,
    job_pool,
    normal_priority_jobs,
    low_priority_jobs,
    very_low_priority_workers,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_start_state,
    run_every_cycle_end,
    run_every_cycle_end_state,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    external_jobs,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    return [0,
            check_access,
            job_pool,
            normal_priority_jobs,
            low_priority_jobs,
            very_low_priority_workers,
            main_execution_context,
            current_execution_context,
            uncaught_exn,
            cycle_count,
            cycle_start,
            in_cycle,
            run_every_cycle_start,
            run_every_cycle_start_state,
            run_every_cycle_end,
            run_every_cycle_end_state,
            last_cycle_time,
            last_cycle_num_jobs,
            total_cycle_time,
            time_source,
            external_jobs,
            thread_safe_external_job_hook,
            job_queued_hook,
            event_added_hook,
            yield$0,
            yield_until_no_jobs_remain,
            check_invariants,
            max_num_jobs_per_priority_per_,
            record_backtraces];
   }
   function map$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _gO_ = caml_call1(record_backtraces_fun, record_backtraces$0),
     _gP_ =
       caml_call1
        (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
     _gQ_ = caml_call1(check_invariants_fun, check_invariants$0),
     _gR_ =
       caml_call1
        (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _gS_ = caml_call1(yield_fun, yield$1),
     _gT_ = caml_call1(event_added_hook_fun, event_added_hook$0),
     _gU_ = caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _gV_ =
       caml_call1
        (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _gW_ = caml_call1(external_jobs_fun, external_jobs$0),
     _gX_ = caml_call1(time_source_fun, time_source$0),
     _gY_ = caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _gZ_ = caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _g0_ = caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _g1_ =
       caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _g2_ = caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _g3_ =
       caml_call1
        (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _g4_ = caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _g5_ = caml_call1(in_cycle_fun, in_cycle$0),
     _g6_ = caml_call1(cycle_start_fun, cycle_start$0),
     _g7_ = caml_call1(cycle_count_fun, cycle_count$0),
     _g8_ = caml_call1(uncaught_exn_fun, uncaught_exn),
     _g9_ =
       caml_call1(current_execution_context_fun, current_execution_context$0),
     _g__ = caml_call1(main_execution_context_fun, main_execution_context$0),
     _g$_ =
       caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _ha_ = caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _hb_ = caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _hc_ = caml_call1(job_pool_fun, job_pool$0);
    return [0,
            caml_call1(check_access_fun, check_access$0),
            _hc_,
            _hb_,
            _ha_,
            _g$_,
            _g__,
            _g9_,
            _g8_,
            _g7_,
            _g6_,
            _g5_,
            _g4_,
            _g3_,
            _g2_,
            _g1_,
            _g0_,
            _gZ_,
            _gY_,
            _gX_,
            _gW_,
            _gV_,
            _gU_,
            _gT_,
            _gS_,
            _gR_,
            _gQ_,
            _gP_,
            _gO_];
   }
   function iter$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call1(check_access_fun, check_access$0);
    caml_call1(job_pool_fun, job_pool$0);
    caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0);
    caml_call1(low_priority_jobs_fun, low_priority_jobs$0);
    caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0);
    caml_call1(main_execution_context_fun, main_execution_context$0);
    caml_call1(current_execution_context_fun, current_execution_context$0);
    caml_call1(uncaught_exn_fun, uncaught_exn);
    caml_call1(cycle_count_fun, cycle_count$0);
    caml_call1(cycle_start_fun, cycle_start$0);
    caml_call1(in_cycle_fun, in_cycle$0);
    caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0);
    caml_call1(run_every_cycle_start_state_fu, run_every_cycle_start_state$0);
    caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0);
    caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0);
    caml_call1(last_cycle_time_fun, last_cycle_time$0);
    caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0);
    caml_call1(total_cycle_time_fun, total_cycle_time$0);
    caml_call1(time_source_fun, time_source$0);
    caml_call1(external_jobs_fun, external_jobs$0);
    caml_call1
     (thread_safe_external_job_hook_, thread_safe_external_job_hook$0);
    caml_call1(job_queued_hook_fun, job_queued_hook$0);
    caml_call1(event_added_hook_fun, event_added_hook$0);
    caml_call1(yield_fun, yield$1);
    caml_call1(yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0);
    caml_call1(check_invariants_fun, check_invariants$0);
    caml_call1
     (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function fold$1
   (init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    return caml_call2
            (record_backtraces_fun,
             caml_call2
              (max_num_jobs_per_priority_per_,
               caml_call2
                (check_invariants_fun,
                 caml_call2
                  (yield_until_no_jobs_remain_fun,
                   caml_call2
                    (yield_fun,
                     caml_call2
                      (event_added_hook_fun,
                       caml_call2
                        (job_queued_hook_fun,
                         caml_call2
                          (thread_safe_external_job_hook_,
                           caml_call2
                            (external_jobs_fun,
                             caml_call2
                              (time_source_fun,
                               caml_call2
                                (total_cycle_time_fun,
                                 caml_call2
                                  (last_cycle_num_jobs_fun,
                                   caml_call2
                                    (last_cycle_time_fun,
                                     caml_call2
                                      (run_every_cycle_end_state_fun,
                                       caml_call2
                                        (run_every_cycle_end_fun,
                                         caml_call2
                                          (run_every_cycle_start_state_fu,
                                           caml_call2
                                            (run_every_cycle_start_fun,
                                             caml_call2
                                              (in_cycle_fun,
                                               caml_call2
                                                (cycle_start_fun,
                                                 caml_call2
                                                  (cycle_count_fun,
                                                   caml_call2
                                                    (uncaught_exn_fun,
                                                     caml_call2
                                                      (current_execution_context_fun,
                                                       caml_call2
                                                        (main_execution_context_fun,
                                                         caml_call2
                                                          (very_low_priority_workers_fun,
                                                           caml_call2
                                                            (low_priority_jobs_fun,
                                                             caml_call2
                                                              (normal_priority_jobs_fun,
                                                               caml_call2
                                                                (job_pool_fun,
                                                                 caml_call2(check_access_fun, init, check_access$0),
                                                                 job_pool$0),
                                                               normal_priority_jobs$0),
                                                             low_priority_jobs$0),
                                                           very_low_priority_workers$0),
                                                         main_execution_context$0),
                                                       current_execution_context$0),
                                                     uncaught_exn),
                                                   cycle_count$0),
                                                 cycle_start$0),
                                               in_cycle$0),
                                             run_every_cycle_start$0),
                                           run_every_cycle_start_state$0),
                                         run_every_cycle_end$0),
                                       run_every_cycle_end_state$0),
                                     last_cycle_time$0),
                                   last_cycle_num_jobs$0),
                                 total_cycle_time$0),
                               time_source$0),
                             external_jobs$0),
                           thread_safe_external_job_hook$0),
                         job_queued_hook$0),
                       event_added_hook$0),
                     yield$1),
                   yield_until_no_jobs_remain$0),
                 check_invariants$0),
               max_num_jobs_per_priority_per_$0),
             record_backtraces$0);
   }
   function map_poly$0(record){
    var
     _gn_ = [0, caml_call1(record[1], record_backtraces$0), 0],
     _go_ = [0, caml_call1(record[1], max_num_jobs_per_priority_per_$0), _gn_],
     _gp_ = [0, caml_call1(record[1], check_invariants$0), _go_],
     _gq_ = [0, caml_call1(record[1], yield_until_no_jobs_remain$0), _gp_],
     _gr_ = [0, caml_call1(record[1], yield$1), _gq_],
     _gs_ = [0, caml_call1(record[1], event_added_hook$0), _gr_],
     _gt_ = [0, caml_call1(record[1], job_queued_hook$0), _gs_],
     _gu_ = [0, caml_call1(record[1], thread_safe_external_job_hook$0), _gt_],
     _gv_ = [0, caml_call1(record[1], external_jobs$0), _gu_],
     _gw_ = [0, caml_call1(record[1], time_source$0), _gv_],
     _gx_ = [0, caml_call1(record[1], total_cycle_time$0), _gw_],
     _gy_ = [0, caml_call1(record[1], last_cycle_num_jobs$0), _gx_],
     _gz_ = [0, caml_call1(record[1], last_cycle_time$0), _gy_],
     _gA_ = [0, caml_call1(record[1], run_every_cycle_end_state$0), _gz_],
     _gB_ = [0, caml_call1(record[1], run_every_cycle_end$0), _gA_],
     _gC_ = [0, caml_call1(record[1], run_every_cycle_start_state$0), _gB_],
     _gD_ = [0, caml_call1(record[1], run_every_cycle_start$0), _gC_],
     _gE_ = [0, caml_call1(record[1], in_cycle$0), _gD_],
     _gF_ = [0, caml_call1(record[1], cycle_start$0), _gE_],
     _gG_ = [0, caml_call1(record[1], cycle_count$0), _gF_],
     _gH_ = [0, caml_call1(record[1], uncaught_exn), _gG_],
     _gI_ = [0, caml_call1(record[1], current_execution_context$0), _gH_],
     _gJ_ = [0, caml_call1(record[1], main_execution_context$0), _gI_],
     _gK_ = [0, caml_call1(record[1], very_low_priority_workers$0), _gJ_],
     _gL_ = [0, caml_call1(record[1], low_priority_jobs$0), _gK_],
     _gM_ = [0, caml_call1(record[1], normal_priority_jobs$0), _gL_],
     _gN_ = [0, caml_call1(record[1], job_pool$0), _gM_];
    return [0, caml_call1(record[1], check_access$0), _gN_];
   }
   function for_all$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _fY_ = caml_call1(check_access_fun, check_access$0),
     _fZ_ = _fY_ ? caml_call1(job_pool_fun, job_pool$0) : _fY_,
     _f0_ =
       _fZ_
        ? caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0)
        : _fZ_,
     _f1_ =
       _f0_ ? caml_call1(low_priority_jobs_fun, low_priority_jobs$0) : _f0_,
     _f2_ =
       _f1_
        ? caml_call1
          (very_low_priority_workers_fun, very_low_priority_workers$0)
        : _f1_,
     _f3_ =
       _f2_
        ? caml_call1(main_execution_context_fun, main_execution_context$0)
        : _f2_,
     _f4_ =
       _f3_
        ? caml_call1
          (current_execution_context_fun, current_execution_context$0)
        : _f3_,
     _f5_ = _f4_ ? caml_call1(uncaught_exn_fun, uncaught_exn) : _f4_,
     _f6_ = _f5_ ? caml_call1(cycle_count_fun, cycle_count$0) : _f5_,
     _f7_ = _f6_ ? caml_call1(cycle_start_fun, cycle_start$0) : _f6_,
     _f8_ = _f7_ ? caml_call1(in_cycle_fun, in_cycle$0) : _f7_,
     _f9_ =
       _f8_
        ? caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0)
        : _f8_,
     _f__ =
       _f9_
        ? caml_call1
          (run_every_cycle_start_state_fu, run_every_cycle_start_state$0)
        : _f9_,
     _f$_ =
       _f__
        ? caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0)
        : _f__,
     _ga_ =
       _f$_
        ? caml_call1
          (run_every_cycle_end_state_fun, run_every_cycle_end_state$0)
        : _f$_,
     _gb_ = _ga_ ? caml_call1(last_cycle_time_fun, last_cycle_time$0) : _ga_,
     _gc_ =
       _gb_
        ? caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0)
        : _gb_,
     _gd_ = _gc_ ? caml_call1(total_cycle_time_fun, total_cycle_time$0) : _gc_,
     _ge_ = _gd_ ? caml_call1(time_source_fun, time_source$0) : _gd_,
     _gf_ = _ge_ ? caml_call1(external_jobs_fun, external_jobs$0) : _ge_,
     _gg_ =
       _gf_
        ? caml_call1
          (thread_safe_external_job_hook_, thread_safe_external_job_hook$0)
        : _gf_,
     _gh_ = _gg_ ? caml_call1(job_queued_hook_fun, job_queued_hook$0) : _gg_,
     _gi_ = _gh_ ? caml_call1(event_added_hook_fun, event_added_hook$0) : _gh_,
     _gj_ = _gi_ ? caml_call1(yield_fun, yield$1) : _gi_,
     _gk_ =
       _gj_
        ? caml_call1
          (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0)
        : _gj_,
     _gl_ = _gk_ ? caml_call1(check_invariants_fun, check_invariants$0) : _gk_,
     _gm_ =
       _gl_
        ? caml_call1
          (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0)
        : _gl_;
    return _gm_
            ? caml_call1(record_backtraces_fun, record_backtraces$0)
            : _gm_;
   }
   function exists$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _fX_ = caml_call1(check_access_fun, check_access$0),
     _fx_ = _fX_ || caml_call1(job_pool_fun, job_pool$0),
     _fy_ =
       _fx_ || caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _fz_ = _fy_ || caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _fA_ =
       _fz_
       ||
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _fB_ =
       _fA_
       || caml_call1(main_execution_context_fun, main_execution_context$0),
     _fC_ =
       _fB_
       ||
        caml_call1(current_execution_context_fun, current_execution_context$0),
     _fD_ = _fC_ || caml_call1(uncaught_exn_fun, uncaught_exn),
     _fE_ = _fD_ || caml_call1(cycle_count_fun, cycle_count$0),
     _fF_ = _fE_ || caml_call1(cycle_start_fun, cycle_start$0),
     _fG_ = _fF_ || caml_call1(in_cycle_fun, in_cycle$0),
     _fH_ =
       _fG_ || caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _fI_ =
       _fH_
       ||
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _fJ_ = _fI_ || caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _fK_ =
       _fJ_
       ||
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _fL_ = _fK_ || caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _fM_ = _fL_ || caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _fN_ = _fM_ || caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _fO_ = _fN_ || caml_call1(time_source_fun, time_source$0),
     _fP_ = _fO_ || caml_call1(external_jobs_fun, external_jobs$0),
     _fQ_ =
       _fP_
       ||
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _fR_ = _fQ_ || caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _fS_ = _fR_ || caml_call1(event_added_hook_fun, event_added_hook$0),
     _fT_ = _fS_ || caml_call1(yield_fun, yield$1),
     _fU_ =
       _fT_
       ||
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _fV_ = _fU_ || caml_call1(check_invariants_fun, check_invariants$0),
     _fW_ =
       _fV_
       ||
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return _fW_
            ? _fW_
            : caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function to_list$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _e8_ = [0, caml_call1(record_backtraces_fun, record_backtraces$0), 0],
     _e9_ =
       [0,
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
        _e8_],
     _e__ = [0, caml_call1(check_invariants_fun, check_invariants$0), _e9_],
     _e$_ =
       [0,
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
        _e__],
     _fa_ = [0, caml_call1(yield_fun, yield$1), _e$_],
     _fb_ = [0, caml_call1(event_added_hook_fun, event_added_hook$0), _fa_],
     _fc_ = [0, caml_call1(job_queued_hook_fun, job_queued_hook$0), _fb_],
     _fd_ =
       [0,
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
        _fc_],
     _fe_ = [0, caml_call1(external_jobs_fun, external_jobs$0), _fd_],
     _ff_ = [0, caml_call1(time_source_fun, time_source$0), _fe_],
     _fg_ = [0, caml_call1(total_cycle_time_fun, total_cycle_time$0), _ff_],
     _fh_ =
       [0, caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0), _fg_],
     _fi_ = [0, caml_call1(last_cycle_time_fun, last_cycle_time$0), _fh_],
     _fj_ =
       [0,
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
        _fi_],
     _fk_ =
       [0, caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0), _fj_],
     _fl_ =
       [0,
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
        _fk_],
     _fm_ =
       [0,
        caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
        _fl_],
     _fn_ = [0, caml_call1(in_cycle_fun, in_cycle$0), _fm_],
     _fo_ = [0, caml_call1(cycle_start_fun, cycle_start$0), _fn_],
     _fp_ = [0, caml_call1(cycle_count_fun, cycle_count$0), _fo_],
     _fq_ = [0, caml_call1(uncaught_exn_fun, uncaught_exn), _fp_],
     _fr_ =
       [0,
        caml_call1(current_execution_context_fun, current_execution_context$0),
        _fq_],
     _fs_ =
       [0,
        caml_call1(main_execution_context_fun, main_execution_context$0),
        _fr_],
     _ft_ =
       [0,
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
        _fs_],
     _fu_ = [0, caml_call1(low_priority_jobs_fun, low_priority_jobs$0), _ft_],
     _fv_ =
       [0, caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0), _fu_],
     _fw_ = [0, caml_call1(job_pool_fun, job_pool$0), _fv_];
    return [0, caml_call1(check_access_fun, check_access$0), _fw_];
   }
   function iter$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call3(check_access_fun, check_access$0, record, record[1]);
    caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    caml_call3
     (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]);
    caml_call3(low_priority_jobs_fun, low_priority_jobs$0, record, record[4]);
    caml_call3
     (very_low_priority_workers_fun,
      very_low_priority_workers$0,
      record,
      record[5]);
    caml_call3
     (main_execution_context_fun, main_execution_context$0, record, record[6]);
    caml_call3
     (current_execution_context_fun,
      current_execution_context$0,
      record,
      record[7]);
    caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]);
    caml_call3(cycle_count_fun, cycle_count$0, record, record[9]);
    caml_call3(cycle_start_fun, cycle_start$0, record, record[10]);
    caml_call3(in_cycle_fun, in_cycle$0, record, record[11]);
    caml_call3
     (run_every_cycle_start_fun, run_every_cycle_start$0, record, record[12]);
    caml_call3
     (run_every_cycle_start_state_fu,
      run_every_cycle_start_state$0,
      record,
      record[13]);
    caml_call3
     (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]);
    caml_call3
     (run_every_cycle_end_state_fun,
      run_every_cycle_end_state$0,
      record,
      record[15]);
    caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]);
    caml_call3
     (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]);
    caml_call3(total_cycle_time_fun, total_cycle_time$0, record, record[18]);
    caml_call3(time_source_fun, time_source$0, record, record[19]);
    caml_call3(external_jobs_fun, external_jobs$0, record, record[20]);
    caml_call3
     (thread_safe_external_job_hook_,
      thread_safe_external_job_hook$0,
      record,
      record[21]);
    caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]);
    caml_call3(event_added_hook_fun, event_added_hook$0, record, record[23]);
    caml_call3(yield_fun, yield$1, record, record[24]);
    caml_call3
     (yield_until_no_jobs_remain_fun,
      yield_until_no_jobs_remain$0,
      record,
      record[25]);
    caml_call3(check_invariants_fun, check_invariants$0, record, record[26]);
    caml_call3
     (max_num_jobs_per_priority_per_,
      max_num_jobs_per_priority_per_$0,
      record,
      record[27]);
    return caml_call3
            (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function fold$2
   (record,
    init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _eH_ = record[28],
     _eI_ = record[27],
     _eJ_ = record[26],
     _eK_ = record[25],
     _eL_ = record[24],
     _eM_ = record[23],
     _eN_ = record[22],
     _eO_ = record[21],
     _eP_ = record[20],
     _eQ_ = record[19],
     _eR_ = record[18],
     _eS_ = record[17],
     _eT_ = record[16],
     _eU_ = record[15],
     _eV_ = record[14],
     _eW_ = record[13],
     _eX_ = record[12],
     _eY_ = record[11],
     _eZ_ = record[10],
     _e0_ = record[9],
     _e1_ = record[8],
     _e2_ = record[7],
     _e3_ = record[6],
     _e4_ = record[5],
     _e5_ = record[4],
     _e6_ = record[3],
     _e7_ = record[2];
    return caml_call4
            (record_backtraces_fun,
             caml_call4
              (max_num_jobs_per_priority_per_,
               caml_call4
                (check_invariants_fun,
                 caml_call4
                  (yield_until_no_jobs_remain_fun,
                   caml_call4
                    (yield_fun,
                     caml_call4
                      (event_added_hook_fun,
                       caml_call4
                        (job_queued_hook_fun,
                         caml_call4
                          (thread_safe_external_job_hook_,
                           caml_call4
                            (external_jobs_fun,
                             caml_call4
                              (time_source_fun,
                               caml_call4
                                (total_cycle_time_fun,
                                 caml_call4
                                  (last_cycle_num_jobs_fun,
                                   caml_call4
                                    (last_cycle_time_fun,
                                     caml_call4
                                      (run_every_cycle_end_state_fun,
                                       caml_call4
                                        (run_every_cycle_end_fun,
                                         caml_call4
                                          (run_every_cycle_start_state_fu,
                                           caml_call4
                                            (run_every_cycle_start_fun,
                                             caml_call4
                                              (in_cycle_fun,
                                               caml_call4
                                                (cycle_start_fun,
                                                 caml_call4
                                                  (cycle_count_fun,
                                                   caml_call4
                                                    (uncaught_exn_fun,
                                                     caml_call4
                                                      (current_execution_context_fun,
                                                       caml_call4
                                                        (main_execution_context_fun,
                                                         caml_call4
                                                          (very_low_priority_workers_fun,
                                                           caml_call4
                                                            (low_priority_jobs_fun,
                                                             caml_call4
                                                              (normal_priority_jobs_fun,
                                                               caml_call4
                                                                (job_pool_fun,
                                                                 caml_call4
                                                                  (check_access_fun, init, check_access$0, record, record[1]),
                                                                 job_pool$0,
                                                                 record,
                                                                 _e7_),
                                                               normal_priority_jobs$0,
                                                               record,
                                                               _e6_),
                                                             low_priority_jobs$0,
                                                             record,
                                                             _e5_),
                                                           very_low_priority_workers$0,
                                                           record,
                                                           _e4_),
                                                         main_execution_context$0,
                                                         record,
                                                         _e3_),
                                                       current_execution_context$0,
                                                       record,
                                                       _e2_),
                                                     uncaught_exn,
                                                     record,
                                                     _e1_),
                                                   cycle_count$0,
                                                   record,
                                                   _e0_),
                                                 cycle_start$0,
                                                 record,
                                                 _eZ_),
                                               in_cycle$0,
                                               record,
                                               _eY_),
                                             run_every_cycle_start$0,
                                             record,
                                             _eX_),
                                           run_every_cycle_start_state$0,
                                           record,
                                           _eW_),
                                         run_every_cycle_end$0,
                                         record,
                                         _eV_),
                                       run_every_cycle_end_state$0,
                                       record,
                                       _eU_),
                                     last_cycle_time$0,
                                     record,
                                     _eT_),
                                   last_cycle_num_jobs$0,
                                   record,
                                   _eS_),
                                 total_cycle_time$0,
                                 record,
                                 _eR_),
                               time_source$0,
                               record,
                               _eQ_),
                             external_jobs$0,
                             record,
                             _eP_),
                           thread_safe_external_job_hook$0,
                           record,
                           _eO_),
                         job_queued_hook$0,
                         record,
                         _eN_),
                       event_added_hook$0,
                       record,
                       _eM_),
                     yield$1,
                     record,
                     _eL_),
                   yield_until_no_jobs_remain$0,
                   record,
                   _eK_),
                 check_invariants$0,
                 record,
                 _eJ_),
               max_num_jobs_per_priority_per_$0,
               record,
               _eI_),
             record_backtraces$0,
             record,
             _eH_);
   }
   function for_all$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _eg_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _eh_ =
       _eg_ ? caml_call3(job_pool_fun, job_pool$0, record, record[2]) : _eg_,
     _ei_ =
       _eh_
        ? caml_call3
          (normal_priority_jobs_fun,
           normal_priority_jobs$0,
           record,
           record[3])
        : _eh_,
     _ej_ =
       _ei_
        ? caml_call3
          (low_priority_jobs_fun, low_priority_jobs$0, record, record[4])
        : _ei_,
     _ek_ =
       _ej_
        ? caml_call3
          (very_low_priority_workers_fun,
           very_low_priority_workers$0,
           record,
           record[5])
        : _ej_,
     _el_ =
       _ek_
        ? caml_call3
          (main_execution_context_fun,
           main_execution_context$0,
           record,
           record[6])
        : _ek_,
     _em_ =
       _el_
        ? caml_call3
          (current_execution_context_fun,
           current_execution_context$0,
           record,
           record[7])
        : _el_,
     _en_ =
       _em_
        ? caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8])
        : _em_,
     _eo_ =
       _en_
        ? caml_call3(cycle_count_fun, cycle_count$0, record, record[9])
        : _en_,
     _ep_ =
       _eo_
        ? caml_call3(cycle_start_fun, cycle_start$0, record, record[10])
        : _eo_,
     _eq_ =
       _ep_ ? caml_call3(in_cycle_fun, in_cycle$0, record, record[11]) : _ep_,
     _er_ =
       _eq_
        ? caml_call3
          (run_every_cycle_start_fun,
           run_every_cycle_start$0,
           record,
           record[12])
        : _eq_,
     _es_ =
       _er_
        ? caml_call3
          (run_every_cycle_start_state_fu,
           run_every_cycle_start_state$0,
           record,
           record[13])
        : _er_,
     _et_ =
       _es_
        ? caml_call3
          (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14])
        : _es_,
     _eu_ =
       _et_
        ? caml_call3
          (run_every_cycle_end_state_fun,
           run_every_cycle_end_state$0,
           record,
           record[15])
        : _et_,
     _ev_ =
       _eu_
        ? caml_call3
          (last_cycle_time_fun, last_cycle_time$0, record, record[16])
        : _eu_,
     _ew_ =
       _ev_
        ? caml_call3
          (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17])
        : _ev_,
     _ex_ =
       _ew_
        ? caml_call3
          (total_cycle_time_fun, total_cycle_time$0, record, record[18])
        : _ew_,
     _ey_ =
       _ex_
        ? caml_call3(time_source_fun, time_source$0, record, record[19])
        : _ex_,
     _ez_ =
       _ey_
        ? caml_call3(external_jobs_fun, external_jobs$0, record, record[20])
        : _ey_,
     _eA_ =
       _ez_
        ? caml_call3
          (thread_safe_external_job_hook_,
           thread_safe_external_job_hook$0,
           record,
           record[21])
        : _ez_,
     _eB_ =
       _eA_
        ? caml_call3
          (job_queued_hook_fun, job_queued_hook$0, record, record[22])
        : _eA_,
     _eC_ =
       _eB_
        ? caml_call3
          (event_added_hook_fun, event_added_hook$0, record, record[23])
        : _eB_,
     _eD_ = _eC_ ? caml_call3(yield_fun, yield$1, record, record[24]) : _eC_,
     _eE_ =
       _eD_
        ? caml_call3
          (yield_until_no_jobs_remain_fun,
           yield_until_no_jobs_remain$0,
           record,
           record[25])
        : _eD_,
     _eF_ =
       _eE_
        ? caml_call3
          (check_invariants_fun, check_invariants$0, record, record[26])
        : _eE_,
     _eG_ =
       _eF_
        ? caml_call3
          (max_num_jobs_per_priority_per_,
           max_num_jobs_per_priority_per_$0,
           record,
           record[27])
        : _eF_;
    return _eG_
            ? caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28])
            : _eG_;
   }
   function exists$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _ef_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _dR_ = _ef_ || caml_call3(job_pool_fun, job_pool$0, record, record[2]),
     _dS_ =
       _dR_
       ||
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _dT_ =
       _dS_
       ||
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _dU_ =
       _dT_
       ||
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
     _dV_ =
       _dU_
       ||
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
     _dW_ =
       _dV_
       ||
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
     _dX_ =
       _dW_ || caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _dY_ =
       _dX_ || caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _dZ_ =
       _dY_ || caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _d0_ = _dZ_ || caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _d1_ =
       _d0_
       ||
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
     _d2_ =
       _d1_
       ||
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
     _d3_ =
       _d2_
       ||
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _d4_ =
       _d3_
       ||
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
     _d5_ =
       _d4_
       ||
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _d6_ =
       _d5_
       ||
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _d7_ =
       _d6_
       ||
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _d8_ =
       _d7_ || caml_call3(time_source_fun, time_source$0, record, record[19]),
     _d9_ =
       _d8_
       || caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _d__ =
       _d9_
       ||
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
     _d$_ =
       _d__
       ||
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _ea_ =
       _d$_
       ||
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _eb_ = _ea_ || caml_call3(yield_fun, yield$1, record, record[24]),
     _ec_ =
       _eb_
       ||
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
     _ed_ =
       _ec_
       ||
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
     _ee_ =
       _ed_
       ||
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]);
    return _ee_
            ? _ee_
            : caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function to_list$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _dq_ =
       [0,
        caml_call3
         (record_backtraces_fun, record_backtraces$0, record, record[28]),
        0],
     _dr_ =
       [0,
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]),
        _dq_],
     _ds_ =
       [0,
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
        _dr_],
     _dt_ =
       [0,
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
        _ds_],
     _du_ = [0, caml_call3(yield_fun, yield$1, record, record[24]), _dt_],
     _dv_ =
       [0,
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
        _du_],
     _dw_ =
       [0,
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
        _dv_],
     _dx_ =
       [0,
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
        _dw_],
     _dy_ =
       [0,
        caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
        _dx_],
     _dz_ =
       [0,
        caml_call3(time_source_fun, time_source$0, record, record[19]),
        _dy_],
     _dA_ =
       [0,
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
        _dz_],
     _dB_ =
       [0,
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
        _dA_],
     _dC_ =
       [0,
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
        _dB_],
     _dD_ =
       [0,
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
        _dC_],
     _dE_ =
       [0,
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
        _dD_],
     _dF_ =
       [0,
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
        _dE_],
     _dG_ =
       [0,
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
        _dF_],
     _dH_ =
       [0, caml_call3(in_cycle_fun, in_cycle$0, record, record[11]), _dG_],
     _dI_ =
       [0,
        caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
        _dH_],
     _dJ_ =
       [0,
        caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
        _dI_],
     _dK_ =
       [0,
        caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
        _dJ_],
     _dL_ =
       [0,
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
        _dK_],
     _dM_ =
       [0,
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
        _dL_],
     _dN_ =
       [0,
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
        _dM_],
     _dO_ =
       [0,
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
        _dN_],
     _dP_ =
       [0,
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
        _dO_],
     _dQ_ = [0, caml_call3(job_pool_fun, job_pool$0, record, record[2]), _dP_];
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _dQ_];
   }
   function map$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _c1_ =
       caml_call3
        (record_backtraces_fun, record_backtraces$0, record, record[28]),
     _c2_ =
       caml_call3
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         record,
         record[27]),
     _c3_ =
       caml_call3
        (check_invariants_fun, check_invariants$0, record, record[26]),
     _c4_ =
       caml_call3
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         record,
         record[25]),
     _c5_ = caml_call3(yield_fun, yield$1, record, record[24]),
     _c6_ =
       caml_call3
        (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _c7_ =
       caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _c8_ =
       caml_call3
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         record,
         record[21]),
     _c9_ = caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _c__ = caml_call3(time_source_fun, time_source$0, record, record[19]),
     _c$_ =
       caml_call3
        (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _da_ =
       caml_call3
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _db_ =
       caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _dc_ =
       caml_call3
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         record,
         record[15]),
     _dd_ =
       caml_call3
        (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _de_ =
       caml_call3
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         record,
         record[13]),
     _df_ =
       caml_call3
        (run_every_cycle_start_fun,
         run_every_cycle_start$0,
         record,
         record[12]),
     _dg_ = caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _dh_ = caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _di_ = caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _dj_ = caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _dk_ =
       caml_call3
        (current_execution_context_fun,
         current_execution_context$0,
         record,
         record[7]),
     _dl_ =
       caml_call3
        (main_execution_context_fun,
         main_execution_context$0,
         record,
         record[6]),
     _dm_ =
       caml_call3
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         record,
         record[5]),
     _dn_ =
       caml_call3
        (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _do_ =
       caml_call3
        (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _dp_ = caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _dp_,
            _do_,
            _dn_,
            _dm_,
            _dl_,
            _dk_,
            _dj_,
            _di_,
            _dh_,
            _dg_,
            _df_,
            _de_,
            _dd_,
            _dc_,
            _db_,
            _da_,
            _c$_,
            _c__,
            _c9_,
            _c8_,
            _c7_,
            _c6_,
            _c5_,
            _c4_,
            _c3_,
            _c2_,
            _c1_];
   }
   function set_all_mutable_fields$0
   (record,
    check_access,
    job_pool,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_end,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = check_access;
    record$0[2] = job_pool;
    record$0[6] = main_execution_context;
    record$0[7] = current_execution_context;
    record$0[8] = uncaught_exn;
    record$0[9] = cycle_count;
    record$0[10] = cycle_start;
    record$0[11] = in_cycle;
    record$0[12] = run_every_cycle_start;
    record$0[14] = run_every_cycle_end;
    record$0[16] = last_cycle_time;
    record$0[17] = last_cycle_num_jobs;
    record$0[18] = total_cycle_time;
    record$0[19] = time_source;
    record$0[21] = thread_safe_external_job_hook;
    record$0[22] = job_queued_hook;
    record$0[23] = event_added_hook;
    record$0[24] = yield$0;
    record$0[25] = yield_until_no_jobs_remain;
    record$0[26] = check_invariants;
    record$0[27] = max_num_jobs_per_priority_per_;
    record$0[28] = record_backtraces;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       record_backtraces$0,
       max_num_jobs_per_priority_per_$0,
       check_invariants$0,
       yield_until_no_jobs_remain$0,
       yield$1,
       event_added_hook$0,
       job_queued_hook$0,
       thread_safe_external_job_hook$0,
       external_jobs$0,
       time_source$0,
       total_cycle_time$0,
       last_cycle_num_jobs$0,
       last_cycle_time$0,
       run_every_cycle_end_state$0,
       run_every_cycle_end$0,
       run_every_cycle_start_state$0,
       run_every_cycle_start$0,
       in_cycle$0,
       cycle_start$0,
       cycle_count$0,
       uncaught_exn,
       current_execution_context$0,
       main_execution_context$0,
       very_low_priority_workers$0,
       low_priority_jobs$0,
       normal_priority_jobs$0,
       job_pool$0,
       check_access$0,
       make_creator$0,
       create$2,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0];
   function sexp_of_t$1(param){
    var
     check_access_007 = param[1],
     job_pool_009 = param[2],
     very_low_priority_workers_015 = param[5],
     low_priority_jobs_013 = param[4],
     normal_priority_jobs_011 = param[3],
     main_execution_context_017 = param[6],
     current_execution_context_019 = param[7],
     uncaught_exn_021 = param[8],
     cycle_count_027 = param[9],
     cycle_start_029 = param[10],
     in_cycle_031 = param[11],
     run_every_cycle_start_033 = param[12],
     run_every_cycle_start_state_03 = param[13],
     run_every_cycle_end_037 = param[14],
     run_every_cycle_end_state_039 = param[15],
     last_cycle_time_041 = param[16],
     last_cycle_num_jobs_043 = param[17],
     total_cycle_time_045 = param[18],
     time_source_047 = param[19],
     external_jobs_049 = param[20],
     job_queued_hook_053 = param[22],
     event_added_hook_055 = param[23],
     yield_057 = param[24],
     yield_until_no_jobs_remain_059 = param[25],
     check_invariants_061 = param[26],
     max_num_jobs_per_priority_per_ = param[27],
     record_backtraces_065 = param[28],
     arg_066 = caml_call1(Core[305], record_backtraces_065),
     bnds_006 = [0, [1, [0, _al_, [0, arg_066, 0]]], 0],
     arg_064 =
       caml_call1(Async_kernel_config[5][2], max_num_jobs_per_priority_per_),
     bnds_006$0 = [0, [1, [0, _am_, [0, arg_064, 0]]], bnds_006],
     arg_062 = caml_call1(Core[305], check_invariants_061),
     bnds_006$1 = [0, [1, [0, _an_, [0, arg_062, 0]]], bnds_006$0],
     arg_060 =
       caml_call1(Sexplib0_Sexp_conv[23], yield_until_no_jobs_remain_059),
     bnds_006$2 = [0, [1, [0, _ao_, [0, arg_060, 0]]], bnds_006$1],
     arg_058 = caml_call1(Sexplib0_Sexp_conv[23], yield_057),
     bnds_006$3 = [0, [1, [0, _ap_, [0, arg_058, 0]]], bnds_006$2];
    function _cP_(param){
     function _cZ_(_c0_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _cZ_);
    }
    var
     arg_056 = caml_call2(Core[454], _cP_, event_added_hook_055),
     bnds_006$4 = [0, [1, [0, _aq_, [0, arg_056, 0]]], bnds_006$3];
    function _cQ_(param){
     function _cX_(_cY_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _cX_);
    }
    var
     arg_054 = caml_call2(Core[454], _cQ_, job_queued_hook_053),
     bnds_006$5 = [0, [1, [0, _ar_, [0, arg_054, 0]]], bnds_006$4];
    function _cR_(_cW_){return 0;}
    var
     arg_052 = caml_call1(Sexplib0_Sexp_conv[24], _cR_),
     bnds_006$6 = [0, [1, [0, _as_, [0, arg_052, 0]]], bnds_006$5],
     arg_050 =
       caml_call2
        (Thread_safe_queue[1],
         Async_kernel_External_job[1],
         external_jobs_049),
     bnds_006$7 = [0, [1, [0, _at_, [0, arg_050, 0]]], bnds_006$6],
     arg_048 =
       caml_call2
        (Async_kernel_Synchronous_time_[4][17], Core[202], time_source_047),
     bnds_006$8 = [0, [1, [0, _au_, [0, arg_048, 0]]], bnds_006$7],
     arg_046 = caml_call1(Core_Time_ns[1][10], total_cycle_time_045),
     bnds_006$9 = [0, [1, [0, _av_, [0, arg_046, 0]]], bnds_006$8],
     arg_044 = caml_call1(Core[356], last_cycle_num_jobs_043),
     bnds_006$10 = [0, [1, [0, _aw_, [0, arg_044, 0]]], bnds_006$9],
     arg_042 = caml_call1(Core_Time_ns[1][10], last_cycle_time_041),
     bnds_006$11 = [0, [1, [0, _ax_, [0, arg_042, 0]]], bnds_006$10],
     arg_040 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_end_state_039),
     bnds_006$12 = [0, [1, [0, _ay_, [0, arg_040, 0]]], bnds_006$11],
     arg_038 =
       caml_call2(Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_end_037),
     bnds_006$13 = [0, [1, [0, _az_, [0, arg_038, 0]]], bnds_006$12],
     arg_036 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_start_state_03),
     bnds_006$14 = [0, [1, [0, _aA_, [0, arg_036, 0]]], bnds_006$13],
     arg_034 =
       caml_call2
        (Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_start_033),
     bnds_006$15 = [0, [1, [0, _aB_, [0, arg_034, 0]]], bnds_006$14],
     arg_032 = caml_call1(Core[305], in_cycle_031),
     bnds_006$16 = [0, [1, [0, _aC_, [0, arg_032, 0]]], bnds_006$15],
     arg_030 = caml_call1(Async_kernel_Time_ns[92], cycle_start_029),
     bnds_006$17 = [0, [1, [0, _aD_, [0, arg_030, 0]]], bnds_006$16],
     arg_028 = caml_call1(Core[356], cycle_count_027),
     bnds_006$18 = [0, [1, [0, _aE_, [0, arg_028, 0]]], bnds_006$17];
    function _cS_(param){
     var
      arg1_024 = param[2],
      arg0_023 = param[1],
      res0_025 = caml_call1(Base_Exn[1], arg0_023),
      res1_026 = caml_call1(Core_Sexp[90], arg1_024);
     return [1, [0, res0_025, [0, res1_026, 0]]];
    }
    var
     arg_022 = caml_call2(Core[454], _cS_, uncaught_exn_021),
     bnds_006$19 = [0, [1, [0, _aF_, [0, arg_022, 0]]], bnds_006$18],
     arg_020 =
       caml_call1
        (Async_kernel_Execution_context[6], current_execution_context_019),
     bnds_006$20 = [0, [1, [0, _aG_, [0, arg_020, 0]]], bnds_006$19],
     arg_018 =
       caml_call1
        (Async_kernel_Execution_context[6], main_execution_context_017),
     bnds_006$21 = [0, [1, [0, _aH_, [0, arg_018, 0]]], bnds_006$20],
     arg_016 =
       caml_call2
        (Core_Deque[10],
         Very_low_priority_worker[5],
         very_low_priority_workers_015),
     bnds_006$22 = [0, [1, [0, _aI_, [0, arg_016, 0]]], bnds_006$21],
     arg_014 = caml_call1(Async_kernel_Job_queue[1], low_priority_jobs_013),
     bnds_006$23 = [0, [1, [0, _aJ_, [0, arg_014, 0]]], bnds_006$22],
     arg_012 = caml_call1(Async_kernel_Job_queue[1], normal_priority_jobs_011),
     bnds_006$24 = [0, [1, [0, _aK_, [0, arg_012, 0]]], bnds_006$23],
     arg_010 = caml_call1(Async_kernel_Job_pool[2], job_pool_009),
     bnds_006$25 = [0, [1, [0, _aL_, [0, arg_010, 0]]], bnds_006$24];
    function _cT_(param){
     function _cU_(_cV_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _cU_);
    }
    var
     arg_008 = caml_call2(Core[454], _cT_, check_access_007),
     bnds_006$26 = [0, [1, [0, _aM_, [0, arg_008, 0]]], bnds_006$25];
    return [1, bnds_006$26];
   }
   function uncaught_exn$0(t){
    var _cN_ = t[8];
    if(! _cN_) return 0;
    var match = _cN_[1], sexp = match[2], exn = match[1];
    function _cO_(param){
     var
      arg1_068 = param[2],
      arg0_067 = param[1],
      res0_069 = caml_call1(Base_Exn[1], arg0_067),
      res1_070 = caml_call1(Core_Sexp[90], arg1_068);
     return [1, [0, res0_069, [0, res1_070, 0]]];
    }
    return [0,
            caml_call5
             (Core_Error[17],
              0,
              0,
              cst_unhandled_exception,
              [0, exn, sexp],
              _cO_)];
   }
   function num_pending_jobs(t){
    var _cM_ = caml_call1(Async_kernel_Job_queue[8], t[4]);
    return caml_call1(Async_kernel_Job_queue[8], t[3]) + _cM_ | 0;
   }
   function num_jobs_run(t){
    var _cL_ = caml_call1(Async_kernel_Job_queue[10], t[4]);
    return caml_call1(Async_kernel_Job_queue[10], t[3]) + _cL_ | 0;
   }
   function last_cycle_num_jobs$1(t){return t[17];}
   function unordered_is_sublist(equal, small, large){
    function _cG_(acc, x){
     function _cI_(l$0){
      function _cJ_(y){return 1 - caml_call2(equal, y, x);}
      var
       _cK_ = caml_call2(Core_List[130], l$0, _cJ_),
       match = _cK_[2],
       l = _cK_[1];
      if(! match) return 0;
      var r = match[2];
      return [0, caml_call2(Core[157], l, r)];
     }
     return caml_call2(Core_Option[27], acc, _cI_);
    }
    var _cH_ = caml_call3(Core_List[10], small, [0, large], _cG_);
    return caml_call1(Core_Option[57], _cH_);
   }
   function check_hook_table_invariant(table, list){
    var _cF_ = caml_call1(Core_Hashtbl[65], table);
    if(unordered_is_sublist(Core[246], _cF_, list)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
   }
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _bx_ = function(_cE_){return 0;},
      _by_ = function(_cD_){return 0;},
      _bz_ = function(_cC_){return 0;},
      _bA_ = function(_cB_){return 0;},
      _bB_ = function(_cA_){return 0;},
      _bC_ = function(_cz_){return 0;},
      _bD_ = function(_cy_){return 0;},
      _bE_ = function(_cx_){return 0;},
      _bF_ = function(_cw_){return 0;},
      _bG_ =
        function(job){
         if(caml_call2(Tuple_pool[6], t[2], job)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
        },
      _bH_ = caml_call1(Async_kernel_Synchronous_time_[8][3], _bG_),
      _bI_ = function(_cv_){return check(_bH_, _cv_);},
      _bJ_ = function(_cu_){return 0;},
      _bK_ =
        function(last_cycle_num_jobs){
         if(caml_call2(Async_kernel_Import[1], last_cycle_num_jobs, 0))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
        },
      _bL_ = function(_ct_){return check(_bK_, _ct_);},
      _bM_ = function(_cs_){return 0;},
      _bN_ =
        function(run_every_cycle_end_state){
         return check_hook_table_invariant(run_every_cycle_end_state, t[14]);
        },
      _bO_ = function(_cr_){return check(_bN_, _cr_);},
      _bP_ = function(_cq_){return 0;},
      _bQ_ =
        function(run_every_cycle_start_state){
         return check_hook_table_invariant(run_every_cycle_start_state, t[12]);
        },
      _bR_ = function(_cp_){return check(_bQ_, _cp_);},
      _bS_ = function(_co_){return 0;},
      _bT_ = function(_cn_){return 0;},
      _bU_ = function(_cm_){return 0;},
      _bV_ =
        function(cycle_count){
         if(caml_call2(Async_kernel_Import[1], cycle_count, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
        },
      _bW_ = function(_cl_){return check(_bV_, _cl_);},
      _bX_ =
        function(uncaught_exn){
         var _cj_ = caml_call1(Core[243], uncaught_exn);
         if(! _cj_) return _cj_;
         var _ck_ = num_pending_jobs(t);
         if(caml_call2(Async_kernel_Import[3], _ck_, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
        },
      _bY_ = function(_ci_){return check(_bX_, _ci_);},
      _bZ_ = Async_kernel_Execution_context[7],
      _b0_ = function(_ch_){return check(_bZ_, _ch_);},
      _b1_ = Async_kernel_Execution_context[7],
      _b2_ = function(_cg_){return check(_b1_, _cg_);},
      _b3_ =
        function(q){
         return caml_call2(Core_Deque[17], q, Very_low_priority_worker[6]);
        },
      _b4_ = function(_cf_){return check(_b3_, _cf_);},
      _b5_ = Async_kernel_Job_queue[2],
      _b6_ = function(_ce_){return check(_b5_, _ce_);},
      _b7_ = Async_kernel_Job_queue[2],
      _b8_ = function(_cd_){return check(_b7_, _cd_);},
      _b9_ = Async_kernel_Job_pool[3],
      _b__ = function(_cc_){return check(_b9_, _cc_);},
      _b$_ = function(_cb_){return 0;},
      _ca_ =
        caml_call28
         (Fields$0[33],
          _b$_,
          _b__,
          _b8_,
          _b6_,
          _b4_,
          _b2_,
          _b0_,
          _bY_,
          _bW_,
          _bU_,
          _bT_,
          _bS_,
          _bR_,
          _bP_,
          _bO_,
          _bM_,
          _bL_,
          _bJ_,
          _bI_,
          _bF_,
          _bE_,
          _bD_,
          _bC_,
          _bB_,
          _bA_,
          _bz_,
          _by_,
          _bx_);
     return _ca_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _bu_ = [0, [1, [0, _aO_, [0, sexp_of_t$1(t), 0]]], 0],
      _bv_ = [0, [1, [0, _aP_, [0, caml_call1(Core[537], exn), 0]]], _bu_],
      _bw_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _bv_]];
     return caml_call1(Core[253], _bw_);
    }
   }
   function free_job(t, job){return caml_call2(Tuple_pool[15], t[2], job);}
   function enqueue(t, execution_context, f, a){
    var _bs_ = caml_call1(Core[242], t[8]);
    if(_bs_){
     var priority = execution_context[2], job_queue = priority ? t[4] : t[3];
     caml_call4(Async_kernel_Job_queue[4], job_queue, execution_context, f, a);
     var match = t[22];
     if(match){var f$0 = match[1]; return caml_call1(f$0, priority);}
     var _bt_ = 0;
    }
    else
     var _bt_ = _bs_;
    return _bt_;
   }
   function enqueue_job(t, job, free_job){
    var
     job_pool = t[2],
     _bq_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][5]),
     _br_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][4]);
    enqueue
     (t,
      caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][3]),
      _br_,
      _bq_);
    return free_job ? caml_call2(Tuple_pool[15], t[2], job) : free_job;
   }
   function handle_fired(time_source, job_or_event){
    var
     k = caml_call1(Async_kernel_Synchronous_time_[4][2][5][1], job_or_event),
     match =
       caml_call2(Async_kernel_Synchronous_time_[4][2][5][2], k, job_or_event);
    return k
            ? enqueue_job(time_source[9], match, 1)
            : caml_call2
              (Async_kernel_Synchronous_time_[14], time_source, match);
   }
   function create$3(param){
    var
     now = caml_call1(Async_kernel_Time_ns[50], 0),
     t = [],
     time_source = [],
     events = caml_call2(Timing_wheel[9], Async_kernel_config[29], now),
     _a3_ = Async_kernel_config[27],
     _a4_ = Async_kernel_config[23],
     _a5_ = Async_kernel_config[16],
     _a6_ = caml_call1(Bvar[1], 0),
     _a7_ = caml_call1(Bvar[1], 0),
     _a8_ = 0,
     _a9_ = 0;
    function _a__(_bp_){return 0;}
    var
     _a$_ = caml_call1(Thread_safe_queue[3], 0),
     _ba_ = caml_call1(Async_kernel_Import[16], 0.),
     _bb_ = caml_call1(Async_kernel_Import[16], 0.),
     _bc_ = Async_kernel_Types[20],
     _bd_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _bc_[20], _bc_[10], _bc_[36]]),
     _be_ = Async_kernel_Types[20],
     _bf_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _be_[20], _be_[10], _be_[36]]),
     _bg_ = Async_kernel_Execution_context[8],
     _bh_ = Async_kernel_Execution_context[8],
     _bi_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _bj_ = caml_call1(Async_kernel_Job_queue[3], 0),
     _bk_ = caml_call1(Async_kernel_Job_queue[3], 0);
    caml_update_dummy
     (t,
      [0,
       0,
       caml_call1(Async_kernel_Job_pool[4], 0),
       _bk_,
       _bj_,
       _bi_,
       _bh_,
       _bg_,
       0,
       0,
       now,
       0,
       0,
       _bf_,
       0,
       _bd_,
       _bb_,
       0,
       _ba_,
       time_source,
       _a$_,
       _a__,
       _a9_,
       _a8_,
       _a7_,
       _a6_,
       _a5_,
       _a4_,
       _a3_]);
    var _bl_ = 1;
    function _bm_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _bn_ = Async_kernel_Synchronous_time_[22][3][2],
     _bo_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _bo_,
       _bn_,
       _bm_,
       _bl_,
       t]);
    return t;
   }
   function is_dead(t){return caml_call1(Core[243], t[8]);}
   function set_check_access$0(t, f){t[1] = f; return 0;}
   var match = caml_call1(Core_Result[47], create$3);
   if(0 === match[0])
    var t = match[1], t_ref = [0, t];
   else{
    var exn = match[1];
    caml_call3
     (Async_kernel_Debug[15], cst_Async_cannot_create_its_ra, exn, Core[537]);
    var t_ref = caml_call1(Core[83], 1);
   }
   function check_access$1(t){
    var match = t[1];
    if(! match) return 0;
    var f = match[1];
    return caml_call1(f, 0);
   }
   function t$0(param){var t = t_ref[1]; check_access$1(t); return t;}
   function current_execution_context$1(t){
    return t[28] ? caml_call1(Async_kernel_Execution_context[12], t[7]) : t[7];
   }
   function with_execution_context1(t, tmp_context, f, x){
    var old_context = current_execution_context$1(t);
    caml_call2(set_execution_context, t, tmp_context);
    function _a2_(param){
     return caml_call2(set_execution_context, t, old_context);
    }
    return caml_call3(Core[252], f, x, _a2_);
   }
   function with_execution_context(t, tmp_context, f){
    return with_execution_context1(t, tmp_context, f, 0);
   }
   function create_job(t, execution_context, f, a){
    if(caml_call1(Tuple_pool[14], t[2]))
     t[2] = caml_call2(Tuple_pool[13], 0, t[2]);
    return caml_call4(Tuple_pool[19], t[2], execution_context, f, a);
   }
   function got_uncaught_exn(t, exn, sexp){
    if(debug){
     var
      _a1_ =
        function(param){
         var
          arg1_072 = param[2],
          arg0_071 = param[1],
          res0_073 = caml_call1(Base_Exn[1], arg0_071),
          res1_074 = caml_call1(Core_Sexp[90], arg1_072);
         return [1, [0, res0_073, [0, res1_074, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_got_uncaught_exn, [0, exn, sexp], _a1_);
    }
    caml_call2
     (Core_List[9], [0, t[3], [0, t[4], 0]], Async_kernel_Job_queue[5]);
    t[8] = [0, [0, exn, sexp]];
    return 0;
   }
   function start_cycle(t, max_num_jobs_per_priority){
    var n = caml_call1(Async_kernel_config[5][5], max_num_jobs_per_priority);
    caml_call2(Async_kernel_Job_queue[6], t[3], n);
    return caml_call2(Async_kernel_Job_queue[6], t[4], n);
   }
   function run_jobs(t){
    for(;;){
     var e = caml_call2(Async_kernel_Job_queue[9], t[3], t);
     if(0 !== e[0]) return e;
     var e$0 = caml_call2(Async_kernel_Job_queue[9], t[4], t);
     if(0 !== e$0[0]) return e$0;
     if
      (!
       caml_call1(Async_kernel_Job_queue[7], t[3])
       && ! caml_call1(Async_kernel_Job_queue[7], t[4]))
      return _aU_;
    }
   }
   function stabilize(t){
    start_cycle(t, caml_call1(Async_kernel_config[5][4], Core_Int[41]));
    var match = run_jobs(t);
    if(0 === match[0]) return _aV_;
    var exn = match[1][1];
    return [1, exn];
   }
   function create_time_source(opt, now, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = Async_kernel_config[29];
    var
     t = t$0(0),
     events = caml_call2(Timing_wheel[9], timing_wheel_config, now),
     time_source = [],
     _aX_ = 0;
    function _aY_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _aZ_ = Async_kernel_Synchronous_time_[22][3][2],
     _a0_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _a0_,
       _aZ_,
       _aY_,
       _aX_,
       t]);
    return time_source;
   }
   function wall_clock(param){
    var _aW_ = t$0(0)[19];
    return caml_call1(Async_kernel_Synchronous_time_[13], _aW_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler1);
   var
    Async_kernel_Scheduler1 =
      [0,
       events,
       set_execution_context,
       debug,
       Ivar,
       Bvar,
       Very_low_priority_worker,
       record_backtraces,
       set_record_backtraces,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       check_invariants,
       set_check_invariants,
       yield_until_no_jobs_remain,
       set_yield_until_no_jobs_remain,
       yield$0,
       set_yield,
       event_added_hook,
       set_event_added_hook,
       job_queued_hook,
       set_job_queued_hook,
       thread_safe_external_job_hook,
       set_thread_safe_external_job_h,
       external_jobs,
       time_source,
       set_time_source,
       total_cycle_time,
       set_total_cycle_time,
       set_last_cycle_num_jobs,
       last_cycle_time,
       set_last_cycle_time,
       run_every_cycle_end_state,
       run_every_cycle_end,
       set_run_every_cycle_end,
       run_every_cycle_start_state,
       run_every_cycle_start,
       set_run_every_cycle_start,
       in_cycle,
       set_in_cycle,
       cycle_start,
       set_cycle_start,
       cycle_count,
       set_cycle_count,
       set_uncaught_exn,
       set_current_execution_context,
       main_execution_context,
       set_main_execution_context,
       very_low_priority_workers,
       low_priority_jobs,
       normal_priority_jobs,
       job_pool,
       set_job_pool,
       Fields$0,
       sexp_of_t$1,
       uncaught_exn_unwrapped,
       uncaught_exn$0,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs$1,
       unordered_is_sublist,
       check_hook_table_invariant,
       invariant$0,
       free_job,
       enqueue,
       enqueue_job,
       handle_fired,
       create$3,
       is_dead,
       set_check_access$0,
       t_ref,
       check_access$1,
       t$0,
       current_execution_context$1,
       with_execution_context1,
       with_execution_context,
       create_job,
       got_uncaught_exn,
       start_cycle,
       run_jobs,
       stabilize,
       create_time_source,
       wall_clock];
   runtime.caml_register_global
    (120, Async_kernel_Scheduler1, cst_Async_kernel_Scheduler1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar0
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Scheduler1, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar0$0 = "Async_kernel__Ivar0",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar0_ml = "src/ivar0.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar0_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _q_ = [0, cst_src_ivar0_ml, 450, 21],
    _r_ = [0, cst_src_ivar0_ml, 446, 35],
    _p_ = [0, cst_src_ivar0_ml, 383, 15],
    _o_ = [0, cst_src_ivar0_ml, 362, 15],
    _n_ = [0, cst_src_ivar0_ml, 340, 15],
    _m_ = [0, cst_src_ivar0_ml, 321, 15],
    _j_ = [0, "_"],
    _k_ = [0, "t"],
    cst_Ivar_fill_of_full_ivar = "Ivar.fill of full ivar",
    _l_ = [0, cst_src_ivar0_ml, 306, 15],
    _i_ = [0, cst_src_ivar0_ml, 296, 15],
    cst_Ivar_value_exn_called_on_e = "Ivar.value_exn called on empty ivar",
    _h_ = [0, cst_src_ivar0_ml, 285, 15],
    _g_ = [0, cst_src_ivar0_ml, 277, 15],
    _e_ = [0, "Full"],
    _f_ = [0, cst_src_ivar0_ml, 269, 15],
    _d_ = [0, "Empty"],
    _c_ = [0, cst_src_ivar0_ml, 258, 15],
    _b_ = [0, "execution_context"],
    _a_ = [0, cst_src_ivar0_ml, 118, 6],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar0 = cst_Async_kernel_Ivar0$0;
   function set_prev(param, x){param[3] = x; return 0;}
   function set_next(param, x){param[4] = x; return 0;}
   function create(run, execution_context){
    var t = [0, run, execution_context, 0, 0];
    set_prev(t, t);
    set_next(t, t);
    return t;
   }
   function create2(run1, execution_context1, run2, execution_context2){
    var
     t1 = [0, run1, execution_context1, 0, 0],
     t2 = [0, run2, execution_context2, t1, t1];
    set_prev(t1, t2);
    set_next(t1, t2);
    return t1;
   }
   function length(t){
    var n = [0, 1], r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return n[1];
     n[1]++;
     r[1] = r[1][4];
    }
   }
   function enqueue(t, scheduler, v){
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, t[2], t[1], v);
   }
   function schedule_jobs(t, v){
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0);
    enqueue(t, scheduler, v);
    var r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return 0;
     enqueue(r[1], scheduler, v);
     r[1] = r[1][4];
    }
   }
   function add(t, run, execution_context){
    var result = [0, run, execution_context, t[3], t];
    set_next(t[3], result);
    set_prev(t, result);
    return result;
   }
   function of_list(l){
    if(! l) return 0;
    var
     l$0 = l[2],
     match = l[1],
     execution_context = match[2],
     run = match[1],
     first = create(run, execution_context),
     prev = first,
     l$1 = l$0;
    for(;;){
     if(! l$1){set_prev(first, prev); return [0, first];}
     var
      l$2 = l$1[2],
      match$0 = l$1[1],
      execution_context$0 = match$0[2],
      run$0 = match$0[1],
      prev$0 = [0, run$0, execution_context$0, prev, first];
     set_next(prev, prev$0);
     var prev = prev$0, l$1 = l$2;
    }
   }
   function to_list(first){
    var t$1 = first[3], t = t$1, acc = 0;
    for(;;){
     var acc$0 = [0, [0, t[1], t[2]], acc];
     if(caml_call2(Core[246], t, first)) return acc$0;
     var t$0 = t[3], t = t$0, acc = acc$0;
    }
   }
   function sexp_of_t(param, t){
    var execution_context = t[2];
    return [1,
            [0,
             _b_,
             [0,
              caml_call1(Async_kernel_Execution_context[6], execution_context),
              0]]];
   }
   function cell_of_handler(x){return x;}
   function equal(t$0, t){return caml_call2(Core[246], t$0, t);}
   function indir(t){return [0, [3, t]];}
   var
    include = Async_kernel_Scheduler1[4],
    create_with_cell = include[1],
    create$0 = include[2],
    create_full = include[3];
   function squash(t$3){
    var match$0 = t$3[1];
    if(typeof match$0 !== "number" && 3 === match$0[0]){
     var t$4 = match$0[1], indir$1 = t$4[1];
     if(typeof indir$1 !== "number" && 3 === indir$1[0]){
      var t$5 = indir$1[1];
      a:
      {
       var indir = indir$1, t = t$5;
       for(;;){
        var indir$0 = t[1];
        if(typeof indir$0 === "number") break;
        if(3 !== indir$0[0]) break a;
        var t$0 = indir$0[1], indir = indir$0, t = t$0;
       }
      }
      var t$1 = t$3;
      for(;;){
       var match = t$1[1];
       if(typeof match !== "number" && 3 === match[0]){
        var t$2 = match[1];
        t$1[1] = indir;
        var t$1 = t$2;
        continue;
       }
       return t$1;
      }
     }
     return t$4;
    }
    return t$3;
   }
   function invariant(a_invariant, t){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler === "number") return 0;
    switch(handler[0]){
      case 0:
       caml_call1(Async_kernel_Execution_context[7], handler[2]);
       var r = [0, handler[4]];
       for(;;){
        if(caml_call2(Core[246], r[1], handler)) return 0;
        var t1 = r[1];
        if(! caml_call2(Core[246], t1[4][3], t1))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        caml_call1(Async_kernel_Execution_context[7], t1[2]);
        r[1] = r[1][4];
       }
       break;
      case 1:
       var execution_context = handler[2];
       return caml_call1(Async_kernel_Execution_context[7], execution_context);
      case 2:
       var a = handler[1]; return caml_call1(a_invariant, a);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1];
        return [1, [0, _e_, [0, caml_call1(sexp_of_a, a), 0]]];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
    return _d_;
   }
   function peek(t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return [0, a];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    return 0;
   }
   function value(t, if_empty_then_failwith){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return a;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
    return caml_call1(Core[6], if_empty_then_failwith);
   }
   function value_exn(t){return value(t, cst_Ivar_value_exn_called_on_e);}
   function is_empty(t){
    var t$0 = squash(t), _D_ = t$0[1];
    if(typeof _D_ !== "number")
     switch(_D_[0]){
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    return 1;
   }
   function is_full(t){return 1 - is_empty(t);}
   function fill(t, v){
    var x_001 = squash(t), handler = x_001[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        x_001[1] = [2, v]; return schedule_jobs(handler, v);
       case 1:
        var execution_context = handler[2], run = handler[1];
        x_001[1] = [2, v];
        var _y_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        return caml_call3
                (caml_call1(Async_kernel_Scheduler1[63], _y_),
                 execution_context,
                 run,
                 v);
       case 2:
        var
         _z_ = 0,
         _A_ = 0,
         _B_ =
           [0,
            [1,
             [0,
              _k_,
              [0, sexp_of_t$0(function(param){return _j_;}, x_001), _A_]]],
            _z_],
         _C_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Ivar_fill_of_full_ivar),
             _B_]];
        return caml_call1(Core[253], _C_);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
    x_001[1] = [2, v];
    return 0;
   }
   function remove_handler(t, handler){
    function x(_x_){return 0;}
    handler[1] = x;
    var t$0 = squash(t), cell = t$0[1];
    if(typeof cell !== "number")
     switch(cell[0]){
       case 0:
        if(caml_call2(Core[246], handler, handler[4])){t$0[1] = 0; return 0;}
        if(caml_call2(Core[246], handler, cell)) t$0[1] = handler[4];
        set_prev(handler[4], handler[3]);
        set_next(handler[3], handler[4]);
        set_prev(handler, handler);
        return set_next(handler, handler);
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     }
    return 0;
   }
   function add_handler(t, run, execution_context){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        return add(handler, run, execution_context);
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         handler$1 =
           create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = handler$1;
        return handler$1;
       case 2:
        var
         v = handler[1],
         handler$2 = create(run, execution_context),
         run$1 = function(v){return caml_call1(handler$2[1], v);},
         _w_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        caml_call3
         (caml_call1(Async_kernel_Scheduler1[63], _w_),
          execution_context,
          run$1,
          v);
        return handler$2;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     }
    var handler$0 = create(run, execution_context);
    t$0[1] = handler$0;
    return handler$0;
   }
   function has_handlers(t){
    var t$0 = squash(t), _v_ = t$0[1];
    if(typeof _v_ !== "number")
     switch(_v_[0]){
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
       case 2: break;
       default: return 1;
     }
    return 0;
   }
   function upon(t, run){
    var _u_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return add_handler(t, run, caml_call1(Async_kernel_Scheduler1[72], _u_));
   }
   function upon$0(t, run){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     t$0 = squash(t),
     handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        add(handler, run, execution_context); return 0;
       case 1:
        var execution_context$0 = handler[2], run$0 = handler[1];
        t$0[1] = create2(run, execution_context, run$0, execution_context$0);
        return 0;
       case 2:
        var v = handler[1];
        return caml_call4
                (Async_kernel_Scheduler1[63],
                 scheduler,
                 execution_context,
                 run,
                 v);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     }
    t$0[1] = [1, run, execution_context];
    return 0;
   }
   function connect(bind_result, bind_rhs){
    var _s_ = 1 - caml_call2(Core[246], bind_result, bind_rhs);
    if(! _s_) return _s_;
    var bind_result$0 = squash(bind_result), indir = [3, bind_result$0];
    a:
    {
     b:
     c:
     {
      var ivar = bind_rhs;
      d:
      for(;;){
       var bind_rhs_contents = ivar[1];
       if(typeof bind_rhs_contents === "number") break c;
       switch(bind_rhs_contents[0]){
         case 2:
          break d;
         case 3:
          var ivar$0 = bind_rhs_contents[1];
          ivar[1] = indir;
          var ivar = ivar$0;
          break;
         default: break b;
       }
      }
      break a;
     }
     if(1 - caml_call2(Core[246], ivar, bind_result$0)) ivar[1] = indir;
    }
    var t1 = bind_result$0[1];
    a:
    {
     b:
     {
      if(typeof t1 !== "number")
       switch(t1[0]){
         case 0:
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var last1 = t1[3], last2 = bind_rhs_contents[3];
             set_next(last1, bind_rhs_contents);
             set_next(last2, t1);
             set_prev(t1, last2);
             return set_prev(bind_rhs_contents, last1);
            case 1:
             var
              execution_context2 = bind_rhs_contents[2],
              run2 = bind_rhs_contents[1];
             add(t1, run2, execution_context2);
             return 0;
            case 2:
             var v = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             return schedule_jobs(t1, v);
          }
          break;
         case 1:
          var execution_context = t1[2], run = t1[1];
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var handler1 = add(bind_rhs_contents, run, execution_context);
             bind_result$0[1] = handler1;
             return 0;
            case 1:
             var
              execution_context2$0 = bind_rhs_contents[2],
              run2$0 = bind_rhs_contents[1],
              handler1$0 =
                create2(run, execution_context, run2$0, execution_context2$0);
             bind_result$0[1] = handler1$0;
             return 0;
            case 2:
             var v$0 = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             var _t_ = caml_call1(Async_kernel_Scheduler1[71], 0);
             return caml_call3
                     (caml_call1(Async_kernel_Scheduler1[63], _t_),
                      execution_context,
                      run,
                      v$0);
          }
          break;
         case 2: break;
         default: break b;
       }
      if(typeof bind_rhs_contents !== "number" && 3 === bind_rhs_contents[0])
       break b;
      if(typeof t1 === "number") break a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    }
    return typeof bind_rhs_contents === "number"
            ? 0
            : (bind_result$0[1] = bind_rhs_contents, 0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar0);
   var
    Async_kernel_Ivar0 =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       create_full,
       create_with_cell,
       peek,
       value_exn,
       value,
       is_empty,
       is_full,
       equal,
       connect,
       fill,
       [0, sexp_of_t, length, of_list, to_list],
       cell_of_handler,
       add_handler,
       remove_handler,
       has_handlers,
       upon$0,
       upon,
       indir,
       squash];
   runtime.caml_register_global
    (36, Async_kernel_Ivar0, cst_Async_kernel_Ivar0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred0
//# unitInfo: Requires: Async_kernel__Ivar0, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred0$0 = "Async_kernel__Deferred0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_Deferred_value_exn_called_ =
      "Deferred.value_exn called on undetermined deferred",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred0 = cst_Async_kernel_Deferred0$0;
   function of_ivar(ivar){return ivar;}
   function invariant(invariant_a, t){
    return caml_call2(Async_kernel_Ivar0[2], invariant_a, t);
   }
   function sexp_of_t(sexp_of_a, t){
    return caml_call2(Async_kernel_Ivar0[1], sexp_of_a, t);
   }
   function peek(t){return caml_call1(Async_kernel_Ivar0[6], t);}
   function return$0(a){return caml_call1(Async_kernel_Ivar0[4], a);}
   function is_determined(t){return caml_call1(Async_kernel_Ivar0[10], t);}
   function value_exn(t){
    return caml_call2
            (Async_kernel_Ivar0[8], t, cst_Deferred_value_exn_called_);
   }
   function upon(t, f){return caml_call2(Async_kernel_Ivar0[19], t, f);}
   function create(f){
    var result = caml_call1(Async_kernel_Ivar0[3], 0);
    caml_call1(f, result);
    return result;
   }
   function bind(t, f){
    var bind_result = caml_call1(Async_kernel_Ivar0[3], 0);
    upon
     (t,
      function(a){
       var _a_ = caml_call1(f, a);
       return caml_call2(Async_kernel_Ivar0[12], bind_result, _a_);
      });
    return bind_result;
   }
   function add_handler(t, f, execution_context){
    return caml_call3(Async_kernel_Ivar0[16], t, f, execution_context);
   }
   function remove_handler(t, h){
    return caml_call2(Async_kernel_Ivar0[17], t, h);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred0);
   var
    Async_kernel_Deferred0 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       return$0,
       upon,
       bind,
       [0, Async_kernel_Ivar0[14][1]],
       add_handler,
       remove_handler];
   runtime.caml_register_global
    (13, Async_kernel_Deferred0, cst_Async_kernel_Deferred0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar0, Core__Binable, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar$0 = "Async_kernel__Ivar",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Core_Option = global_data.Core__Option,
    Core_Binable = global_data.Core__Binable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/ivar.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    sexp_of_t = Async_kernel_Ivar0[1],
    invariant = Async_kernel_Ivar0[2],
    create = Async_kernel_Ivar0[3],
    create_full = Async_kernel_Ivar0[4],
    peek = Async_kernel_Ivar0[6],
    value_exn = Async_kernel_Ivar0[7],
    is_empty = Async_kernel_Ivar0[9],
    is_full = Async_kernel_Ivar0[10],
    equal = Async_kernel_Ivar0[11],
    fill = Async_kernel_Ivar0[13],
    has_handlers = Async_kernel_Ivar0[18],
    read = Async_kernel_Deferred0[3],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar = cst_Async_kernel_Ivar$0;
   function fill_if_empty(t, v){
    var _a_ = caml_call1(is_empty, t);
    return _a_ ? caml_call2(fill, t, v) : _a_;
   }
   function to_binable(t){return caml_call1(peek, t);}
   function of_binable(param){
    if(! param) return caml_call1(create, 0);
    var a = param[1];
    return caml_call1(create_full, a);
   }
   var
    include =
      caml_call1
       (caml_call1
         (Core_Binable[7],
          [0,
           Core_Option[1],
           Core_Option[2],
           Core_Option[3],
           Core_Option[4],
           Core_Option[5]]),
        [0, to_binable, of_binable]),
    bin_shape_t = include[1],
    bin_size_t = include[2],
    bin_write_t = include[3],
    bin_read_t = include[4],
    bin_read_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar);
   var
    Async_kernel_Ivar =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       sexp_of_t,
       invariant,
       equal,
       create,
       create_full,
       fill,
       fill_if_empty,
       is_empty,
       is_full,
       read,
       peek,
       value_exn,
       has_handlers];
   runtime.caml_register_global
    (15, Async_kernel_Ivar, cst_Async_kernel_Ivar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monad_sequence
//# unitInfo: Requires: Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monad_sequenc$0 = "Async_kernel__Monad_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monad_sequenc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/monad_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, "Parallel"],
    _b_ = [0, "Sequential"],
    _c_ = [0, "Max_concurrent_jobs"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monad_sequenc = cst_Async_kernel_Monad_sequenc$0;
   function sexp_of_how(param){
    if(typeof param === "number") return -676829465 <= param ? _a_ : _b_;
    var v_001 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[356], v_001), 0]]];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monad_sequenc);
   var Async_kernel_Monad_sequence = [0, sexp_of_how];
   runtime.caml_register_global
    (15, Async_kernel_Monad_sequence, cst_Async_kernel_Monad_sequenc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred1
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred0, Async_kernel__Ivar, Async_kernel__Monad_sequence, Async_kernel__Scheduler1, Base__Monad, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred1$0 = "Async_kernel__Deferred1",
    cst_async_kernel$0 = "async_kernel",
    cst_src_deferred1_ml = "src/deferred1.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad,
    Async_kernel_Monad_sequence = global_data.Async_kernel__Monad_sequence;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_deferred1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    sexp_of_t = Async_kernel_Deferred0[1],
    invariant = Async_kernel_Deferred0[2],
    of_ivar = Async_kernel_Deferred0[3],
    create = Async_kernel_Deferred0[4],
    peek = Async_kernel_Deferred0[5],
    value_exn = Async_kernel_Deferred0[6],
    is_determined = Async_kernel_Deferred0[7],
    upon = Async_kernel_Deferred0[9],
    Handler = Async_kernel_Deferred0[11],
    add_handler = Async_kernel_Deferred0[12],
    remove_handler = Async_kernel_Deferred0[13],
    _a_ = [0, cst_src_deferred1_ml, 120, 10],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred1 = cst_Async_kernel_Deferred1$0;
   function never(param){
    var _F_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call1(Async_kernel_Ivar[18], _F_);
   }
   var
    of_ivar$0 = Async_kernel_Deferred0[3],
    return$0 = Async_kernel_Deferred0[8],
    upon$0 = Async_kernel_Deferred0[9],
    bind = Async_kernel_Deferred0[10],
    map =
      [0,
       -198771759,
       function(t, f){
        var result = caml_call1(Async_kernel_Ivar[12], 0);
        caml_call2
         (upon$0,
          t,
          function(a){
           var _E_ = caml_call1(f, a);
           return caml_call2(Async_kernel_Ivar[14], result, _E_);
          });
        return caml_call1(of_ivar$0, result);
       }],
    M = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = M[1],
    symbol_map = M[2],
    Monad_infix = M[3],
    bind$0 = M[4],
    map$0 = M[6],
    join = M[7],
    ignore_m = M[8],
    return$1 = Async_kernel_Deferred0[8],
    include = M[11],
    symbol_bind$0 = include[2],
    symbol_map$0 = include[3],
    return$2 = Async_kernel_Deferred0[8],
    include$0 = M[11][4],
    bind$1 = include$0[2],
    map$1 = include$0[3],
    both = include$0[4],
    Open_on_rhs = include$0[5],
    return$3 = Async_kernel_Deferred0[8],
    Let_syntax = [0, bind$1, map$1, both, Open_on_rhs, return$3],
    Let_syntax$0 = [0, symbol_bind$0, symbol_map$0, return$2, Let_syntax],
    unit = caml_call1(Let_syntax$0[3], 0);
   function both$0(t1, t2){
    return caml_call1
            (create,
             function(result){
              return caml_call2
                      (upon,
                       t1,
                       function(a1){
                        return caml_call2
                                (upon,
                                 t2,
                                 function(a2){
                                  return caml_call2
                                          (Async_kernel_Ivar[14], result, [0, a1, a2]);
                                 });
                       });
             });
   }
   var
    symbol_bind$1 = Monad_infix[1],
    symbol_map$1 = Monad_infix[2],
    Infix = [0, symbol_bind$1, symbol_map$1, upon, both$0];
   function don_t_wait_for(param){return 0;}
   function map$2(param, f2){
    var f1 = param[2], t = param[1];
    return [0, t, function(x){return caml_call1(f2, caml_call1(f1, x));}];
   }
   var Choice = [0, map$2];
   function process(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var rest = param$0[3], handler = param$0[2], t = param$0[1];
     caml_call2(remove_handler, t, handler);
     var param$0 = rest;
    }
   }
   var Unregister = [0, process];
   function choice(t, f){return [0, t, f];}
   function enabled(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _A_ = caml_call1(Async_kernel_Ivar[16], result);
     if(! _A_) return _A_;
     caml_call1(Unregister[1], unregisters[1]);
     function _B_(param){
      function _C_(ac, param){
       var f = param[2], t = param[1], match = caml_call1(peek, t);
       if(! match) return ac;
       var v = match[1];
       return [0, caml_call1(f, v), ac];
      }
      var _D_ = caml_call3(Core_List[10], choices, 0, _C_);
      return caml_call1(Core_List[34], _D_);
     }
     return caml_call2(Async_kernel_Ivar[14], result, _B_);
    }
    var
     _y_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _y_);
    function _z_(acc, param){
     var t = param[1];
     return [0,
             t,
             caml_call3
              (Async_kernel_Deferred0[12], t, ready, execution_context),
             acc];
    }
    unregisters[1] = caml_call3(Core_List[10], choices, 0, _z_);
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function choose_result(choices){
    var choices$0 = choices;
    for(;;){
     if(! choices$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      choices$1 = choices$0[2],
      match = choices$0[1],
      f = match[2],
      t = match[1],
      match$0 = caml_call1(peek, t);
     if(match$0){var v = match$0[1]; return caml_call1(f, v);}
     var choices$0 = choices$1;
    }
   }
   function choose(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _w_ = caml_call1(Async_kernel_Ivar[16], result);
     if(! _w_) return _w_;
     caml_call1(Unregister[1], unregisters[1]);
     var _x_ = choose_result(choices);
     return caml_call2(Async_kernel_Ivar[14], result, _x_);
    }
    var
     _u_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _u_);
    function _v_(acc, param){
     var t = param[1];
     return [0,
             t,
             caml_call3
              (Async_kernel_Deferred0[12], t, ready, execution_context),
             acc];
    }
    unregisters[1] = caml_call3(Core_List[10], choices, 0, _v_);
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function any_f(ts, f){
    function _t_(t){return [0, t, f];}
    return choose(caml_call2(Core_List[72], ts, _t_));
   }
   function any(ts){return any_f(ts, function(_s_){return _s_;});}
   function any_unit(ts){return any_f(ts, function(_r_){return 0;});}
   function for$0(start, to, do$0){
    function loop(i){
     if(caml_call2(Core[91], i, to)) return caml_call1(Let_syntax$0[3], 0);
     function _p_(param){return loop(i + 1 | 0);}
     var _q_ = caml_call1(do$0, i);
     return caml_call2(Let_syntax$0[4][1], _q_, _p_);
    }
    return loop(start);
   }
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               function _n_(param){
                if(990972795 <= param[1]){
                 var state = param[2];
                 return loop(state);
                }
                var result = param[2];
                return caml_call2(Async_kernel_Ivar[14], finished, result);
               }
               var _o_ = caml_call1(f, state);
               return caml_call2(Infix[3], _o_, _n_);
              }
              return loop(state);
             });
   }
   function forever(state, f){
    var
     _j_ = Core[159],
     _k_ =
       repeat_until_finished
        (state,
         function(state){
          function _l_(state){return [0, 990972795, state];}
          var _m_ = caml_call1(f, state);
          return caml_call2(Let_syntax$0[4][2], _m_, _l_);
         });
    return caml_call2(Infix[3], _k_, _j_);
   }
   var sexp_of_how = Async_kernel_Monad_sequence[1];
   function fold(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1];
               function _h_(b){return loop(xs, b);}
               var _i_ = caml_call2(f, b, x);
               return caml_call2(Infix[3], _i_, _h_);
              }
              return loop(t, init);
             });
   }
   function seqmap(t, f){
    var
     _d_ = Core_List[34],
     _e_ =
       fold
        (t,
         0,
         function(bs, a){
          function _f_(b){return [0, b, bs];}
          var _g_ = caml_call1(f, a);
          return caml_call2(Infix[2], _g_, _f_);
         });
    return caml_call2(Infix[2], _e_, _d_);
   }
   function all(ds){return seqmap(ds, function(_c_){return _c_;});}
   function all_unit(ds){return fold(ds, 0, function(param, d){return d;});}
   function ok(x){
    function _b_(x){return [0, x];}
    return caml_call2(Infix[2], x, _b_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred1);
   var
    Async_kernel_Deferred1 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       upon,
       Handler,
       add_handler,
       remove_handler,
       never,
       M,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       map$0,
       join,
       ignore_m,
       return$1,
       Let_syntax$0,
       unit,
       both$0,
       Infix,
       don_t_wait_for,
       Choice,
       Unregister,
       choice,
       enabled,
       choose_result,
       choose,
       any_f,
       any,
       any_unit,
       for$0,
       repeat_until_finished,
       forever,
       sexp_of_how,
       fold,
       seqmap,
       all,
       all_unit,
       ok];
   runtime.caml_register_global
    (20, Async_kernel_Deferred1, cst_Async_kernel_Deferred1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_std
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_std = "Async_kernel__Deferred_std",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_std);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_std.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = Async_kernel_Deferred1[25],
    symbol = _a_[3],
    ppx_both = _a_[4],
    include = Async_kernel_Deferred1[22],
    symbol_bind = include[1],
    symbol_map = include[2],
    return$0 = include[3],
    Let_syntax = include[4],
    choice = Async_kernel_Deferred1[29],
    choose = Async_kernel_Deferred1[32],
    don_t_wait_for = Async_kernel_Deferred1[26],
    never = Async_kernel_Deferred1[12],
    upon = Async_kernel_Deferred1[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_std);
   var
    Async_kernel_Deferred_std =
      [0,
       symbol,
       ppx_both,
       symbol_bind,
       symbol_map,
       Let_syntax,
       choice,
       choose,
       don_t_wait_for,
       never,
       return$0,
       upon];
   runtime.caml_register_global
    (12, Async_kernel_Deferred_std, cst_Async_kernel_Deferred_std);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar_filler
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar_filler$0 = "Async_kernel__Ivar_filler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar_filler_ml = "src/ivar_filler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar_filler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar_filler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_attempt_to_fill_full_ivar = "attempt to fill full ivar",
    _d_ = [0, "_"],
    _c_ = [0, cst_src_ivar_filler_ml, 15, 20],
    _e_ = [0, cst_src_ivar_filler_ml, 12, 154, 176],
    _a_ = [0, "Empty"],
    _b_ = [0, "Full"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar_filler = cst_Async_kernel_Ivar_filler$0;
   function sexp_of_t(of_a_005, x_006){
    function _i_(param){
     if(! param) return _b_;
     var
      arg0_002 = param[1],
      res0_003 = caml_call2(Async_kernel_Ivar[9], of_a_005, arg0_002);
     return [1, [0, _a_, [0, res0_003, 0]]];
    }
    return caml_call2(Core[501], _i_, x_006);
   }
   function invariant(param, t){
    function _g_(param){
     var match = t[1];
     if(! match) return 0;
     var ivar = match[1];
     if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
    function _h_(x_007){
     return sexp_of_t(function(param){return _d_;}, x_007);
    }
    return caml_call4(Base_Invariant[1], _e_, t, _h_, _g_);
   }
   function create(param){
    var ivar = caml_call1(Async_kernel_Ivar[12], 0), t = [0, [0, ivar]];
    return [0, t, caml_call1(Async_kernel_Ivar[18], ivar)];
   }
   function is_empty(t){return t[1] ? 1 : 0;}
   function fill(t, a){
    var match = t[1];
    if(match){
     var i = match[1];
     t[1] = 0;
     return caml_call2(Async_kernel_Ivar[14], i, a);
    }
    var
     _f_ = caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_fill_full_ivar);
    return caml_call1(Core[253], _f_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar_filler);
   var
    Async_kernel_Ivar_filler =
      [0, sexp_of_t, invariant, create, is_empty, fill];
   runtime.caml_register_global
    (22, Async_kernel_Ivar_filler, cst_Async_kernel_Ivar_filler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Tail
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Ivar, Base__Field, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Tail$0 = "Async_kernel__Tail",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core;
   global_data.Base__Field;
   var
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Tail$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/tail.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_stream_is_closed = "stream is closed",
    cst_open_tail = "<open tail>",
    cst_closed_tail = "<closed tail>",
    _a_ = [0, "..."],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Tail = cst_Async_kernel_Tail$0;
   function sexp_of_t(sexp_of_a, t){
    var d = t, ac = 0;
    for(;;){
     var match = caml_call1(Async_kernel_Deferred1[5], d);
     if(! match) return [1, caml_call1(Core_List[34], [0, _a_, ac])];
     var match$0 = match[1];
     if(! match$0) return [1, caml_call1(Core_List[34], ac)];
     var
      t$0 = match$0[2],
      a = match$0[1],
      ac$0 = [0, caml_call1(sexp_of_a, a), ac],
      d = t$0,
      ac = ac$0;
    }
   }
   function next(t){return t;}
   var Stream = [0, sexp_of_t, next];
   function sexp_of_t$0(param, t){
    var
     _d_ =
       caml_call1(Async_kernel_Ivar[16], t[1])
        ? cst_open_tail
        : cst_closed_tail;
    return [0, _d_];
   }
   function create(param){return [0, caml_call1(Async_kernel_Ivar[12], 0)];}
   function collect(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function fill_exn(t, v){
    if(! is_closed(t)) return caml_call2(Async_kernel_Ivar[14], t[1], v);
    var _c_ = caml_call1(Sexplib0_Sexp_conv[7], cst_stream_is_closed);
    return caml_call1(Core[253], _c_);
   }
   function close_exn(t){return fill_exn(t, 0);}
   function close_if_open(t){
    var _b_ = 1 - is_closed(t);
    return _b_ ? caml_call2(Async_kernel_Ivar[14], t[1], 0) : _b_;
   }
   function extend(t, v){
    var next = caml_call1(Async_kernel_Ivar[12], 0);
    fill_exn(t, [0, v, caml_call1(Async_kernel_Ivar[18], next)]);
    t[1] = next;
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Tail);
   var
    Async_kernel_Tail =
      [0,
       sexp_of_t$0,
       create,
       extend,
       close_exn,
       close_if_open,
       is_closed,
       Stream,
       collect];
   runtime.caml_register_global
    (23, Async_kernel_Tail, cst_Async_kernel_Tail$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Ivar_filler, Async_kernel__Monitor0, Async_kernel__Scheduler1, Async_kernel__Tail, Async_kernel_config, Base__Backtrace, Base__Exn, Base__Field, Base__Invariant, Core, Core__Bag, Core__Error, Core__Info, Core__List, Core__Or_error, Core__Result, Core__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Async_kernel_Monitor$0 = "Async_kernel__Monitor",
    cst_Caught_by_monitor = "Caught by monitor ",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn",
    cst_file = "file ",
    cst_src_monitor_ml = "src/monitor.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    job_queue = 'Called from file "job_queue.ml"',
    deferred0 = 'Called from file "deferred0.ml"',
    deferred1 = 'Called from file "deferred1.ml"',
    monitor = 'Called from file "monitor.ml"',
    import0 = 'Raised at file "import0.ml"',
    error = 'Called from file "error.ml"',
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar_filler = global_data.Async_kernel__Ivar_filler,
    Base_Exn = global_data.Base__Exn;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Result = global_data.Core__Result,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Bag = global_data.Core__Bag,
    Core_List = global_data.Core__List,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Info = global_data.Core__Info,
    Core_String = global_data.Core__String,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_monitor_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    has_seen_error = Async_kernel_Monitor0[4],
    name = Async_kernel_Monitor0[14],
    Fields = Async_kernel_Monitor0[15],
    sexp_of_t = Async_kernel_Monitor0[18],
    create_with_parent = Async_kernel_Monitor0[20],
    main = Async_kernel_Monitor0[21],
    cst_Monitor_catch_got_unexpect =
      "Monitor.catch got unexpected empty stream",
    _q_ = [0, "finally_exn"],
    _r_ = [0, cst_exn],
    cst_Async_finally = "Async finally",
    _s_ = [0, 523273847],
    _t_ = [0, 0],
    _u_ = [0, "finally"],
    cst_Monitor_protect = "Monitor.protect",
    cst_try_with_join_or_error = "try_with_join_or_error",
    cst_try_with_or_error = "try_with_or_error",
    _p_ = [0, 3903734],
    _o_ = [0, cst_src_monitor_ml, 422, 17],
    _n_ = [0, cst_exn],
    cst_failed_to_set_Monitor_Expe =
      "failed to set [Monitor.Expert.try_with_log_exn]",
    _l_ = [0, 3553398],
    _m_ = [1, 0],
    cst_Monitor_send_exn_found_lis =
      "Monitor.send_exn found listening monitor",
    cst_Monitor_send_exn = "Monitor.send_exn",
    cst_monitor_ml_Error = "monitor.ml.Error",
    _k_ = [0, cst_src_monitor_ml, 199, 6],
    _d_ =
      [0,
       [11, cst_file, [3, 0, [11, ", line LINE, characters C1-C2", 0]]],
       "file %S, line LINE, characters C1-C2"],
    _i_ =
      [0,
       [11,
        cst_file,
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11, ", characters ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]]]]]],
       "file %S, line %d, characters %d-%d"],
    _e_ =
      [0,
       [11, cst_Caught_by_monitor, [2, 0, [11, " at ", [2, 0, 0]]]],
       "Caught by monitor %s at %s"],
    _g_ =
      [0, [11, "Caught by monitor at ", [2, 0, 0]], "Caught by monitor at %s"],
    _h_ = [0, [11, cst_Caught_by_monitor, [2, 0, 0]], "Caught by monitor %s"],
    _f_ = [0, "backtrace_history"],
    _c_ = [0, cst_src_monitor_ml, 46, 23],
    _a_ = [0, cst_src_monitor_ml, 20, 44],
    _b_ = [0, cst_src_monitor_ml, 13, 226, 248],
    cst_Async_kernel_Monitor_Monit = "Async_kernel__Monitor.Monitor_exn",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor = cst_Async_kernel_Monitor$0;
   function invariant(t){
    function _ax_(param){
     function _az_(_aM_){return 0;}
     function _aA_(_aL_){return 0;}
     function _aB_(_aK_){return 0;}
     function _aC_(_aJ_){return 0;}
     function f(next_error){
      if(caml_call1(Async_kernel_Ivar[16], next_error)) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
     var _ay_ = caml_call2(Base_Invariant[2], t, f);
     function _aD_(_aI_){return 0;}
     function _aE_(_aH_){return 0;}
     function _aF_(_aG_){return 0;}
     return caml_call8
             (Fields[13], _aF_, _aE_, _aD_, _ay_, _aC_, _aB_, _aA_, _az_);
    }
    return caml_call4(Base_Invariant[1], _b_, t, sexp_of_t, _ax_);
   }
   function current_execution_context(param){
    var _aw_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call1(Async_kernel_Scheduler1[72], _aw_);
   }
   function current(param){
    var _av_ = current_execution_context(0);
    return caml_call1(Async_kernel_Execution_context[4], _av_);
   }
   function detach(t){t[8] = 0; return 0;}
   function detach_and_iter_errors(t, f){
    detach(t);
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     handler_state_ref = [0, 0];
    function run_f(exn){
     var match = handler_state_ref[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var bag_elt = match[1];
     try{var _au_ = caml_call1(f, exn); return _au_;}
     catch(inner_exn$0){
      var inner_exn = caml_wrap_exception(inner_exn$0);
      handler_state_ref[1] = 1;
      caml_call2(Core_Bag[26], t[5], bag_elt);
      throw caml_maybe_attach_backtrace(inner_exn, 0);
     }
    }
    handler_state_ref[1] =
     [0, caml_call2(Core_Bag[23], t[5], [0, execution_context, run_f])];
    return 0;
   }
   function detach_and_get_error_stream(t){
    detach(t);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    t[6] = [0, tail, t[6]];
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function get_next_error(t){return caml_call1(Async_kernel_Ivar[18], t[4]);}
   function detach_and_get_next_error(t){detach(t); return get_next_error(t);}
   function create(here, info, name, param){
    var parent = current(0);
    return caml_call4(create_with_parent, here, info, name, [0, parent]);
   }
   function backtrace(t){return t[2];}
   function extract_exn(t){return t[1];}
   var
    Monitor_exn =
      [248, cst_Async_kernel_Monitor_Monit, runtime.caml_fresh_oo_id(0)];
   function _j_(param){
    if(param[1] !== Monitor_exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var
     t = param[2],
     monitor$0 = t[4],
     backtrace_history = t[3],
     backtrace = t[2],
     exn = t[1],
     s = caml_call1(Core_Info[9], monitor$0[1]),
     name = runtime.caml_string_notequal(s, cst$1) ? [0, s] : 0,
     match$0 = monitor$0[2];
    if(match$0)
     var
      here = match$0[1],
      column = here[4] - here[3] | 0,
      _ao_ =
        Core[541]
         ? caml_call2(Core[257], _d_, here[1])
         : caml_call5(Core[257], _i_, here[1], here[2], column, column),
      pos = [0, _ao_];
    else
     var pos = 0;
    if(pos){
     var pos$0 = pos[1];
     if(name)
      var
       name$0 = name[1],
       _ap_ = [0, caml_call3(Core[257], _e_, name$0, pos$0), 0];
     else
      var _ap_ = [0, caml_call2(Core[257], _g_, pos$0), 0];
     var monitor$1 = _ap_;
    }
    else if(name)
     var
      name$1 = name[1],
      monitor$1 = [0, caml_call2(Core[257], _h_, name$1), 0];
    else
     var monitor$1 = 0;
    if(backtrace)
     var
      backtrace$0 = backtrace[1],
      backtrace$1 = caml_call1(Base_Backtrace[4], backtrace$0);
    else
     var backtrace$1 = 0;
    a:
    {
     if(backtrace$1){
      var rest = backtrace$1[2], t1 = backtrace$1[1];
      if(caml_call2(Core_String[57], t1, import0)){
       b:
       {
        if(rest){
         var rest$0 = rest[2], t2 = rest[1];
         if(caml_call2(Core_String[57], t2, error)){
          c:
          {
           if(rest$0){
            var rest$1 = rest$0[2], t3 = rest$0[1];
            if(caml_call2(Core_String[57], t3, error)){var rest$2 = rest$1; break c;}
           }
           var rest$2 = rest$0;
          }
          var rest$3 = rest$2;
          break b;
         }
        }
        var rest$3 = rest;
       }
       var traces = rest$3;
       break a;
      }
     }
     var traces = backtrace$1;
    }
    var match = caml_call1(Core_List[34], traces);
    a:
    {
     if(match){
      var rest$4 = match[2], t1$0 = match[1];
      if(caml_call2(Core_String[57], t1$0, job_queue)){
       if(rest$4){
        var rest$5 = rest$4[2], t2$0 = rest$4[1];
        if(caml_call2(Core_String[57], t2$0, job_queue)){
         b:
         if(rest$5){
          var rest$6 = rest$5[2], t2$1 = rest$5[1];
          if
           (!
            caml_call2(Core_String[57], t2$1, deferred0)
            &&
             !
             caml_call2(Core_String[57], t2$1, deferred1)
             && ! caml_call2(Core_String[57], t2$1, monitor))
           break b;
          var _aq_ = caml_call1(Core_List[34], rest$6);
          break a;
         }
         var _aq_ = caml_call1(Core_List[34], rest$5);
         break a;
        }
       }
       var _aq_ = caml_call1(Core_List[34], rest$4);
       break a;
      }
     }
     var _aq_ = traces;
    }
    var backtrace$2 = caml_call2(Core[157], _aq_, monitor$1);
    function list_if_not_empty(l){return l ? [0, l] : 0;}
    var
     match$1 = list_if_not_empty(backtrace$2),
     _ar_ = list_if_not_empty(backtrace_history),
     match$2 = 0;
    if(_ar_)
     var
      x_002 = _ar_[1],
      match$3 =
        [0,
         [1,
          [0, _f_, [0, caml_call2(Core[421], Base_Backtrace[1], x_002), 0]]],
         match$2];
    else
     var match$3 = match$2;
    if(match$1)
     var
      x_001 = match$1[1],
      _as_ = [0, caml_call2(Core[421], Core[471], x_001), match$3];
    else
     var _as_ = match$3;
    var sexp = [1, [0, caml_call1(Core[537], exn), _as_]];
    if(0 === sexp[0]) var _at_ = [0, sexp, 0]; else var l = sexp[1], _at_ = l;
    return [1,
            [0, caml_call1(Sexplib0_Sexp_conv[7], cst_monitor_ml_Error), _at_]];
   }
   caml_call4(Sexplib_Conv[70][1], 0, 0, Monitor_exn, _j_);
   function extract_exn$0(exn){
    if(exn[1] !== Monitor_exn) return exn;
    var error = exn[2];
    return error[1];
   }
   function send_exn(t, opt, exn){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 3553398;
    if(exn[1] === Monitor_exn)
     var exn$0 = exn;
    else{
     if(typeof backtrace === "number")
      var backtrace$0 = caml_call1(Base_Backtrace[6][5], exn);
     else
      var b = backtrace[2], backtrace$0 = [0, b];
     var
      backtrace_history = current_execution_context(0)[4],
      exn$0 = [0, Monitor_exn, [0, exn, backtrace$0, backtrace_history, t]];
    }
    if(Async_kernel_Debug[7]){
     var
      _ai_ =
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          res0_005 = caml_call1(sexp_of_t, arg0_003),
          res1_006 = caml_call1(Core[537], arg1_004);
         return [1, [0, res0_005, [0, res1_006, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_Monitor_send_exn, [0, t, exn$0], _ai_);
    }
    t[7] = 1;
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0), t$0 = t;
    for(;;){
     caml_call2(Async_kernel_Ivar[14], t$0[4], exn$0);
     t$0[4] = caml_call1(Async_kernel_Ivar[12], 0);
     var match = t$0[8];
     if(typeof match === "number") break;
     var parent = match[1], t$0 = parent;
    }
    if(match){
     var
      _aj_ = caml_call1(Async_kernel_config[31][1], 0),
      _ak_ = caml_call1(Async_kernel_Scheduler1[71], 0);
     return caml_call2
             (caml_call1(Async_kernel_Scheduler1[76], _ak_), exn$0, _aj_);
    }
    if(Async_kernel_Debug[7]){
     var
      _al_ =
        function(param){
         var
          arg1_008 = param[2],
          arg0_007 = param[1],
          res0_009 = caml_call1(sexp_of_t, arg0_007),
          res1_010 = caml_call1(Core[537], arg1_008);
         return [1, [0, res0_009, [0, res1_010, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn_found_lis,
       [0, t$0, exn$0],
       _al_);
    }
    function _am_(param){
     var f = param[2], execution_context = param[1];
     return caml_call4
             (Async_kernel_Scheduler1[63],
              scheduler,
              execution_context,
              f,
              exn$0);
    }
    caml_call2(Core_Bag[7], t$0[5], _am_);
    function _an_(tail){return caml_call2(Async_kernel_Tail[3], tail, exn$0);}
    return caml_call2(Core_List[9], t$0[6], _an_);
   }
   function within_context(context, f){
    function _ag_(param){
     var match = caml_call1(Core_Result[47], f);
     if(0 === match[0]){var x = match[1]; return [0, x];}
     var exn = match[1];
     send_exn
      (caml_call1(Async_kernel_Execution_context[4], context), _l_, exn);
     return _m_;
    }
    var _ah_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler1[74], _ah_), context, _ag_);
   }
   function within_gen(monitor, priority, f){
    var
     _af_ = current_execution_context(0),
     tmp_context =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _af_);
    return within_context(tmp_context, f);
   }
   function within(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return caml_call1(Async_kernel_Deferred1[12], 0);
    var d = match[1];
    return d;
   }
   function within_v(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   function within$0(monitor, priority, f){
    return 0 === within_gen(monitor, priority, f)[0] ? 0 : 0;
   }
   function schedule_with_data(monitor, priority, work, x){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     _ad_ = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     _ae_ =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _ad_);
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, _ae_, work, x);
   }
   function schedule(monitor, priority, work){
    return schedule_with_data(monitor, priority, work, 0);
   }
   function upon_work_fill_i(param){
    var i = param[2], work = param[1];
    function _ab_(a){return caml_call2(Async_kernel_Ivar[14], i, a);}
    var _ac_ = caml_call1(work, 0);
    return caml_call2(Async_kernel_Deferred_std[11], _ac_, _ab_);
   }
   function schedule$0(monitor, priority, work){
    var i = caml_call1(Async_kernel_Ivar[12], 0);
    schedule_with_data(monitor, priority, upon_work_fill_i, [0, work, i]);
    return caml_call1(Async_kernel_Ivar[18], i);
   }
   function preserve_execution_context(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    function _aa_(a){
     return caml_call4
             (Async_kernel_Scheduler1[63], scheduler, execution_context, f, a);
    }
    return caml_call1(Core[258], _aa_);
   }
   function preserve_execution_context$0(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    function call_and_fill(param){
     var i = param[3], a = param[2], f = param[1];
     function ___(r){return caml_call2(Async_kernel_Ivar[14], i, r);}
     var _$_ = caml_call1(f, a);
     return caml_call2(Async_kernel_Deferred_std[11], _$_, ___);
    }
    function _Y_(a){
     function _Z_(i){
      return caml_call4
              (Async_kernel_Scheduler1[63],
               scheduler,
               execution_context,
               call_and_fill,
               [0, f, a, i]);
     }
     return caml_call1(Async_kernel_Deferred1[4], _Z_);
    }
    return caml_call1(Core[258], _Y_);
   }
   function stream_iter(stream, f){
    function loop(stream){
     function _W_(param){
      if(! param) return 0;
      var stream = param[2], v = param[1];
      loop(stream);
      return caml_call1(f, v);
     }
     var _X_ = caml_call1(Async_kernel_Tail[7][2], stream);
     return caml_call2(Async_kernel_Deferred_std[1], _X_, _W_);
    }
    return loop(stream);
   }
   function create$0(here, info, name, run, f){
    var
     monitor = caml_call4(create_with_parent, here, info, name, 0),
     exns = detach_and_get_error_stream(monitor),
     ok =
       523273847 <= run
        ? schedule$0([0, monitor], 0, f)
        : within([0, monitor], 0, f);
    return [0, ok, exns];
   }
   function fill_result_and_handle_backgro
   (result_filler, result, exns, handle_exns_after_result){
    var _V_ = caml_call1(Async_kernel_Ivar_filler[4], result_filler);
    return _V_
            ? (caml_call2
               (Async_kernel_Ivar_filler[5], result_filler, result),
              caml_call1(handle_exns_after_result, exns))
            : _V_;
   }
   var
    try_with_log_exn =
      [0,
       function(exn){
        var
         _T_ = [0, [1, [0, _n_, [0, caml_call1(Base_Exn[1], exn), 0]]], 0],
         _U_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_failed_to_set_Monitor_Expe),
             _T_]];
        return caml_call1(Core[253], _U_);
       }],
    Expert = [0, try_with_log_exn];
   function try_with(here, info, opt, _O_, _N_, _M_, f$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst$0;
    if(_O_)
     var sth$0 = _O_[1], do_extract_exn = sth$0;
    else
     var do_extract_exn = 0;
    if(_N_) var sth$1 = _N_[1], run = sth$1; else var run = 3903734;
    if(_M_) var sth$2 = _M_[1], rest = sth$2; else var rest = -146189108;
    var
     match = create$0(here, info, [0, name], run, f$0),
     exns = match[2],
     ok = match[1];
    if(typeof rest === "number")
     if(3804260 <= rest)
      var handle_exn = Expert[1][1];
     else
      var
       parent = current(0),
       handle_exn = function(exn){return send_exn(parent, 0, exn);};
    else
     var
      f = rest[2],
      parent$0 = current(0),
      handle_exn =
        function(exn){
         return within$0
                 ([0, parent$0],
                  0,
                  function(param){return caml_call1(f, exn);});
        };
    function handle_exns_after_result(exns){return stream_iter(exns, handle_exn);
    }
    return within
            ([0, main],
             0,
             function(param){
              if(caml_call1(Async_kernel_Deferred1[7], ok)){
               handle_exns_after_result(exns);
               var _P_ = [0, caml_call1(Async_kernel_Deferred1[6], ok)];
               return caml_call1(Async_kernel_Deferred_std[10], _P_);
              }
              var
               match = caml_call1(Async_kernel_Ivar_filler[3], 0),
               result = match[2],
               result_filler = match[1];
              function _Q_(res){
               return fill_result_and_handle_backgro
                       (result_filler, [0, res], exns, handle_exns_after_result);
              }
              caml_call2(Async_kernel_Deferred_std[11], ok, _Q_);
              function _R_(param){
               if(! param)
                throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
               var
                exns = param[2],
                exn = param[1],
                exn$0 = do_extract_exn ? extract_exn$0(exn) : exn;
               return fill_result_and_handle_backgro
                       (result_filler, [1, exn$0], exns, handle_exns_after_result);
              }
              var _S_ = caml_call1(Async_kernel_Tail[7][2], exns);
              caml_call2(Async_kernel_Deferred_std[11], _S_, _R_);
              return result;
             });
   }
   function try_with_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_or_error;
    var arg = Core_Or_error[38];
    function _K_(eta){return caml_call2(arg, 0, eta);}
    var _L_ = try_with(here, info, [0, name], extract_exn, _p_, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _L_, _K_);
   }
   function try_with_join_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_join_or_error;
    var
     _I_ = Core_Or_error[27],
     _J_ = try_with_or_error(here, info, [0, name], extract_exn, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _J_, _I_);
   }
   function protect(here, info, opt, extract_exn, run, rest, f, finally$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Monitor_protect;
    function _B_(r){
     function _D_(fr){
      if(0 === r[0]){
       var r$0 = r[1];
       if(0 === fr[0]) return r$0;
       var e = fr[1];
      }
      else{
       var exn = r[1];
       if(0 !== fr[0]){
        var
         finally_exn = fr[1],
         _F_ =
           [0, [1, [0, _q_, [0, caml_call1(Core[537], finally_exn), 0]]], 0],
         _G_ = [0, [1, [0, _r_, [0, caml_call1(Core[537], exn), 0]]], _F_],
         _H_ =
           [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Async_finally), _G_]];
        return caml_call1(Core[253], _H_);
       }
       var e = exn;
      }
      throw caml_maybe_attach_backtrace(e, 0);
     }
     var _E_ = try_with(here, info, _u_, _t_, _s_, rest, finally$0);
     return caml_call2(Async_kernel_Deferred_std[5][2], _E_, _D_);
    }
    var _C_ = try_with(here, info, [0, name], extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred_std[5][1], _C_, _B_);
   }
   function handle_errors(here, info, name, f, handler){
    var
     match = create$0(here, info, name, 3903734, f),
     exns = match[2],
     ok = match[1];
    stream_iter(exns, handler);
    return ok;
   }
   function catch_stream(here, info, name, f){
    var
     exns =
       create$0
         (here,
          info,
          name,
          3903734,
          function(param){
           caml_call1(f, 0);
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          })
        [2];
    return exns;
   }
   function catch$0(here, info, name, f){
    function _x_(param){
     if(param){var x = param[1]; return x;}
     var
      _A_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Monitor_catch_got_unexpect);
     return caml_call1(Core[253], _A_);
    }
    var
     _y_ = catch_stream(here, info, name, f),
     _z_ = caml_call1(Async_kernel_Tail[7][2], _y_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _z_, _x_);
   }
   function catch_error(here, info, name, f){
    var arg = Core_Error[25];
    function _v_(eta){return caml_call2(arg, 0, eta);}
    var _w_ = catch$0(here, info, name, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function parent(t){
    var match = t[8];
    if(typeof match === "number") return match ? 0 : 0;
    var parent = match[1];
    return [0, parent];
   }
   function depth(t){
    var t$0 = t, n = 0;
    for(;;){
     var match = parent(t$0);
     if(! match) return n;
     var t$1 = match[1], n$0 = n + 1 | 0, t$0 = t$1, n = n$0;
    }
   }
   var For_tests = [0, parent, depth];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor);
   var
    Async_kernel_Monitor =
      [0,
       sexp_of_t,
       invariant,
       create,
       name,
       current,
       detach,
       detach_and_iter_errors,
       detach_and_get_next_error,
       detach_and_get_error_stream,
       get_next_error,
       [0, extract_exn, backtrace],
       Monitor_exn,
       extract_exn$0,
       has_seen_error,
       send_exn,
       try_with,
       try_with_or_error,
       try_with_join_or_error,
       handle_errors,
       catch_stream,
       catch$0,
       catch_error,
       protect,
       main,
       Expert,
       [0,
        within,
        within$0,
        within_v,
        schedule$0,
        schedule,
        within_context,
        preserve_execution_context,
        preserve_execution_context$0],
       For_tests];
   runtime.caml_register_global
    (79, Async_kernel_Monitor, cst_Async_kernel_Monitor$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_stream
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_stream$0 = "Async_kernel__Async_stream",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_stream_ml = "src/async_stream.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_stream$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_async_stream_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    include = Async_kernel_Tail[7],
    sexp_of_t = include[1],
    next = include[2],
    _b_ = [0, -146189108],
    _c_ = [0, 523273847],
    _a_ = [0, cst_src_async_stream_ml, 179, 18],
    cst_Stream_first_of_empty_stre = "Stream.first of empty stream",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_stream = cst_Async_kernel_Async_stream$0;
   function first_exn(t){
    function _aD_(param){
     if(param){var x = param[1]; return x;}
     var
      _aF_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stream_first_of_empty_stre);
     return caml_call1(Core[253], _aF_);
    }
    var _aE_ = caml_call1(next, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _aE_, _aD_);
   }
   function fold(t, init, f){
    function _ax_(result){
     function loop(t, b){
      function _ay_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, b);
       var t = param[2], v = param[1];
       function _aA_(_aC_){return loop(t, _aC_);}
       var _aB_ = caml_call2(f, b, v);
       return caml_call2(Async_kernel_Deferred_std[11], _aB_, _aA_);
      }
      var _az_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[11], _az_, _ay_);
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _ax_);
   }
   function fold$0(t, init, f){
    function _as_(result){
     function loop$0(counter, t, b){
      var
       _au_ = caml_call1(next, t),
       match = caml_call1(Async_kernel_Deferred1[5], _au_);
      if(! match){
       var
        _av_ = function(next){return loop_next(next, b);},
        _aw_ = caml_call1(next, t);
       return caml_call2(Async_kernel_Deferred_std[11], _aw_, _av_);
      }
      var next$0 = match[1];
      if(counter >= 50)
       return caml_trampoline_return(loop_next$0, [0, next$0, b]);
      var counter$0 = counter + 1 | 0;
      return loop_next$0(counter$0, next$0, b);
     }
     function loop_next$0(counter, next, b){
      if(! next) return caml_call2(Async_kernel_Ivar[14], result, b);
      var t = next[2], v = next[1], _at_ = caml_call2(f, b, v);
      if(counter >= 50) return caml_trampoline_return(loop$0, [0, t, _at_]);
      var counter$0 = counter + 1 | 0;
      return loop$0(counter$0, t, _at_);
     }
     function loop(t, b){return caml_trampoline(loop$0(0, t, b));}
     function loop_next(next, b){
      return caml_trampoline(loop_next$0(0, next, b));
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _as_);
   }
   function length(t){
    return fold$0(t, 0, function(n, param){return n + 1 | 0;});
   }
   function iter(t, f){
    return fold(t, 0, function(param, v){return caml_call1(f, v);});
   }
   function closed(t){
    var
     _ar_ = caml_call1(next, t),
     match = caml_call1(Async_kernel_Deferred1[5], _ar_);
    if(match && ! match[1])
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    return iter
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function iter$0(t, f){
    var
     _aq_ =
       iter
        (t,
         function(a){
          caml_call1(f, a);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call1(Async_kernel_Deferred_std[8], _aq_);
   }
   function create(f){
    var
     tail = caml_call1(Async_kernel_Tail[2], 0),
     t = caml_call1(Async_kernel_Tail[8], tail);
    caml_call1(f, tail);
    return t;
   }
   function unfold(b, f){
    return create
            (function(tail){
              function loop(b){
               function _ao_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var match = param[1], b = match[2], a = match[1];
                caml_call2(Async_kernel_Tail[3], tail, a);
                return loop(b);
               }
               var _ap_ = caml_call1(f, b);
               return caml_call2(Async_kernel_Deferred_std[11], _ap_, _ao_);
              }
              return loop(b);
             });
   }
   function of_list(l){
    return create
            (function(tail){
              function _an_(x){
               return caml_call2(Async_kernel_Tail[3], tail, x);
              }
              caml_call2(Core_List[9], l, _an_);
              return caml_call1(Async_kernel_Tail[4], tail);
             });
   }
   function to_list(s){
    var
     _al_ = Core_List[34],
     _am_ =
       fold
        (s,
         0,
         function(b, a){
          return caml_call1(Async_kernel_Deferred_std[10], [0, a, b]);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _am_, _al_);
   }
   function copy_to_tail(t, tail){
    return iter
            (t,
             function(a){
              var _ak_ = caml_call2(Async_kernel_Tail[3], tail, a);
              return caml_call1(Async_kernel_Deferred_std[10], _ak_);
             });
   }
   function append(t1, t2){
    return create
            (function(tail){
              function _ag_(param){
               function _ai_(param){
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _aj_ = copy_to_tail(t2, tail);
               return caml_call2(Async_kernel_Deferred_std[11], _aj_, _ai_);
              }
              var _ah_ = copy_to_tail(t1, tail);
              return caml_call2(Async_kernel_Deferred_std[11], _ah_, _ag_);
             });
   }
   function concat(t){
    return create
            (function(tail){
              function _ae_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var _af_ = iter(t, function(t){return copy_to_tail(t, tail);});
              return caml_call2(Async_kernel_Deferred_std[11], _af_, _ae_);
             });
   }
   function filter_deprecated(t, f){
    return create
            (function(tail){
              function _$_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _aa_ =
                 iter
                  (t,
                   function(v){
                    function _ab_(param){
                     return param ? caml_call2(Async_kernel_Tail[3], tail, v) : 0;
                    }
                    var
                     _ac_ = caml_call1(f, v),
                     _ad_ = caml_call1(Async_kernel_Deferred_std[10], _ac_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2], _ad_, _ab_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _aa_, _$_);
             });
   }
   function filter_map_deprecated(t, f){
    return create
            (function(tail){
              function _W_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _X_ =
                 iter
                  (t,
                   function(v){
                    function _Y_(param){
                     if(! param) return 0;
                     var v = param[1];
                     return caml_call2(Async_kernel_Tail[3], tail, v);
                    }
                    var
                     _Z_ = caml_call1(f, v),
                     ___ = caml_call1(Async_kernel_Deferred_std[10], _Z_);
                    return caml_call2(Async_kernel_Deferred_std[5][2], ___, _Y_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _X_, _W_);
             });
   }
   function map(t, f){
    return create
            (function(tail){
              function _S_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _T_ =
                 iter
                  (t,
                   function(v){
                    var
                     _U_ = caml_call1(Async_kernel_Tail[3], tail),
                     _V_ = caml_call1(f, v);
                    return caml_call2(Async_kernel_Deferred_std[4], _V_, _U_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _T_, _S_);
             });
   }
   function map$0(t, f){
    return map
            (t,
             function(a){
              var _R_ = caml_call1(f, a);
              return caml_call1(Async_kernel_Deferred_std[10], _R_);
             });
   }
   function first_n(s, n){
    return create
            (function(tail){
              function loop(s, n){
               if(caml_call2(Core[90], n, 0))
                return caml_call1(Async_kernel_Tail[4], tail);
               function _P_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var t = param[2], x = param[1];
                caml_call2(Async_kernel_Tail[3], tail, x);
                return loop(t, n - 1 | 0);
               }
               var _Q_ = caml_call1(next, s);
               return caml_call2(Async_kernel_Deferred_std[11], _Q_, _P_);
              }
              return loop(s, n);
             });
   }
   function available_now(t){
    var t$0 = t, ac = 0;
    for(;;){
     var
      _O_ = caml_call1(next, t$0),
      match = caml_call1(Async_kernel_Deferred1[5], _O_);
     if(match){
      var match$0 = match[1];
      if(match$0){
       var
        t$1 = match$0[2],
        x = match$0[1],
        ac$0 = [0, x, ac],
        t$0 = t$1,
        ac = ac$0;
       continue;
      }
     }
     return [0, caml_call1(Core_List[34], ac), t$0];
    }
   }
   function split(opt, _E_, t){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    if(_E_)
     var sth$0 = _E_[1], f = sth$0;
    else
     var f = function(param){return 192584839;};
    var
     reason_for_stopping = caml_call1(Async_kernel_Ivar[12], 0),
     prefix = caml_call1(Async_kernel_Tail[2], 0);
    function finish(v){
     caml_call1(Async_kernel_Tail[4], prefix);
     return caml_call2(Async_kernel_Ivar[14], reason_for_stopping, v);
    }
    function loop(t){
     function _G_(param){
      if(typeof param === "number") return finish([0, 280164845, t]);
      var o = param[2];
      if(! o) return finish(1144100);
      var t$0 = o[2], a = o[1], match = caml_call1(f, a);
      if(typeof match === "number"){
       caml_call2(Async_kernel_Tail[3], prefix, a);
       return loop(t$0);
      }
      var b = match[2];
      return finish([0, 398750242, [0, b, t$0]]);
     }
     var _H_ = 0;
     function _I_(o){return [0, 870035731, o];}
     var
      _J_ = caml_call1(next, t),
      _K_ = [0, caml_call2(Async_kernel_Deferred_std[6], _J_, _I_), _H_];
     function _L_(param){return 280164845;}
     var
      _M_ = [0, caml_call2(Async_kernel_Deferred_std[6], stop, _L_), _K_],
      _N_ = caml_call1(Async_kernel_Deferred_std[7], _M_);
     return caml_call2(Async_kernel_Deferred_std[1], _N_, _G_);
    }
    loop(t);
    var _F_ = caml_call1(Async_kernel_Ivar[18], reason_for_stopping);
    return [0, caml_call1(Async_kernel_Tail[8], prefix), _F_];
   }
   function find(t, f){
    var
     found =
       split
         (0,
          [0,
           function(a){
            return caml_call1(f, a) ? [0, 398750242, a] : 192584839;
           }],
          t)
        [2];
    function _D_(x){
     if(typeof x !== "number" && 398750242 > x[1])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     return x;
    }
    return caml_call2(Async_kernel_Deferred_std[5][2], found, _D_);
   }
   function ungroup(t){
    return create
            (function(tail){
              function _A_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _B_ =
                 iter
                  (t,
                   function(l){
                    function _C_(x){
                     return caml_call2(Async_kernel_Tail[3], tail, x);
                    }
                    caml_call2(Core_List[9], l, _C_);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _B_, _A_);
             });
   }
   function interleave(ts){
    return create
            (function(tail){
              var num_open = [0, 1];
              function close(param){
               num_open[1] = num_open[1] - 1 | 0;
               var _z_ = caml_call2(Core[90], num_open[1], 0);
               return _z_ ? caml_call1(Async_kernel_Tail[4], tail) : _z_;
              }
              var
               outer_closed =
                 iter
                  (ts,
                   function(t){
                    num_open[1] = num_open[1] + 1 | 0;
                    var _y_ = copy_to_tail(t, tail);
                    caml_call2(Async_kernel_Deferred_std[11], _y_, close);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11], outer_closed, close);
             });
   }
   function take_until(t, d){
    return create
            (function(tail){
              function loop(t){
               function _q_(param){
                if(typeof param !== "number"){
                 var match = param[2];
                 if(match){
                  var t = match[2], x = match[1];
                  caml_call2(Async_kernel_Tail[3], tail, x);
                  return loop(t);
                 }
                }
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _r_ = 0;
               function _s_(z){return [0, 870035731, z];}
               var
                _t_ = caml_call1(next, t),
                _u_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], _t_, _s_), _r_];
               function _v_(param){return 926227490;}
               var
                _w_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], d, _v_), _u_],
                _x_ = caml_call1(Async_kernel_Deferred_std[7], _w_);
               return caml_call2(Async_kernel_Deferred_std[11], _x_, _q_);
              }
              return loop(t);
             });
   }
   function iter_durably(t, f){
    function _j_(result){
     function loop(t){
      function _k_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       function _m_(z){
        loop(t);
        if(0 === z[0]) return 0;
        var e = z[1], _p_ = caml_call1(Async_kernel_Monitor[5], 0);
        return caml_call3(Async_kernel_Monitor[15], _p_, 0, e);
       }
       function _n_(param){return caml_call1(f, x);}
       var
        _o_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _c_, _b_, _n_);
       return caml_call2(Async_kernel_Deferred_std[1], _o_, _m_);
      }
      var _l_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _l_, _k_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _j_);
   }
   function iter_durably_report_end(t, f){
    function _g_(result){
     function loop(t){
      function _h_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       loop(t);
       return caml_call1(f, x);
      }
      var _i_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _i_, _h_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _g_);
   }
   function iter_durably$0(t, f){
    var _f_ = iter_durably_report_end(t, f);
    return caml_call1(Async_kernel_Deferred_std[8], _f_);
   }
   function of_fun(f){
    return unfold
            (0,
             function(param){
              function _d_(a){return [0, [0, a, 0]];}
              var _e_ = caml_call1(f, 0);
              return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_stream);
   var
    Async_kernel_Async_stream =
      [0,
       sexp_of_t,
       create,
       next,
       first_exn,
       of_list,
       to_list,
       of_fun,
       copy_to_tail,
       append,
       concat,
       available_now,
       filter_deprecated,
       filter_map_deprecated,
       fold,
       fold$0,
       iter,
       closed,
       iter$0,
       take_until,
       iter_durably,
       iter_durably$0,
       iter_durably_report_end,
       length,
       map,
       map$0,
       first_n,
       unfold,
       split,
       find,
       ungroup,
       interleave];
   runtime.caml_register_global
    (24, Async_kernel_Async_stream, cst_Async_kernel_Async_stream$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_source_i = "Async_kernel__Time_source_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/time_source_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source_i);
   var Async_kernel_Time_source_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Time_source_intf, cst_Async_kernel_Time_source_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Bvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Async_kernel__Scheduler1, Async_kernel__Types, Base__Field, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Bvar$0 = "Async_kernel__Bvar",
    cst_async_kernel$0 = "async_kernel",
    cst_has_any_waiters$0 = "has_any_waiters",
    cst_ivar$0 = "ivar",
    cst_src_bvar_ml = "src/bvar.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Types = global_data.Async_kernel__Types,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Bvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_bvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _k_ = [0, cst_has_any_waiters$0],
    _i_ = [0, "_"],
    _h_ = [0, cst_src_bvar_ml, 19, 47],
    _g_ = [0, cst_src_bvar_ml, 23, 11],
    _j_ = [0, cst_src_bvar_ml, 14, 287, 309],
    _e_ = [0, cst_ivar$0],
    _f_ = [0, cst_has_any_waiters$0],
    cst_ivar = cst_ivar$0,
    cst_has_any_waiters = cst_has_any_waiters$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Bvar = cst_Async_kernel_Bvar$0;
   function ivar(r){return r[2];}
   function set_ivar(r, v){r[2] = v; return 0;}
   function has_any_waiters(r){return r[1];}
   function set_has_any_waiters(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = [0, set_ivar],
    ivar$0 = [0, function(param){return 0;}, cst_ivar, _b_, ivar, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = [0, set_has_any_waiters],
    has_any_waiters$0 =
      [0,
       function(param){return 0;},
       cst_has_any_waiters,
       _d_,
       has_any_waiters,
       _c_];
   function invariant(invariant_a, param, t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], repr, f);}
     var
      ivar_fun =
        check
         (function(ivar){
           caml_call2(Async_kernel_Ivar[10], invariant_a, ivar);
           if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
          }),
      has_any_waiters_fun =
        check
         (function(has_any_waiters){
           var _q_ = caml_call1(Async_kernel_Ivar[21], repr[2]);
           if(! _q_) return _q_;
           if(has_any_waiters) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
          });
     caml_call1(has_any_waiters_fun, has_any_waiters$0);
     return caml_call1(ivar_fun, ivar$0);
    }
    function _p_(x_007){
     function of_a_001(param){return _i_;}
     var
      has_any_waiters_003 = x_007[1],
      ivar_005 = x_007[2],
      arg_006 = caml_call2(Async_kernel_Ivar[9], of_a_001, ivar_005),
      bnds_002 = [0, [1, [0, _e_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Core[305], has_any_waiters_003),
      bnds_002$0 = [0, [1, [0, _f_, [0, arg_004, 0]]], bnds_002];
     return [1, bnds_002$0];
    }
    return caml_call4(Base_Invariant[1], _j_, repr, _p_, _o_);
   }
   function sexp_of_t(param, _n_, t){
    var has_any_waiters = caml_call1(Async_kernel_Types[10][2], t)[1];
    return [1, [0, _k_, [0, caml_call1(Core[305], has_any_waiters), 0]]];
   }
   var include = Async_kernel_Scheduler1[5], create = include[1];
   function broadcast(t, a){
    var
     repr = caml_call1(Async_kernel_Types[10][2], t),
     _l_ = repr[1],
     _m_ =
       _l_
        ? (repr
           [1]
          = 0,
          caml_call2(Async_kernel_Ivar[14], repr[2], a),
          repr[2] = caml_call1(Async_kernel_Ivar[12], 0),
          0)
        : _l_;
    return _m_;
   }
   function wait(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    repr[1] = 1;
    return caml_call1(Async_kernel_Ivar[18], repr[2]);
   }
   function has_any_waiters$1(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return repr[1];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Bvar);
   var
    Async_kernel_Bvar =
      [0, sexp_of_t, invariant, create, wait, broadcast, has_any_waiters$1];
   runtime.caml_register_global
    (28, Async_kernel_Bvar, cst_Async_kernel_Bvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Base__Field, Base__Invariant, Core, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Time_source$0 = "Async_kernel__Time_source",
    cst_Happened = "Happened",
    cst_Ok = "Ok",
    cst_Previously_aborted = "Previously_aborted",
    cst_Previously_happened = "Previously_happened",
    cst$0 = "_",
    cst_alarm$0 = "alarm",
    cst_async_kernel$0 = "async_kernel",
    cst_fired$0 = "fired",
    cst_num_fires_to_skip$0 = "num_fires_to_skip",
    cst_scheduled_at$0 = "scheduled_at",
    cst_src_time_source_ml = "src/time_source.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/time_source.ml:294:30",
    cst = "",
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_time_source_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    debug = Async_kernel_Debug[1],
    upon = Async_kernel_Deferred1[8],
    choose = Async_kernel_Deferred1[32],
    choice = Async_kernel_Deferred1[29],
    include = Async_kernel_Synchronous_time_[4],
    Job_or_event = include[2],
    invariant_with_jobs = include[20],
    invariant = include[21],
    cst_Time_source_with_timeout_b$0 =
      "Time_source.with_timeout bug: should only abort once",
    cst_Time_source_with_timeout_b =
      "Time_source.with_timeout bug: both completed and timed out",
    _Q_ = [0, 1],
    _P_ = [0, "span"],
    cst_Time_source_every_got_nonp = "Time_source.every got nonpositive span",
    _N_ = [0, -146189108],
    _O_ = [0, 3903734],
    cst_Time_source_Event_run_at = "Time_source.Event.run_at",
    _M_ = [0, cst$0],
    _L_ = [0, cst$0],
    cst_Time_source_Event_reschedu = "Time_source.Event.reschedule_at",
    _I_ = [0, cst_Ok],
    _J_ = [0, cst_Previously_aborted],
    _K_ = [0, cst_Previously_happened],
    cst_Clock_Event_abort_exn_fail =
      "Clock.Event.abort_exn failed to abort event that previously aborted",
    cst_Clock_Event_abort_exn_fail$0 =
      "Clock.Event.abort_exn failed to abort event that previously happened",
    _H_ = [0, cst$0],
    _G_ = [0, cst$0],
    cst_Time_source_Event_abort = "Time_source.Event.abort",
    _D_ = [0, cst_Ok],
    _E_ = [0, cst_Previously_aborted],
    _F_ = [0, cst_Previously_happened],
    _A_ = [0, cst_Aborted],
    _B_ = [0, cst_Happened],
    _C_ = [0, "Scheduled_at"],
    _y_ = [0, cst$0],
    _x_ = [0, cst$0],
    _v_ = [0, cst_src_time_source_ml, 278, 18],
    _w_ = [0, cst_src_time_source_ml, 280, 18],
    _u_ = [0, cst_src_time_source_ml, 289, 43],
    _z_ = [0, cst_src_time_source_ml, 271, 9504, 9528],
    _o_ = [0, "time_source"],
    _p_ = [0, cst_scheduled_at$0],
    _q_ = [0, cst_num_fires_to_skip$0],
    _r_ = [0, cst_fired$0],
    _s_ = [0, "fire"],
    _t_ = [0, cst_alarm$0],
    _e_ = [0, cst_Aborted],
    _f_ = [0, cst_Happened],
    _d_ = [0, cst_src_time_source_ml, 228, 5],
    _a_ = [0, cst$0],
    cst_wall_clock = "<wall_clock>",
    _b_ = [0, "events"],
    _c_ = [0, "is_wall_clock"],
    cst_scheduled_at = cst_scheduled_at$0,
    cst_num_fires_to_skip = cst_num_fires_to_skip$0,
    cst_fired = cst_fired$0,
    cst_alarm = cst_alarm$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_source = cst_Async_kernel_Time_source$0;
   function sexp_of_t(param, _a4_){
    var events = _a4_[4], is_wall_clock = _a4_[8];
    if(is_wall_clock)
     return caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock);
    var _a5_ = 0, _a6_ = 0;
    function _a7_(param){return _a_;}
    var
     _a8_ =
       [0,
        [1, [0, _b_, [0, caml_call2(Timing_wheel[2], _a7_, events), _a6_]]],
        _a5_];
    return [1,
            [0,
             [1, [0, _c_, [0, caml_call1(Core[305], is_wall_clock), 0]]],
             _a8_]];
   }
   function sexp_of_t$0(x_002){return sexp_of_t(Core[202], x_002);}
   var Read_write = [0, sexp_of_t$0, invariant, invariant_with_jobs];
   function sexp_of_t$1(x_003){return sexp_of_t(Core[171], x_003);}
   function read_only(t){return t;}
   var
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function is_wall_clock(t){return t[8];}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function id(t){return t[1];}
   function now(t){
    return t[8]
            ? caml_call1(Async_kernel_Time_ns[50], 0)
            : timing_wheel_now(t);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_directly(t, to){
    return caml_call3(Async_kernel_Synchronous_time_[27], t, to, send_exn);
   }
   function advance_directly_by(t, by){
    var _a3_ = now(t);
    return advance_directly
            (t, caml_call2(Async_kernel_Time_ns[113], _a3_, by));
   }
   function fire_past_alarms(t){
    return caml_call2(Async_kernel_Synchronous_time_[28], t, send_exn);
   }
   function yield$0(t){
    var _a2_ = caml_call1(Async_kernel_Scheduler1[15], t[9]);
    return caml_call1(Async_kernel_Bvar[4], _a2_);
   }
   function advance_by_alarms(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = caml_call1(Timing_wheel[35], t[4]);
      if(! match) return finish(0);
      var min_alarm_time_in_min_interval = match[1];
      if
       (caml_call2
         (Async_kernel_Time_ns[94], min_alarm_time_in_min_interval, to))
       return finish(0);
      advance_directly(t, min_alarm_time_in_min_interval);
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran)){
       var _a1_ = function(param){return walk_alarms(0);};
       return caml_call2
               (Async_kernel_Deferred_std[5][1], queued_alarms_ran, _a1_);
      }
     }
    }
    fire_past_alarms(t);
    function _aZ_(param){return walk_alarms(0);}
    var _a0_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _a0_, _aZ_);
   }
   function advance_by_max_alarms_in_each_(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = next_alarm_fires_at(t);
      if(! match) return finish(0);
      var next_alarm_fires_at$0 = match[1];
      if(caml_call2(Async_kernel_Time_ns[94], next_alarm_fires_at$0, to))
       return finish(0);
      advance_directly(t, caml_call1(Timing_wheel[36], t[4]));
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran)){
       var _aY_ = function(param){return walk_alarms(0);};
       return caml_call2
               (Async_kernel_Deferred_std[5][1], queued_alarms_ran, _aY_);
      }
     }
    }
    fire_past_alarms(t);
    function _aW_(param){return walk_alarms(0);}
    var _aX_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _aX_, _aW_);
   }
   function advance_by_alarms_by(wait_for, t, by){
    var _aV_ = now(t);
    return advance_by_alarms
            (wait_for, t, caml_call2(Async_kernel_Time_ns[113], _aV_, by));
   }
   function span_to_time(t, span){
    var _aU_ = now(t);
    return caml_call2(Async_kernel_Time_ns[113], _aU_, span);
   }
   function run_at_internal(t, time, f$0, a){
    var
     execution_context = caml_call1(Async_kernel_Scheduler1[72], t[9]),
     _aT_ = caml_call1(Timing_wheel[11], t[4]);
    if(! caml_call2(Async_kernel_Time_ns[97], time, _aT_)){
     caml_call4(Async_kernel_Scheduler1[63], t[9], execution_context, f$0, a);
     return caml_call1(Timing_wheel[5][2], 0);
    }
    var
     _aR_ =
       caml_call4
        (Async_kernel_Scheduler1[75], t[9], execution_context, f$0, a),
     _aS_ = caml_call1(Job_or_event[2], _aR_),
     alarm = caml_call3(Timing_wheel[25], t[4], time, _aS_),
     match = t[9][23];
    if(match){var f = match[1]; caml_call1(f, time);}
    return alarm;
   }
   function run_at(t, time, f, a){run_at_internal(t, time, f, a); return 0;}
   function run_after(t, span, f, a){
    return run_at(t, span_to_time(t, span), f, a);
   }
   function fill(result){return caml_call2(Async_kernel_Ivar[14], result, 0);}
   function at(t, time){
    var _aQ_ = caml_call1(Timing_wheel[11], t[4]);
    if(caml_call2(Async_kernel_Time_ns[95], time, _aQ_))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var result = caml_call1(Async_kernel_Ivar[12], 0);
    run_at_internal(t, time, fill, result);
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function after(t, span){return at(t, span_to_time(t, span));}
   function remove_alarm(t, alarm){
    var
     job_or_event = caml_call2(Timing_wheel[5][5], t[4], alarm),
     k = caml_call1(Job_or_event[5][1], job_or_event),
     match = caml_call2(Job_or_event[5][2], k, job_or_event);
    if(! k) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    caml_call2(Async_kernel_Scheduler1[62], t[9], match);
    return caml_call2(Timing_wheel[28], t[4], alarm);
   }
   function sexp_of_t$2(of_a_008, of_h_009, param){
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_008, arg0_010);
     return [1, [0, _e_, [0, res0_011, 0]]];
    }
    var arg0_012 = param[1], res0_013 = caml_call1(of_h_009, arg0_012);
    return [1, [0, _f_, [0, res0_013, 0]]];
   }
   var Fired = [0, sexp_of_t$2];
   function scheduled_at(r){return r[5];}
   function set_scheduled_at(r, v){r[5] = v; return 0;}
   function num_fires_to_skip(r){return r[4];}
   function set_num_fires_to_skip(r, v){r[4] = v; return 0;}
   function fired(r){return r[3];}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _g_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}
   var
    _h_ = [0, set_scheduled_at],
    scheduled_at$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_at,
       _h_,
       scheduled_at,
       _g_];
   function _i_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _j_ = [0, set_num_fires_to_skip],
    num_fires_to_skip$0 =
      [0,
       function(param){return 0;},
       cst_num_fires_to_skip,
       _j_,
       num_fires_to_skip,
       _i_];
   function _k_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _l_ = 0,
    fired$0 = [0, function(param){return 0;}, cst_fired, _l_, fired, _k_];
   function _m_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _n_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _n_, alarm, _m_];
   function sexp_of_t$3(of_a_016, of_h_017, param){
    var
     alarm_019 = param[1],
     fired_023 = param[3],
     num_fires_to_skip_025 = param[4],
     scheduled_at_027 = param[5],
     time_source_029 = param[6],
     arg_030 = caml_call1(Async_kernel_Synchronous_time_[5], time_source_029),
     bnds_018 = [0, [1, [0, _o_, [0, arg_030, 0]]], 0],
     arg_028 = caml_call1(Async_kernel_Time_ns[92], scheduled_at_027),
     bnds_018$0 = [0, [1, [0, _p_, [0, arg_028, 0]]], bnds_018],
     arg_026 = caml_call1(Core[356], num_fires_to_skip_025),
     bnds_018$1 = [0, [1, [0, _q_, [0, arg_026, 0]]], bnds_018$0],
     _aN_ = caml_call2(Fired[1], of_a_016, of_h_017),
     arg_024 = caml_call2(Async_kernel_Ivar[9], _aN_, fired_023),
     bnds_018$2 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_018$1];
    function _aO_(_aP_){return 0;}
    var
     arg_022 = caml_call1(Sexplib0_Sexp_conv[24], _aO_),
     bnds_018$3 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_018$2],
     arg_020 = caml_call2(Timing_wheel[5][1], Job_or_event[6], alarm_019),
     bnds_018$4 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_018$3];
    return [1, bnds_018$4];
   }
   function sexp_of_t_unit(x_031){
    return sexp_of_t$3(Core[518], Core[518], x_031);
   }
   function fired$1(t){return caml_call1(Async_kernel_Ivar[18], t[3]);}
   function invariant$0(invariant_a, invariant_h, t){
    function _aG_(param){
     var events = t[6][4];
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      scheduled_at_fun =
        check
         (function(scheduled_at){
           var _aM_ = caml_call2(Timing_wheel[27], events, t[1]);
           if(! _aM_) return _aM_;
           var
            expect = caml_call2(Timing_wheel[5][3], events, t[1]),
            sexpifier = Async_kernel_Time_ns[92],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_033, b_034){
            return caml_call2(Async_kernel_Time_ns[101], a_033, b_034);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    scheduled_at);
          }),
      num_fires_to_skip_fun =
        check
         (function(num_fires_to_skip){
           if(caml_call2(Async_kernel_Import[1], num_fires_to_skip, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
          }),
      fired_fun =
        check
         (function(fired){
           var
            _aL_ = caml_call1(Async_kernel_Ivar[18], fired),
            match = caml_call1(Async_kernel_Deferred1[5], _aL_);
           if(! match) return 0;
           var match$0 = match[1];
           if(0 === match$0[0]){
            var a = match$0[1];
            return caml_call1(invariant_a, a);
           }
           var h = match$0[1];
           return caml_call1(invariant_h, h);
          }),
      alarm_fun =
        check
         (function(alarm){
           if(caml_call1(Async_kernel_Ivar[17], t[3])){
            if(caml_call2(Timing_wheel[27], events, alarm))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
            return 0;
           }
           var _aJ_ = caml_call2(Timing_wheel[27], events, alarm);
           if(! _aJ_) return _aJ_;
           var _aK_ = caml_call2(Timing_wheel[5][5], events, alarm);
           if(caml_call1(Job_or_event[4], _aK_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          });
     caml_call1(alarm_fun, alarm$0);
     caml_call1(fired_fun, fired$0);
     caml_call1(num_fires_to_skip_fun, num_fires_to_skip$0);
     caml_call1(scheduled_at_fun, scheduled_at$0);
     return 0;
    }
    function _aH_(x_032){
     function _aI_(param){return _x_;}
     return sexp_of_t$3(function(param){return _y_;}, _aI_, x_032);
    }
    return caml_call4(Base_Invariant[1], _z_, t, _aH_, _aG_);
   }
   function sexp_of_t$4(of_a_035, of_h_036, param){
    switch(param[0]){
      case 0:
       var arg0_037 = param[1], res0_038 = caml_call1(of_a_035, arg0_037);
       return [1, [0, _A_, [0, res0_038, 0]]];
      case 1:
       var arg0_039 = param[1], res0_040 = caml_call1(of_h_036, arg0_039);
       return [1, [0, _B_, [0, res0_040, 0]]];
      default:
       var
        arg0_041 = param[1],
        res0_042 = caml_call1(Async_kernel_Time_ns[92], arg0_041);
       return [1, [0, _C_, [0, res0_042, 0]]];
    }
   }
   var Status = [0, sexp_of_t$4];
   function status(t){
    var
     _aF_ = caml_call1(Async_kernel_Ivar[18], t[3]),
     match = caml_call1(Async_kernel_Deferred1[5], _aF_);
    if(! match) return [2, t[5]];
    var match$0 = match[1];
    if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
    var h = match$0[1];
    return [1, h];
   }
   function sexp_of_t$5(of_a_045, of_h_046, param){
    if(typeof param === "number") return _D_;
    if(0 === param[0]){
     var arg0_047 = param[1], res0_048 = caml_call1(of_a_045, arg0_047);
     return [1, [0, _E_, [0, res0_048, 0]]];
    }
    var arg0_049 = param[1], res0_050 = caml_call1(of_h_046, arg0_049);
    return [1, [0, _F_, [0, res0_050, 0]]];
   }
   var Abort_result = [0, sexp_of_t$5];
   function abort(t, a){
    if(debug){
     var
      _aC_ =
        function(x_053){
         function _aE_(param){return _G_;}
         return sexp_of_t$3(function(param){return _H_;}, _aE_, x_053);
        };
     caml_call3(Async_kernel_Debug[15], cst_Time_source_Event_abort, t, _aC_);
    }
    var
     _aD_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aD_);
    if(! match){
     caml_call2(Async_kernel_Ivar[14], t[3], [0, a]);
     var alarm = t[1], t$0 = t[6];
     if(caml_call2(Timing_wheel[27], t$0[4], alarm)) remove_alarm(t$0, alarm);
     return 0;
    }
    var match$0 = match[1];
    if(0 === match$0[0]){var a$0 = match$0[1]; return [0, a$0];}
    var h = match$0[1];
    return [1, h];
   }
   function abort_exn(t, a){
    var match = abort(t, a);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var
      _aA_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail);
     return caml_call1(Core[253], _aA_);
    }
    var
     _aB_ =
       caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail$0);
    return caml_call1(Core[253], _aB_);
   }
   function abort_if_possible(t, a){abort(t, a); return 0;}
   function schedule(t){t[1] = run_at_internal(t[6], t[5], t[2], 0); return;}
   function sexp_of_t$6(of_a_054, of_h_055, param){
    if(typeof param === "number") return _I_;
    if(0 === param[0]){
     var arg0_056 = param[1], res0_057 = caml_call1(of_a_054, arg0_056);
     return [1, [0, _J_, [0, res0_057, 0]]];
    }
    var arg0_058 = param[1], res0_059 = caml_call1(of_h_055, arg0_058);
    return [1, [0, _K_, [0, res0_059, 0]]];
   }
   var Reschedule_result = [0, sexp_of_t$6];
   function reschedule_at(t, at){
    if(debug){
     var
      _aw_ =
        function(param){
         var arg1_063 = param[2], arg0_062 = param[1];
         function _az_(param){return _L_;}
         var
          res0_064 = sexp_of_t$3(function(param){return _M_;}, _az_, arg0_062),
          res1_065 = caml_call1(Async_kernel_Time_ns[92], arg1_063);
         return [1, [0, res0_064, [0, res1_065, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_reschedu,
       [0, t, at],
       _aw_);
    }
    var
     _ax_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _ax_);
    if(match){
     var match$0 = match[1];
     if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
     var h = match$0[1];
     return [1, h];
    }
    var
     events = t[6][4],
     is_in_timing_wheel = caml_call2(Timing_wheel[27], events, t[1]),
     _ay_ = caml_call1(Timing_wheel[11], events),
     am_trying_to_reschedule_in_the =
       caml_call2(Async_kernel_Time_ns[97], at, _ay_);
    t[5] = at;
    if(am_trying_to_reschedule_in_the)
     if(is_in_timing_wheel)
      caml_call3(Timing_wheel[29], events, t[1], at);
     else{t[4] = t[4] + 1 | 0; schedule(t);}
    else if(is_in_timing_wheel){
     caml_call1(t[6][7], t[1]);
     caml_call2(Timing_wheel[28], events, t[1]);
    }
    return 0;
   }
   function reschedule_after(t, span){
    return reschedule_at(t, span_to_time(t[6], span));
   }
   function run_at$0(time_source, scheduled_at, f, z){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_run_at,
       scheduled_at,
       Async_kernel_Time_ns[92]);
    var _ap_ = 0, _aq_ = caml_call1(Async_kernel_Ivar[12], 0);
    function _ar_(_av_){return 0;}
    var
     t =
       [0,
        caml_call1(Timing_wheel[5][2], 0),
        _ar_,
        _aq_,
        _ap_,
        scheduled_at,
        time_source];
    function fire(param){
     var _as_ = caml_call1(Async_kernel_Ivar[16], t[3]);
     if(_as_){
      if(caml_call2(Async_kernel_Import[4], t[4], 0)){t[4] = t[4] - 1 | 0; return 0;}
      var
       result = caml_call1(f, z),
       _at_ = caml_call1(Async_kernel_Ivar[16], t[3]);
      if(_at_) return caml_call2(Async_kernel_Ivar[14], t[3], [1, result]);
      var _au_ = _at_;
     }
     else
      var _au_ = _as_;
     return _au_;
    }
    t[2] = fire;
    schedule(t);
    return t;
   }
   function at$0(time_source, time){
    var _an_ = 0;
    return run_at$0(time_source, time, function(_ao_){return 0;}, _an_);
   }
   function run_after$0(time_source, span, f, a){
    return run_at$0(time_source, span_to_time(time_source, span), f, a);
   }
   function after$0(time_source, span){
    return at$0(time_source, span_to_time(time_source, span));
   }
   function at_times(opt, t, next_time){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    function loop(param){
     function _aj_(param){
      return 936767357 <= param
              ? (caml_call2(Async_kernel_Tail[3], tail, 0), loop(0))
              : caml_call1(Async_kernel_Tail[4], tail);
     }
     var _ak_ = 0;
     function _al_(param){return 936767357;}
     var
      _am_ =
        [0, caml_call2(choice, at(t, caml_call1(next_time, 0)), _al_), _ak_];
     return caml_call2
             (upon,
              caml_call1
               (choose,
                [0,
                 caml_call2(choice, stop, function(param){return 926227490;}),
                 _am_]),
              _aj_);
    }
    loop(0);
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function at_varying_intervals(stop, t, compute_span){
    return at_times
            (stop,
             t,
             function(param){
              var _ah_ = caml_call1(compute_span, 0), _ai_ = now(t);
              return caml_call2(Async_kernel_Time_ns[113], _ai_, _ah_);
             });
   }
   function at_intervals(start, stop, t, interval){
    if(start) var x = start[1], start$0 = x; else var start$0 = now(t);
    return at_times
            (stop,
             t,
             function(param){
              var _ag_ = now(t);
              return caml_call5
                      (Async_kernel_Time_ns[65], 0, start$0, _ag_, interval, 0);
             });
   }
   var immediately = 0;
   function run_repeatedly(opt, stop, _aa_, _$_, time_source, f, continue$0){
    if(opt)
     var sth = opt[1], start = sth;
    else
     var start = caml_call1(Async_kernel_Deferred_std[10], 0);
    if(_aa_)
     var sth$0 = _aa_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 1;
    if(_$_)
     var sth$1 = _$_[1], finished = sth$1;
    else
     var finished = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (upon,
             start,
             function(param){
              var alarm = [0, caml_call1(Timing_wheel[5][2], 0)];
              if(stop){
               var stop$0 = stop[1];
               caml_call2
                (upon,
                 stop$0,
                 function(param){
                  var
                   _af_ =
                     caml_call2(Timing_wheel[27], time_source[4], alarm[1]);
                  return _af_
                          ? (remove_alarm
                             (time_source, alarm[1]),
                            caml_call2(Async_kernel_Ivar[15], finished, 0))
                          : _af_;
                 });
               var stop$1 = stop$0;
              }
              else
               var stop$1 = caml_call1(Async_kernel_Deferred1[12], 0);
              function run_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               if(continue_on_error)
                return caml_call2
                        (upon,
                         caml_call7
                          (Async_kernel_Monitor[16], 0, 0, 0, 0, _O_, _N_, f),
                         continue_try_with);
               var d = caml_call1(f, 0);
               return caml_call1(Async_kernel_Deferred1[7], d)
                       ? continue_f(0)
                       : caml_call2(upon, d, continue_f);
              }
              function continue_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               var _ad_ = 0;
               if(typeof continue$0 === "number")
                var _ae_ = caml_call1(Timing_wheel[11], time_source[4]);
               else if(0 === continue$0[0])
                var
                 span = continue$0[1],
                 _ae_ = span_to_time(time_source, span);
               else
                var
                 interval = continue$0[2],
                 base = continue$0[1],
                 _ac_ = now(time_source),
                 _ae_ =
                   caml_call5
                    (Async_kernel_Time_ns[65], 0, base, _ac_, interval, 0);
               alarm[1] = run_at_internal(time_source, _ae_, run_f, _ad_);
               return 0;
              }
              function continue_try_with(or_error){
               if(0 !== or_error[0]){
                var
                 error = or_error[1],
                 _ab_ = caml_call1(Async_kernel_Monitor[5], 0);
                caml_call3(Async_kernel_Monitor[15], _ab_, 0, error);
               }
               return continue_f(0);
              }
              return run_f(0);
             });
   }
   function every(start, stop, continue_on_error, finished, t, span, f){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _Z_ =
        [0, [1, [0, _P_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      ___ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_every_got_nonp),
          _Z_]];
     caml_call1(Core[253], ___);
    }
    return run_repeatedly
            (start, stop, continue_on_error, finished, t, f, [0, span]);
   }
   function every$0(start, stop, continue_on_error, t, span, f){
    return every
            (start,
             stop,
             continue_on_error,
             0,
             t,
             span,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function run_at_intervals(start, stop, continue_on_error, t, interval, f){
    var now$0 = now(t);
    if(start)
     var
      start$0 = start[1],
      start$1 =
        [0,
         at
          (t,
           caml_call5
            (Async_kernel_Time_ns[65], _Q_, start$0, now$0, interval, 0))],
      base = start$0;
    else
     var start$1 = 0, base = now$0;
    return run_repeatedly
            (start$1, stop, continue_on_error, 0, t, f, [1, base, interval]);
   }
   function run_at_intervals$0(start, stop, continue_on_error, t, interval, f){
    return run_at_intervals
            (start,
             stop,
             continue_on_error,
             t,
             interval,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function with_timeout(t, span, d){
    var timeout = after$0(t, span), _U_ = 0;
    function _V_(param){
     if(0 !== param[0]) return 642269825;
     var
      _Y_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b);
     return caml_call1(Core[253], _Y_);
    }
    var _W_ = [0, caml_call2(choice, fired$1(timeout), _V_), _U_];
    return caml_call1
            (choose,
             [0,
              caml_call2
               (choice,
                d,
                function(v){
                 var match = abort(timeout, 0);
                 a:
                 if(typeof match !== "number" && 0 === match[0]){
                  var
                   _X_ =
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b$0);
                  caml_call1(Core[253], _X_);
                  break a;
                 }
                 return [0, 1025039613, v];
                }),
              _W_]);
   }
   function duration_of(t, f){
    var start = now(t);
    function _R_(result){
     var
      _T_ = now(t),
      duration = caml_call2(Async_kernel_Time_ns[57], _T_, start);
     return [0, result, duration];
    }
    var _S_ = caml_call1(f, 0);
    return caml_call2(Async_kernel_Deferred_std[5][2], _S_, _R_);
   }
   function of_synchronous(t){return t;}
   function to_synchronous(t){return t;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source);
   var
    Async_kernel_Time_source =
      [0,
       [0, sexp_of_t],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t$1,
       id,
       invariant,
       invariant_with_jobs,
       read_only,
       create,
       wall_clock,
       alarm_precision,
       is_wall_clock,
       next_alarm_fires_at,
       now,
       timing_wheel_now,
       advance_directly,
       advance_directly,
       advance_directly_by,
       advance_directly_by,
       fire_past_alarms,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_by_alarms_by,
       [0, immediately],
       run_repeatedly,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       duration_of,
       [0,
        sexp_of_t$3,
        sexp_of_t_unit,
        invariant$0,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        Abort_result,
        abort,
        abort_exn,
        abort_if_possible,
        Fired,
        fired$1,
        Reschedule_result,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       of_synchronous,
       to_synchronous];
   runtime.caml_register_global
    (83, Async_kernel_Time_source, cst_Async_kernel_Time_source$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Stack_or_counter
//# unitInfo: Requires: Base, Base__Stack, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Stack_or_coun$0 = "Async_kernel__Stack_or_counter",
    cst_async_kernel$0 = "async_kernel",
    cst_length = "length";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Stack = global_data.Base__Stack,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Stack_or_coun$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/stack_or_counter.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_Stack_or_counter_pop_exn_o =
      "[Stack_or_counter.pop_exn] of empty stack",
    _d_ = [0, cst_length],
    cst_Stack_or_counter_create_co =
      "[Stack_or_counter.create_counter] got negative length",
    _a_ = [0, "Stack"],
    _b_ = [0, cst_length],
    _c_ = [0, "Counter"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Stack_or_coun = cst_Async_kernel_Stack_or_coun$0;
   function sexp_of_t(of_a_002, param){
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_004 = caml_call2(Base_Stack[2], of_a_002, arg0_003);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    var
     length_006 = param[1],
     arg_007 = caml_call1(Base[120], length_006),
     bnds_005 = [0, [1, [0, _b_, [0, arg_007, 0]]], 0];
    return [1, [0, _c_, bnds_005]];
   }
   function of_list(list){return [0, caml_call1(Base_Stack[22], list)];}
   function create_counter(length){
    if(length < 0){
     var
      _i_ = [0, [1, [0, _d_, [0, caml_call1(Base[120], length), 0]]], 0],
      _j_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_create_co),
          _i_]];
     caml_call1(Base[203], _j_);
    }
    return [1, length];
   }
   function length(t){
    if(0 !== t[0]) return t[1];
    var s = t[1];
    return caml_call1(Base_Stack[6], s);
   }
   function clear(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[30], s);}
    t[1] = 0;
    return 0;
   }
   function push(t, a){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[25], s, a);}
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function pop_exn(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[27], s);}
    if(0 === t[1]){
     var
      _h_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_pop_exn_o);
     caml_call1(Base[203], _h_);
    }
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function iter(t, f){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[8], s, f);}
    var _f_ = t[1], _e_ = 1;
    if(_f_ >= 1){
     var for$0 = _e_;
     for(;;){
      caml_call1(f, 0);
      var _g_ = for$0 + 1 | 0;
      if(_f_ === for$0) break;
      var for$0 = _g_;
     }
    }
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Stack_or_coun);
   var
    Async_kernel_Stack_or_counter =
      [0,
       sexp_of_t,
       clear,
       create_counter,
       iter,
       length,
       of_list,
       pop_exn,
       push];
   runtime.caml_register_global
    (20, Async_kernel_Stack_or_counter, cst_Async_kernel_Stack_or_coun$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttle
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Stack_or_counter, Base__Field, Core, Core__Int, Core__List, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Throttle$0 = "Async_kernel__Throttle",
    cst_Ok = "Ok",
    cst_Raised = "Raised",
    cst_async_kernel$0 = "async_kernel",
    cst_capacity_available$0 = "capacity_available",
    cst_cleaned$0 = "cleaned",
    cst_job_resources_not_in_use$0 = "job_resources_not_in_use",
    cst_jobs_waiting_to_start$0 = "jobs_waiting_to_start",
    cst_max_concurrent_jobs$0 = "max_concurrent_jobs",
    cst_num_jobs_running$0 = "num_jobs_running",
    cst_num_resources_not_cleaned$0 = "num_resources_not_cleaned",
    cst_src_throttle_ml = "src/throttle.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Stack_or_counter = global_data.Async_kernel__Stack_or_counter,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttle$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_throttle_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _Z_ = [0, cst_src_throttle_ml, 173, 2],
    _$_ = [0, cst_src_throttle_ml, 174, 2],
    ___ = [0, cst_src_throttle_ml, 175, 2],
    cst_enqueue_exclusive_was_call =
      "[enqueue_exclusive] was called with a very large value of [max_concurrent_jobs]. This doesn't work.",
    _ab_ = [0, cst_src_throttle_ml, 279, 2],
    cst_throttle_aborted_job = "throttle aborted job",
    _aa_ = [0, cst_max_concurrent_jobs$0],
    cst_Throttle_create_requires_p =
      "Throttle.create requires positive max_concurrent_jobs, but got",
    _L_ = [0, "_"],
    _Y_ = [0, cst_src_throttle_ml, 104, 43],
    _X_ = [0, cst_src_throttle_ml, 108, 11],
    _W_ = [0, cst_src_throttle_ml, 113, 29],
    _V_ = [0, cst_src_throttle_ml, 116, 11],
    _U_ = [0, cst_src_throttle_ml, 117, 11],
    _T_ = [0, cst_src_throttle_ml, 119, 16],
    _S_ = [0, cst_src_throttle_ml, 123, 26],
    _R_ = [0, cst_src_throttle_ml, 128, 11],
    _Q_ = [0, cst_src_throttle_ml, 129, 11],
    _P_ = [0, cst_src_throttle_ml, 130, 69],
    _O_ = [0, cst_src_throttle_ml, 133, 40],
    _M_ = [0, "t"],
    _N_ = [0, "exn"],
    cst_Throttle_invariant_failed = "Throttle.invariant failed",
    _B_ = [0, cst_cleaned$0],
    _C_ = [0, cst_num_resources_not_cleaned$0],
    _D_ = [0, "cleans"],
    _E_ = [0, "is_dead"],
    _F_ = [0, cst_capacity_available$0],
    _G_ = [0, cst_num_jobs_running$0],
    _H_ = [0, cst_jobs_waiting_to_start$0],
    _I_ = [0, cst_job_resources_not_in_use$0],
    _J_ = [0, cst_max_concurrent_jobs$0],
    _K_ = [0, "continue_on_error"],
    _m_ = [0, cst_src_throttle_ml, 58, 18],
    _k_ = [0, 3804260],
    _l_ = [0, 523273847],
    _h_ = [0, "Abort"],
    _i_ = [0, "Start"],
    _e_ = [0, cst_Ok],
    _f_ = [0, cst_Raised],
    _d_ = [0, cst_Aborted],
    _g_ = [0, "outcome"],
    _j_ = [0, "start"],
    _a_ = [0, cst_Aborted],
    _b_ = [0, cst_Ok],
    _c_ = [0, cst_Raised],
    cst_cleaned = cst_cleaned$0,
    cst_num_resources_not_cleaned = cst_num_resources_not_cleaned$0,
    cst_capacity_available = cst_capacity_available$0,
    cst_num_jobs_running = cst_num_jobs_running$0,
    cst_jobs_waiting_to_start = cst_jobs_waiting_to_start$0,
    cst_job_resources_not_in_use = cst_job_resources_not_in_use$0,
    cst_max_concurrent_jobs = cst_max_concurrent_jobs$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Throttle = cst_Async_kernel_Throttle$0;
   function sexp_of_outcome(of_a_001, param){
    if(typeof param === "number") return _a_;
    if(17724 <= param[1]){
     var v_002 = param[2];
     return [1, [0, _b_, [0, caml_call1(of_a_001, v_002), 0]]];
    }
    var v_003 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[537], v_003), 0]]];
   }
   function abort(t){
    return caml_call2(Async_kernel_Ivar[14], t[1], 774323088);
   }
   function cleaned(r){return r[10];}
   function num_resources_not_cleaned(r){return r[9];}
   function set_num_resources_not_cleaned(r, v){r[9] = v; return 0;}
   function is_dead(r){return r[7];}
   function capacity_available(r){return r[6];}
   function set_capacity_available(r, v){r[6] = v; return 0;}
   function num_jobs_running(r){return r[5];}
   function set_num_jobs_running(r, v){r[5] = v; return 0;}
   function jobs_waiting_to_start(r){return r[4];}
   function job_resources_not_in_use(r){return r[3];}
   function max_concurrent_jobs(r){return r[2];}
   function _n_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v];
   }
   var
    _o_ = 0,
    cleaned$0 =
      [0, function(param){return 0;}, cst_cleaned, _o_, cleaned, _n_];
   function _p_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v, r[10]];
   }
   var
    _q_ = [0, set_num_resources_not_cleaned],
    num_resources_not_cleaned$0 =
      [0,
       function(param){return 0;},
       cst_num_resources_not_cleaned,
       _q_,
       num_resources_not_cleaned,
       _p_];
   function _r_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9], r[10]];
   }
   var
    _s_ = [0, set_capacity_available],
    capacity_available$0 =
      [0,
       function(param){return 0;},
       cst_capacity_available,
       _s_,
       capacity_available,
       _r_];
   function _t_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _u_ = [0, set_num_jobs_running],
    num_jobs_running$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_running,
       _u_,
       num_jobs_running,
       _t_];
   function _v_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _w_ = 0,
    jobs_waiting_to_start$0 =
      [0,
       function(param){return 0;},
       cst_jobs_waiting_to_start,
       _w_,
       jobs_waiting_to_start,
       _v_];
   function _x_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _y_ = 0,
    job_resources_not_in_use$0 =
      [0,
       function(param){return 0;},
       cst_job_resources_not_in_use,
       _y_,
       job_resources_not_in_use,
       _x_];
   function _z_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
   }
   var
    _A_ = 0,
    max_concurrent_jobs$0 =
      [0,
       function(param){return 0;},
       cst_max_concurrent_jobs,
       _A_,
       max_concurrent_jobs,
       _z_];
   function sexp_of_t(of_a_011, param){
    var
     jobs_waiting_to_start_019 = param[4],
     job_resources_not_in_use_017 = param[3],
     max_concurrent_jobs_015 = param[2],
     continue_on_error_013 = param[1],
     num_jobs_running_021 = param[5],
     capacity_available_023 = param[6],
     is_dead_025 = param[7],
     cleans_027 = param[8],
     num_resources_not_cleaned_029 = param[9],
     cleaned_031 = param[10],
     arg_032 = caml_call2(Async_kernel_Ivar[9], Core[518], cleaned_031),
     bnds_012 = [0, [1, [0, _B_, [0, arg_032, 0]]], 0],
     arg_030 = caml_call1(Core[356], num_resources_not_cleaned_029),
     bnds_012$0 = [0, [1, [0, _C_, [0, arg_030, 0]]], bnds_012];
    function _a3_(param){
     function _a8_(_a9_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _a8_);
    }
    var
     arg_028 = caml_call2(Core[421], _a3_, cleans_027),
     bnds_012$1 = [0, [1, [0, _D_, [0, arg_028, 0]]], bnds_012$0],
     arg_026 = caml_call1(Core[305], is_dead_025),
     bnds_012$2 = [0, [1, [0, _E_, [0, arg_026, 0]]], bnds_012$1],
     _a4_ = caml_call1(Async_kernel_Ivar[9], Core[518]),
     arg_024 = caml_call2(Core[454], _a4_, capacity_available_023),
     bnds_012$3 = [0, [1, [0, _F_, [0, arg_024, 0]]], bnds_012$2],
     arg_022 = caml_call1(Core[356], num_jobs_running_021),
     bnds_012$4 = [0, [1, [0, _G_, [0, arg_022, 0]]], bnds_012$3];
    function _a5_(param){
     var outcome_009 = param[2], start_006 = param[1], bnds_005 = 0;
     function _a6_(param){
      return -216426513 === param ? _d_ : 17724 <= param ? _e_ : _f_;
     }
     var
      arg_010 = caml_call2(Async_kernel_Deferred1[1], _a6_, outcome_009),
      bnds_005$0 = [0, [1, [0, _g_, [0, arg_010, 0]]], bnds_005];
     function _a7_(param){
      if(typeof param === "number") return _h_;
      var v_008 = param[2];
      return [1, [0, _i_, [0, caml_call1(of_a_011, v_008), 0]]];
     }
     var
      arg_007 = caml_call2(Async_kernel_Ivar[9], _a7_, start_006),
      bnds_005$1 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_005$0];
     return [1, bnds_005$1];
    }
    var
     arg_020 = caml_call2(Core_Queue[11], _a5_, jobs_waiting_to_start_019),
     bnds_012$5 = [0, [1, [0, _H_, [0, arg_020, 0]]], bnds_012$4],
     arg_018 =
       caml_call2
        (Async_kernel_Stack_or_counter[1],
         of_a_011,
         job_resources_not_in_use_017),
     bnds_012$6 = [0, [1, [0, _I_, [0, arg_018, 0]]], bnds_012$5],
     arg_016 = caml_call1(Core[356], max_concurrent_jobs_015),
     bnds_012$7 = [0, [1, [0, _J_, [0, arg_016, 0]]], bnds_012$6],
     arg_014 = caml_call1(Core[305], continue_on_error_013),
     bnds_012$8 = [0, [1, [0, _K_, [0, arg_014, 0]]], bnds_012$7];
    return [1, bnds_012$8];
   }
   function invariant(invariant_a, x_033){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_033));
        },
      _aQ_ =
        function(cleaned){
         var _a2_ = caml_call1(Async_kernel_Ivar[17], cleaned);
         if(! _a2_) return _a2_;
         if(caml_call2(Async_kernel_Import[3], x_033[9], 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
        },
      _aR_ =
        function(num_resources_not_cleaned){
         if
          (! caml_call2(Async_kernel_Import[1], num_resources_not_cleaned, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
         if
          (!
           caml_call2
            (Async_kernel_Import[2], num_resources_not_cleaned, x_033[2]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _Q_], 1);
         var
          _a1_ =
            caml_call2
             (Async_kernel_Import[5], num_resources_not_cleaned, x_033[2]);
         if(! _a1_) return _a1_;
         if(x_033[7]) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
        },
      _aS_ =
        function(param){
         if(! param) return 0;
         var ivar = param[1];
         if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
        },
      _aT_ =
        function(num_jobs_running){
         if(! caml_call2(Async_kernel_Import[1], num_jobs_running, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
         if(! caml_call2(Async_kernel_Import[2], num_jobs_running, x_033[2]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
         var
          _a0_ =
            caml_call2(Async_kernel_Import[5], num_jobs_running, x_033[2]);
         if(! _a0_) return _a0_;
         if(caml_call1(Core_Queue[15], x_033[4])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
        },
      _aU_ =
        function(jobs_waiting_to_start){
         var _aZ_ = x_033[7];
         if(! _aZ_) return _aZ_;
         if(caml_call1(Core_Queue[15], jobs_waiting_to_start)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
        },
      _aV_ =
        function(job_resources_not_in_use){
         caml_call2
          (Async_kernel_Stack_or_counter[4],
           job_resources_not_in_use,
           invariant_a);
         var
          _aX_ = x_033[7] ? 0 : x_033[2] - x_033[5] | 0,
          _aY_ =
            caml_call1
             (Async_kernel_Stack_or_counter[5], job_resources_not_in_use);
         if(caml_call2(Async_kernel_Import[3], _aY_, _aX_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
        };
     check
      (function(max_concurrent_jobs){
        if(caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0))
         return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
       },
       max_concurrent_jobs$0);
     check(_aV_, job_resources_not_in_use$0);
     check(_aU_, jobs_waiting_to_start$0);
     check(_aT_, num_jobs_running$0);
     check(_aS_, capacity_available$0);
     check(_aR_, num_resources_not_cleaned$0);
     var _aW_ = check(_aQ_, cleaned$0);
     return _aW_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _aL_ = 0,
      _aM_ = 0,
      _aN_ =
        [0,
         [1,
          [0, _M_, [0, sexp_of_t(function(param){return _L_;}, x_033), _aM_]]],
         _aL_],
      _aO_ = [0, [1, [0, _N_, [0, caml_call1(Core[537], exn), 0]]], _aN_],
      _aP_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_invariant_failed),
          _aO_]];
     return caml_call1(Core[253], _aP_);
    }
   }
   function sexp_of_t$0(of_a_034, of_kind_035, x_036){return sexp_of_t(of_a_034, x_036);
   }
   function invariant$0(invariant_a, param, t){return invariant(invariant_a, t);
   }
   var T2 = [0, sexp_of_t$0, invariant$0];
   function num_jobs_waiting_to_start(t){
    return caml_call1(Core_Queue[14], t[4]);
   }
   function clean_resource(t, a){
    function _aG_(param){
     t[9] = t[9] - 1 | 0;
     var _aK_ = caml_call2(Async_kernel_Import[3], t[9], 0);
     return _aK_ ? caml_call2(Async_kernel_Ivar[14], t[10], 0) : _aK_;
    }
    function _aH_(f){return caml_call1(f, a);}
    var
     _aI_ = caml_call2(Core_List[72], t[8], _aH_),
     _aJ_ = caml_call1(Async_kernel_Deferred1[43], _aI_);
    return caml_call2(Async_kernel_Deferred_std[1], _aJ_, _aG_);
   }
   function kill(t){
    var _aE_ = 1 - t[7];
    if(! _aE_) return _aE_;
    t[7] = 1;
    caml_call2(Core_Queue[16], t[4], abort);
    caml_call1(Core_Queue[47], t[4]);
    function _aF_(a){return clean_resource(t, a);}
    caml_call2(Async_kernel_Stack_or_counter[4], t[3], _aF_);
    return caml_call1(Async_kernel_Stack_or_counter[2], t[3]);
   }
   function at_kill(t, f){
    var
     _aD_ = caml_call1(Async_kernel_Monitor[26][8], f),
     f$0 = caml_call1(Core[259], _aD_);
    t[8] = [0, f$0, t[8]];
    return 0;
   }
   function cleaned$1(t){return caml_call1(Async_kernel_Ivar[18], t[10]);}
   function start_job(t){
    if(t[7]) throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
    if(! caml_call2(Async_kernel_Import[5], t[5], t[2]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
    if(caml_call1(Core_Queue[15], t[4]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var job = caml_call1(Core_Queue[44], t[4]);
    t[5] = t[5] + 1 | 0;
    var job_resource = caml_call1(Async_kernel_Stack_or_counter[7], t[3]);
    function _aC_(res){
     t[5] = t[5] - 1 | 0;
     if(17724 > res && 1 - t[1]) kill(t);
     if(t[7]) return clean_resource(t, job_resource);
     caml_call2(Async_kernel_Stack_or_counter[8], t[3], job_resource);
     if(! caml_call1(Core_Queue[15], t[4])) return start_job(t);
     var match = t[6];
     if(! match) return 0;
     var ivar = match[1];
     caml_call2(Async_kernel_Ivar[14], ivar, 0);
     t[6] = 0;
     return 0;
    }
    caml_call2(Async_kernel_Ivar[14], job[1], [0, 389604418, job_resource]);
    function _aA_(x){
     if(-216426513 === x)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     return x;
    }
    var _aB_ = caml_call2(Async_kernel_Deferred_std[5][2], job[2], _aA_);
    return caml_call2(Async_kernel_Deferred_std[1], _aB_, _aC_);
   }
   function create_internal(continue_on_error, job_resources){
    var
     max_concurrent_jobs =
       caml_call1(Async_kernel_Stack_or_counter[5], job_resources),
     _az_ = caml_call1(Async_kernel_Ivar[12], 0);
    return [0,
            continue_on_error,
            max_concurrent_jobs,
            job_resources,
            caml_call2(Core_Queue[61], 0, 0),
            0,
            0,
            0,
            0,
            max_concurrent_jobs,
            _az_];
   }
   function create_with(continue_on_error, job_resources){
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[6], job_resources));
   }
   function create(opt, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    return create_with(continue_on_error, [0, a, 0]);
   }
   var Sequencer = [0, sexp_of_t, create];
   function create$0(continue_on_error, max_concurrent_jobs){
    if(caml_call2(Async_kernel_Import[2], max_concurrent_jobs, 0)){
     var
      _ax_ =
        [0,
         [1, [0, _aa_, [0, caml_call1(Core[356], max_concurrent_jobs), 0]]],
         0],
      _ay_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_create_requires_p),
          _ax_]];
     caml_call1(Core[253], _ay_);
    }
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[3], max_concurrent_jobs));
   }
   function enqueue(t, work){
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _ar_(param){
     if(typeof param === "number")
      return caml_call1(Async_kernel_Deferred_std[10], -216426513);
     var a = param[2];
     function _au_(param){
      if(0 === param[0]){var a = param[1]; return [0, 17724, a];}
      var exn = param[1];
      return [0, -387916264, exn];
     }
     function _av_(param){return caml_call1(work, a);}
     var
      _aw_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _l_, _k_, _av_);
     return caml_call2(Async_kernel_Deferred_std[5][2], _aw_, _au_);
    }
    var
     _as_ = caml_call1(Async_kernel_Ivar[18], start),
     result = caml_call2(Async_kernel_Deferred_std[5][1], _as_, _ar_);
    function _at_(param){
     return typeof param === "number"
             ? -216426513
             : 17724 <= param[1] ? 17724 : -387916264;
    }
    var
     outcome = caml_call2(Async_kernel_Deferred_std[5][2], result, _at_),
     internal_job = [0, start, outcome];
    if(t[7])
     abort(internal_job);
    else{
     caml_call2(Core_Queue[41], t[4], internal_job);
     if(caml_call2(Async_kernel_Import[5], t[5], t[2])) start_job(t);
    }
    return result;
   }
   function handle_enqueue_result(result){
    if(typeof result === "number"){
     var _aq_ = caml_call1(Sexplib0_Sexp_conv[7], cst_throttle_aborted_job);
     return caml_call1(Core[253], _aq_);
    }
    if(17724 <= result[1]){var a = result[2]; return a;}
    var exn = result[2];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function enqueue$0(t, f){
    var _ap_ = enqueue(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], _ap_, handle_enqueue_result);
   }
   function enqueue_exclusive(t, f){
    var n = t[2];
    if(caml_call2(Core_Int[84], n, 1000000)){
     var
      _ai_ = caml_call1(Sexplib0_Sexp_conv[7], cst_enqueue_exclusive_was_call);
     caml_call1(Core[253], _ai_);
    }
    var done = caml_call1(Async_kernel_Ivar[12], 0);
    if(! caml_call2(Async_kernel_Import[4], n, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
    function f_placeholder(slot){
     return caml_call1(Async_kernel_Ivar[18], done);
    }
    var _ak_ = n - 1 | 0, _aj_ = 1;
    if(_ak_ >= 1){
     var for$0 = _aj_;
     for(;;){
      var _an_ = enqueue$0(t, f_placeholder);
      caml_call1(Async_kernel_Deferred_std[8], _an_);
      var _ao_ = for$0 + 1 | 0;
      if(_ak_ === for$0) break;
      var for$0 = _ao_;
     }
    }
    function _al_(result){
     caml_call2(Async_kernel_Ivar[14], done, 0);
     return handle_enqueue_result(result);
    }
    var _am_ = enqueue(t, function(slot){return caml_call1(f, 0);});
    return caml_call2(Async_kernel_Deferred_std[5][2], _am_, _al_);
   }
   function monad_sequence_how(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a){
         return enqueue$0(t, function(param){return caml_call1(f, a);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function monad_sequence_how2(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a1, a2){
         return enqueue$0(t, function(param){return caml_call2(f, a1, a2);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function prior_jobs_done(t){
    function _ad_(all_dummy_jobs_running){
     var dummy_jobs_running = [0, 0], _af_ = t[2], _ae_ = 1;
     if(_af_ >= 1){
      var for$0 = _ae_;
      for(;;){
       var
        _ag_ =
          enqueue$0
           (t,
            function(param){
             dummy_jobs_running[1]++;
             if
              (caml_call2(Async_kernel_Import[3], dummy_jobs_running[1], t[2]))
              caml_call2(Async_kernel_Ivar[14], all_dummy_jobs_running, 0);
             return caml_call1(Async_kernel_Ivar[18], all_dummy_jobs_running);
            });
       caml_call1(Async_kernel_Deferred_std[8], _ag_);
       var _ah_ = for$0 + 1 | 0;
       if(_af_ === for$0) break;
       var for$0 = _ah_;
      }
     }
     return 0;
    }
    return caml_call1(Async_kernel_Deferred1[4], _ad_);
   }
   function capacity_available$1(t){
    if(caml_call2(Async_kernel_Import[5], t[5], t[2]))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var match = t[6];
    if(match){
     var ivar = match[1];
     return caml_call1(Async_kernel_Ivar[18], ivar);
    }
    function _ac_(ivar){t[6] = [0, ivar]; return 0;}
    return caml_call1(Async_kernel_Deferred1[4], _ac_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttle);
   var
    Async_kernel_Throttle =
      [0,
       T2,
       sexp_of_t,
       invariant,
       create$0,
       create_with,
       sexp_of_outcome,
       enqueue,
       enqueue$0,
       enqueue_exclusive,
       monad_sequence_how,
       monad_sequence_how2,
       prior_jobs_done,
       max_concurrent_jobs,
       num_jobs_running,
       num_jobs_waiting_to_start,
       capacity_available$1,
       kill,
       is_dead,
       at_kill,
       cleaned$1,
       Sequencer];
   runtime.caml_register_global
    (81, Async_kernel_Throttle, cst_Async_kernel_Throttle$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/synchronous_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    default_timing_wheel_config = Async_kernel_Synchronous_time_[3],
    T1 = Async_kernel_Synchronous_time_[4],
    sexp_of_t = Async_kernel_Synchronous_time_[5],
    invariant = Async_kernel_Synchronous_time_[6],
    invariant_with_jobs = Async_kernel_Synchronous_time_[7],
    Read_write = Async_kernel_Synchronous_time_[8],
    id = Async_kernel_Synchronous_time_[9],
    is_wall_clock = Async_kernel_Synchronous_time_[10],
    length = Async_kernel_Synchronous_time_[11],
    max_allowed_alarm_time = Async_kernel_Synchronous_time_[12],
    read_only = Async_kernel_Synchronous_time_[13],
    alarm_precision = Async_kernel_Synchronous_time_[15],
    next_alarm_fires_at = Async_kernel_Synchronous_time_[16],
    next_alarm_runs_at = Async_kernel_Synchronous_time_[17],
    now = Async_kernel_Synchronous_time_[18],
    timing_wheel_now = Async_kernel_Synchronous_time_[19],
    Event = Async_kernel_Synchronous_time_[22],
    run_after = Async_kernel_Synchronous_time_[23],
    run_at = Async_kernel_Synchronous_time_[24],
    run_at_intervals = Async_kernel_Synchronous_time_[25],
    advance_by_alarms = Async_kernel_Synchronous_time_[32],
    advance_by_max_alarms_in_each_ = Async_kernel_Synchronous_time_[33],
    advance_directly = Async_kernel_Synchronous_time_[34],
    duration_of = Async_kernel_Synchronous_time_[35],
    max_alarm_time_in_min_timing_w = Async_kernel_Synchronous_time_[36],
    has_events_to_run = Async_kernel_Synchronous_time_[37],
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    _a_ = Event[3],
    Async_kernel_Synchronous_time_$0 =
      [0,
       [0, T1[17]],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t,
       invariant_with_jobs,
       invariant,
       id,
       read_only,
       create,
       alarm_precision,
       is_wall_clock,
       now,
       timing_wheel_now,
       run_at,
       run_after,
       run_at_intervals,
       max_allowed_alarm_time,
       duration_of,
       [0,
        Event[17],
        Event[18],
        [0,
         _a_[8],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[9],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[7]],
        Event[25],
        Event[26],
        Event[28],
        Event[29],
        Event[30],
        Event[32],
        Event[31],
        Event[33],
        Event[35],
        Event[36],
        Event[37],
        Event[38],
        Event[39],
        Event[21]],
       default_timing_wheel_config,
       wall_clock,
       length,
       next_alarm_runs_at,
       next_alarm_fires_at,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (14, Async_kernel_Synchronous_time_$0, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Job_queue, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Backtrace, Core, Core__Deque, Core__Error, Core__Gc, Core__Hashtbl, Core__Heap_block, Core__List, Core__Option, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler$0 = "Async_kernel__Scheduler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_scheduler_ml = "src/scheduler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Backtrace = global_data.Base__Backtrace,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Core_Error = global_data.Core__Error,
    Core_Option = global_data.Core__Option,
    Core_List = global_data.Core__List,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Core_Heap_block = global_data.Core__Heap_block,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Core_Gc = global_data.Core__Gc,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    start_cycle = Async_kernel_Scheduler1[77],
    create_job = Async_kernel_Scheduler1[75],
    with_execution_context = Async_kernel_Scheduler1[74],
    with_execution_context1 = Async_kernel_Scheduler1[73],
    current_execution_context = Async_kernel_Scheduler1[72],
    check_access = Async_kernel_Scheduler1[70],
    t_ref = Async_kernel_Scheduler1[69],
    set_check_access = Async_kernel_Scheduler1[68],
    is_dead = Async_kernel_Scheduler1[67],
    enqueue_job = Async_kernel_Scheduler1[64],
    enqueue = Async_kernel_Scheduler1[63],
    free_job = Async_kernel_Scheduler1[62],
    invariant = Async_kernel_Scheduler1[61],
    last_cycle_num_jobs = Async_kernel_Scheduler1[58],
    num_jobs_run = Async_kernel_Scheduler1[57],
    num_pending_jobs = Async_kernel_Scheduler1[56],
    uncaught_exn = Async_kernel_Scheduler1[55],
    uncaught_exn_unwrapped = Async_kernel_Scheduler1[54],
    sexp_of_t = Async_kernel_Scheduler1[53],
    last_cycle_time = Async_kernel_Scheduler1[29],
    Very_low_priority_worker = Async_kernel_Scheduler1[6],
    debug = Async_kernel_Scheduler1[3],
    set_execution_context = Async_kernel_Scheduler1[2],
    events = Async_kernel_Scheduler1[1],
    t = Async_kernel_Scheduler1[71],
    include = Async_kernel_Monitor[26],
    within = include[1],
    within$0 = include[2],
    within_v = include[3],
    schedule = include[4],
    schedule$0 = include[5],
    within_context = include[6],
    preserve_execution_context = include[7],
    preserve_execution_context$0 = include[8],
    _c_ = [0, cst_src_scheduler_ml, 324, 4],
    _d_ = [0, 1],
    _b_ = [0, "n"],
    cst_Scheduler_yield_every_got_ =
      "Scheduler.yield_every got nonpositive count",
    cst_reset_in_forked_process = "reset_in_forked_process",
    cst_Async_scheduler_is_unusabl =
      "Async scheduler is unusable due to [make_async_unusable]",
    cst_run_cycles_until_no_jobs_r =
      "run_cycles_until_no_jobs_remain starting",
    _a_ = [0, "scheduler"],
    cst_run_cycles_until_no_jobs_r$0 =
      "run_cycles_until_no_jobs_remain cannot proceed -- scheduler is dead",
    cst_run_cycles_until_no_jobs_r$1 =
      "run_cycles_until_no_jobs_remain finished",
    cst_run_cycle_starting = "run_cycle starting",
    cst_run_cycle_finished = "run_cycle finished",
    cst_enqueueing_finalizer_using =
      "enqueueing finalizer (using 'last' semantic)",
    cst_adding_finalizer_using_las =
      "adding finalizer (using 'last' semantic)",
    cst_enqueueing_finalizer = "enqueueing finalizer",
    cst_adding_finalizer = "adding finalizer",
    cst_Attempted_to_remove_a_cycl$0 =
      "Attempted to remove a cycle end hook which has already been removed.",
    cst_Attempted_to_remove_a_cycl =
      "Attempted to remove a cycle start hook which has already been removed.",
    cst_Scheduler_remove_single_cy =
      "Scheduler.remove_single_cycle_hook called with a hook that isn't registered",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler = cst_Async_kernel_Scheduler$0;
   function find_local(key){
    var _af_ = caml_call1(current_execution_context, caml_call1(t, 0));
    return caml_call2(Async_kernel_Execution_context[10], _af_, key);
   }
   function with_local(key, value, f){
    var
     t$0 = caml_call1(t, 0),
     _ae_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call3(Async_kernel_Execution_context[11], _ae_, key, value);
    return caml_call3(with_execution_context, t$0, execution_context, f);
   }
   var main_execution_context = caml_call1(t, 0)[6];
   function can_run_a_job(t){
    var
     _ac_ = caml_call1(num_pending_jobs, t),
     _ad_ = caml_call2(Async_kernel_Import[4], _ac_, 0);
    return _ad_ ? _ad_ : caml_call1(Async_kernel_Bvar[6], t[24]);
   }
   function has_upcoming_event(t){
    var _ab_ = caml_call1(events, t);
    return 1 - caml_call1(Timing_wheel[13], _ab_);
   }
   function next_upcoming_event(t){
    var _aa_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[38], _aa_);
   }
   function next_upcoming_event_exn(t){
    var _$_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[39], _$_);
   }
   function event_precision(t){
    var ___ = caml_call1(events, t);
    return caml_call1(Timing_wheel[10], ___);
   }
   function cycle_start(t){return t[10];}
   function run_every_cycle_start(t, f){t[12] = [0, f, t[12]]; return 0;}
   function run_every_cycle_end(t, f){t[14] = [0, f, t[14]]; return 0;}
   function add_every_cycle_start_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[13], handle, f);
    run_every_cycle_start(t, f);
    return handle;
   }
   function add_every_cycle_end_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[15], handle, f);
    run_every_cycle_end(t, f);
    return handle;
   }
   function remove_single_cycle_hook(lst, f){
    var f$0 = caml_call1(Core[246], f);
    function _X_(x){return 1 - caml_call1(f$0, x);}
    var
     _Y_ = caml_call2(Core_List[130], lst, _X_),
     match = _Y_[2],
     l = _Y_[1];
    if(match)
     var r = match[2], match$0 = [0, caml_call2(Core[157], l, r)];
    else
     var match$0 = 0;
    if(match$0){var lst$0 = match$0[1]; return lst$0;}
    var
     _Z_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_remove_single_cy);
    return caml_call1(Core[253], _Z_);
   }
   function remove_every_cycle_start_hook_(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[13], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl);
    var f = match[1];
    t[12] = remove_single_cycle_hook(t[12], f);
    return 0;
   }
   function remove_every_cycle_end_hook_ex(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[15], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl$0);
    var f = match[1];
    t[14] = remove_single_cycle_hook(t[14], f);
    return 0;
   }
   function map_cycle_times(t, f){
    function _V_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _W_ = caml_call1(f, t[16]);
               return caml_call2(Async_kernel_Tail[3], tail, _W_);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _V_);
   }
   function long_cycles(t, at_least){
    function _T_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _U_ = caml_call2(Core_Time_ns[1][15], t[16], at_least);
               return _U_
                       ? caml_call2(Async_kernel_Tail[3], tail, t[16])
                       : _U_;
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _T_);
   }
   function cycle_num_jobs(t){
    function _S_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               return caml_call2(Async_kernel_Tail[3], tail, t[17]);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _S_);
   }
   function cycle_count(t){return t[9];}
   function set_max_num_jobs_per_priority_(t, int$0){
    t[27] = caml_call1(Async_kernel_config[5][4], int$0);
    return 0;
   }
   function max_num_jobs_per_priority_per_(t){
    return caml_call1(Async_kernel_config[5][5], t[27]);
   }
   function set_thread_safe_external_job_h(t, f){t[21] = f; return 0;}
   function thread_safe_enqueue_external_j(t, execution_context, f, a){
    caml_call2(Thread_safe_queue[5], t[20], [0, execution_context, f, a]);
    return caml_call1(t[21], 0);
   }
   function set_event_added_hook(t, f){t[23] = [0, f]; return 0;}
   function set_job_queued_hook(t, f){t[22] = [0, f]; return 0;}
   function create_alarm(t, f){
    var execution_context = caml_call1(current_execution_context, t);
    function _R_(param){
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    return caml_call1(Core_Gc[10][6][2], _R_);
   }
   function add_finalizer(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(heap_block){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer);
     return thread_safe_enqueue_external_j
             (t, execution_context, f, heap_block);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer);
    try{var _P_ = caml_call2(Stdlib_Gc[3], finalizer, heap_block); return _P_;
    }
    catch(_Q_){
     var _O_ = caml_wrap_exception(_Q_);
     if(_O_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_O_, 0);
    }
   }
   function add_finalizer_exn(t, x, f){
    function _N_(heap_block){
     return caml_call1(f, caml_call1(Core_Heap_block[4], heap_block));
    }
    return add_finalizer(t, caml_call1(Core_Heap_block[3], x), _N_);
   }
   function add_finalizer_last(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(param){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer_using);
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer_using_las);
    try{var _L_ = caml_call2(Stdlib_Gc[4], finalizer, heap_block); return _L_;
    }
    catch(_M_){
     var _K_ = caml_wrap_exception(_M_);
     if(_K_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_K_, 0);
    }
   }
   function add_finalizer_last_exn(t, x, f){
    return add_finalizer_last(t, caml_call1(Core_Heap_block[3], x), f);
   }
   function force_current_cycle_to_end(t){
    return caml_call2(Async_kernel_Job_queue[6], t[3], 0);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_clock(t, now){
    return caml_call3
            (Async_kernel_Synchronous_time_[29], t[19], now, send_exn);
   }
   function run_cycle(t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_run_cycle_starting, t, sexp_of_t);
    var now = caml_call1(Async_kernel_Time_ns[50], 0);
    t[9] = t[9] + 1 | 0;
    t[10] = now;
    t[11] = 1;
    caml_call2(Async_kernel_Bvar[5], t[24], 0);
    var num_jobs_run_at_start_of_cycle = caml_call1(num_jobs_run, t);
    function _y_(f){return caml_call1(f, 0);}
    caml_call2(Core_List[9], t[12], _y_);
    advance_clock(t, now);
    caml_call2(start_cycle, t, t[27]);
    for(;;){
     var match = caml_call1(Async_kernel_Scheduler1[78], t);
     if(0 === match[0]) break;
     var
      match$0 = match[1],
      backtrace = match$0[2],
      exn = match$0[1],
      _z_ = caml_call1(Async_kernel_Monitor[5], 0);
     caml_call3
      (Async_kernel_Monitor[15], _z_, [0, [0, 936718974, backtrace]], exn);
    }
    var
     _A_ = t[10],
     _B_ = caml_call1(Async_kernel_Time_ns[50], 0),
     cycle_time = caml_call2(Async_kernel_Time_ns[57], _B_, _A_);
    t[16] = cycle_time;
    t[17] = caml_call1(num_jobs_run, t) - num_jobs_run_at_start_of_cycle | 0;
    t[18] = caml_call2(Core_Time_ns[1][97], t[18], cycle_time);
    var _C_ = caml_call1(Async_kernel_Bvar[6], t[25]);
    if(_C_)
     var
      _D_ = caml_call1(num_pending_jobs, t),
      _E_ = caml_call2(Async_kernel_Import[3], _D_, 0);
    else
     var _E_ = _C_;
    if(_E_) caml_call2(Async_kernel_Bvar[5], t[25], 0);
    function _F_(f){return caml_call1(f, 0);}
    caml_call2(Core_List[9], t[14], _F_);
    t[11] = 0;
    if(! debug) return debug;
    function _G_(param){
     var
      arg1_002 = param[2],
      arg0_001 = param[1],
      res0_003 = caml_call2(Core[454], Core_Error[6], arg0_001),
      res1_004 = caml_call1(Core[305], arg1_002);
     return [1, [0, res0_003, [0, res1_004, 0]]];
    }
    var
     _H_ = next_upcoming_event(t),
     _I_ = caml_call1(Core[243], _H_),
     _J_ = [0, caml_call1(uncaught_exn, t), _I_];
    return caml_call3
            (Async_kernel_Debug[15], cst_run_cycle_finished, _J_, _G_);
   }
   function run_cycles_until_no_jobs_remai(param){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r);
    var t$0 = caml_call1(t, 0);
    if(caml_call1(is_dead, t$0)){
     var
      _u_ = [0, [1, [0, _a_, [0, caml_call1(sexp_of_t, t$0), 0]]], 0],
      _v_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_run_cycles_until_no_jobs_r$0),
          _u_]];
     caml_call1(Core[253], _v_);
    }
    for(;;){
     run_cycle(t$0);
     advance_clock(t$0, caml_call1(Async_kernel_Time_ns[50], 0));
     if(! can_run_a_job(t$0)){
      caml_call2(set_execution_context, t$0, t$0[6]);
      if(debug)
       caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r$1);
      var _w_ = Core_Error[28], _x_ = caml_call1(uncaught_exn, t$0);
      return caml_call2(Core_Option[41], _x_, _w_);
     }
    }
   }
   function make_async_unusable(param){
    var t = t_ref[1];
    t[1] =
     [0,
      function(param){
       var
        _t_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_scheduler_is_unusabl);
       return caml_call1(Core[253], _t_);
      }];
    return 0;
   }
   function reset_in_forked_process(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_reset_in_forked_process);
    var _s_ = caml_call1(Async_kernel_Scheduler1[66], 0);
    Async_kernel_Scheduler1[69][1] = _s_;
    return 0;
   }
   function check_invariants(t){return t[26];}
   function set_check_invariants(t, b){t[26] = b; return 0;}
   function set_record_backtraces(t, b){t[28] = b; return 0;}
   function yield$0(t){return caml_call1(Async_kernel_Bvar[4], t[24]);}
   function yield_until_no_jobs_remain(opt, t){
    if(opt)
     var sth = opt[1], may_return_immediately = sth;
    else
     var may_return_immediately = 0;
    if(may_return_immediately){
     var _r_ = caml_call1(num_pending_jobs, t);
     if(caml_call2(Async_kernel_Import[3], _r_, 0))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    return caml_call1(Async_kernel_Bvar[4], t[25]);
   }
   function yield_every(n){
    if(caml_call2(Async_kernel_Import[2], n, 0)){
     var
      _n_ = [0, [1, [0, _b_, [0, caml_call1(Core[356], n), 0]]], 0],
      _o_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_yield_every_got_),
          _n_]];
     return caml_call1(Core[253], _o_);
    }
    if(caml_call2(Async_kernel_Import[3], n, 1)){
     var _p_ = function(t){return yield$0(t);};
     return caml_call1(Core[258], _p_);
    }
    var count_until_yield = [0, n];
    function _q_(t){
     count_until_yield[1] += -1;
     return caml_call2(Async_kernel_Import[4], count_until_yield[1], 0)
             ? caml_call1(Async_kernel_Deferred_std[10], 0)
             : (count_until_yield[1] = n, yield$0(t));
    }
    return caml_call1(Core[258], _q_);
   }
   function total_cycle_time(t){
    if(! t[11]) return t[18];
    var
     _l_ = t[10],
     _m_ = caml_call1(Async_kernel_Time_ns[50], 0),
     this_cycle_time = caml_call2(Async_kernel_Time_ns[57], _m_, _l_);
    return caml_call2(Core_Time_ns[1][97], t[18], this_cycle_time);
   }
   function run(t){
    var num_execs_before_yielding = 1000;
    for(;;){
     if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding, 0))
      return yield_then_run(t);
     var _j_ = 1 - caml_call1(Core_Deque[16], t[5]);
     if(! _j_) return _j_;
     var worker = caml_call1(Core_Deque[61], t[5]);
     caml_call2(set_execution_context, t, worker[1]);
     a:
     {
      var num_execs_before_yielding$0 = num_execs_before_yielding;
      for(;;){
       if(! caml_call2(Core[246], t[7], worker[1]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding$0, 0)){caml_call2(Core_Deque[52], t[5], worker); return yield_then_run(t);}
       var num_execs_before_yielding$1 = num_execs_before_yielding$0 - 1 | 0;
       try{var val = caml_call1(worker[2], 0);}
       catch(exn$0){var exn = caml_wrap_exception(exn$0); break;}
       if(! val) break a;
       var num_execs_before_yielding$0 = num_execs_before_yielding$1;
      }
      var
       bt = caml_call1(Base_Backtrace[6][4], 0),
       _k_ = caml_call1(Async_kernel_Monitor[5], 0);
      caml_call3(Async_kernel_Monitor[15], _k_, [0, [0, 936718974, bt]], exn);
      var num_execs_before_yielding = num_execs_before_yielding$1;
      continue;
     }
     var num_execs_before_yielding = num_execs_before_yielding$1;
    }
   }
   function yield_then_run(t){
    var _g_ = 1 - caml_call1(Core_Deque[16], t[5]);
    if(! _g_) return _g_;
    function _h_(param){return run(t);}
    var _i_ = yield$0(t);
    return caml_call2(Async_kernel_Deferred1[8], _i_, _h_);
   }
   function enqueue$0(f){
    var
     t$0 = caml_call1(t, 0),
     queue = t$0[5],
     running = 1 - caml_call1(Core_Deque[16], queue),
     _e_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call4(Async_kernel_Execution_context[9], 0, _d_, 0, _e_);
    caml_call2(Core_Deque[53], queue, [0, execution_context, f]);
    var _f_ = 1 - running;
    return _f_ ? caml_call4(enqueue, t$0, execution_context, run, t$0) : _f_;
   }
   var For_bench = [0, advance_clock];
   function in_cycle(t){return t[11];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler);
   var
    Async_kernel_Scheduler =
      [0,
       sexp_of_t,
       t,
       invariant,
       current_execution_context,
       with_execution_context,
       with_execution_context1,
       set_execution_context,
       enqueue,
       create_job,
       enqueue_job,
       free_job,
       main_execution_context,
       cycle_start,
       run_cycle,
       run_cycles_until_no_jobs_remai,
       has_upcoming_event,
       next_upcoming_event,
       next_upcoming_event_exn,
       event_precision,
       uncaught_exn,
       uncaught_exn_unwrapped,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs,
       map_cycle_times,
       cycle_num_jobs,
       cycle_count,
       total_cycle_time,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       set_check_access,
       check_access,
       check_invariants,
       set_check_invariants,
       set_record_backtraces,
       run_every_cycle_start,
       run_every_cycle_end,
       add_every_cycle_start_hook,
       add_every_cycle_end_hook,
       remove_every_cycle_start_hook_,
       remove_every_cycle_end_hook_ex,
       last_cycle_time,
       long_cycles,
       can_run_a_job,
       create_alarm,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       set_thread_safe_external_job_h,
       set_job_queued_hook,
       set_event_added_hook,
       thread_safe_enqueue_external_j,
       force_current_cycle_to_end,
       within,
       within$0,
       within_v,
       schedule,
       schedule$0,
       preserve_execution_context,
       preserve_execution_context$0,
       within_context,
       find_local,
       with_local,
       make_async_unusable,
       reset_in_forked_process,
       yield$0,
       yield_every,
       yield_until_no_jobs_remain,
       [0, Very_low_priority_worker[1], enqueue$0],
       For_bench,
       in_cycle];
   runtime.caml_register_global
    (61, Async_kernel_Scheduler, cst_Async_kernel_Scheduler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Cycle_hook
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Cycle_hook = "Async_kernel__Cycle_hook",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Cycle_hook);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/cycle_hook.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Handle = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Cycle_hook);
   var Async_kernel_Cycle_hook = [0, Handle];
   runtime.caml_register_global
    (11, Async_kernel_Cycle_hook, cst_Async_kernel_Cycle_hook);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_kernel_scheduler
//# unitInfo: Requires: Async_kernel__Scheduler, Async_kernel__Time_ns, Base__Staged, Core, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_kernel_$0 = "Async_kernel__Async_kernel_scheduler",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_kernel_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/async_kernel_scheduler.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    t = Async_kernel_Scheduler[2],
    with_execution_context = Async_kernel_Scheduler[5],
    with_execution_context1 = Async_kernel_Scheduler[6],
    enqueue = Async_kernel_Scheduler[8],
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    last_cycle_num_jobs = Async_kernel_Scheduler[24],
    map_cycle_times = Async_kernel_Scheduler[25],
    run_every_cycle_start = Async_kernel_Scheduler[36],
    run_every_cycle_end = Async_kernel_Scheduler[37],
    add_every_cycle_start_hook = Async_kernel_Scheduler[38],
    add_every_cycle_end_hook = Async_kernel_Scheduler[39],
    remove_every_cycle_start_hook_ = Async_kernel_Scheduler[40],
    remove_every_cycle_end_hook_ex = Async_kernel_Scheduler[41],
    thread_safe_enqueue_external_j = Async_kernel_Scheduler[53],
    within = Async_kernel_Scheduler[55],
    within$0 = Async_kernel_Scheduler[56],
    within_v = Async_kernel_Scheduler[57],
    schedule = Async_kernel_Scheduler[58],
    schedule$0 = Async_kernel_Scheduler[59],
    preserve_execution_context = Async_kernel_Scheduler[60],
    preserve_execution_context$0 = Async_kernel_Scheduler[61],
    within_context = Async_kernel_Scheduler[62],
    find_local = Async_kernel_Scheduler[63],
    with_local = Async_kernel_Scheduler[64],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_kernel_ = cst_Async_kernel_Async_kernel_$0,
    _a_ = Async_kernel_Scheduler[4],
    _b_ = Async_kernel_Scheduler[13],
    _c_ = Async_kernel_Scheduler[19],
    _d_ = Async_kernel_Scheduler[22],
    _e_ = Async_kernel_Scheduler[23],
    _f_ = Async_kernel_Scheduler[27],
    _g_ = Async_kernel_Scheduler[28],
    _h_ = Async_kernel_Scheduler[29],
    _i_ = Async_kernel_Scheduler[30],
    _j_ = Async_kernel_Scheduler[35],
    _k_ = Async_kernel_Scheduler[42],
    _l_ = Async_kernel_Scheduler[43],
    _m_ = Async_kernel_Scheduler[54],
    _n_ = Async_kernel_Scheduler[67],
    _o_ = Async_kernel_Scheduler[68],
    _p_ = Async_kernel_Scheduler[69];
   function enqueue_job(execution_context, f, a){
    return caml_call4(enqueue, caml_call1(t, 0), execution_context, f, a);
   }
   function thread_safe_enqueue_job(execution_context, f, a){
    return caml_call4
            (thread_safe_enqueue_external_j,
             caml_call1(t, 0),
             execution_context,
             f,
             a);
   }
   function current_execution_context(param){
    return caml_call1(_a_, caml_call1(t, 0));
   }
   function cycle_count(param){return caml_call1(_f_, caml_call1(t, 0));}
   function cycle_start_ns(param){return caml_call1(_b_, caml_call1(t, 0));}
   function cycle_start(param){
    var _w_ = cycle_start_ns(0);
    return caml_call1(Async_kernel_Time_ns[70], _w_);
   }
   function cycle_times_ns(param){
    function _u_(_v_){return _v_;}
    return caml_call2(map_cycle_times, caml_call1(t, 0), _u_);
   }
   function cycle_times(param){
    var _t_ = Core_Time_ns[1][134];
    return caml_call2(map_cycle_times, caml_call1(t, 0), _t_);
   }
   function total_cycle_time(param){return caml_call1(_g_, caml_call1(t, 0));}
   function last_cycle_time(param){return caml_call1(_k_, caml_call1(t, 0));}
   function long_cycles(at_least){
    return caml_call2(_l_, caml_call1(t, 0), at_least);
   }
   function event_precision_ns(param){
    return caml_call1(_c_, caml_call1(t, 0));
   }
   function event_precision(param){
    var _s_ = event_precision_ns(0);
    return caml_call1(Core_Time_ns[1][134], _s_);
   }
   function set_max_num_jobs_per_priority_(i){
    return caml_call2(_i_, caml_call1(t, 0), i);
   }
   function max_num_jobs_per_priority_per_(param){return caml_call1(_h_, caml_call1(t, 0));
   }
   function set_record_backtraces(bool){
    return caml_call2(_j_, caml_call1(t, 0), bool);
   }
   function force_current_cycle_to_end(param){return caml_call1(_m_, caml_call1(t, 0));
   }
   function yield$0(param){return caml_call1(_n_, caml_call1(t, 0));}
   function yield_until_no_jobs_remain(may_return_immediately, param){return caml_call2(_p_, may_return_immediately, caml_call1(t, 0));
   }
   function yield_every(n){
    var
     _q_ = caml_call1(_o_, n),
     yield_every = caml_call1(Base_Staged[2], _q_),
     t$0 = caml_call1(t, 0);
    function _r_(param){return caml_call1(yield_every, t$0);}
    return caml_call1(Core[258], _r_);
   }
   function num_jobs_run(param){return caml_call1(_e_, caml_call1(t, 0));}
   function num_pending_jobs(param){return caml_call1(_d_, caml_call1(t, 0));}
   function last_cycle_num_jobs$0(param){
    return caml_call1(last_cycle_num_jobs, caml_call1(t, 0));
   }
   function run_every_cycle_start$0(f){
    return caml_call2(run_every_cycle_start, caml_call1(t, 0), f);
   }
   function run_every_cycle_end$0(f){
    return caml_call2(run_every_cycle_end, caml_call1(t, 0), f);
   }
   function add_every_cycle_start_hook$0(f){
    return caml_call2(add_every_cycle_start_hook, caml_call1(t, 0), f);
   }
   function add_every_cycle_end_hook$0(f){
    return caml_call2(add_every_cycle_end_hook, caml_call1(t, 0), f);
   }
   function remove_every_cycle_start_hook_$0(handle){
    return caml_call2
            (remove_every_cycle_start_hook_, caml_call1(t, 0), handle);
   }
   function remove_every_cycle_end_hook_ex$0(handle){
    return caml_call2
            (remove_every_cycle_end_hook_ex, caml_call1(t, 0), handle);
   }
   function with_execution_context$0(execution_context, f){
    return caml_call3
            (with_execution_context, caml_call1(t, 0), execution_context, f);
   }
   function with_execution_context1$0(execution_context, f, x){
    return caml_call4
            (with_execution_context1,
             caml_call1(t, 0),
             execution_context,
             f,
             x);
   }
   var
    Expert =
      [0,
       run_cycles_until_no_jobs_remai,
       last_cycle_num_jobs$0,
       run_every_cycle_start$0,
       run_every_cycle_end$0,
       add_every_cycle_start_hook$0,
       add_every_cycle_end_hook$0,
       remove_every_cycle_start_hook_$0,
       remove_every_cycle_end_hook_ex$0,
       with_execution_context$0,
       with_execution_context1$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_kernel_);
   var
    Async_kernel_Async_kernel_sche =
      [0,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert];
   runtime.caml_register_global
    (16, Async_kernel_Async_kernel_sche, cst_Async_kernel_Async_kernel_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_intf$0 = "Async_kernel__Clock_intf",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_intf$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/clock_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, "Timeout"],
    _b_ = [0, "Result"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_intf = cst_Async_kernel_Clock_intf$0;
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && 642269825 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 1025039613 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return runtime.caml_compare(a_001, b_002);
   }
   function sexp_of_t(of_a_005, param){
    if(typeof param === "number") return _a_;
    var v_006 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_005, v_006), 0]]];
   }
   var Or_timeout = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_intf);
   var Async_kernel_Clock_intf = [0, Or_timeout];
   runtime.caml_register_global
    (14, Async_kernel_Clock_intf, cst_Async_kernel_Clock_intf$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_ns
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Time_source, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_ns$0 = "Async_kernel__Clock_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/clock_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_ns = cst_Async_kernel_Clock_ns$0;
   function time_source(param){
    var _q_ = caml_call1(Async_kernel_Scheduler1[71], 0)[19];
    return caml_call1(Async_kernel_Time_source[39], _q_);
   }
   function after(span){
    var _p_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[29], _p_, span);
   }
   function at(time){
    var _o_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[28], _o_, time);
   }
   function at_varying_intervals(stop, compute_span){
    var _n_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[33], stop, _n_, compute_span);
   }
   function at_intervals(start, stop, interval){
    var _m_ = time_source(0);
    return caml_call4
            (Async_kernel_Time_source[34], start, stop, _m_, interval);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _l_ = time_source(0);
    return caml_call7
            (Async_kernel_Time_source[35],
             start,
             stop,
             continue_on_error,
             finished,
             _l_,
             span,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _k_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[36],
             start,
             stop,
             continue_on_error,
             _k_,
             span,
             f);
   }
   function run_after(span, f, a){
    var _j_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[27], _j_, span, f, a);
   }
   function run_at(time, f, a){
    var _i_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[26], _i_, time, f, a);
   }
   function run_at_intervals(start, stop, continue_on_error, interval, f){
    var _h_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[38],
             start,
             stop,
             continue_on_error,
             _h_,
             interval,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, interval, f){
    var _g_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[37],
             start,
             stop,
             continue_on_error,
             _g_,
             interval,
             f);
   }
   function with_timeout(span, d){
    var _f_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[30], _f_, span, d);
   }
   function duration_of(f){
    var _e_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[31], _e_, f);
   }
   var
    include = Async_kernel_Time_source[32],
    sexp_of_t = include[1],
    sexp_of_t_unit = include[2],
    invariant = include[3],
    scheduled_at = include[4],
    Status = include[5],
    status = include[6],
    abort = include[10],
    abort_exn = include[11],
    abort_if_possible = include[12],
    fired = include[14],
    reschedule_at = include[16],
    reschedule_after = include[17],
    _a_ = include[7],
    _b_ = include[8],
    _c_ = include[18],
    _d_ = include[19];
   function after$0(span){return caml_call2(_d_, time_source(0), span);}
   function run_after$0(span, f, a){
    return caml_call4(_b_, time_source(0), span, f, a);
   }
   function at$0(time){return caml_call2(_c_, time_source(0), time);}
   function run_at$0(time, f, z){
    return caml_call4(_a_, time_source(0), time, f, z);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_ns);
   var
    Async_kernel_Clock_ns =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals$0,
       run_at_intervals,
       duration_of];
   runtime.caml_register_global
    (13, Async_kernel_Clock_ns, cst_Async_kernel_Clock_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_array
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__Array, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_arra$0 = "Async_kernel__Deferred_array",
    cst_async_kernel$0 = "async_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Array = global_data.Core__Array,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_arra$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_array.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_arra = cst_Async_kernel_Deferred_arra$0;
   function foldi(t, init, f){
    function _L_(result){
     function loop(i, b){
      if(caml_call2(Core[90], i, t.length - 1))
       return caml_call2(Async_kernel_Ivar[14], result, b);
      function _M_(b){return loop(i + 1 | 0, b);}
      var _N_ = caml_call3(f, i, b, caml_check_bound(t, i)[1 + i]);
      return caml_call2(Async_kernel_Deferred_std[1], _N_, _M_);
     }
     return loop(0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _L_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    function _G_(bs){
     var _K_ = caml_call1(Core_List[34], bs);
     return caml_call1(Core_Array[52], _K_);
    }
    var
     _H_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          function _I_(b){return [0, b, bs];}
          var _J_ = caml_call2(f, i, a);
          return caml_call2(Async_kernel_Deferred_std[4], _J_, _I_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _H_, _G_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _F_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _F_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _D_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _E_ = caml_call1(Core[259], _D_);
    return all_unit(caml_call2(Core_Array[59], t, _E_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _B_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _C_ = caml_call1(Core[259], _B_);
    return all(caml_call2(Core_Array[59], t, _C_));
   }
   function filteri(how, t, f){
    function _x_(bools){
     function _z_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _A_ = caml_call4(Core_Array[82], t, bools, 0, _z_);
     return caml_call1(Core_Array[90], _A_);
    }
    var _y_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _y_, _x_);
   }
   function filter_mapi(how, t, f){
    var _v_ = Core_Array[74], _w_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function concat_mapi(how, t, f){
    function _s_(t){
     var _u_ = caml_call1(Core_Array[32], t);
     return caml_call1(Core_Array[44], _u_);
    }
    var _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _t_, _s_);
   }
   function find_mapi(t, f){
    function aux(i){
     if(caml_call2(Core[90], i, t.length - 1))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : aux(i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return aux(0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_Array[40], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_arra);
   var
    Async_kernel_Deferred_array =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_array, cst_Async_kernel_Deferred_arra$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_list
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_list$0 = "Async_kernel__Deferred_list",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_list$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_list.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_list = cst_Async_kernel_Deferred_list$0;
   function foldi(t, init, f){
    function _J_(result){
     function loop(t, i, b){
      if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
      var xs = t[2], x = t[1];
      function _K_(b){return loop(xs, i + 1 | 0, b);}
      var _L_ = caml_call3(f, i, b, x);
      return caml_call2(Async_kernel_Deferred_std[1], _L_, _K_);
     }
     return loop(t, 0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _J_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _F_ = Core_List[34],
     _G_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          function _H_(b){return [0, b, bs];}
          var _I_ = caml_call2(f, i, a);
          return caml_call2(Async_kernel_Deferred_std[5][2], _I_, _H_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _G_, _F_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _E_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _E_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _C_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _D_ = caml_call1(Core[259], _C_);
    return all_unit(caml_call2(Core_List[92], t, _D_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _A_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _B_ = caml_call1(Core[259], _A_);
    return all(caml_call2(Core_List[92], t, _B_));
   }
   function filteri(how, t, f){
    function _w_(bools){
     function _y_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _z_ = caml_call4(Core_List[42], t, bools, 0, _y_);
     return caml_call1(Core_List[34], _z_);
    }
    var _x_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
   }
   function filter_mapi(how, t, f){
    var _u_ = Core_List[124], _v_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _v_, _u_);
   }
   function concat_mapi(how, t, f){
    var _s_ = Core_List[133], _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var tl = t[2], hd = t[1];
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(tl, f, i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, hd);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_List[119], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_list);
   var
    Async_kernel_Deferred_list =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (19, Async_kernel_Deferred_list, cst_Async_kernel_Deferred_list$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_map
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_list, Async_kernel__Deferred_std, Async_kernel__Ivar, Base__Field, Base__List, Base__Map, Core__Map, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_map$0 = "Async_kernel__Deferred_map",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Map = global_data.Core__Map,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Base_List = global_data.Base__List,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Map = global_data.Base__Map,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_map.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, -542431297],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_map = cst_Async_kernel_Deferred_map$0;
   function change(t, k, f){
    function _K_(opt){
     function _M_(param){return opt;}
     return caml_call3(Core_Map[36], t, k, _M_);
    }
    var _L_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _L_, _K_);
   }
   function update(t, k, f){
    function _I_(data){return caml_call3(Core_Map[32], t, k, data);}
    var _J_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _J_, _I_);
   }
   function iter_keys(how, t, f){
    var _H_ = caml_call1(Core_Map[72], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _H_, f);
   }
   function iter(how, t, f){
    var _G_ = caml_call1(Core_Map[73], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _G_, f);
   }
   function iteri(how, t, f){
    function _E_(param){
     var data = param[2], key = param[1];
     return caml_call2(f, key, data);
    }
    var _F_ = caml_call2(Core_Map[74], 0, t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _F_, _E_);
   }
   function fold(t, init, f){
    function _C_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_increasing_key_order = caml_call3(Core_Map[57], t, 0, _C_);
    function _D_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_increasing_key_order,
             init,
             _D_);
   }
   function fold_right(t, init, f){
    function _A_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_decreasing_key_order = caml_call3(Core_Map[55], t, 0, _A_);
    function _B_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_decreasing_key_order,
             init,
             _B_);
   }
   function result(r){return r[3];}
   function filter_mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var
      comparator = caml_call1(Core_Map[2], t),
      sequence = caml_call4(Core_Map[101], _a_, 0, 0, t),
      _m_ =
        function(ivar){
         function _u_(x){
          var
           _y_ = caml_call1(Base_Map[104][3][96][3], x),
           _z_ = caml_call2(Core_Map[110][23], comparator, _y_);
          return caml_call2(Async_kernel_Ivar[14], ivar, _z_);
         }
         function _v_(s, param, k){
          var data = param[2], key = param[1];
          function _w_(param){
           if(! param) return caml_call1(k, s);
           var
            data = param[1],
            s$0 =
              caml_call4(Base_Map[104][3][96][2], s, comparator, key, data);
           return caml_call1(k, s$0);
          }
          var _x_ = caml_call2(f, key, data);
          return caml_call2(Async_kernel_Deferred_std[11], _x_, _w_);
         }
         return caml_call4
                 (Core_Sequence[105],
                  sequence,
                  Base_Map[104][3][96][1],
                  _v_,
                  _u_);
        };
     return caml_call1(Async_kernel_Deferred1[4], _m_);
    }
    var jobs = [0, 0];
    function _n_(key, data){
     var job = [0, key, data, 0];
     jobs[1] = [0, job, jobs[1]];
     return job;
    }
    var job_map = caml_call2(Core_Map[52], t, _n_);
    function _o_(param){return caml_call2(Core_Map[62], job_map, result);}
    function _p_(job){
     var data = job[2], key = job[1];
     function _s_(x){job[3] = x; return 0;}
     var _t_ = caml_call2(f, key, data);
     return caml_call2(Async_kernel_Deferred_std[5][2], _t_, _s_);
    }
    var
     _q_ = caml_call1(Base_List[38], jobs[1]),
     _r_ = caml_call3(Async_kernel_Deferred_list[14], [0, how], _q_, _p_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _r_, _o_);
   }
   function filter_map(how, t, f){
    return filter_mapi
            (how, t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _k_(b){return b ? [0, data] : 0;}
              var _l_ = caml_call1(f, key);
              return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
             });
   }
   function filter(how, t, f){
    return filter_mapi
            (how,
             t,
             function(param, data){
              function _i_(b){return b ? [0, data] : 0;}
              var _j_ = caml_call1(f, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
             });
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _g_(b){return b ? [0, data] : 0;}
              var _h_ = caml_call2(f, key, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
             });
   }
   function mapi(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _e_(z){return [0, z];}
              var _f_ = caml_call2(f, key, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
             });
   }
   function map(how, t, f){
    return mapi(how, t, function(param, data){return caml_call1(f, data);});
   }
   function merge(how, t1, t2, f){
    function _c_(thunk){return caml_call1(thunk, 0);}
    function _d_(key, z){
     return [0, function(param){return caml_call2(f, key, z);}];
    }
    return filter_map(how, caml_call3(Core_Map[77], t1, t2, _d_), _c_);
   }
   function all(t){return map(0, t, function(_b_){return _b_;});}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_map);
   var
    Async_kernel_Deferred_map =
      [0,
       change,
       update,
       iter_keys,
       iter,
       iteri,
       map,
       mapi,
       fold,
       fold_right,
       filter_keys,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       merge,
       all];
   runtime.caml_register_global
    (25, Async_kernel_Deferred_map, cst_Async_kernel_Deferred_map$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Monitor, Base__Exn, Base__Staged, Core__Memo, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo$0 = "Async_kernel__Deferred_memo",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Memo = global_data.Core__Memo,
    Base_Staged = global_data.Base__Staged,
    Base_Exn = global_data.Base__Exn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_memo.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _c_ = [0, 3804260],
    _d_ = [0, 3903734],
    _a_ = [0, 3804260],
    _b_ = [0, 3903734],
    cst_caught_exception_in_memoiz = "caught exception in memoized function",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_memo = cst_Async_kernel_Deferred_memo$0;
   function reraise(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    return caml_call2(Base_Exn[8], exn, cst_caught_exception_in_memoiz);
   }
   function general(hashable, f){
    function _h_(a){
     function _k_(param){return caml_call1(f, a);}
     return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _b_, _a_, _k_);
    }
    var f$0 = caml_call3(Core_Memo[1], [0, hashable[4]], 0, _h_);
    function _i_(a){
     var _j_ = caml_call1(f$0, a);
     return caml_call2(Async_kernel_Deferred_std[4], _j_, reraise);
    }
    return caml_call1(Base_Staged[1], _i_);
   }
   function unit(f){
    function _e_(param){
     return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _d_, _c_, f);
    }
    var f$0 = caml_call1(Core_Memo[3], _e_);
    function _f_(param){
     var _g_ = caml_call1(f$0, 0);
     return caml_call2(Async_kernel_Deferred_std[4], _g_, reraise);
    }
    return caml_call1(Base_Staged[1], _f_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo = [0, general, unit];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_memo, cst_Async_kernel_Deferred_memo$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_option
//# unitInfo: Requires: Async_kernel__Deferred1, Base__Monad, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_opti$0 = "Async_kernel__Deferred_option",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_opti$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_option.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_opti = cst_Async_kernel_Deferred_opti$0;
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _b_(param){
     if(! param) return caml_call1(Async_kernel_Deferred1[21], 0);
     var a = param[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _b_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _a_(r){return caml_call2(Core_Option[29], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _a_);
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_opti);
   var
    Async_kernel_Deferred_option =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_option, cst_Async_kernel_Deferred_opti$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_result
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Base__Monad, Core__Printf, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_resu$0 = "Async_kernel__Deferred_result",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Printf = global_data.Core__Printf,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_resu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_result.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_resu = cst_Async_kernel_Deferred_resu$0;
   function combine(t1, t2, ok, err){
    function _d_(param){
     var t2 = param[2], t1 = param[1];
     return caml_call4(Core_Result[40], t1, t2, ok, err);
    }
    var _e_ = caml_call2(Async_kernel_Deferred_std[5][3], t1, t2);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
   }
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _c_(error){
     if(0 !== error[0]) return caml_call1(Async_kernel_Deferred1[21], error);
     var a = error[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _c_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _b_(r){return caml_call2(Core_Result[38], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _b_);
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){return caml_call1(Async_kernel_Deferred1[21], [1, x]);}
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    function _a_(r){return caml_call2(Core_Result[39], r, f);}
    return caml_call2(Async_kernel_Deferred1[18], t, _a_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_resu);
   var
    Async_kernel_Deferred_result =
      [0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error,
       combine];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_result, cst_Async_kernel_Deferred_resu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_or_error
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_or_e$0 = "Async_kernel__Deferred_or_error",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_or_e$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_or_error.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    try_with = Async_kernel_Monitor[16],
    ignore_m = Async_kernel_Deferred_result[9],
    join = Async_kernel_Deferred_result[8],
    return$0 = Async_kernel_Deferred_result[6],
    bind = Async_kernel_Deferred_result[5],
    Monad_infix = Async_kernel_Deferred_result[4],
    symbol_bind = Async_kernel_Deferred_result[1],
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_or_e = cst_Async_kernel_Deferred_or_e$0,
    _a_ = Async_kernel_Deferred_result[7];
   function apply(f, x){
    function _aa_(e1, e2){
     return caml_call2(Core_Error[24], 0, [0, e1, [0, e2, 0]]);
    }
    function _ab_(f, x){return caml_call1(f, x);}
    return caml_call4(Async_kernel_Deferred_result[15], f, x, _ab_, _aa_);
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _$_ = caml_call1(Core_Result[27], error);
    return caml_call1(Async_kernel_Deferred1[21], _$_);
   }
   function ok_exn(t){
    return caml_call2(Async_kernel_Deferred1[18], t, Core_Or_error[36]);
   }
   function of_exn(exn){
    var ___ = caml_call2(Core_Or_error[37], 0, exn);
    return caml_call1(Async_kernel_Deferred1[21], ___);
   }
   function of_exn_result(t){
    var arg = Core_Or_error[38];
    function _Z_(eta){return caml_call2(arg, 0, eta);}
    return caml_call2(Async_kernel_Deferred1[18], t, _Z_);
   }
   function error(msg, v, sexp_of){
    var _Y_ = caml_call5(Core_Or_error[39], 0, 0, msg, v, sexp_of);
    return caml_call1(Async_kernel_Deferred1[21], _Y_);
   }
   function error_s(sexp){
    var _X_ = caml_call1(Core_Or_error[40], sexp);
    return caml_call1(Async_kernel_Deferred1[21], _X_);
   }
   function error_string(msg){
    var _W_ = caml_call1(Core_Or_error[41], msg);
    return caml_call1(Async_kernel_Deferred1[21], _W_);
   }
   function errorf(format){
    return caml_call2(Core[244], error_string, format);
   }
   function tag(t, tag){
    var _T_ = Core_Or_error[43];
    function _U_(_V_){return caml_call2(_T_, _V_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _U_);
   }
   function tag_s(t, tag){
    var _Q_ = Core_Or_error[44];
    function _R_(_S_){return caml_call2(_Q_, _S_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _R_);
   }
   function tag_s_lazy(t, tag){
    var _N_ = Core_Or_error[45];
    function _O_(_P_){return caml_call2(_N_, _P_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _O_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _M_(t){
     return caml_call4(Core_Or_error[46], t, message, a, sexp_of_a);
    }
    return caml_call2(Async_kernel_Deferred1[18], t, _M_);
   }
   function unimplemented(msg){
    var _L_ = caml_call1(Core_Or_error[47], msg);
    return caml_call1(Async_kernel_Deferred1[21], _L_);
   }
   function combine_errors(l){
    var
     _J_ = Core_Or_error[51],
     _K_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _K_, _J_);
   }
   function combine_errors_unit(l){
    var
     _H_ = Core_Or_error[52],
     _I_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _I_, _H_);
   }
   function filter_ok_at_least_one(l){
    var
     _F_ = Core_Or_error[53],
     _G_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _G_, _F_);
   }
   function find_map_ok(l, f){
    function _B_(param){
     var errors = param[2], l = param[1];
     if(l){
      var
       tl = l[2],
       hd = l[1],
       _C_ =
         function(param){
          if(0 === param[0]){
           var result = param[1];
           return [0, -289386606, [0, result]];
          }
          var current_error = param[1];
          return [0, 990972795, [0, tl, [0, current_error, errors]]];
         },
       _D_ = caml_call1(f, hd);
      return caml_call2(Async_kernel_Deferred1[18], _D_, _C_);
     }
     var
      _E_ = caml_call1(Core_List[34], errors),
      errors$0 = caml_call2(Core_Error[24], 0, _E_);
     return caml_call1
             (Async_kernel_Deferred1[21], [0, -289386606, [1, errors$0]]);
    }
    return caml_call2(Async_kernel_Deferred1[37], [0, l, 0], _B_);
   }
   var ok_unit = caml_call1(return$1, 0);
   function try_with$0(extract_exn, run, rest, here, name, f){
    function _z_(ok){
     if(0 === ok[0]) return ok;
     var exn = ok[1];
     return [1, caml_call2(Core_Error[25], 0, exn)];
    }
    var _A_ = caml_call7(try_with, here, 0, name, extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred1[18], _A_, _z_);
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _x_ = Core_Or_error[27],
     _y_ = try_with$0(extract_exn, run, rest, here, name, f);
    return caml_call2(Async_kernel_Deferred1[18], _y_, _x_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     function _w_(acc){return loop(i + 1 | 0, acc, tl);}
     return caml_call2(bind, caml_call3(f, i, acc, hd), _w_);
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _u_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _v_ = caml_call1(Core[259], _u_);
    return caml_call1(all_unit, caml_call2(Core_List[92], t, _v_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var _q_ = Core_List[34];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 function _t_(b){return [0, b, bs];}
                 return caml_call2(map$0, caml_call2(f, i, a), _t_);
                }),
              _q_);
    }
    var
     _r_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _s_ = caml_call1(Core[259], _r_);
    return caml_call1(all, caml_call2(Core_List[92], t, _s_));
   }
   function filter_mapi(how, t, f){
    var _p_ = Core_List[124];
    return caml_call2(symbol_map$0, mapi(how, t, f), _p_);
   }
   function concat_mapi(how, t, f){
    var _o_ = Core_List[133];
    return caml_call2(symbol_map$0, mapi(how, t, f), _o_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              function _n_(b){return b ? [0, x] : 0;}
              return caml_call2(map$0, caml_call2(f, i, x), _n_);
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     function _m_(some){
      return some ? caml_call1(return$1, some) : find_mapi(tl, f, i + 1 | 0);
     }
     return caml_call2(bind, caml_call2(f, i, hd), _m_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _l_(b){return b ? [0, [0, i, elt]] : 0;}
              return caml_call2(map$0, caml_call2(f, i, elt), _l_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _k_(b){return b ? [0, elt] : 0;}
              return caml_call2(map$0, caml_call1(f, elt), _k_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _j_(b){return b ? _b_ : 0;}
                return caml_call2(map$0, caml_call2(f, i, elt), _j_);
               }),
             _i_);
   }
   function for_alli(t, f){
    function _g_(param){return param ? 0 : 1;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _h_(b){return b ? 0 : _c_;}
                return caml_call2(map$0, caml_call2(f, i, elt), _h_);
               }),
             _g_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _e_(_f_){return _f_;}
    return map$1(how, caml_call2(Core_List[119], n, _e_), f);
   }
   function repeat_until_finished(state, f){
    function _d_(param){
     if(990972795 <= param[1]){
      var state = param[2];
      return repeat_until_finished(state, f);
     }
     var state$0 = param[2];
     return caml_call1(return$1, state$0);
    }
    return caml_call2(bind, caml_call1(f, state), _d_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_or_e);
   var
    Async_kernel_Deferred_or_error =
      [0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_map_ok,
       ok_unit,
       try_with$0,
       try_with_join,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Async_kernel_Deferred_or_error, cst_Async_kernel_Deferred_or_e$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_queue
//# unitInfo: Requires: Async_kernel__Deferred_list, Async_kernel__Deferred_std, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_queu$0 = "Async_kernel__Deferred_queue",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_queu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_queue.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_queu = cst_Async_kernel_Deferred_queu$0;
   function foldi(t, init, f){
    var _V_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[1], _V_, init, f);
   }
   function fold(t, init, f){
    var _U_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[2], _U_, init, f);
   }
   function all(t){
    var
     _R_ = Core_Queue[38],
     _S_ = caml_call1(Core_Queue[26], t),
     _T_ = caml_call1(Async_kernel_Deferred_list[11], _S_);
    return caml_call2(Async_kernel_Deferred_std[4], _T_, _R_);
   }
   function all_unit(t){
    var _Q_ = caml_call1(Core_Queue[26], t);
    return caml_call1(Async_kernel_Deferred_list[12], _Q_);
   }
   function iter(how, t, f){
    var _P_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _P_, f);
   }
   function iteri(how, t, f){
    var _O_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[15], how, _O_, f);
   }
   function map(how, t, f){
    var
     _L_ = Core_Queue[38],
     _M_ = caml_call1(Core_Queue[26], t),
     _N_ = caml_call3(Async_kernel_Deferred_list[16], how, _M_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _N_, _L_);
   }
   function mapi(how, t, f){
    var
     _I_ = Core_Queue[38],
     _J_ = caml_call1(Core_Queue[26], t),
     _K_ = caml_call3(Async_kernel_Deferred_list[17], how, _J_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _K_, _I_);
   }
   function init(how, n, f){
    var
     _G_ = Core_Queue[38],
     _H_ = caml_call3(Async_kernel_Deferred_list[13], how, n, f);
    return caml_call2(Async_kernel_Deferred_std[4], _H_, _G_);
   }
   function filter(how, t, f){
    var
     _D_ = Core_Queue[38],
     _E_ = caml_call1(Core_Queue[26], t),
     _F_ = caml_call3(Async_kernel_Deferred_list[18], how, _E_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _F_, _D_);
   }
   function filteri(how, t, f){
    var
     _A_ = Core_Queue[38],
     _B_ = caml_call1(Core_Queue[26], t),
     _C_ = caml_call3(Async_kernel_Deferred_list[19], how, _B_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _C_, _A_);
   }
   function filter_map(how, t, f){
    var
     _x_ = Core_Queue[38],
     _y_ = caml_call1(Core_Queue[26], t),
     _z_ = caml_call3(Async_kernel_Deferred_list[20], how, _y_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _z_, _x_);
   }
   function filter_mapi(how, t, f){
    var
     _u_ = Core_Queue[38],
     _v_ = caml_call1(Core_Queue[26], t),
     _w_ = caml_call3(Async_kernel_Deferred_list[21], how, _v_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _u_);
   }
   function concat_map(how, t, f){
    var _o_ = Core_Queue[38];
    function _p_(x){
     var _s_ = Core_Queue[26], _t_ = caml_call1(f, x);
     return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
    }
    var
     _q_ = caml_call1(Core_Queue[26], t),
     _r_ = caml_call3(Async_kernel_Deferred_list[22], how, _q_, _p_);
    return caml_call2(Async_kernel_Deferred_std[4], _r_, _o_);
   }
   function concat_mapi(how, t, f){
    var _i_ = Core_Queue[38];
    function _j_(i, x){
     var _m_ = Core_Queue[26], _n_ = caml_call2(f, i, x);
     return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
    }
    var
     _k_ = caml_call1(Core_Queue[26], t),
     _l_ = caml_call3(Async_kernel_Deferred_list[23], how, _k_, _j_);
    return caml_call2(Async_kernel_Deferred_std[4], _l_, _i_);
   }
   function find_map(t, f){
    var _h_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[5], _h_, f);
   }
   function find_mapi(t, f){
    var _g_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[6], _g_, f);
   }
   function find(t, f){
    var _f_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[3], _f_, f);
   }
   function findi(t, f){
    var _e_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[4], _e_, f);
   }
   function for_all(t, f){
    var _d_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[9], _d_, f);
   }
   function for_alli(t, f){
    var _c_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[10], _c_, f);
   }
   function exists(t, f){
    var _b_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[7], _b_, f);
   }
   function existsi(t, f){
    var _a_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[8], _a_, f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_queu);
   var
    Async_kernel_Deferred_queue =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_queue, cst_Async_kernel_Deferred_queu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_sequence
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Throttle, Core__List, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_sequ$0 = "Async_kernel__Deferred_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_sequ$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/deferred_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_sequ = cst_Async_kernel_Deferred_sequ$0;
   function fold_mapi(opt, t){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    return function(init, mapi_f, fold_f){
     if(typeof how !== "number"){
      var
       max_concurrent_jobs = how[2],
       throttle = caml_call2(Async_kernel_Throttle[4], 0, max_concurrent_jobs),
       loop$0 =
         function(i, t, c){
          function _Y_(param){
           var match = caml_call1(Core_Sequence[47], t);
           if(! match) return c;
           var match$0 = match[1], t$0 = match$0[2], a = match$0[1];
           function ___(b){
            function _ab_(c){return caml_call2(fold_f, c, b);}
            return caml_call2(Async_kernel_Deferred_std[5][2], c, _ab_);
           }
           function _$_(param){return caml_call2(mapi_f, i, a);}
           var _aa_ = caml_call2(Async_kernel_Throttle[8], throttle, _$_);
           return loop$0
                   (i + 1 | 0,
                    t$0,
                    caml_call2(Async_kernel_Deferred_std[5][1], _aa_, ___));
          }
          var _Z_ = caml_call1(Async_kernel_Throttle[16], throttle);
          return caml_call2(Async_kernel_Deferred_std[5][1], _Z_, _Y_);
         };
      return loop$0(0, t, caml_call1(Async_kernel_Deferred_std[10], init));
     }
     if(-676829465 > how){
      var
       loop =
         function(i, t, c){
          var match = caml_call1(Core_Sequence[47], t);
          if(! match) return caml_call1(Async_kernel_Deferred_std[10], c);
          var match$0 = match[1], t$0 = match$0[2], a = match$0[1];
          function _W_(b){
           return loop(i + 1 | 0, t$0, caml_call2(fold_f, c, b));
          }
          var _X_ = caml_call2(mapi_f, i, a);
          return caml_call2(Async_kernel_Deferred_std[5][1], _X_, _W_);
         };
      return loop(0, t, init);
     }
     var
      c$1 = caml_call1(Async_kernel_Deferred_std[10], init),
      i = 0,
      t$0 = t,
      c = c$1;
     for(;;){
      var match = caml_call1(Core_Sequence[47], t$0);
      if(! match) return c;
      var
       match$0 = match[1],
       t$1 = match$0[2],
       a = match$0[1],
       _T_ =
         function(c){
           return function(b){
            function _V_(c){return caml_call2(fold_f, c, b);}
            return caml_call2(Async_kernel_Deferred_std[5][2], c, _V_);};
          }
          (c),
       _U_ = caml_call2(mapi_f, i, a),
       c$0 = caml_call2(Async_kernel_Deferred_std[5][1], _U_, _T_),
       i$0 = i + 1 | 0,
       i = i$0,
       t$0 = t$1,
       c = c$0;
     }};
   }
   function foldi(t, init, f){
    function _P_(param){
     var b = param[2];
     return caml_call1(Async_kernel_Deferred_std[10], b);
    }
    function _Q_(param, a, k){
     var b = param[2], i = param[1];
     function _R_(b){return caml_call1(k, [0, i + 1 | 0, b]);}
     var _S_ = caml_call3(f, i, b, a);
     return caml_call2(Async_kernel_Deferred_std[5][1], _S_, _R_);
    }
    return caml_call4(Core_Sequence[105], t, [0, 0, init], _Q_, _P_);
   }
   function fold(t, init, f){
    var _M_ = Async_kernel_Deferred_std[10];
    function _N_(b, a, k){
     var _O_ = caml_call2(f, b, a);
     return caml_call2(Async_kernel_Deferred_std[3], _O_, k);
    }
    return caml_call4(Core_Sequence[105], t, init, _N_, _M_);
   }
   function all(t){
    function _I_(res){
     var _L_ = caml_call1(Core_List[34], res);
     return caml_call1(Core_Sequence[109], _L_);
    }
    var
     _J_ =
       fold
        (t,
         0,
         function(accum, d){
          function _K_(a){return [0, a, accum];}
          return caml_call2(Async_kernel_Deferred_std[5][2], d, _K_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _J_, _I_);
   }
   function all_unit(t){return fold(t, 0, function(param, v){return v;});}
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     var match = caml_call1(Core_Sequence[47], t);
     if(! match) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var match$0 = match[1], rest = match$0[2], v = match$0[1];
     function _G_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(rest, f, i + 1 | 0);
     }
     var _H_ = caml_call2(f, i, v);
     return caml_call2(Async_kernel_Deferred_std[5][1], _H_, _G_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _E_(b){return b ? [0, [0, i, elt]] : 0;}
              var _F_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _F_, _E_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _C_(b){return b ? [0, elt] : 0;}
              var _D_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _D_, _C_);
             });
   }
   function existsi(t, f){
    function _y_(param){return param ? 1 : 0;}
    var
     _z_ =
       find_mapi
        (t,
         function(i, elt){
          function _A_(b){return b ? _a_ : 0;}
          var _B_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _B_, _A_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _z_, _y_);
   }
   function for_alli(t, f){
    function _u_(param){return param ? 0 : 1;}
    var
     _v_ =
       find_mapi
        (t,
         function(i, elt){
          function _w_(b){return b ? 0 : _b_;}
          var _x_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _v_, _u_);
   }
   function iteri(how, t, f){
    function _s_(param, _t_){return 0;}
    return fold_mapi(how, t)(0, f, _s_);
   }
   function mapi(how, t, f){
    function _n_(bs){
     var _r_ = caml_call1(Core_List[34], bs);
     return caml_call1(Core_Sequence[109], _r_);
    }
    function _o_(bs, b){return [0, b, bs];}
    function _p_(i, a){return caml_call2(f, i, a);}
    var _q_ = fold_mapi(how, t)(0, _p_, _o_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _q_, _n_);
   }
   function filter_mapi(how, t, f){
    function _i_(bs){
     var _m_ = caml_call1(Core_List[34], bs);
     return caml_call1(Core_Sequence[109], _m_);
    }
    function _j_(bs, maybe_v){
     if(! maybe_v) return bs;
     var b = maybe_v[1];
     return [0, b, bs];
    }
    function _k_(i, a){return caml_call2(f, i, a);}
    var _l_ = fold_mapi(how, t)(0, _k_, _j_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _i_);
   }
   function concat_mapi(how, t, f){
    var _g_ = Core_Sequence[70], _h_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _h_, _g_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, a){
              function _e_(param){return param ? [0, a] : 0;}
              var _f_ = caml_call2(f, i, a);
              return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
             });
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_Sequence[83], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_sequ);
   var
    Async_kernel_Deferred_sequence =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (17, Async_kernel_Deferred_sequence, cst_Async_kernel_Deferred_sequ$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred = "Async_kernel__Deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Deferred1[1],
    invariant = Async_kernel_Deferred1[2],
    create = Async_kernel_Deferred1[4],
    peek = Async_kernel_Deferred1[5],
    value_exn = Async_kernel_Deferred1[6],
    is_determined = Async_kernel_Deferred1[7],
    upon = Async_kernel_Deferred1[8],
    never = Async_kernel_Deferred1[12],
    symbol_bind = Async_kernel_Deferred1[14],
    symbol_map = Async_kernel_Deferred1[15],
    Monad_infix = Async_kernel_Deferred1[16],
    bind = Async_kernel_Deferred1[17],
    map = Async_kernel_Deferred1[18],
    join = Async_kernel_Deferred1[19],
    ignore_m = Async_kernel_Deferred1[20],
    return$0 = Async_kernel_Deferred1[21],
    Let_syntax = Async_kernel_Deferred1[22],
    unit = Async_kernel_Deferred1[23],
    both = Async_kernel_Deferred1[24],
    Infix = Async_kernel_Deferred1[25],
    don_t_wait_for = Async_kernel_Deferred1[26],
    Choice = Async_kernel_Deferred1[27],
    choice = Async_kernel_Deferred1[29],
    enabled = Async_kernel_Deferred1[30],
    choose = Async_kernel_Deferred1[32],
    any = Async_kernel_Deferred1[34],
    any_unit = Async_kernel_Deferred1[35],
    for$0 = Async_kernel_Deferred1[36],
    repeat_until_finished = Async_kernel_Deferred1[37],
    forever = Async_kernel_Deferred1[38],
    all = Async_kernel_Deferred1[42],
    all_unit = Async_kernel_Deferred1[43],
    ok = Async_kernel_Deferred1[44];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred);
   var
    _a_ = Let_syntax[4],
    Async_kernel_Deferred =
      [0,
       sexp_of_t,
       invariant,
       create,
       upon,
       peek,
       value_exn,
       is_determined,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       [0,
        Let_syntax[3],
        Let_syntax[1],
        Let_syntax[2],
        [0, _a_[5], _a_[1], _a_[2], _a_[3], _a_[4]]],
       [0, Infix[1], Infix[2], Infix[3]],
       unit,
       never,
       both,
       all,
       all_unit,
       any,
       any_unit,
       don_t_wait_for,
       Choice,
       choice,
       enabled,
       choose,
       for$0,
       repeat_until_finished,
       forever,
       ok];
   runtime.caml_register_global
    (12, Async_kernel_Deferred, cst_Async_kernel_Deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Clock_ns, Async_kernel__Time_ns, Core__Date, Core__Time_float, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Require_expli =
      "Async_kernel__Require_explicit_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Core_Date = global_data.Core__Date,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core_Time_float = global_data.Core__Time_float,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Require_expli);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1
    (Expect_test_collector[5][1], "src/require_explicit_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    every = Async_kernel_Clock_ns[10],
    with_timeout = Async_kernel_Clock_ns[5];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Require_expli);
   var
    Async_kernel_Require_explicit_ =
      [0,
       Async_kernel_Clock_ns,
       [0,
        Async_kernel_Time_ns[1],
        Async_kernel_Time_ns[2],
        Async_kernel_Time_ns[3],
        Async_kernel_Time_ns[4],
        Async_kernel_Time_ns[5],
        Async_kernel_Time_ns[6],
        Async_kernel_Time_ns[7],
        Async_kernel_Time_ns[8],
        Async_kernel_Time_ns[9],
        Async_kernel_Time_ns[10],
        Async_kernel_Time_ns[11],
        Async_kernel_Time_ns[12],
        Async_kernel_Time_ns[13],
        Async_kernel_Time_ns[14],
        Async_kernel_Time_ns[15],
        Async_kernel_Time_ns[16],
        Async_kernel_Time_ns[17],
        Async_kernel_Time_ns[18],
        Async_kernel_Time_ns[19],
        Async_kernel_Time_ns[20],
        Async_kernel_Time_ns[21],
        Async_kernel_Time_ns[22],
        Async_kernel_Time_ns[23],
        Async_kernel_Time_ns[24],
        Async_kernel_Time_ns[25],
        Async_kernel_Time_ns[26],
        Async_kernel_Time_ns[27],
        Async_kernel_Time_ns[28],
        Async_kernel_Time_ns[29],
        Async_kernel_Time_ns[30],
        Async_kernel_Time_ns[31],
        Async_kernel_Time_ns[32],
        Async_kernel_Time_ns[33],
        Async_kernel_Time_ns[34],
        Async_kernel_Time_ns[35],
        Async_kernel_Time_ns[36],
        Async_kernel_Time_ns[37],
        Async_kernel_Time_ns[38],
        Async_kernel_Time_ns[39],
        Async_kernel_Time_ns[40],
        Async_kernel_Time_ns[41],
        Async_kernel_Time_ns[42],
        Async_kernel_Time_ns[43],
        Async_kernel_Time_ns[44],
        Async_kernel_Time_ns[45],
        Async_kernel_Time_ns[46],
        Async_kernel_Time_ns[47],
        Async_kernel_Time_ns[48],
        Async_kernel_Time_ns[49],
        Async_kernel_Time_ns[51],
        Async_kernel_Time_ns[52],
        Async_kernel_Time_ns[53],
        Async_kernel_Time_ns[54],
        Async_kernel_Time_ns[55],
        Async_kernel_Time_ns[56],
        Async_kernel_Time_ns[57],
        Async_kernel_Time_ns[58],
        Async_kernel_Time_ns[59],
        Async_kernel_Time_ns[60],
        Async_kernel_Time_ns[61],
        Async_kernel_Time_ns[62],
        Async_kernel_Time_ns[63],
        Async_kernel_Time_ns[64],
        Async_kernel_Time_ns[65],
        Async_kernel_Time_ns[66],
        Async_kernel_Time_ns[67],
        Async_kernel_Time_ns[68],
        Async_kernel_Time_ns[69],
        Async_kernel_Time_ns[70],
        Async_kernel_Time_ns[71],
        Async_kernel_Time_ns[72],
        Async_kernel_Time_ns[73],
        Async_kernel_Time_ns[74],
        Async_kernel_Time_ns[75],
        Async_kernel_Time_ns[76],
        Async_kernel_Time_ns[77],
        Async_kernel_Time_ns[78],
        Async_kernel_Time_ns[79],
        Async_kernel_Time_ns[80],
        Async_kernel_Time_ns[81],
        Async_kernel_Time_ns[82],
        Async_kernel_Time_ns[83],
        Async_kernel_Time_ns[84],
        Async_kernel_Time_ns[85],
        Async_kernel_Time_ns[86],
        Async_kernel_Time_ns[87],
        Async_kernel_Time_ns[88],
        Async_kernel_Time_ns[89],
        Async_kernel_Time_ns[90],
        Async_kernel_Time_ns[91],
        Async_kernel_Time_ns[92],
        Async_kernel_Time_ns[93],
        Async_kernel_Time_ns[94],
        Async_kernel_Time_ns[95],
        Async_kernel_Time_ns[96],
        Async_kernel_Time_ns[97],
        Async_kernel_Time_ns[98],
        Async_kernel_Time_ns[99],
        Async_kernel_Time_ns[100],
        Async_kernel_Time_ns[101],
        Async_kernel_Time_ns[102],
        Async_kernel_Time_ns[103],
        Async_kernel_Time_ns[104],
        Async_kernel_Time_ns[105],
        Async_kernel_Time_ns[106],
        Async_kernel_Time_ns[107],
        Async_kernel_Time_ns[108],
        Async_kernel_Time_ns[109],
        Async_kernel_Time_ns[110],
        Async_kernel_Time_ns[111],
        Async_kernel_Time_ns[112],
        Async_kernel_Time_ns[113],
        Async_kernel_Time_ns[50]],
       [0,
        Core_Time_float[1],
        Core_Time_float[2],
        Core_Time_float[3],
        Core_Time_float[4],
        Core_Time_float[5],
        Core_Time_float[6],
        Core_Time_float[7],
        Core_Time_float[8],
        Core_Time_float[9],
        Core_Time_float[10],
        Core_Time_float[11],
        Core_Time_float[12],
        Core_Time_float[14],
        Core_Time_float[15],
        Core_Time_float[16],
        Core_Time_float[17],
        Core_Time_float[18],
        Core_Time_float[19],
        Core_Time_float[20],
        Core_Time_float[21],
        Core_Time_float[22],
        Core_Time_float[23],
        Core_Time_float[24],
        Core_Time_float[25],
        Core_Time_float[26],
        Core_Time_float[27],
        Core_Time_float[28],
        Core_Time_float[29],
        Core_Time_float[30],
        Core_Time_float[31],
        Core_Time_float[32],
        Core_Time_float[33],
        Core_Time_float[34],
        Core_Time_float[35],
        Core_Time_float[36],
        Core_Time_float[37],
        Core_Time_float[38],
        Core_Time_float[39],
        Core_Time_float[40],
        Core_Time_float[41],
        Core_Time_float[42],
        Core_Time_float[43],
        Core_Time_float[45],
        Core_Time_float[46],
        Core_Time_float[48],
        Core_Time_float[49],
        Core_Time_float[50],
        Core_Time_float[51],
        Core_Time_float[52],
        Core_Time_float[53],
        Core_Time_float[54],
        Core_Time_float[55],
        Core_Time_float[56],
        Core_Time_float[57],
        Core_Time_float[58],
        Core_Time_float[59],
        Core_Time_float[60],
        Core_Time_float[61],
        Core_Time_float[62],
        Core_Time_float[63],
        Core_Time_float[64],
        Core_Time_float[65],
        Core_Time_float[66],
        Core_Time_float[67],
        Core_Time_float[68],
        Core_Time_float[69],
        Core_Time_float[70],
        Core_Time_float[71],
        Core_Time_float[72],
        Core_Time_float[73],
        Core_Time_float[74],
        Core_Time_float[75],
        Core_Time_float[76],
        Core_Time_float[77],
        Core_Time_float[78],
        Core_Time_float[79],
        Core_Time_float[80],
        Core_Time_float[81],
        Core_Time_float[82],
        Core_Time_float[93],
        Core_Time_float[94],
        Core_Time_float[95],
        Core_Time_float[96],
        Core_Time_float[97],
        Core_Time_float[98],
        Core_Time_float[99],
        Core_Time_float[100],
        Core_Time_float[101],
        Core_Time_float[102],
        Core_Time_float[103],
        Core_Time_float[104],
        Core_Time_float[105],
        Core_Time_float[106],
        Core_Time_float[107],
        Core_Time_float[108],
        Core_Time_float[109],
        Core_Time_float[110],
        Core_Time_float[111],
        Core_Time_float[112],
        Core_Time_float[113],
        Core_Time_float[114],
        Core_Time_float[115],
        Core_Time_float[47]],
       [0,
        Async_kernel_Async_kernel_sche[1],
        Async_kernel_Async_kernel_sche[2],
        Async_kernel_Async_kernel_sche[3],
        Async_kernel_Async_kernel_sche[4],
        Async_kernel_Async_kernel_sche[5],
        Async_kernel_Async_kernel_sche[6],
        Async_kernel_Async_kernel_sche[7],
        Async_kernel_Async_kernel_sche[8],
        Async_kernel_Async_kernel_sche[9],
        Async_kernel_Async_kernel_sche[10],
        Async_kernel_Async_kernel_sche[11],
        Async_kernel_Async_kernel_sche[12],
        Async_kernel_Async_kernel_sche[13],
        Async_kernel_Async_kernel_sche[16],
        Async_kernel_Async_kernel_sche[17],
        Async_kernel_Async_kernel_sche[18],
        Async_kernel_Async_kernel_sche[19],
        Async_kernel_Async_kernel_sche[20],
        Async_kernel_Async_kernel_sche[21],
        Async_kernel_Async_kernel_sche[22],
        Async_kernel_Async_kernel_sche[23],
        Async_kernel_Async_kernel_sche[24],
        Async_kernel_Async_kernel_sche[25],
        Async_kernel_Async_kernel_sche[26],
        Async_kernel_Async_kernel_sche[27],
        Async_kernel_Async_kernel_sche[28],
        Async_kernel_Async_kernel_sche[29],
        Async_kernel_Async_kernel_sche[30],
        Async_kernel_Async_kernel_sche[31],
        Async_kernel_Async_kernel_sche[32],
        Async_kernel_Async_kernel_sche[14],
        Async_kernel_Async_kernel_sche[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[20],
        Core_Date[21],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[41],
        Core_Date[44],
        Core_Date[45],
        Core_Date[46],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[92],
        Core_Date[94],
        Core_Date[95],
        Core_Date[96],
        Core_Date[93]],
       at,
       after,
       every,
       with_timeout];
   runtime.caml_register_global
    (16, Async_kernel_Require_explicit_, cst_Async_kernel_Require_expli);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Pipe
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_queue, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Base__Field, Core, Core__Bag, Core__Bool, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Queue, Core__Sequence, Core__Sexp, Core__Source_code_position, Expect_test_collector, Pairing_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Pipe$0 = "Async_kernel__Pipe",
    cst_Eof = "Eof",
    cst_Ok = "Ok",
    cst_Reader_closed = "Reader_closed",
    cst$0 = "_",
    cst_async_kernel$0 = "async_kernel",
    cst_blocked_flushes$0 = "blocked_flushes",
    cst_blocked_reads$0 = "blocked_reads",
    cst_consumer$0 = "consumer",
    cst_consumers$0 = "consumers",
    cst_exn = "exn",
    cst_pipe = "pipe",
    cst_pushback$0 = "pushback",
    cst_size_budget$0 = "size_budget",
    cst_src_pipe_ml = "src/pipe.ml",
    cst_values_read$0 = "values_read",
    cst_wants$0 = "wants",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Pairing_heap = global_data.Pairing_heap,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Sequence = global_data.Core__Sequence,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_queue = global_data.Async_kernel__Deferred_queue,
    Core_Sexp = global_data.Core__Sexp,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Core_Bag = global_data.Core__Bag,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Bool = global_data.Core__Bool,
    Base_Field = global_data.Base__Field,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Pipe$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_pipe_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    show_debug_messages = [0, 0],
    check_invariant = [0, 0],
    cst_Pipe_interleave = "Pipe.interleave",
    _a0_ = [0, "Mapped"],
    _aZ_ = [0, cst_src_pipe_ml, 949, 4],
    _aY_ = [0, "max_iterations_per_job"],
    cst_iter_without_pushback_got_ =
      "iter_without_pushback got non-positive max_iterations_per_job",
    _aW_ = [0, 3804260],
    _aX_ = [0, 523273847],
    _aT_ = [0, "When_value_read"],
    _aU_ = [0, "When_value_processed"],
    _aV_ = [0, "Consumer"],
    _aS_ = [0, cst_src_pipe_ml, 674, 6],
    cst_read_exactly = "read_exactly",
    _aR_ = [0, "num_values"],
    cst_Pipe_read_exactly_got_num_ = "Pipe.read_exactly got num_values <= 0",
    _aQ_ = [0, "here"],
    cst_Pipe_read_choice_single_co =
      "Pipe.read_choice_single_consumer_exn: choice was enabled but pipe is empty; this is likely due to a race condition with one or more other consumers",
    cst_values_available = "values_available",
    cst_Pipe_read_exn_received_EOF = "Pipe.read_exn: received EOF",
    cst_read$0 = "read",
    _aP_ = [0, cst_src_pipe_ml, 623, 4],
    cst_read = "read'",
    _aO_ = [0, "max_queue_length"],
    cst_max_queue_length_0 = "max_queue_length <= 0",
    cst_read_now = "read_now",
    _aN_ = [0, cst_src_pipe_ml, 574, 4],
    _aM_ = [0, cst$0],
    _aL_ = [0, cst$0],
    _aI_ = [0, cst$0],
    _aJ_ = [0, cst_pipe],
    _aK_ = [0, cst_consumer$0],
    cst_Attempt_to_use_consumer_wi = "Attempt to use consumer with wrong pipe",
    _aG_ = [0, cst$0],
    _aF_ = [0, cst$0],
    _aE_ = [0, cst$0],
    _aD_ = [0, cst$0],
    cst_write = "write",
    _aH_ = [0, cst_pipe],
    cst_write_to_closed_pipe = "write to closed pipe",
    _aC_ = [0, cst_src_pipe_ml, 465, 2],
    _aB_ = [0, cst_src_pipe_ml, 456, 2],
    _az_ = [0, 3804260],
    _aA_ = [0, 523273847],
    _ax_ = [0, 3804260],
    _ay_ = [0, 523273847],
    _aw_ = [0, cst$0],
    _av_ = [0, cst$0],
    cst_close_read = "close_read",
    _au_ = [0, cst$0],
    _at_ = [0, cst$0],
    cst_close = "close",
    _as_ = [0, cst_size_budget$0],
    cst_negative_size_budget = "negative size_budget",
    _ar_ = [0, cst_src_pipe_ml, 307, 2],
    _aq_ = [0, cst_src_pipe_ml, 300, 2],
    _ae_ = [0, cst$0],
    _ad_ = [0, cst$0],
    _ap_ = [0, cst_src_pipe_ml, 258, 46],
    _ao_ = [0, cst_src_pipe_ml, 261, 11],
    _al_ = [0, cst_src_pipe_ml, 269, 13],
    _an_ = [0, cst_src_pipe_ml, 270, 11],
    _am_ = [0, cst_src_pipe_ml, 276, 30],
    _ai_ = [0, cst_src_pipe_ml, 284, 13],
    _ak_ = [0, cst_src_pipe_ml, 281, 36],
    _aj_ = [0, cst_src_pipe_ml, 286, 31],
    _ah_ = [0, cst_src_pipe_ml, 293, 13],
    _af_ = [0, cst_pipe],
    _ag_ = [0, cst_exn],
    cst_Pipe_invariant_failed = "Pipe.invariant failed",
    _T_ = [0, "upstream_flusheds"],
    _U_ = [0, cst_consumers$0],
    _V_ = [0, "read_closed"],
    _W_ = [0, "closed"],
    _X_ = [0, cst_blocked_reads$0],
    _Y_ = [0, cst_blocked_flushes$0],
    _Z_ = [0, "num_values_read"],
    ___ = [0, cst_pushback$0],
    _$_ = [0, cst_size_budget$0],
    _aa_ = [0, "buffer"],
    _ab_ = [0, "info"],
    _ac_ = [0, "id"],
    _F_ = [0, cst_Ok],
    _G_ = [0, cst_Reader_closed],
    _H_ = [0, "ready"],
    _I_ = [0, "fill_when_num_values_read"],
    _B_ = [0, cst$0],
    _E_ = [0, cst_src_pipe_ml, 140, 33],
    _C_ = [0, cst_pipe],
    _D_ = [0, cst_exn],
    cst_Pipe_Blocked_read_invarian = "Pipe.Blocked_read.invariant failed",
    _z_ = [0, cst_consumer$0],
    _A_ = [0, cst_wants$0],
    _s_ = [0, cst_Eof],
    _t_ = [0, cst_Ok],
    _p_ = [0, cst_Eof],
    _q_ = [0, cst_Ok],
    _m_ = [0, cst_Eof],
    _n_ = [0, cst_Ok],
    _o_ = [0, "Zero"],
    _r_ = [0, "One"],
    _u_ = [0, "At_most"],
    _l_ = [0, cst_src_pipe_ml, 79, 54],
    _j_ = [0, cst_pipe],
    _k_ = [0, cst_exn],
    cst_Pipe_Consumer_invariant_fa = "Pipe.Consumer.invariant failed",
    _e_ = [0, "downstream_flushed"],
    _f_ = [0, "Have_been_sent_downstream"],
    _i_ = [0, "Have_not_been_sent_downstream"],
    _g_ = [0, cst_values_read$0],
    _h_ = [0, "pipe_id"],
    _a_ = [0, cst_Ok],
    _b_ = [0, cst_Reader_closed],
    cst_values_read = cst_values_read$0,
    cst_consumer = cst_consumer$0,
    cst_wants = cst_wants$0,
    cst_consumers = cst_consumers$0,
    cst_blocked_reads = cst_blocked_reads$0,
    cst_blocked_flushes = cst_blocked_flushes$0,
    cst_pushback = cst_pushback$0,
    cst_size_budget = cst_size_budget$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Pipe = cst_Async_kernel_Pipe$0;
   function compare(a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(17724 <= a_001){
     if(typeof b_002 === "number" && 17724 === b_002) return 0;
    }
    else if(typeof b_002 === "number" && -402004920 === b_002) return 0;
    return runtime.caml_int_compare(a_001, b_002);
   }
   function sexp_of_t(param){return 17724 <= param ? _a_ : _b_;}
   function equal(x_003, x_004){return 0 === compare(x_003, x_004) ? 1 : 0;}
   function combine(l){
    function _eZ_(l){
     return caml_call3(Core_List[6], l, -402004920, equal)
             ? -402004920
             : 17724;
    }
    var _e0_ = caml_call1(Async_kernel_Deferred[21], l);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e0_, _eZ_);
   }
   function values_read(r){return r[2];}
   function set_values_read(r, v){r[2] = v; return 0;}
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = [0, set_values_read],
    values_read$0 =
      [0, function(param){return 0;}, cst_values_read, _d_, values_read, _c_];
   function sexp_of_t$0(param){
    var pipe_id_009 = param[1], values_read_011 = param[2], bnds_008 = 0;
    function _eX_(_eY_){return 0;}
    var
     arg_015 = caml_call1(Sexplib0_Sexp_conv[24], _eX_),
     bnds_008$0 = [0, [1, [0, _e_, [0, arg_015, 0]]], bnds_008];
    if(typeof values_read_011 === "number")
     var arg_012 = _f_;
    else
     var
      v_013 = values_read_011[2],
      arg_012 =
        [1,
         [0, _i_, [0, caml_call2(Async_kernel_Ivar[9], Core[518], v_013), 0]]];
    var
     bnds_008$1 = [0, [1, [0, _g_, [0, arg_012, 0]]], bnds_008$0],
     arg_010 = caml_call1(Core[356], pipe_id_009),
     bnds_008$2 = [0, [1, [0, _h_, [0, arg_010, 0]]], bnds_008$1];
    return [1, bnds_008$2];
   }
   function invariant(t){
    try{
     var param = caml_call2(Base_Field[3], values_read$0, t);
     if(typeof param !== "number"){
      var ivar = param[2];
      if(! caml_call1(Async_kernel_Ivar[16], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
     var _eT_ = 0;
     return _eT_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _eU_ = [0, [1, [0, _j_, [0, sexp_of_t$0(t), 0]]], 0],
      _eV_ = [0, [1, [0, _k_, [0, caml_call1(Core[537], exn), 0]]], _eU_],
      _eW_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_Consumer_invariant_fa),
          _eV_]];
     return caml_call1(Core[253], _eW_);
    }
   }
   function start(t){
    return typeof t[2] === "number"
            ? (t
               [2]
              = [0, -122467239, caml_call1(Async_kernel_Ivar[12], 0)],
              0)
            : 0;
   }
   function values_sent_downstream(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var ivar = match[2];
    caml_call2(Async_kernel_Ivar[14], ivar, 0);
    t[2] = -758792467;
    return 0;
   }
   function values_sent_downstream_and_flu(t){
    var match = t[2];
    if(typeof match === "number") return caml_call1(t[3], 0);
    var when_sent_downstream = match[2];
    function _eR_(param){return caml_call1(t[3], 0);}
    var _eS_ = caml_call1(Async_kernel_Ivar[18], when_sent_downstream);
    return caml_call2(Async_kernel_Deferred_std[5][1], _eS_, _eR_);
   }
   function consumer(r){return r[2];}
   function wants(r){return r[1];}
   function _v_(r, v){return [0, r[1], v];}
   var
    _w_ = 0,
    consumer$0 =
      [0, function(param){return 0;}, cst_consumer, _w_, consumer, _v_];
   function _x_(r, v){return [0, v, r[2]];}
   var
    _y_ = 0,
    wants$0 = [0, function(param){return 0;}, cst_wants, _y_, wants, _x_];
   function sexp_of_t$1(of_a_029, param){
    var
     consumer_033 = param[2],
     wants_031 = param[1],
     arg_034 = caml_call2(Core[454], sexp_of_t$0, consumer_033),
     bnds_030 = [0, [1, [0, _z_, [0, arg_034, 0]]], 0];
    switch(wants_031[0]){
      case 0:
       var
        arg0_018 = wants_031[1],
        _eO_ = function(param){return 3456156 <= param ? _m_ : _n_;},
        res0_019 = caml_call2(Async_kernel_Ivar[9], _eO_, arg0_018),
        arg_032 = [1, [0, _o_, [0, res0_019, 0]]];
       break;
      case 1:
       var
        arg0_021 = wants_031[1],
        _eP_ =
          function(param){
           if(typeof param === "number") return _p_;
           var v_020 = param[2];
           return [1, [0, _q_, [0, caml_call1(of_a_029, v_020), 0]]];
          },
        res0_022 = caml_call2(Async_kernel_Ivar[9], _eP_, arg0_021),
        arg_032 = [1, [0, _r_, [0, res0_022, 0]]];
       break;
      default:
       var
        arg1_025 = wants_031[2],
        arg0_024 = wants_031[1],
        res0_026 = caml_call1(Core[356], arg0_024),
        _eQ_ =
          function(param){
           if(typeof param === "number") return _s_;
           var v_023 = param[2];
           return [1,
                   [0,
                    _t_,
                    [0, caml_call2(Core_Queue[11], of_a_029, v_023), 0]]];
          },
        res1_027 = caml_call2(Async_kernel_Ivar[9], _eQ_, arg1_025),
        arg_032 = [1, [0, _u_, [0, res0_026, [0, res1_027, 0]]]];
    }
    var bnds_030$0 = [0, [1, [0, _A_, [0, arg_032, 0]]], bnds_030];
    return [1, bnds_030$0];
   }
   function fill_with_eof(t){
    var match = t[1];
    switch(match[0]){
      case 0:
       var i = match[1]; return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      case 1:
       var i$0 = match[1];
       return caml_call2(Async_kernel_Ivar[14], i$0, 3456156);
      default:
       var i$1 = match[2];
       return caml_call2(Async_kernel_Ivar[14], i$1, 3456156);
    }
   }
   function fill_when_num_values_read(r){return r[1];}
   function sexp_of_t$2(param){
    var
     ready_039 = param[2],
     fill_when_num_values_read_037 = param[1],
     bnds_036 = 0;
    function _eN_(param){return 17724 <= param ? _F_ : _G_;}
    var
     arg_040 = caml_call2(Async_kernel_Ivar[9], _eN_, ready_039),
     bnds_036$0 = [0, [1, [0, _H_, [0, arg_040, 0]]], bnds_036],
     arg_038 = caml_call1(Core[356], fill_when_num_values_read_037),
     bnds_036$1 = [0, [1, [0, _I_, [0, arg_038, 0]]], bnds_036$0];
    return [1, bnds_036$1];
   }
   function fill(t, v){return caml_call2(Async_kernel_Ivar[14], t[2], v);}
   function consumers(r){return r[11];}
   function set_consumers(r, v){r[11] = v; return 0;}
   function blocked_reads(r){return r[8];}
   function blocked_flushes(r){return r[7];}
   function pushback(r){return r[5];}
   function set_pushback(r, v){r[5] = v; return 0;}
   function size_budget(r){return r[4];}
   function set_size_budget(r, v){r[4] = v; return 0;}
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12]];
   }
   var
    _K_ = [0, set_consumers],
    consumers$0 =
      [0, function(param){return 0;}, cst_consumers, _K_, consumers, _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12]];
   }
   var
    _M_ = 0,
    blocked_reads$0 =
      [0,
       function(param){return 0;},
       cst_blocked_reads,
       _M_,
       blocked_reads,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12]];
   }
   var
    _O_ = 0,
    blocked_flushes$0 =
      [0,
       function(param){return 0;},
       cst_blocked_flushes,
       _O_,
       blocked_flushes,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12]];
   }
   var
    _Q_ = [0, set_pushback],
    pushback$0 =
      [0, function(param){return 0;}, cst_pushback, _Q_, pushback, _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12]];
   }
   var
    _S_ = [0, set_size_budget],
    size_budget$0 =
      [0, function(param){return 0;}, cst_size_budget, _S_, size_budget, _R_];
   function sexp_of_pipe(of_a_041, of_phantom_042, param){
    var
     id_044 = param[1],
     info_046 = param[2],
     buffer_050 = param[3],
     size_budget_052 = param[4],
     pushback_054 = param[5],
     num_values_read_056 = param[6],
     read_closed_064 = param[10],
     closed_062 = param[9],
     blocked_reads_060 = param[8],
     blocked_flushes_058 = param[7],
     consumers_066 = param[11],
     upstream_flusheds_068 = param[12],
     bnds_043 = 0;
    function _eI_(param){
     function _eL_(_eM_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _eL_);
    }
    var
     arg_069 = caml_call2(Core_Bag[3], _eI_, upstream_flusheds_068),
     bnds_043$0 = [0, [1, [0, _T_, [0, arg_069, 0]]], bnds_043],
     arg_067 = caml_call2(Core[421], sexp_of_t$0, consumers_066),
     bnds_043$1 = [0, [1, [0, _U_, [0, arg_067, 0]]], bnds_043$0],
     arg_065 = caml_call2(Async_kernel_Ivar[9], Core[518], read_closed_064),
     bnds_043$2 = [0, [1, [0, _V_, [0, arg_065, 0]]], bnds_043$1],
     arg_063 = caml_call2(Async_kernel_Ivar[9], Core[518], closed_062),
     bnds_043$3 = [0, [1, [0, _W_, [0, arg_063, 0]]], bnds_043$2];
    function _eJ_(_eK_){return sexp_of_t$1(of_a_041, _eK_);}
    var
     arg_061 = caml_call2(Core_Queue[11], _eJ_, blocked_reads_060),
     bnds_043$4 = [0, [1, [0, _X_, [0, arg_061, 0]]], bnds_043$3],
     arg_059 = caml_call2(Core_Queue[11], sexp_of_t$2, blocked_flushes_058),
     bnds_043$5 = [0, [1, [0, _Y_, [0, arg_059, 0]]], bnds_043$4],
     arg_057 = caml_call1(Core[356], num_values_read_056),
     bnds_043$6 = [0, [1, [0, _Z_, [0, arg_057, 0]]], bnds_043$5],
     arg_055 = caml_call2(Async_kernel_Ivar[9], Core[518], pushback_054),
     bnds_043$7 = [0, [1, [0, ___, [0, arg_055, 0]]], bnds_043$6],
     arg_053 = caml_call1(Core[356], size_budget_052),
     bnds_043$8 = [0, [1, [0, _$_, [0, arg_053, 0]]], bnds_043$7],
     arg_051 = caml_call2(Core_Queue[11], of_a_041, buffer_050),
     bnds_043$9 = [0, [1, [0, _aa_, [0, arg_051, 0]]], bnds_043$8];
    if(info_046)
     var
      v_047 = info_046[1],
      arg_049 = caml_call1(Core_Sexp[90], v_047),
      bnd_048 = [1, [0, _ab_, [0, arg_049, 0]]],
      bnds_043$10 = [0, bnd_048, bnds_043$9];
    else
     var bnds_043$10 = bnds_043$9;
    var
     arg_045 = caml_call2(Sexp_hidden_in_test[10], Core[356], id_044),
     bnds_043$11 = [0, [1, [0, _ac_, [0, arg_045, 0]]], bnds_043$10];
    return [1, bnds_043$11];
   }
   function hash(t){return caml_call1(Core_Hashtbl[1], t[1]);}
   function equal$0(t1, t2){return caml_call2(Core[246], t1, t2);}
   function compare$0(t1, t2){return caml_call2(Core_Int[91], t1[1], t2[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[9]);}
   function is_read_closed(t){
    return caml_call1(Async_kernel_Ivar[17], t[10]);
   }
   function closed(t){return caml_call1(Async_kernel_Ivar[18], t[9]);}
   function pushback$1(t){return caml_call1(Async_kernel_Ivar[18], t[5]);}
   function length(t){return caml_call1(Core_Queue[14], t[3]);}
   function is_empty(t){
    var _eH_ = length(t);
    return caml_call2(Async_kernel_Import[3], _eH_, 0);
   }
   function invariant$0(x_073){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_073));
        },
      _ej_ =
        function(l){
         function _eG_(consumer){
          invariant(consumer);
          if(caml_call2(Async_kernel_Import[3], consumer[1], x_073[1]))
           return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ah_], 1);
         }
         return caml_call2(Core_List[9], l, _eG_);
        },
      _ek_ =
        function(blocked_reads){
         if
          (1 - is_empty(x_073) && ! caml_call1(Core_Queue[15], blocked_reads))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
         function _ex_(x_035){
          try{
           var
            check =
              function(f, field){
               return caml_call1(f, caml_call2(Base_Field[3], field, x_035));
              },
            _eE_ =
              function(param){
               if(! param) return 0;
               var consumer = param[1];
               return invariant(consumer);
              };
           check
            (function(param){
              if(2 !== param[0]) return 0;
              var i = param[1];
              if(caml_call2(Async_kernel_Import[4], i, 0)) return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
             },
             wants$0);
           check(_eE_, consumer$0);
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _ez_ = 0,
            _eA_ = 0,
            _eB_ =
              [0,
               [1,
                [0,
                 _C_,
                 [0, sexp_of_t$1(function(param){return _B_;}, x_035), _eA_]]],
               _ez_],
            _eC_ =
              [0, [1, [0, _D_, [0, caml_call1(Core[537], exn), 0]]], _eB_],
            _eD_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Pipe_Blocked_read_invarian),
                _eC_]];
           caml_call1(Core[253], _eD_);
          }
          var match = x_035[1];
          switch(match[0]){
            case 0:
             var i = match[1], _eF_ = caml_call1(Async_kernel_Ivar[16], i);
             break;
            case 1:
             var
              i$0 = match[1],
              _eF_ = caml_call1(Async_kernel_Ivar[16], i$0);
             break;
            default:
             var
              i$1 = match[2],
              _eF_ = caml_call1(Async_kernel_Ivar[16], i$1);
          }
          if(_eF_) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ai_], 1);
         }
         caml_call2(Core_Queue[16], blocked_reads, _ex_);
         var _ey_ = is_closed(x_073);
         if(! _ey_) return _ey_;
         if(caml_call1(Core_Queue[15], blocked_reads)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aj_], 1);
        },
      _el_ =
        function(blocked_flushes){
         function _es_(f){
          if(caml_call2(Async_kernel_Import[4], f[1], x_073[6])) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
         }
         caml_call2(Core_Queue[16], blocked_flushes, _es_);
         var
          _et_ = Core_Int[91],
          _eu_ = caml_call1(Core_Queue[26], blocked_flushes),
          _ev_ = caml_call2(Core_List[72], _eu_, fill_when_num_values_read);
         if(! caml_call2(Core_List[140], _ev_, _et_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
         var _ew_ = is_empty(x_073);
         if(! _ew_) return _ew_;
         if(caml_call1(Core_Queue[15], blocked_flushes)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
        },
      _em_ =
        function(pushback){
         var
          _en_ = x_073[4],
          _eo_ = length(x_073),
          _ep_ = caml_call2(Async_kernel_Import[2], _eo_, _en_),
          _eq_ = _ep_ || is_closed(x_073),
          _er_ = caml_call1(Async_kernel_Ivar[17], pushback);
         if(caml_call2(Core_Bool[27], _er_, _eq_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
        };
     check
      (function(size_budget){
        if(caml_call2(Async_kernel_Import[1], size_budget, 0)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
       },
       size_budget$0);
     check(_em_, pushback$0);
     check(_el_, blocked_flushes$0);
     check(_ek_, blocked_reads$0);
     check(_ej_, consumers$0);
     var _ec_ = 0;
     return _ec_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ed_ = 0,
      _ee_ = 0,
      _ef_ = function(param){return _ad_;},
      _eg_ =
        [0,
         [1,
          [0,
           _af_,
           [0, sexp_of_pipe(function(param){return _ae_;}, _ef_, x_073), _ee_]]],
         _ed_],
      _eh_ = [0, [1, [0, _ag_, [0, caml_call1(Core[537], exn), 0]]], _eg_],
      _ei_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_invariant_failed),
          _eh_]];
     return caml_call1(Core[253], _ei_);
    }
   }
   function sexp_of_phantom(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aq_], 1);
   }
   function sexp_of_t$3(of_a_074, x_075){
    return sexp_of_pipe(of_a_074, sexp_of_phantom, x_075);
   }
   function sexp_of_phantom$0(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ar_], 1);
   }
   function sexp_of_t$4(of_a_076, x_077){
    return sexp_of_pipe(of_a_076, sexp_of_phantom$0, x_077);
   }
   var id_ref = [0, 0];
   function create_internal(size_budget, info, initial_buffer){
    id_ref[1]++;
    var
     _d8_ = caml_call1(Core_Bag[22], 0),
     _d9_ = caml_call1(Async_kernel_Ivar[12], 0),
     _d__ = caml_call1(Async_kernel_Ivar[12], 0),
     _d$_ = caml_call2(Core_Queue[61], 0, 0),
     _ea_ = caml_call2(Core_Queue[61], 0, 0),
     _eb_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        id_ref[1],
        info,
        initial_buffer,
        size_budget,
        _eb_,
        0,
        _ea_,
        _d$_,
        _d__,
        _d9_,
        0,
        _d8_];
    return t;
   }
   function validate_size_budget(size_budget){
    if(! caml_call2(Async_kernel_Import[5], size_budget, 0))
     return size_budget;
    var
     _d6_ = [0, [1, [0, _as_, [0, caml_call1(Core[356], size_budget), 0]]], 0],
     _d7_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_negative_size_budget), _d6_]];
    return caml_call1(Core[253], _d7_);
   }
   function create(size_budget, info, param){
    if(size_budget)
     var v = size_budget[1], size_budget$0 = validate_size_budget(v);
    else
     var size_budget$0 = 0;
    var
     t =
       create_internal(size_budget$0, info, caml_call2(Core_Queue[61], 0, 0));
    caml_call2(Async_kernel_Ivar[14], t[5], 0);
    if(check_invariant[1]) invariant$0(t);
    return [0, t, t];
   }
   function update_pushback(t){
    var _d2_ = t[4], _d3_ = length(t);
    if(! caml_call2(Async_kernel_Import[2], _d3_, _d2_) && ! is_closed(t)){
     var
      _d4_ = caml_call1(Async_kernel_Ivar[17], t[5]),
      _d5_ = _d4_ ? (t[5] = caml_call1(Async_kernel_Ivar[12], 0), 0) : _d4_;
     return _d5_;
    }
    return caml_call2(Async_kernel_Ivar[15], t[5], 0);
   }
   function close(t){
    if(show_debug_messages[1]){
     var
      _dZ_ =
        function(x_078){
         function _d1_(param){return _at_;}
         return sexp_of_pipe(function(param){return _au_;}, _d1_, x_078);
        };
     caml_call3(Async_kernel_Import[14], cst_close, t, _dZ_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _d0_ = 1 - is_closed(t);
    if(! _d0_) return _d0_;
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    if(is_empty(t)){
     caml_call2(Core_Queue[16], t[8], fill_with_eof);
     caml_call1(Core_Queue[47], t[8]);
    }
    return update_pushback(t);
   }
   function close_read(t){
    if(show_debug_messages[1]){
     var
      _dV_ =
        function(x_079){
         function _dY_(param){return _av_;}
         return sexp_of_pipe(function(param){return _aw_;}, _dY_, x_079);
        };
     caml_call3(Async_kernel_Import[14], cst_close_read, t, _dV_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _dW_ = 1 - is_read_closed(t);
    if(! _dW_) return _dW_;
    caml_call2(Async_kernel_Ivar[14], t[10], 0);
    function _dX_(flush){return fill(flush, -402004920);}
    caml_call2(Core_Queue[16], t[7], _dX_);
    caml_call1(Core_Queue[47], t[7]);
    caml_call1(Core_Queue[47], t[3]);
    update_pushback(t);
    return close(t);
   }
   function create_reader_not_close_on_exc(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dT_(param){return close(w);}
    var _dU_ = caml_call1(f, w);
    caml_call2(Async_kernel_Deferred_std[11], _dU_, _dT_);
    return r;
   }
   function create_reader(size_budget, close_on_exception, f){
    if(! close_on_exception)
     return create_reader_not_close_on_exc(size_budget, f);
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dQ_(param){
     close(w);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dR_(param){return caml_call1(f, w);}
    var
     _dS_ =
       caml_call8
        (Async_kernel_Monitor[23], 0, 0, 0, 0, _ay_, _ax_, _dR_, _dQ_);
    caml_call1(Async_kernel_Deferred_std[8], _dS_);
    return r;
   }
   function create_writer(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dN_(param){
     close_read(r);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dO_(param){return caml_call1(f, r);}
    var
     _dP_ =
       caml_call8
        (Async_kernel_Monitor[23], 0, 0, 0, 0, _aA_, _az_, _dO_, _dN_);
    caml_call1(Async_kernel_Deferred_std[8], _dP_);
    return w;
   }
   function values_were_read(t, consumer){
    caml_call2(Core_Option[41], consumer, start);
    for(;;){
     var match = caml_call1(Core_Queue[45], t[7]);
     if(! match) return;
     var
      flush = match[1],
      _dK_ = caml_call2(Async_kernel_Import[1], t[6], flush[1]);
     if(! _dK_) return _dK_;
     caml_call1(Core_Queue[44], t[7]);
     if(consumer){
      var
       consumer$0 = consumer[1],
       _dL_ =
         function(flush){
           return function(flush_result){return fill(flush, flush_result);};
          }
          (flush),
       _dM_ = values_sent_downstream_and_flu(consumer$0);
      caml_call2(Async_kernel_Deferred_std[11], _dM_, _dL_);
     }
     else
      fill(flush, 17724);
    }
   }
   function consume_one(t, consumer){
    var _dJ_ = length(t);
    if(! caml_call2(Async_kernel_Import[1], _dJ_, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aB_], 1);
    var result = caml_call1(Core_Queue[44], t[3]);
    t[6] = t[6] + 1 | 0;
    values_were_read(t, consumer);
    update_pushback(t);
    return result;
   }
   function consume(t, max_queue_length, consumer){
    if(! caml_call2(Async_kernel_Import[1], max_queue_length, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
    var _dI_ = length(t);
    if(caml_call2(Async_kernel_Import[1], max_queue_length, _dI_)){
     var result = t[3];
     t[3] = caml_call2(Core_Queue[61], 0, 0);
     var _dH_ = caml_call1(Core_Queue[14], result);
     t[6] = t[6] + _dH_ | 0;
     values_were_read(t, consumer);
     update_pushback(t);
     return result;
    }
    t[6] = t[6] + max_queue_length | 0;
    values_were_read(t, consumer);
    var result$0 = caml_call2(Core_Queue[61], [0, max_queue_length], 0);
    caml_call4(Core_Queue[64], t[3], result$0, [0, max_queue_length], 0);
    update_pushback(t);
    return result$0;
   }
   function set_size_budget$0(t, size_budget){
    var size_budget$0 = validate_size_budget(size_budget);
    t[4] = size_budget$0;
    return update_pushback(t);
   }
   function start_write(x_081){
    if(show_debug_messages[1]){
     var
      _dz_ =
        function(x_080){
         function _dG_(param){return _aD_;}
         return sexp_of_pipe(function(param){return _aE_;}, _dG_, x_080);
        };
     caml_call3(Async_kernel_Import[14], cst_write, x_081, _dz_);
    }
    if(check_invariant[1]) invariant$0(x_081);
    var _dA_ = is_closed(x_081);
    if(! _dA_) return _dA_;
    var _dB_ = 0, _dC_ = 0;
    function _dD_(param){return _aF_;}
    var
     _dE_ =
       [0,
        [1,
         [0,
          _aH_,
          [0, sexp_of_pipe(function(param){return _aG_;}, _dD_, x_081), _dC_]]],
        _dB_],
     _dF_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_write_to_closed_pipe), _dE_]];
    return caml_call1(Core[253], _dF_);
   }
   function finish_write(t){
    for(;;){
     if(! caml_call1(Core_Queue[15], t[8]) && ! is_empty(t)){
      var
       blocked_read = caml_call1(Core_Queue[44], t[8]),
       consumer = blocked_read[2],
       match = blocked_read[1];
      switch(match[0]){
        case 0:
         var ivar = match[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 17724);
         break;
        case 1:
         var ivar$0 = match[1], _dx_ = [0, 17724, consume_one(t, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$0, _dx_);
         break;
        default:
         var
          ivar$1 = match[2],
          max_queue_length = match[1],
          _dy_ = [0, 17724, consume(t, max_queue_length, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$1, _dy_);
      }
      continue;
     }
     return update_pushback(t);
    }
   }
   function transfer_in_without_pushback(t, from){
    start_write(t);
    caml_call4(Core_Queue[64], from, t[3], 0, 0);
    return finish_write(t);
   }
   function transfer_in(t, from){
    transfer_in_without_pushback(t, from);
    return pushback$1(t);
   }
   function write(t, q){return transfer_in(t, q);}
   function write_without_pushback(t, value){
    start_write(t);
    caml_call2(Core_Queue[41], t[3], value);
    return finish_write(t);
   }
   function write$0(t, value){
    write_without_pushback(t, value);
    return pushback$1(t);
   }
   function write_when_ready(t, f){
    function _dv_(param){
     return is_closed(t)
             ? -1025106484
             : [0,
               17724,
               caml_call1
                (f, function(x){return write_without_pushback(t, x);})];
    }
    var _dw_ = pushback$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _dw_, _dv_);
   }
   function write_if_open(t, x){
    return is_closed(t)
            ? caml_call1(Async_kernel_Deferred_std[10], 0)
            : write$0(t, x);
   }
   function write_without_pushback_if_open(t, x){
    var _du_ = 1 - is_closed(t);
    return _du_ ? write_without_pushback(t, x) : _du_;
   }
   function ensure_consumer_matches(consumer, x_083){
    if(! consumer) return;
    var
     consumer$0 = consumer[1],
     _do_ = caml_call2(Async_kernel_Import[6], x_083[1], consumer$0[1]);
    if(! _do_) return _do_;
    var
     _dp_ = 0,
     _dq_ = 0,
     _dr_ =
       [0,
        [1,
         [0,
          _aJ_,
          [0, sexp_of_t$3(function(param){return _aI_;}, x_083), _dq_]]],
        _dp_],
     _ds_ = [0, [1, [0, _aK_, [0, sexp_of_t$0(consumer$0), 0]]], _dr_],
     _dt_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_use_consumer_wi),
         _ds_]];
    return caml_call1(Core[253], _dt_);
   }
   function start_read(consumer, t, label){
    if(show_debug_messages[1]){
     var
      _dm_ =
        function(x_084){
         function _dn_(param){return _aL_;}
         return sexp_of_pipe(function(param){return _aM_;}, _dn_, x_084);
        };
     caml_call3(Async_kernel_Import[14], label, t, _dm_);
    }
    if(check_invariant[1]) invariant$0(t);
    return ensure_consumer_matches(consumer, t);
   }
   function gen_read_now(consumer, t, consume){
    start_read(consumer, t, cst_read_now);
    if(is_empty(t)) return is_closed(t) ? 3456156 : -445537353;
    if(caml_call1(Core_Queue[15], t[8]))
     return [0, 17724, caml_call2(consume, t, consumer)];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
   }
   function get_max_queue_length(max_queue_length){
    if(! max_queue_length) return Core_Int[41];
    var max_queue_length$0 = max_queue_length[1];
    if(caml_call2(Async_kernel_Import[2], max_queue_length$0, 0)){
     var
      _dk_ =
        [0,
         [1, [0, _aO_, [0, caml_call1(Core[356], max_queue_length$0), 0]]],
         0],
      _dl_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_max_queue_length_0), _dk_]];
     caml_call1(Core[253], _dl_);
    }
    return max_queue_length$0;
   }
   function read_now(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    return gen_read_now
            (consumer,
             t,
             function(t, consumer){
              return consume(t, max_queue_length$0, consumer);
             });
   }
   function read_now$0(consumer, t){
    return gen_read_now(consumer, t, consume_one);
   }
   function peek(t){return caml_call1(Core_Queue[45], t[3]);}
   function clear(t){read_now(0, 0, t); return 0;}
   function read(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    start_read(consumer, t, cst_read);
    var r = read_now(consumer, [0, max_queue_length$0], t);
    if(typeof r === "number" && 3456156 > r){
     var
      _dj_ =
        function(ivar){
         return caml_call2
                 (Core_Queue[41],
                  t[8],
                  [0, [2, max_queue_length$0, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dj_);
    }
    return caml_call1(Async_kernel_Deferred_std[10], r);
   }
   function read$0(consumer, t){
    start_read(consumer, t, cst_read$0);
    if(is_empty(t)){
     if(is_closed(t))
      return caml_call1(Async_kernel_Deferred_std[10], 3456156);
     var
      _dh_ =
        function(ivar){
         return caml_call2(Core_Queue[41], t[8], [0, [1, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dh_);
    }
    if(! caml_call1(Core_Queue[15], t[8]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aP_], 1);
    var _di_ = [0, 17724, consume_one(t, consumer)];
    return caml_call1(Async_kernel_Deferred_std[10], _di_);
   }
   function read_exn(consumer, t){
    function _de_(param){
     if(typeof param === "number"){
      var
       _dg_ =
         caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exn_received_EOF);
      return caml_call1(Core[253], _dg_);
     }
     var value = param[2];
     return value;
    }
    var _df_ = read$0(consumer, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _df_, _de_);
   }
   function values_available(t){
    start_read(0, t, cst_values_available);
    if(! is_empty(t)) return caml_call1(Async_kernel_Deferred_std[10], 17724);
    if(is_closed(t))
     return caml_call1(Async_kernel_Deferred_std[10], 3456156);
    var match = caml_call1(Core_Queue[62], t[8]);
    if(match){
     var _db_ = match[1], _dc_ = _db_[1];
     if(0 === _dc_[0] && ! _db_[2]){
      var ivar = _dc_[1];
      return caml_call1(Async_kernel_Ivar[18], ivar);
     }
    }
    function _dd_(ivar){
     return caml_call2(Core_Queue[41], t[8], [0, [0, ivar], 0]);
    }
    return caml_call1(Async_kernel_Deferred[3], _dd_);
   }
   function read_choice(t){
    function _c$_(param){return read_now$0(0, t);}
    var _da_ = values_available(t);
    return caml_call2(Async_kernel_Deferred_std[6], _da_, _c$_);
   }
   function read_choice_single_consumer_ex(t, here){
    function _c7_(x){
     if(typeof x === "number" && 3456156 > x){
      var
       _c9_ =
         [0,
          [1,
           [0, _aQ_, [0, caml_call1(Core_Source_code_position[1], here), 0]]],
          0],
       _c__ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_choice_single_co),
           _c9_]];
      return caml_call1(Core[253], _c__);
     }
     return x;
    }
    var _c8_ = read_choice(t);
    return caml_call2(Async_kernel_Deferred[26][1], _c8_, _c7_);
   }
   function read_exactly(consumer, t, num_values){
    start_read(consumer, t, cst_read_exactly);
    if(caml_call2(Async_kernel_Import[2], num_values, 0)){
     var
      _c1_ = [0, [1, [0, _aR_, [0, caml_call1(Core[356], num_values), 0]]], 0],
      _c2_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exactly_got_num_),
          _c1_]];
     caml_call1(Core[253], _c2_);
    }
    function _c3_(finish){
     var result = caml_call2(Core_Queue[61], 0, 0);
     function loop(param){
      var already_read = caml_call1(Core_Queue[14], result);
      if(! caml_call2(Async_kernel_Import[2], already_read, num_values))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
      if(caml_call2(Async_kernel_Import[3], already_read, num_values))
       return caml_call2
               (Async_kernel_Ivar[14], finish, [0, -876407060, result]);
      function _c4_(param){
       if(typeof param === "number"){
        var
         _c6_ =
           caml_call2(Async_kernel_Import[3], already_read, 0)
            ? 3456156
            : [0, 287952037, result];
        return caml_call2(Async_kernel_Ivar[14], finish, _c6_);
       }
       var q = param[2];
       caml_call4(Core_Queue[64], q, result, 0, 0);
       return loop(0);
      }
      var _c5_ = read(consumer, [0, num_values - already_read | 0], t);
      return caml_call2(Async_kernel_Deferred_std[1], _c5_, _c4_);
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _c3_);
   }
   function downstream_flushed(t){
    if(is_empty(t))
     return caml_call1(Core_List[8], t[11])
             ? caml_call1(Async_kernel_Deferred_std[10], 17724)
             : combine
               (caml_call2
                 (Core_List[72], t[11], values_sent_downstream_and_flu));
    function _cZ_(ready){
     var _c0_ = length(t);
     return caml_call2(Core_Queue[41], t[7], [0, t[6] + _c0_ | 0, ready]);
    }
    return caml_call1(Async_kernel_Deferred[3], _cZ_);
   }
   function upstream_flushed(t){
    if(caml_call1(Core_Bag[6], t[12])) return downstream_flushed(t);
    function _cX_(f){return caml_call1(f, 0);}
    var _cY_ = caml_call1(Core_Bag[17], t[12]);
    return combine(caml_call2(Core_List[72], _cY_, _cX_));
   }
   function add_consumer(t, downstream_flushed){
    var
     pipe_id = t[1],
     consumer = [0, pipe_id, -758792467, downstream_flushed];
    t[11] = [0, consumer, t[11]];
    return consumer;
   }
   function consumer$1(param){var t = param[1]; return t[2];}
   function create$0(upstream, downstream){
    function upstream_flushed$0(param){return upstream_flushed(upstream);}
    var _cW_ = caml_call2(Core_Bag[23], downstream[12], upstream_flushed$0);
    return [0,
            [0,
             downstream,
             add_consumer
              (upstream,
               function(param){return downstream_flushed(downstream);}),
             _cW_]];
   }
   function sexp_of_t$5(param){
    if(typeof param === "number") return param ? _aT_ : _aU_;
    var arg0_085 = param[1], res0_086 = sexp_of_t$0(arg0_085);
    return [1, [0, _aV_, [0, res0_086, 0]]];
   }
   var Flushed = [0, sexp_of_t$5];
   function fold_gen(read_now, opt, t, init, f){
    if(opt) var sth = opt[1], flushed = sth; else var flushed = 1;
    if(typeof flushed === "number")
     var
      consumer =
        flushed
         ? 0
         : [0,
           add_consumer
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 17724);
             })];
    else
     var consumer$0 = flushed[1], consumer = [0, consumer$0];
    if(check_invariant[1]) invariant$0(t);
    ensure_consumer_matches(consumer, t);
    function _cR_(finished){
     function _cS_(param){
      function loop(b){
       var match = caml_call2(read_now, consumer, t);
       if(typeof match !== "number"){
        var v = match[2];
        return caml_call3(f, b, v, continue$0);
       }
       if(3456156 <= match)
        return caml_call2(Async_kernel_Ivar[14], finished, b);
       function _cU_(param){return loop(b);}
       var _cV_ = values_available(t);
       return caml_call2(Async_kernel_Deferred_std[1], _cV_, _cU_);
      }
      function continue$0(b){
       caml_call2(Core_Option[41], consumer, values_sent_downstream);
       return loop(b);
      }
      return loop(init);
     }
     var _cT_ = caml_call1(Async_kernel_Deferred_std[10], 0);
     return caml_call2(Async_kernel_Deferred_std[1], _cT_, _cS_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cR_);
   }
   function fold(flushed, max_queue_length, t, init, f){
    function _cN_(b, q, loop){
     var _cQ_ = caml_call2(f, b, q);
     return caml_call2(Async_kernel_Deferred_std[1], _cQ_, loop);
    }
    return fold_gen
            (function(_cO_){
              return function(_cP_){
               return read_now(_cO_, max_queue_length, _cP_);};
             },
             flushed,
             t,
             init,
             _cN_);
   }
   function fold$0(flushed, t, init, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             init,
             function(b, a, loop){
              var _cM_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cM_, loop);
             });
   }
   function fold_without_pushback(consumer, t, init, f){
    function _cK_(b, a, loop){return caml_call1(loop, caml_call2(f, b, a));}
    if(consumer) var c = consumer[1], _cL_ = [0, [0, c]]; else var _cL_ = 0;
    return fold_gen(read_now$0, _cL_, t, init, _cK_);
   }
   function with_error_to_current_monitor(opt, f, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    if(! continue_on_error) return caml_call1(f, a);
    function _cF_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _cI_ = caml_call1(Async_kernel_Monitor[13], exn),
      _cJ_ = caml_call1(Async_kernel_Monitor[5], 0);
     return caml_call3(Async_kernel_Monitor[15], _cJ_, 0, _cI_);
    }
    function _cG_(param){return caml_call1(f, a);}
    var
     _cH_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _aX_, _aW_, _cG_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _cH_, _cF_);
   }
   function iter(continue_on_error, flushed, max_queue_length, t, f){
    return fold
            (flushed,
             max_queue_length,
             t,
             0,
             function(param, q){
              return with_error_to_current_monitor(continue_on_error, f, q);
             });
   }
   function iter$0(continue_on_error, flushed, t, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             0,
             function(param, a, loop){
              function _cD_(param){return caml_call1(loop, 0);}
              var
               _cE_ = with_error_to_current_monitor(continue_on_error, f, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cE_, _cD_);
             });
   }
   function iter_without_pushback(consumer, opt, max_iterations_per_job, t, f){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    ensure_consumer_matches(consumer, t);
    if(max_iterations_per_job){
     var max_iterations_per_job$0 = max_iterations_per_job[1];
     if(caml_call2(Async_kernel_Import[2], max_iterations_per_job$0, 0)){
      var
       _ct_ =
         [0,
          [1,
           [0, _aY_, [0, caml_call1(Core[356], max_iterations_per_job$0), 0]]],
          0],
       _cu_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_iter_without_pushback_got_),
           _ct_]];
      caml_call1(Core[253], _cu_);
     }
     var max_iterations_per_job$1 = max_iterations_per_job$0;
    }
    else
     var max_iterations_per_job$1 = Core_Int[41];
    var
     f$0 =
       continue_on_error
        ? function
         (a){
          try{caml_call1(f, a); return;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _cC_ = caml_call1(Async_kernel_Monitor[5], 0);
           return caml_call3(Async_kernel_Monitor[15], _cC_, 0, exn);
          }
         }
        : f;
    function _cv_(finished){
     function _cw_(param){
      function start(param){
       var remaining = max_iterations_per_job$1;
       for(;;){
        if(caml_call2(Async_kernel_Import[3], remaining, 0)){
         var
          _cy_ = function(param){return start(0);},
          _cz_ = caml_call1(Async_kernel_Deferred_std[10], 0);
         return caml_call2(Async_kernel_Deferred_std[1], _cz_, _cy_);
        }
        var match = read_now$0(consumer, t);
        if(typeof match === "number"){
         if(3456156 <= match)
          return caml_call2(Async_kernel_Ivar[14], finished, 0);
         var
          _cA_ = function(param){return start(0);},
          _cB_ = values_available(t);
         return caml_call2(Async_kernel_Deferred_std[1], _cB_, _cA_);
        }
        var a = match[2];
        caml_call1(f$0, a);
        var remaining$0 = remaining - 1 | 0, remaining = remaining$0;
       }
      }
      return start(0);
     }
     var _cx_ = caml_call1(Async_kernel_Deferred_std[10], 0);
     return caml_call2(Async_kernel_Deferred_std[1], _cx_, _cw_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cv_);
   }
   function drain(t){
    return iter
            (0,
             0,
             0,
             t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function drain_and_count(t){
    return fold
            (0,
             0,
             t,
             0,
             function(sum, q){
              var _cs_ = sum + caml_call1(Core_Queue[14], q) | 0;
              return caml_call1(Async_kernel_Deferred_std[10], _cs_);
             });
   }
   function read_all(input){
    var result = caml_call2(Core_Queue[61], 0, 0);
    function _cq_(param){return result;}
    var
     _cr_ =
       iter
        (0,
         0,
         0,
         input,
         function(q){
          caml_call4(Core_Queue[64], q, result, 0, 0);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _cr_, _cq_);
   }
   function to_list(r){
    var _co_ = Core_Queue[26], _cp_ = read_all(r);
    return caml_call2(Async_kernel_Deferred_std[4], _cp_, _co_);
   }
   function to_stream_deprecated(t){
    function _cl_(tail){
     function _cm_(param){return caml_call1(Async_kernel_Tail[4], tail);}
     var
      _cn_ =
        iter_without_pushback
         (0,
          0,
          0,
          t,
          function(x){return caml_call2(Async_kernel_Tail[3], tail, x);});
     return caml_call2(Async_kernel_Deferred_std[1], _cn_, _cm_);
    }
    return caml_call1(Async_kernel_Async_stream[2], _cl_);
   }
   function of_stream_deprecated(s){
    var
     match = create(0, 0, 0),
     w = match[2],
     r = match[1],
     q = caml_call2(Core_Queue[61], 0, 0);
    function transfer(param){
     var _cj_ = 1 - caml_call1(Core_Queue[15], q);
     if(! _cj_) return _cj_;
     var _ck_ = write(w, q);
     return caml_call1(Async_kernel_Deferred_std[8], _ck_);
    }
    function loop$0(counter, s){
     if(is_closed(w))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aZ_], 1);
     var
      next_deferred = caml_call1(Async_kernel_Async_stream[3], s),
      match = caml_call1(Async_kernel_Deferred[5], next_deferred);
     if(! match){
      transfer(0);
      return caml_call2
              (Async_kernel_Deferred_std[11],
               next_deferred,
               check_closed_loop_next);
     }
     var next = match[1];
     if(counter >= 50) return caml_trampoline_return(loop_next$0, [0, next]);
     var counter$0 = counter + 1 | 0;
     return loop_next$0(counter$0, next);
    }
    function loop_next$0(counter, param){
     if(! param){transfer(0); return close(w);}
     var s = param[2], x = param[1];
     caml_call2(Core_Queue[41], q, x);
     if(counter >= 50) return caml_trampoline_return(loop$0, [0, s]);
     var counter$0 = counter + 1 | 0;
     return loop$0(counter$0, s);
    }
    function loop(s){return caml_trampoline(loop$0(0, s));}
    function loop_next(param){return caml_trampoline(loop_next$0(0, param));}
    function check_closed_loop_next(next){
     var _ci_ = 1 - is_closed(w);
     return _ci_ ? loop_next(next) : _ci_;
    }
    loop(s);
    return r;
   }
   function transfer_gen(read_now, write, input, output, f){
    if(check_invariant[1]){invariant$0(input); invariant$0(output);}
    var link = create$0(input, output), consumer = consumer$1(link);
    function unlink(param){
     var t = link[1];
     return caml_call2(Core_Bag[26], t[1][12], t[3]);
    }
    function _b5_(result){
     function _b6_(param){
      function output_closed(param){
       close_read(input);
       unlink(0);
       return caml_call2(Async_kernel_Ivar[14], result, 0);
      }
      function loop(param){
       if(is_closed(output)) return output_closed(0);
       var match = caml_call2(read_now, [0, consumer], input);
       if(typeof match !== "number"){
        var x = match[2];
        return caml_call2(f, x, continue$0);
       }
       if(3456156 <= match){
        unlink(0);
        return caml_call2(Async_kernel_Ivar[14], result, 0);
       }
       function _b9_(param){return loop(0);}
       var _b__ = 0;
       function _b$_(_ch_){return 0;}
       var
        _ca_ = closed(output),
        _cb_ = [0, caml_call2(Async_kernel_Deferred_std[6], _ca_, _b$_), _b__];
       function _cc_(_cg_){return 0;}
       var
        _cd_ = values_available(input),
        _ce_ = [0, caml_call2(Async_kernel_Deferred_std[6], _cd_, _cc_), _cb_],
        _cf_ = caml_call1(Async_kernel_Deferred_std[7], _ce_);
       return caml_call2(Async_kernel_Deferred_std[1], _cf_, _b9_);
      }
      function continue$0(y){
       if(is_closed(output)) return output_closed(0);
       var pushback = caml_call2(write, output, y);
       values_sent_downstream(consumer);
       function _b8_(param){return loop(0);}
       return caml_call2(Async_kernel_Deferred_std[1], pushback, _b8_);
      }
      return loop(0);
     }
     var _b7_ = caml_call1(Async_kernel_Deferred_std[10], 0);
     return caml_call2(Async_kernel_Deferred_std[1], _b7_, _b6_);
    }
    return caml_call1(Async_kernel_Deferred[3], _b5_);
   }
   function transfer(max_queue_length, input, output, f){
    function _b1_(q, k){
     var _b4_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _b4_, k);
    }
    return transfer_gen
            (function(_b2_){
              return function(_b3_){
               return read_now(_b2_, max_queue_length, _b3_);};
             },
             write,
             input,
             output,
             _b1_);
   }
   function transfer$0(input, output, f){
    return transfer_gen
            (read_now$0,
             write$0,
             input,
             output,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function transfer_id(max_queue_length, input, output){
    function _bY_(q, k){return caml_call1(k, q);}
    return transfer_gen
            (function(_bZ_){
              return function(_b0_){
               return read_now(_bZ_, max_queue_length, _b0_);};
             },
             write,
             input,
             output,
             _bY_);
   }
   function map_gen(read, write, input, f){
    function _bV_(info){
     return [1, [0, _a0_, [0, caml_call1(Core_Sexp[90], info), 0]]];
    }
    var
     info = caml_call2(Core_Option[29], input[2], _bV_),
     match = create(0, info, 0),
     output = match[2],
     result = match[1];
    function _bW_(param){return close(output);}
    var _bX_ = transfer_gen(read, write, input, output, f);
    caml_call2(Async_kernel_Deferred_std[11], _bX_, _bW_);
    return result;
   }
   function map(max_queue_length, input, f){
    function _bR_(q, k){
     var _bU_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _bU_, k);
    }
    return map_gen
            (function(_bS_){
              return function(_bT_){
               return read_now(_bS_, max_queue_length, _bT_);};
             },
             write,
             input,
             _bR_);
   }
   function map$0(input, f){
    return map_gen
            (read_now$0,
             write$0,
             input,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function concat_map_list(max_queue_length, input, f){
    function _bO_(q, k){
     return caml_call1(k, caml_call2(Core_Queue[51], q, f));
    }
    return map_gen
            (function(_bP_){
              return function(_bQ_){
               return read_now(_bP_, max_queue_length, _bQ_);};
             },
             write,
             input,
             _bO_);
   }
   function filter_map(max_queue_length, input, f){
    return map
            (max_queue_length,
             input,
             function(q){
              return caml_call3(Async_kernel_Deferred_queue[20], 0, q, f);
             });
   }
   function filter_map$0(max_queue_length, input, f){
    function _bK_(q, k){
     function _bN_(x){return is_read_closed(input) ? 0 : caml_call1(f, x);}
     return caml_call1(k, caml_call2(Core_Queue[53], q, _bN_));
    }
    return map_gen
            (function(_bL_){
              return function(_bM_){
               return read_now(_bL_, max_queue_length, _bM_);};
             },
             write,
             input,
             _bK_);
   }
   function folding_filter_map(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map
            (max_queue_length,
             input,
             function(x){
              function _bI_(param){
               var x = param[2], a = param[1];
               accum[1] = a;
               return x;
              }
              var _bJ_ = caml_call2(f, accum[1], x);
              return caml_call2(Async_kernel_Deferred_std[5][2], _bJ_, _bI_);
             });
   }
   function folding_filter_map$0(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map$0
            (max_queue_length,
             input,
             function(x){
              var
               match = caml_call2(f, accum[1], x),
               x$0 = match[2],
               a = match[1];
              accum[1] = a;
              return x$0;
             });
   }
   function folding_map(max_queue_length, input, init, f){
    return folding_filter_map$0
            (max_queue_length,
             input,
             init,
             function(accum, a){
              var
               match = caml_call2(f, accum, a),
               b = match[2],
               accum$0 = match[1];
              return [0, accum$0, [0, b]];
             });
   }
   function filter(input, f){
    return filter_map$0
            (0, input, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function of_list(l){
    var t = create_internal(0, 0, caml_call1(Core_Queue[38], l));
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    update_pushback(t);
    return t;
   }
   function empty(param){return of_list(0);}
   function singleton(x){
    var match = create(0, 0, 0), writer = match[2], reader = match[1];
    write_without_pushback(writer, x);
    close(writer);
    return reader;
   }
   function unfold(s, f){
    function symbol(d, f){
     var match = caml_call1(Async_kernel_Deferred[5], d);
     if(! match) return caml_call2(Async_kernel_Deferred_std[3], d, f);
     var x = match[1];
     return caml_call1(f, x);
    }
    return create_reader
            (0,
             0,
             function(writer){
              function loop(s){
               function _bG_(param){
                if(! param)
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                var match = param[1], s = match[2], a = match[1];
                if(is_closed(writer))
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                function _bH_(param){return loop(s);}
                return symbol(write$0(writer, a), _bH_);
               }
               return symbol(caml_call1(f, s), _bG_);
              }
              return loop(s);
             });
   }
   function of_sequence(sequence){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(sequence$1){
               if
                (!
                 is_closed(writer)
                 && ! caml_call1(Core_Sequence[16], sequence$1)){
                start_write(writer);
                var
                 _bD_ = length(writer),
                 i$1 = (1 + writer[4] | 0) - _bD_ | 0,
                 sequence = sequence$1,
                 i = i$1;
                for(;;){
                 if(! caml_call2(Async_kernel_Import[2], i, 0)){
                  var match = caml_call1(Core_Sequence[47], sequence);
                  if(match){
                   var
                    match$0 = match[1],
                    sequence$0 = match$0[2],
                    a = match$0[1];
                   caml_call2(Core_Queue[41], writer[3], a);
                   var i$0 = i - 1 | 0, sequence = sequence$0, i = i$0;
                   continue;
                  }
                 }
                 finish_write(writer);
                 var
                  _bE_ = function(param){return loop(sequence);},
                  _bF_ = pushback$1(writer);
                 return caml_call2
                         (Async_kernel_Deferred_std[5][1], _bF_, _bE_);
                }
               }
               return caml_call1(Async_kernel_Deferred_std[10], 0);
              }
              return loop(sequence);
             });
   }
   function to_sequence(t){
    function _bC_(param){
     var match = read_now$0(0, t);
     if(typeof match === "number")
      return 3456156 <= match ? 0 : [0, [0, [1, values_available(t)], 0]];
     var a = match[2];
     return [0, [0, [0, a], 0]];
    }
    return caml_call2(Core_Sequence[49], 0, _bC_);
   }
   function interleave_pipe(inputs){
    var
     match =
       create
        (0, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_interleave)], 0),
     output_writer = match[2],
     output = match[1],
     num_pipes_remaining = [0, 1];
    function decr_num_pipes_remaining(param){
     num_pipes_remaining[1] += -1;
     var _bB_ = caml_call2(Async_kernel_Import[3], num_pipes_remaining[1], 0);
     return _bB_ ? close(output_writer) : _bB_;
    }
    function _bv_(param){return decr_num_pipes_remaining(0);}
    var
     _bw_ =
       iter_without_pushback
        (0,
         0,
         0,
         inputs,
         function(input){
          num_pipes_remaining[1]++;
          function _by_(param){return decr_num_pipes_remaining(0);}
          var
           _bz_ = transfer_id(0, input, output_writer),
           _bA_ = caml_call2(Async_kernel_Deferred_std[5][2], _bz_, _by_);
          return caml_call1(Async_kernel_Deferred_std[8], _bA_);
         }),
     _bx_ = caml_call2(Async_kernel_Deferred_std[5][2], _bw_, _bv_);
    caml_call1(Async_kernel_Deferred_std[8], _bx_);
    return output;
   }
   function interleave(inputs){
    if(check_invariant[1]) caml_call2(Core_List[9], inputs, invariant$0);
    return interleave_pipe(of_list(inputs));
   }
   function merge(inputs, compare){
    if(! inputs) return empty(0);
    if(inputs[2]){
     var
      match = create(0, 0, 0),
      w = match[2],
      r = match[1],
      _bf_ =
        function(param){return caml_call2(Core_List[9], inputs, close_read);},
      _bg_ = closed(w);
     caml_call2(Async_kernel_Deferred_std[11], _bg_, _bf_);
     var
      _bh_ = 0,
      _bi_ =
        function(param, _bu_){
         var a2 = _bu_[1], a1 = param[1];
         return caml_call2(compare, a1, a2);
        },
      heap = caml_call3(Pairing_heap[20], 0, _bi_, _bh_),
      handle_read =
        function(input, eof_or_ok){
         if(typeof eof_or_ok === "number") return 0;
         var v = eof_or_ok[2];
         return caml_call2(Pairing_heap[25], heap, [0, v, input]);
        },
      pop_heap_and_loop =
        function(param){
         for(;;){
          var match = caml_call1(Pairing_heap[28], heap);
          if(! match) return close(w);
          var
           match$0 = match[1],
           input = match$0[2],
           v = match$0[1],
           _bm_ = 1 - is_closed(w);
          if(! _bm_) return _bm_;
          write_without_pushback(w, v);
          var _bn_ = caml_call1(Pairing_heap[3], heap);
          if(caml_call2(Async_kernel_Import[3], _bn_, 0)){
           var
            _bo_ = function(param){return close(w);},
            _bp_ = transfer_id(0, input, w);
           return caml_call2(Async_kernel_Deferred_std[11], _bp_, _bo_);
          }
          var x = read_now$0(0, input);
          if(typeof x === "number" && 3456156 > x){
           var
            _bq_ =
              function(param){
               function _bs_(x){
                handle_read(input, x);
                return pop_heap_and_loop(0);
               }
               var _bt_ = read$0(0, input);
               return caml_call2(Async_kernel_Deferred_std[1], _bt_, _bs_);
              },
            _br_ = pushback$1(w);
           return caml_call2(Async_kernel_Deferred_std[1], _br_, _bq_);
          }
          handle_read(input, x);
         }
        },
      _bj_ =
        function(input){
         function _bk_(x){return handle_read(input, x);}
         var _bl_ = read$0(0, input);
         return caml_call2(Async_kernel_Deferred_std[5][2], _bl_, _bk_);
        },
      initial_push =
        caml_call3(Async_kernel_Deferred_list[14], 0, inputs, _bj_);
     caml_call2
      (Async_kernel_Deferred_std[11], initial_push, pop_heap_and_loop);
     return r;
    }
    var input = inputs[1];
    return input;
   }
   function concat_pipe(inputs){
    var
     r =
       create_reader_not_close_on_exc
        (0,
         function(w){
          var link = create$0(inputs, w), consumer = consumer$1(link);
          return iter$0
                  (0,
                   [0, [0, consumer]],
                   inputs,
                   function(input){return transfer_id(0, input, w);});
         });
    function _bd_(param){return close(inputs);}
    var _be_ = closed(r);
    caml_call2(Async_kernel_Deferred_std[11], _be_, _bd_);
    return r;
   }
   function concat(inputs){
    return create_reader_not_close_on_exc
            (0,
             function(w){
              function _bc_(input){return transfer_id(0, input, w);}
              return caml_call3
                      (Async_kernel_Deferred_list[14], 0, inputs, _bc_);
             });
   }
   function fork(t, pushback_uses){
    var
     match = create(0, 0, 0),
     writer0 = match[2],
     reader0 = match[1],
     match$0 = create(0, 0, 0),
     writer1 = match$0[2],
     reader1 = match$0[1],
     some_reader_was_closed = [0, 0],
     consumer =
       add_consumer
        (t,
         function(param){
          var some_reader_was_closed$0 = some_reader_was_closed[1];
          function _a$_(param){
           return 17724 <= param
                   ? some_reader_was_closed$0 ? -402004920 : 17724
                   : -402004920;
          }
          var
           _ba_ = [0, downstream_flushed(writer1), 0],
           _bb_ = combine([0, downstream_flushed(writer0), _ba_]);
          return caml_call2(Async_kernel_Deferred_std[5][2], _bb_, _a$_);
         }),
     still_open = [0, writer0, [0, writer1, 0]];
    function filter_open(still_open){
     if(! caml_call2(Core_List[13], still_open, is_closed)) return still_open;
     some_reader_was_closed[1] = 1;
     function _a__(w){return 1 - is_closed(w);}
     var still_open$0 = caml_call2(Core_List[50], still_open, _a__);
     if(caml_call1(Core_List[8], still_open$0)) close(t);
     return still_open$0;
    }
    function _a1_(still_open){
     caml_call2(Core_List[9], still_open, close);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    var
     _a2_ =
       fold
        ([0, [0, consumer]],
         0,
         t,
         still_open,
         function(still_open, queue){
          var still_open$0 = filter_open(still_open);
          if(caml_call1(Core_List[8], still_open$0))
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          function _a4_(param){
           var still_open = filter_open(still_open$0);
           function _a8_(w){
            start_write(w);
            function _a9_(x){return caml_call2(Core_Queue[41], w[3], x);}
            caml_call2(Core_Queue[16], queue, _a9_);
            return finish_write(w);
           }
           caml_call2(Core_List[9], still_open, _a8_);
           return still_open;
          }
          if(-648027566 <= pushback_uses)
           var
            _a5_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _a6_ = caml_call1(Async_kernel_Deferred[23], _a5_);
          else
           var
            _a7_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _a6_ = caml_call1(Async_kernel_Deferred[22], _a7_);
          return caml_call2(Async_kernel_Deferred_std[5][2], _a6_, _a4_);
         }),
     _a3_ = caml_call2(Async_kernel_Deferred_std[5][1], _a2_, _a1_);
    caml_call1(Async_kernel_Deferred_std[8], _a3_);
    return [0, reader0, reader1];
   }
   function set_info(t, info){var v = [0, info]; t[2] = v; return 0;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Pipe);
   var
    Async_kernel_Pipe =
      [0,
       sexp_of_pipe,
       sexp_of_pipe,
       [0, sexp_of_t$4, invariant$0],
       [0, sexp_of_t$3, invariant$0],
       create_reader,
       create_writer,
       create,
       empty,
       of_list,
       singleton,
       unfold,
       of_sequence,
       to_sequence,
       close,
       close_read,
       is_closed,
       closed,
       [0, compare, sexp_of_t],
       upstream_flushed,
       downstream_flushed,
       [0, values_sent_downstream],
       add_consumer,
       length,
       is_empty,
       pushback$1,
       write$0,
       write_without_pushback,
       transfer_in,
       transfer_in_without_pushback,
       write_when_ready,
       write_if_open,
       write_without_pushback_if_open,
       read,
       read$0,
       read_exn,
       read_exactly,
       read_now,
       read_now$0,
       peek,
       clear,
       read_all,
       values_available,
       read_choice,
       read_choice_single_consumer_ex,
       Flushed,
       fold,
       fold$0,
       fold_without_pushback,
       iter,
       iter$0,
       iter_without_pushback,
       transfer,
       transfer$0,
       transfer_id,
       map,
       map$0,
       concat_map_list,
       folding_map,
       filter_map,
       filter_map$0,
       folding_filter_map,
       folding_filter_map$0,
       filter,
       interleave,
       interleave_pipe,
       merge,
       concat,
       concat_pipe,
       fork,
       to_stream_deprecated,
       of_stream_deprecated,
       drain,
       drain_and_count,
       to_list,
       hash,
       equal$0,
       compare$0,
       size_budget,
       set_size_budget$0,
       show_debug_messages,
       check_invariant,
       set_info];
   runtime.caml_register_global
    (171, Async_kernel_Pipe, cst_Async_kernel_Pipe$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Mvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Pipe, Base__Field, Base__Invariant, Core, Core__Unit, Expect_test_collector, Moption, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Mvar$0 = "Async_kernel__Mvar",
    cst_async_kernel$0 = "async_kernel",
    cst_current_value$0 = "current_value",
    cst_src_mvar_ml = "src/mvar.ml",
    cst_taken$0 = "taken",
    cst_value_available$0 = "value_available",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/mvar.ml:23:26",
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Moption = global_data.Moption,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Unit = global_data.Core__Unit;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Mvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_mvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    cst_Mvar_take_exn_called_on_em = "Mvar.take_exn called on empty mvar",
    _l_ = [0, cst_src_mvar_ml, 60, 2],
    cst_Mvar_peek_exn_called_on_em = "Mvar.peek_exn called on empty mvar",
    _j_ = [0, "_"],
    _k_ = [0, cst_src_mvar_ml, 16, 357, 379],
    _g_ = [0, cst_value_available$0],
    _h_ = [0, cst_taken$0],
    _i_ = [0, cst_current_value$0],
    cst_value_available = cst_value_available$0,
    cst_taken = cst_taken$0,
    cst_current_value = cst_current_value$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Mvar = cst_Async_kernel_Mvar$0;
   function value_available(r){return r[3];}
   function set_value_available(r, v){r[3] = v; return 0;}
   function taken(r){return r[2];}
   function current_value(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = [0, set_value_available],
    value_available$0 =
      [0,
       function(param){return 0;},
       cst_value_available,
       _b_,
       value_available,
       _a_];
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = 0,
    taken$0 = [0, function(param){return 0;}, cst_taken, _d_, taken, _c_];
   function _e_(r, v){return [0, v, r[2], r[3]];}
   var
    _f_ = 0,
    current_value$0 =
      [0,
       function(param){return 0;},
       cst_current_value,
       _f_,
       current_value,
       _e_];
   function value_available$1(t){
    return caml_call1(Async_kernel_Ivar[18], t[3]);
   }
   function is_empty(t){return caml_call1(Moption[5], t[1]);}
   function invariant(invariant_a, param, t){
    function _C_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      value_available_fun =
        check
         (function(value_available){
           var
            got = caml_call1(Async_kernel_Ivar[17], value_available),
            expect = caml_call1(Moption[6], t[1]),
            sexpifier = Core[305],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_011, b_012){
            return caml_call2(Core[301], a_011, b_012);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     function _E_(_F_){return 0;}
     var
      taken_fun = check(caml_call2(Async_kernel_Bvar[2], Core_Unit[5], _E_)),
      current_value_fun = check(caml_call1(Moption[2], invariant_a));
     caml_call1(current_value_fun, current_value$0);
     caml_call1(taken_fun, taken$0);
     return caml_call1(value_available_fun, value_available$0);
    }
    function _D_(x_010){
     function of_a_001(param){return _j_;}
     var
      taken_006 = x_010[2],
      current_value_004 = x_010[1],
      value_available_008 = x_010[3],
      arg_009 =
        caml_call2(Async_kernel_Ivar[9], Core[518], value_available_008),
      bnds_003 = [0, [1, [0, _g_, [0, arg_009, 0]]], 0],
      arg_007 =
        caml_call3(Async_kernel_Bvar[1], Core[518], Core[202], taken_006),
      bnds_003$0 = [0, [1, [0, _h_, [0, arg_007, 0]]], bnds_003],
      arg_005 = caml_call2(Moption[1], of_a_001, current_value_004),
      bnds_003$1 = [0, [1, [0, _i_, [0, arg_005, 0]]], bnds_003$0];
     return [1, bnds_003$1];
    }
    return caml_call4(Base_Invariant[1], _k_, t, _D_, _C_);
   }
   function peek(t){return caml_call1(Moption[7], t[1]);}
   function peek_exn(t){
    if(is_empty(t)){
     var
      _B_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_peek_exn_called_on_em);
     caml_call1(Core[253], _B_);
    }
    return caml_call1(Moption[8], t[1]);
   }
   function sexp_of_t(sexp_of_a, param, t){
    var x_013 = peek(t);
    return caml_call2(Core[454], sexp_of_a, x_013);
   }
   function sexp_of_t$0(of_a_014, x_015){
    return sexp_of_t(of_a_014, Core[202], x_015);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_A_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$0, invariant$0];
   function sexp_of_t$1(of_a_016, x_017){
    return sexp_of_t(of_a_016, Core[171], x_017);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_z_){return 0;}, t);
   }
   var Read_only = [0, sexp_of_t$1, invariant$1];
   function read_only(t){return t;}
   function write_only(t){return t;}
   function create(param){
    var
     _x_ = caml_call1(Async_kernel_Ivar[12], 0),
     _y_ = caml_call1(Async_kernel_Bvar[3], 0);
    return [0, caml_call1(Moption[4], 0), _y_, _x_];
   }
   function take_nonempty(t){
    if(is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var r = caml_call1(Moption[8], t[1]);
    caml_call1(Moption[11], t[1]);
    caml_call2(Async_kernel_Bvar[5], t[2], 0);
    t[3] = caml_call1(Async_kernel_Ivar[12], 0);
    return r;
   }
   function take_now_exn(t){
    if(is_empty(t)){
     var
      _w_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_take_exn_called_on_em);
     caml_call1(Core[253], _w_);
    }
    return take_nonempty(t);
   }
   function take_now(t){return is_empty(t) ? 0 : [0, take_nonempty(t)];}
   function take(t){
    if(is_empty(t)){
     var _t_ = function(param){return take(t);}, _u_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _u_, _t_);
    }
    var _v_ = take_nonempty(t);
    return caml_call1(Async_kernel_Deferred_std[10], _v_);
   }
   function set(t, v){
    caml_call2(Moption[12], t[1], v);
    return caml_call2(Async_kernel_Ivar[15], t[3], 0);
   }
   function update(t, f){return set(t, caml_call1(f, peek(t)));}
   function update_exn(t, f){return set(t, caml_call1(f, peek_exn(t)));}
   function taken$1(t){return caml_call1(Async_kernel_Bvar[4], t[2]);}
   function put(t, v){
    if(is_empty(t)){
     set(t, v);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _r_(param){return put(t, v);}
    var _s_ = taken$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][1], _s_, _r_);
   }
   function pipe_when_ready(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function loop(param){
     function _n_(param){
      if(caml_call1(Async_kernel_Pipe[16], w))
       return caml_call1(Async_kernel_Deferred_std[10], 0);
      var match = take_now(t);
      if(! match) return loop(0);
      var x = match[1];
      function _p_(param){return loop(0);}
      var _q_ = caml_call2(Async_kernel_Pipe[26], w, x);
      return caml_call2(Async_kernel_Deferred_std[5][1], _q_, _p_);
     }
     var _o_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _o_, _n_);
    }
    var _m_ = loop(0);
    caml_call1(Async_kernel_Deferred_std[8], _m_);
    return r;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Mvar);
   var
    Async_kernel_Mvar =
      [0,
       sexp_of_t,
       Read_write,
       Read_only,
       create,
       is_empty,
       put,
       set,
       update,
       update_exn,
       read_only,
       write_only,
       value_available$1,
       take,
       take_now,
       take_now_exn,
       taken$1,
       peek,
       peek_exn,
       pipe_when_ready];
   runtime.caml_register_global
    (37, Async_kernel_Mvar, cst_Async_kernel_Mvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Lazy_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Base__Monad, Core, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Lazy_deferred$0 = "Async_kernel__Lazy_deferred",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Lazy_deferred$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/lazy_deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _b_ = [0, 3804260],
    _a_ = [0, 3804260],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Lazy_deferred = cst_Async_kernel_Lazy_deferred$0;
   function create(f){
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _l_(param){
     return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, _a_, f);
    }
    var _m_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _m_, _l_)];
   }
   function create_or_error(f){
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _j_(param){
     return caml_call6(Async_kernel_Monitor[18], 0, 0, 0, 0, _b_, f);
    }
    var _k_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _k_, _j_)];
   }
   function wait(t){return t[2];}
   function wait_exn(t){
    return caml_call2(Async_kernel_Deferred_std[4], t[2], Core[245]);
   }
   function force(t){caml_call2(Async_kernel_Ivar[15], t[1], 0); return t[2];}
   function force_exn(t){
    var _h_ = Core[245], _i_ = force(t);
    return caml_call2(Async_kernel_Deferred_std[4], _i_, _h_);
   }
   function return$0(a){
    return create
            (function(param){
              return caml_call1(Async_kernel_Deferred_std[10], a);
             });
   }
   function bind(t, f){
    return create
            (function(param){
              function _f_(a){return force_exn(caml_call1(f, a));}
              var _g_ = force_exn(t);
              return caml_call2(Async_kernel_Deferred_std[5][1], _g_, _f_);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return create
                (function(param){
                  var _e_ = force_exn(t);
                  return caml_call2(Async_kernel_Deferred_std[4], _e_, f);
                 });
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function bind$1(t, f){
    return caml_call2
            (bind$0,
             t,
             function(a){
              return create(function(param){return caml_call1(f, a);});
             });
   }
   function is_forced(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function is_determined(t){
    return caml_call1(Async_kernel_Deferred[7], t[2]);
   }
   function peek(t){return caml_call1(Async_kernel_Deferred[5], t[2]);}
   function peek_exn(t){
    var _c_ = Core[245], _d_ = peek(t);
    return caml_call2(Core_Option[29], _d_, _c_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Lazy_deferred);
   var
    Async_kernel_Lazy_deferred =
      [0,
       create,
       create_or_error,
       force,
       force_exn,
       wait,
       wait_exn,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       bind$1,
       peek,
       peek_exn,
       is_determined,
       is_forced];
   runtime.caml_register_global
    (20, Async_kernel_Lazy_deferred, cst_Async_kernel_Lazy_deferred$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_condition
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Core__Option, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_conditi$0 = "Async_kernel__Async_condition",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Queue = global_data.Core__Queue,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_conditi$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/async_condition.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    _a_ = [0, "waits"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_conditi = cst_Async_kernel_Async_conditi$0;
   function sexp_of_t(of_a_001, param){
    var
     waits_003 = param[1],
     _f_ = caml_call1(Async_kernel_Ivar[9], of_a_001),
     arg_004 = caml_call2(Core_Queue[11], _f_, waits_003),
     bnds_002 = [0, [1, [0, _a_, [0, arg_004, 0]]], 0];
    return [1, bnds_002];
   }
   function create(param){return [0, caml_call2(Core_Queue[61], 0, 0)];}
   function wait(t){
    function _e_(ivar){return caml_call2(Core_Queue[41], t[1], ivar);}
    return caml_call1(Async_kernel_Deferred[3], _e_);
   }
   function signal(t, a){
    function _c_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    var _d_ = caml_call1(Core_Queue[43], t[1]);
    return caml_call2(Core_Option[41], _d_, _c_);
   }
   function broadcast(t, a){
    function _b_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    caml_call2(Core_Queue[16], t[1], _b_);
    return caml_call1(Core_Queue[47], t[1]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_conditi);
   var
    Async_kernel_Async_condition =
      [0, sexp_of_t, create, signal, broadcast, wait];
   runtime.caml_register_global
    (16, Async_kernel_Async_condition, cst_Async_kernel_Async_conditi$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_gc
//# unitInfo: Requires: Async_kernel__Scheduler, Core__Gc, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_gc$0 = "Async_kernel__Async_gc",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Gc = global_data.Core__Gc;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_gc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/async_gc.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    Stat = Core_Gc[1],
    Control = Core_Gc[2],
    print_stat = Core_Gc[3],
    allocated_bytes = Core_Gc[4],
    keep_alive = Core_Gc[5],
    Allocation_policy = Core_Gc[6],
    tune = Core_Gc[7],
    disable_compaction = Core_Gc[8],
    For_testing = Core_Gc[9],
    Stable = Core_Gc[11],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_gc = cst_Async_kernel_Async_gc$0;
   function add_finalizer(heap_block, f){
    var _e_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[46], _e_), heap_block, f);
   }
   function add_finalizer_exn(heap_block, f){
    var _d_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[47], _d_), heap_block, f);
   }
   function add_finalizer_last(heap_block, f){
    var _c_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[48], _c_), heap_block, f);
   }
   function add_finalizer_last_exn(heap_block, f){
    var _b_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[49], _b_), heap_block, f);
   }
   var sexp_of_t = Core_Gc[10][6][1];
   function create(f){
    var _a_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call1(caml_call1(Async_kernel_Scheduler[45], _a_), f);
   }
   var delete$0 = Core_Gc[10][6][3], Alarm = [0, sexp_of_t, create, delete$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_gc);
   var
    Async_kernel_Async_gc =
      [0,
       Stat,
       Control,
       print_stat,
       allocated_bytes,
       keep_alive,
       Allocation_policy,
       tune,
       disable_compaction,
       For_testing,
       Stable,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       Alarm];
   runtime.caml_register_global
    (13, Async_kernel_Async_gc, cst_Async_kernel_Async_gc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Async = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant_i = [0, Async];
   runtime.caml_register_global
    (11, Async_kernel_Async_invariant_i, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant
//# unitInfo: Requires: Async_kernel__Async_invariant_intf, Async_kernel__Deferred, Async_kernel__Monitor, Base__Field, Base__Invariant, Core, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria$0 = "Async_kernel__Async_invariant",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Field = global_data.Base__Field,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    invariant = Base_Invariant[1],
    check_field = Base_Invariant[2],
    _e_ = [0, cst_exn],
    _f_ = [0, "field"],
    cst_problem_with_field = "problem with field",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, 1],
    _a_ = [0, cst_exn],
    cst_invariant_failed = "invariant failed",
    _b_ = [0, 3804260],
    _c_ = [0, 523273847],
    _d_ = [0, 1],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_invaria = cst_Async_kernel_Async_invaria$0;
   function invariant$0(here, t, sexp_of_t, f){
    function _r_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _t_ = [0, caml_call1(sexp_of_t, t), 0],
      _u_ = [0, [1, [0, _a_, [0, caml_call1(Core[537], exn), 0]]], _t_],
      _v_ = [0, caml_call1(Core_Source_code_position[1], here), _u_],
      _w_ =
        [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_invariant_failed), _v_]];
     return caml_call1(Core[253], _w_);
    }
    var _s_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _d_, _c_, _b_, f);
    return caml_call2(Async_kernel_Deferred[16][4][3], _s_, _r_);
   }
   function check_field$0(t, f, wait_for_previous, field){
    function _j_(param){
     function _k_(param){
      if(0 === param[0]) return 0;
      var
       exn = param[1],
       _n_ = [0, [1, [0, _e_, [0, caml_call1(Core[537], exn), 0]]], 0],
       _o_ = caml_call1(Base_Field[2], field),
       _p_ = [0, [1, [0, _f_, [0, caml_call1(Core[471], _o_), 0]]], _n_],
       _q_ =
         [1,
          [0, caml_call1(Sexplib0_Sexp_conv[7], cst_problem_with_field), _p_]];
      return caml_call1(Core[253], _q_);
     }
     function _l_(param){
      return caml_call1(f, caml_call2(Base_Field[3], field, t));
     }
     var
      _m_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _i_, _h_, _g_, _l_);
     return caml_call2(Async_kernel_Deferred[16][4][3], _m_, _k_);
    }
    return caml_call2(Async_kernel_Deferred[16][4][2], wait_for_previous, _j_);
   }
   var Async = [0, invariant$0, check_field$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant = [0, invariant, check_field, Async];
   runtime.caml_register_global
    (29, Async_kernel_Async_invariant, cst_Async_kernel_Async_invaria$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Scheduler, Core, Expect_test_collector, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel$0 = "Async_kernel",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_kernel_ml$0 = "src/async_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/async_kernel.ml:94:17",
    cst = "",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_async_kernel_ml$0);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    catch$0 = Async_kernel_Monitor[21],
    choice = Async_kernel_Deferred[27],
    choose = Async_kernel_Deferred[29],
    don_t_wait_for = Async_kernel_Deferred[25],
    every = Async_kernel_Clock_ns[10],
    never = Async_kernel_Deferred[19],
    schedule = Async_kernel_Scheduler[59],
    schedule$0 = Async_kernel_Scheduler[58],
    try_with = Async_kernel_Monitor[16],
    upon = Async_kernel_Deferred[4],
    with_timeout = Async_kernel_Clock_ns[5],
    within = Async_kernel_Scheduler[56],
    within$0 = Async_kernel_Scheduler[55],
    symbol = Async_kernel_Deferred[17][3],
    symbol$0 = Async_kernel_Deferred_result[1],
    symbol$1 = Async_kernel_Deferred_result[2],
    include = Async_kernel_Deferred[16],
    return$0 = include[1],
    symbol_bind = include[2],
    symbol_map = include[3],
    Let_syntax = include[4],
    Async_kernel_private = [0],
    cst_src_async_kernel_ml = cst_src_async_kernel_ml$0,
    cst_return_does_not_allocate = "[return ()] does not allocate",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel = cst_Async_kernel$0;
   function _a_(param){
    var expect = runtime.core_gc_minor_words(0);
    caml_call1(return$0, 0);
    caml_call1(Async_kernel_Deferred[12], 0);
    caml_call1(Async_kernel_Deferred[16][1], 0);
    caml_call1(Async_kernel_Deferred[16][4][1], 0);
    var
     got = runtime.core_gc_minor_words(0),
     sexpifier = Core[356],
     equal = 0,
     message = 0,
     here = 0;
    function comparator(a_001, b_002){
     return caml_call2(Core[352], a_001, b_002);
    }
    caml_call8
     (Ppx_assert_lib_Runtime[3],
      pos,
      sexpifier,
      comparator,
      here,
      message,
      equal,
      expect,
      got);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_return_does_not_allocate,
     0,
     cst_src_async_kernel_ml,
     87,
     0,
     443,
     _a_);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel);
   var
    Async_kernel =
      [0,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       within,
       within$0,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private];
   runtime.caml_register_global(22, Async_kernel, cst_Async_kernel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFmdGVyIiwidCIsInNwYW4iLCJyZXN1bHQiLCJsb2ciLCJhcmcyXzAwMyIsImFyZzNfMDA0Iiwic2V4cF9vZl9hIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDA1IiwicmVzMV8wMDYiLCJyZXMyXzAwNyIsInJlczNfMDA4IiwibG9nX3N0cmluZyIsIm1lc3NhZ2UiLCJjb25jYXQiLCJlcHJpbnQiLCJlcHJpbnRfcyIsImVwcmludHMiLCJwcmludF9zIiwic2V4cCIsInNlYyIsInNleHBfb2ZfdCIsInRvX3JlcHIiLCJvZl9yZXByIiwibmFtZXMiLCJkZWJ1ZyIsImZvcndhcmRpbmciLCJyIiwic2V0X2ZvcndhcmRpbmciLCJ2IiwiaGFzX3NlZW5fZXJyb3IiLCJzZXRfaGFzX3NlZW5fZXJyb3IiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyIsInNldF90YWlsc19mb3JfYWxsX2Vycm9ycyIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwic2V0X2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwibmV4dF9lcnJvciIsInNldF9uZXh0X2Vycm9yIiwiaWQiLCJoZXJlIiwibmFtZSIsImZvcndhcmRpbmckMCIsImhhc19zZWVuX2Vycm9yJDAiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyQwIiwiaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMkMCIsIm5leHRfZXJyb3IkMCIsImlkJDAiLCJoZXJlJDAiLCJuYW1lJDAiLCJtYWtlX2NyZWF0b3IiLCJuYW1lX2Z1biIsImhlcmVfZnVuIiwiaWRfZnVuIiwibmV4dF9lcnJvcl9mdW4iLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19mdW4iLCJ0YWlsc19mb3JfYWxsX2Vycm9yc19mdW4iLCJoYXNfc2Vlbl9lcnJvcl9mdW4iLCJmb3J3YXJkaW5nX2Z1biIsImNvbXBpbGVfYWNjIiwiY29tcGlsZV9hY2MkMCIsIm5hbWVfZ2VuIiwiY29tcGlsZV9hY2MkMSIsImhlcmVfZ2VuIiwiY29tcGlsZV9hY2MkMiIsImlkX2dlbiIsImNvbXBpbGVfYWNjJDMiLCJuZXh0X2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDQiLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19nZW4iLCJjb21waWxlX2FjYyQ1IiwidGFpbHNfZm9yX2FsbF9lcnJvcnNfZ2VuIiwiY29tcGlsZV9hY2MkNiIsImhhc19zZWVuX2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDciLCJmb3J3YXJkaW5nX2dlbiIsImFjYyIsImNyZWF0ZSIsIm1hcCIsIml0ZXIiLCJmb2xkIiwiaW5pdCIsIm1hcF9wb2x5IiwicmVjb3JkIiwiZm9yX2FsbCIsImV4aXN0cyIsInRvX2xpc3QiLCJpdGVyJDAiLCJmb2xkJDAiLCJmb3JfYWxsJDAiLCJleGlzdHMkMCIsInRvX2xpc3QkMCIsIm1hcCQwIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyIsInJlY29yZCQwIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbnMiLCJ0JDEiLCJhYyIsImFjJDAiLCJ0JDAiLCJ4XzAwMSIsIm5leHRfaWQiLCJjcmVhdGVfd2l0aF9wYXJlbnQiLCJpbmZvIiwicGFyZW50IiwiaSIsInMiLCJzJDAiLCJ4XzAwMiIsInBhcmVudCQwIiwibWFpbiIsImJhY2t0cmFjZV9oaXN0b3J5IiwibG9jYWxfc3RvcmFnZSIsInByaW9yaXR5IiwibW9uaXRvciIsImJhY2t0cmFjZV9oaXN0b3J5JDAiLCJsb2NhbF9zdG9yYWdlJDAiLCJwcmlvcml0eSQwIiwibW9uaXRvciQwIiwibW9uaXRvcl9mdW4iLCJwcmlvcml0eV9mdW4iLCJsb2NhbF9zdG9yYWdlX2Z1biIsImJhY2t0cmFjZV9oaXN0b3J5X2Z1biIsIm1vbml0b3JfZ2VuIiwicHJpb3JpdHlfZ2VuIiwibG9jYWxfc3RvcmFnZV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV8wMDgiLCJsb2NhbF9zdG9yYWdlXzAwNiIsInByaW9yaXR5XzAwNCIsIm1vbml0b3JfMDAyIiwiYXJnXzAwOSIsImJuZHNfMDAxIiwiYXJnXzAwNyIsImJuZHNfMDAxJDAiLCJhcmdfMDA1IiwiYm5kc18wMDEkMSIsImFyZ18wMDMiLCJibmRzXzAwMSQyIiwiaW52YXJpYW50IiwiY3JlYXRlX2xpa2UiLCJmaW5kX2xvY2FsIiwia2V5Iiwid2l0aF9sb2NhbCIsImRhdGEiLCJyZWNvcmRfYmFja3RyYWNlIiwiZHVtbXlfZSIsImR1bW15X2YiLCJkdW1teV9hIiwic2V4cF9vZl9zbG90cyIsIm9mX2V2ZW50IiwiZXZlbnQiLCJvZl9qb2IiLCJqb2IiLCJpc19ldmVudCIsImlzX2pvYiIsImtpbmQiLCJwcm9qZWN0Iiwiam9iX29yX2V2ZW50IiwiZXZlbnRzIiwic2V0X2V4ZWN1dGlvbl9jb250ZXh0IiwiZXhlY3V0aW9uX2NvbnRleHQiLCJsZW5ndGgiLCJzZXRfbGVuZ3RoIiwiZnJvbnQiLCJzZXRfZnJvbnQiLCJtYXNrIiwic2V0X21hc2siLCJqb2JzIiwic2V0X2pvYnMiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSIsInNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSIsIm51bV9qb2JzX3J1biIsInNldF9udW1fam9ic19ydW4iLCJsZW5ndGgkMCIsImZyb250JDAiLCJtYXNrJDAiLCJqb2JzJDAiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSQwIiwibnVtX2pvYnNfcnVuJDAiLCJudW1fam9ic19ydW5fMDAyIiwiam9ic19sZWZ0X3RoaXNfY3ljbGVfMDA0Iiwiam9ic18wMDYiLCJtYXNrXzAwOCIsImZyb250XzAxMCIsImxlbmd0aF8wMTIiLCJhcmdfMDEzIiwiYXJnXzAxMSIsImJuZHNfMDAxJDMiLCJibmRzXzAwMSQ0Iiwib2Zmc2V0IiwiY2FwYWNpdHkiLCJjaGVjayIsImYiLCJsZW5ndGhfZnVuIiwiZnJvbnRfZnVuIiwibWFza19mdW4iLCJqb2JzX2Z1biIsImpvYnNfbGVmdF90aGlzX2N5Y2xlX2Z1biIsIm51bV9qb2JzX3J1bl9mdW4iLCJjcmVhdGVfYXJyYXkiLCJjbGVhciIsInNldCIsImEiLCJvZmZzZXQkMCIsImVucXVldWUiLCJvbGRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJvbGRfam9icyIsIm9sZF9mcm9udCIsImxlbjEiLCJsZW4yIiwibmV3X2pvYnMiLCJzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUkMCIsIm4iLCJjYW5fcnVuX2Ffam9iIiwicnVuX2pvYiIsInNjaGVkdWxlciIsInJ1bl9leHRlcm5hbF9qb2JzIiwiZXh0ZXJuYWxfam9icyIsInJ1bl9qb2JzIiwidGhpc19qb2IiLCJleG4kMCIsImV4biIsImJhY2t0cmFjZSIsInBvcyQzIiwicG9zJDIiLCJwb3MkMSIsInBvcyQwIiwicG9zIiwibmFtZXMkMCIsImlzX251bGwiLCJkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWciLCJjb21wYXJlJDAiLCJlcXVhbCQwIiwic2V4cF9vZl90JDEiLCJ0cmFuc2l0aW9uX2lzX2FsbG93ZWQiLCJmcm9tIiwidG8iLCJzZXhwX29mX2V2ZW50IiwiYXQiLCJpbnRlcnZhbCIsInN0YXR1cyIsIm1hdGNoIiwibm9uZSIsInNvbWUiLCJpc19ub25lIiwiaXNfc29tZSIsImZpcnN0X3NvbWUiLCJ0MSIsInQyIiwidW5zYWZlX3ZhbHVlIiwic2V4cF9vZl90JDIiLCJwcHhfb3B0aW9uYWxfZV8wIiwidmFsdWUkMCIsImRlZmF1bHQkMCIsInZhbHVlX2V4biIsInRvX29wdGlvbiIsIm9mX29wdGlvbiIsInNldF9zdGF0dXMiLCJwcmV2X2ZpcmVkIiwic2V0X3ByZXZfZmlyZWQiLCJuZXh0X2ZpcmVkIiwic2V0X25leHRfZmlyZWQiLCJzZXRfaW50ZXJ2YWwiLCJjYWxsYmFjayIsImF0JDAiLCJzZXRfYXQiLCJhbGFybSIsInNldF9hbGFybSIsInN0YXR1cyQwIiwicHJldl9maXJlZCQwIiwibmV4dF9maXJlZCQwIiwiaW50ZXJ2YWwkMCIsImV4ZWN1dGlvbl9jb250ZXh0JDAiLCJjYWxsYmFjayQwIiwiYXQkMSIsImFsYXJtJDAiLCJhbGFybV9mdW4iLCJhdF9mdW4iLCJjYWxsYmFja19mdW4iLCJleGVjdXRpb25fY29udGV4dF9mdW4iLCJpbnRlcnZhbF9mdW4iLCJuZXh0X2ZpcmVkX2Z1biIsInByZXZfZmlyZWRfZnVuIiwic3RhdHVzX2Z1biIsImFsYXJtX2dlbiIsImF0X2dlbiIsImNhbGxiYWNrX2dlbiIsImV4ZWN1dGlvbl9jb250ZXh0X2dlbiIsImludGVydmFsX2dlbiIsIm5leHRfZmlyZWRfZ2VuIiwicHJldl9maXJlZF9nZW4iLCJzdGF0dXNfZ2VuIiwiZ290Iiwic2V4cGlmaWVyIiwiZXhwZWN0IiwiZXF1YWwiLCJjb21wYXJhdG9yIiwiYV8wMTMiLCJiXzAxNCIsImFfMDA5IiwiYl8wMTAiLCJhXzAwNSIsImJfMDA2Iiwic2V0X3N0YXR1cyQwIiwic2V0X3N0YXR1c19pZiIsImlzIiwic2V4cF9vZl90JDMiLCJrIiwiaXNfd2FsbF9jbG9jayIsImhhbmRsZV9maXJlZCIsIm1vc3RfcmVjZW50bHlfZmlyZWQiLCJzZXRfbW9zdF9yZWNlbnRseV9maXJlZCIsImZpcmVkX2V2ZW50cyIsInNldF9maXJlZF9ldmVudHMiLCJhbV9hZHZhbmNpbmciLCJzZXRfYW1fYWR2YW5jaW5nIiwiYWR2YW5jZV9lcnJvcnMiLCJzZXRfYWR2YW5jZV9lcnJvcnMiLCJzY2hlZHVsZXIkMCIsImlzX3dhbGxfY2xvY2skMCIsImhhbmRsZV9maXJlZCQwIiwibW9zdF9yZWNlbnRseV9maXJlZCQwIiwiZmlyZWRfZXZlbnRzJDAiLCJldmVudHMkMCIsImFtX2FkdmFuY2luZyQwIiwiYWR2YW5jZV9lcnJvcnMkMCIsIm1ha2VfY3JlYXRvciQwIiwiYWR2YW5jZV9lcnJvcnNfZnVuIiwiYW1fYWR2YW5jaW5nX2Z1biIsImV2ZW50c19mdW4iLCJmaXJlZF9ldmVudHNfZnVuIiwibW9zdF9yZWNlbnRseV9maXJlZF9mdW4iLCJoYW5kbGVfZmlyZWRfZnVuIiwiaXNfd2FsbF9jbG9ja19mdW4iLCJzY2hlZHVsZXJfZnVuIiwiYWR2YW5jZV9lcnJvcnNfZ2VuIiwiYW1fYWR2YW5jaW5nX2dlbiIsImV2ZW50c19nZW4iLCJmaXJlZF9ldmVudHNfZ2VuIiwibW9zdF9yZWNlbnRseV9maXJlZF9nZW4iLCJoYW5kbGVfZmlyZWRfZ2VuIiwiaXNfd2FsbF9jbG9ja19nZW4iLCJjb21waWxlX2FjYyQ4Iiwic2NoZWR1bGVyX2dlbiIsImNyZWF0ZSQwIiwibWFwJDEiLCJpdGVyJDEiLCJmb2xkJDEiLCJtYXBfcG9seSQwIiwiZm9yX2FsbCQxIiwiZXhpc3RzJDEiLCJ0b19saXN0JDEiLCJpdGVyJDIiLCJmb2xkJDIiLCJmb3JfYWxsJDIiLCJleGlzdHMkMiIsInRvX2xpc3QkMiIsIm1hcCQyIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyQwIiwic2V4cF9vZl90JDQiLCJub3ciLCJhbGxfZXZlbnRzIiwiYXQyIiwiYXQxIiwidGltaW5nX3doZWVsX25vdyIsImlzX2luX2ZpcmVkX2V2ZW50cyIsInRhcmdldF9ldmVudCIsImN1cnJlbnQkMSIsImN1cnJlbnQiLCJjdXJyZW50JDAiLCJpbnZhcmlhbnRfd2l0aF9qb2JzIiwiam9iX2ludmFyaWFudCIsInBweF9vcHRpb25hbF9lXzAkMCIsImFfMDE3IiwiYl8wMTgiLCJnb3QkMCIsInNleHBpZmllciQwIiwiZXhwZWN0JDAiLCJtZXNzYWdlJDAiLCJjb21wYXJhdG9yJDAiLCJhXzAxOSIsImJfMDIwIiwieF8wMTYiLCJpbnZhcmlhbnQkMCIsInNleHBfb2ZfdCQ1IiwieF8wMjEiLCJpbnZhcmlhbnQkMSIsImludmFyaWFudF93aXRoX2pvYnMkMCIsInNleHBfb2ZfdCQ2IiwieF8wMjIiLCJpZCQxIiwiaXNfd2FsbF9jbG9jayQxIiwibWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsInJlYWRfb25seSIsImZpcmUiLCJjb250aW51ZSQwIiwibmV4dCQwIiwiY29udGludWUkMSIsInBweF9vcHRpb25hbF9lXzAkMSIsIm5leHQiLCJwcHhfb3B0aW9uYWxfZV8wJDIiLCJwcmV2IiwiYWxhcm1fcHJlY2lzaW9uIiwibmV4dF9hbGFybV9maXJlc19hdCIsIm5leHRfYWxhcm1fcnVuc19hdCIsIm5vdyQwIiwidGltaW5nX3doZWVsX25vdyQwIiwic2NoZWR1bGUiLCJyZW1vdmVfZnJvbV9maXJlZCIsIm5ld19zdGF0dXMiLCJzZXhwX29mX2V2ZW50JDAiLCJzdGF0dXMkMSIsInByZXZfZmlyZWQkMSIsInNldF9wcmV2X2ZpcmVkJDAiLCJuZXh0X2ZpcmVkJDEiLCJzZXRfbmV4dF9maXJlZCQwIiwiaW50ZXJ2YWwkMSIsInNldF9pbnRlcnZhbCQwIiwiZXhlY3V0aW9uX2NvbnRleHQkMSIsImNhbGxiYWNrJDEiLCJzZXRfYXQkMCIsImFsYXJtJDEiLCJzZXRfYWxhcm0kMCIsInNleHBfb2ZfdCQ3IiwiaW52YXJpYW50JDIiLCJzZXRfc3RhdHVzJDEiLCJzZXRfc3RhdHVzX2lmJDAiLCJzY2hlZHVsZWRfYXQiLCJjcmVhdGVfaW50ZXJuYWwiLCJhZGQkMCIsImNyZWF0ZV9hbmRfYWRkIiwiYXQkMiIsImFmdGVyJDAiLCJyZXF1aXJlX3NwYW5fYXRfbGVhc3RfYWxhcm1fcHIiLCJhbGFybV9wcmVjaXNpb24kMCIsImF0X2ludGVydmFscyIsInNleHBfb2ZfdCQ4IiwiYWJvcnQiLCJhYm9ydF9pZl9wb3NzaWJsZSIsImFib3J0X2V4biIsInJlYXNvbiIsImNyZWF0ZSQxIiwic2NoZWR1bGVfYXRfaW50ZXJuYWwiLCJzY2hlZHVsZV9hdCIsInNjaGVkdWxlX2FmdGVyIiwic2NoZWR1bGVfYXRfaW50ZXJ2YWxzIiwicmVzY2hlZHVsZV9hdCIsInJlc2NoZWR1bGVfYWZ0ZXIiLCJydW5fYWZ0ZXIiLCJydW5fYXQiLCJydW5fYXRfaW50ZXJ2YWxzIiwicnVuX2ZpcmVkX2V2ZW50cyIsInNlbmRfZXhuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCIsInNlbmRfZXhuJDAiLCJhZHZhbmNlX2Nsb2NrIiwiZmlyZV9wYXN0X2FsYXJtcyIsImFkdmFuY2VfaW50ZXJuYWwiLCJwcmVwYXJlX3RvX2FkdmFuY2UiLCJmaW5pc2hfYWR2YW5jaW5nIiwiZXJyb3JzIiwiYWR2YW5jZV9ieV9hbGFybXMiLCJtaW5fYWxhcm1fdGltZSIsImFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoXyIsImFkdmFuY2VfZGlyZWN0bHkiLCJkdXJhdGlvbl9vZiIsInN0YXJ0IiwiZHVyYXRpb24iLCJtYXhfYWxhcm1fdGltZV9pbl9taW5fdGltaW5nX3ciLCJoYXNfZXZlbnRzX3RvX3J1biIsImNyZWF0ZV93aXRoX2NlbGwiLCJjZWxsIiwiY3JlYXRlX2Z1bGwiLCJleGVjIiwiZXhlYyQwIiwiZXhlY19mdW4iLCJleGVjX2dlbiIsInNleHBfb2ZfdCQwIiwiZXhlY3V0aW9uX2NvbnRleHRfMDAyIiwicmVjb3JkX2JhY2t0cmFjZXMiLCJzZXRfcmVjb3JkX2JhY2t0cmFjZXMiLCJtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl8iLCJzZXRfbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV8iLCJjaGVja19pbnZhcmlhbnRzIiwic2V0X2NoZWNrX2ludmFyaWFudHMiLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiIsInNldF95aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiIsInlpZWxkJDAiLCJzZXRfeWllbGQiLCJldmVudF9hZGRlZF9ob29rIiwic2V0X2V2ZW50X2FkZGVkX2hvb2siLCJqb2JfcXVldWVkX2hvb2siLCJzZXRfam9iX3F1ZXVlZF9ob29rIiwidGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2siLCJzZXRfdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2giLCJ0aW1lX3NvdXJjZSIsInNldF90aW1lX3NvdXJjZSIsInRvdGFsX2N5Y2xlX3RpbWUiLCJzZXRfdG90YWxfY3ljbGVfdGltZSIsImxhc3RfY3ljbGVfbnVtX2pvYnMiLCJzZXRfbGFzdF9jeWNsZV9udW1fam9icyIsImxhc3RfY3ljbGVfdGltZSIsInNldF9sYXN0X2N5Y2xlX3RpbWUiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZCIsInNldF9ydW5fZXZlcnlfY3ljbGVfZW5kIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0Iiwic2V0X3J1bl9ldmVyeV9jeWNsZV9zdGFydCIsImluX2N5Y2xlIiwic2V0X2luX2N5Y2xlIiwiY3ljbGVfc3RhcnQiLCJzZXRfY3ljbGVfc3RhcnQiLCJjeWNsZV9jb3VudCIsInNldF9jeWNsZV9jb3VudCIsInVuY2F1Z2h0X2V4bl91bndyYXBwZWQiLCJzZXRfdW5jYXVnaHRfZXhuIiwic2V0X2N1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQiLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0Iiwic2V0X21haW5fZXhlY3V0aW9uX2NvbnRleHQiLCJ2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIiwibG93X3ByaW9yaXR5X2pvYnMiLCJub3JtYWxfcHJpb3JpdHlfam9icyIsImpvYl9wb29sIiwic2V0X2pvYl9wb29sIiwiY2hlY2tfYWNjZXNzIiwic2V0X2NoZWNrX2FjY2VzcyIsInJlY29yZF9iYWNrdHJhY2VzJDAiLCJtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl8kMCIsImNoZWNrX2ludmFyaWFudHMkMCIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluJDAiLCJ5aWVsZCQxIiwiZXZlbnRfYWRkZWRfaG9vayQwIiwiam9iX3F1ZXVlZF9ob29rJDAiLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayQwIiwiZXh0ZXJuYWxfam9icyQwIiwidGltZV9zb3VyY2UkMCIsInRvdGFsX2N5Y2xlX3RpbWUkMCIsImxhc3RfY3ljbGVfbnVtX2pvYnMkMCIsImxhc3RfY3ljbGVfdGltZSQwIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSQwIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZCQwIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlJDAiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnQkMCIsImluX2N5Y2xlJDAiLCJjeWNsZV9zdGFydCQwIiwiY3ljbGVfY291bnQkMCIsInVuY2F1Z2h0X2V4biIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQkMCIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHQkMCIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMkMCIsImxvd19wcmlvcml0eV9qb2JzJDAiLCJub3JtYWxfcHJpb3JpdHlfam9icyQwIiwiam9iX3Bvb2wkMCIsImNoZWNrX2FjY2VzcyQwIiwiY2hlY2tfYWNjZXNzX2Z1biIsImpvYl9wb29sX2Z1biIsIm5vcm1hbF9wcmlvcml0eV9qb2JzX2Z1biIsImxvd19wcmlvcml0eV9qb2JzX2Z1biIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfZnVuIiwibWFpbl9leGVjdXRpb25fY29udGV4dF9mdW4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0X2Z1biIsInVuY2F1Z2h0X2V4bl9mdW4iLCJjeWNsZV9jb3VudF9mdW4iLCJjeWNsZV9zdGFydF9mdW4iLCJpbl9jeWNsZV9mdW4iLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfZnVuIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlX2Z1IiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF9mdW4iLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlX2Z1biIsImxhc3RfY3ljbGVfdGltZV9mdW4iLCJsYXN0X2N5Y2xlX251bV9qb2JzX2Z1biIsInRvdGFsX2N5Y2xlX3RpbWVfZnVuIiwidGltZV9zb3VyY2VfZnVuIiwiZXh0ZXJuYWxfam9ic19mdW4iLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va18iLCJqb2JfcXVldWVkX2hvb2tfZnVuIiwiZXZlbnRfYWRkZWRfaG9va19mdW4iLCJ5aWVsZF9mdW4iLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl9mdW4iLCJjaGVja19pbnZhcmlhbnRzX2Z1biIsInJlY29yZF9iYWNrdHJhY2VzX2Z1biIsImNoZWNrX2FjY2Vzc19nZW4iLCJqb2JfcG9vbF9nZW4iLCJub3JtYWxfcHJpb3JpdHlfam9ic19nZW4iLCJsb3dfcHJpb3JpdHlfam9ic19nZW4iLCJ2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzX2dlbiIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHRfZ2VuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dF9nZW4iLCJ1bmNhdWdodF9leG5fZ2VuIiwiY3ljbGVfY291bnRfZ2VuIiwiY29tcGlsZV9hY2MkOSIsImN5Y2xlX3N0YXJ0X2dlbiIsImNvbXBpbGVfYWNjJDEwIiwiaW5fY3ljbGVfZ2VuIiwiY29tcGlsZV9hY2MkMTEiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfZ2VuIiwiY29tcGlsZV9hY2MkMTIiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfZ2UiLCJjb21waWxlX2FjYyQxMyIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfZ2VuIiwiY29tcGlsZV9hY2MkMTQiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlX2dlbiIsImNvbXBpbGVfYWNjJDE1IiwibGFzdF9jeWNsZV90aW1lX2dlbiIsImNvbXBpbGVfYWNjJDE2IiwibGFzdF9jeWNsZV9udW1fam9ic19nZW4iLCJjb21waWxlX2FjYyQxNyIsInRvdGFsX2N5Y2xlX3RpbWVfZ2VuIiwiY29tcGlsZV9hY2MkMTgiLCJ0aW1lX3NvdXJjZV9nZW4iLCJjb21waWxlX2FjYyQxOSIsImV4dGVybmFsX2pvYnNfZ2VuIiwiY29tcGlsZV9hY2MkMjAiLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va18kMCIsImNvbXBpbGVfYWNjJDIxIiwiam9iX3F1ZXVlZF9ob29rX2dlbiIsImNvbXBpbGVfYWNjJDIyIiwiZXZlbnRfYWRkZWRfaG9va19nZW4iLCJjb21waWxlX2FjYyQyMyIsInlpZWxkX2dlbiIsImNvbXBpbGVfYWNjJDI0IiwieWllbGRfdW50aWxfbm9fam9ic19yZW1haW5fZ2VuIiwiY29tcGlsZV9hY2MkMjUiLCJjaGVja19pbnZhcmlhbnRzX2dlbiIsImNvbXBpbGVfYWNjJDI2IiwibWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfJDEiLCJjb21waWxlX2FjYyQyNyIsInJlY29yZF9iYWNrdHJhY2VzX2dlbiIsImNyZWF0ZSQyIiwiY2hlY2tfYWNjZXNzXzAwNyIsImpvYl9wb29sXzAwOSIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfMDE1IiwibG93X3ByaW9yaXR5X2pvYnNfMDEzIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfMDExIiwibWFpbl9leGVjdXRpb25fY29udGV4dF8wMTciLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XzAxOSIsInVuY2F1Z2h0X2V4bl8wMjEiLCJjeWNsZV9jb3VudF8wMjciLCJjeWNsZV9zdGFydF8wMjkiLCJpbl9jeWNsZV8wMzEiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfMDMzIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlXzAzIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF8wMzciLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlXzAzOSIsImxhc3RfY3ljbGVfdGltZV8wNDEiLCJsYXN0X2N5Y2xlX251bV9qb2JzXzA0MyIsInRvdGFsX2N5Y2xlX3RpbWVfMDQ1IiwidGltZV9zb3VyY2VfMDQ3IiwiZXh0ZXJuYWxfam9ic18wNDkiLCJqb2JfcXVldWVkX2hvb2tfMDUzIiwiZXZlbnRfYWRkZWRfaG9va18wNTUiLCJ5aWVsZF8wNTciLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl8wNTkiLCJjaGVja19pbnZhcmlhbnRzXzA2MSIsInJlY29yZF9iYWNrdHJhY2VzXzA2NSIsImFyZ18wNjYiLCJibmRzXzAwNiIsImFyZ18wNjQiLCJibmRzXzAwNiQwIiwiYXJnXzA2MiIsImJuZHNfMDA2JDEiLCJhcmdfMDYwIiwiYm5kc18wMDYkMiIsImFyZ18wNTgiLCJibmRzXzAwNiQzIiwiYXJnXzA1NiIsImJuZHNfMDA2JDQiLCJhcmdfMDU0IiwiYm5kc18wMDYkNSIsImFyZ18wNTIiLCJibmRzXzAwNiQ2IiwiYXJnXzA1MCIsImJuZHNfMDA2JDciLCJhcmdfMDQ4IiwiYm5kc18wMDYkOCIsImFyZ18wNDYiLCJibmRzXzAwNiQ5IiwiYXJnXzA0NCIsImJuZHNfMDA2JDEwIiwiYXJnXzA0MiIsImJuZHNfMDA2JDExIiwiYXJnXzA0MCIsImJuZHNfMDA2JDEyIiwiYXJnXzAzOCIsImJuZHNfMDA2JDEzIiwiYXJnXzAzNiIsImJuZHNfMDA2JDE0IiwiYXJnXzAzNCIsImJuZHNfMDA2JDE1IiwiYXJnXzAzMiIsImJuZHNfMDA2JDE2IiwiYXJnXzAzMCIsImJuZHNfMDA2JDE3IiwiYXJnXzAyOCIsImJuZHNfMDA2JDE4IiwiYXJnMV8wMjQiLCJhcmcwXzAyMyIsInJlczBfMDI1IiwicmVzMV8wMjYiLCJhcmdfMDIyIiwiYm5kc18wMDYkMTkiLCJhcmdfMDIwIiwiYm5kc18wMDYkMjAiLCJhcmdfMDE4IiwiYm5kc18wMDYkMjEiLCJhcmdfMDE2IiwiYm5kc18wMDYkMjIiLCJhcmdfMDE0IiwiYm5kc18wMDYkMjMiLCJhcmdfMDEyIiwiYm5kc18wMDYkMjQiLCJhcmdfMDEwIiwiYm5kc18wMDYkMjUiLCJhcmdfMDA4IiwiYm5kc18wMDYkMjYiLCJ1bmNhdWdodF9leG4kMCIsImFyZzFfMDY4IiwiYXJnMF8wNjciLCJyZXMwXzA2OSIsInJlczFfMDcwIiwibnVtX3BlbmRpbmdfam9icyIsImxhc3RfY3ljbGVfbnVtX2pvYnMkMSIsInVub3JkZXJlZF9pc19zdWJsaXN0Iiwic21hbGwiLCJsYXJnZSIsIngiLCJsJDAiLCJ5IiwibCIsImNoZWNrX2hvb2tfdGFibGVfaW52YXJpYW50IiwidGFibGUiLCJsaXN0IiwiZmllbGQiLCJxIiwiZnJlZV9qb2IiLCJqb2JfcXVldWUiLCJmJDAiLCJlbnF1ZXVlX2pvYiIsImNyZWF0ZSQzIiwiaXNfZGVhZCIsInNldF9jaGVja19hY2Nlc3MkMCIsInRfcmVmIiwiY2hlY2tfYWNjZXNzJDEiLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0JDEiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSIsInRtcF9jb250ZXh0Iiwib2xkX2NvbnRleHQiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IiwiY3JlYXRlX2pvYiIsImdvdF91bmNhdWdodF9leG4iLCJhcmcxXzA3MiIsImFyZzBfMDcxIiwicmVzMF8wNzMiLCJyZXMxXzA3NCIsInN0YXJ0X2N5Y2xlIiwibWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSIsImUiLCJlJDAiLCJzdGFiaWxpemUiLCJjcmVhdGVfdGltZV9zb3VyY2UiLCJvcHQiLCJzdGgiLCJ0aW1pbmdfd2hlZWxfY29uZmlnIiwid2FsbF9jbG9jayIsInNldF9wcmV2IiwicGFyYW0iLCJzZXRfbmV4dCIsInJ1biIsImNyZWF0ZTIiLCJydW4xIiwiZXhlY3V0aW9uX2NvbnRleHQxIiwicnVuMiIsImV4ZWN1dGlvbl9jb250ZXh0MiIsInNjaGVkdWxlX2pvYnMiLCJhZGQiLCJvZl9saXN0IiwiZmlyc3QiLCJsJDEiLCJsJDIiLCJydW4kMCIsInByZXYkMCIsImFjYyQwIiwiY2VsbF9vZl9oYW5kbGVyIiwiaW5kaXIiLCJzcXVhc2giLCJ0JDMiLCJ0JDQiLCJpbmRpciQxIiwidCQ1IiwiaW5kaXIkMCIsInQkMiIsImFfaW52YXJpYW50IiwiaGFuZGxlciIsInBlZWsiLCJ2YWx1ZSIsImlmX2VtcHR5X3RoZW5fZmFpbHdpdGgiLCJpc19lbXB0eSIsImlzX2Z1bGwiLCJmaWxsIiwicmVtb3ZlX2hhbmRsZXIiLCJhZGRfaGFuZGxlciIsImhhbmRsZXIkMSIsImhhbmRsZXIkMiIsInJ1biQxIiwiaGFuZGxlciQwIiwiaGFzX2hhbmRsZXJzIiwidXBvbiIsInVwb24kMCIsImNvbm5lY3QiLCJiaW5kX3Jlc3VsdCIsImJpbmRfcmhzIiwiYmluZF9yZXN1bHQkMCIsIml2YXIiLCJiaW5kX3Joc19jb250ZW50cyIsIml2YXIkMCIsImxhc3QxIiwibGFzdDIiLCJoYW5kbGVyMSIsImV4ZWN1dGlvbl9jb250ZXh0MiQwIiwicnVuMiQwIiwiaGFuZGxlcjEkMCIsInYkMCIsIm9mX2l2YXIiLCJpbnZhcmlhbnRfYSIsInJldHVybiQwIiwiaXNfZGV0ZXJtaW5lZCIsImJpbmQiLCJoIiwicmVhZCIsImZpbGxfaWZfZW1wdHkiLCJ0b19iaW5hYmxlIiwib2ZfYmluYWJsZSIsInNleHBfb2ZfaG93Iiwidl8wMDEiLCJuZXZlciIsInJldHVybiQxIiwicmV0dXJuJDIiLCJyZXR1cm4kMyIsInVuaXQiLCJib3RoJDAiLCJhMSIsImEyIiwiZG9uX3Rfd2FpdF9mb3IiLCJmMiIsImYxIiwicHJvY2VzcyIsInJlc3QiLCJjaG9pY2UiLCJlbmFibGVkIiwiY2hvaWNlcyIsInVucmVnaXN0ZXJzIiwicmVhZHkiLCJjaG9vc2VfcmVzdWx0IiwiY2hvaWNlcyQwIiwiY2hvaWNlcyQxIiwiY2hvb3NlIiwiYW55X2YiLCJ0cyIsImFueSIsImFueV91bml0IiwiZm9yJDAiLCJkbyQwIiwibG9vcCIsInJlcGVhdF91bnRpbF9maW5pc2hlZCIsInN0YXRlIiwiZmluaXNoZWQiLCJmb3JldmVyIiwiYiIsInhzIiwic2VxbWFwIiwiYnMiLCJhbGwiLCJkcyIsImFsbF91bml0IiwiZCIsIm9rIiwib2ZfYV8wMDUiLCJ4XzAwNiIsImFyZzBfMDAyIiwicmVzMF8wMDMiLCJ4XzAwNyIsImNvbGxlY3QiLCJpc19jbG9zZWQiLCJmaWxsX2V4biIsImNsb3NlX2V4biIsImNsb3NlX2lmX29wZW4iLCJleHRlbmQiLCJkZWZlcnJlZDAiLCJkZWZlcnJlZDEiLCJpbXBvcnQwIiwiZXJyb3IiLCJkZXRhY2giLCJkZXRhY2hfYW5kX2l0ZXJfZXJyb3JzIiwiaGFuZGxlcl9zdGF0ZV9yZWYiLCJydW5fZiIsImJhZ19lbHQiLCJpbm5lcl9leG4kMCIsImlubmVyX2V4biIsImRldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSIsInRhaWwiLCJnZXRfbmV4dF9lcnJvciIsImRldGFjaF9hbmRfZ2V0X25leHRfZXJyb3IiLCJleHRyYWN0X2V4biIsImNvbHVtbiIsIm1vbml0b3IkMSIsIm5hbWUkMSIsImJhY2t0cmFjZSQwIiwiYmFja3RyYWNlJDEiLCJyZXN0JDAiLCJyZXN0JDEiLCJ0MyIsInJlc3QkMiIsInJlc3QkMyIsInRyYWNlcyIsInJlc3QkNCIsInQxJDAiLCJyZXN0JDUiLCJ0MiQwIiwicmVzdCQ2IiwidDIkMSIsImJhY2t0cmFjZSQyIiwibGlzdF9pZl9ub3RfZW1wdHkiLCJtYXRjaCQyIiwibWF0Y2gkMyIsImV4dHJhY3RfZXhuJDAiLCJhcmcxXzAwNCIsImFyZzBfMDAzIiwiYXJnMV8wMDgiLCJhcmcwXzAwNyIsInJlczBfMDA5IiwicmVzMV8wMTAiLCJ3aXRoaW5fY29udGV4dCIsImNvbnRleHQiLCJ3aXRoaW5fZ2VuIiwid2l0aGluIiwid2l0aGluX3YiLCJ3aXRoaW4kMCIsInNjaGVkdWxlX3dpdGhfZGF0YSIsIndvcmsiLCJ1cG9uX3dvcmtfZmlsbF9pIiwic2NoZWR1bGUkMCIsInByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0IiwicHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQkMCIsImNhbGxfYW5kX2ZpbGwiLCJzdHJlYW1faXRlciIsInN0cmVhbSIsImV4bnMiLCJmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm8iLCJyZXN1bHRfZmlsbGVyIiwiaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IiwidHJ5X3dpdGhfbG9nX2V4biIsInRyeV93aXRoIiwic3RoJDAiLCJkb19leHRyYWN0X2V4biIsInN0aCQxIiwic3RoJDIiLCJoYW5kbGVfZXhuIiwicmVzIiwidHJ5X3dpdGhfb3JfZXJyb3IiLCJ0cnlfd2l0aF9qb2luX29yX2Vycm9yIiwicHJvdGVjdCIsImZpbmFsbHkkMCIsImZyIiwiciQwIiwiZmluYWxseV9leG4iLCJoYW5kbGVfZXJyb3JzIiwiY2F0Y2hfc3RyZWFtIiwiY2F0Y2gkMCIsImNhdGNoX2Vycm9yIiwiZGVwdGgiLCJuJDAiLCJmaXJzdF9leG4iLCJsb29wJDAiLCJsb29wX25leHQiLCJsb29wX25leHQkMCIsImNsb3NlZCIsInVuZm9sZCIsImNvcHlfdG9fdGFpbCIsImFwcGVuZCIsImZpbHRlcl9kZXByZWNhdGVkIiwiZmlsdGVyX21hcF9kZXByZWNhdGVkIiwiZmlyc3RfbiIsImF2YWlsYWJsZV9ub3ciLCJzcGxpdCIsInN0b3AiLCJyZWFzb25fZm9yX3N0b3BwaW5nIiwicHJlZml4IiwiZmluaXNoIiwibyIsImZpbmQiLCJmb3VuZCIsInVuZ3JvdXAiLCJpbnRlcmxlYXZlIiwibnVtX29wZW4iLCJjbG9zZSIsIm91dGVyX2Nsb3NlZCIsInRha2VfdW50aWwiLCJ6IiwiaXRlcl9kdXJhYmx5IiwiaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmQiLCJpdGVyX2R1cmFibHkkMCIsIm9mX2Z1biIsInNldF9pdmFyIiwiaGFzX2FueV93YWl0ZXJzIiwic2V0X2hhc19hbnlfd2FpdGVycyIsImhhc19hbnlfd2FpdGVycyQwIiwicmVwciIsIml2YXJfZnVuIiwiaGFzX2FueV93YWl0ZXJzX2Z1biIsIm9mX2FfMDAxIiwiaGFzX2FueV93YWl0ZXJzXzAwMyIsIml2YXJfMDA1IiwiYXJnXzAwNiIsImJuZHNfMDAyIiwiYXJnXzAwNCIsImJuZHNfMDAyJDAiLCJicm9hZGNhc3QiLCJ3YWl0IiwiaGFzX2FueV93YWl0ZXJzJDEiLCJ4XzAwMyIsImFkdmFuY2VfZGlyZWN0bHlfYnkiLCJieSIsIndhaXRfZm9yIiwicnVuX3F1ZXVlZF9hbGFybXMiLCJ3YWxrX2FsYXJtcyIsIm1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCIsInF1ZXVlZF9hbGFybXNfcmFuIiwibmV4dF9hbGFybV9maXJlc19hdCQwIiwiYWR2YW5jZV9ieV9hbGFybXNfYnkiLCJzcGFuX3RvX3RpbWUiLCJydW5fYXRfaW50ZXJuYWwiLCJ0aW1lIiwicmVtb3ZlX2FsYXJtIiwib2ZfYV8wMDgiLCJvZl9oXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJhcmcwXzAxMiIsInJlczBfMDEzIiwic2V0X3NjaGVkdWxlZF9hdCIsIm51bV9maXJlc190b19za2lwIiwic2V0X251bV9maXJlc190b19za2lwIiwiZmlyZWQiLCJzY2hlZHVsZWRfYXQkMCIsIm51bV9maXJlc190b19za2lwJDAiLCJmaXJlZCQwIiwib2ZfYV8wMTYiLCJvZl9oXzAxNyIsImFsYXJtXzAxOSIsImZpcmVkXzAyMyIsIm51bV9maXJlc190b19za2lwXzAyNSIsInNjaGVkdWxlZF9hdF8wMjciLCJ0aW1lX3NvdXJjZV8wMjkiLCJibmRzXzAxOCIsImJuZHNfMDE4JDAiLCJhcmdfMDI2IiwiYm5kc18wMTgkMSIsImFyZ18wMjQiLCJibmRzXzAxOCQyIiwiYm5kc18wMTgkMyIsImJuZHNfMDE4JDQiLCJzZXhwX29mX3RfdW5pdCIsInhfMDMxIiwiZmlyZWQkMSIsImludmFyaWFudF9oIiwic2NoZWR1bGVkX2F0X2Z1biIsImFfMDMzIiwiYl8wMzQiLCJudW1fZmlyZXNfdG9fc2tpcF9mdW4iLCJmaXJlZF9mdW4iLCJ4XzAzMiIsIm9mX2FfMDM1Iiwib2ZfaF8wMzYiLCJhcmcwXzAzNyIsInJlczBfMDM4IiwiYXJnMF8wMzkiLCJyZXMwXzA0MCIsImFyZzBfMDQxIiwicmVzMF8wNDIiLCJvZl9hXzA0NSIsIm9mX2hfMDQ2IiwiYXJnMF8wNDciLCJyZXMwXzA0OCIsImFyZzBfMDQ5IiwicmVzMF8wNTAiLCJ4XzA1MyIsImEkMCIsIm9mX2FfMDU0Iiwib2ZfaF8wNTUiLCJhcmcwXzA1NiIsInJlczBfMDU3IiwiYXJnMF8wNTgiLCJyZXMwXzA1OSIsImFyZzFfMDYzIiwiYXJnMF8wNjIiLCJyZXMwXzA2NCIsInJlczFfMDY1IiwiaXNfaW5fdGltaW5nX3doZWVsIiwiYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlIiwicnVuX2F0JDAiLCJydW5fYWZ0ZXIkMCIsImF0X3RpbWVzIiwibmV4dF90aW1lIiwiYXRfdmFyeWluZ19pbnRlcnZhbHMiLCJjb21wdXRlX3NwYW4iLCJzdGFydCQwIiwiaW1tZWRpYXRlbHkiLCJydW5fcmVwZWF0ZWRseSIsImNvbnRpbnVlX29uX2Vycm9yIiwic3RvcCQwIiwic3RvcCQxIiwiY29udGludWVfdHJ5X3dpdGgiLCJjb250aW51ZV9mIiwiYmFzZSIsIm9yX2Vycm9yIiwiZXZlcnkiLCJldmVyeSQwIiwic3RhcnQkMSIsInJ1bl9hdF9pbnRlcnZhbHMkMCIsIndpdGhfdGltZW91dCIsInRpbWVvdXQiLCJvZl9zeW5jaHJvbm91cyIsInRvX3N5bmNocm9ub3VzIiwib2ZfYV8wMDIiLCJyZXMwXzAwNCIsImxlbmd0aF8wMDYiLCJibmRzXzAwNSIsImNyZWF0ZV9jb3VudGVyIiwicHVzaCIsInBvcF9leG4iLCJzZXhwX29mX291dGNvbWUiLCJ2XzAwMiIsInZfMDAzIiwiY2xlYW5lZCIsIm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQiLCJzZXRfbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCIsImNhcGFjaXR5X2F2YWlsYWJsZSIsInNldF9jYXBhY2l0eV9hdmFpbGFibGUiLCJudW1fam9ic19ydW5uaW5nIiwic2V0X251bV9qb2JzX3J1bm5pbmciLCJqb2JzX3dhaXRpbmdfdG9fc3RhcnQiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UiLCJtYXhfY29uY3VycmVudF9qb2JzIiwiY2xlYW5lZCQwIiwibnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCQwIiwiY2FwYWNpdHlfYXZhaWxhYmxlJDAiLCJudW1fam9ic19ydW5uaW5nJDAiLCJqb2JzX3dhaXRpbmdfdG9fc3RhcnQkMCIsImpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSQwIiwibWF4X2NvbmN1cnJlbnRfam9icyQwIiwib2ZfYV8wMTEiLCJqb2JzX3dhaXRpbmdfdG9fc3RhcnRfMDE5Iiwiam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXzAxNyIsIm1heF9jb25jdXJyZW50X2pvYnNfMDE1IiwiY29udGludWVfb25fZXJyb3JfMDEzIiwibnVtX2pvYnNfcnVubmluZ18wMjEiLCJjYXBhY2l0eV9hdmFpbGFibGVfMDIzIiwiaXNfZGVhZF8wMjUiLCJjbGVhbnNfMDI3IiwibnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF8wMjkiLCJjbGVhbmVkXzAzMSIsImJuZHNfMDEyIiwiYm5kc18wMTIkMCIsImJuZHNfMDEyJDEiLCJibmRzXzAxMiQyIiwiYm5kc18wMTIkMyIsImJuZHNfMDEyJDQiLCJvdXRjb21lXzAwOSIsInN0YXJ0XzAwNiIsImJuZHNfMDA1JDAiLCJ2XzAwOCIsImJuZHNfMDA1JDEiLCJibmRzXzAxMiQ1IiwiYm5kc18wMTIkNiIsImJuZHNfMDEyJDciLCJibmRzXzAxMiQ4IiwieF8wMzMiLCJvZl9hXzAzNCIsIm9mX2tpbmRfMDM1IiwieF8wMzYiLCJudW1fam9ic193YWl0aW5nX3RvX3N0YXJ0IiwiY2xlYW5fcmVzb3VyY2UiLCJraWxsIiwiYXRfa2lsbCIsImNsZWFuZWQkMSIsInN0YXJ0X2pvYiIsImpvYl9yZXNvdXJjZSIsImpvYl9yZXNvdXJjZXMiLCJjcmVhdGVfd2l0aCIsIm91dGNvbWUiLCJpbnRlcm5hbF9qb2IiLCJoYW5kbGVfZW5xdWV1ZV9yZXN1bHQiLCJlbnF1ZXVlJDAiLCJlbnF1ZXVlX2V4Y2x1c2l2ZSIsImRvbmUiLCJmX3BsYWNlaG9sZGVyIiwic2xvdCIsIm1vbmFkX3NlcXVlbmNlX2hvdyIsImhvdyIsIm1vbmFkX3NlcXVlbmNlX2hvdzIiLCJwcmlvcl9qb2JzX2RvbmUiLCJhbGxfZHVtbXlfam9ic19ydW5uaW5nIiwiZHVtbXlfam9ic19ydW5uaW5nIiwiY2FwYWNpdHlfYXZhaWxhYmxlJDEiLCJoYXNfdXBjb21pbmdfZXZlbnQiLCJuZXh0X3VwY29taW5nX2V2ZW50IiwibmV4dF91cGNvbWluZ19ldmVudF9leG4iLCJldmVudF9wcmVjaXNpb24iLCJhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayIsImhhbmRsZSIsImFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayIsInJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayIsImxzdCIsImxzdCQwIiwicmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfIiwicmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4IiwibWFwX2N5Y2xlX3RpbWVzIiwibG9uZ19jeWNsZXMiLCJhdF9sZWFzdCIsImN5Y2xlX251bV9qb2JzIiwiaW50JDAiLCJ0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2oiLCJjcmVhdGVfYWxhcm0iLCJhZGRfZmluYWxpemVyIiwiaGVhcF9ibG9jayIsImZpbmFsaXplciIsImFkZF9maW5hbGl6ZXJfZXhuIiwiYWRkX2ZpbmFsaXplcl9sYXN0IiwiYWRkX2ZpbmFsaXplcl9sYXN0X2V4biIsImZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kIiwicnVuX2N5Y2xlIiwibnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlIiwiY3ljbGVfdGltZSIsInJlczFfMDA0IiwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpIiwibWFrZV9hc3luY191bnVzYWJsZSIsInJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzIiwibWF5X3JldHVybl9pbW1lZGlhdGVseSIsInlpZWxkX2V2ZXJ5IiwiY291bnRfdW50aWxfeWllbGQiLCJ0aGlzX2N5Y2xlX3RpbWUiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nIiwieWllbGRfdGhlbl9ydW4iLCJ3b3JrZXIiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDAiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDEiLCJidCIsInF1ZXVlIiwicnVubmluZyIsInRocmVhZF9zYWZlX2VucXVldWVfam9iIiwiY3ljbGVfc3RhcnRfbnMiLCJjeWNsZV90aW1lc19ucyIsImN5Y2xlX3RpbWVzIiwiZXZlbnRfcHJlY2lzaW9uX25zIiwiYm9vbCIsImFkZF9ldmVyeV9jeWNsZV9zdGFydF9ob29rJDAiLCJhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2skMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rXyQwIiwicmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4JDAiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0JDAiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSQwIiwiY29tcGFyZSIsImNtcF9hIiwiYV8wMDEiLCJiXzAwMiIsInJpZ2h0XzAwNCIsImxlZnRfMDAzIiwidl8wMDYiLCJmb2xkaSIsInNlcW1hcGkiLCJpdGVyaSIsIm1hcGkiLCJmaWx0ZXJpIiwiYm9vbHMiLCJmaWx0ZXJfbWFwaSIsImNvbmNhdF9tYXBpIiwiZmluZF9tYXBpIiwiYXV4IiwiZmluZGkiLCJlbHQiLCJleGlzdHNpIiwiZm9yX2FsbGkiLCJmaWx0ZXJfbWFwIiwiZmlsdGVyIiwiY29uY2F0X21hcCIsImZpbmRfbWFwIiwidGwiLCJoZCIsImNoYW5nZSIsInVwZGF0ZSIsIml0ZXJfa2V5cyIsImFsaXN0IiwiYWxpc3RfaW5faW5jcmVhc2luZ19rZXlfb3JkZXIiLCJmb2xkX3JpZ2h0IiwiYWxpc3RfaW5fZGVjcmVhc2luZ19rZXlfb3JkZXIiLCJzZXF1ZW5jZSIsImpvYl9tYXAiLCJmaWx0ZXJfa2V5cyIsIm1lcmdlIiwidGh1bmsiLCJyZXJhaXNlIiwiZ2VuZXJhbCIsImhhc2hhYmxlIiwiY29tYmluZSIsImVyciIsImZhaWwiLCJmYWlsZiIsImZvcm1hdCIsIm1hcF9lcnJvciIsImlnbm9yZV9tIiwiam9pbiIsInN5bWJvbF9iaW5kIiwiYXBwbHkiLCJlMSIsImUyIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsIm9rX2V4biIsIm9mX2V4biIsIm9mX2V4bl9yZXN1bHQiLCJtc2ciLCJzZXhwX29mIiwiZXJyb3JfcyIsImVycm9yX3N0cmluZyIsImVycm9yZiIsInRhZyIsInRhZ19zIiwidGFnX3NfbGF6eSIsInRhZ19hcmciLCJ1bmltcGxlbWVudGVkIiwiY29tYmluZV9lcnJvcnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiZmlsdGVyX29rX2F0X2xlYXN0X29uZSIsImZpbmRfbWFwX29rIiwiY3VycmVudF9lcnJvciIsImVycm9ycyQwIiwib2tfdW5pdCIsInRyeV93aXRoJDAiLCJ0cnlfd2l0aF9qb2luIiwic3RhdGUkMCIsImZvbGRfbWFwaSIsIm1hcGlfZiIsImZvbGRfZiIsInRocm90dGxlIiwiYyIsImMkMSIsImMkMCIsImkkMCIsImFjY3VtIiwibWF5YmVfdiIsInNob3dfZGVidWdfbWVzc2FnZXMiLCJjaGVja19pbnZhcmlhbnQiLCJ4XzAwNCIsInZhbHVlc19yZWFkIiwic2V0X3ZhbHVlc19yZWFkIiwidmFsdWVzX3JlYWQkMCIsInBpcGVfaWRfMDA5IiwidmFsdWVzX3JlYWRfMDExIiwiYm5kc18wMDgiLCJhcmdfMDE1IiwiYm5kc18wMDgkMCIsInZfMDEzIiwiYm5kc18wMDgkMSIsImJuZHNfMDA4JDIiLCJ2YWx1ZXNfc2VudF9kb3duc3RyZWFtIiwidmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1Iiwid2hlbl9zZW50X2Rvd25zdHJlYW0iLCJjb25zdW1lciIsIndhbnRzIiwiY29uc3VtZXIkMCIsIndhbnRzJDAiLCJvZl9hXzAyOSIsImNvbnN1bWVyXzAzMyIsIndhbnRzXzAzMSIsImJuZHNfMDMwIiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIxIiwidl8wMjAiLCJyZXMwXzAyMiIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInZfMDIzIiwicmVzMV8wMjciLCJibmRzXzAzMCQwIiwiZmlsbF93aXRoX2VvZiIsImkkMSIsImZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQiLCJyZWFkeV8wMzkiLCJmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXzAzNyIsImJuZHNfMDM2IiwiYm5kc18wMzYkMCIsImJuZHNfMDM2JDEiLCJjb25zdW1lcnMiLCJzZXRfY29uc3VtZXJzIiwiYmxvY2tlZF9yZWFkcyIsImJsb2NrZWRfZmx1c2hlcyIsInB1c2hiYWNrIiwic2V0X3B1c2hiYWNrIiwic2l6ZV9idWRnZXQiLCJzZXRfc2l6ZV9idWRnZXQiLCJjb25zdW1lcnMkMCIsImJsb2NrZWRfcmVhZHMkMCIsImJsb2NrZWRfZmx1c2hlcyQwIiwicHVzaGJhY2skMCIsInNpemVfYnVkZ2V0JDAiLCJzZXhwX29mX3BpcGUiLCJvZl9hXzA0MSIsIm9mX3BoYW50b21fMDQyIiwiaWRfMDQ0IiwiaW5mb18wNDYiLCJidWZmZXJfMDUwIiwic2l6ZV9idWRnZXRfMDUyIiwicHVzaGJhY2tfMDU0IiwibnVtX3ZhbHVlc19yZWFkXzA1NiIsInJlYWRfY2xvc2VkXzA2NCIsImNsb3NlZF8wNjIiLCJibG9ja2VkX3JlYWRzXzA2MCIsImJsb2NrZWRfZmx1c2hlc18wNTgiLCJjb25zdW1lcnNfMDY2IiwidXBzdHJlYW1fZmx1c2hlZHNfMDY4IiwiYm5kc18wNDMiLCJhcmdfMDY5IiwiYm5kc18wNDMkMCIsImFyZ18wNjciLCJibmRzXzA0MyQxIiwiYXJnXzA2NSIsImJuZHNfMDQzJDIiLCJhcmdfMDYzIiwiYm5kc18wNDMkMyIsImFyZ18wNjEiLCJibmRzXzA0MyQ0IiwiYXJnXzA1OSIsImJuZHNfMDQzJDUiLCJhcmdfMDU3IiwiYm5kc18wNDMkNiIsImFyZ18wNTUiLCJibmRzXzA0MyQ3IiwiYXJnXzA1MyIsImJuZHNfMDQzJDgiLCJhcmdfMDUxIiwiYm5kc18wNDMkOSIsInZfMDQ3IiwiYXJnXzA0OSIsImJuZF8wNDgiLCJibmRzXzA0MyQxMCIsImFyZ18wNDUiLCJibmRzXzA0MyQxMSIsImhhc2giLCJpc19yZWFkX2Nsb3NlZCIsInB1c2hiYWNrJDEiLCJ4XzA3MyIsInhfMDM1Iiwic2V4cF9vZl9waGFudG9tIiwib2ZfYV8wNzQiLCJ4XzA3NSIsInNleHBfb2ZfcGhhbnRvbSQwIiwib2ZfYV8wNzYiLCJ4XzA3NyIsImlkX3JlZiIsImluaXRpYWxfYnVmZmVyIiwidmFsaWRhdGVfc2l6ZV9idWRnZXQiLCJ1cGRhdGVfcHVzaGJhY2siLCJ4XzA3OCIsImNsb3NlX3JlYWQiLCJ4XzA3OSIsImZsdXNoIiwiY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjIiwidyIsImNyZWF0ZV9yZWFkZXIiLCJjbG9zZV9vbl9leGNlcHRpb24iLCJjcmVhdGVfd3JpdGVyIiwidmFsdWVzX3dlcmVfcmVhZCIsImZsdXNoX3Jlc3VsdCIsImNvbnN1bWVfb25lIiwiY29uc3VtZSIsIm1heF9xdWV1ZV9sZW5ndGgiLCJyZXN1bHQkMCIsInNldF9zaXplX2J1ZGdldCQwIiwic3RhcnRfd3JpdGUiLCJ4XzA4MSIsInhfMDgwIiwiZmluaXNoX3dyaXRlIiwiYmxvY2tlZF9yZWFkIiwiaXZhciQxIiwidHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayIsInRyYW5zZmVyX2luIiwid3JpdGUiLCJ3cml0ZV93aXRob3V0X3B1c2hiYWNrIiwid3JpdGUkMCIsIndyaXRlX3doZW5fcmVhZHkiLCJ3cml0ZV9pZl9vcGVuIiwid3JpdGVfd2l0aG91dF9wdXNoYmFja19pZl9vcGVuIiwiZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMiLCJ4XzA4MyIsInN0YXJ0X3JlYWQiLCJsYWJlbCIsInhfMDg0IiwiZ2VuX3JlYWRfbm93IiwiZ2V0X21heF9xdWV1ZV9sZW5ndGgiLCJtYXhfcXVldWVfbGVuZ3RoJDAiLCJyZWFkX25vdyIsInJlYWRfbm93JDAiLCJyZWFkJDAiLCJyZWFkX2V4biIsInZhbHVlc19hdmFpbGFibGUiLCJyZWFkX2Nob2ljZSIsInJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leCIsInJlYWRfZXhhY3RseSIsIm51bV92YWx1ZXMiLCJhbHJlYWR5X3JlYWQiLCJkb3duc3RyZWFtX2ZsdXNoZWQiLCJ1cHN0cmVhbV9mbHVzaGVkIiwiYWRkX2NvbnN1bWVyIiwicGlwZV9pZCIsImNvbnN1bWVyJDEiLCJ1cHN0cmVhbSIsImRvd25zdHJlYW0iLCJ1cHN0cmVhbV9mbHVzaGVkJDAiLCJhcmcwXzA4NSIsInJlczBfMDg2IiwiZm9sZF9nZW4iLCJmbHVzaGVkIiwiZm9sZF93aXRob3V0X3B1c2hiYWNrIiwid2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IiLCJpdGVyX3dpdGhvdXRfcHVzaGJhY2siLCJtYXhfaXRlcmF0aW9uc19wZXJfam9iIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQwIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQxIiwicmVtYWluaW5nIiwicmVtYWluaW5nJDAiLCJkcmFpbiIsImRyYWluX2FuZF9jb3VudCIsInN1bSIsInJlYWRfYWxsIiwiaW5wdXQiLCJ0b19zdHJlYW1fZGVwcmVjYXRlZCIsIm9mX3N0cmVhbV9kZXByZWNhdGVkIiwidHJhbnNmZXIiLCJuZXh0X2RlZmVycmVkIiwiY2hlY2tfY2xvc2VkX2xvb3BfbmV4dCIsInRyYW5zZmVyX2dlbiIsIm91dHB1dCIsImxpbmsiLCJ1bmxpbmsiLCJvdXRwdXRfY2xvc2VkIiwidHJhbnNmZXIkMCIsInRyYW5zZmVyX2lkIiwibWFwX2dlbiIsImNvbmNhdF9tYXBfbGlzdCIsImZpbHRlcl9tYXAkMCIsImZvbGRpbmdfZmlsdGVyX21hcCIsImZvbGRpbmdfZmlsdGVyX21hcCQwIiwieCQwIiwiZm9sZGluZ19tYXAiLCJhY2N1bSQwIiwiZW1wdHkiLCJzaW5nbGV0b24iLCJ3cml0ZXIiLCJyZWFkZXIiLCJzeW1ib2wiLCJvZl9zZXF1ZW5jZSIsInNlcXVlbmNlJDEiLCJzZXF1ZW5jZSQwIiwidG9fc2VxdWVuY2UiLCJpbnRlcmxlYXZlX3BpcGUiLCJpbnB1dHMiLCJvdXRwdXRfd3JpdGVyIiwibnVtX3BpcGVzX3JlbWFpbmluZyIsImRlY3JfbnVtX3BpcGVzX3JlbWFpbmluZyIsImhlYXAiLCJoYW5kbGVfcmVhZCIsImVvZl9vcl9vayIsInBvcF9oZWFwX2FuZF9sb29wIiwiaW5pdGlhbF9wdXNoIiwiY29uY2F0X3BpcGUiLCJmb3JrIiwicHVzaGJhY2tfdXNlcyIsIndyaXRlcjAiLCJyZWFkZXIwIiwid3JpdGVyMSIsInJlYWRlcjEiLCJzb21lX3JlYWRlcl93YXNfY2xvc2VkIiwic29tZV9yZWFkZXJfd2FzX2Nsb3NlZCQwIiwic3RpbGxfb3BlbiIsImZpbHRlcl9vcGVuIiwic3RpbGxfb3BlbiQwIiwic2V0X2luZm8iLCJ2YWx1ZV9hdmFpbGFibGUiLCJzZXRfdmFsdWVfYXZhaWxhYmxlIiwidGFrZW4iLCJjdXJyZW50X3ZhbHVlIiwidmFsdWVfYXZhaWxhYmxlJDAiLCJ0YWtlbiQwIiwiY3VycmVudF92YWx1ZSQwIiwidmFsdWVfYXZhaWxhYmxlJDEiLCJ2YWx1ZV9hdmFpbGFibGVfZnVuIiwiYV8wMTEiLCJiXzAxMiIsInRha2VuX2Z1biIsImN1cnJlbnRfdmFsdWVfZnVuIiwieF8wMTAiLCJ0YWtlbl8wMDYiLCJjdXJyZW50X3ZhbHVlXzAwNCIsInZhbHVlX2F2YWlsYWJsZV8wMDgiLCJibmRzXzAwMyIsImJuZHNfMDAzJDAiLCJibmRzXzAwMyQxIiwicGVla19leG4iLCJ4XzAxMyIsIm9mX2FfMDE0IiwieF8wMTUiLCJ4XzAxNyIsIndyaXRlX29ubHkiLCJ0YWtlX25vbmVtcHR5IiwidGFrZV9ub3dfZXhuIiwidGFrZV9ub3ciLCJ0YWtlIiwidXBkYXRlX2V4biIsInRha2VuJDEiLCJwdXQiLCJwaXBlX3doZW5fcmVhZHkiLCJjcmVhdGVfb3JfZXJyb3IiLCJ3YWl0X2V4biIsImZvcmNlIiwiZm9yY2VfZXhuIiwiYmluZCQxIiwiaXNfZm9yY2VkIiwid2FpdHNfMDAzIiwic2lnbmFsIiwiZGVsZXRlJDAiLCJjaGVja19maWVsZCQwIiwid2FpdF9mb3JfcHJldmlvdXMiLCJzeW1ib2wkMCIsInN5bWJvbCQxIl0sInNvdXJjZXMiOlsiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvdGltZV9ucy5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2RlYnVnLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvaW1wb3J0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvcHJpb3JpdHkubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC90eXBlcy5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL21vbml0b3IwLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvZXhlY3V0aW9uX2NvbnRleHQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9leHRlcm5hbF9qb2IubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9qb2JfcG9vbC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2pvYi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2pvYl9vcl9ldmVudC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL3NjaGVkdWxlcjAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9qb2JfcXVldWUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9zeW5jaHJvbm91c190aW1lX3NvdXJjZTAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIxLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvaXZhcjAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZDAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9pdmFyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvbW9uYWRfc2VxdWVuY2UubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZDEubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9zdGQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9pdmFyX2ZpbGxlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL3RhaWwubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9tb25pdG9yLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfc3RyZWFtLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvYnZhci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL3RpbWVfc291cmNlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvc3RhY2tfb3JfY291bnRlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL3Rocm90dGxlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvc3luY2hyb25vdXNfdGltZV9zb3VyY2UubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9jeWNsZV9ob29rLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfa2VybmVsX3NjaGVkdWxlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2Nsb2NrX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9jbG9ja19ucy5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX2FycmF5Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfbGlzdC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX21hcC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX21lbW8ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9vcHRpb24ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9yZXN1bHQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9vcl9lcnJvci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX3F1ZXVlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc2VxdWVuY2UubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9yZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvcGlwZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL212YXIubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9sYXp5X2RlZmVycmVkLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfY29uZGl0aW9uLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfZ2MubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2FzeW5jX2tlcm5lbC9hc3luY19pbnZhcmlhbnRfaW50Zi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2ludmFyaWFudC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFPSUEsTUFBTUMsR0FBRUM7SUFDRyxJQUFUQyxTQUFTLGdCQURMRixHQUFFQztJQUVzQjtNQUE3QixnQ0FGT0E7U0FFc0IscUJBRDVCQyxRQURJRjs7SUFFd0UsT0FENUVFO0dBQ2tGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGcEZIOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDRkFJLElBSWVDLFVBQUFDLFVBSkRDO0lBQ2hCO0tBR2lCQyxXQUN5QjtLQUR6QkMsV0FDUjtLQURRQyxxQ0FBQUQ7S0FBQUUsZ0RBQUFIO0tBQUFJLGlDQUFBUDtLQUFBUSxzQkFKRE4sV0FJQ0Q7S0FEZjtPQUFBOzs7aUJBQ2VJLGNBQUFDLGNBQUFDLGNBQUFDO0lBRGYsT0FBQTtHQUVxRTtZQUdyRUMsV0FBV0MsU0FBVSxPQVJyQlgsSUFRV1csdUJBQXlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BUnBEWDtPQVFBVTs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNGQUU7SUFDQUM7SUFDQUM7SUFDQUM7Ozs7WUFDQUMsUUFBUUM7SUFBdUIsVUFBQSw2QkFBdkJBO0lBQXVCLE9BQUE7R0FBNEI7R0FLL0MsSUFKWkMsMkJBSVksY0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BVlZOO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FFOzs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0NiSixTQUFBQyxpQkFBQSx5QkFHb0I7Ozs7O21DQUhwQkE7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDMkhNQyxRQUFRdkIsR0FBSSxPQUFKQSxFQUFLO1lBQ2J3QixRQUFReEIsR0FBSSxPQUFKQSxFQUFLO0dBVGI7SUFBQSxXQVNBd0IsU0FEQUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDdkhERTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSkRDOzs7Ozs7Ozs7Ozs7OztHQUlKLFNBVVlDLFdBQUFDLEdBQUEsT0FBQUEsS0FBVTtZQUFWQyxlQUFBRCxHQUFBRSxHQUFBRixPQUFBRSxZQUFVO1lBRFZDLGVBQUFILEdBQUEsT0FBQUEsS0FBYztZQUFkSSxtQkFBQUosR0FBQUUsR0FBQUYsT0FBQUUsWUFBYztZQURkRyxxQkFBQUwsR0FBQSxPQUFBQSxLQUFvQjtZQUFwQk0seUJBQUFOLEdBQUFFLEdBQUFGLE9BQUFFLFlBQW9CO1lBRnBCSyx3QkFBQVAsR0FBQSxPQUFBQSxLQUF1QjtZQUF2QlEsNEJBQUFSLEdBQUFFLEdBQUFGLE9BQUFFLFlBQXVCO1lBRnZCTyxXQUFBVCxHQUFBLE9BQUFBLEtBQVU7WUFBVlUsZUFBQVYsR0FBQUUsR0FBQUYsT0FBQUUsWUFBVTtZQURsQlMsR0FBQVgsR0FBQSxPQUFBQSxLQUFFO1lBREZZLEtBQUFaLEdBQUEsT0FBQUEsS0FBSTtZQURKYSxLQUFBYixHQUFBLE9BQUFBLEtBQUk7Z0JBU0lBLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUU7R0FBVTtHQUFWO0lBQUEsVUFBQUQ7SUFBQWE7MEJBQUEsU0FBVSx3QkFBVmY7Z0JBREFDLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUY7R0FBYztHQUFkO0lBQUEsVUFBQUk7SUFBQVc7O3VCQUFBLFNBQWM7OztPQUFkWjs7Z0JBREFILEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUE7R0FBb0I7R0FBcEI7SUFBQSxVQUFBTTtJQUFBVTs7dUJBQUEsU0FBb0I7OztPQUFwQlg7O2dCQUZBTCxHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUFBO0dBQXVCO0dBQXZCO0lBQUEsVUFBQVE7SUFBQVM7O3VCQUFBLFNBQXVCOzs7T0FBdkJWOztnQkFGQVAsR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQTtHQUFVO0dBQVY7SUFBQSxVQUFBVTtJQUFBUTswQkFBQSxTQUFVLHdCQUFWVDtnQkFEUlQsR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQTtHQUFFO0dBQUYsYUFBQW1CLDJCQUFBLFNBQUUsZ0JBQUZSO2dCQURBWCxHQUFBRTtJQUFBLFdBQUFGLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQUk7R0FBSjs7SUFBQW9CLDZCQUFBLFNBQUksa0JBQUpSO2dCQURBWixHQUFBRTtJQUFBLFdBQUFBLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQUk7R0FBSjs7SUFBQXFCLDZCQUFBLFNBQUksa0JBQUpSO1lBRENTO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxRQUFBLFdBQUFSLFVBQ0RGLFFBRENVO0tBQUFDO0tBQUFDO0tBQUEsVUFBQSxXQUFBVCxVQUVESixRQUZDWTtLQUFBRTtLQUFBQztLQUFBLFVBQUEsV0FBQVYsUUFHRE4sTUFIQ2U7S0FBQUU7S0FBQUM7S0FBQSxVQUFBLFdBQUFYLGdCQUlPUixjQUpQa0I7S0FBQUU7S0FBQUM7S0FBQTtPQUFBO1NBQUFaO1NBTU9WO1NBTlBxQjtLQUFBRTtLQUFBQztLQUFBO09BQUE7U0FBQWIsMEJBUU9aLHdCQVJQd0I7S0FBQUU7S0FBQUM7S0FBQSxVQUFBLFdBQUFkLG9CQVNPZCxrQkFUUDJCO0tBQUFFO0tBQUFDO0tBQUEsVUFBQSxXQUFBZixnQkFVT2hCLGNBVlA4QjtLQUFBRTtLQUFBQztJQUFBO3FCQUFBQzthQUFBO2NBQUFuQyxPQUFBLFdBQUFvQixVQUFBZTtjQUFBcEMsT0FBQSxXQUFBdUIsVUFBQWE7Y0FBQXJDLEtBQUEsV0FBQTBCLFFBQUFXO2NBQUF2QyxhQUFBLFdBQUE4QixnQkFBQVM7Y0FBQXpDO2dCQUFBLFdBQUFrQyw2QkFBQU87Y0FBQTNDLHVCQUFBLFdBQUFzQywwQkFBQUs7Y0FBQTdDLGlCQUFBLFdBQUEwQyxvQkFBQUc7Y0FBQWpELGFBQUEsV0FBQWdELGdCQUFBQzthQUFBO3FCQUFBbkM7cUJBQUFEO3FCQUFBRDtxQkFBQUY7cUJBQUFGO3FCQUFBRjtxQkFBQUY7cUJBQUFKO1lBQUM7WUFBRCtDOztZQUFBRztJQUFBcEM7SUFBQUQ7SUFBQUQ7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQUo7SUFBQTtZQUFBYztZQUFBRDtZQUFBRDtZQUFBRjtZQUFBRjtZQUFBRjtZQUFBRjtZQUFBSjtHQUFDO1lBQURtRDtJQUFBM0I7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQUEsZ0JBVU9oQjtLQVZQLE9BQUEsV0FBQWUsb0JBU09kO0tBVFAsT0FBQSxXQUFBYSwwQkFRT1o7S0FSUCxPQUFBLFdBQUFXLDZCQU1PVjtLQU5QLE9BQUEsV0FBQVMsZ0JBSU9SO0tBSlAsT0FBQSxXQUFBTyxRQUdETjtLQUhDLE9BQUEsV0FBQUssVUFFREo7SUFGQztZQUFBLFdBQUFHLFVBQ0RGOzs7Ozs7OztHQURFO1lBQUQ4QjtJQUFBNUI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQSxXQUFBUCxVQUNERjtJQURDLFdBQUFHLFVBRURKO0lBRkMsV0FBQUssUUFHRE47SUFIQyxXQUFBTyxnQkFJT1I7SUFKUCxXQUFBUyw2QkFNT1Y7SUFOUCxXQUFBVywwQkFRT1o7SUFSUCxXQUFBYSxvQkFTT2Q7SUFDQSxPQUFBLFdBVlBlLGdCQVVPaEI7R0FWTjtZQUFEc0M7SUFBQUM7SUFBQTlCO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUEsT0FVTzthQVZQQTthQUFBO2VBQUFEO2VBQUE7aUJBQUFEO2lCQUFBO21CQUFBRDttQkFBQTtxQkFBQUQ7cUJBQUE7dUJBQUFEO3VCQUFBO3lCQUFBRCxVQUFBLFdBQUFELFVBQUE4QixNQUNEaEMsU0FDQUQ7dUJBQ0FEO3FCQUNRRDttQkFFQUQ7aUJBRUFEO2VBQ0FEO2FBQ0FEO0dBVk47WUFBRHdDLFNBQUFDO0lBQUE7S0FBQSxXQUFBLFdBQUFBLFdBVU96QztLQVZQLFdBQUEsV0FBQXlDLFdBU094QztLQVRQLFdBQUEsV0FBQXdDLFdBUU92QztLQVJQLFdBQUEsV0FBQXVDLFdBTU90QztLQU5QLFdBQUEsV0FBQXNDLFdBSU9yQztLQUpQLFdBQUEsV0FBQXFDLFdBR0RwQztLQUhDLFdBQUEsV0FBQW9DLFdBRURuQztJQUZDLFdBQUEsV0FBQW1DLFdBQ0RsQztHQURFO1lBQURtQztJQUFBakM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQVAsVUFDREY7S0FEQyxjQUFBLFdBQUFHLFVBRURKO0tBRkMsY0FBQSxXQUFBSyxRQUdETjtLQUhDLGNBQUEsV0FBQU8sZ0JBSU9SO0tBSlA7O1VBQUEsV0FBQVMsNkJBTU9WOztLQU5QOztVQUFBLFdBQUFXLDBCQVFPWjs7S0FSUCxjQUFBLFdBQUFhLG9CQVNPZDtJQVRQLGNBVU8sV0FWUGUsZ0JBVU9oQjtHQVZOO1lBQUQyQztJQUFBbEM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQVAsVUFDREY7S0FEQyxlQUFBLFdBQUFHLFVBRURKO0tBRkMsZUFBQSxXQUFBSyxRQUdETjtLQUhDLGVBQUEsV0FBQU8sZ0JBSU9SO0tBSlA7O1VBQUEsV0FBQVMsNkJBTU9WO0tBTlA7ZUFBQSxXQUFBVywwQkFRT1o7S0FSUCxlQUFBLFdBQUFhLG9CQVNPZDtJQVRQLHFCQVVPLFdBVlBlLGdCQVVPaEI7R0FWTjtZQUFENEM7SUFBQW5DO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxXQUFBLFdBQUFBLGdCQVVPaEI7S0FWUCxXQUFBLFdBQUFlLG9CQVNPZDtLQVRQO1dBQUEsV0FBQWEsMEJBUU9aO0tBUlA7O1FBQUEsV0FBQVcsNkJBTU9WOztLQU5QLFdBQUEsV0FBQVMsZ0JBSU9SO0tBSlAsV0FBQSxXQUFBTyxRQUdETjtLQUhDLFdBQUEsV0FBQUssVUFFREo7SUFGQyxXQUFBLFdBQUFHLFVBQ0RGO0dBREU7WUFBRHNDO0lBQUFKO0lBQUFoQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBLFdBQUFQLFVBQ0RGLFFBRENrQyxRQUFBQTtJQUFBLFdBQUEvQixVQUVESixRQUZDbUMsUUFBQUE7SUFBQSxXQUFBOUIsUUFHRE4sTUFIQ29DLFFBQUFBO0lBQUEsV0FBQTdCLGdCQUlPUixjQUpQcUMsUUFBQUE7SUFBQTtNQUFBNUI7TUFNT1Y7TUFOUHNDO01BQUFBO0lBQUE7TUFBQTNCLDBCQVFPWix3QkFSUHVDLFFBQUFBO0lBQUEsV0FBQTFCLG9CQVNPZCxrQkFUUHdDLFFBQUFBO0lBVU8sT0FBQSxXQVZQekIsZ0JBVU9oQixjQVZQeUMsUUFBQUE7R0FBQztZQUFESztJQUFBTDtJQUFBRjtJQUFBOUI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7O1dBQUF5QjtXQUFBQTtXQUFBQTtXQUFBQTtXQUFBQTtZQUFBQTtZQUFBQTtJQUFBLE9BQUE7YUFBQXpCO2FBQUE7ZUFBQUQ7ZUFBQTtpQkFBQUQ7aUJBQUE7bUJBQUFEO21CQUFBO3FCQUFBRDtxQkFBQTt1QkFBQUQ7dUJBQUE7eUJBQUFEO3lCQUFBLFdBQUFELFVBQUE4QixNQUNEaEMsUUFEQ2tDLFFBQUFBO3lCQUVEbkM7eUJBRkNtQzs7dUJBR0RwQzt1QkFIQ29DOztxQkFJT3JDO3FCQUpQcUM7O21CQU1PdEM7bUJBTlBzQzs7aUJBUU92QztpQkFSUHVDOztlQVNPeEM7ZUFUUHdDOzthQVVPekM7YUFWUHlDOzs7WUFBQU07SUFBQU47SUFBQWhDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxNQUFBLFdBQUFQLFVBQ0RGLFFBRENrQyxRQUFBQTtLQUFBLFlBQUEsV0FBQS9CLFVBRURKLFFBRkNtQyxRQUFBQTtLQUFBLFlBQUEsV0FBQTlCLFFBR0ROLE1BSENvQyxRQUFBQTtLQUFBO2FBQUEsV0FBQTdCLGdCQUlPUixjQUpQcUMsUUFBQUE7S0FBQTs7VUFBQTtXQUFBNUI7V0FNT1Y7V0FOUHNDO1dBQUFBOztLQUFBOztVQUFBO1dBQUEzQjtXQVFPWjtXQVJQdUM7V0FBQUE7O0tBQUE7O1VBQUEsV0FBQTFCLG9CQVNPZCxrQkFUUHdDLFFBQUFBOztJQUFBO2NBVU8sV0FWUHpCLGdCQVVPaEIsY0FWUHlDLFFBQUFBOztHQUFDO1lBQURPO0lBQUFQO0lBQUFoQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsTUFBQSxXQUFBUCxVQUNERixRQURDa0MsUUFBQUE7S0FBQSxhQUFBLFdBQUEvQixVQUVESixRQUZDbUMsUUFBQUE7S0FBQSxhQUFBLFdBQUE5QixRQUdETixNQUhDb0MsUUFBQUE7S0FBQSxhQUFBLFdBQUE3QixnQkFJT1IsY0FKUHFDLFFBQUFBO0tBQUE7OztRQUFBO1VBQUE1QjtVQU1PVjtVQU5Qc0M7VUFBQUE7S0FBQTs7O1FBQUE7VUFBQTNCLDBCQVFPWix3QkFSUHVDLFFBQUFBO0tBQUE7O1VBQUEsV0FBQTFCLG9CQVNPZCxrQkFUUHdDLFFBQUFBO0lBQUE7O2NBVU8sV0FWUHpCLGdCQVVPaEIsY0FWUHlDLFFBQUFBO0dBQUM7WUFBRFE7SUFBQVI7SUFBQWhDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxVQUFBLFdBQUFBLGdCQVVPaEIsY0FWUHlDLFFBQUFBO0tBQUE7O1FBQUEsV0FBQTFCLG9CQVNPZCxrQkFUUHdDLFFBQUFBOztLQUFBOztRQUFBO1VBQUEzQiwwQkFRT1osd0JBUlB1QyxRQUFBQTs7S0FBQTs7UUFBQTtVQUFBNUI7VUFNT1Y7VUFOUHNDO1VBQUFBOztLQUFBO1dBQUEsV0FBQTdCLGdCQUlPUixjQUpQcUMsUUFBQUE7S0FBQSxVQUFBLFdBQUE5QixRQUdETixNQUhDb0MsUUFBQUE7S0FBQSxVQUFBLFdBQUEvQixVQUVESixRQUZDbUMsUUFBQUE7SUFBQSxXQUFBLFdBQUFoQyxVQUNERixRQURDa0MsUUFBQUE7R0FBQztZQUFEUztJQUFBVDtJQUFBaEM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE1BQUEsV0FBQUEsZ0JBVU9oQixjQVZQeUMsUUFBQUE7S0FBQSxNQUFBLFdBQUExQixvQkFTT2Qsa0JBVFB3QyxRQUFBQTtLQUFBO09BQUE7U0FBQTNCLDBCQVFPWix3QkFSUHVDLFFBQUFBO0tBQUE7T0FBQTtTQUFBNUI7U0FNT1Y7U0FOUHNDO1NBQUFBO0tBQUEsTUFBQSxXQUFBN0IsZ0JBSU9SLGNBSlBxQyxRQUFBQTtLQUFBLE1BQUEsV0FBQTlCLFFBR0ROLE1BSENvQyxRQUFBQTtLQUFBLE1BQUEsV0FBQS9CLFVBRURKLFFBRkNtQyxRQUFBQTtJQUFBO1lBQUEsV0FBQWhDLFVBQ0RGLFFBRENrQyxRQUFBQTs7Ozs7Ozs7R0FBQztZQUFEVTtJQUFBVjtJQUFBOUM7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQUo7SUFBQSxJQUFBbUUsV0FBQSw2QkFBQVg7SUFBQVcsY0FBQXpEO0lBQUF5RCxjQUFBM0Q7SUFBQTJELGNBQUE3RDtJQUFBNkQsY0FBQS9EO0lBQUErRCxjQUFBbkU7O0dBQUM7R0FBRDtJQUFBOztPQUFBNEQ7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7SUFBQTs7T0FBQXBFO09BVU9pQjtPQURBQztPQURBQztPQUZBQztPQUZBQztPQURSQztPQURBQztPQURBQztPQURDQztPQUFBMkI7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUU7T0FBQUU7T0FBQUM7T0FBQUM7O1lBY0RTLFlBQVkvRjtJQUNkLFlBRGNBO2dEQUFBQTs7S0FHUHdDO3dEQUFBQTs0Q0FIT3hDO0dBRzJEO1lBR3ZFZ0csYUFPRUM7SUFBSyxJQU5JakcsSUFNVGlHLEtBTldDO0lBQ2I7S0FBUyxJQURJQyxXQVBiSixZQU9XL0YsSUFBRWtHLEtBRWIsUUFGV2xHO21DQUd5QixPQUFBLDBCQUh2Qm1HO1NBQUZDLGdCQUFBcEcsSUFBQW9HLEtBQUVGLEtBQUFDOztHQU1HO1lBR2hCN0UsVUFBVXRCO0lBQVksSUFBaUJxRyxRQVZ2Q0wsYUFVVWhHO2dEQUE2QnFHOztHQUdqQyxJQUFKekU7R0FDSixTQUZFMEUsZUFDRTFFLGVBQUFBLEtBR0E7WUFHRjJFLG1CQUFvQi9ELE1BQU1nRSxNQUFNL0QsTUFBS2dFO0lBQzlCLElBQUxsRSxLQVJGK0Q7SUFTRixHQUY0QkU7U0FJbkJFLElBSm1CRjtRQUFNL0Q7VUFLakJrRSxJQUxpQmxFLGVBS1osMEJBRGJpRSxHQUNRQzs7Z0JBRFJEO1NBRkx6RDs7WUFGOEJSO1NBTW5CbUUsTUFObUJuRSxTQUU5QlEsU0FJZ0IsMEJBQUwyRDs7OztpQkFDa0NDO1Msc0RBQUFBOztNQUw3QzVELFNBS2MsMENBTmRWO0lBUUosR0FUdUNrRTtTQWV6QkssV0FmeUJMLHFCQWV6Qks7OztJQUxaO0tBREU5RyxRQVBBaUQsUUFGa0JULE1BQ2xCRCxZQWlCMEI7SUFLOUIsR0FsRUViO0tBa0VZLHdEQWRWMUIsR0FsQkZzQjtJQWdDWSxPQWRWdEI7R0FlSDtHQUdRLElBQVArRyxPQTNCQVI7Ozs7Ozs7O09BM0NBN0U7T0FjUUM7T0FBQUU7T0FEQUU7T0FBQUM7T0FEQUM7T0FBQUM7T0FGQUM7T0FBQUM7T0FGQUM7T0FBQUM7T0FEUkM7T0FEQUM7T0FEQUM7O09BYUFzRDtPQU1BQztPQVVBMUU7T0FFQWdGO09BT0FDO09BMkJBUTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDckVDdEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUFMLFNBSUl1RixrQkFBQXBGLEdBQUEsT0FBQUEsS0FBaUI7WUFEakJxRixjQUFBckYsR0FBQSxPQUFBQSxLQUFhO1lBRGJzRixTQUFBdEYsR0FBQSxPQUFBQSxLQUFRO1lBRFJ1RixRQUFBdkYsR0FBQSxPQUFBQSxLQUFPO2dCQUdQQSxHQUFBRSxHQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFFLEdBQWlCO0dBQWpCOztJQUFBc0Y7O3VCQUFBLFNBQWlCOzs7T0FBakJKOztnQkFEQXBGLEdBQUFFLEdBQUEsV0FBQUYsTUFBQUEsTUFBQUUsR0FBQUYsTUFBYTtHQUFiOztJQUFBeUY7O3VCQUFBLFNBQWE7OztPQUFiSjs7Z0JBREFyRixHQUFBRSxHQUFBLFdBQUFGLE1BQUFFLEdBQUFGLE1BQUFBLE1BQVE7R0FBUjs7SUFBQTBGOzBCQUFBLFNBQVEsc0JBQVJKO2dCQURBdEYsR0FBQUUsR0FBQSxXQUFBQSxHQUFBRixNQUFBQSxNQUFBQSxNQUFPO0dBQVA7O0lBQUEyRjswQkFBQSxTQUFPLHFCQUFQSjtZQURDakU7SUFBQXNFO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFoRTtJQUFBO0tBQUEsUUFBQSxXQUFBNkQsYUFDREQsV0FEQzVEO0tBQUFDO0tBQUFnRTtLQUFBLFVBQUEsV0FBQUgsY0FFREgsWUFGQzFEO0tBQUFFO0tBQUErRDtLQUFBLFVBQUEsV0FBQUgsbUJBR0RMLGlCQUhDdkQ7S0FBQUU7S0FBQThEO0tBQUE7T0FBQSxXQUFBSCx1QkFJRFAscUJBSkNwRDtLQUFBRTtLQUFBNkQ7SUFBQTtxQkFBQW5EO2FBQUE7Y0FBQXVDLFVBQUEsV0FBQVMsYUFBQWhEO2NBQUFzQyxXQUFBLFdBQUFXLGNBQUFqRDtjQUFBcUMsZ0JBQUEsV0FBQWEsbUJBQUFsRDtjQUFBb0Msb0JBQUEsV0FBQWUsdUJBQUFuRDthQUFBLFdBQUF1QyxTQUFBRCxVQUFBRCxlQUFBRDtZQUFDO1lBQUQ5QztHQUFDO1lBQURXLE9BQUFzQyxTQUFBRCxVQUFBRCxlQUFBRCxtQkFBQSxXQUFBRyxTQUFBRCxVQUFBRCxlQUFBRDtHQUFDO1lBQURsQztJQUFBMEMsYUFBQUMsY0FBQUMsbUJBQUFDO0lBQUE7S0FBQSxNQUFBLFdBQUFBLHVCQUlEUDtLQUpDLE1BQUEsV0FBQU0sbUJBR0RMO0tBSEMsTUFBQSxXQUFBSSxjQUVESDtJQUZDLFdBQUEsV0FBQUUsYUFDREQ7R0FERTtZQUFEeEM7SUFBQXlDLGFBQUFDLGNBQUFDLG1CQUFBQztJQUFBLFdBQUFILGFBQ0REO0lBREMsV0FBQUUsY0FFREg7SUFGQyxXQUFBSSxtQkFHREw7SUFDQSxPQUFBLFdBSkNNLHVCQUlEUDtHQUpFO1lBQURwQztJQUFBQyxNQUFBdUMsYUFBQUMsY0FBQUMsbUJBQUFDO0lBQUEsT0FJRDthQUpDQTthQUFBO2VBQUFEO2VBQUE7aUJBQUFEO2lCQUFBLFdBQUFELGFBQUF2QyxNQUNEc0M7aUJBQ0FEO2VBQ0FEO2FBQ0FEO0dBSkU7WUFBRGxDLFNBQUFDO0lBQUE7S0FBQSxVQUFBLFdBQUFBLFdBSURpQztLQUpDLFVBQUEsV0FBQWpDLFdBR0RrQztLQUhDLFVBQUEsV0FBQWxDLFdBRURtQztJQUZDLFdBQUEsV0FBQW5DLFdBQ0RvQztHQURFO1lBQURuQztJQUFBb0MsYUFBQUMsY0FBQUMsbUJBQUFDO0lBQUE7S0FBQSxNQUFBLFdBQUFILGFBQ0REO0tBREMsWUFBQSxXQUFBRSxjQUVESDtLQUZDLFlBQUEsV0FBQUksbUJBR0RMO0lBSEMsYUFJRCxXQUpDTSx1QkFJRFA7R0FKRTtZQUFEL0I7SUFBQW1DLGFBQUFDLGNBQUFDLG1CQUFBQztJQUFBO0tBQUEsTUFBQSxXQUFBSCxhQUNERDtLQURDLGFBQUEsV0FBQUUsY0FFREg7S0FGQyxhQUFBLFdBQUFJLG1CQUdETDtJQUhDLG1CQUlELFdBSkNNLHVCQUlEUDtHQUpFO1lBQUQ5QjtJQUFBa0MsYUFBQUMsY0FBQUMsbUJBQUFDO0lBQUE7S0FBQSxVQUFBLFdBQUFBLHVCQUlEUDtLQUpDLFVBQUEsV0FBQU0sbUJBR0RMO0tBSEMsVUFBQSxXQUFBSSxjQUVESDtJQUZDLFdBQUEsV0FBQUUsYUFDREQ7R0FERTtZQUFEaEM7SUFBQUo7SUFBQXFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUEsV0FBQUgsYUFDREQsV0FEQ3BDLFFBQUFBO0lBQUEsV0FBQXNDLGNBRURILFlBRkNuQyxRQUFBQTtJQUFBLFdBQUF1QyxtQkFHREwsaUJBSENsQyxRQUFBQTtJQUlELE9BQUE7YUFKQ3dDLHVCQUlEUCxxQkFKQ2pDLFFBQUFBO0dBQUM7WUFBREs7SUFBQUw7SUFBQUY7SUFBQXVDO0lBQUFDO0lBQUFDO0lBQUFDO2NBQUF4QyxpQkFBQUEsaUJBQUFBO0lBQUEsT0FBQTthQUFBd0M7YUFBQTtlQUFBRDtlQUFBO2lCQUFBRDtpQkFBQSxXQUFBRCxhQUFBdkMsTUFDRHNDLFdBRENwQyxRQUFBQTtpQkFFRG1DO2lCQUZDbkM7O2VBR0RrQztlQUhDbEM7O2FBSURpQzthQUpDakM7OztZQUFBTTtJQUFBTjtJQUFBcUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE1BQUEsV0FBQUgsYUFDREQsV0FEQ3BDLFFBQUFBO0tBQUEsWUFBQSxXQUFBc0MsY0FFREgsWUFGQ25DLFFBQUFBO0tBQUE7O1VBQUEsV0FBQXVDLG1CQUdETCxpQkFIQ2xDLFFBQUFBOztJQUFBO2NBSUQ7ZUFKQ3dDLHVCQUlEUCxxQkFKQ2pDLFFBQUFBOztHQUFDO1lBQURPO0lBQUFQO0lBQUFxQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsTUFBQSxXQUFBSCxhQUNERCxXQURDcEMsUUFBQUE7S0FBQSxhQUFBLFdBQUFzQyxjQUVESCxZQUZDbkMsUUFBQUE7S0FBQTs7VUFBQSxXQUFBdUMsbUJBR0RMLGlCQUhDbEMsUUFBQUE7SUFBQTs7Y0FJRDtlQUpDd0MsdUJBSURQLHFCQUpDakMsUUFBQUE7R0FBQztZQUFEUTtJQUFBUjtJQUFBcUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBOztRQUFBO1VBQUFBLHVCQUlEUCxxQkFKQ2pDLFFBQUFBOztLQUFBOztRQUFBLFdBQUF1QyxtQkFHREwsaUJBSENsQyxRQUFBQTs7S0FBQSxVQUFBLFdBQUFzQyxjQUVESCxZQUZDbkMsUUFBQUE7SUFBQSxXQUFBLFdBQUFxQyxhQUNERCxXQURDcEMsUUFBQUE7R0FBQztZQUFEUztJQUFBVDtJQUFBcUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBO09BQUE7U0FBQUEsdUJBSURQLHFCQUpDakMsUUFBQUE7S0FBQSxNQUFBLFdBQUF1QyxtQkFHREwsaUJBSENsQyxRQUFBQTtLQUFBLE1BQUEsV0FBQXNDLGNBRURILFlBRkNuQyxRQUFBQTtJQUFBO1lBQUEsV0FBQXFDLGFBQ0RELFdBRENwQyxRQUFBQTs7OztHQUFDO1lBQURVLHVCQUFBVjtJQUFBLDZCQUFBQTtJQUFBO0dBQUM7R0FBRDs7O09BQUFJO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO1lBQUx2RTtJQUFBO0tBSUkwRztLQURBQztLQURBQztLQURBQztLQUdBQyxVQUFBLHlDQUFBSjtLQUpKSyxnQ0FJSUQ7S0FEQUUsVUFBQSw2QkFBQUw7S0FISk0sa0NBR0lELGVBSEpEO0tBRUlHLFVBQUEscUNBQUFOO0tBRkpPLGtDQUVJRCxlQUZKRDtLQUNJRyxVQUFBLHNDQUFBUDtLQURKUSxrQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQU00QjtZQUV4QkMsaUJBQW9CLFNBQUU7R0FHeEI7SUFERTdCOzs7Ozs7WUFRQThCLFlBQWExQixTQUFTRCxVQUFVRCxlQUFjakg7SUFDaEQ7S0FBSXVILFlBQVUsNEJBRENKLFNBQWlDbkg7S0FFaEQsTUFGZ0RBO0tBSTlCLE1BQUEsNEJBSmdCaUgsZUFBY2pIO0lBRWhEO1lBREl1SDtZQUVTLDRCQUhXTCxVQUF3QmxIOzs7R0FNL0M7WUFHQzhJLFdBQVc5SSxHQUFFK0k7SUFBTSxPQUFBLDhCQUFSL0ksTUFBRStJO0dBQXVDO1lBRXBEQyxXQUFXaEosR0FBRStJLEtBQUlFO0lBQ25CLFVBRGFqSjt3QkFDNkQsT0FEdkRpSixLQUMyRDtJQUFyRCxVQUFBLDhCQURaakosTUFBRStJO0lBQ2YsV0FEYS9JLE1BQUFBO0dBQ29FO1lBRy9Fa0osaUJBQWlCbEo7SUFDbkIsVUFEbUJBLE1BQ1UsVUFBQTtJQUE3QixXQURtQkEsTUFBQUEsTUFBQUE7R0FDbUQ7Ozs7Ozs7O09BOUJwRWdIO09BREFDO09BREFDO09BREFDOztRQURDMUY7UUFJRDJGO1FBREFDO1FBREFDO1FBREFDO1FBREN2QztRQUFBOUI7UUFBQTJCO1FBQUFDO1FBQUFDO1FBQUFLO1FBQUFDO1FBQUFDO1FBQUFKOztPQUFMNUQ7T0FRSXNIO09BRUE3QjtPQVFBOEI7T0FTQUM7T0FFQUU7T0FJQUU7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ2pDQTVILGlCQUFjLFdBQWlCOzs7Ozt1Q0FBL0JBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDQUE2SDs7O1lBQ0FDLGE7R0FBMEIsSUFDMUJDO0dBRUosU0FBQUMsY0FBQWpEO0lBQUE7O3VCOzs7SUFBQSxPQUFBOzs7OzthQUFBQTtHQUNvQjtZQUVwQi9FLFVBQUF1RjtJQUFBLE9BQUEsMEJBSEF5QyxlQUdBekM7R0FBMEM7WUFFdEMrQixVQUFVNUk7c0I7SUFBSSxPQUFBLCtCQUFKQTtHQUEyQjtZQUNyQzZFO0lBQVksT0FBbUM7Ozs7aUJBVi9Dc0UsU0FDQUMsU0FDQUM7R0FRMEU7Ozs7OztnQ0FOOUVDLGVBR0FoSSxXQUVJc0gsV0FDQS9EOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDWEosU0FBQXZELFVBQUErRTtJQUFBLE9BQUEsdURBQUFBO0dBQTJEOzs7Ozs4QkFBM0QvRTs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDaUNJaUksU0FBU0MsT0FBWSxPQUFaQSxNQUF1QztZQUNoREMsT0FBT0MsS0FBVSxPQUFWQSxJQUFpQztZQUN4Q0MsU0FBVTNKLEdBQVMsT0FBQSwwQkFBVEEsR0FBa0M7WUFDNUM0SixPQUFRNUosR0FBUyxjQUFUQSx1QkFBZ0M7WUFTdEM2SixLQUFLN0osR0FBSSxPQVZYMkosU0FVTzNKLFdBQXlDO1lBQzlDOEosZUFBOEJDLGNBQWUsT0FBZkEsYUFBZ0Q7R0FSckUsZ0JBT1RGLE1BQ0FDOzs7Ozs7b0NBYkZQLFVBQ0FFLFFBQ0FFLFVBQ0FDOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNuQ0FJLE9BQU9oSyxHQUFJLE9BQUpBLFNBQXdCO1lBRS9CaUssc0JBQXNCakssR0FBRWtLO0lBRTFCO0tBQU8sVUFBQSxzQkFGaUJsSyxNQUFFa0s7a0JBQUZsSyxPQUFFa0s7O0dBRzJCOzs7OztxQ0FMbkRGLFFBRUFDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNGQWQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBQ0FDLGE7R0FBMEIsSUFDMUJDO0dBTUosU0FlWWMsT0FBQXZJLEdBQUEsT0FBQUEsS0FBTTtZQUFOd0ksV0FBQXhJLEdBQUFFLEdBQUFGLE9BQUFFLFlBQU07WUFETnVJLE1BQUF6SSxHQUFBLE9BQUFBLEtBQUs7WUFBTDBJLFVBQUExSSxHQUFBRSxHQUFBRixPQUFBRSxZQUFLO1lBSEx5SSxLQUFBM0ksR0FBQSxPQUFBQSxLQUFJO1lBQUo0SSxTQUFBNUksR0FBQUUsR0FBQUYsT0FBQUUsWUFBSTtZQUhKMkksS0FBQTdJLEdBQUEsT0FBQUEsS0FBSTtZQUFKOEksU0FBQTlJLEdBQUFFLEdBQUFGLE9BQUFFLFlBQUk7WUFOSjZJLHFCQUFBL0ksR0FBQSxPQUFBQSxLQUFvQjtZQUFwQmdKLHlCQUFBaEosR0FBQUUsR0FBQUYsT0FBQUUsWUFBb0I7WUFEcEIrSSxhQUFBakosR0FBQSxPQUFBQSxLQUFZO1lBQVprSixpQkFBQWxKLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVk7Z0JBY1pGLEdBQUFFLEdBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBTTtHQUFOO0lBQUEsVUFBQXNJO0lBQUFXLCtCQUFBLFNBQU0sb0JBQU5aO2dCQURBdkksR0FBQUUsR0FBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFLO0dBQUw7SUFBQSxVQUFBMEk7SUFBQVUsOEJBQUEsU0FBSyxtQkFBTFg7Z0JBSEF6SSxHQUFBRSxHQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUk7R0FBSjtJQUFBLFVBQUE0STtJQUFBUyw2QkFBQSxTQUFJLGtCQUFKVjtnQkFIQTNJLEdBQUFFLEdBQUEsV0FBQUYsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUEsTUFBQUEsTUFBSTtHQUFKO0lBQUEsVUFBQThJO0lBQUFRLDZCQUFBLFNBQUksa0JBQUpUO2dCQU5BN0ksR0FBQUUsR0FBQSxXQUFBRixNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFvQjtHQUFwQjtJQUFBLFVBQUFnSjtJQUFBTzs7dUJBQUEsU0FBb0I7OztPQUFwQlI7O2dCQURBL0ksR0FBQUUsR0FBQSxXQUFBQSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFZO0dBQVo7SUFBQSxVQUFBa0o7SUFBQU07O3VCQUFBLFNBQVk7OztPQUFaUDs7WUFEWnZKO0lBQUE7S0FDWStKO0tBQ0FDO0tBTUFDO0tBR0FDO0tBR0FDO0tBQ0FDO0tBQUFDLFVBQUEsc0JBQUFEO0tBZlpyRCxnQ0FlWXNEO0tBREFDLFVBQUEsc0JBQUFIO0tBZFpsRCxrQ0FjWXFELGVBZFp2RDtLQVdZRCxVQUFBLHNCQUFBb0Q7S0FYWi9DLGtDQVdZTCxlQVhaRztLQVFZRCxVQUFBLG1DQUFBaUQ7S0FSWjVDLGtDQVFZTCxlQVJaRztLQUVZRCxVQUFBLHNCQUFBOEM7S0FGWk8sa0NBRVlyRCxlQUZaRztLQUNZRCxVQUFBLHNCQUFBMkM7S0FEWlMsa0NBQ1lwRCxlQURabUQ7SUFBQSxXQUFBQztHQWlCNEI7WUFFeEJDLE9BQU8vTCxHQUFFMEcsR0FBSSxTQUFOMUcsT0FBRTBHLFNBQUYxRyxjQUErQztZQUN0RGdNLFNBQVNoTSxHQUFJLE9BQUpBLGFBQWM7WUFFdkI0SSxVQUFVNUk7O2NBRU5pTSxNQUFNQyxHQUFJLE9BQUEsOEJBRkpsTSxHQUVBa00sR0FBNkI7S0FxQm5DO01BN0NIQztRQXdCR0Y7bUJBcUJZOUI7V0FDVCxLQUFPLG1DQURFQTtZQUNULE1BQUE7V0FDa0IsVUEzQnpCNkIsU0FFVWhNO1dBeUJJLEdBQUEsbUNBRkVtSztXQUVULE1BQUE7VUFBNkI7TUEvQ25DaUM7UUF3QkdIO21CQWlCWTVCO1dBQ1QsS0FBTyxtQ0FERUE7WUFDVCxNQUFBO1dBQ2dCLFVBdkJ2QjJCLFNBRVVoTTtXQXFCSSxHQUFBLG1DQUZFcUs7V0FFVCxNQUFBO1VBQTJCO01BM0NqQ2dDO1FBd0JHSjttQkFZWTFCO1dBQ1QsSUFBSXlCLFdBREt6QjtXQUVGLEtBQUEseUJBREh5QjtZQUNKLE1BQUE7V0FDbUMsVUFBQSxtQ0FqQmhDaE07V0FpQkksR0FBQSxtQ0FGSGdNOztXQUVKLE1BQUE7VUFBbUQ7TUF2Q3pETTtRQXdCR0w7bUJBTVl4QjtXQUNULFVBVEd6SyxjQVNIOztnQkFBQTBHOzthQUV5QjtjQUFBLE1BZGhDcUYsT0FHVS9MLEdBU0gwRztjQUVhLE1BQUEsbUNBSEorRDthQUVQO2FBQUEsVUFERi9EO3dCQUFBQTtpQkFBQUE7Ozs7VUFHSTtNQWxDVjZGO1FBd0JHTjttQkFJWXRCO1dBQXdCLEdBQU8sbUNBQS9CQTs7V0FBd0IsTUFBQTtVQUFrQztNQTVCekU2QjtRQXdCR1A7bUJBRXdCcEI7V0FBZ0IsR0FBTyxtQ0FBdkJBO1dBQWdCLE1BQUE7VUFBMEI7S0ExQnJFLFdBQUEyQixrQkFDT3BCO0tBRFAsV0FBQW1CLDBCQUVPcEI7S0FGUCxXQUFBbUIsVUFRT3BCO0tBUlAsV0FBQW1CLFVBV09wQjtLQVhQLFdBQUFtQixXQWNPcEI7S0FDQSxPQUFBLFdBZlBtQixZQWVPcEI7SUFnQzhCO0lBeEJJLE9BQUEsbUNBRGhDL0ssR0F0QmRzQjtHQStDMkM7WUFHdkNtTCxhQUFjVDtJQUFXLDBDQUFYQTtHQUE2RDtZQUUzRW5ILGNBQ0YsaUJBSEU0SCwwQkFVRDtZQUdDQyxNQUFNMU0sR0FBQUEsVUFBQUEsVUFBQUEsbUJBR21CO1lBdUJ6QjJNLElBQWEzTSxHQUFFMEcsR0FBRXdELG1CQUFrQmdDLEdBQUVVO0lBQzFCLElBQVRDLFdBdkVGZCxPQXNFYS9MLEdBQUUwRztJQUVqQixtQ0FGZTFHLE1BQ1g2TSxVQURlM0M7SUFHbkIsbUNBSGVsSyxNQUNYNk0sa0JBRGlDWDtJQUdyQyxPQUFBLG1DQUhlbE0sTUFDWDZNLGtCQURtQ0Q7R0FJWTtZQUdqREUsUUFBUTlNLEdBQUVrSyxtQkFBa0JnQyxHQUFFVTtJQUNsQixVQTdFWlosU0E0RVFoTTtJQUNQLEdBQUEsbUNBRE9BO0tBMUJTO01BQWYrTSxlQWxERmYsU0E0RVFoTTtNQXpCTmdOLGVBREFEO01BRUFFLFdBd0JNak47TUF2Qk5rTixZQXVCTWxOO01BdEJObU47UUFBTyx5QkFzQkRuTixNQTFCTitNLGVBR0FHO01BRUFFLFFBcUJNcE4sZ0JBdEJObU47TUFFQUUsV0ExQkZaLGFBcUJFTztLQU1KOytCQUxJQyxVQUNBQyxtQkFHQUcsYUFGQUY7S0FTSixtQ0FYSUYsYUFJQUksVUFGQUYsTUFDQUM7S0FxQk1wTixPQXpCTmdOO0tBeUJNaE4sT0FwQk5xTjtLQW9CTXJOOztJQVBSMk0sSUFPUTNNLEdBQUFBLE1BQUVrSyxtQkFBa0JnQyxHQUFFVTtJQUF0QjVNLE9BQUFBOztHQUdjO1lBR3RCc04sMkJBQXlCdE4sR0FBRXVOO0lBQzdCLEdBQUcsbUNBRDBCQTs7aUNBdEcvQmpNLFVBc0c2QnRCO3VEQUFFdU47Ozs7OztLQUczQjs7SUFIeUJ2TixPQUFFdU47O0dBS0Y7WUFHekJDLGNBQWN4TjtJQUFJLFVBQUEsbUNBQUpBO0lBQUksZ0RBQUpBO0dBQThDO1lBRTVEeU4sUUFBUXpOLEdBQUcwTixXQUF5QnhELG1CQUFrQmdDLEdBQUVVO0lBQWhENU0sT0FBQUE7SUFFVix1Q0FGYTBOLFdBQXlCeEQ7SUFFdEMsT0FBQSxXQUZ3RGdDLEdBQUVVO0dBR3ZEO1lBR0RlLGtCQUFrQjNOLEdBQUcwTjtJQUN2QixJQUFJRSxnQkFEbUJGOztLQUVqQixVQUFBLGlDQURGRTtLQUNFLEtBQUE7S0FFRjtNQUFBLFFBQUEsaUNBSEFBO01BRXlDaEI7TUFBSFY7TUFBbkJoQztLQVRyQnVELFFBTWtCek4sR0FBRzBOLFdBR0F4RCxtQkFBbUJnQyxHQUFHVTs7R0FJekM7WUFHRmlCLFNBQWtCN04sR0FBRTBOO0lBS3RCO0tBZkVDLGtCQVVrQjNOLEdBQUUwTjs7TUFPZCxLQXpCTkYsY0FrQmtCeE4sSUE4QmxCO01BdEJpQjtPQUFYOE4sV0FySE4vQixPQTZHa0IvTDtPQVNaa0ssb0JBQ00sbUNBVk1sSyxNQVFaOE47T0FJQTVCLElBQXdCLG1DQVpabE0sTUFRWjhOO09BS0FsQixJQUFnQixtQ0FiSjVNLE1BUVo4TjtNQS9DTm5CLElBdUNrQjNNLE1BeElsQm1KLFNBQ0FDLFNBQ0FDO01Bc0lrQnJKLFFBQUFBLGdCQUFBQTtNQUFBQSxPQUFBQTtNQUFBQSxPQUFBQTtNQWhCbEJ5TixRQWdCa0J6TixHQUFFME4sV0FTZHhELG1CQUdBZ0MsR0FDQVU7TUF2Qk5lLGtCQVVrQjNOLEdBQUUwTjs7O1VBZ0NwQks7S0FJZ0I7TUFKaEJDLDBCQUFBRDtNQUlJRSxZQUFZO0tBQ2hCLGVBTEFELEtBSUlDOztHQUNrQjs7Ozs7Ozs7T0FySzFCM007T0FzQklzSDtPQThCQS9EO09BNENBaUk7T0FqQ0FKO09BdUNBWTtPQVFBRTtPQS9GUXJEO09BaUhSMEQ7T0EvSFFoRDs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUN1VW9CcUQ7SUFEQUM7SUF6SkZDO0lBa0JFQztJQVVBQzs7SUF4RHZCN007Ozs7Ozs7Ozs7OztJQThGRzhNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFsUE5qTixVQUFVdEI7SUFFRDtLQUFBLE9BQUEsZ0NBRkNBO0tBRVQ7T0FBQTtTQUFPO0lBQVAsT0FBQTs7R0FUVTtJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FPWHNCOzs7Ozs7O1lBU0FrTixRQUFReE87SUFBaUIsV0FBQTtJQUFBLE9BQUEsc0JBQWpCQTtHQUEwQjtHQUh6QjtJQUFBLDBEQUdUd087SUFXZ0MsTUFBQTtJQUN0QixVQUFBO0lBUFpDO01BS0Y7SUFhSUM7WUFBQUMsb0I7WUFBQUM7SUFBQTs7T0FDRTs7T0FDQTs7T0FDQTtlQUNBOztHQUNrQztZQUVoQ0Msc0JBQXVCQyxNQUFNQztJQUMvQjs7WUFEeUJEOztpQkFBTUMsVUFBQUE7O2VBQUFBOztnQkFBQUE7eUJBQUFBLFdBQUFBOztLQVdpQzs7SUFDVjtHQUFLO0dBcEIvQyxpQkFDZEwsV0FBQUMsU0FBQUMsYUFPSUM7WUFrQkZHO1FBRUtDLGVBR0FDLHFCQUdBQyxtQkFLTEM7T0FSS0Y7O01BUUxwTixJQVJLb047OzZEQVFMcE4sVUFBQXNOOztnQkFBQUE7NkRBWEtIOzt1REFNQUU7O0dBYzJCLElBQUEsc0JBdUI5QkU7WUFFQUMsVztZQUNBQyxRQUFRdlAsR0FBSSxPQURKLHNCQUNBQSxHQUhScVAsTUFHNkI7WUFDN0JHLFFBQVF4UCxHQUFJLFdBRFp1UCxRQUNRdlAsR0FBbUI7WUFDM0J5UCxXQUFXQyxJQUFHQyxJQUFLLE9BRG5CSCxRQUNXRSxNQUFBQSxLQUFHQyxHQUFrQztZQUs1Q0MsbUI7R0FGbUI7SUFBQSxzQkFMdkJMLFNBT0lLO0lBSGlCO1lBU3JCQyxZQUNhQztJLHVDQUFBQTtJQUViLElBQUt0RyxRQUFMLG9DQUZhc0c7V0E5RGZkLGNBZ0VPeEY7O1lBR0x1RyxRQUNhRCxrQkFESkU7SSx1Q0FDSUY7S0FDTCxPQUZDRTtJQUdULElBQUt4RyxRQUFMLG9DQUZhc0c7SUFFQyxPQUFUdEc7O1lBR0x5RyxVQUNhSDtJLHVDQUFBQTs7Ozs7SUFFYixJQUFLdEcsUUFBTCxvQ0FGYXNHO0lBRUMsT0FBVHRHOztZQUdMMEcsVUFDYUo7SSx1Q0FBQUEsbUJBQ0w7SUFDUixJQUFLdEcsUUFBTCxvQ0FGYXNHO0lBRUMsV0FBVHRHOztZQUdMMkc7SUFBWSxZQS9Ea0IsT0F1QjlCZDtRQTBDSzdGO0lBQVMsT0FBVEE7R0FBbUI7R0FwRWQ7Ozs7T0EwQlY2RjtPQUVBQztPQUNBQztPQUNBQztPQUNBQzs7T0FXQUk7T0FNQUU7T0FNQUU7T0FNQUM7T0FNQUM7R0FNTixTQWdCWWhCLE9BQUF2TixHQUFBLE9BQUFBLEtBQU07WUFBTndPLFdBQUF4TyxHQUFBRSxHQUFBRixPQUFBRSxZQUFNO1lBRE51TyxXQUFBek8sR0FBQSxPQUFBQSxLQUFVO1lBQVYwTyxlQUFBMU8sR0FBQUUsR0FBQUYsT0FBQUUsWUFBVTtZQURWeU8sV0FBQTNPLEdBQUEsT0FBQUEsS0FBVTtZQUFWNE8sZUFBQTVPLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVU7WUFQVm9OLFNBQUF0TixHQUFBLE9BQUFBLEtBQVE7WUFBUjZPLGFBQUE3TyxHQUFBRSxHQUFBRixPQUFBRSxZQUFRO1lBRmhCb0ksa0JBQUF0SSxHQUFBLE9BQUFBLEtBQWlCO1lBRGpCOE8sU0FBQTlPLEdBQUEsT0FBQUEsS0FBUTtZQURBK08sS0FBQS9PLEdBQUEsT0FBQUEsS0FBRTtZQUFGZ1AsT0FBQWhQLEdBQUFFLEdBQUFGLE9BQUFFLFlBQUU7WUFERitPLE1BQUFqUCxHQUFBLE9BQUFBLEtBQUs7WUFBTGtQLFVBQUFsUCxHQUFBRSxHQUFBRixPQUFBRSxZQUFLO2dCQWNMRixHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFO0dBQU07R0FBTjtJQUFBLFVBQUFzTztJQUFBVywrQkFBQSxTQUFNLG9CQUFONUI7Z0JBREF2TixHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGO0dBQVU7R0FBVjtJQUFBLFVBQUEwTztJQUFBVTswQkFBQSxTQUFVLHdCQUFWWDtnQkFEQXpPLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUE7R0FBVTtHQUFWO0lBQUEsVUFBQTRPO0lBQUFTOzBCQUFBLFNBQVUsd0JBQVZWO2dCQVBBM08sR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQTtHQUFRO0dBQVI7SUFBQSxVQUFBNk87SUFBQVM7MEJBQUEsU0FBUSxzQkFBUmhDO2dCQUZSdE4sR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQTtHQUFpQjtHQUFqQjs7SUFBQXVQOzt1QkFBQSxTQUFpQjs7O09BQWpCakg7O2dCQURBdEksR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQTtHQUFRO0dBQVI7O0lBQUF3UDswQkFBQSxTQUFRLHNCQUFSVjtnQkFEUTlPLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUUsR0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUE7R0FBRTtHQUFGO0lBQUEsVUFBQWdQO0lBQUFTLDJCQUFBLFNBQUUsZ0JBQUZWO2dCQURBL08sR0FBQUU7SUFBQSxXQUFBQSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQTtHQUFLO0dBQUw7SUFBQSxVQUFBa1A7SUFBQVEsOEJBQUEsU0FBSyxtQkFBTFQ7WUFGUDNOO0lBQUFxTztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbk87SUFBQTtLQUFBLFFBQUEsV0FBQTROLFdBRU9ELFNBRlAzTjtLQUFBQztLQUFBbU87S0FBQSxVQUFBLFdBQUFQLFFBR09ILE1BSFB6TjtLQUFBRTtLQUFBa087S0FBQSxVQUFBLFdBQUFQLGNBSURMLFlBSkN0TjtLQUFBRTtLQUFBaU87S0FBQTtPQUFBLFdBQUFQLHVCQUtEUCxxQkFMQ25OO0tBQUFFO0tBQUFnTztLQUFBLFVBQUEsV0FBQVAsY0FPT1QsWUFQUGhOO0tBQUFFO0tBQUErTjtLQUFBLFVBQUEsV0FBQVAsZ0JBY09YLGNBZFA3TTtLQUFBRTtLQUFBOE47S0FBQSxVQUFBLFdBQUFQLGdCQWVPYixjQWZQMU07S0FBQUU7S0FBQTZOO0tBQUEsVUFBQSxXQUFBUCxZQWdCT2YsVUFoQlB2TTtLQUFBRTtLQUFBNE47SUFBQTtxQkFBQTFOO2FBQUE7Y0FBQWlNLFFBQUEsV0FBQWtCLFdBQUFuTjtjQUFBcUssS0FBQSxXQUFBK0MsUUFBQXBOO2NBQUE4TCxXQUFBLFdBQUF1QixjQUFBck47Y0FBQXNGLG9CQUFBLFdBQUFnSSx1QkFBQXROO2NBQUFzSyxXQUFBLFdBQUFpRCxjQUFBdk47Y0FBQTJMLGFBQUEsV0FBQTZCLGdCQUFBeE47Y0FBQXlMLGFBQUEsV0FBQWdDLGdCQUFBek47Y0FBQXVLLFNBQUEsV0FBQW1ELFlBQUExTjthQUFBO3FCQUFBaU07cUJBQUE1QjtxQkFBQXlCO3FCQUFBeEc7cUJBQUFnRjtxQkFBQXFCO3FCQUFBRjtxQkFBQWxCO1lBQUM7WUFBRHpLOztZQUFBRztJQUFBZ007SUFBQTVCO0lBQUF5QjtJQUFBeEc7SUFBQWdGO0lBQUFxQjtJQUFBRjtJQUFBbEI7SUFBQTtZQUFBMEI7WUFBQTVCO1lBQUF5QjtZQUFBeEc7WUFBQWdGO1lBQUFxQjtZQUFBRjtZQUFBbEI7R0FBQztZQUFEcks7SUFBQXlNO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxPQUFBLFdBQUFBLFlBZ0JPZjtLQWhCUCxPQUFBLFdBQUFjLGdCQWVPYjtLQWZQLE9BQUEsV0FBQVksZ0JBY09YO0tBZFAsT0FBQSxXQUFBVSxjQU9PVDtLQVBQLE9BQUEsV0FBQVEsdUJBS0RQO0tBTEMsT0FBQSxXQUFBTSxjQUlETDtLQUpDLE9BQUEsV0FBQUksUUFHT0g7SUFIUDtZQUFBLFdBQUFFLFdBRU9EOzs7Ozs7OztHQUZOO1lBQUR2TTtJQUFBd007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQSxXQUFBUCxXQUVPRDtJQUZQLFdBQUFFLFFBR09IO0lBSFAsV0FBQUksY0FJREw7SUFKQyxXQUFBTSx1QkFLRFA7SUFMQyxXQUFBUSxjQU9PVDtJQVBQLFdBQUFVLGdCQWNPWDtJQWRQLFdBQUFZLGdCQWVPYjtJQUNBLE9BQUEsV0FoQlBjLFlBZ0JPZjtHQWhCTjtZQUFEL0w7SUFBQUM7SUFBQXNNO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUEsT0FnQk87YUFoQlBBO2FBQUE7ZUFBQUQ7ZUFBQTtpQkFBQUQ7aUJBQUE7bUJBQUFEO21CQUFBO3FCQUFBRDtxQkFBQTt1QkFBQUQ7dUJBQUE7eUJBQUFELFFBQUEsV0FBQUQsV0FBQXRNLE1BRU9xTSxVQUNBRDt1QkFDUkQ7cUJBQ0FEO21CQUVRRDtpQkFPQUQ7ZUFDQUQ7YUFDQUQ7R0FoQk47WUFBRDdMLFNBQUFDO0lBQUE7S0FBQSxXQUFBLFdBQUFBLFdBZ0JPNEw7S0FoQlAsV0FBQSxXQUFBNUwsV0FlTzZMO0tBZlAsV0FBQSxXQUFBN0wsV0FjTzhMO0tBZFAsV0FBQSxXQUFBOUwsV0FPTytMO0tBUFAsV0FBQSxXQUFBL0wsV0FLRGdNO0tBTEMsV0FBQSxXQUFBaE0sV0FJRGlNO0tBSkMsV0FBQSxXQUFBak0sV0FHT2tNO0lBSFAsV0FBQSxXQUFBbE0sV0FFT21NO0dBRk47WUFBRGxNO0lBQUFtTTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsT0FBQSxXQUFBUCxXQUVPRDtLQUZQLGNBQUEsV0FBQUUsUUFHT0g7S0FIUCxjQUFBLFdBQUFJLGNBSURMO0tBSkM7Y0FBQSxXQUFBTSx1QkFLRFA7S0FMQyxjQUFBLFdBQUFRLGNBT09UO0tBUFAsY0FBQSxXQUFBVSxnQkFjT1g7S0FkUCxjQUFBLFdBQUFZLGdCQWVPYjtJQWZQLGNBZ0JPLFdBaEJQYyxZQWdCT2Y7R0FoQk47WUFBRDFMO0lBQUFrTTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsT0FBQSxXQUFBUCxXQUVPRDtLQUZQLGVBQUEsV0FBQUUsUUFHT0g7S0FIUCxlQUFBLFdBQUFJLGNBSURMO0tBSkMsZUFBQSxXQUFBTSx1QkFLRFA7S0FMQyxlQUFBLFdBQUFRLGNBT09UO0tBUFAsZUFBQSxXQUFBVSxnQkFjT1g7S0FkUCxlQUFBLFdBQUFZLGdCQWVPYjtJQWZQLHFCQWdCTyxXQWhCUGMsWUFnQk9mO0dBaEJOO1lBQUR6TDtJQUFBaU07SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLFdBQUEsV0FBQUEsWUFnQk9mO0tBaEJQLFdBQUEsV0FBQWMsZ0JBZU9iO0tBZlAsV0FBQSxXQUFBWSxnQkFjT1g7S0FkUCxXQUFBLFdBQUFVLGNBT09UO0tBUFAsV0FBQSxXQUFBUSx1QkFLRFA7S0FMQyxXQUFBLFdBQUFNLGNBSURMO0tBSkMsV0FBQSxXQUFBSSxRQUdPSDtJQUhQLFdBQUEsV0FBQUUsV0FFT0Q7R0FGTjtZQUFEL0w7SUFBQUo7SUFBQW9NO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUEsV0FBQVAsV0FFT0QsU0FGUG5NLFFBQUFBO0lBQUEsV0FBQXFNLFFBR09ILE1BSFBsTSxRQUFBQTtJQUFBLFdBQUFzTSxjQUlETCxZQUpDak0sUUFBQUE7SUFBQSxXQUFBdU0sdUJBS0RQLHFCQUxDaE0sUUFBQUE7SUFBQSxXQUFBd00sY0FPT1QsWUFQUC9MLFFBQUFBO0lBQUEsV0FBQXlNLGdCQWNPWCxjQWRQOUwsUUFBQUE7SUFBQSxXQUFBME0sZ0JBZU9iLGNBZlA3TCxRQUFBQTtJQWdCTyxPQUFBLFdBaEJQMk0sWUFnQk9mLFVBaEJQNUwsUUFBQUE7R0FBQztZQUFESztJQUFBTDtJQUFBRjtJQUFBc007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7O1lBQUEzTTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtJQUFBLE9BQUE7YUFBQTJNO2FBQUE7ZUFBQUQ7ZUFBQTtpQkFBQUQ7aUJBQUE7bUJBQUFEO21CQUFBO3FCQUFBRDtxQkFBQTt1QkFBQUQ7dUJBQUE7eUJBQUFEO3lCQUFBLFdBQUFELFdBQUF0TSxNQUVPcU0sU0FGUG5NLFFBQUFBO3lCQUdPa007eUJBSFBsTTs7dUJBSURpTTt1QkFKQ2pNOztxQkFLRGdNO3FCQUxDaE07O21CQU9PK0w7bUJBUFAvTDs7aUJBY084TDtpQkFkUDlMOztlQWVPNkw7ZUFmUDdMOzthQWdCTzRMO2FBaEJQNUw7OztZQUFBTTtJQUFBTjtJQUFBb007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQVAsV0FFT0QsU0FGUG5NLFFBQUFBO0tBQUEsY0FBQSxXQUFBcU0sUUFHT0gsTUFIUGxNLFFBQUFBO0tBQUE7Y0FBQSxXQUFBc00sY0FJREwsWUFKQ2pNLFFBQUFBO0tBQUE7O1VBQUE7V0FBQXVNLHVCQUtEUCxxQkFMQ2hNLFFBQUFBOztLQUFBO2NBQUEsV0FBQXdNLGNBT09ULFlBUFAvTCxRQUFBQTtLQUFBOztVQUFBLFdBQUF5TSxnQkFjT1gsY0FkUDlMLFFBQUFBOztLQUFBOztVQUFBLFdBQUEwTSxnQkFlT2IsY0FmUDdMLFFBQUFBOztJQUFBLGNBZ0JPLFdBaEJQMk0sWUFnQk9mLFVBaEJQNUwsUUFBQUE7R0FBQztZQUFETztJQUFBUDtJQUFBb007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQVAsV0FFT0QsU0FGUG5NLFFBQUFBO0tBQUEsZUFBQSxXQUFBcU0sUUFHT0gsTUFIUGxNLFFBQUFBO0tBQUEsZUFBQSxXQUFBc00sY0FJREwsWUFKQ2pNLFFBQUFBO0tBQUE7OztRQUFBO1VBQUF1TSx1QkFLRFAscUJBTENoTSxRQUFBQTtLQUFBLGVBQUEsV0FBQXdNLGNBT09ULFlBUFAvTCxRQUFBQTtLQUFBO2VBQUEsV0FBQXlNLGdCQWNPWCxjQWRQOUwsUUFBQUE7S0FBQTtlQUFBLFdBQUEwTSxnQkFlT2IsY0FmUDdMLFFBQUFBO0lBQUEscUJBZ0JPLFdBaEJQMk0sWUFnQk9mLFVBaEJQNUwsUUFBQUE7R0FBQztZQUFEUTtJQUFBUjtJQUFBb007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLFdBQUEsV0FBQUEsWUFnQk9mLFVBaEJQNUwsUUFBQUE7S0FBQTtXQUFBLFdBQUEwTSxnQkFlT2IsY0FmUDdMLFFBQUFBO0tBQUE7V0FBQSxXQUFBeU0sZ0JBY09YLGNBZFA5TCxRQUFBQTtLQUFBLFdBQUEsV0FBQXdNLGNBT09ULFlBUFAvTCxRQUFBQTtLQUFBOztRQUFBO1VBQUF1TSx1QkFLRFAscUJBTENoTSxRQUFBQTs7S0FBQSxXQUFBLFdBQUFzTSxjQUlETCxZQUpDak0sUUFBQUE7S0FBQSxXQUFBLFdBQUFxTSxRQUdPSCxNQUhQbE0sUUFBQUE7SUFBQSxXQUFBLFdBQUFvTSxXQUVPRCxTQUZQbk0sUUFBQUE7R0FBQztZQUFEUztJQUFBVDtJQUFBb007SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQUEsWUFnQk9mLFVBaEJQNUwsUUFBQUE7S0FBQSxPQUFBLFdBQUEwTSxnQkFlT2IsY0FmUDdMLFFBQUFBO0tBQUEsT0FBQSxXQUFBeU0sZ0JBY09YLGNBZFA5TCxRQUFBQTtLQUFBLE9BQUEsV0FBQXdNLGNBT09ULFlBUFAvTCxRQUFBQTtLQUFBO09BQUE7U0FBQXVNLHVCQUtEUCxxQkFMQ2hNLFFBQUFBO0tBQUEsT0FBQSxXQUFBc00sY0FJREwsWUFKQ2pNLFFBQUFBO0tBQUEsT0FBQSxXQUFBcU0sUUFHT0gsTUFIUGxNLFFBQUFBO0lBQUE7WUFBQSxXQUFBb00sV0FFT0QsU0FGUG5NLFFBQUFBOzs7Ozs7OztHQUFDO1lBQURVO0lBQUFWLFFBQUEwTCxPQUFBNUIsSUFBQUMsVUFBQXFCLFlBQUFGLFlBQUFsQjtJQUFBLElBQUFySixXQUFBLDZCQUFBWDtJQUFBVyxjQUFBK0s7SUFBQS9LLGNBQUFtSjtJQUFBbkosY0FBQW9KO0lBQUFwSixjQUFBeUs7SUFBQXpLLGNBQUF1SztJQUFBdkssY0FBQXFKOztHQUFDO0dBQUQ7SUFBQTs7T0FBQTVKO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO0lBQUE7O09BQUFwRTtPQWdCT3NQO09BREFDO09BREFDO09BUEFDO09BRlJDO09BREFDO09BRFFDO09BREFDO09BRlBwTztPQUFBMkI7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUU7T0FBQUU7T0FBQUM7T0FBQUM7O1lBc0JEc0QsVUFBVTVJOztjQUVOaU0sTUFBTUMsR0FBSSxPQUFBLDhCQUZKbE0sR0FFQWtNLEdBQTZCO0tBQ3ZDLG9CO0tBd0JJO01BQUE7UUF6QkFEO21CQTBCa0I2RDtXLCtCQUFBQSxtQkFJYjtXQUNBO1lBQUtPLGFBQUwsNEJBTGFQO1lBTUV5QyxNQWxDZHZTO1lBa0Njd1M7WUFBQUM7WUFBQUM7WUFBQTVSO1lBQUEwQjtvQkFBQW1RLFdBQUFDLE9BQUFDO1lBQUEsT0FBQSxzQkFBQUQsT0FBQUM7V0FBUTs7O2FBQVJ2RTthQUFBa0U7YUFBQUc7YUFBQW5RO2FBQUExQjthQUFBNFI7YUFBQUQ7YUFBQUY7V0FDSSxXQUZkbEMsZUFFYyxPQUFBLHNCQW5DbEJyUTtXQW1DTSxHQUFBO1dBQVAsTUFBQTs7TUFsQkw7UUFmQWlNO21CQWdCa0I2RDtXLCtCQUFBQSxtQkFJYjtXQUNBO1lBQUtTLGFBQUwsNEJBTGFUO1lBTUV5QyxNQXhCZHZTO1lBd0Jjd1M7WUFBQUM7WUFBQUM7WUFBQTVSO1lBQUEwQjtvQkFBQW1RLFdBQUFHLE9BQUFDO1lBQUEsT0FBQSxzQkFBQUQsT0FBQUM7V0FBUTs7O2FBQVIxRTthQUFBbUU7YUFBQUc7YUFBQW5RO2FBQUExQjthQUFBNFI7YUFBQUQ7YUFBQUY7V0FDSSxXQUZkaEMsZUFFYyxPQUFBLHNCQXpCbEJ2UTtXQXlCTSxHQUFBO1dBQVAsTUFBQTs7eUI7eUI7eUI7eUI7S0FwQkw7O1FBSEFpTTttQkFHWTRFO1dBQ1Q7WUFBZTBCLE1BQ2IscUJBRk8xQjtZQUNNNEIsZUFOWnpTO1lBTVl3UztZQUFBRTtZQUFBNVI7WUFBQTBCO29CQUFBbVEsV0FBQUssT0FBQUM7WUFBQSxPQUFBLHNCQUFBRCxPQUFBQztXQUFJOzs7b0JBQUo3RTtvQkFBQW9FO29CQUFBRztvQkFBQW5RO29CQUFBMUI7b0JBQUE0UjtvQkFBQUQ7b0JBQUFGO1VBS1c7S0F5QnZCLE9BQUE7O0lBQU07SUFuQzBCLE9BQUEsbUNBRGhDdlMsR0FqSFZnUDtHQXFKaUI7WUFHakJrRSxhQUFXbFQsR0FBRStPO0lBQ2YsSUFBSUQsT0FEUzlPO1dBRU4sc0JBREg4TyxNQURXQzs7a0NBeEpiQyxjQXdKV2hQO3dEQUFFK087d0RBQ1hEOzs7Ozs7Ozs7O0tBR0Y7O0lBSlc5TyxPQUFFK087O0dBV0E7WUFHYm9FLGNBQWVDLElBQUdwVCxHQUFFK087SUFBUyxXQUFBLHNCQUFkcUUsSUFBR3BUO0lBQVcsY0FkN0JrVCxhQWNrQmxULEdBQUUrTztHQUF1RDtHQWpNbEU7SUFBQTs7O09BMkJUQzs7T0EyR1FHO09BREFrQjtPQUFBQztPQURBQztPQUFBQztPQVBBdEI7T0FBQXVCO09BRlJ2RztPQURBd0c7T0FEUUM7T0FBQUM7T0FEQUM7T0FBQUM7O09BN0ZSOUI7T0FpSEFwRztPQXVDQXNLO09BY0FDO09BeEVReEM7Ozs7OztZQStFUjBDLFlBQVVyVDtJQUNaO0tBQ09zVCxJQUFLLDRDQUZBdFQ7S0FJSG9QLFFBREEsNENBREZrRSxHQUZLdFQ7V0FFTHNUOztvQ0FFRWxFO0dBSWE7R0FYSjtrRUFHaEJpRTtHQVlOLFNBd0JJM0YsVUFBQTlMLEdBQUEsT0FBQUEsS0FBUztZQURUMlIsY0FBQTNSLEdBQUEsT0FBQUEsS0FBYTtZQURiNFIsYUFBQTVSLEdBQUEsT0FBQUEsS0FBWTtZQUhKNlIsb0JBQUE3UixHQUFBLE9BQUFBLEtBQW1CO1lBQW5COFIsd0JBQUE5UixHQUFBRSxHQUFBRixPQUFBRSxZQUFtQjtZQVJuQjZSLGFBQUEvUixHQUFBLE9BQUFBLEtBQVk7WUFBWmdTLGlCQUFBaFMsR0FBQUUsR0FBQUYsT0FBQUUsWUFBWTtZQUhwQmtJLE9BQUFwSSxHQUFBLE9BQUFBLEtBQU07WUFERWlTLGFBQUFqUyxHQUFBLE9BQUFBLEtBQVk7WUFBWmtTLGlCQUFBbFMsR0FBQUUsR0FBQUYsT0FBQUUsWUFBWTtZQUhaaVMsZUFBQW5TLEdBQUEsT0FBQUEsS0FBYztZQUFkb1MsbUJBQUFwUyxHQUFBRSxHQUFBRixPQUFBRSxZQUFjO1lBSHRCUyxHQUFBWCxHQUFBLE9BQUFBLEtBQUU7Z0JBdUJGQSxHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFO0dBQVM7R0FBVDs7SUFBQW1TOzBCQUFBLFNBQVMsdUJBQVR2RztnQkFEQTlMLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUY7R0FBYTtHQUFiOztJQUFBc1M7O3VCQUFBLFNBQWE7OztPQUFiWDs7Z0JBREEzUixHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBO0dBQVk7R0FBWjs7SUFBQXVTOzt1QkFBQSxTQUFZOzs7T0FBWlg7O2dCQUhRNVIsR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQTtHQUFtQjtHQUFuQjtJQUFBLFVBQUE4UjtJQUFBVTs7dUJBQUEsU0FBbUI7OztPQUFuQlg7O2dCQVJBN1IsR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQTtHQUFZO0dBQVo7SUFBQSxVQUFBZ1M7SUFBQVM7O3VCQUFBLFNBQVk7OztPQUFaVjs7Z0JBSFIvUixHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQU07R0FBTjs7SUFBQTBTLCtCQUFBLFNBQU0sb0JBQU50SztnQkFEUXBJLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUE7R0FBWTtHQUFaO0lBQUEsVUFBQWtTO0lBQUFTOzt1QkFBQSxTQUFZOzs7T0FBWlY7O2dCQUhBalMsR0FBQUU7SUFBQSxXQUFBRixNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQTtHQUFjO0dBQWQ7SUFBQSxVQUFBb1M7SUFBQVE7O3VCQUFBLFNBQWM7OztPQUFkVDs7Z0JBSFJuUyxHQUFBRTtJQUFBLFdBQUFBLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQUU7R0FBRixhQUFBbUIsMkJBQUEsU0FBRSxnQkFBRlI7WUFETWtTO0lBQUFwUjtJQUFBcVI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQXRSO0lBQUE7S0FBQSxRQUFBLFdBQUFOLFFBQ05OLE1BRE1ZO0tBQUFDO0tBQUFLO0tBQUEsVUFBQSxXQUFBeVEsb0JBSUVGLGtCQUpGNVE7S0FBQUU7S0FBQW9SO0tBQUEsVUFBQSxXQUFBUCxrQkFPRUosZ0JBUEZ6UTtLQUFBRTtLQUFBbVI7S0FBQSxVQUFBLFdBQUFQLFlBUU5OLFVBUk10UTtLQUFBRTtLQUFBa1I7S0FBQSxVQUFBLFdBQUFQLGtCQVdFUixnQkFYRm5RO0tBQUFFO0tBQUFpUjtLQUFBO09BQUE7U0FBQVAseUJBbUJFVix1QkFuQkZoUTtLQUFBRTtLQUFBZ1I7S0FBQSxVQUFBLFdBQUFQLGtCQXNCTlosZ0JBdEJNN1A7S0FBQUU7S0FBQStRO0tBQUEsVUFBQSxXQUFBUCxtQkF1Qk5kLGlCQXZCTTFQO0tBQUFFO0tBQUE4UTtLQUFBLFVBQUEsV0FBQVAsZUF3Qk5oQixhQXhCTXZQO0tBQUErUTtLQUFBQztJQUFBO3FCQUFBOVE7YUFBQTtjQUFBckMsS0FBQSxXQUFBMEIsUUFBQVc7Y0FBQW1QLGlCQUFBLFdBQUFtQixvQkFBQXRRO2NBQUFpUCxlQUFBLFdBQUFzQixrQkFBQXZRO2NBQUFvRixTQUFBLFdBQUFvTCxZQUFBeFE7Y0FBQStPLGVBQUEsV0FBQTBCLGtCQUFBelE7Y0FBQTZPLHNCQUFBLFdBQUE2Qix5QkFBQTFRO2NBQUE0TyxlQUFBLFdBQUErQixrQkFBQTNRO2NBQUEyTyxnQkFBQSxXQUFBaUMsbUJBQUE1UTtjQUFBOEksWUFBQSxXQUFBZ0ksZUFBQTlRO2FBQUE7cUJBQUFyQztxQkFBQXdSO3FCQUFBRjtxQkFBQTdKO3FCQUFBMko7cUJBQUFGO3FCQUFBRDtxQkFBQUQ7cUJBQUE3RjtZQUFDO1lBQUQrSDs7WUFBQUU7SUFBQXBUO0lBQUF3UjtJQUFBRjtJQUFBN0o7SUFBQTJKO0lBQUFGO0lBQUFEO0lBQUFEO0lBQUE3RjtJQUFBO1lBQUFuTDtZQUFBd1I7WUFBQUY7WUFBQTdKO1lBQUEySjtZQUFBRjtZQUFBRDtZQUFBRDtZQUFBN0Y7R0FBQztZQUFEa0k7SUFBQXZTO0lBQUFxUjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsT0FBQSxXQUFBQSxlQXdCTmhCO0tBeEJNLE9BQUEsV0FBQWUsbUJBdUJOZDtLQXZCTSxPQUFBLFdBQUFhLGtCQXNCTlo7S0F0Qk0sT0FBQSxXQUFBVyx5QkFtQkVWO0tBbkJGLE9BQUEsV0FBQVMsa0JBV0VSO0tBWEYsT0FBQSxXQUFBTyxZQVFOTjtLQVJNLE9BQUEsV0FBQUssa0JBT0VKO0tBUEYsT0FBQSxXQUFBRyxvQkFJRUY7SUFKRjtZQUFBLFdBQUFuUixRQUNOTjs7Ozs7Ozs7O0dBRE87WUFBRDhTO0lBQUF4UztJQUFBcVI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQSxXQUFBNVIsUUFDTk47SUFETSxXQUFBMlIsb0JBSUVGO0lBSkYsV0FBQUcsa0JBT0VKO0lBUEYsV0FBQUssWUFRTk47SUFSTSxXQUFBTyxrQkFXRVI7SUFYRixXQUFBUyx5QkFtQkVWO0lBbkJGLFdBQUFXLGtCQXNCTlo7SUF0Qk0sV0FBQWEsbUJBdUJOZDtJQUNBLE9BQUEsV0F4Qk1lLGVBd0JOaEI7R0F4Qk87WUFBRDZCO0lBQUE3UTtJQUFBNUI7SUFBQXFSO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUEsT0F3Qk47YUF4Qk1BO2FBQUE7ZUFBQUQ7ZUFBQTtpQkFBQUQ7aUJBQUE7bUJBQUFEO21CQUFBO3FCQUFBRDtxQkFBQTt1QkFBQUQ7dUJBQUE7eUJBQUFEO3lCQUFBOzJCQUFBRDsyQkFBQSxXQUFBclIsUUFBQTRCLE1BQ05sQzsyQkFHUXlSO3lCQUdBRDt1QkFDUkQ7cUJBR1FEO21CQVFBRDtpQkFHUkQ7ZUFDQUQ7YUFDQUQ7R0F4Qk87WUFBRDhCLFdBQUE1UTtJQUFBO0tBQUEsV0FBQSxXQUFBQSxXQXdCTjhPO0tBeEJNLFdBQUEsV0FBQTlPLFdBdUJOK087S0F2Qk0sV0FBQSxXQUFBL08sV0FzQk5nUDtLQXRCTSxXQUFBLFdBQUFoUCxXQW1CRWlQO0tBbkJGLFdBQUEsV0FBQWpQLFdBV0VrUDtLQVhGLFdBQUEsV0FBQWxQLFdBUU5tUDtLQVJNLFdBQUEsV0FBQW5QLFdBT0VvUDtLQVBGLFdBQUEsV0FBQXBQLFdBSUVxUDtJQUpGLFdBQUEsV0FBQXJQLFdBQ05wQztHQURPO1lBQURpVDtJQUFBM1M7SUFBQXFSO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxPQUFBLFdBQUE1UixRQUNOTjtLQURNLGNBQUEsV0FBQTJSLG9CQUlFRjtLQUpGLGNBQUEsV0FBQUcsa0JBT0VKO0tBUEYsY0FBQSxXQUFBSyxZQVFOTjtLQVJNLGNBQUEsV0FBQU8sa0JBV0VSO0tBWEY7O1VBQUEsV0FBQVMseUJBbUJFVjs7S0FuQkYsY0FBQSxXQUFBVyxrQkFzQk5aO0tBdEJNLGNBQUEsV0FBQWEsbUJBdUJOZDtJQXZCTSxjQXdCTixXQXhCTWUsZUF3Qk5oQjtHQXhCTztZQUFEZ0M7SUFBQTVTO0lBQUFxUjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsT0FBQSxXQUFBNVIsUUFDTk47S0FETSxlQUFBLFdBQUEyUixvQkFJRUY7S0FKRixlQUFBLFdBQUFHLGtCQU9FSjtLQVBGLGVBQUEsV0FBQUssWUFRTk47S0FSTSxlQUFBLFdBQUFPLGtCQVdFUjtLQVhGLGVBQUEsV0FBQVMseUJBbUJFVjtLQW5CRixlQUFBLFdBQUFXLGtCQXNCTlo7S0F0Qk0sZUFBQSxXQUFBYSxtQkF1Qk5kO0lBdkJNLHFCQXdCTixXQXhCTWUsZUF3Qk5oQjtHQXhCTztZQUFEaUM7SUFBQTdTO0lBQUFxUjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBO0tBQUEsV0FBQSxXQUFBQSxlQXdCTmhCO0tBeEJNLFdBQUEsV0FBQWUsbUJBdUJOZDtLQXZCTSxXQUFBLFdBQUFhLGtCQXNCTlo7S0F0Qk07V0FBQSxXQUFBVyx5QkFtQkVWO0tBbkJGLFdBQUEsV0FBQVMsa0JBV0VSO0tBWEYsV0FBQSxXQUFBTyxZQVFOTjtLQVJNLFdBQUEsV0FBQUssa0JBT0VKO0tBUEYsV0FBQSxXQUFBRyxvQkFJRUY7SUFKRixXQUFBLFdBQUFuUixRQUNOTjtHQURPO1lBQURvVDtJQUFBaFI7SUFBQTlCO0lBQUFxUjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBLFdBQUE1UixRQUNOTixNQURNb0MsUUFBQUE7SUFBQSxXQUFBdVAsb0JBSUVGLGtCQUpGclAsUUFBQUE7SUFBQSxXQUFBd1Asa0JBT0VKLGdCQVBGcFAsUUFBQUE7SUFBQSxXQUFBeVAsWUFRTk4sVUFSTW5QLFFBQUFBO0lBQUEsV0FBQTBQLGtCQVdFUixnQkFYRmxQLFFBQUFBO0lBQUE7TUFBQTJQLHlCQW1CRVYsdUJBbkJGalAsUUFBQUE7SUFBQSxXQUFBNFAsa0JBc0JOWixnQkF0Qk1oUCxRQUFBQTtJQUFBLFdBQUE2UCxtQkF1Qk5kLGlCQXZCTS9PLFFBQUFBO0lBd0JOLE9BQUEsV0F4Qk04UCxlQXdCTmhCLGFBeEJNOU8sUUFBQUE7R0FBQztZQUFEaVI7SUFBQWpSO0lBQUFGO0lBQUE1QjtJQUFBcVI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7O1lBQUE5UDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtJQUFBLE9BQUE7YUFBQThQO2FBQUE7ZUFBQUQ7ZUFBQTtpQkFBQUQ7aUJBQUE7bUJBQUFEO21CQUFBO3FCQUFBRDtxQkFBQTt1QkFBQUQ7dUJBQUE7eUJBQUFEO3lCQUFBOzJCQUFBRDsyQkFBQSxXQUFBclIsUUFBQTRCLE1BQ05sQyxNQURNb0MsUUFBQUE7MkJBSUVxUDsyQkFKRnJQOzt5QkFPRW9QO3lCQVBGcFA7O3VCQVFObVA7dUJBUk1uUDs7cUJBV0VrUDtxQkFYRmxQOzttQkFtQkVpUDttQkFuQkZqUDs7aUJBc0JOZ1A7aUJBdEJNaFA7O2VBdUJOK087ZUF2Qk0vTzs7YUF3Qk44TzthQXhCTTlPOzs7WUFBQWtSO0lBQUFsUjtJQUFBOUI7SUFBQXFSO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxPQUFBLFdBQUE1UixRQUNOTixNQURNb0MsUUFBQUE7S0FBQTs7VUFBQSxXQUFBdVAsb0JBSUVGLGtCQUpGclAsUUFBQUE7O0tBQUE7O1VBQUEsV0FBQXdQLGtCQU9FSixnQkFQRnBQLFFBQUFBOztLQUFBLGNBQUEsV0FBQXlQLFlBUU5OLFVBUk1uUCxRQUFBQTtLQUFBOztVQUFBLFdBQUEwUCxrQkFXRVIsZ0JBWEZsUCxRQUFBQTs7S0FBQTs7VUFBQTtXQUFBMlAseUJBbUJFVix1QkFuQkZqUCxRQUFBQTs7S0FBQTs7VUFBQSxXQUFBNFAsa0JBc0JOWixnQkF0Qk1oUCxRQUFBQTs7S0FBQTs7VUFBQSxXQUFBNlAsbUJBdUJOZCxpQkF2Qk0vTyxRQUFBQTs7SUFBQTtjQXdCTixXQXhCTThQLGVBd0JOaEIsYUF4Qk05TyxRQUFBQTs7R0FBQztZQUFEbVI7SUFBQW5SO0lBQUE5QjtJQUFBcVI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLE9BQUEsV0FBQTVSLFFBQ05OLE1BRE1vQyxRQUFBQTtLQUFBOztVQUFBLFdBQUF1UCxvQkFJRUYsa0JBSkZyUCxRQUFBQTtLQUFBO2VBQUEsV0FBQXdQLGtCQU9FSixnQkFQRnBQLFFBQUFBO0tBQUEsZUFBQSxXQUFBeVAsWUFRTk4sVUFSTW5QLFFBQUFBO0tBQUE7ZUFBQSxXQUFBMFAsa0JBV0VSLGdCQVhGbFAsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQTJQLHlCQW1CRVYsdUJBbkJGalAsUUFBQUE7S0FBQTtlQUFBLFdBQUE0UCxrQkFzQk5aLGdCQXRCTWhQLFFBQUFBO0tBQUE7O1VBQUEsV0FBQTZQLG1CQXVCTmQsaUJBdkJNL08sUUFBQUE7SUFBQTs7Y0F3Qk4sV0F4Qk04UCxlQXdCTmhCLGFBeEJNOU8sUUFBQUE7R0FBQztZQUFEb1I7SUFBQXBSO0lBQUE5QjtJQUFBcVI7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQTtLQUFBLFdBQUEsV0FBQUEsZUF3Qk5oQixhQXhCTTlPLFFBQUFBO0tBQUE7O1FBQUEsV0FBQTZQLG1CQXVCTmQsaUJBdkJNL08sUUFBQUE7O0tBQUE7O1FBQUEsV0FBQTRQLGtCQXNCTlosZ0JBdEJNaFAsUUFBQUE7O0tBQUE7O1FBQUE7VUFBQTJQLHlCQW1CRVYsdUJBbkJGalAsUUFBQUE7O0tBQUE7O1FBQUEsV0FBQTBQLGtCQVdFUixnQkFYRmxQLFFBQUFBOztLQUFBLFdBQUEsV0FBQXlQLFlBUU5OLFVBUk1uUCxRQUFBQTtLQUFBOztRQUFBLFdBQUF3UCxrQkFPRUosZ0JBUEZwUCxRQUFBQTs7S0FBQTs7UUFBQSxXQUFBdVAsb0JBSUVGLGtCQUpGclAsUUFBQUE7O0lBQUEsV0FBQSxXQUFBOUIsUUFDTk4sTUFETW9DLFFBQUFBO0dBQUM7WUFBRHFSO0lBQUFyUjtJQUFBOUI7SUFBQXFSO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUE7S0FBQSxPQUFBLFdBQUFBLGVBd0JOaEIsYUF4Qk05TyxRQUFBQTtLQUFBLE9BQUEsV0FBQTZQLG1CQXVCTmQsaUJBdkJNL08sUUFBQUE7S0FBQSxPQUFBLFdBQUE0UCxrQkFzQk5aLGdCQXRCTWhQLFFBQUFBO0tBQUE7T0FBQTtTQUFBMlAseUJBbUJFVix1QkFuQkZqUCxRQUFBQTtLQUFBLE9BQUEsV0FBQTBQLGtCQVdFUixnQkFYRmxQLFFBQUFBO0tBQUEsT0FBQSxXQUFBeVAsWUFRTk4sVUFSTW5QLFFBQUFBO0tBQUEsT0FBQSxXQUFBd1Asa0JBT0VKLGdCQVBGcFAsUUFBQUE7S0FBQTtPQUFBLFdBQUF1UCxvQkFJRUYsa0JBSkZyUCxRQUFBQTtJQUFBO1lBQUEsV0FBQTlCLFFBQ05OLE1BRE1vQyxRQUFBQTs7Ozs7Ozs7O0dBQUM7WUFBRHNSO0lBQUF0UixRQUFBNE8sZ0JBQUFGLGNBQUFGLGNBQUFGO0lBQUEsSUFBQTNOLFdBQUEsNkJBQUFYO0lBQUFXLGNBQUFpTztJQUFBak8sY0FBQStOO0lBQUEvTixjQUFBNk47SUFBQTdOLGNBQUEyTjs7R0FBQztHQUFEO0lBQUE7O09BQUEwQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztJQUFBOztPQUFBbEk7T0F3Qk4wRjtPQURBQztPQURBQztPQUhRQztPQVJBQztPQUhSQztPQURRQztPQUhBQztPQUhSelI7T0FETTBSO09BQUFrQjtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQzs7WUE4Qk5RO0lBYVE7S0FSSjFNO0tBR0F1SjtLQUtGb0QsTUFBTSw2QkFSSjNNO0lBU04sR0FOTXVKOzhEQUtGb0Q7OztJQUllLElBQWJDO2tCQUM2Qi9GO0tBQy9CLFdBRkUrRixlQUVvQyxPQUFBLHFCQWRwQzVNLFFBYTZCNkc7S0FEN0IrRix3QkFFYSxxQkFkYjVNLFFBYTZCNkc7O0lBQytDO0lBRGhGLDZCQWJJN0c7SUFhSixvQjs7S0FHaUMsSUFBZTZNLGVBQVRDO0tBQW9CLE9BQUEseUJBQXBCQSxLQUFTRDtJQUFtQztJQUFqRjtLQUFBLE9BQUEsMEJBSkVEO0tBT3FDdEMsV0FIdkM7Ozs7NkRBR3VDQTs7OzBEQVh2Q3FDOztZQWNGSSxpQkFBaUIvVyxHQUFJLG9DQUFKQSxNQUE2QjtZQUU5Q2dYLG1CQU9FaFgsR0FBRWlYO0lBQWdCLElBTlBDLFlBTVhsWCxNQUxhOFAsbUJBREZvSDs7c0NBQ0VwSCxtQkFDTDtLQUNSO01BQUtxSCxVQUFMLDhCQUZhckg7TUFHYixPQUFBLHNCQURLcUgsU0FHSEY7S0FGRixTQUFBO1NBSldHLFlBR05ELFlBRlFySCxtQkFERnNIOztHQU0wQztZQUd2REMsb0JBQW9DQyxlQUFnQ3RYOztjQUVoRWlNLE1BQU1DLEdBQUksT0FBQSw4QkFGc0RsTSxHQUUxRGtNLEdBQTZCO0tBQ3ZDLG9CO3lCO3lCO0tBa0NJO01BQUE7UUFuQ0FEO21CQW9Da0J3SDtXLGlDQUFBQSxzQkFDTDtXQUNSLElBQUtqSyxRQUFMLDhCQUZhaUs7V0FFUSxHQWxEOUJ1RCxtQkFVb0VoWCxHQXdDdER3SjtXQUFTLE1BQUE7O01BbEJuQjtRQXBCQXlDO21CQTZCK0I2RDtXQVI1QixpQ0FRNEJBLG1CQUNsQjtXQUNSO1lBVm1Cb0gsWUFVbkIsOEJBRjBCcEg7WUFSUHFILFVBQUFEO1dBQ25CO1lBQWtDLFdBcEMzQ0gsaUJBWW9FL1c7WUF3QnBELEtBQUEsd0JBRFltWDthQUNuQixNQUFBO2dCQUM0QkkscUJBRlRKOzZDQUVTSSxxQkFDbEI7WUFDUixJQUFLSCxZQUFMLDhCQUYwQkc7WUFHbkIsS0FBQSx3QkFMVUosWUFJWkM7YUFDTCxNQUFBO2dCQUxpQkQsVUFJWkM7O1VBTXdCO01BekJwQztRQU5Bbkw7bUJBTVlqQzsrQjtXQUNULGtDQURTQTt5QkFFd0I2RztZQUMvQjthQUFJOUcsZUFBZSxxQkFIWkMsUUFFd0I2RzthQUd4QnlDLElBQUssK0JBRlJ2SjthQUtLUCxRQUZBLCtCQURGOEosR0FGSHZKO2VBRUd1SixHQUVPLE9BQUEsV0FmYWdFLGVBZ0JsQjlOO1lBQ0EsS0FBQSxzQkFQc0JxSCxPQU10QnJIO2FBQ1AsTUFBQTtZQUMyQzthQUE1QitJLE1BRlIvSTthQUVRaUosU0FBNEIscUJBVnRDekksUUFFd0I2RzthQVFkMkI7YUFBQUU7YUFBQTVSO2FBQUEwQjtxQkFBQW1RLFdBQUE2RSxPQUFBQzthQUFBLE9BQUEseUJBQUFELE9BQUFDO1lBQVM7OztjQUFUdEo7Y0FBQXFFO2NBQUFHO2NBQUFuUTtjQUFBMUI7Y0FBQTRSO2NBQUFEO2NBQUFGOzthQUNBbUYsUUFIUmxPO2FBR1FtTzthQUFBQzthQUFBako7YUFBQWtKO2FBQUE3VTtxQkFBQThVLGFBQUFDLE9BQUFDO2FBQUEsT0FBQSx3QkFBQUQsT0FBQUM7WUFBYzs7O2NBQWQ5SjtjQUFBeUo7Y0FBQUc7Y0FBQTlVO2NBQUE2VTtjQUFBbEo7Y0FBQWlKO2NBQUFGO1lBQWYsT0FBQSxzQkFIT2xPO1dBSWM7V0FWRyxPQUFBLDZCQUZuQlE7VUFZaUI7eUI7eUI7eUI7S0FxQnBCLE9BQUE7Ozs7Ozs7Ozs7O0lBQU07a0JBeENvQmlPO0ssT0F4Q3ZDdkIsNEIsZUF3Q3VDdUI7O0lBQUssT0FBQSxvQ0FEd0JqWTtHQXlDaEQ7WUFHcEJrWSxZQUFVbFk7SUFBSSxPQTVDZHFYLG9DQTRDaUQsU0FBRSxHQUF6Q3JYO0dBQTRDO0dBdFVoRDs7Ozs7T0E2T04wTjtPQURBNkY7T0FEQUM7T0FIUUM7T0FBQUM7T0FSQUM7T0FBQUM7T0FIUjVKO09BRFE2SjtPQUFBQztPQUhBQztPQUFBQztPQUhSelI7O09BNkJBbVU7T0EyQkFLO09BRUFDO09BVUFLO09BNENBYTtZQUtOQyxZQUFBQyxPQUFBLE9BQUEsOEJBQUFBLE9BQXVDO09BRW5DQyxzQkFDQUM7WUFHRkMsWUFBQUMsT0FBQSxPQUFBLDhCQUFBQSxPQUE2QztHQUQzQixxQkFDbEJELGFBSkVGLGFBQ0FDO1lBU0FHLEtBQUd6WSxHQUFJLE9BQUpBLEtBQVE7WUFDWDBZLGdCQUFjMVksR0FBSSxPQUFKQSxLQUFtQjtZQUNqQ21LLE9BQU9uSyxHQUFJLG9DQUFKQSxNQUFnQztZQUN2QzJZLHVCQUF1QjNZO0lBQUksb0NBQUpBO0dBQWdEO1lBQ3ZFNFksVUFBVzVZLEdBQXVCLE9BQXZCQSxFQUF3QjtZQUluQzZZLEtBQUs3WSxHQUFHd0o7SUFDVixzQkFEVUE7SUFBQUEsV0FFSztRQU9Fc0csbUJBVFY5UDs7O3dDQVNVOFA7TUFDYjtPQUFLMkQsc0JBQUwsOEJBRGEzRDtTQUNpQix3QkFBekIyRCx3QkFWQ2pLO09BVU47UUFBSzRLO1VBQUwsOEJBRGF0RTtPQVRQdEcsV0FXYyx3QkFEZjRLO09BVkM1SyxXQVVENEs7Ozs7S0FWQzVLO0tBQUFBLFdBQUh4Sjs7SUFBQUEsT0FpQmtCLHdCQWpCZndKOztTQXVCTytOLHFCQXZCUC9OO3NDQXVCTytOO1VBR1R1Qjs7TUFESjtPQUFLQyxTQUFMLDhCQUZheEI7T0FHVHlCLGFBQVcsd0JBRFZELFdBekJDdlA7TUEyQk4sR0FESXdQLFlBMUJFeFAsV0FBQUEsVUFBQUEsV0F5QkR1UDtVQUNERCxhQUFBRTs7S0FLSixLQUxJRjs7UUFVU0cscUJBcENQelA7dUNBb0NPeVA7S0FFYixJQUFLQyxPQUFMLDhCQUZhRDtLQUVSQyxVQUEyQix3QkF0QzFCMVA7O1FBd0NLMlAscUJBeENMM1A7cUNBd0NLMlAscUJBeENSblosT0F5Q3FCLHdCQXpDbEJ3SjtJQTBDUixJQUFLNFAsT0FBTCw4QkFGYUQ7SUFFUkMsVUFBMkIsd0JBMUN4QjVQOztHQTBDK0M7WUFHdkQ2UCxnQkFBZ0JyWixHQUFJLG9DQUFKQSxNQUF5QztZQUN6RHNaLG9CQUFvQnRaLEdBQUksb0NBQUpBLE1BQTZDO1lBRWpFdVosbUJBQW1Cdlo7SUFDckIsT0FBRyx3QkFEa0JBO2tCQUVYLG1CQUZXQTsyQ0FBQUE7R0FHeUI7WUFHNUN3WixNQUFJeFo7SUFBSSxPQUFKQSxPQUE0Qiw2QkFBb0IsbUJBQWhEQTtHQUFrRTtPQUN0RXlaO1lBRUFDLFNBQVMxWixHQUFHd0o7SUFDZCxzQkFEY0E7SUFFd0MsV0FBQSxxQkFGeENBO0lBQUFBLFdBRUMsNkJBRkp4SixNQUFHd0o7O0dBRXdFO1lBR3BGbVEsa0JBQWtCM1osR0FBR3dKLE9BQWtCb1E7SUFDekMsSUFDaUI5SixtQkFGRzlQO3VDQUVIOFA7S0FFYjtNQUFLMkQsc0JBQUwsOEJBRmEzRDtLQUdWLEdBQUEsc0JBTGdCdEcsT0FJZGlLO01BSld6VCxPQU9XLHdCQVBSd0osVUFBQUE7O0lBU3ZCLElBQ2lCK04scUJBVk0vTjtxQ0FVTitOO0tBVkd2WCxPQUFHd0o7O0tBWW5CLElBQUs0UCxPQUFMLDhCQUZhN0I7S0FFUjZCLFVBWmM1UDs7SUFjdkIsSUFDaUJ5UCxxQkFmTXpQO3VDQWVOeVA7S0FFYixJQUFLQyxPQUFMLDhCQUZhRDtLQUVSQyxVQWpCYzFQOztJQUFBQTtJQUFBQTtJQXFCdkIsT0FBQSxzQkFyQnVCQSxPQUFrQm9RO0dBcUJSOzs7O0lBdFozQkM7O0lBMkdRQztJQURBQztJQUFBQztJQURBQztJQUFBQztJQVBBQztJQUFBQztJQUZSQztJQURBQztJQURRQztJQURBQztJQUFBQzs7SUFrQlJDO0lBRUFDO0lBdUNBQztJQWNBQztJQUNBQztZQXFQRkMsZ0JBQWdCL2EsR0FBR2lQLElBQUlDLFVBQVV3QjtJQUNuQyxtREFEa0IxUTtJQUNsQjtZQUFVO1lBRFdpUDtZQUFjeUI7O1lBQVZ4Qjs7OztHQVN4QjtZQUdDOEwsTUFBSWhiLEdBQUV3SjtJQUNtQixXQUFBLFdBL0MzQmlRLG9CQThDTXpaO0lBQ0gsT0FBQSx3QkFES3dKO2NBckdScVAsS0FxR003WSxHQUFFd0o7Y0E1Q1JrUSxTQTRDTTFaLEdBQUV3SjtHQUdhO1lBR25CeVIsZUFBZWpiLEdBQUdpUCxJQUFJQyxVQUFVd0I7SUFDdEIsSUFBUmxILFFBbkJGdVIsZ0JBa0JlL2EsR0FBR2lQLElBQUlDLFVBQVV3QjtJQU5oQ3NLLE1BTWVoYixHQUNid0o7SUFDSixPQURJQTtHQUVDO1lBR0gwUixLQUFHbGIsR0FBRWlQLElBQUd5QixVQUFXLE9BTm5CdUssZUFNR2piLEdBQUVpUCxPQUFHeUIsVUFBd0Q7WUFFaEV5SyxRQUFNbmIsR0FBRUMsTUFBS3lRO0lBQ3FCLFdBOURwQzhJLE1BNkRReFo7SUFDUixPQVRFaWI7YUFRTWpiLEdBQ2EsK0JBRFhDLFVBQUt5UTtHQUMyRDtZQUd4RTBLLCtCQUFzQ3BiLEdBQUVDO0lBQzFDO0tBQUlvYixvQkEzRUpoQyxnQkEwRXdDclo7S0FFckMsT0FBQSxnQ0FGdUNDLE1BQ3RDb2I7SUFDRCxXQUFBOzs7Ozt1REFEQ0E7Ozs7MERBRHNDcGI7Ozs7Ozs7O0dBUUM7WUFHekNxYixhQUFhdGIsR0FBRUMsTUFBS3lRO0lBWHBCMEssK0JBV2FwYixHQUFFQztJQUNqQixPQXhCRWdiLGVBdUJhamIsR0E1RWZ3WixNQTRFZXhaLFFBQUVDLE9BQUt5UTtHQUVzQztHQUk1RCxTQUFBNks7SUFBQTs7T0FDRTs7T0FDQTtlQUNBOztHQUNrQjtHQUxBLHVCQUNwQkE7WUFPRUMsTUFBTXhiLEdBQUd3SjtJQUNYLE9BRFdBOztPQWpGWG1RLGtCQWlGUTNaLEdBQUd3SixXQVNUOztjQVRTQSxZQUFBQTs7T0FZVCxzQkFaU0E7T0FhVCw2QkFiTXhKLE1BQUd3SjtPQUFBQSxXQWNNO09BQ2Y7ZUFDZTs7R0FBc0I7WUFHckNpUyxrQkFBa0J6YixHQUFFd0osT0FuQnBCZ1MsTUFtQmtCeGIsR0FBRXdKLFFBQWdCLFNBQStCO1lBRW5Fa1MsVUFBVTFiLEdBQUV3SjtJQUNSLElBRUptUyxTQXhCQUgsTUFxQlV4YixHQUFFd0o7U0FHWm1TLFFBRE07Ozt5REFDTkE7Ozs7Ozs7R0FJZ0M7WUFHaENDLFNBQU81YixHQUFFMFE7SUFBVyxPQXJGcEJxSyxnQkFxRk8vYSxtQkFBRTBRO0dBQXVFO1lBRWhGbUwscUJBQXFCN2IsR0FBR3dKLE9BQVd5RixJQUFJQztJQUl6QyxJQUNFQyxTQUx3QjNGO1lBS3hCMkY7S0FMd0IzRixXQUFXeUY7S0FBWHpGLFdBQWUwRjtLQTNFdkM4TCxNQTJFcUJoYixHQUFHd0o7S0FXeEI7Ozt3Q0FOQTJGOzs7Ozs7O0dBT0s7WUFHTDJNLFlBQVk5YixHQUFFd0osT0FBTXlGO0lBQUssT0FmekI0TSxxQkFlWTdiLEdBQUV3SixPQUFNeUY7R0FBbUQ7WUFDdkU4TSxlQUFlL2IsR0FBRXdKLE9BQU12SjtJQUEwQyxXQTFJbkV1WixNQTBJaUJ4WjtJQUFtQyxPQURsRDhiLFlBQ2U5YixHQUFFd0osT0FBaUMsK0JBQTNCdko7R0FBdUQ7WUFFOUUrYixzQkFBc0JoYyxHQUFFd0osT0FBTXZKO0lBM0U5Qm1iLCtCQTJFc0JwYixHQUFRQztJQUVlLE9BcEI3QzRiLHFCQWtCc0I3YixHQUFFd0osT0E1STFCZ1EsTUE0SXdCeFosUUFBUUM7R0FFMEI7WUFHeERnYyxjQUFjamMsR0FBRXdKLE9BQU15RjtJQUN4QixPQURrQnpGOztPQXpJbEJtUSxrQkF5SWdCM1osR0FBRXdKLFdBQUFBLFdBQU15RixJQUt0QixPQXZHQStMLE1Ba0djaGIsR0FBRXdKOztPQUFBQSxXQUFNeUYsSUFTdEIsT0EzR0ErTCxNQWtHY2hiLEdBQUV3Sjs7T0FBQUEsV0FBTXlGO09BWUYsV0FBQSxXQTVKdEJ3SyxvQkFnSmdCelo7T0FZWCxPQUFBLHdCQVptQmlQO2lCQWFqQiw2QkFiU2pQLE1BQUV3SixVQUFNeUY7a0JBZXBCO3FDQWZZalAsTUFBRXdKO2lCQXZNbEJxUCxLQXVNZ0I3WSxHQUFFd0o7ZUFBQUEsV0FBTXlGLElBQU56RixjQW9CaEIsT0F0SEF3UixNQWtHY2hiLEdBQUV3Sjs7R0FvQkw7WUFHWDBTLGlCQUFpQmxjLEdBQUV3SixPQUFNdko7SUFBNEMsV0F4S3ZFdVosTUF3S21CeFo7SUFBcUMsT0F2QnREaWMsY0F1QmlCamMsR0FBRXdKLE9BQW1DLCtCQUE3QnZKO0dBQXlEO0dBeEl6RTs7OztPQXpaUDRaOztPQTJHUUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FQQUM7T0FBQUM7T0FGUkM7T0FEQUM7T0FEUUM7T0FEQUM7T0FBQUM7O09Ba0JSQztPQUVBQztPQXVDQUM7T0FjQUM7T0FDQUM7T0FxUEZDO09BWUFDO09BTUFDO09BTUFDO09BRUFDO09BSUFDO09BV0FFOztPQWFBRTtPQW1CQUM7T0FFQUM7T0FVQUU7T0FFQUM7T0FlQUM7T0FDQUM7T0FFQUM7T0FLQUM7T0F1QkFDO1lBSUZDLFVBQVVuYyxHQUFFQyxNQUFLeVE7SUFBbUIsd0JBQTFCMVEsR0FBRUMsTUFBS3lRO0lBQW1CO0dBQXNDO1lBQzFFMEwsT0FBT3BjLEdBQUVpUCxJQUFHeUI7SUFBbUIsd0JBQXhCMVEsR0FBRWlQLElBQUd5QjtJQUFtQjtHQUFpQztZQUVoRTJMLGlCQUFpQnJjLEdBQUVDLE1BQUt5UTtJQUNsQix3QkFEVzFRLEdBQUVDLE1BQUt5UTtJQUNsQjtHQUE2QztZQUtuRDRMLGlCQUFpQnRjLEdBQUl1YztJQUN2QixJQUFJQyw0QkFEZXhjOztTQUdGOFAsbUJBSEU5UDt3Q0FHRjhQOzs7TUFFYixJQUFLdEcsUUFBTCxnQ0FGYXNHO1NBRVJ0RztPQUVxQyxNQUFBO01BcEw1Q21RLGtCQTZLaUIzWixHQUtWd0o7TUFPRix1Q0FaWXhKLE1BS1Z3Sjs7O09BT0YsSUFVTyxXQWpCTEE7YUFrQld1RTtZQUFBQywwQkFBQUQ7UUFDVixHQXhCYXdPO1NBMkJNO1VBRFhFLGFBMUJLRjtVQTJCTnRPLFlBQVk7U0FDaEI7V0FGS3dPLFlBckJUalQsZ0NBc0JReUUsYUFKR0Q7OztvQkF2QkRoTztTQUFBQSxXQXlCc0IsOEJBRnJCZ087O1FBTVYsMkJBeEJEeEU7OztPQTBCQyxZQTFCREE7O1lBNEJTMEY7UUFDRixHQUFBLDZCQTdCUDFGO1NBcUNrQixXQUFBLFdBOU56QmlRLG9CQW9MaUJ6WjtTQUtWd0osV0FrQ1MsMkJBbENUQSxnQkE0QlMwRjtTQW5OaEJ3SyxTQWtMaUIxWixHQUtWd0o7Ozs7UUEyQlksMkJBM0JaQTs7OztLQXdDRjtNQUlQLE9BQUE7MkNBakRtQnhKLE1BQ2Z3Yzs7R0FnRGtFO1lBR3BFRSxjQUFjMWMsR0FBRytPLElBQUt3TjtJQUN4Qiw2QkFEZ0J2YyxNQUFHK08sSUFBSC9PO0lBQ2hCLE9BckRFc2MsaUJBb0RjdGMsR0FBUXVjO0dBRUk7WUFHMUJJLGlCQUFpQjNjLEdBQUd1YztJQUN0Qiw2QkFEbUJ2YyxNQUFBQTtJQUNuQixPQTFERXNjLGlCQXlEaUJ0YyxHQUFHdWM7R0FFTTtZQUcxQkssaUJBQWlCNWMsR0FBRytPLElBQUt3TjtJQVZ6QkcsY0FVaUIxYyxHQUFHK08sSUFBS3dOO0lBQzNCLE9BTkVJLGlCQUtpQjNjLEdBQVF1YztHQUVDO1lBRzFCTSxtQkFBbUI3YyxHQUFHdWM7SUFDeEIsR0FEcUJ2Yzs7O0tBR25COztJQUhtQkE7T0FBQUEsTUFBQUE7SUFRckIsT0EzRUVzYyxpQkFtRW1CdGMsR0FBR3VjO0dBUUk7WUFHMUJPLGlCQUFpQjljO0lBQUFBO1FBSWpCK2MsU0FKaUIvYztXQUlqQitjO2VBSmlCL2MsY0FNWCw4QkFGTitjOztHQUU0QjtZQUc1QkMsa0JBQWtCaGQsR0FBRytPO0lBcEJyQjhOLG1CQW9Ca0I3YztJQUdMLElBQVg4WSxxQkFGQXlEOztVQUVBekQ7TUE1QkY4RCxpQkF5QmtCNWMsR0FBRytPLElBQ25Cd047TUFnQkosT0ExQkVPLGlCQVNrQjljOztLQUtmLEdBQUEsNkJBTGVBO01BR2hCOFk7O01BS3FCLElBQWpCbUUsaUJBQWlCLDZCQVJMamQ7TUFTYixHQUFBLHdCQURDaWQsZ0JBUmVsTztPQUduQitKOztPQTVCRjhELGlCQXlCa0I1YyxHQVFaaWQsZ0JBUEpWOzs7R0FpQmM7WUFHaEJXLCtCQUFvRGxkLEdBQUcrTztJQXpDdkQ4TixtQkF5Q29EN2M7SUFHdkMsSUFBWDhZLHFCQUZBeUQ7O1VBRUF6RDtNQWpERjhELGlCQThDb0Q1YyxHQUFHK08sSUFDckR3TjtNQW1CSixPQWxERU8saUJBOEJvRDljOztLQUtqRCxHQUFBLDZCQUxpREE7TUFHbEQ4WTs7TUFLMEIsSUFBdEJRLHNCQUFzQiw2QkFSd0J0WjtNQVMvQyxHQUFBLHdCQURDc1oscUJBUmlEdks7T0FHckQrSjs7T0FqREY4RCxpQkE4Q29ENWMsR0FpQnpDLDZCQWpCeUNBLE9BQ2xEdWM7OztHQW9CYztZQUdoQlksaUJBQWlCbmQsR0FBRytPO0lBakVwQjhOLG1CQWlFaUI3YztJQXRFakI0YyxpQkFzRWlCNWMsR0FBRytPO0lBR3RCLE9BekRFK04saUJBc0RpQjljO0dBSUQ7WUFHaEJvZCxZQUFZcGQsR0FBRWtNO0lBQ2hCO0tBQUltUixRQWpVRjdELE1BZ1VZeFo7S0FFVkUsU0FBUyxXQUZHZ007S0FHWSxPQW5VMUJzTixNQWdVWXhaO0tBR1ZzZCxXQUFXLDhCQUZYRDtJQUdKLFdBRkluZCxRQUNBb2Q7R0FDWTtZQUdkQywrQkFBNEN2ZDtJQUM5QyxvQ0FEOENBO0dBQ007WUFHbER3ZCxrQkFBa0J4ZCxHQUFJLGlDQUFKQSxNQUF1Qzs7Ozs7Ozs7OztPQS91QnpEeU87O09BMFZKMEo7T0FFSUU7T0FDQUM7O09BU0FHO09BQ0FDO09BQ0F2TztPQUNBd087T0FDQUM7T0FJQUM7T0E2Q0FRO09BQ0FDO09BRUFDO09BTUFDO09BQ0FDO09BRUFDO09BS0FDOztPQW9LQXdDO09BQ0FDO09BRUFDO09BTUFDO09Bb0RBSTtPQUtBQztPQUtBQztPQUtBQztPQVdBQztPQVNBRTtPQXFCQUU7T0F3QkFDO09BT0FDO09BT0FHO09BSUFDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM1dEJHL2I7SUFhRjhNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaEREN007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFLRStiLGlCQUFpQkMsTUFBTyxXQUFQQSxNQUFlO1lBQ2hDN1ksY0FBWSxjQUFzQjtZQUVsQzhZLFlBQXNCL1EsR0FTeEIsZUFUd0JBLElBUzRCO0dBZjFDLGVBR1I2USxrQkFDQTVZLFFBRUE4WTtZQWdCQWhJO0lBQW9CLGtCQUFrQztJQUFsQyxPQUFBO0dBQWtEO0dBSDlELGVBR1JBO0dBS0YsU0FBQXJVLGlCQUFBLHlCQUdvQjtHQUpELHNCQUNuQkE7R0FNRixTQUVJc2MsS0FBQWhjLEdBQUEsT0FBQUEsS0FBSTtZQURKc0ksa0JBQUF0SSxHQUFBLE9BQUFBLEtBQWlCO2dCQUNqQkEsR0FBQUUsR0FBQSxXQUFBRixNQUFBRSxHQUFJO0dBQUo7O0lBQUErYiw2QkFBQSxTQUFJLGtCQUFKRDtnQkFEQWhjLEdBQUFFLEdBQUEsV0FBQUEsR0FBQUYsTUFBaUI7R0FBakI7O0lBQUF1UDs7dUJBQUEsU0FBaUI7OztPQUFqQmpIOztZQURDaEgsYUFBQXdPLHVCQUFBb00sVUFBQW5hO0lBQUE7S0FBQTtPQUFBLFdBQUErTix1QkFDRFAscUJBREN4TjtLQUFBQztLQUFBc087S0FBQSxVQUFBLFdBQUE0TCxVQUVERCxRQUZDamE7S0FBQUU7S0FBQWlhO0lBQUE7cUJBQUFuWjthQUFBO2NBQUFzRixvQkFBQSxXQUFBZ0ksdUJBQUF0TjtjQUFBZ1osT0FBQSxXQUFBRyxVQUFBblo7YUFBQSxXQUFBc0YsbUJBQUEwVDtZQUFDO1lBQUQ5WjtHQUFDO1lBQUQ4WCxTQUFBMVIsbUJBQUEwVCxNQUFBLFdBQUExVCxtQkFBQTBUO0dBQUM7WUFBRDlZLElBQUE0TSx1QkFBQW9NO0lBQUEsV0FBQSxXQUFBQSxVQUVERDtJQUZDLFdBQUEsV0FBQW5NLHVCQUNEUDtHQURFO1lBQURwTSxLQUFBMk0sdUJBQUFvTTtJQUFBLFdBQUFwTSx1QkFDRFA7SUFDQSxPQUFBLFdBRkMyTSxVQUVERDtHQUZFO1lBQUQ3WSxLQUFBQyxNQUFBeU0sdUJBQUFvTTtJQUFBLE9BRUQ7YUFGQ0E7YUFBQSxXQUFBcE0sdUJBQUF6TSxNQUNEa007YUFDQTBNO0dBRkU7WUFBRDNZLFNBQUFDO0lBQUEsZUFBQSxXQUFBQSxXQUVEMFk7SUFGQyxXQUFBLFdBQUExWSxXQUNEZ007R0FERTtZQUFEL0wsUUFBQXNNLHVCQUFBb007SUFBQSxXQUFBLFdBQUFwTSx1QkFDRFA7SUFEQyxjQUVELFdBRkMyTSxVQUVERDtHQUZFO1lBQUR4WSxPQUFBcU0sdUJBQUFvTTtJQUFBLFdBQUEsV0FBQXBNLHVCQUNEUDtJQURDLHFCQUVELFdBRkMyTSxVQUVERDtHQUZFO1lBQUR2WSxRQUFBb00sdUJBQUFvTTtJQUFBLGVBQUEsV0FBQUEsVUFFREQ7SUFGQyxXQUFBLFdBQUFuTSx1QkFDRFA7R0FERTtZQUFENUwsT0FBQUosUUFBQXVNLHVCQUFBb007SUFBQSxXQUFBcE0sdUJBQ0RQLHFCQURDaE0sUUFBQUE7SUFFRCxPQUFBLFdBRkMyWSxVQUVERCxRQUZDMVksUUFBQUE7R0FBQztZQUFESyxPQUFBTCxRQUFBRixNQUFBeU0sdUJBQUFvTTtJQUFBLFdBQUEzWTtJQUFBLE9BQUE7YUFBQTJZO2FBQUE7ZUFBQXBNO2VBQUF6TTtlQUNEa007ZUFEQ2hNO2VBQUFBO2FBRUQwWTthQUZDMVk7O0dBQUM7WUFBRE0sVUFBQU4sUUFBQXVNLHVCQUFBb007SUFBQTs7T0FBQTtTQUFBcE0sdUJBQ0RQLHFCQURDaE0sUUFBQUE7SUFBQSxjQUVELFdBRkMyWSxVQUVERCxRQUZDMVksUUFBQUE7R0FBQztZQUFETyxTQUFBUCxRQUFBdU0sdUJBQUFvTTtJQUFBOztPQUFBO1NBQUFwTSx1QkFDRFAscUJBRENoTSxRQUFBQTtJQUFBLHFCQUVELFdBRkMyWSxVQUVERCxRQUZDMVksUUFBQUE7R0FBQztZQUFEUSxVQUFBUixRQUFBdU0sdUJBQUFvTTtJQUFBLGVBQUEsV0FBQUEsVUFFREQsUUFGQzFZLFFBQUFBO0lBQUE7WUFBQTtjQUFBdU0sdUJBQ0RQLHFCQURDaE0sUUFBQUE7O0dBQUM7WUFBRFMsTUFBQVQsUUFBQXVNLHVCQUFBb007SUFBQSxXQUFBLFdBQUFBLFVBRURELFFBRkMxWSxRQUFBQTtJQUFBO1lBQUE7Y0FBQXVNLHVCQUNEUCxxQkFEQ2hNLFFBQUFBOztHQUFDO1lBQURVLHVCQUFBVjtJQUFBLDZCQUFBQTtJQUFBO0dBQUM7R0FBRDtJQUFBOztPQUFBSTtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztJQUFBOztPQUFBcEU7T0FFRG9jO09BREExTTtPQURDak87T0FBQTBZO09BQUE5VztPQUFBQztPQUFBQztPQUFBRTtPQUFBRTtPQUFBQztPQUFBQzs7WUFBTDBZO0lBQUEsSUFDSUMsa0NBREo1Vjt3QjtJQUVJO0tBQUFHO0tBRkpELGtDQUVJQyxlQUZKSDtLQUNJSztPQUFBLDhDQUFBdVY7S0FESnhWLGtDQUNJQyxlQURKSDtJQUFBLFdBQUFFO0dBSTRCO1lBRXhCRyxVQUFVNUk7O0tBR1Ysb0I7S0FBeUU7TUFEL0RrTTtNQUFJLE9BQUEsOEJBRkpsTSxHQUVBa007S0FDK0QsT0FBQTtJQUFNO0lBRnJDLE9BQUEsbUNBRGhDbE0sR0FOZGdlO0dBU29GO0dBakJwRDs7OztPQVU1Qko7T0FEQTFUOztPQURKOFQ7T0FNSXBWO0dBT04sU0EwRFlzVixrQkFBQXRjLEdBQUEsT0FBQUEsTUFBaUI7WUFBakJ1YyxzQkFBQXZjLEdBQUFFLEdBQUFGLFFBQUFFLFlBQWlCO1lBRGpCc2MsK0JBQUF4YyxHQUFBLE9BQUFBLE1BQW1DO1lBQW5DeWMsK0JBQUF6YyxHQUFBRSxHQUFBRixRQUFBRSxZQUFtQztZQURuQ3djLGlCQUFBMWMsR0FBQSxPQUFBQSxNQUFnQjtZQUFoQjJjLHFCQUFBM2MsR0FBQUUsR0FBQUYsUUFBQUUsWUFBZ0I7WUFGaEIwYywyQkFBQTVjLEdBQUEsT0FBQUEsTUFBMEI7WUFBMUI2YywrQkFBQTdjLEdBQUFFLEdBQUFGLFFBQUFFLFlBQTBCO1lBRDFCNGMsUUFBQTljLEdBQUEsT0FBQUEsTUFBSztZQUFMK2MsVUFBQS9jLEdBQUFFLEdBQUFGLFFBQUFFLFlBQUs7WUFETDhjLGlCQUFBaGQsR0FBQSxPQUFBQSxNQUFnQjtZQUFoQmlkLHFCQUFBamQsR0FBQUUsR0FBQUYsUUFBQUUsWUFBZ0I7WUFEaEJnZCxnQkFBQWxkLEdBQUEsT0FBQUEsTUFBZTtZQUFmbWQsb0JBQUFuZCxHQUFBRSxHQUFBRixRQUFBRSxZQUFlO1lBSmZrZCw4QkFBQXBkLEdBQUEsT0FBQUEsTUFBNkI7WUFBN0JxZCwrQkFBQXJkLEdBQUFFLEdBQUFGLFFBQUFFLFlBQTZCO1lBRHJDOEwsY0FBQWhNLEdBQUEsT0FBQUEsTUFBYTtZQWxCTHNkLFlBQUF0ZCxHQUFBLE9BQUFBLE1BQVc7WUFBWHVkLGdCQUFBdmQsR0FBQUUsR0FBQUYsUUFBQUUsWUFBVztZQURYc2QsaUJBQUF4ZCxHQUFBLE9BQUFBLE1BQWdCO1lBQWhCeWQscUJBQUF6ZCxHQUFBRSxHQUFBRixRQUFBRSxZQUFnQjtZQURoQndkLG9CQUFBMWQsR0FBQSxPQUFBQSxNQUFtQjtZQUFuQjJkLHdCQUFBM2QsR0FBQUUsR0FBQUYsUUFBQUUsWUFBbUI7WUFEbkIwZCxnQkFBQTVkLEdBQUEsT0FBQUEsTUFBZTtZQUFmNmQsb0JBQUE3ZCxHQUFBRSxHQUFBRixRQUFBRSxZQUFlO1lBRnZCNGQsMEJBQUE5ZCxHQUFBLE9BQUFBLE1BQXlCO1lBRGpCK2Qsb0JBQUEvZCxHQUFBLE9BQUFBLE1BQW1CO1lBQW5CZ2Usd0JBQUFoZSxHQUFBRSxHQUFBRixRQUFBRSxZQUFtQjtZQUYzQitkLDRCQUFBamUsR0FBQSxPQUFBQSxNQUEyQjtZQURuQmtlLHNCQUFBbGUsR0FBQSxPQUFBQSxNQUFxQjtZQUFyQm1lLDBCQUFBbmUsR0FBQUUsR0FBQUYsUUFBQUUsWUFBcUI7WUFEckJrZSxTQUFBcGUsR0FBQSxPQUFBQSxNQUFRO1lBQVJxZSxhQUFBcmUsR0FBQUUsR0FBQUYsUUFBQUUsWUFBUTtZQURSb2UsWUFBQXRlLEdBQUEsT0FBQUEsTUFBVztZQUFYdWUsZ0JBQUF2ZSxHQUFBRSxHQUFBRixRQUFBRSxZQUFXO1lBRFhzZSxZQUFBeGUsR0FBQSxPQUFBQSxLQUFXO1lBQVh5ZSxnQkFBQXplLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVc7WUE4Q25Cd2UsdUJBL0NRMWUsR0FBQSxPQUFBQSxLQUFZO1lBQVoyZSxpQkFBQTNlLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVk7WUFMWjBhLDBCQUFBNWEsR0FBQSxPQUFBQSxLQUF5QjtZQUF6QjRlLDhCQUFBNWUsR0FBQUUsR0FBQUYsT0FBQUUsWUFBeUI7WUFEekIyZSx1QkFBQTdlLEdBQUEsT0FBQUEsS0FBc0I7WUFBdEI4ZSwyQkFBQTllLEdBQUFFLEdBQUFGLE9BQUFFLFlBQXNCO1lBRDlCNmUsMEJBQUEvZSxHQUFBLE9BQUFBLEtBQXlCO1lBRHpCZ2Ysa0JBQUFoZixHQUFBLE9BQUFBLEtBQWlCO1lBRGpCaWYscUJBQUFqZixHQUFBLE9BQUFBLEtBQW9CO1lBRFprZixTQUFBbGYsR0FBQSxPQUFBQSxLQUFRO1lBQVJtZixhQUFBbmYsR0FBQUUsR0FBQUYsT0FBQUUsWUFBUTtZQURSa2YsYUFBQXBmLEdBQUEsT0FBQUEsS0FBWTtZQUFacWYsaUJBQUFyZixHQUFBRSxHQUFBRixPQUFBRSxZQUFZO2dCQXNEWkYsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTs7R0FBQTtJQUFBLFVBQUFxYztJQUFBK0M7O3VCQUFBLFNBQWlCOzs7T0FBakJoRDs7Z0JBREF0YyxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGOztHQUFBO0lBQUEsVUFBQXljO0lBQUE4Qzs7dUJBQUEsU0FBbUM7OztPQUFuQy9DOztnQkFEQXhjLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7O0dBQUE7SUFBQSxVQUFBMmM7SUFBQTZDOzt1QkFBQSxTQUFnQjs7O09BQWhCOUM7O2dCQUZBMWMsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUE2YztJQUFBNEM7O3VCQUFBLFNBQTBCOzs7T0FBMUI3Qzs7Z0JBREE1YyxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBO0lBQUEsVUFBQStjO0lBQUEyQyw4QkFBQSxTQUFLLG1CQUFMNUM7Z0JBREE5YyxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBO0lBQUEsVUFBQWlkO0lBQUEwQzs7dUJBQUEsU0FBZ0I7OztPQUFoQjNDOztnQkFEQWhkLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxVQUFBbWQ7SUFBQXlDOzt1QkFBQSxTQUFlOzs7T0FBZjFDOztnQkFKQWxkLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxVQUFBcWQ7SUFBQXdDOzt1QkFBQSxTQUE2Qjs7O09BQTdCekM7O2dCQURScGQsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTs7SUFBQThmOzt1QkFBQSxTQUFhOzs7T0FBYjlUOztnQkFsQlFoTSxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBO0lBQUEsVUFBQXVkO0lBQUF3QzswQkFBQSxTQUFXLHlCQUFYekM7Z0JBREF0ZCxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBO0lBQUEsVUFBQXlkO0lBQUF1Qzs7dUJBQUEsU0FBZ0I7OztPQUFoQnhDOztnQkFEQXhkLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxVQUFBMmQ7SUFBQXNDOzt1QkFBQSxTQUFtQjs7O09BQW5CdkM7O2dCQURBMWQsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUE2ZDtJQUFBcUM7O3VCQUFBLFNBQWU7OztPQUFmdEM7O2dCQUZSNWQsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTs7SUFBQW1nQjs7dUJBQUEsU0FBeUI7OztPQUF6QnJDOztnQkFEUTlkLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxVQUFBZ2U7SUFBQW9DOzt1QkFBQSxTQUFtQjs7O09BQW5CckM7O2dCQUZSL2QsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTs7SUFBQXFnQjs7dUJBQUEsU0FBMkI7OztPQUEzQnBDOztnQkFEUWplLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxVQUFBbWU7SUFBQW1DOzt1QkFBQSxTQUFxQjs7O09BQXJCcEM7O2dCQURBbGUsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUFxZTtJQUFBa0M7MEJBQUEsU0FBUSxzQkFBUm5DO2dCQURBcGUsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUF1ZTtJQUFBaUM7MEJBQUEsU0FBVyx5QkFBWGxDO2dCQURBdGUsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUF5ZTtJQUFBZ0M7MEJBQUEsU0FBVyx5QkFBWGpDO2dCQURBeGUsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUEyZTtJQUFBK0I7O3VCQUFBLFNBQVk7OztPQStDcEJoQzs7Z0JBcERRMWUsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTtJQUFBLFVBQUE0ZTtJQUFBK0I7O3VCQUFBLFNBQXlCOzs7T0FBekIvRjs7Z0JBREE1YSxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBO0lBQUEsV0FBQThlO0lBQUE4Qjs7dUJBQUEsU0FBc0I7OztPQUF0Qi9COztpQkFEUjdlLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7O0lBQUE2Z0I7O3VCQUFBLFNBQXlCOzs7T0FBekI5Qjs7aUJBREEvZSxHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBOztHQUFBOztJQUFBOGdCOzt1QkFBQSxTQUFpQjs7O09BQWpCOUI7O2lCQURBaGYsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7R0FBQTs7SUFBQStnQjs7dUJBQUEsU0FBb0I7OztPQUFwQjlCOztpQkFEUWpmLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxXQUFBbWY7SUFBQTZCOzBCQUFBLFNBQVEsdUJBQVI5QjtpQkFEQWxmLEdBQUFFO0lBQUE7WUFBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7O0dBQUE7SUFBQSxXQUFBcWY7SUFBQTRCOzt1QkFBQSxTQUFZOzs7T0FBWjdCOztZQUpQdk07SUFBQXFPO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFuRztJQUFBb0c7SUFBQTdnQjtJQUFBO0tBQUEsUUFBQSxXQUFBbWYsa0JBSU9ELGdCQUpQbGY7S0FBQUM7S0FBQTZnQjtLQUFBLFVBQUEsV0FBQTFCLGNBS09ILFlBTFBoZjtLQUFBRTtLQUFBNGdCO0tBQUE7T0FBQTtTQUFBMUIsMEJBTURMLHdCQU5DN2U7S0FBQUU7S0FBQTJnQjtLQUFBO09BQUEsV0FBQTFCLHVCQU9EUCxxQkFQQzFlO0tBQUFFO0tBQUEwZ0I7S0FBQTtPQUFBO1NBQUExQjtTQVFEVDtTQVJDdmU7S0FBQUU7S0FBQXlnQjtLQUFBO09BQUE7U0FBQTFCLDRCQVNPWCwwQkFUUHBlO0tBQUFFO0tBQUF3Z0I7S0FBQTtPQUFBO1NBQUExQjtTQVVPYjtTQVZQamU7S0FBQUU7S0FBQXVnQjtLQUFBLFVBQUEsV0FBQTFCLGtCQWVPZixjQWZQOWQ7S0FBQUU7S0FBQXNnQjtLQUFBLFVBQUEsV0FBQTFCLGlCQWdCT2pCLGVBaEJQM2Q7S0FBQStRO0tBQUF3UDtLQUFBLFVBQUEsV0FBQTFCLGlCQWlCT25CLGVBakJQM007S0FBQXlQO0tBQUFDO0tBQUEsVUFBQSxXQUFBM0IsY0FrQk9yQixZQWxCUCtDO0tBQUFFO0tBQUFDO0tBQUE7T0FBQTtTQUFBNUIsMkJBbUJPdkIseUJBbkJQa0Q7S0FBQUU7S0FBQUM7S0FBQTtPQUFBO1NBQUE3QjtTQW9CRHpCO1NBcEJDcUQ7S0FBQUU7S0FBQUM7S0FBQTtPQUFBO1NBQUE5Qix5QkFzQk8zQix1QkF0QlB3RDtLQUFBRTtLQUFBQztLQUFBO09BQUE7U0FBQS9CO1NBdUJEN0I7U0F2QkMyRDtLQUFBRTtLQUFBQztLQUFBO09BQUEsV0FBQWhDLHFCQXlCTy9CLG1CQXpCUDhEO0tBQUFFO0tBQUFDO0tBQUE7T0FBQTtTQUFBakMseUJBMEJPakMsdUJBMUJQaUU7S0FBQUU7S0FBQUM7S0FBQTtPQUFBLFdBQUFsQyxzQkEyQk9uQyxvQkEzQlBvRTtLQUFBRTtLQUFBQztLQUFBLFdBQUEsV0FBQW5DLGlCQTRCT3JDLGVBNUJQdUU7S0FBQUU7S0FBQUM7S0FBQSxXQUFBLFdBQUFwQyxtQkE4Q0R2QyxpQkE5Q0MwRTtLQUFBRTtLQUFBQztLQUFBO09BQUE7U0FBQXJDO1NBK0NPekM7U0EvQ1A2RTtLQUFBRTtLQUFBQztLQUFBO09BQUEsV0FBQXRDLHFCQW1ETzNDLG1CQW5EUGdGO0tBQUFFO0tBQUFDO0tBQUE7T0FBQSxXQUFBdkMsc0JBb0RPN0Msb0JBcERQbUY7S0FBQUU7S0FBQUM7S0FBQSxXQUFBLFdBQUF4QyxXQXFETy9DLFNBckRQc0Y7S0FBQUU7S0FBQUM7S0FBQTtPQUFBO1NBQUF6QztTQXNET2pEO1NBdERQeUY7S0FBQUU7S0FBQUM7S0FBQTtPQUFBLFdBQUExQyxzQkF3RE9uRCxvQkF4RFA0RjtLQUFBRTtLQUFBQztLQUFBO09BQUE7U0FBQS9JO1NBeURPK0M7U0F6RFArRjtLQUFBRTtLQUFBQztLQUFBO09BQUEsV0FBQTdDLHVCQTBET3RELHFCQTFEUGtHO0tBQUFFO0tBQUFDO0lBQUE7cUJBQUEzaUI7YUFBQTtjQUFBb2MsZUFBQSxXQUFBeUQsa0JBQUE3ZjtjQUFBa2MsV0FBQSxXQUFBNEQsY0FBQTlmO2NBQUFpYyx1QkFBQSxXQUFBOEQsMEJBQUEvZjtjQUFBZ2Msb0JBQUEsV0FBQWdFLHVCQUFBaGdCO2NBQUErYjtnQkFBQSxXQUFBa0UsK0JBQUFqZ0I7Y0FBQTZiO2dCQUFBLFdBQUFxRSw0QkFBQWxnQjtjQUFBNFg7Z0JBQUEsV0FBQXVJLCtCQUFBbmdCO2NBQUEwZCxlQUFBLFdBQUEwQyxrQkFBQXBnQjtjQUFBd2IsY0FBQSxXQUFBNkUsaUJBQUFyZ0I7Y0FBQXNiLGNBQUEsV0FBQWlGLGlCQUFBdmdCO2NBQUFvYixXQUFBLFdBQUFxRixjQUFBemdCO2NBQUFrYjtnQkFBQSxXQUFBeUYsMkJBQUEzZ0I7Y0FBQWliO2dCQUFBLFdBQUE0RixnQ0FBQTdnQjtjQUFBK2Esc0JBQUEsV0FBQWdHLHlCQUFBL2dCO2NBQUE4YTtnQkFBQSxXQUFBbUcsK0JBQUFqaEI7Y0FBQTRhLGtCQUFBLFdBQUF1RyxxQkFBQW5oQjtjQUFBMGEsc0JBQUEsV0FBQTJHLHlCQUFBcmhCO2NBQUF3YSxtQkFBQSxXQUFBK0csc0JBQUF2aEI7Y0FBQXNhLGNBQUEsV0FBQW1ILGlCQUFBemhCO2NBQUFnSixnQkFBQSxXQUFBMlksbUJBQUEzaEI7Y0FBQW9hO2dCQUFBLFdBQUF5SCxrQ0FBQTdoQjtjQUFBa2Esa0JBQUEsV0FBQTZILHFCQUFBL2hCO2NBQUFnYSxtQkFBQSxXQUFBaUksc0JBQUFqaUI7Y0FBQThaLFVBQUEsV0FBQXFJLFdBQUFuaUI7Y0FBQTRaO2dCQUFBLFdBQUF5SSxnQ0FBQXJpQjtjQUFBMFosbUJBQUEsV0FBQTZJLHNCQUFBdmlCO2NBQUF3WjtnQkFBQSxXQUFBaUosa0NBQUF6aUI7Y0FBQXNaLG9CQUFBLFdBQUFxSix1QkFBQTNpQjthQUFBO3FCQUFBb2M7cUJBQUFGO3FCQUFBRDtxQkFBQUQ7cUJBQUFEO3FCQUFBRjtxQkFBQWpFO3FCQUFBOEY7cUJBQUFsQztxQkFBQUY7cUJBQUFGO3FCQUFBRjtxQkFBQUQ7cUJBQUFGO3FCQUFBRDtxQkFBQUY7cUJBQUFGO3FCQUFBRjtxQkFBQUY7cUJBQUF0UjtxQkFBQW9SO3FCQUFBRjtxQkFBQUY7cUJBQUFGO3FCQUFBRjtxQkFBQUY7cUJBQUFGO3FCQUFBRjs7WUFBQW9KOztZQUFBRTtJQUFBeEc7SUFBQUY7SUFBQUQ7SUFBQUQ7SUFBQUQ7SUFBQUY7SUFBQWpFO0lBQUE4RjtJQUFBbEM7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQUQ7SUFBQUY7SUFBQUQ7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQUY7SUFBQXRSO0lBQUFvUjtJQUFBRjtJQUFBRjtJQUFBRjtJQUFBRjtJQUFBRjtJQUFBRjtJQUFBRjtJQUFBO1lBQUE4QztZQUFBRjtZQUFBRDtZQUFBRDtZQUFBRDtZQUFBRjtZQUFBakU7WUFBQThGO1lBQUFsQztZQUFBRjtZQUFBRjtZQUFBRjtZQUFBRDtZQUFBRjtZQUFBRDtZQUFBRjtZQUFBRjtZQUFBRjtZQUFBRjtZQUFBdFI7WUFBQW9SO1lBQUFGO1lBQUFGO1lBQUFGO1lBQUFGO1lBQUFGO1lBQUFGO1lBQUFGOztZQUFBdEk7SUFBQWtOO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFuRztJQUFBb0c7SUFBQTtLQUFBLE9BQUEsV0FBQUEsdUJBMERPdEQ7S0ExRFA7T0FBQTtTQUFBOUMsZ0NBeURPK0M7S0F6RFAsT0FBQSxXQUFBb0Qsc0JBd0RPbkQ7S0F4RFA7T0FBQTtTQUFBa0QsZ0NBc0RPakQ7S0F0RFAsT0FBQSxXQUFBZ0QsV0FxRE8vQztLQXJEUCxPQUFBLFdBQUE4QyxzQkFvRE83QztLQXBEUCxPQUFBLFdBQUE0QyxxQkFtRE8zQztLQW5EUDtPQUFBO1NBQUEwQyxnQ0ErQ096QztLQS9DUCxPQUFBLFdBQUF3QyxtQkE4Q0R2QztLQTlDQyxPQUFBLFdBQUFzQyxpQkE0Qk9yQztLQTVCUCxPQUFBLFdBQUFvQyxzQkEyQk9uQztLQTNCUCxPQUFBLFdBQUFrQyx5QkEwQk9qQztLQTFCUCxPQUFBLFdBQUFnQyxxQkF5Qk8vQjtLQXpCUDtPQUFBLFdBQUE4QiwrQkF1QkQ3QjtLQXZCQyxPQUFBLFdBQUE0Qix5QkFzQk8zQjtLQXRCUDtPQUFBO1NBQUEwQixnQ0FvQkR6QjtLQXBCQyxPQUFBLFdBQUF3QiwyQkFtQk92QjtLQW5CUCxPQUFBLFdBQUFzQixjQWtCT3JCO0tBbEJQLE9BQUEsV0FBQW9CLGlCQWlCT25CO0tBakJQLE9BQUEsV0FBQWtCLGlCQWdCT2pCO0tBaEJQLE9BQUEsV0FBQWdCLGtCQWVPZjtLQWZQO09BQUEsV0FBQWMsK0JBVU9iO0tBVlAsT0FBQSxXQUFBWSw0QkFTT1g7S0FUUDtPQUFBLFdBQUFVLCtCQVFEVDtLQVJDLE9BQUEsV0FBQVEsdUJBT0RQO0tBUEMsT0FBQSxXQUFBTSwwQkFNREw7S0FOQyxPQUFBLFdBQUFJLGNBS09IO0lBTFA7WUFBQSxXQUFBRSxrQkFJT0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBSlBoTjtJQUFBaU47SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQW5HO0lBQUFvRztJQUFBLFdBQUExQixrQkFJT0Q7SUFKUCxXQUFBRSxjQUtPSDtJQUxQLFdBQUFJLDBCQU1ETDtJQU5DLFdBQUFNLHVCQU9EUDtJQVBDLFdBQUFRLCtCQVFEVDtJQVJDLFdBQUFVLDRCQVNPWDtJQVRQLFdBQUFZLCtCQVVPYjtJQVZQLFdBQUFjLGtCQWVPZjtJQWZQLFdBQUFnQixpQkFnQk9qQjtJQWhCUCxXQUFBa0IsaUJBaUJPbkI7SUFqQlAsV0FBQW9CLGNBa0JPckI7SUFsQlAsV0FBQXNCLDJCQW1CT3ZCO0lBbkJQLFdBQUF3QixnQ0FvQkR6QjtJQXBCQyxXQUFBMEIseUJBc0JPM0I7SUF0QlAsV0FBQTRCLCtCQXVCRDdCO0lBdkJDLFdBQUE4QixxQkF5Qk8vQjtJQXpCUCxXQUFBZ0MseUJBMEJPakM7SUExQlAsV0FBQWtDLHNCQTJCT25DO0lBM0JQLFdBQUFvQyxpQkE0Qk9yQztJQTVCUCxXQUFBc0MsbUJBOENEdkM7SUE5Q0M7TUFBQXdDLGdDQStDT3pDO0lBL0NQLFdBQUEwQyxxQkFtRE8zQztJQW5EUCxXQUFBNEMsc0JBb0RPN0M7SUFwRFAsV0FBQThDLFdBcURPL0M7SUFyRFAsV0FBQWdELGdDQXNET2pEO0lBdERQLFdBQUFrRCxzQkF3RE9uRDtJQXhEUDtNQUFBaEQsZ0NBeURPK0M7SUFDQSxPQUFBLFdBMURQcUQsdUJBMERPdEQ7O1lBMURQcEw7SUFBQTdRO0lBQUE2ZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBMERPLE9BQUE7YUExRFBBO2FBQUE7ZUFBQXBHO2VBQUE7aUJBQUFtRztpQkFBQTttQkFBQUQ7bUJBQUE7cUJBQUFEO3FCQUFBO3VCQUFBRDt1QkFBQTt5QkFBQUQ7eUJBQUE7MkJBQUFEOzJCQUFBOzZCQUFBRDs2QkFBQTsrQkFBQUQ7K0JBQUE7aUNBQUFEO2lDQUFBO21DQUFBRDttQ0FBQTtxQ0FBQUQ7cUNBQUE7dUNBQUFEO3VDQUFBO3lDQUFBRDt5Q0FBQTsyQ0FBQUQ7MkNBQUE7NkNBQUFEOzZDQUFBOytDQUFBRDsrQ0FBQTtpREFBQUQ7aURBQUE7bURBQUFEO21EQUFBO3FEQUFBRDtxREFBQTt1REFBQUQ7dURBQUE7eURBQUFEO3lEQUFBOzJEQUFBRDsyREFBQTs2REFBQUQ7NkRBQUE7K0RBQUFEOytEQUFBO2lFQUFBRDtpRUFBQSxXQUFBRCxrQkFBQTdkLE1BSU80ZDtpRUFDQUQ7K0RBQ1JEOzZEQUNBRDsyREFDQUQ7eURBQ1FEO3VEQUNBRDtxREFLQUQ7bURBQ0FEO2lEQUNBRDsrQ0FDQUQ7NkNBQ0FEOzJDQUNSRDt5Q0FFUUQ7dUNBQ1JEO3FDQUVRRDttQ0FDQUQ7aUNBQ0FEOytCQUNBRDs2QkFrQlJEOzJCQUNRRDt5QkFJQUQ7dUJBQ0FEO3FCQUNBRDttQkFDQUQ7aUJBRUFEO2VBQ0FEO2FBQ0FEOztZQTFEUG5MLFdBQUE1UTtJQUFBO0tBQUEsV0FBQSxXQUFBQSxXQTBETytiO0tBMURQLFdBQUEsV0FBQS9iLFdBeURPZ2M7S0F6RFAsV0FBQSxXQUFBaGMsV0F3RE9pYztLQXhEUCxXQUFBLFdBQUFqYyxXQXNET2tjO0tBdERQLFdBQUEsV0FBQWxjLFdBcURPbWM7S0FyRFAsV0FBQSxXQUFBbmMsV0FvRE9vYztLQXBEUCxXQUFBLFdBQUFwYyxXQW1ET3FjO0tBbkRQLFdBQUEsV0FBQXJjLFdBK0NPc2M7S0EvQ1AsV0FBQSxXQUFBdGMsV0E4Q0R1YztLQTlDQyxXQUFBLFdBQUF2YyxXQTRCT3djO0tBNUJQLFdBQUEsV0FBQXhjLFdBMkJPeWM7S0EzQlAsV0FBQSxXQUFBemMsV0EwQk8wYztLQTFCUCxXQUFBLFdBQUExYyxXQXlCTzJjO0tBekJQLFdBQUEsV0FBQTNjLFdBdUJENGM7S0F2QkMsV0FBQSxXQUFBNWMsV0FzQk82YztLQXRCUCxXQUFBLFdBQUE3YyxXQW9CRDhjO0tBcEJDLFdBQUEsV0FBQTljLFdBbUJPK2M7S0FuQlAsV0FBQSxXQUFBL2MsV0FrQk9nZDtLQWxCUCxXQUFBLFdBQUFoZCxXQWlCT2lkO0tBakJQLFdBQUEsV0FBQWpkLFdBZ0JPa2Q7S0FoQlAsV0FBQSxXQUFBbGQsV0FlT21kO0tBZlAsV0FBQSxXQUFBbmQsV0FVT29kO0tBVlAsV0FBQSxXQUFBcGQsV0FTT3FkO0tBVFAsV0FBQSxXQUFBcmQsV0FRRHNkO0tBUkMsV0FBQSxXQUFBdGQsV0FPRHVkO0tBUEMsV0FBQSxXQUFBdmQsV0FNRHdkO0tBTkMsV0FBQSxXQUFBeGQsV0FLT3lkO0lBTFAsV0FBQSxXQUFBemQsV0FJTzBkO0dBSk47WUFBRDdNO0lBQUE4TTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQSxPQUFBLFdBQUExQixrQkFJT0Q7S0FKUCxjQUFBLFdBQUFFLGNBS09IO0tBTFA7O1VBQUEsV0FBQUksMEJBTURMOztLQU5DO2NBQUEsV0FBQU0sdUJBT0RQO0tBUEM7O1VBQUE7V0FBQVEsK0JBUURUOztLQVJDOztVQUFBLFdBQUFVLDRCQVNPWDs7S0FUUDs7VUFBQTtXQUFBWSwrQkFVT2I7O0tBVlAsY0FBQSxXQUFBYyxrQkFlT2Y7S0FmUCxjQUFBLFdBQUFnQixpQkFnQk9qQjtLQWhCUCxjQUFBLFdBQUFrQixpQkFpQk9uQjtLQWpCUCxjQUFBLFdBQUFvQixjQWtCT3JCO0tBbEJQOztVQUFBLFdBQUFzQiwyQkFtQk92Qjs7S0FuQlA7O1VBQUE7V0FBQXdCLGdDQW9CRHpCOztLQXBCQzs7VUFBQSxXQUFBMEIseUJBc0JPM0I7O0tBdEJQOztVQUFBO1dBQUE0QiwrQkF1QkQ3Qjs7S0F2QkMsY0FBQSxXQUFBOEIscUJBeUJPL0I7S0F6QlA7O1VBQUEsV0FBQWdDLHlCQTBCT2pDOztLQTFCUCxjQUFBLFdBQUFrQyxzQkEyQk9uQztLQTNCUCxjQUFBLFdBQUFvQyxpQkE0Qk9yQztLQTVCUCxjQUFBLFdBQUFzQyxtQkE4Q0R2QztLQTlDQzs7VUFBQTtXQUFBd0MsZ0NBK0NPekM7O0tBL0NQLGNBQUEsV0FBQTBDLHFCQW1ETzNDO0tBbkRQLGNBQUEsV0FBQTRDLHNCQW9ETzdDO0tBcERQLGNBQUEsV0FBQThDLFdBcURPL0M7S0FyRFA7O1VBQUE7V0FBQWdELGdDQXNET2pEOztLQXREUCxjQUFBLFdBQUFrRCxzQkF3RE9uRDtLQXhEUDs7VUFBQTtXQUFBaEQsZ0NBeURPK0M7O0lBekRQO2NBMERPLFdBMURQcUQsdUJBMERPdEQ7OztZQTFEUGpMO0lBQUE2TTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQSxPQUFBLFdBQUExQixrQkFJT0Q7S0FKUCxlQUFBLFdBQUFFLGNBS09IO0tBTFA7ZUFBQSxXQUFBSSwwQkFNREw7S0FOQyxlQUFBLFdBQUFNLHVCQU9EUDtLQVBDOzs7UUFBQSxXQUFBUSwrQkFRRFQ7S0FSQzs7VUFBQSxXQUFBVSw0QkFTT1g7S0FUUDs7O1FBQUEsV0FBQVksK0JBVU9iO0tBVlAsZUFBQSxXQUFBYyxrQkFlT2Y7S0FmUCxlQUFBLFdBQUFnQixpQkFnQk9qQjtLQWhCUCxlQUFBLFdBQUFrQixpQkFpQk9uQjtLQWpCUCxlQUFBLFdBQUFvQixjQWtCT3JCO0tBbEJQO2VBQUEsV0FBQXNCLDJCQW1CT3ZCO0tBbkJQOzs7UUFBQTtVQUFBd0IsZ0NBb0JEekI7S0FwQkMsZUFBQSxXQUFBMEIseUJBc0JPM0I7S0F0QlA7OztRQUFBLFdBQUE0QiwrQkF1QkQ3QjtLQXZCQyxlQUFBLFdBQUE4QixxQkF5Qk8vQjtLQXpCUCxlQUFBLFdBQUFnQyx5QkEwQk9qQztLQTFCUCxlQUFBLFdBQUFrQyxzQkEyQk9uQztLQTNCUCxlQUFBLFdBQUFvQyxpQkE0Qk9yQztLQTVCUCxlQUFBLFdBQUFzQyxtQkE4Q0R2QztLQTlDQzs7O1FBQUE7VUFBQXdDLGdDQStDT3pDO0tBL0NQLGVBQUEsV0FBQTBDLHFCQW1ETzNDO0tBbkRQLGVBQUEsV0FBQTRDLHNCQW9ETzdDO0tBcERQLGVBQUEsV0FBQThDLFdBcURPL0M7S0FyRFA7OztRQUFBO1VBQUFnRCxnQ0FzRE9qRDtLQXREUCxlQUFBLFdBQUFrRCxzQkF3RE9uRDtLQXhEUDs7O1FBQUE7VUFBQWhELGdDQXlETytDO0lBekRQOztjQTBETyxXQTFEUHFELHVCQTBET3REOztZQTFEUGhMO0lBQUE0TTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQSxXQUFBLFdBQUFBLHVCQTBET3REO0tBMURQOztRQUFBO1VBQUE5QyxnQ0F5RE8rQzs7S0F6RFAsV0FBQSxXQUFBb0Qsc0JBd0RPbkQ7S0F4RFA7O1FBQUE7VUFBQWtELGdDQXNET2pEOztLQXREUCxXQUFBLFdBQUFnRCxXQXFETy9DO0tBckRQLFdBQUEsV0FBQThDLHNCQW9ETzdDO0tBcERQLFdBQUEsV0FBQTRDLHFCQW1ETzNDO0tBbkRQOztRQUFBO1VBQUEwQyxnQ0ErQ096Qzs7S0EvQ1AsV0FBQSxXQUFBd0MsbUJBOENEdkM7S0E5Q0MsV0FBQSxXQUFBc0MsaUJBNEJPckM7S0E1QlAsV0FBQSxXQUFBb0Msc0JBMkJPbkM7S0EzQlA7V0FBQSxXQUFBa0MseUJBMEJPakM7S0ExQlAsV0FBQSxXQUFBZ0MscUJBeUJPL0I7S0F6QlA7O1FBQUEsV0FBQThCLCtCQXVCRDdCOztLQXZCQztXQUFBLFdBQUE0Qix5QkFzQk8zQjtLQXRCUDs7UUFBQTtVQUFBMEIsZ0NBb0JEekI7O0tBcEJDOztRQUFBLFdBQUF3QiwyQkFtQk92Qjs7S0FuQlAsV0FBQSxXQUFBc0IsY0FrQk9yQjtLQWxCUCxXQUFBLFdBQUFvQixpQkFpQk9uQjtLQWpCUCxXQUFBLFdBQUFrQixpQkFnQk9qQjtLQWhCUCxXQUFBLFdBQUFnQixrQkFlT2Y7S0FmUDs7UUFBQSxXQUFBYywrQkFVT2I7O0tBVlA7O1FBQUEsV0FBQVksNEJBU09YOztLQVRQOztRQUFBLFdBQUFVLCtCQVFEVDs7S0FSQyxXQUFBLFdBQUFRLHVCQU9EUDtLQVBDO1dBQUEsV0FBQU0sMEJBTURMO0tBTkMsV0FBQSxXQUFBSSxjQUtPSDtJQUxQLFdBQUEsV0FBQUUsa0JBSU9EOztZQUpQMU07SUFBQWhSO0lBQUEyZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUEsV0FBQTFCLGtCQUlPRCxnQkFKUDFkLFFBQUFBO0lBQUEsV0FBQTRkLGNBS09ILFlBTFB6ZCxRQUFBQTtJQUFBO01BQUE2ZCwwQkFNREwsd0JBTkN4ZCxRQUFBQTtJQUFBLFdBQUE4ZCx1QkFPRFAscUJBUEN2ZCxRQUFBQTtJQUFBO01BQUErZDtNQVFEVDtNQVJDdGQ7TUFBQUE7SUFBQTtNQUFBZ2UsNEJBU09YLDBCQVRQcmQsUUFBQUE7SUFBQTtNQUFBaWU7TUFVT2I7TUFWUHBkO01BQUFBO0lBQUEsV0FBQWtlLGtCQWVPZixjQWZQbmQsUUFBQUE7SUFBQSxXQUFBbWUsaUJBZ0JPakIsZUFoQlBsZCxRQUFBQTtJQUFBLFdBQUFvZSxpQkFpQk9uQixlQWpCUGpkLFFBQUFBO0lBQUEsV0FBQXFlLGNBa0JPckIsWUFsQlBoZCxRQUFBQTtJQUFBO01BQUFzZSwyQkFtQk92Qix5QkFuQlAvYyxRQUFBQTtJQUFBO01BQUF1ZTtNQW9CRHpCO01BcEJDOWM7TUFBQUE7SUFBQTtNQUFBd2UseUJBc0JPM0IsdUJBdEJQN2MsUUFBQUE7SUFBQTtNQUFBeWU7TUF1QkQ3QjtNQXZCQzVjO01BQUFBO0lBQUEsV0FBQTBlLHFCQXlCTy9CLG1CQXpCUDNjLFFBQUFBO0lBQUE7TUFBQTJlLHlCQTBCT2pDLHVCQTFCUDFjLFFBQUFBO0lBQUEsV0FBQTRlLHNCQTJCT25DLG9CQTNCUHpjLFFBQUFBO0lBQUEsV0FBQTZlLGlCQTRCT3JDLGVBNUJQeGMsUUFBQUE7SUFBQSxXQUFBOGUsbUJBOENEdkMsaUJBOUNDdmMsUUFBQUE7SUFBQTtNQUFBK2U7TUErQ096QztNQS9DUHRjO01BQUFBO0lBQUEsV0FBQWdmLHFCQW1ETzNDLG1CQW5EUHJjLFFBQUFBO0lBQUEsV0FBQWlmLHNCQW9ETzdDLG9CQXBEUHBjLFFBQUFBO0lBQUEsV0FBQWtmLFdBcURPL0MsU0FyRFBuYyxRQUFBQTtJQUFBO01BQUFtZjtNQXNET2pEO01BdERQbGM7TUFBQUE7SUFBQSxXQUFBb2Ysc0JBd0RPbkQsb0JBeERQamMsUUFBQUE7SUFBQTtNQUFBaVo7TUF5RE8rQztNQXpEUGhjO01BQUFBO0lBMERPLE9BQUE7YUExRFBxZix1QkEwRE90RCxxQkExRFAvYixRQUFBQTs7WUFBQWlSO0lBQUFqUjtJQUFBRjtJQUFBNmQ7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQW5HO0lBQUFvRzs7WUFBQXJmO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO0lBQUEsT0FBQTthQUFBcWY7YUFBQTtlQUFBcEc7ZUFBQTtpQkFBQW1HO2lCQUFBO21CQUFBRDttQkFBQTtxQkFBQUQ7cUJBQUE7dUJBQUFEO3VCQUFBO3lCQUFBRDt5QkFBQTsyQkFBQUQ7MkJBQUE7NkJBQUFEOzZCQUFBOytCQUFBRDsrQkFBQTtpQ0FBQUQ7aUNBQUE7bUNBQUFEO21DQUFBO3FDQUFBRDtxQ0FBQTt1Q0FBQUQ7dUNBQUE7eUNBQUFEO3lDQUFBOzJDQUFBRDsyQ0FBQTs2Q0FBQUQ7NkNBQUE7K0NBQUFEOytDQUFBO2lEQUFBRDtpREFBQTttREFBQUQ7bURBQUE7cURBQUFEO3FEQUFBO3VEQUFBRDt1REFBQTt5REFBQUQ7eURBQUE7MkRBQUFEOzJEQUFBOzZEQUFBRDs2REFBQTsrREFBQUQ7K0RBQUE7aUVBQUFEO2lFQUFBO21FQUFBRCxrQkFBQTdkLE1BSU80ZCxnQkFKUDFkLFFBQUFBO2lFQUtPeWQ7aUVBTFB6ZDs7K0RBTUR3ZDsrREFOQ3hkOzs2REFPRHVkOzZEQVBDdmQ7OzJEQVFEc2Q7MkRBUkN0ZDs7eURBU09xZDt5REFUUHJkOzt1REFVT29kO3VEQVZQcGQ7O3FEQWVPbWQ7cURBZlBuZDs7bURBZ0JPa2Q7bURBaEJQbGQ7O2lEQWlCT2lkO2lEQWpCUGpkOzsrQ0FrQk9nZDsrQ0FsQlBoZDs7NkNBbUJPK2M7NkNBbkJQL2M7OzJDQW9CRDhjOzJDQXBCQzljOzt5Q0FzQk82Yzt5Q0F0QlA3Yzs7dUNBdUJENGM7dUNBdkJDNWM7O3FDQXlCTzJjO3FDQXpCUDNjOzttQ0EwQk8wYzttQ0ExQlAxYzs7aUNBMkJPeWM7aUNBM0JQemM7OytCQTRCT3djOytCQTVCUHhjOzs2QkE4Q0R1Yzs2QkE5Q0N2Yzs7MkJBK0NPc2M7MkJBL0NQdGM7O3lCQW1ET3FjO3lCQW5EUHJjOzt1QkFvRE9vYzt1QkFwRFBwYzs7cUJBcURPbWM7cUJBckRQbmM7O21CQXNET2tjO21CQXREUGxjOztpQkF3RE9pYztpQkF4RFBqYzs7ZUF5RE9nYztlQXpEUGhjOzthQTBETytiO2FBMURQL2I7OztZQUFBa1I7SUFBQWxSO0lBQUEyZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQSxPQUFBLFdBQUExQixrQkFJT0QsZ0JBSlAxZCxRQUFBQTtLQUFBO2NBQUEsV0FBQTRkLGNBS09ILFlBTFB6ZCxRQUFBQTtLQUFBOztVQUFBO1dBQUE2ZDtXQU1ETDtXQU5DeGQ7V0FBQUE7O0tBQUE7O1VBQUE7V0FBQThkLHVCQU9EUCxxQkFQQ3ZkLFFBQUFBOztLQUFBOztVQUFBO1dBQUErZDtXQVFEVDtXQVJDdGQ7V0FBQUE7O0tBQUE7O1VBQUE7V0FBQWdlO1dBU09YO1dBVFByZDtXQUFBQTs7S0FBQTs7VUFBQTtXQUFBaWU7V0FVT2I7V0FWUHBkO1dBQUFBOztLQUFBOztVQUFBLFdBQUFrZSxrQkFlT2YsY0FmUG5kLFFBQUFBOztLQUFBOztVQUFBLFdBQUFtZSxpQkFnQk9qQixlQWhCUGxkLFFBQUFBOztLQUFBOztVQUFBLFdBQUFvZSxpQkFpQk9uQixlQWpCUGpkLFFBQUFBOztLQUFBO2NBQUEsV0FBQXFlLGNBa0JPckIsWUFsQlBoZCxRQUFBQTtLQUFBOztVQUFBO1dBQUFzZTtXQW1CT3ZCO1dBbkJQL2M7V0FBQUE7O0tBQUE7O1VBQUE7V0FBQXVlO1dBb0JEekI7V0FwQkM5YztXQUFBQTs7S0FBQTs7VUFBQTtXQUFBd2UseUJBc0JPM0IsdUJBdEJQN2MsUUFBQUE7O0tBQUE7O1VBQUE7V0FBQXllO1dBdUJEN0I7V0F2QkM1YztXQUFBQTs7S0FBQTs7VUFBQTtXQUFBMGUscUJBeUJPL0IsbUJBekJQM2MsUUFBQUE7O0tBQUE7O1VBQUE7V0FBQTJlLHlCQTBCT2pDLHVCQTFCUDFjLFFBQUFBOztLQUFBOztVQUFBO1dBQUE0ZSxzQkEyQk9uQyxvQkEzQlB6YyxRQUFBQTs7S0FBQTs7VUFBQSxXQUFBNmUsaUJBNEJPckMsZUE1QlB4YyxRQUFBQTs7S0FBQTs7VUFBQSxXQUFBOGUsbUJBOENEdkMsaUJBOUNDdmMsUUFBQUE7O0tBQUE7O1VBQUE7V0FBQStlO1dBK0NPekM7V0EvQ1B0YztXQUFBQTs7S0FBQTs7VUFBQTtXQUFBZ2YscUJBbURPM0MsbUJBbkRQcmMsUUFBQUE7O0tBQUE7O1VBQUE7V0FBQWlmLHNCQW9ETzdDLG9CQXBEUHBjLFFBQUFBOztLQUFBLGNBQUEsV0FBQWtmLFdBcURPL0MsU0FyRFBuYyxRQUFBQTtLQUFBOztVQUFBO1dBQUFtZjtXQXNET2pEO1dBdERQbGM7V0FBQUE7O0tBQUE7O1VBQUE7V0FBQW9mLHNCQXdET25ELG9CQXhEUGpjLFFBQUFBOztLQUFBOztVQUFBO1dBQUFpWjtXQXlETytDO1dBekRQaGM7V0FBQUE7O0lBQUE7Y0EwRE87ZUExRFBxZix1QkEwRE90RCxxQkExRFAvYixRQUFBQTs7O1lBQUFtUjtJQUFBblI7SUFBQTJkO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFuRztJQUFBb0c7SUFBQTtLQUFBLE9BQUEsV0FBQTFCLGtCQUlPRCxnQkFKUDFkLFFBQUFBO0tBQUEsZUFBQSxXQUFBNGQsY0FLT0gsWUFMUHpkLFFBQUFBO0tBQUE7OztRQUFBO1VBQUE2ZCwwQkFNREwsd0JBTkN4ZCxRQUFBQTtLQUFBOzs7UUFBQTtVQUFBOGQsdUJBT0RQLHFCQVBDdmQsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQStkO1VBUURUO1VBUkN0ZDtVQUFBQTtLQUFBOzs7UUFBQTtVQUFBZ2U7VUFTT1g7VUFUUHJkO1VBQUFBO0tBQUE7OztRQUFBO1VBQUFpZTtVQVVPYjtVQVZQcGQ7VUFBQUE7S0FBQTtlQUFBLFdBQUFrZSxrQkFlT2YsY0FmUG5kLFFBQUFBO0tBQUE7ZUFBQSxXQUFBbWUsaUJBZ0JPakIsZUFoQlBsZCxRQUFBQTtLQUFBO2VBQUEsV0FBQW9lLGlCQWlCT25CLGVBakJQamQsUUFBQUE7S0FBQSxlQUFBLFdBQUFxZSxjQWtCT3JCLFlBbEJQaGQsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQXNlO1VBbUJPdkI7VUFuQlAvYztVQUFBQTtLQUFBOzs7UUFBQTtVQUFBdWU7VUFvQkR6QjtVQXBCQzljO1VBQUFBO0tBQUE7OztRQUFBO1VBQUF3ZSx5QkFzQk8zQix1QkF0QlA3YyxRQUFBQTtLQUFBOzs7UUFBQTtVQUFBeWU7VUF1QkQ3QjtVQXZCQzVjO1VBQUFBO0tBQUE7OztRQUFBLFdBQUEwZSxxQkF5Qk8vQixtQkF6QlAzYyxRQUFBQTtLQUFBOzs7UUFBQTtVQUFBMmUseUJBMEJPakMsdUJBMUJQMWMsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQTRlLHNCQTJCT25DLG9CQTNCUHpjLFFBQUFBO0tBQUE7ZUFBQSxXQUFBNmUsaUJBNEJPckMsZUE1QlB4YyxRQUFBQTtLQUFBOztVQUFBLFdBQUE4ZSxtQkE4Q0R2QyxpQkE5Q0N2YyxRQUFBQTtLQUFBOzs7UUFBQTtVQUFBK2U7VUErQ096QztVQS9DUHRjO1VBQUFBO0tBQUE7OztRQUFBLFdBQUFnZixxQkFtRE8zQyxtQkFuRFByYyxRQUFBQTtLQUFBOzs7UUFBQTtVQUFBaWYsc0JBb0RPN0Msb0JBcERQcGMsUUFBQUE7S0FBQSxlQUFBLFdBQUFrZixXQXFETy9DLFNBckRQbmMsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQW1mO1VBc0RPakQ7VUF0RFBsYztVQUFBQTtLQUFBOzs7UUFBQTtVQUFBb2Ysc0JBd0RPbkQsb0JBeERQamMsUUFBQUE7S0FBQTs7O1FBQUE7VUFBQWlaO1VBeURPK0M7VUF6RFBoYztVQUFBQTtJQUFBOztjQTBETztlQTFEUHFmLHVCQTBET3RELHFCQTFEUC9iLFFBQUFBOztZQUFBb1I7SUFBQXBSO0lBQUEyZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQTs7UUFBQTtVQUFBQSx1QkEwRE90RCxxQkExRFAvYixRQUFBQTs7S0FBQTs7UUFBQTtVQUFBaVo7VUF5RE8rQztVQXpEUGhjO1VBQUFBOztLQUFBOztRQUFBO1VBQUFvZixzQkF3RE9uRCxvQkF4RFBqYyxRQUFBQTs7S0FBQTs7UUFBQTtVQUFBbWY7VUFzRE9qRDtVQXREUGxjO1VBQUFBOztLQUFBLFdBQUEsV0FBQWtmLFdBcURPL0MsU0FyRFBuYyxRQUFBQTtLQUFBOztRQUFBO1VBQUFpZixzQkFvRE83QyxvQkFwRFBwYyxRQUFBQTs7S0FBQTs7UUFBQSxXQUFBZ2YscUJBbURPM0MsbUJBbkRQcmMsUUFBQUE7O0tBQUE7O1FBQUE7VUFBQStlO1VBK0NPekM7VUEvQ1B0YztVQUFBQTs7S0FBQTs7UUFBQSxXQUFBOGUsbUJBOENEdkMsaUJBOUNDdmMsUUFBQUE7O0tBQUE7O1FBQUEsV0FBQTZlLGlCQTRCT3JDLGVBNUJQeGMsUUFBQUE7O0tBQUE7O1FBQUE7VUFBQTRlLHNCQTJCT25DLG9CQTNCUHpjLFFBQUFBOztLQUFBOztRQUFBO1VBQUEyZSx5QkEwQk9qQyx1QkExQlAxYyxRQUFBQTs7S0FBQTs7UUFBQSxXQUFBMGUscUJBeUJPL0IsbUJBekJQM2MsUUFBQUE7O0tBQUE7O1FBQUE7VUFBQXllO1VBdUJEN0I7VUF2QkM1YztVQUFBQTs7S0FBQTs7UUFBQTtVQUFBd2UseUJBc0JPM0IsdUJBdEJQN2MsUUFBQUE7O0tBQUE7O1FBQUE7VUFBQXVlO1VBb0JEekI7VUFwQkM5YztVQUFBQTs7S0FBQTs7UUFBQTtVQUFBc2U7VUFtQk92QjtVQW5CUC9jO1VBQUFBOztLQUFBO1dBQUEsV0FBQXFlLGNBa0JPckIsWUFsQlBoZCxRQUFBQTtLQUFBOztRQUFBLFdBQUFvZSxpQkFpQk9uQixlQWpCUGpkLFFBQUFBOztLQUFBOztRQUFBLFdBQUFtZSxpQkFnQk9qQixlQWhCUGxkLFFBQUFBOztLQUFBOztRQUFBLFdBQUFrZSxrQkFlT2YsY0FmUG5kLFFBQUFBOztLQUFBOztRQUFBO1VBQUFpZTtVQVVPYjtVQVZQcGQ7VUFBQUE7O0tBQUE7O1FBQUE7VUFBQWdlO1VBU09YO1VBVFByZDtVQUFBQTs7S0FBQTs7UUFBQTtVQUFBK2Q7VUFRRFQ7VUFSQ3RkO1VBQUFBOztLQUFBOztRQUFBO1VBQUE4ZCx1QkFPRFAscUJBUEN2ZCxRQUFBQTs7S0FBQTs7UUFBQTtVQUFBNmQsMEJBTURMLHdCQU5DeGQsUUFBQUE7O0tBQUEsV0FBQSxXQUFBNGQsY0FLT0gsWUFMUHpkLFFBQUFBO0lBQUE7WUFBQSxXQUFBMmQsa0JBSU9ELGdCQUpQMWQsUUFBQUE7OztZQUFBcVI7SUFBQXJSO0lBQUEyZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBbkc7SUFBQW9HO0lBQUE7S0FBQTtPQUFBO1NBQUFBLHVCQTBET3RELHFCQTFEUC9iLFFBQUFBO0tBQUE7T0FBQTtTQUFBaVo7U0F5RE8rQztTQXpEUGhjO1NBQUFBO0tBQUE7T0FBQTtTQUFBb2Ysc0JBd0RPbkQsb0JBeERQamMsUUFBQUE7S0FBQTtPQUFBO1NBQUFtZjtTQXNET2pEO1NBdERQbGM7U0FBQUE7S0FBQSxPQUFBLFdBQUFrZixXQXFETy9DLFNBckRQbmMsUUFBQUE7S0FBQTtPQUFBO1NBQUFpZixzQkFvRE83QyxvQkFwRFBwYyxRQUFBQTtLQUFBO09BQUEsV0FBQWdmLHFCQW1ETzNDLG1CQW5EUHJjLFFBQUFBO0tBQUE7T0FBQTtTQUFBK2U7U0ErQ096QztTQS9DUHRjO1NBQUFBO0tBQUEsT0FBQSxXQUFBOGUsbUJBOENEdkMsaUJBOUNDdmMsUUFBQUE7S0FBQSxPQUFBLFdBQUE2ZSxpQkE0Qk9yQyxlQTVCUHhjLFFBQUFBO0tBQUE7T0FBQTtTQUFBNGUsc0JBMkJPbkMsb0JBM0JQemMsUUFBQUE7S0FBQTtPQUFBO1NBQUEyZSx5QkEwQk9qQyx1QkExQlAxYyxRQUFBQTtLQUFBO09BQUEsV0FBQTBlLHFCQXlCTy9CLG1CQXpCUDNjLFFBQUFBO0tBQUE7T0FBQTtTQUFBeWU7U0F1QkQ3QjtTQXZCQzVjO1NBQUFBO0tBQUE7T0FBQTtTQUFBd2UseUJBc0JPM0IsdUJBdEJQN2MsUUFBQUE7S0FBQTtPQUFBO1NBQUF1ZTtTQW9CRHpCO1NBcEJDOWM7U0FBQUE7S0FBQTtPQUFBO1NBQUFzZTtTQW1CT3ZCO1NBbkJQL2M7U0FBQUE7S0FBQSxPQUFBLFdBQUFxZSxjQWtCT3JCLFlBbEJQaGQsUUFBQUE7S0FBQSxPQUFBLFdBQUFvZSxpQkFpQk9uQixlQWpCUGpkLFFBQUFBO0tBQUEsT0FBQSxXQUFBbWUsaUJBZ0JPakIsZUFoQlBsZCxRQUFBQTtLQUFBLE9BQUEsV0FBQWtlLGtCQWVPZixjQWZQbmQsUUFBQUE7S0FBQTtPQUFBO1NBQUFpZTtTQVVPYjtTQVZQcGQ7U0FBQUE7S0FBQTtPQUFBO1NBQUFnZTtTQVNPWDtTQVRQcmQ7U0FBQUE7S0FBQTtPQUFBO1NBQUErZDtTQVFEVDtTQVJDdGQ7U0FBQUE7S0FBQTtPQUFBO1NBQUE4ZCx1QkFPRFAscUJBUEN2ZCxRQUFBQTtLQUFBO09BQUE7U0FBQTZkLDBCQU1ETCx3QkFOQ3hkLFFBQUFBO0tBQUEsT0FBQSxXQUFBNGQsY0FLT0gsWUFMUHpkLFFBQUFBO0lBQUE7WUFBQSxXQUFBMmQsa0JBSU9ELGdCQUpQMWQsUUFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBQUFzUjtJQUFBdFI7SUFBQTZiO0lBQUFGO0lBQUFMO0lBQUFqRTtJQUFBOEY7SUFBQWxDO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFIO0lBQUFIO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUFGO0lBQUEsSUFBQXBZLFdBQUEsNkJBQUFYO0lBQUFXLGNBQUFrYjtJQUFBbGIsY0FBQWdiO0lBQUFoYixjQUFBMmE7SUFBQTNhLGNBQUEwVztJQUFBMVcsY0FBQXdjO0lBQUF4YyxjQUFBc2E7SUFBQXRhLGVBQUFvYTtJQUFBcGEsZUFBQWthO0lBQUFsYSxlQUFBZ2E7SUFBQWhhLGVBQUE2WjtJQUFBN1osZUFBQTBaO0lBQUExWixlQUFBd1o7SUFBQXhaLGVBQUFzWjtJQUFBdFosZUFBQW9aO0lBQUFwWixlQUFBa1o7SUFBQWxaLGVBQUFnWjtJQUFBaFosZUFBQThZO0lBQUE5WSxlQUFBNFk7SUFBQTVZLGVBQUEwWTtJQUFBMVksZUFBQXdZO0lBQUF4WSxlQUFBc1k7SUFBQXRZLGVBQUFvWTs7R0FBQztHQUFEO0lBQUE7O09BQUEvSDtPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztPQUFBQztJQUFBOztPQUFBbEk7T0EwRE8yUztPQURBQztPQURBQztPQUZBQztPQURBQztPQURBQztPQURBQztPQUpBQztPQURSQztPQWxCUUM7T0FEQUM7T0FEQUM7T0FEQUM7T0FGUkM7T0FEUUM7T0FGUkM7T0FEUUM7T0FEQUM7T0FEQUM7T0FEQUM7T0FEQUM7T0FMQUM7T0FEQUM7T0FEUkM7T0FEQUM7T0FEQUM7T0FEUUM7T0FEQUM7T0FKUHBPO09BQUErUztPQUFBNVI7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7O1lBQUx0SDtJQTBEWTtLQXREQTZZO0tBQ0FDO0tBR1JDO0tBREFDO0tBREFDO0tBR1FDO0tBQ0FDO0tBS0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ1JDO0tBRVFDO0tBQ1JDO0tBRVFDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBa0JSQztLQUtRQztLQUNBQztLQUNBQztLQUNBQztLQUVBQztLQUNBN0s7S0FDQThLO0tBQUFDLFVBQUEsc0JBQUFEO0tBMURaRSxpQ0EwRFlEO0tBREFFO09BQUEsc0NBQUFqTDtLQXpEWmtMLG1DQXlEWUQsZUF6RFpEO0tBd0RZRyxVQUFBLHNCQUFBTjtLQXhEWk8sbUNBd0RZRCxlQXhEWkQ7S0FzRFlHO09BQUEsbUNBQUFUO0tBdERaVSxtQ0FzRFlELGVBdERaRDtLQXFEWUcsVUFBQSxtQ0FBQVo7S0FyRFphLG1DQXFEWUQsZUFyRFpEOzt5Qjs7O0lBb0RZO0tBQUFHLFVBQUEsNEJBQUFmO0tBcERaZ0IsbUNBb0RZRCxlQXBEWkQ7O3lCOzs7SUFtRFk7S0FBQUcsVUFBQSw0QkFBQWxCO0tBbkRabUIsbUNBbURZRCxlQW5EWkQ7d0I7SUErQ1k7S0FBQUc7S0EvQ1pDLG1DQStDWUQsZUEvQ1pEO0tBOENJRztPQUFBOzs7U0FBQXZCO0tBOUNKd0IsbUNBOENJRCxlQTlDSkQ7S0E0QllHO09BQUE7MkRBQUExQjtLQTVCWjJCLG1DQTRCWUQsZUE1QlpEO0tBMkJZRyxVQUFBLGdDQUFBN0I7S0EzQlo4QixtQ0EyQllELGVBM0JaRDtLQTBCWUcsVUFBQSxzQkFBQWhDO0tBMUJaaUMsb0NBMEJZRCxlQTFCWkQ7S0F5QllHLFVBQUEsZ0NBQUFuQztLQXpCWm9DLG9DQXlCWUQsZUF6QlpEO0tBdUJJRztPQUFBOzs7O1NBQUF0QztLQXZCSnVDLG9DQXVCSUQsZUF2QkpEO0tBc0JZRztPQUFBLDhDQUFBekM7S0F0QlowQyxvQ0FzQllELGVBdEJaRDtLQW9CSUc7T0FBQTs7OztTQUFBNUM7S0FwQko2QyxvQ0FvQklELGVBcEJKRDtLQW1CWUc7T0FBQTs0Q0FBQS9DO0tBbkJaZ0Qsb0NBbUJZRCxlQW5CWkQ7S0FrQllHLFVBQUEsc0JBQUFsRDtLQWxCWm1ELG9DQWtCWUQsZUFsQlpEO0tBaUJZRyxVQUFBLHFDQUFBckQ7S0FqQlpzRCxvQ0FpQllELGVBakJaRDtLQWdCWUcsVUFBQSxzQkFBQXhEO0tBaEJaeUQsb0NBZ0JZRCxlQWhCWkQ7OztNQWU0Qkc7TUFBQUM7TUFBQUMsbUNBQUFEO01BQUFFLHFDQUFBSDtvQkFBQUUsY0FBQUM7O0lBQWhCO0tBQUFDLFVBQUEsNEJBQUEvRDtLQWZaZ0Usb0NBZVlELGVBZlpMO0tBVVlPO09BQUE7NENBQUFsRTtLQVZabUUsb0NBVVlELGVBVlpEO0tBU1lHO09BQUE7NENBQUFyRTtLQVRac0Usb0NBU1lELGVBVFpEO0tBUUlHO09BQUE7OztTQUFBMUU7S0FSSjJFLG9DQVFJRCxlQVJKRDtLQU9JRyxVQUFBLHNDQUFBM0U7S0FQSjRFLG9DQU9JRCxlQVBKRDtLQU1JRyxVQUFBLHNDQUFBNUU7S0FOSjZFLG9DQU1JRCxlQU5KRDtLQUtZRyxVQUFBLHFDQUFBakY7S0FMWmtGLG9DQUtZRCxlQUxaRDs7eUI7OztJQUlZO0tBQUFHLFVBQUEsNEJBQUFwRjtLQUpacUYsb0NBSVlELGVBSlpEO0lBQUEsV0FBQUU7O1lBZ0VJQyxlQUFhL3NCO0lBQ2YsV0FEZUE7ZUFFTDt5QkFDR29CLGlCQUFMNE07OztNQUMwRGdmO01BQUFDO01BQUFDLG1DQUFBRDtNQUFBRSxxQ0FBQUg7b0JBQUFFLGNBQUFDOztJQUFoRTtZQUFLOzs7OztrQkFEQ25mLEtBQUs1TTs7R0FDcUU7WUFHaEZnc0IsaUJBQWlCcHRCO0lBQ3VCLFdBQUEsc0NBRHZCQTtJQUNuQixPQUFBLHNDQURtQkE7R0FDMkQ7WUFHNUU2SyxhQUFhN0s7SUFFYixXQUFBLHVDQUZhQTtJQUNmLE9BQUEsdUNBRGVBO0dBRTZCO1lBRzFDcXRCLHNCQUFvQnJ0QixHQUFJLE9BQUpBLE1BQXlCO1lBRTdDc3RCLHFCQUFzQjVhLE9BQWU2YSxPQUFNQztJQU03QyxjQUM4QzVvQixLQUFJNm9CO21CQUNyQkM7b0JBTk1DLEdBQUssV0FBSSxXQUZwQmpiLE9BRVdpYixHQUtlRixHQUxLO01BQS9DO09BQUEsT0FBQSwyQkFNcUJDOztPQUp6QkU7a0JBRFM7VUFDRGhzQjtNQUFLLFdBQUssc0JBQWxCZ3NCLEdBQVFoc0I7S0FJZ0M7S0FBcEIsT0FBQSw0QkFEc0JnRDtJQUNEO0lBRDNDLFdBQUEsMEJBUHFDMm9CLFdBQU1DO0lBTzNDLE9BQUE7R0FDNkM7WUFHN0NLLDJCQUEyQkMsT0FBTUM7SUFHcUIsV0FBQSw2QkFIM0JEO0lBR3RCLEdBZExSLHNDQVdpQ1M7SUFHbkMsTUFBQTtHQUFrRjtZQUdoRjdWLFlBQVVsWTtJQUNaO0tBaUNTO01BaENIaU07aUJBQU1DLEdBQUU4aEI7U0FBUSxPQUFFLFdBQVo5aEIsR0FBWSwwQkFBVjhoQixPQUZGaHVCO1FBRStCOzRCOzRCOzRCOzRCOzRCOzRCOzRCOzRCOzRCOztpQkFnQ2dDMEo7U0FDL0QsR0FBTywwQkFuQ1AxSixNQWtDK0QwSjtTQUMvRCxNQUFBO1FBQTZDO01BRGhELE9BQUE7TUFESCxzQixPQS9CQXVDOzRCOztpQkE2QllxVDtTQUF1QixHQUFPLG1DQUE5QkE7O1NBQXVCLE1BQUE7UUFBaUM7TUFBcEUsc0IsT0E3QkFyVDs0Qjs7aUJBd0JZeVQ7U0FDVCxPQWpDUG1PLDJCQWdDZ0JuTywyQkExQk4xZjtRQTJCdUU7TUFEN0Usc0IsT0F4QkFpTTs0Qjs7aUJBa0JZNFQ7U0FDVCxPQTNCUGdPLDJCQTBCZ0JoTyw2QkFwQk43ZjtRQXVCc0I7TUFINUIsc0IsT0FsQkFpTTs0Qjs0Qjs0Qjs7aUJBYXVCbVU7U0FBZSxHQUFPLG1DQUF0QkE7U0FBZSxNQUFBO1FBQXlCO01BQXBELHNCLE9BYlhuVTs7aUJBV1lxVztTQUNOLFdBQUEsc0JBRE1BO1NBQ04sV0FBQTtTQUFrQyxXQTFDNUM4SyxpQkE0QlVwdEI7U0FjaUMsR0FBQTtTQUFQLE1BQUE7UUFBK0I7TUFEL0Qsc0IsT0FYQWlNO01BV0E7TUFGeUIsc0IsT0FUekJBO01BU3lCO01BREgsc0IsT0FSdEJBOztpQkFPWWdpQjtTQUFLLGtDQUFMQTtRQUF1RDtNQUFuRSxzQixPQVBBaGlCO01BT0E7TUFGaUIsc0IsT0FMakJBO01BS2lCO01BREcsc0IsT0FKcEJBO01BSW9CO01BRFosc0IsT0FIUkE7NEI7TUFDSjtRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FBQTs7VUEyQ0E4Qjs7TUFBQUMsMEJBQUFEO21DQWpKSmEsWUFtR2M1Tzt5REE4Q1ZnTzs7Ozs7Ozs7O1lBR0FrZ0IsU0FBU2x1QixHQUFFMEosS0FBTSxPQUFBLDJCQUFSMUosTUFBRTBKLEtBQThCO1lBRXpDb0QsUUFBUTlNLEdBQUdrSyxtQkFBeUNnQyxHQUFFVTtJQUdyRCxXQUFBLHNCQUhPNU07SUFHUDtLQUdELElBRElrSCxXQUxPZ0Qsc0JBTVBpa0IsWUFEQWpuQixXQUxJbEgsT0FBQUE7S0FXUixzQ0FMSW11QixXQU5PamtCLG1CQUF5Q2dDLEdBQUVVO2lCQUE5QzVNO21CQWNEb3VCLGdCQUFLLE9BQUEsV0FBTEEsS0FUSGxuQjs7Ozs7SUFRTTtHQUNhO1lBR3ZCbW5CLFlBQVlydUIsR0FBRTBKLEtBQUt3a0I7SUFDckI7S0FBSXBOLFdBRFU5Z0I7S0FNWixPQUFBLDJCQUxFOGdCLFVBRFlwWDtLQUtkLE9BQUEsMkJBSkVvWCxVQURZcFg7SUFqQmRvRDtNQWlCWTlNO01BSVosMkJBSEU4Z0IsVUFEWXBYOzs7V0FBS3drQixXQU9KLDJCQVBIbHVCLE1BQUUwSixPQUFLd2tCO0dBT29CO1lBR3ZDMWEsYUFBYzBMLGFBQThDblY7SUFDOUQ7S0FDT3VKLElBQUssdURBRmtEdko7S0FLckRxRjtPQUZBLHVEQURGa0UsR0FGdUR2SjtXQUV2RHVKO2NBWkwrYSxZQVVjblAsZ0JBS1A5UDtjQUFTO21EQUxGOFAsYUFLUDlQO0dBQXVEO1lBRzlEa2Y7SUFDUTtLQUFOM1gsTUFBTTtLQUNGM1c7S0FpQ0prZjtLQUZBbFYsU0FDRixxREFqQ0UyTTs7OztLQTBCNkIsT0FBQTtLQURyQixPQUFBO0tBQUE7O3dCO0lBSlE7S0FBQSxPQUFBO0tBRkcsT0FBQTtLQUZELE9BQUE7O0tBRFU7T0FBQTs7S0FGRTtPQUFBOzs7S0FSRixPQUFBO0tBRFIsT0FBQTtLQURHLE9BQUE7O01BSG5CM1c7OztPQUVPOzs7Ozs7OztPQUhYMlc7Ozs7Ozs7OztPQWtDQXVJOzs7Ozs7Ozs7OztrQkFLb0JyTztLQUFTLE9BaEQvQjJDO2NBMkNFMEwsYUFLc0QsK0JBUHREbFYsUUFPb0I2RztJQUE0RDs7Ozs7TUFMaEZxTzs7T0FDSzs7O09BSExsVjs7Ozs7T0EvQkloSztJQTZDUixPQTdDUUE7O1lBZ0ROdXVCLFFBQVF2dUIsR0FBSSw2QkFBSkEsTUFBMEI7WUFDbEN3dUIsbUJBQWlCeHVCLEdBQUVrTSxHQUFGbE0sT0FBRWtNLFlBQXVCO0dBR3RDLFlBQUEsNEJBdERKb2lCOztRQXVER3R1QixjQUZIeXVCLFlBRUd6dUI7O1FBQ0dnTztJQUNOOzhEQURNQTtRQUhOeWdCLFFBS0E7O1lBR0FDLGVBQWExdUI7SUFDZixZQURlQTtnQkFFTDtRQUNIa007SUFBSyxPQUFBLFdBQUxBO0dBQVM7WUFHZDlGLFdBQ0YsSUFBSXBHLElBZkZ5dUIsVUFRQUMsZUFPRTF1QixJQUNKLE9BRElBLEVBRUg7WUFHQzJ1Qiw0QkFBMEIzdUI7SUFDNUIsT0FENEJBLHVEQUFBQSxRQUFBQTtHQUdJO1lBRzlCNHVCLHdCQUF3QjV1QixHQUFFNnVCLGFBQWEzaUIsR0FBRXVoQjtJQUN6QixJQUFkcUIsY0FQRkgsNEJBTXdCM3VCO0lBRTFCLGtDQUYwQkEsR0FBRTZ1Qjs7S0FHSyxPQURqQyxrQ0FGMEI3dUIsR0FDdEI4dUI7SUFFZ0U7SUFBN0MsT0FBQSxzQkFIa0I1aUIsR0FBRXVoQjtHQUcwQjtZQUduRXNCLHVCQUF1Qi91QixHQUFFNnVCLGFBQWEzaUI7SUFBSSxPQU4xQzBpQix3QkFNdUI1dUIsR0FBRTZ1QixhQUFhM2lCO0dBQStDO1lBRXJGOGlCLFdBQW9CaHZCLEdBQUVrSyxtQkFBa0JnQyxHQUFFVTtJQUM1QyxHQUFHLDJCQURtQjVNO0tBQUFBLE9BQ3dCLDhCQUR4QkE7SUFFdEIsT0FBQSwyQkFGc0JBLE1BQUVrSyxtQkFBa0JnQyxHQUFFVTtHQU14QjtZQUdsQnFpQixpQkFBaUJqdkIsR0FBRWdPLEtBQUk1TTtJQUN6QixHQTFVRU07S0EwVVk7Ozs7VUFBb0R3dEI7VUFBQUM7VUFBQUMsbUNBQUFEO1VBQUFFLHFDQUFBSDt3QkFBQUUsY0FBQUM7O0tBQXBEO3lEQURPcmhCLEtBQUk1TTs7SUFFekI7d0JBRm1CcEIsVUFBQUE7SUFBQUEsZUFBRWdPLEtBQUk1TTs7R0FHUztZQUtoQ2t1QixZQUFZdHZCLEdBQUd1dkI7SUFDVCxJQUFKaGlCLElBQUksc0NBRFNnaUI7SUFFakIsc0NBRmN2dkIsTUFDVnVOO0lBQ0osT0FBQSxzQ0FGY3ZOLE1BQ1Z1TjtHQUVvRDtZQU1sRE0sU0FBUzdOO0lBQ2Y7S0FBTSxJQUNKd3ZCLElBREksc0NBRFN4dkIsTUFBQUE7Y0FFYnd2QixNQUFnQixPQUFoQkE7S0FFTyxJQUNKQyxNQURJLHNDQUpNenZCLE1BQUFBO2NBS1Z5dkIsUUFBZ0IsT0FBaEJBO0tBR0c7O09BREEsc0NBUE96dkI7WUFRUCxzQ0FST0E7TUFVTDs7R0FBTTtZQUdkMHZCLFVBQVUxdkI7SUF0QlZzdkIsWUFzQlV0dkIsR0FJUjtJQUNFLFlBbEJBNk4sU0FhTTdOO3VCQU1EO1FBQ0ZnTztJQUFvQixXQUFwQkE7R0FBNkI7WUFHcEMyaEIsbUJBQ0lDLEtBQ0RqWjtJQUdMLEdBSk1pWjtTQUFzQkMsTUFBdEJELFFBQUFFLHNCQUFzQkQ7O1NBQXRCQztJQUlFO0tBQUo5dkIsSUExRUZvRztLQTJFRTRELFNBQVMsNEJBTFA4bEIscUJBQ0RuWjtLQUtHdUk7O2tCQUtnQnJPO0tBQVMsT0E1Si9CMkM7Y0F1Sk0wTCxhQUtrRCwrQkFOdERsVixRQU1vQjZHO0lBQTREOzs7OztNQUw1RXFPOztPQUNDOzs7T0FGTGxWOzs7OztPQURBaEs7SUFjSixPQVpRa2Y7R0FZRztZQUdUNlE7SUFBa0QsV0EzRmxEM3BCO0lBMkZrRCxPQUFBO0dBQWtCOzs7Ozs7Ozs7O09BdllwRTFFOzs7O09BMEdRd2M7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FGQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FKQUM7T0FBQUM7T0FEUnJSO09BbEJRc1I7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUU7T0FEQUM7T0FBQUM7T0FGUkM7T0FEUUM7T0FBQUM7T0FGUkM7T0FEUUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUM7T0FBQUM7T0FEQUU7T0FMQUM7T0FEQUM7T0FBQUM7T0FEUkM7T0FEQUM7T0FEQUM7T0FEUUM7T0FBQUM7O09BTFpuUztPQThESTBSO09BRUF5TTtPQU9BSztPQUlBdmlCO09BS0F3aUI7T0FFQUM7T0FXQU87T0FNQTNWO09BaURBZ1c7T0FFQXBoQjtPQWlCQXVoQjtPQVVBN2E7T0FRQThhO09Ba0RBQztPQUNBQztPQUVBQztPQVFBQztPQU1BdG9CO09BTUF1b0I7T0FNQUM7T0FNQUc7T0FFQUM7T0FTQUM7T0FRQUs7T0FTSXpoQjtPQWFKNmhCO09BVUFDO09Bc0JBSTs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDOVZFQyxTQUFxQ0MsT0FBU3hDLEdBQVR3QyxXQUFTeEM7WUFDOUN5QyxTQUFxQ0QsT0FBU3hDLEdBQVR3QyxXQUFTeEM7WUFFOUM1b0IsT0FBT3NyQixLQUFJam1CO0lBb0JULElBRkFsSyxRQWxCS213QixLQUFJam1CO0lBSFg4bEIsU0FxQkVod0IsR0FBQUE7SUFwQkZrd0IsU0FvQkVsd0IsR0FBQUE7SUFLSixPQUxJQTtHQU1IO1lBR0Nvd0IsUUFBUUMsTUFBS0Msb0JBQW1CQyxNQUFLQztJQWdCdkM7S0FBSTlnQixTQWhCTTJnQixNQUFLQztLQXdCWDNnQixTQXhCOEI0Z0IsTUFBS0Msb0JBZ0JuQzlnQixJQUFBQTtJQTlDRnNnQixTQThDRXRnQixJQVFBQztJQXJERnVnQixTQTZDRXhnQixJQVFBQztJQUtKLE9BYklEO0dBY0Y7WUFnQkF2RixPQUFPbks7SUFDVCxJQUFJdU4sWUFDQTNMLFFBRks1Qjs7S0FHQyxHQUFBLHNCQURONEIsTUFGSzVCLFdBQ0x1TjtLQUFBQTtLQUNBM0wsT0FBQUE7O0dBS0Y7WUFHQWtMLFFBQVE5TSxHQUFFME4sV0FBVTVMO0lBQUksT0FBQSx3Q0FBZDRMLFdBQUYxTixNQUFBQSxNQUFZOEI7R0FBK0Q7WUFFbkYydUIsY0FBY3p3QixHQUFFOEI7SUFDRixJQUFaNEwsWUFBWTtJQUhkWixRQUVjOU0sR0FDWjBOLFdBRGM1TDtJQUdWLElBQUpGLFFBSFk1Qjs7S0FJTixHQUFBLHNCQURONEIsTUFIWTVCO0tBRmQ4TSxRQUtFbEwsTUFGQThMLFdBRGM1TDtLQUdkRixPQUFBQTs7R0FJQTtZQVVGOHVCLElBQUkxd0IsR0FBRW13QixLQUFJam1CO0lBRWlCLElBRHpCaEssYUFESWl3QixLQUFJam1CLG1CQUFObEssTUFBQUE7SUF4R0prd0IsU0F3R0lsd0IsTUFDRkU7SUExR0Y4dkIsU0F5R0lod0IsR0FDRkU7SUFJSixPQUpJQTtHQUtFO1lBbUJKeXdCLFFBQVEvQztJQUNWLEtBRFVBLEdBRUY7SUFFTTtLQUNNRixNQUxWRTthQUFBQTtLQUdGMWpCO0tBQUxpbUI7S0FFWVMsUUFwSWIvckIsT0FrSUNzckIsS0FBS2ptQjtLQUVPa1AsT0FBQXdYO0tBQUtDLE1BQUFuRDtJQUNoQjtVQURnQm1ELEtBdklsQmIsU0F1SWFZLE9BQUF4WCxPQVdiLFdBWGF3WDtLQUtvQjtNQUxmRSxNQUFBRDtnQkFBQUE7TUFHUjFmO01BQUw0ZjtNQUhRQyxhQUdSRCxPQUFLNWYscUJBSEdpSSxNQUFBd1g7S0F0SWJWLFNBc0lhOVcsTUFBQTRYO1NBQUE1WCxPQUFBNFgsUUFBS0gsTUFBQUM7O0dBV1I7WUFHVnhyQixRQUFRc3JCO0lBQ1YsSUFBYTNxQixNQURIMnFCLFVBQ0c1d0IsSUFBQWlHLEtBQUVyQjtJQUNiO0tBQVUsSUFER3FzQixnQkFBRmp4QixNQUFBQSxPQUFFNEU7S0FFVixHQUFBLHNCQUZRNUUsR0FESDR3QixRQUdtQixPQUZkSztLQUU0QixJQUY5QjdxQixNQUFBcEcsTUFBQUEsSUFBQW9HLEtBQUV4QixNQUFBcXNCOztHQUlLO1lBR2xCM3ZCLGlCQUFhdEI7SUFDZixJQUEyQ2tLLG9CQUQ1QmxLOzs7Ozs0REFDNEJrSzs7R0FHUztZQU9wRGduQixnQkFDQXpELEdBQXNDLE9BQXRDQSxFQUF1QztZQUd2Qy9hLE1BQU90TSxLQUFTcEcsR0FBSyxPQUFBLHNCQUFkb0csS0FBU3BHLEdBQW9CO1lBQ3BDbXhCLE1BQU1ueEIsR0FBSSxlQUFKQSxJQUFzQjs7Ozs7O1lBTzVCb3hCLE9BY0VDO0lBQ0YsY0FERUE7O0tBR0EsSUFETUMsa0JBRUhDLFVBRkdEO2VBRUhDLDhCQUFBQTtVQWpCY0MsTUFpQmREOzs7V0FYVUosUUFXVkksU0FqQmN2eEIsSUFBQXd4QjtPQUVuQjtZQUZhQyxVQUFNenhCO2tCQUFOeXhCO2lCQUFBQTtZQUFNcnJCLE1BQU5xckIsWUFNRU4sUUFORk0sU0FBTXp4QixJQUFBb0c7OztVQU1OSCxNQU9Yb3JCO01BTkY7bUJBRGFwckI7O1lBQUF5ckI7UUFBQXpyQixTQUFFa3JCO1lBQUZsckIsTUFBQXlyQjs7O09BS04sT0FMTXpyQjs7O0tBWUgsT0FIRnFyQjs7SUFJRCxPQU5MRDtHQU1NO1lBS1J6b0IsVUFBVStvQixhQUFZM3hCO0lBQ3hCLElBQUlvRyxNQTFCRmdyQixPQXlCc0JweEIsSUFRdEI0eEIsVUFQRXhyQjtjQU9Gd3JCLHNCQUhTO1dBR1RBOztPQXJKQSw4Q0FxSkFBO09BcEpRLElBQUpod0IsUUFvSkpnd0I7O1FBbkpVLEdBQUEsc0JBRE5od0IsTUFvSkpnd0I7WUFsSk1saUIsS0FGRjlOO1FBR0ssS0FBQSxzQkFESDhOLFVBQUFBO1NBQ0osTUFBQTtRQUNBLDhDQUZJQTtRQUZGOU4sT0FBQUE7Ozs7V0FrSmtCc0ksb0JBRXRCMG5CO09BREEsT0FBQSw4Q0FEc0IxbkI7O1dBRmpCMEMsSUFJTGdsQixZQUpVLE9BQUEsV0FKQUQsYUFJTC9rQjtlQURNLE1BQUE7O0dBS3lEO1lBR3BFb1IsWUFBVTFkLFdBQVVOO0lBQ3RCLElBQUlvRyxNQXJDRmdyQixPQW9Db0JweEIsSUFFdEIsUUFESW9HOzs7O1lBR0d3RztRQUFLLHdCQUFvQixXQUpwQnRNLFdBSUxzTTs7UUFETSxNQUFBOztJQUVtRDtHQUFZO1lBRzFFaWxCLEtBQUs3eEI7SUFDUCxJQUFJb0csTUE3Q0ZnckIsT0E0Q0tweEIsSUFFUCxRQURJb0c7Ozs7WUFHR3dHLGNBQUssV0FBTEE7O1FBRE0sTUFBQTs7SUFFbUQ7R0FBSTtZQUdsRWtsQixNQUFNOXhCLEdBQUcreEI7SUFDWCxJQUFJM3JCLE1BckRGZ3JCLE9Bb0RNcHhCLElBRVIsUUFESW9HOzs7O1lBR0d3RyxjQUFLLE9BQUxBOztRQURNLE1BQUE7O0lBR1gsT0FBQSxvQkFOU21sQjtHQU1zQjtZQUcvQjloQixVQUFValEsR0FBSSxPQVRkOHhCLE1BU1U5eEIsbUNBQXlFO1lBRW5GZ3lCLFNBQVNoeUI7SUFDWCxJQUFJb0csTUFoRUZnckIsT0ErRFNweEIsSUFFWCxNQURJb0c7Ozs7UUFHUTs7UUFEQyxNQUFBOztJQUVtRDtHQUFJO1lBR2xFNnJCLFFBQVFqeUIsR0FBSSxXQVJaZ3lCLFNBUVFoeUIsR0FBb0I7WUFFNUJreUIsS0FBS2x5QixHQUFFOEI7SUFDVCxJQUc0RHVFLFFBN0UxRCtxQixPQXlFS3B4QixJQVNMNHhCLFVBTDBEdnJCO2NBSzFEdXJCO1lBQUFBOztRQUwwRHZyQixlQUpuRHZFLElBV1AsT0FoTEUydUIsY0E4S0ZtQixTQVRPOXZCOztZQU1pQm9JLG9CQUd4QjBuQixZQUhtQnpCLE1BR25CeUI7UUFMMER2ckIsZUFKbkR2RTtRQVFZLFVBQUE7UUFBbkIsT0FBQTtpQkFBVztpQkFGYW9JO2lCQUFMaW1CO2lCQU5acnVCOztRQUlHO1NBQUE7Ozs7Ozs7a0JBekNWa2MsNEIsY0F5QzBEM1g7Ozs7Ozs7OztRQUQvQyxNQUFBOztJQUMrQ0EsZUFKbkR2RTs7R0FXd0I7WUFHL0Jxd0IsZUFBZW55QixHQUFHNHhCO0lBQ3BCLFNBN1FpRG5FLE87SUE0UTdCbUUsYUE1UTZCbkU7SUE4UXpDLElBQUpybkIsTUF6RkZnckIsT0F1RmVweEIsSUFZZjBkLE9BVkV0WDtjQVVGc1g7WUFBQUE7O1FBQ0csR0E5TTZCLHNCQWlNZGtVLFNBQUFBLGFBRWhCeHJCO1FBY0csR0FBQSxzQkFoQmF3ckIsU0FZbEJsVSxPQVZFdFgsU0FGZ0J3ckI7UUEzUWhCNUIsU0EyUWdCNEIsWUFBQUE7UUExUWhCMUIsU0EwUWdCMEIsWUFBQUE7UUEzUWhCNUIsU0EyUWdCNEIsU0FBQUE7UUF0S2xCLE9BcEdFMUIsU0EwUWdCMEIsU0FBQUE7O1FBV2xCOztRQVBXLE1BQUE7O0lBR1g7R0FVeUI7WUFHekJRLFlBQVlweUIsR0FBRW13QixLQUFJam1CO0lBQ3BCLElBQUk5RCxNQTVHRmdyQixPQTJHWXB4QixJQVlaNHhCLFVBWEV4ckI7Y0FXRndyQjtZQUFBQTs7UUFBMkMsT0FsTXpDbEIsSUFrTUZrQixTQVpjekIsS0FBSWptQjs7UUFTSjtTQURXaUgsc0JBSXpCeWdCO1NBSm1CYixRQUluQmE7U0FISVM7V0ExUUZqQyxRQWlRWUQsS0FBSWptQixtQkFRQzZtQixPQUFNNWY7UUFQdkIvSyxTQVFFaXNCO1FBRUosT0FGSUE7O1FBS1U7U0FEVHZ3QixJQURMOHZCO1NBRUlVLFlBMVNGenRCLE9BNFJZc3JCLEtBQUlqbUI7U0FpQmRxb0IsaUJBQUl6d0IsR0FBSSxPQUFBLFdBSFJ3d0IsY0FHSXh3QixHQUF5QjtTQUNkLE1BQUE7UUFBbkI7VUFBVztVQWxCT29JO1VBaUJkcW9CO1VBSkN6d0I7UUFLTCxPQUpJd3dCOztRQVhPLE1BQUE7O0lBRUcsSUFBVkUsWUFqU0YzdEIsT0E0UllzckIsS0FBSWptQjtJQUNoQjlELFNBSUVvc0I7SUFFSixPQUZJQTtHQWNHO1lBR1BDLGFBQWF6eUI7SUFDZixJQUFJb0csTUFsSUZnckIsT0FpSWFweEIsSUFFZixNQURJb0c7Ozs7UUFFUyxNQUFBOztnQkFDMkM7O0lBQ3BDO0dBQUs7WUFHdkJzc0IsS0FBTTF5QixHQUFFbXdCO0lBQTZELFVBQUE7SUFBMUIsT0E5QjNDaUMsWUE4Qk1weUIsR0FBRW13QixLQUFtQztHQUFpQztZQVc1RXdDLE9BQUszeUIsR0FBRW13QjtJQUNUO0tBQUl6aUIsWUFBWTtLQUNaeEQsb0JBQW9CLHdDQURwQndEO0tBRUF0SCxNQXZKRmdyQixPQW9KS3B4QjtLQVdMNHhCLFVBUkV4ckI7Y0FRRndyQjtZQUFBQTs7UUExT0VsQixJQTBPRmtCLFNBWE96QixLQUVMam1CLG9CQVVNOztZQUppQmlILHNCQUd6QnlnQixZQUhtQmIsUUFHbkJhO1FBUkV4ckIsU0E3U0FncUIsUUEwU0tELEtBRUxqbUIsbUJBTWlCNm1CLE9BQU01Zjs7O1lBRnBCclAsSUFLTDh2QjtRQUxVLE9BQUE7O2lCQUxSbGtCO2lCQUNBeEQ7aUJBRktpbUI7aUJBTUZydUI7O1FBRE0sTUFBQTs7SUFGVHNFLGFBSEsrcEIsS0FFTGptQjs7R0FVOEQ7WUE0QmhFMG9CLFFBbUJHQyxhQUFhQztJQUNULGNBQUEsc0JBREpELGFBQWFDO2NBQ1Q7SUFFYSxJQWpCZUMsZ0JBak1uQzNCLE9BK01HeUIsY0FkeUIxQixZQUFPNEI7Ozs7OztVQUFiQyxPQWNORjs7TUFiaEI7V0FrQk1HLG9CQW5CZ0JEO09BRXRCLFVBaUJNQztPQWpCTixPQWlCTUE7Ozs7Y0FuQmdCQyxTQW1CaEJEO1VBbkJnQkQsVUFBTTdCO2NBQU42QixPQUFBRTs7Ozs7OztZQVdiLHNCQVhhRixNQUFhRCxnQkFBYkMsVUFBTTdCOztJQXNCMUIsSUFXRXpoQixLQWpDK0JxakI7Ozs7O2dCQWlDL0JyakI7Y0FBQUE7O29CQWRFdWpCO2lCQUFBQTs7YUE5UU0sSUFBUkUsUUE0UkF6akIsT0EzUkEwakIsUUE2UUVIO2FBdllKL0MsU0F5SEVpRCxPQThRRUY7YUF2WUovQyxTQTBIRWtELE9BMlJBMWpCO2FBdFpGc2dCLFNBc1pFdGdCLElBM1JBMGpCO2FBR0osT0E5SEVwRCxTQXdZSWlELG1CQTlRRkU7OztjQW9TMkIzQyxxQkF0QnpCeUM7Y0FzQm1CMUMsT0F0Qm5CMEM7YUEvUkp2QyxJQTZTRWhoQixJQVFxQjZnQixNQUFNQzthQUNuQjs7aUJBVHdDMXVCLElBZDlDbXhCO2FBbkI2QkYsbUJBbUI3QkU7YUFnQkYsT0FoVUZ4QyxjQThURS9nQixJQUFnRDVOOzs7O2NBSHhCb0ksb0JBR3hCd0YsT0FIbUJ5Z0IsTUFHbkJ6Z0I7b0JBZEV1akI7aUJBQUFBOzthQTBCYSxJQUFYSSxXQXpUTjNDLElBK1JJdUMsbUJBV2lCOUMsS0FBS2ptQjthQTlCTzZvQixtQkE2QzNCTTs7O2FBUFc7Y0FEWUMsdUJBbEJ6Qkw7Y0FrQm1CTSxTQWxCbkJOO2NBbUJFTztnQkE3WE5wRCxRQXFYcUJELEtBQUtqbUIsbUJBT0hxcEIsUUFBTUQ7YUFyQ0lQLG1CQXNDM0JTOzs7aUJBUjZDQyxNQVgvQ1I7YUFuQjZCRixtQkFtQjdCRTthQWFpQixVQUFBO2FBQW5CLE9BQUE7c0JBQVc7c0JBRmEvb0I7c0JBQUxpbUI7c0JBQThCc0Q7Ozs7OztnQkFYL0NSLHdDQUFBQTs7Z0JBY0Z2akI7TUFOYSxNQUFBOztLQUpjLE1BQUE7O2tCQUp6QnVqQjs7ZUFuQjZCRixtQkFtQjdCRTtHQTZCaUY7Ozs7Ozs7O09BN012RmpWO09BWEFwVjs7OztPQW1CQWlwQjtPQWlCQTVoQjtPQVRBNmhCO09BV0FFO09BUUFDO09BL0VBdmY7T0FvTUFrZ0I7T0FuSEFWO1dBaEdFNXdCLFdBakZBNkksUUFzREF3bUIsU0FtQkFyckI7T0FtQkY0ckI7T0F1SEFrQjtPQXBCQUQ7T0EwQ0FNO09BbUJBRTtPQVhBRDtPQWhKQXZCO09BT0FDOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ3pNQXNDLFFBQWtCVixNQUF5QixPQUF6QkEsS0FBdUM7WUFFekRwcUIsVUFBVStxQixhQUFZM3pCO0lBQUksT0FBMkIsa0NBQTNDMnpCLGFBQVkzekI7R0FBMEM7WUFDaEVzQixVQUFVaEIsV0FBVU47SUFBSSxPQUF5QixrQ0FBdkNNLFdBQVVOO0dBQXdDO1lBQzVENnhCLEtBQUs3eEIsR0FBSSxPQUFVLGtDQUFkQSxHQUF5QjtZQUM5QjR6QixTQUFPaG5CLEdBQUksT0FBUSxrQ0FBWkEsR0FBZ0M7WUFDdkNpbkIsY0FBYzd6QixHQUFJLE9BQWEsbUNBQWpCQSxHQUE0QjtZQUUxQ2lRLFVBQVVqUTtJQUNaLE9BQUE7b0NBRFlBO0dBR2tFO1lBRzVFMHlCLEtBQUsxeUIsR0FBRWtNLEdBQUksT0FBQSxtQ0FBTmxNLEdBQUVrTSxHQUEyQjtZQUVsQ3JILE9BQU9xSDtJQUNJLElBQVRoTSxTQUFTO0lBQ2IsV0FGU2dNLEdBQ0xoTTtJQUNKLE9BRElBO0dBRVU7WUFJWjR6QixLQUFLOXpCLEdBQUdrTTtJQUNRLElBQWQybUIsY0FBYztJQVZoQkg7TUFTSzF5QjtlQUVLNE07T0FBa0QsVUFBQSxXQUZwRFYsR0FFRVU7T0FBeUMsT0FBQSxtQ0FEakRpbUI7TUFDZ0U7SUFBcEUsT0FESUE7R0FFZTtZQUdqQlQsWUFBWXB5QixHQUFFa00sR0FBRWhDO0lBQW9CLE9BQUEsbUNBQXhCbEssR0FBRWtNLEdBQUVoQztHQUFvRTtZQUNwRmlvQixlQUFlbnlCLEdBQUUrekI7SUFBSSxPQUFBLG1DQUFOL3pCLEdBQUUrekI7R0FBcUM7Ozs7Ozs7O09BM0J0RHp5QjtPQURBc0g7T0FGQThxQjtPQWdCQTd1QjtPQVpBZ3RCO09BSUE1aEI7T0FGQTRqQjtPQURBRDtPQVNBbEI7T0FTQW9COztPQU1BMUI7T0FDQUQ7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3REQTZCOzs7WUFDQUMsY0FBY2owQixHQUFFOEI7SUFBTyxVQUFBLHFCQUFUOUI7SUFBUyxhQUFnQixpQkFBekJBLEdBQUU4QjtHQUErQjtZQVF6Q295QixXQUFXbDBCLEdBQUksT0FBQSxpQkFBSkEsR0FBVTtZQUVyQm0wQjtJQUFhLFlBQ0wsT0FBQTtRQUNIdm5CO0lBQUssT0FBQSx3QkFBTEE7R0FBa0I7Ozs7Ozs7Ozs7OztZQUp2QnNuQixZQUVBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BVk5GOzs7T0FEQUQ7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQ0tKLFNBQUFJO0lBQUE7UUFDRUM7a0RBQUFBO0dBTWtCOzs7Ozt5Q0FQcEJEOzs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNGSUU7SUFBcUIsVUFBQTtJQUFBLE9BQUE7R0FBZ0I7R0FhM0I7Ozs7O0lBQU54dkI7OztnQkFSSTlFLEdBQUdrTTtRQUdJLElBQVRoTSxTQUFTO1FBQ2I7O1VBSk1GO21CQUlNNE07V0FBc0IsVUFBQSxXQUp6QlYsR0FJR1U7V0FBc0IsT0FBQSxrQ0FEOUIxTTtVQUNtQztRQUF2QyxPQUFBLHNCQURJQTtPQUVVO3NEQUdaNEU7Ozs7Ozs7O0lBaUJKeXZCOzs7O0lBS0VDOzs7Ozs7SUFLRUM7SUFIYyxtREFHZEE7SUFSWSxnREFHZEQ7SUFlRkUsT0FBTztZQUVQQyxPQUFLamxCLElBQUdDO0lBQ1YsT0FBTzs7c0JBQUt6UDtjQUFVLE9BQVE7O3VCQUR2QndQO2dDQUM0QmtsQjt3QkFBTSxPQUFROztpQ0FEdkNqbEI7MENBQzRDa2xCO2tDQUFNLE9BQWlCO2tFQUFqRTMwQixZQUF1QjAwQixJQUFtQkM7aUNBQStCO3VCQUFDO2FBQUM7R0FBQztHQUczRTs7O0lBQUEsK0NBSlhGO1lBYUFHLHNCQUE4QixTQUFFO1lBSzlCdGUsYUFBbUJ1ZTtRQUFSQyxlQUFIaDFCO0lBQWdCLFdBQWhCQSxZQUEwQnl0QixHQUFLLE9BQUcsV0FBdkJzSCxJQUF1QixXQUEvQkMsSUFBdUJ2SCxJQUFjOztHQUh0QyxpQkFHVmpYO1lBU0l5ZTtJQUFVO0lBQUE7bUJBQ1A7U0FDV0MsbUJBQVR0RCxzQkFBSDV4QjtLQUNOLDJCQURNQSxHQUFHNHhCO21CQUFTc0Q7O0dBRU47R0FWRSxxQkFNVkQ7WUFRTkUsT0FBT24xQixHQUFFa00sR0FBSSxXQUFObE0sR0FBRWtNLEdBQW1CO1lBRTVCa3BCLFFBQVFDO0lBQ1YsSUFBSW4xQixTQUFTLHNDQUNUbzFCO2FBQ0FDO0tBQ0MsVUFBQSxrQ0FIRHIxQjtLQUdDLFVBQUE7S0FFRCwwQkFKQW8xQjs7bUJBT3dDcHZCO09BQUwsSUFBc0JnRyxjQUFIbE0sY0FDekMsUUFBQSxpQkFEeUNBO21CQUVyQyxPQUZ1QmtHO1dBRzFCcEU7T0FBSyxXQUFBLFdBSHNDb0ssR0FHM0NwSyxJQUgwQm9FO01BR1g7TUFIekIsVUFBQSwwQkFURW12QjtNQVNGLE9BQUE7S0FHMEI7S0FMYixPQUFBLGtDQU5qQm4xQjtJQVdnQztJQUV5QjtLQUFBLE1BQUE7S0FBekRnSyxvQkFBK0I7aUJBRWV0RjtLQUFMLElBQW9CNUU7S0FDL0Q7YUFEK0RBO2FBQ3REOzJDQURzREEsR0FiN0R1MUIsT0FXQXJyQjthQUU4Q3RGO0lBQ2U7SUFmN0Qwd0IsaUJBY0QsMEJBaEJPRDtJQWtCVixPQUFBLGtDQWpCSW4xQjtHQWlCWTtZQUdWczFCLGNBQWNIO0lBQ3BCLElBRG9CSSxZQUFBSjtJQUNwQjtVQURvQkk7TUFFWixNQUFBO0tBRUM7TUFKV0MsWUFBQUQ7Y0FBQUE7TUFHTHZwQjtNQUFIbE07TUFDSCxVQUFBLGlCQURHQTtxQkFHRjhCLGdCQUFLLE9BQUEsV0FIQW9LLEdBR0xwSztTQU5VMnpCLFlBQUFDOztHQU1EO1lBR2pCQyxPQUFPTjtJQUNULElBQUluMUIsU0FBUyxzQ0FDVG8xQjthQUNBQztLQUNDLFVBQUEsa0NBSERyMUI7S0FHQyxVQUFBO0tBRUQsMEJBSkFvMUI7S0FLaUIsVUFoQmZFLGNBU0dIO0tBT1ksT0FBQSxrQ0FOakJuMUI7SUFNeUM7SUFFZ0I7S0FBQSxNQUFBO0tBQXpEZ0ssb0JBQStCO2lCQUVldEY7S0FBTCxJQUFvQjVFO0tBQy9EO2FBRCtEQTthQUN0RDsyQ0FEc0RBLEdBUjdEdTFCLE9BTUFyckI7YUFFOEN0RjtJQUNlO0lBVjdEMHdCLGlCQVNELDBCQVhNRDtJQWFULE9BQUEsa0NBWkluMUI7R0FZWTtZQUdkMDFCLE1BQU1DLElBQUczcEI7aUJBQWdDbE0sR0FBSyxXQUFMQSxHQUFoQ2tNLEdBQStDO0lBQXBDLE9BaEJwQnlwQixPQWdCb0IsMEJBQWRFO0dBQW9EO1lBQzFEQyxJQUFJRCxJQUFLLE9BRFRELE1BQ0lDLGtCQUFLLGNBQWM7WUFDdkJFLFNBQVNGLElBQUssT0FGZEQsTUFFU0Msa0IsWUFBd0M7WUFFakRHLE1BQUszWSxPQUFPdE8sSUFBS2tuQjthQUNYQyxLQUFLeHZCO0tBQ1gsR0FBRyxxQkFEUUEsR0FEQ3FJLEtBR1AsT0FBQTt5QkFHSCxPQUxJbW5CLEtBQUt4dkIsV0FLRztLQURFLFVBQUEsV0FMQ3V2QixNQUNOdnZCOztJQUtJO0lBRWpCLE9BUFF3dkIsS0FERDdZO0dBUUc7WUFHUjhZLHNCQUFzQkMsT0FBTWxxQjtJQUM5QixPQUFPOztzQkFBS21xQjt1QkFDRkgsS0FBS0U7O2dCQUVQO3FCQUNNQTtpQkFBUyxPQUhiRixLQUdJRTs7b0JBQ0VsMkI7Z0JBQVUsT0FBQSxrQ0FMZG0yQixVQUtJbjJCO2VBQW1DO2VBSC9DLFVBQUEsV0FIMEJnTSxHQUVma3FCO2VBRVAsT0FBQTtjQUUyQztxQkFKekNGLEtBRmNFO2FBUVo7R0FBQztZQUdYRSxRQUFRRixPQUFNbHFCO0lBQ2hCO0tBQUE7S0FBQTtPQVpFaXFCO1NBV1FDO2tCQUN1QkE7dUJBQ3ZCQSxPQUNSLHNCQURRQSxPQUNLO1VBREcsVUFBQSxXQUZGbHFCLEdBQ2lCa3FCOzs7SUFBakMsT0FBQTtHQUdpQjtHQUduQixJQUFBaEM7WUFLSXB2QixLQUFLaEYsR0FBR2lGLE1BQU1pSDtJQUNoQixPQUFPOztzQkFBS2hNO3VCQUNGZzJCLEtBQUtsMkIsR0FBRXUyQjtlQUNiLEtBRFd2MkIsR0FFSCxPQUFBLGtDQUhBRSxRQUNLcTJCO21CQUdOQyxLQUhJeDJCLE1BR1R5dEIsSUFIU3p0Qjs0QkFHZ0J1MkIsR0FBSyxPQUgxQkwsS0FHQ00sSUFBb0JELEdBQWM7ZUFBNUIsVUFBQSxXQUxEcnFCLEdBRUNxcUIsR0FHWDlJO2VBQXFCLE9BQUE7Y0FBa0I7cUJBSG5DeUksS0FGSGwyQixHQUFHaUY7YUFPRztHQUFDO1lBR1p3eEIsT0FBT3oyQixHQUFHa007SUFBSTtLQUFBO0tBQUE7T0FWZGxIO1NBVU9oRjs7a0JBQStCMDJCLElBQUc5cEI7dUJBQWlCMnBCLEdBQUssV0FBTEEsR0FBcEJHLElBQWdDO1VBQXhCLFVBQUEsV0FBcEN4cUIsR0FBK0JVO1VBQWEsT0FBQTtTQUFnQjtJQUF4RCxPQUFBO0dBQXNFO1lBQ3BGK3BCLElBQUlDLElBQUssT0FEVEgsT0FDSUcsa0JBQUssY0FBa0I7WUFDM0JDLFNBQVNELElBQUssT0FaZDV4QixLQVlTNHhCLHVCQUFpQ0UsR0FBSyxPQUFMQSxFQUFNLEdBQUM7WUFDakRDLEdBQUd0SjtJQUFJLGFBQVVBLEdBQUssV0FBTEEsR0FBUztJQUFiLE9BQUEscUJBQVZBO0dBQXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMUwxQjZHOzs7Ozs7Ozs7T0E4QkFDOztPQW9CQUc7T0FFQUM7O09BYUFHOzs7T0FzQkFLO09BRUFDO09BcUJJSTtPQVNKRztPQWdCQUM7T0FDQUU7T0FDQUM7T0FFQUM7T0FXQUc7T0FXQUc7T0FPSmxDO09BS0lwdkI7T0FVQXl4QjtPQUNBRTtPQUNBRTtPQUNBRTs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3pMQW5EOztJQUpBdUI7SUFDQVE7SUFDQWI7SUFDQVI7SUFFQTVCOzs7Ozs7Ozs7Ozs7O09BTEF5QztPQUNBUTtPQUNBYjtPQUNBUjtPQUNBVjtPQUNBbEI7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0RKcHhCLFVBQUswMUIsVUFBTEM7O0ssWUFIRTtLQURBO01BQUFDO01BQUFDLFdBQUEsaUNBSUdILFVBSkhFO0tBQUEsd0JBQUFDOztJQUlGLE9BQUEsMkJBQUFGO0dBQXlDO1lBRXJDcnVCLGlCQUFZNUk7O0tBRVosWUFGWUE7aUJBR0Y7U0FDRmd6QjtLQUFlLEdBQUEsa0NBQWZBO0tBQVEsTUFBQTtJQUEyQjtpQkFISm9FO0ssT0FIM0M5MUIsMEIsY0FHMkM4MUI7O0lBQUssT0FBQSxtQ0FEaENwM0I7R0FJZ0M7WUFHNUM2RTtJQUNGLElBQUltdUIsT0FBTyxzQ0FDUGh6QixZQURBZ3pCO0lBRUosV0FESWh6QixHQUNELGtDQUZDZ3pCO0dBRWE7WUFHZmhCLFNBQVNoeUIsR0FDWCxPQURXQSxhQUdJO1lBR2JreUIsS0FBS2x5QixHQUFFNE07SUFDVCxZQURPNU07O1NBRUMwRztLQUZEMUc7S0FJTCxPQUFBLGtDQUZNMEcsR0FGQ2tHOzs7OztHQUsrQzs7Ozs7OztVQTFCMUR0TCxXQUVJc0gsV0FPQS9ELFFBTUFtdEIsVUFNQUU7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNsQkU1d0IsVUFBVWhCLFdBQ0NOO0lBQWIsSUFBYTgyQixJQUFBOTJCLEdBQUVrRztJQUNiO0tBQU0sWUFBQSxzQ0FESzR3QjtpQkFFRCxXQUFLLG1DQUZGNXdCOzttQkFHQyxXQUFLLDBCQUhOQTtLQUlrQjtNQUpwQkU7TUFJR3dHO01BSkR6RyxXQUltQixXQUx0QjdGLFdBS0lzTSxJQUpEMUc7TUFBRjR3QixJQUFBMXdCO01BQUVGLEtBQUFDOztHQU1OO1lBR1ArUyxLQUFLbFosR0FBSSxPQUFKQSxFQUFLO0dBakJBLGlCQU9Wc0IsV0FVQTRYO1lBT0Y4RSxtQkFBWWhlO0lBQ0w7O09BQUEsa0NBREtBOzs7SUFDZDtHQUFzRTtZQUdwRTZFLGNBQVksV0FBUyxzQ0FBZ0I7WUFDckN3eUIsUUFBUXIzQixHQUFJLE9BQVUsa0NBQWRBLE1BQXNCO1lBQzlCczNCLFVBQVV0M0IsR0FBSSxPQUFhLGtDQUFqQkEsTUFBeUI7WUFFbkN1M0IsU0FBU3YzQixHQUFFOEI7SUFDYixLQUhFdzFCLFVBRVN0M0IsSUFDb0QsT0FBQSxrQ0FEcERBLE1BQUU4Qjs7O0dBQ3NFO1lBR2pGMDFCLFVBQVV4M0IsR0FBSSxPQUpkdTNCLFNBSVV2M0IsTUFBa0I7WUFDNUJ5M0IsY0FBY3ozQjtJQUFXLGNBUHpCczNCLFVBT2N0M0I7aUJBQThCLGtDQUE5QkE7R0FBb0Q7WUFFbEUwM0IsT0FBTzEzQixHQUFFOEI7SUFDQSxJQUFQb1gsT0FBTztJQVJUcWUsU0FPT3YzQixPQUFFOEIsR0FFVSxrQ0FEakJvWDtJQURLbFosT0FDTGtaOztHQUVVOzs7Ozs7OztPQWxCWjhFO09BSUFuWjtPQVdBNnlCO09BSEFGO09BQ0FDO09BUEFIOztPQURBRDs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQzJESWxKO0lBQ0F3SjtJQUNBQztJQUNBendCO0lBQ0Ewd0I7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXRGSmx2QixVQUFVNUk7O0tBR1Ysb0I7eUI7eUI7eUI7Y0FEVWtNLEVBTWdCN0o7TUFBYyxHQUFPLGtDQUFyQkE7TUFBYyxNQUFBO0tBQWlDO0tBTjNELFdBQUEsOEJBRkpyQyxHQUVBa007eUI7eUI7eUI7S0FLSSxPQUFBOztJQUlVO0lBVmtCLE9BQUEsbUNBRGhDbE07R0FXZTtZQUd6QndjO0lBQW9FLFdBQUE7SUFBQSxPQUFBO0dBQU87WUFDM0VyRjtJQUF1QyxXQUR2Q3FGO0lBQ3VDLE9BQUE7R0FBOEI7WUFLckV1YixPQUFPLzNCLEdBQUFBLG1CQUE0QjtZQU9uQ2c0Qix1QkFBdUJoNEIsR0FBR2tNO0lBUDFCNnJCLE9BT3VCLzNCO0lBRVQ7S0FBWjBOLFlBQVk7S0FDWnhELG9CQUFvQix3Q0FEcEJ3RDtLQUVBdXFCO2FBQ0FDLE1BQU1scUI7S0FDUixZQUZFaXFCOztnQkFJYztNQURHLE1BQUE7O1NBRVRFO0tBQ1IsSUFBSyxXQUFBLFdBVm1CanNCLEdBS2xCOEIsTUFLRDtXQUNGb3FCO1VBQUFDLGdDQUFBRDtNQVBISDtNQVNHLHlCQWJrQmo0QixNQVNibTRCO01BUUwsTUFBQSw0QkFOQUU7O0lBTWdCO0lBYm5CSjtTQWdCTyx5QkFwQmNqNEIsVUFHckJrSyxtQkFFQWd1Qjs7R0FlcUU7WUFHdkVJLDRCQUE0QnQ0QjtJQTlCNUIrM0IsT0E4QjRCLzNCO0lBRW5CLElBQVB1NEIsT0FBTztJQUZtQnY0QixXQUUxQnU0QixNQUYwQnY0QjtJQUk5QixPQUFBLGlDQUZJdTRCO0dBRWE7WUFHZkMsZUFBZXg0QixHQUFJLHlDQUFKQSxNQUEwQjtZQUV6Q3k0QiwwQkFBMEJ6NEIsR0F2QzFCKzNCLE9BdUMwQi8zQixJQUM1QixPQUhFdzRCLGVBRTBCeDRCLEdBRVo7WUFHZDZFLE9BQVFyQyxNQUFNZ0UsTUFBTS9EO0lBQ1QsSUFBVGdFLFNBbERGMFE7SUFtRG1DLE9BQUEsK0JBRjNCM1UsTUFBTWdFLE1BQU0vRCxVQUNsQmdFO0dBQzhDO1lBVzlDd0gsVUFBVWpPLEdBQUksT0FBSkEsS0FBZTtZQUN6QjA0QixZQUFZMTRCLEdBQUksT0FBSkEsS0FBUztHQXNHM0I7Ozs7SUFHc0U7S0FJaEUsTUFBQTtJQW5FUTtLQWdFSUE7S0FuRW1DdUgsWUFtRW5Ddkg7S0FuRWdCZ0gsb0JBbUVoQmhIO0tBbkVLaU8sWUFtRUxqTztLQW5FQWdPLE1BbUVBaE87S0E5RFIyRyxJQUZJLHlCQUh1Q1k7S0FFM0M5RSxvQ0FHQWtFLGdCQUFBQTtLQUVKLFVBUCtDWTs7S0FjM0M7TUFKSy9FO01BR0RtMkIsU0FIQ24yQixVQUFBQTtNQUlMOztXQWNRLDJCQWxCSEE7V0FvQkEsMkJBcEJBQSxTQUFBQSxTQUdEbTJCLFFBQUFBO01BTkpycUI7O1NBQUFBO0lBOEJKLEdBOUJJQTtTQWdDR0QsUUFoQ0hDO1FBTEE3TDs7T0F1Q2FRLFNBdkNiUjtrQkF1Q3VCLDJCQUFWUSxRQUZWb0w7O3FCQUFlLDJCQUFmQTtTQXRDTHVxQjs7WUFDRW4yQjs7TUFzQ1NvMkIsU0F0Q1RwMkI7TUFERm0yQixnQkF1Q3FCLDJCQUFWQzs7U0F2Q1hEO0lBMENKLEdBM0NtQjNxQjs7TUErQ1I2cUIsY0EvQ1E3cUI7TUE5QmY4cUIsY0E2RW9CLDhCQUFiRDs7U0E3RVBDOzs7UUFBQUE7VUFJUTdELE9BSlI2RCxnQkFJRXJwQixLQUpGcXBCO01BSWtCLEdBQUEsNEJBQWhCcnBCLElBTkZtb0I7OztXQU1RM0M7YUFFRzhELFNBRkg5RCxTQUVIdmxCLEtBRkd1bEI7U0FFYSxHQUFBLDRCQUFoQnZsQixJQVBMbW9COzs7Y0FPV2tCO2dCQUVHQyxTQUZIRCxXQUVIRSxLQUZHRjtZQUVhLEdBQUEsNEJBQWhCRSxJQVRScEIsWUFTY3FCLFNBQUFGOztlQUFBRSxTQUZISDs7Y0FFR0ksU0FBQUQ7Ozs7WUFBQUMsU0FKTmxFOztXQUZObUUsU0FNWUQ7Ozs7U0FOWkMsU0FGRk47O0lBYUksWUFBQSwwQkFYRk07Ozs7VUFZSUMsbUJBQU5DO01BQWdCLEdBQUEsNEJBQWhCQSxNQXBCQXBMO1VBb0JNbUw7WUFFR0UsU0FGSEYsV0FFSEcsT0FGR0g7UUFFYSxHQUFBLDRCQUFoQkcsTUF0Qkh0TDs7WUFzQlNxTDtjQUVHRSxTQUZIRixXQUVIRyxPQUZHSDtVQU9FOztZQUpBLDRCQURMRyxNQXZCTmhDOzs7YUEwQlcsNEJBSExnQyxNQXRCTi9CO2tCQTJCVyw0QkFMTCtCLE1BckJOeHlCOztxQkEyQndCLDBCQU5adXlCOzs7b0JBT0QsMEJBVEZGOzs7O2tCQVVELDBCQVpGRjs7OztnQkFaSkQ7O0lBNkVKLElBTkVPLGNBTUYsNEJBaERFaEI7SUFrREosU0FBSWlCLGtCQUVBak0sR0FGb0IsT0FFcEJBLFFBQUFBLE9BQXFCO0lBSXRCO0tBQUEsVUFOQ2lNLGtCQVJBRDtLQWdCQyxPQVJEQyxrQkFuRDBCN3lCO0tBd0Q1Qjh5Qjs7O01BRzBDanpCO01BSDFDa3pCOzs7Z0VBRzBDbHpCO1NBSDFDaXpCOztTQUFBQyxVQUFBRDs7O01BQ2dDenpCO2tEQUFBQSxRQURoQzB6Qjs7Z0JBQUFBO1FBV3dCMzRCLHFDQW5FWjRNO2FBbUVZNU0sd0JBQUFBLG1CQUFBd3NCLElBQUF4c0IsZ0JBQUF3c0I7OztHQUdYO0dBSmpCO1lBT0VvTSxjQUdBaHNCO0lBRkYsR0FFRUEsd0JBQU8sT0FBUEE7UUFEWThwQixRQUNaOXBCO0lBRHFCLE9BQVQ4cEI7R0FDRjtZQUdWdmIsU0FBU3ZjLEdBQUk0dkIsS0FBa0I1aEI7SUFDakMsR0FEZTRoQixTQUFZQyxNQUFaRCxRQUFBM2hCLFlBQVk0aEIsY0FBWjVoQjtPQUFrQkQ7U0FDN0JELFFBRDZCQzs7ZUFBbEJDO1VBS1A2cUIsY0FFUSxpQ0FQaUI5cUI7O1VBUW5CdW9CLElBUkN0b0IsY0FLUDZxQixrQkFHTXZDO0tBRWM7TUFBcEJ2dkIsb0JBaE1Od1Y7TUF1TEV6Tyw2QkFENkJDLEtBS3pCOHFCLGFBS0E5eEIsbUJBVkdoSDs7SUFhWDs7Ozs7VUFBZ0ZpNkI7VUFBQUM7VUFBQXo1QixpQ0FBQXk1QjtVQUFBeDVCLGlDQUFBdTVCO3dCQUFBeDVCLGNBQUFDOztLQUFqRDt5REFicEJWLEdBQ1ArTjs7SUFETy9OO0lBZUssSUFBWjBOLFlBQVksNENBQ0h0SCxNQWhCRnBHO0lBaUJUO0tBQUEsa0NBRFdvRyxRQWZUMkg7S0FlUzNILFNBRUs7aUJBRkxBOztTQUFBSyxtQkFBQUwsTUFBQUs7OztLQWdCK0I7TUFBQSxPQUFBO01BQVosT0FBQTtLQUFZLE9BQUE7Y0FBN0IsK0NBL0JYc0g7Ozs7Ozs7VUFzQjJFb3NCO1VBQUFDO1VBQUFDLGlDQUFBRDtVQUFBRSxpQ0FBQUg7d0JBQUFFLGNBQUFDOztLQUF6RTs7O1dBUE9sMEIsS0FmVDJIOzs7O0tBdUJzQyxJQUF5QjdCLGNBQW5CaEM7S0FDMUMsT0FBQTs7Y0FWRndEO2NBUzRDeEQ7Y0FBbUJnQztjQXZCL0Q2QjtJQXdCc0Q7SUFEdEQsd0JBUlMzSDtrQkFVZ0NteUIsTUFBUSxPQVZyRCxpQ0FVNkNBLE1BekJ6Q3hxQixPQXlCcUU7SUFBakMsT0FBQSx5QkFWM0IzSDtHQWtCUDtZQUlGbTBCLGVBQWVDLFNBQVF0dUI7O0tBRWpCLFlBQUEsNEJBRmlCQTs0QkFHbEJ1aEIsY0FBSyxXQUFMQTtTQUNHemY7S0ExQ1Z1TztPQTJDYSw4Q0FMSWllLGVBSVB4c0I7S0FDTjtJQUNRO0lBTHNCLFdBQUE7SUFBbUIsT0FBQTthQUExQywrQ0FETXdzQjtHQU1KO1lBS1hDLFdBQVl0ekIsU0FBU0QsVUFBU2dGO0lBQ2hDO0tBQ2dDLE9Bek9oQ3NRO0tBd09JcVM7T0FDRjs0Q0FGWTFuQixTQUFTRDtJQUl2QixPQWZFcXpCLGVBWUUxTCxhQUQ0QjNpQjtHQUlKO1lBRzFCd3VCLE9BQVN2ekIsU0FBU0QsVUFBU2dGO0lBQ3ZCLFlBUkp1dUIsV0FPU3R6QixTQUFTRCxVQUFTZ0Y7dUJBRWYsT0FBQTtRQUNUNHFCO0lBQUssT0FBTEE7R0FBTTtZQUdUNkQsU0FBVXh6QixTQUFTRCxVQUFTZ0Y7SUFDeEIsWUFkSnV1QixXQWFVdHpCLFNBQVNELFVBQVNnRjt1QkFFaEI7UUFDVHVoQjtJQUFLLFdBQUxBO0dBQVc7WUFHZG1OLFNBQVF6ekIsU0FBU0QsVUFBU2dGO0lBQzVCLGFBcEJFdXVCLFdBbUJRdHpCLFNBQVNELFVBQVNnRjtHQUdmO1lBR1gydUIsbUJBQW9CMXpCLFNBQVNELFVBQVM0ekIsTUFBS3JOO0lBQzdDO0tBQUkvZixZQUFZO0tBSVgsT0FBQSx3Q0FKREE7S0FHRjtPQUFBOzRDQUpvQnZHLFNBQVNEO0lBRS9CLE9BQUEsd0NBREl3RyxpQkFEb0NvdEIsTUFBS3JOO0dBUzFDO1lBR0QvVCxTQUFVdlMsU0FBU0QsVUFBUzR6QjtJQUFPLE9BWm5DRCxtQkFZVTF6QixTQUFTRCxVQUFTNHpCO0dBQW9EO1lBSzlFQztRQUF3QnIwQixjQUFObzBCO0lBQVcsY0FBb0JsdUIsR0FBSyxPQUFBLGtDQUE5QmxHLEdBQXlCa0csR0FBa0I7SUFBakMsV0FBQSxXQUFoQmt1QjtJQUEwQixPQUFBOztZQUg5Q0UsV0FJRzd6QixTQUFTRCxVQUFTNHpCO0lBQ2IsSUFBSnAwQixJQUFJO0lBbkJSbTBCLG1CQWtCRzF6QixTQUFTRCxVQURWNnpCLHNCQUNtQkQsTUFDakJwMEI7SUFDSixPQUFBLGtDQURJQTtHQUVPO1lBR1h1MEIsMkJBQTJCL3VCO0lBQzdCO0tBQUl3QixZQUFZO0tBQ1p4RCxvQkFBb0Isd0NBRHBCd0Q7a0JBRU9kO0tBQUssT0FBQTsyQ0FGWmMsV0FDQXhELG1CQUZ5QmdDLEdBR2xCVTtJQUFzRDtJQUEzRCxPQUFBO0dBQTREO1lBR2hFc3VCLDZCQUE0Qmh2QjtJQUM5QjtLQUFJd0IsWUFBWTtLQUNaeEQsb0JBQW9CLHdDQURwQndEO0lBRUosU0FBSXl0QjtTQUFxQnowQixjQUFIa0csY0FBSFY7S0FBVyxhQUFnQnRLLEdBQUssT0FBQSxrQ0FBMUI4RSxHQUFxQjlFLEdBQWtCO0tBQTdCLFVBQUEsV0FBaEJzSyxHQUFHVTtLQUFtQixPQUFBOztpQkFDOUJBO2tCQUNZbEc7TUFDbkIsT0FBNEQ7O2VBTDVEZ0g7ZUFDQXhEO2VBQ0FpeEI7bUJBSDBCanZCLEdBSW5CVSxHQUNZbEc7S0FDa0Q7S0FEdkQsT0FBQTtJQUN3RDtJQUZwRSxPQUFBO0dBRXFFO1lBTTNFMDBCLFlBQVlDLFFBQVFudkI7YUFDZGdxQixLQUFLbUY7O01BRVAsWUFDSztVQUNFQSxtQkFBSHY1QjtNQUpGbzBCLEtBSUttRjtNQUNULE9BQUEsV0FOa0JudkIsR0FLWnBLO0tBRUg7S0FMTCxVQUFBLG9DQURXdTVCO0tBRVAsT0FBQTtJQUlDO0lBRVAsT0FSUW5GLEtBRE1tRjtHQVNIO1lBWVAxbEIsU0FBUW5ULE1BQU1nRSxNQUFNL0QsTUFBTTB0QixLQUFJamtCO0lBSWhDO0tBQUkvRSxVQUFVLCtCQUpKM0UsTUFBTWdFLE1BQU0vRDtLQUtsQjY0QixPQWhTSmhELDRCQStSSW54QjtLQUVBNHZCO29CQU53QjVHO1VBakQxQjZLLGVBcURFN3pCLGFBSjRCK0U7VUFqRjlCd3VCLFdBcUZFdnpCLGFBSjRCK0U7SUFXaEMsV0FMSTZxQixJQURBdUU7R0FNUTtZQUlaQztJQUNFQyxlQUNBdDdCLFFBQ0FvN0IsTUFDQUc7SUFFRCxVQUFBLHdDQUxDRDtJQUtEO2VBRUQ7NkNBUEVBLGVBQ0F0N0I7Y0FNRixXQUpFdTdCLDBCQURBSDs7R0FNNEI7R0FLOUI7SUFERUk7O2dCQUNPMXRCO1FBQ1A7NERBRE9BOzs7Ozs7O09BQzJFO0lBSHhFLGFBQ1YwdEI7WUFtQkZDLFNBQ0duNUIsTUFDQWdFLE1BQ0NvcEIsb0JBSUZ4QjtJQUVKLEdBTk13QixTQUFPQyxNQUFQRCxRQUFBbnRCLE9BQU9vdEIsY0FBUHB0QjtJQU1OO1NBTG1DbTVCLGdCQUFqQkMsaUJBQWlCRDs7U0FBakJDO0lBS2xCLFlBSllDLGdCQUFOM0wsTUFBTTJMLGdCQUFOM0w7SUFJTixZQUhhNEwsZ0JBbkJLN0csT0FtQkw2RyxnQkFuQks3RztJQXNCYTtLQUFBLFFBeEQzQnZmLFNBZ0RDblQsTUFDQWdFLFVBQ0MvRCxPQUVBMHRCLEtBRUYvQjtLQUVrQmtOO0tBQWhCdkU7Y0F0Qlk3QjttQkFBQUE7VUF1QmQ4Rzs7TUFqQlc7T0FBVHYxQixTQXRXSjBRO09BdVhFNmtCLHNCQWhCRWh1QixLQUFPLE9BbExYdU8sU0FpTEk5VixXQUNBdUgsS0FBMEM7O0tBRWpDO01BRFA5QixJQVJVZ3BCO01BU1pwdUIsV0F6V0pxUTtNQXVYRTZrQjtpQkFiRWh1QjtTQUFPLE9BakhUNHNCO3NCQWdIRTl6Qjs7a0NBQ3lDLE9BQWxDLFdBRkxvRixHQUVGOEIsS0FBOEM7UUFBQzthQWNqRHl0Qix5QkFBeUJILE1BQU8sT0EvRWxDRixZQStFMkJFLE1BRHpCVTtJQUM4RDtJQUs1QyxPQWhKbEJ0Qjs7OztjQWlKRixHQUFHLHNDQVJDM0Q7ZUFFRjBFLHlCQUZrQkg7ZUFXWCxjQUFJLHNDQVhUdkU7ZUFXSyxPQUFBOztjQUVxQjtlQUFBLFFBQUE7ZUFBVDcyQjtlQUFmczdCOzJCQUNTUztlQUNYLE9BeERKVjt3QkFzRE1DLG1CQUNTUyxNQWRLWCxNQUVsQkc7Y0FpQjRCO2NBTDVCLDBDQWRFMUU7O2VBb0JzQjtnQkFDYixNQUFBO2VBRVA7Z0JBRFd1RTtnQkFBTHR0QjtnQkFDRkQsUUE1Qk04dEIsaUJBbE1oQjdCLGNBNk5ZaHNCLE9BQUFBO2VBRU4sT0FqRU51dEI7d0JBc0RNQyxtQkFVSXp0QixRQURPdXRCLE1BcEJmRztjQTBCK0I7Y0FSMUIsVUFBQSxvQ0FwQmFIO2NBb0JsQjtjQUFBLE9BUG1CcDdCO2FBZ0JaO0dBQUM7WUFHVmc4QixrQkFBbUIxNUIsTUFBTWdFLE1BQU9vcEIsS0FBNkI4SSxhQUFheEQsTUFBS2hwQjtJQUNqRixHQURrQzBqQjtTQUFPQyxNQUFQRCxRQUFBbnRCLE9BQU9vdEI7O1NBQVBwdEI7O3NCO0lBQ2xDLFVBMUNFazVCLFNBeUNtQm41QixNQUFNZ0UsVUFBTy9ELE9BQTZCaTJCLGtCQUFheEQsTUFBS2hwQjs7R0FDRztZQUdsRml3Qix1QkFDRzM1QixNQUNBZ0UsTUFDQ29wQixLQUNEOEksYUFDQXhELE1BQ0RocEI7SUFFSixHQUxNMGpCO1NBQU9DLE1BQVBELFFBQUFudEIsT0FBT290Qjs7U0FBUHB0QjtJQUtOOztLQUFBLE1BWkV5NUIsa0JBS0cxNUIsTUFDQWdFLFVBQ0MvRCxPQUNEaTJCLGFBQ0F4RCxNQUNEaHBCO0lBRUosT0FBQTtHQUEwRTtZQUd4RWt3QixRQUFTNTVCLE1BQU1nRSxNQUFPb3BCLEtBQTJCOEksYUFBYXZJLEtBQUsrRSxNQUFLaHBCLEdBQUdtd0I7SSxHQUFyRHpNLFNBQU9DLE1BQVBELFFBQUFudEIsT0FBT290QixjQUFQcHRCO2lCQUNmYjtrQkFDRDA2QjtNQVVSLFNBWFMxNkI7V0FlSjI2QixNQWZJMzZCO2dCQUNEMDZCLE9BY1MsT0FBWkM7V0FERy9NLElBYkE4TTs7O1dBV0F0dUIsTUFaQ3BNO2dCQUNEMDZCOztTQVdXRSxjQVhYRjs7c0RBV1dFOzBEQUFYeHVCOzs7OztXQUVBd2hCLElBRkF4aEI7O01BRTRCLE1BQUEsNEJBQTVCd2hCO0tBQ1U7S0FiaEIsVUEzREFtTSxTQXdEU241QixNQUFNZ0UscUJBQW9EMHVCLE1BQVFtSDs7O0lBQ2hFLFVBekRYVixTQXdEU241QixNQUFNZ0UsVUFBTy9ELE9BQTJCaTJCLGFBQWF2SSxLQUFLK0UsTUFBS2hwQjs7O1lBbUJ4RXV3QixjQUFlajZCLE1BQU1nRSxNQUFNL0QsTUFBS3lKLEdBQUUwbEI7SUFDcEM7S0FBK0IsUUEzSDNCamMsU0EwSGFuVCxNQUFNZ0UsTUFBTS9ELGVBQUt5SjtLQUNab3ZCO0tBQWhCdkU7SUFoSkpxRSxZQWdKb0JFLE1BRGMxSjtJQUVwQyxPQURNbUY7R0FFSjtZQUdBMkYsYUFBY2w2QixNQUFNZ0UsTUFBTS9ELE1BQUt5SjtJQUNqQztLQUFNb3ZCO09BaklGM2xCO1VBZ0lZblQ7VUFBTWdFO1VBQU0vRDs7O1dBR3hCLFdBSDZCeUo7V0FHN0IsT0FBQTtVQUNTOztJQUViLE9BTE1vdkI7R0FLRjtZQUdGcUIsUUFBT242QixNQUFNZ0UsTUFBTS9ELE1BQUt5Sjs7SyxjQUVsQnVoQixjQUFTLE9BQVRBOzs7OztJQURjO0tBQUEsTUFWcEJpUCxhQVNPbDZCLE1BQU1nRSxNQUFNL0QsTUFBS3lKO0tBQ2hCLE1BQUE7OztZQUtSMHdCLFlBQWFwNkIsTUFBTWdFLE1BQU0vRCxNQUFLeUo7SUFBSTtzQjtJQUFBLFVBTmxDeXdCLFFBTWFuNkIsTUFBTWdFLE1BQU0vRCxNQUFLeUo7O0dBQThDO1lBRzFFekYsT0FBT3pHO0lBQ1QsWUFEU0E7O1FBR0F5RztJQUFVLFdBQVZBO0dBQ1M7WUFHaEJvMkIsTUFDVzc4QjtJQUFiLElBQWFvRyxNQUFBcEcsR0FBRXVOO0lBQ2I7S0FBTSxZQVROOUcsT0FRV0w7aUJBRUQsT0FGR21IO0tBR0QsSUFIRHRILGdCQUFFNjJCLE1BQUF2dkIsV0FBRm5ILE1BQUFILEtBQUVzSCxJQUFBdXZCOztHQUtQO0dBZE8sb0JBQ2JyMkIsUUFPQW8yQjs7Ozs7Ozs7O09BdGVGajBCO09BZ0VBL0Q7O09BakRBc1M7T0FLQTRnQjtPQU9BQztPQWdDQVM7T0FUQUg7T0FPQUU7V0FxQkVFLGFBREF6cUI7O09BaUhGK3JCOztPQU1BemQ7T0F3TEFvZjtPQXlDQU87T0FJQUM7T0E4QkFNO09BTUFDO09BU0FDO09BTUFDO09BeENBUjs7OztRQXhMRTFCO1FBWUFFO1FBTkFEO1FBMEJBSztRQUZBdGhCO1FBaERBNmdCO1FBNERBVTtRQU1BQzs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNsVEY2QixVQUFVLzhCOztLLGNBR0p5dEIsY0FBUyxPQUFUQTs7Ozs7SUFGRSxXQUFBLGlCQURFenRCOzs7WUFNVmdGLEtBQU1oRixHQUFHaUYsTUFBTWlIO2tCQUNJaE07Y0FDWGcyQixLQUFLbDJCLEdBQUV1MkI7O09BQ0MsWUFBZCxPQUFBLGtDQUZpQnIyQixRQUNKcTJCO1dBR0F2MkIsY0FBSDhCO09BQXNCLG9CLE9BSDFCbzBCLEtBR09sMkI7T0FBVyxXQUFBLFdBTFhrTSxHQUVBcXFCLEdBR0h6MEI7T0FBc0IsT0FBQTtNQUFTO01BRnBDLFdBQUEsaUJBRE05QjtNQUNHLE9BQUE7S0FFMkI7WUFIbkNrMkIsS0FGRmwyQixHQUFHaUY7SUFPRTtJQU5HLE9BQUE7R0FNRjtZQUtaTyxPQUFLeEYsR0FBR2lGLE1BQU1pSDtrQkFDS2hNO2NBQ1g4OEIsZ0JBQUtoOUIsR0FBRXUyQjtNQUNiO09BQW9CLE9BQUEsaUJBRFR2MkI7T0FDTCxRQUFBOztPQUNTO3dCQUFja1osTUFBUSxPQUVuQytqQixVQUYyQi9qQixNQUZoQnFkLEdBRXdDO1FBQXRDLE9BQUEsaUJBRkp2MkI7T0FFYSxPQUFBOztVQUNqQitZO01BQVE7T0FBQSxPQUFBLHVCQUNibWtCLGlCQURLbmtCLFFBSE13ZDs7TUFHRSxPQUNiMkcsdUJBREtua0IsUUFITXdkO0tBR2tCO2NBQzdCMkcscUJBQVVoa0IsTUFBS3FkO01BQ2pCLEtBRFlyZCxNQUVILE9BQUEsa0NBUFFoWixRQUtBcTJCO01BR08sSUFBYnYyQixJQUhDa1osU0FHSnBYLElBSElvWCxTQUdZLE9BQUEsV0FUWmhOLEdBTUtxcUIsR0FHVHowQjtNQUFnQixrQkFBQSxPQUFBLHVCQVBsQms3QixZQU9LaDlCOztNQUFhLE9BUGxCZzlCLGtCQU9LaDlCO0tBQW9CO2NBUHpCazJCLEtBQUtsMkIsR0FBRXUyQixHLHVCQUFQeUcsVUFBS2g5QixHQUFFdTJCO2NBSVgwRyxVQUFVL2pCLE1BQUtxZDtNLHVCQUFmMkcsZUFBVWhrQixNQUFLcWQ7O1lBSlhMLEtBRkhsMkIsR0FBR2lGO0lBV0c7SUFWRyxPQUFBO0dBVUY7WUFHWmtGLE9BQU9uSztJQUFJLE9BZFh3RixPQWNPeEYsZUFBMkJ1TixVQUFPLE9BQVBBLFVBQVk7R0FBQztZQUMvQ3hJLEtBQU0vRSxHQUFHa007SUFBSSxPQTNCYmxILEtBMkJNaEYsc0JBQW1DOEIsR0FBSyxPQUFBLFdBQXJDb0ssR0FBZ0NwSyxHQUFRO0dBQUM7WUFFbERxN0IsT0FBT245QjtJQUNUO0tBQW9CLE9BQUEsaUJBRFhBO0tBQ0gsUUFBQTs7S0FDUSxPQUFBO0lBQ0ksT0FMaEIrRTthQUVPL0U7O2NBR21CLE9BQUE7YUFBUztHQUFDO1lBR3BDdUYsT0FBS3ZGLEdBQUdrTTtJQUVSOztPQVZBbkg7U0FRSy9FO2tCQUVZNE07VUFDZCxXQUhLVixHQUVTVTtVQUNkLE9BQUE7U0FDUztJQUZaLE9BQUE7R0FFYztZQUdkL0gsT0FBT3FIO0lBQ1Q7S0FBSXFzQixPQUFPO0tBRVB2NEIsSUFBSSxpQ0FGSnU0QjtJQUdKLFdBSlNyc0IsR0FDTHFzQjtJQUdKLE9BREl2NEI7R0FFSDtZQUdDbzlCLE9BQU83RyxHQUFHcnFCO0lBQ1osT0FURXJIO3NCQVNVMHpCO3VCQUNGckMsS0FBS0s7O2dCQUNBLFlBRGIsT0FBQSxpQ0FEVWdDO3NDQUlLaEMsY0FBSDNwQjtnQkFDTixpQ0FMSTJyQixNQUlFM3JCO2dCQUNOLE9BSkVzcEIsS0FHT0s7ZUFFRjtlQUpOLFdBQUEsV0FIR3JxQixHQUVHcXFCO2VBQ0EsT0FBQTtjQUlBO3FCQUxMTCxLQUZESzthQVNEO0dBQUM7WUFHUDVGLFFBQVEvQztJQUNWLE9BckJFL29CO3NCQXFCVTB6Qjs0QkFDVTlLO2VBQUssT0FBQSxpQ0FEZjhLLE1BQ1U5SztjQUF1QjtjQUEzQyx5QkFGUUc7Y0FFUixPQUFBLGlDQURVMks7YUFFUztHQUFDO1lBR3BCanpCLFFBQVFxQjtJQUFJO0tBQUE7S0FBQTtPQXBFWjNCO1NBb0VRMkI7O2tCQUE2QjR2QixHQUFFM3BCO1VBQUssT0FBTyw4Q0FBWkEsR0FBRjJwQjtTQUFzQjtJQUEvQyxPQUFBO0dBQTZEO1lBQ3pFOEcsYUFBYXI5QixHQUFFdTRCO0lBQU8sT0ExQ3RCeHpCO2FBMENhL0U7c0JBQXlCNE07Y0FBWSxXQUFBLGlDQUFuQzJyQixNQUF1QjNyQjtjQUFZLE9BQUE7YUFBb0I7R0FBQztZQUV2RTB3QixPQUFPNXRCLElBQUdDO0lBQ1osT0E5QkU5SztzQkE4QlUwekI7OztnQkFFK0IsT0FEekMsaUNBRFVBO2VBRWtEO2VBQXJELFdBTFA4RSxhQUVVMXRCLElBQ0E0b0I7ZUFFb0IsT0FBQTtjQUErQjtjQUR4RCxXQUpMOEUsYUFFTzN0QixJQUNHNm9CO2NBQ2tCLE9BQUE7YUFDa0M7R0FBQztZQUcvRHgzQixPQUFPZjtJQUNULE9BcENFNkU7c0JBb0NVMHpCOztlQUNrRCxPQUE1RCxpQ0FEVUE7Y0FDcUU7Y0FBMUUsV0FwREx4ekIsS0FrRE8vRSxZQUVlQSxHQUFLLE9BVjNCcTlCLGFBVXNCcjlCLEdBRFp1NEIsTUFDb0M7Y0FBRyxPQUFBO2FBQStCO0dBQUM7WUFhakZnRixrQkFBa0J2OUIsR0FBR2tNO0lBQUksT0FsRHpCckg7c0JBeUNVMHpCOztlQU1HLE9BTGIsaUNBRFVBO2NBTXNCO2NBSjlCOztpQkExREZ4ekI7bUJBaUVrQi9FOzRCQUF5QjhCOztxQixnREFUakN5MkIsTUFTaUN6MkI7O29CQUFZO3FCQUFBLE9BQUEsV0FBbENvSyxHQUFzQnBLO3FCQUFZLE9BQUE7Ozs7Y0FIckQsT0FBQTthQUErQjtHQUc0QjtZQVk3RDA3QixzQkFBc0J4OUIsR0FBR2tNO0lBQUksT0E5RDdCckg7c0JBcURVMHpCOztlQU1HLE9BTGIsaUNBRFVBO2NBTXNCO2NBSjlCOztpQkF0RUZ4ekI7bUJBNkVzQi9FOzRCQUE2QjhCOztxQixZQUxwQzt5QkFDSEE7cUJBQUssT0FBQSxpQ0FMUHkyQixNQUtFejJCOztvQkFJbUQ7cUJBQUEsTUFBQSxXQUF0Q29LLEdBQTBCcEs7cUJBQVksTUFBQTs7O2NBSDdELE9BQUE7YUFBK0I7R0FHb0M7WUFFckVnRCxJQUFLOUUsR0FBR2tNO0lBQ1YsT0FqRUVySDtzQkFpRVUwekI7O2VBR0csT0FGYixpQ0FEVUE7Y0FHc0I7Y0FEOUI7O2lCQWxGRnh6QjttQkErRUsvRTs0QkFHYzhCO29CQUFLO3FCQUFRLE1BQUEsaUNBRnRCeTJCO3FCQUVjLE1BQUEsV0FIaEJyc0IsR0FHV3BLO29CQUFhLE9BQUE7bUJBQWdCO2NBQzlDLE9BQUE7YUFBK0I7R0FBQztZQUdsQzhELE1BQUk1RixHQUFHa007SUFBSSxPQVBYcEg7YUFPSTlFO3NCQUFzQjRNO2NBQVksVUFBQSxXQUEvQlYsR0FBbUJVO2NBQVksT0FBQTthQUFLO0dBQUM7WUFFNUM2d0IsUUFBUTkyQixHQUFFNEc7SUFDWixPQTFFRTFJO3NCQTBFVTB6Qjt1QkFDRnJDLEtBQUt2dkIsR0FBRTRHO2VBQ2IsR0FBRyxxQkFEVUE7Z0JBQWYsT0FBQSxpQ0FEVWdyQjs7Z0JBS1EsWUFKbEIsT0FBQSxpQ0FEVUE7b0JBT092NEIsY0FBSHl0QjtnQkFDTixpQ0FSRThLLE1BT0k5SztnQkFGVixPQUpJeUksS0FNU2wyQixHQU5GdU47ZUFRUTtlQUpkLFVBQUEsaUJBSkk1RztlQUlLLE9BQUE7Y0FJSztjQVR6QixPQUNVdXZCLEtBRkF2dkIsR0FBRTRHO2FBWUY7R0FBQztZQUdUbXdCLGNBQ1cxOUI7SUFBYixJQUFhb0csTUFBQXBHLEdBQUVrRztJQUNiO0tBQW9CO01BQUEsTUFBQSxpQkFEVEU7TUFDTCxRQUFBOzs7O09BRXlCO1FBSHBCSDtRQUdHd25CO1FBSER0bkIsV0FHQ3NuQixHQUhEdm5CO1FBQUZFLE1BQUFIO1FBQUVDLEtBQUFDOzs7O0tBRVEsV0FBQSwwQkFGUkQsS0FBRkU7O0dBS0o7WUFHUHUzQixNQUFRL04sVUFBb0Q1dkI7SUFDOUQsR0FEVTR2QjtTQUFPQyxNQUFQRCxRQUFBZ08sT0FBTy9OOztTQUFQK04sT0FBTztJQUNqQjtTQUQwQ2hDLGdCQUFKMXZCLElBQUkwdkI7O1NBQUoxdkIsb0JBQWEsaUJBQVM7SUFDbEM7S0FBdEIyeEIsc0JBQXNCO0tBQ3RCQyxTQUFTO2FBQ1RDLE9BQU9qOEI7S0FDVCxpQ0FGRWc4QjtLQUVGLE9BQUEsa0NBSEVELHFCQUVPLzdCO0lBRXNCO2FBRXpCbzBCLEtBQUtsMkI7O01BRVAsOEJBQ2lCLE9BUG5CKzlCLHNCQUlTLzlCO1VBSUhnK0I7TUFDTixLQURNQSxHQUVJLE9BVlZEO01BWVUsSUFERTMzQixNQUhONDNCLE1BR0dweEIsSUFISG94QixNQUlJLFFBQUEsV0Fmd0I5eEIsR0FjekJVOztPQUdILGlDQWZOa3hCLFFBWVNseEI7T0FHSCxPQVZGc3BCLEtBT1E5dkI7O1VBS0Ntd0I7TUFBWSxPQWhCekJ3SCwwQkFnQmF4SCxHQUxEbndCO0tBSzhCO0tBVnhDO2tCQUQ0RDQzQixHQUFLLHNCQUFMQSxHQUFZO0tBQTFCO01BQUEsTUFBQSxpQkFEdkNoK0I7Z0JBQ2dDO3lCQUFYLGlCQUFRO0tBQWpDO01BQUEsVUFBRSx5Q0FSRDQ5QjtNQVFSLE1BQUE7S0FDSSxPQUFBO0lBVXdDO0lBWnRDMUgsS0FQc0RsMkI7SUFzQnpDLFVBQUEsa0NBckJqQjY5QjtJQXFCSixXQUFBLGlDQXBCSUM7R0FvQjhDO1lBR2hERyxLQUFLaitCLEdBQUdrTTtJQUNWO0tBQU9neUI7T0ExQkxQOzs7b0JBMEI2Qi93QjtZQUFLLE9BQUcsV0FEN0JWLEdBQ3FCVSxvQkFBQUE7V0FBd0M7VUFEaEU1TTs7aUJBSUx5dEI7SyxVQUFBQSw4QkFBQUE7TUFEYyxNQUFBO0tBQ3NCLE9BQXBDQTs7dURBSEt5UTtHQUdnQztZQUdyQ0MsUUFBUW4rQjtJQUNWLE9BbElFNkU7c0JBa0lVMHpCOztlQUtHLE9BSmIsaUNBRFVBO2NBS3NCO2NBSDlCOztpQkFuSkZ4ekI7bUJBZ0pRL0U7NEJBR1c0dEI7aUNBQ01IO3FCQUFLLE9BQUEsaUNBSHBCOEssTUFHZTlLO29CQUF1QjtvQkFBM0MseUJBRGNHO29CQUNkLE9BQUE7bUJBQ1M7Y0FDWixPQUFBO2FBQStCO0dBQUM7WUFHbEN3USxXQUFXdkk7SUFDYixPQTNJRWh4QjtzQkEySVUwekI7Y0FLSyxJQUFYOEY7dUJBRUFDO2VBRkFELGNBQUFBO2VBSUMsVUFBQSxxQkFKREE7ZUFJQyxhQUZMLGlDQVBVOUY7Y0FTaUM7Y0FHekM7ZUFERWdHO2lCQXJLSng1QjttQkF5Slc4d0I7NEJBYVE3MUI7b0JBUGZxK0IsY0FBQUE7b0JBU0ssVUE5SFRoQixhQTRIbUJyOUIsR0FaVHU0QjtvQkFjTiwrQ0FQQStGO29CQU9BLE9BQUE7bUJBQ1M7Y0FFYixPQUFBO3NEQU5JQyxjQUpBRDthQVVtQjtHQUFDO1lBR3hCRSxXQUFXeCtCLEdBQUU4MkI7SUFDZixPQWhLRWp5QjtzQkFnS1UwekI7dUJBQ0ZyQyxLQUFLbDJCOztnQkFHVDs7O3NCQUVvQkEsY0FBSHl0QjtrQkFDYixpQ0FQRThLLE1BTVc5SztrQkFDYixPQU5BeUksS0FLZ0JsMkI7OztnQkFMeEIsT0FBQSxpQ0FEVXU0QjtlQVFLO2VBSlg7NEJBRDJEa0csR0FBSyxzQkFBTEEsR0FBWTtlQUExQjtnQkFBQSxNQUFBLGlCQUZwQ3orQjs7c0JBRTZCO21DQUFSLGlCQUFLO2VBQTNCO2dCQUFBO3NCQUFFLHlDQUpEODJCO2dCQUlULE1BQUE7ZUFDQSxPQUFBO2NBSVc7cUJBUFBaLEtBRkdsMkI7YUFXTDtHQUFDO1lBR1AwK0IsYUFBYzErQixHQUFHa007aUJBQ0VoTTtjQUNYZzJCLEtBQUtsMkI7O09BRVAsWUFDSyxPQUFBLGtDQUpRRTtXQUtORixjQUFIeXRCO29CQU1FZ1I7UUFWSnZJLEtBSUtsMkI7aUJBTUR5K0IsTUFHSTtRQUNtQixJQUF0QmpQLElBSkRpUCxNQUl1QixNQUFBO1FBQWpCLE9BQUEsNkNBQUxqUDtPQUE2QzsyQkFMekMsT0FWbkIsV0FEbUJ0akIsR0FNUHVoQixHQUtVO09BSmhCO2NBQUE7T0FLSSxPQUFBO01BSWtEO01BYnhELFVBQUEsaUJBRFd6dEI7TUFFUCxPQUFBO0tBWW9EO1lBZGxEazJCLEtBRk1sMkI7SUFrQlI7SUFqQlEsT0FBQTtHQWlCUDtZQUdQMitCLHdCQUF3QjMrQixHQUFHa007aUJBQ1JoTTtjQUNYZzJCLEtBQUtsMkI7O09BRVAsWUFDSyxPQUFBLGtDQUpRRTtXQUtORixjQUFIeXRCO09BSkZ5SSxLQUlLbDJCO09BSVQsT0FBQSxXQVZ1QmtNLEdBTWpCdWhCO01BS0g7TUFSTCxVQUFBLGlCQURXenRCO01BRVAsT0FBQTtLQU9DO1lBVENrMkIsS0FGZ0JsMkI7SUFhbEI7SUFaUSxPQUFBO0dBWVA7WUFHUDQrQixlQUFhNStCLEdBQUdrTTtJQUFtQixVQWhCbkN5eUIsd0JBZ0JhMytCLEdBQUdrTTtJQUFtQixPQUFBO0dBQThCO1lBRWpFMnlCLE9BQU8zeUI7SUFDVCxPQTdNRWt4Qjs7OzJCQThNUXh3QixHQUNSLGVBRFFBLE9BQ0k7Y0FEQSxVQUFBLFdBRkxWOzs7R0FHTTs7Ozs7Ozs7O09Bdk5ickg7O09BaERBazRCO09Bb0VBcE07T0FNQXJyQjtPQTBMQXU1QjtPQXpMQXhCO09BRUFDO09BTUF2OEI7T0FxREEyOEI7T0F0Q0FIO09BWUFDO09BeEdBeDRCO09BWUFRO09BZUFUO09BRUFvNEI7T0FNQTUzQjtPQXNLQWk1QjtPQWNBRTtPQXFDQUU7T0FoQkFEO09BbE5BeDBCO09BZ0ZBckY7T0FPQWM7T0FFQTYzQjtPQWpFQUw7T0F5RkFPO09BeUJBTTtPQU9BRTtPQVNBQzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0MxTEosU0FFWXBMLEtBQUFweEIsR0FBQSxPQUFBQSxLQUFJO1lBQUprOUIsU0FBQWw5QixHQUFBRSxHQUFBRixPQUFBRSxZQUFJO1lBREppOUIsZ0JBQUFuOUIsR0FBQSxPQUFBQSxLQUFlO1lBQWZvOUIsb0JBQUFwOUIsR0FBQUUsR0FBQUYsT0FBQUUsWUFBZTtnQkFDZkYsR0FBQUUsR0FBQSxXQUFBRixNQUFBRSxHQUFJO0dBQUo7SUFBQSxVQUFBZzlCO0lBQUE1TCw2QkFBQSxTQUFJLGtCQUFKRjtnQkFEQXB4QixHQUFBRSxHQUFBLFdBQUFBLEdBQUFGLE1BQWU7R0FBZjtJQUFBLFVBQUFvOUI7SUFBQUM7O3VCQUFBLFNBQWU7OztPQUFmRjs7WUFLUm4yQixVQUFVK3FCLG9CQUFjM3pCO0lBQ2YsSUFBUGsvQixPQUFPLHNDQURlbC9COztjQUdwQmlNLE1BQU1DLEdBQUksT0FBQSw4QkFGWmd6QixNQUVRaHpCLEdBQWdDO0tBTXRDO01BZkFpekI7UUFTQWx6QjttQkFNWSttQjtXQUNULGtDQVZHVyxhQVNNWDtXQUVGLEdBQUEsa0NBRkVBO1dBRVQsTUFBQTtVQUEyQjtNQWpCOUJvTTtRQVNBbnpCO21CQUdZOHlCO1dBQ04sVUFBQSxrQ0FOUkc7V0FNUSxVQUFBO2NBRE1IO1dBQzJCLE1BQUE7VUFBc0I7S0FiN0QsV0FBQUsscUJBQ0lIO0tBQ0EsT0FBQSxXQUZKRSxVQUVJak07SUFlNEI7aUJBVE1rRTtjQVJ6Q2lJLGdCO0tBRU87TUFEQUMsc0JBT2tDbEk7TUFObENtSSxXQU1rQ25JO01BTmxDb0ksVUFBQSxpQ0FGUEgsVUFFT0U7TUFGWkUsZ0NBRVlEO01BREFFLFVBQUEsc0JBQUFKO01BRFpLLGtDQUNZRCxlQURaRDtLQUFBLFdBQUFFOztJQVFzRCxPQUFBLG1DQURoRFQ7R0FVbUM7WUFHckM1OUIsc0JBQWN0QjtJQUNoQixJQUFNKytCLGtCQUE4QixzQ0FEcEIvK0I7a0RBQ1YrK0I7R0FFNkI7O1lBS2pDYSxVQUFVNS9CLEdBQUU0TTtJQUNkO0tBQUlzeUIsT0FBTyxzQ0FEQ2wvQjtLQUVaLE1BRElrL0I7OztXQUFBQTs7O1VBSUYsa0NBSkVBLFNBRFV0eUI7VUFDVnN5QixVQUtXOzs7O0dBQWU7WUFHNUJXLEtBQUs3L0I7SUFDSSxJQUFQay9CLE9BQU8sc0NBREpsL0I7SUFDSGsvQjs2Q0FBQUE7R0FFZTtZQUdqQlksa0JBQWdCOS9CO0lBQ1AsSUFBUGsvQixPQUFPLHNDQURPbC9CO0lBRWxCLE9BRElrL0I7R0FDZ0I7Ozs7Ozs7VUF6QmxCNTlCLFdBZEFzSCxtQkErQkFpM0IsTUFUQUQsV0FlQUU7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDcVAwQnh4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWpTMUI1TTtJQU1BZ3hCO0lBQ0FpRDtJQUNBUjs7O0lBNENBOWQ7SUFEQXpPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBbkNFdEg7UUFvQmMwSSxrQkFaVnVKO0lBS04sR0FMTUE7Ozt5Qjs7OzsyREFZVXZKOzs7O29EQVpWdUo7OztZQW1CUnlLLFlBQUFuWCxPQUFBLE9BM0JJdkYscUJBMkJKdUYsT0FBNkM7R0FEM0IscUJBQ2xCbVgsYUFRRXBWLFdBQ0F5TztZQUhKekksWUFBQW14QixPQUFBLE9BakNNeitCLHFCQWlDTnkrQixPQUF1QztZQUluQ25uQixVQUFXNVksR0FBdUIsT0FBdkJBLEVBQXdCOztJQUNuQzZFO0lBQ0FrckI7WUFDQTFXLGdCQUFnQnJaLEdBQUksb0NBQUpBLE1BQXlDO1lBQ3pEdVQsY0FBY3ZULEdBQUksT0FBSkEsS0FBbUI7WUFDakNzWixvQkFBb0J0WixHQUFJLG9DQUFKQSxNQUE2QztZQUNqRStXLGlCQUFpQi9XLEdBQUksb0NBQUpBLE1BQTZCO1lBQzlDdUMsR0FBR3ZDLEdBQUksT0FBSkEsS0FBUTtZQUlYMlcsSUFBSTNXO0lBQ04sT0FETUE7Y0FTSjtjQWRBK1csaUJBS0kvVztHQVVpQjtHQUlWLElBQVh1YztZQUNBWSxpQkFBaUJuZCxHQUFHK087SUFBTSxPQURmLCtDQUNNL08sR0FBRytPLElBRHBCd047R0FDaUY7WUFDakZ5akIsb0JBQW9CaGdDLEdBQUVpZ0M7SUFBNEMsV0FoQmxFdHBCLElBZ0JvQjNXO0lBQStCLE9BRG5EbWQ7YUFDb0JuZCxHQUErQiw0Q0FBN0JpZ0M7R0FBdUQ7WUFHN0V0akIsaUJBQWlCM2M7SUFBSSxPQUxWLCtDQUtNQSxHQUxqQnVjO0dBSzBFO1lBQzFFbUMsUUFBTTFlO0lBQWMsV0FBQSx3Q0FBZEE7SUFBYyxPQUFBO0dBQTZCO1lBRWpEZ2Qsa0JBQW1Ca2pCLFVBQVNsZ0MsR0FBRytPO2FBQzdCb3hCO0tBTUYsS0FQbUJELFVBQ3JCLE9BSEV4aEIsUUFFNEIxZTtTQVNyQmtNLElBVFlnMEI7S0FTUCxPQUFBLFdBQUxoMEI7SUFBUzthQUVkNnhCO0tBbEJGNWdCLGlCQU80Qm5kLEdBQUcrTztLQUgvQjROLGlCQUc0QjNjO0tBYTVCLE9BWkVtZ0M7SUFja0I7YUFFZEM7S0FDTjtNQUFNLFlBQUEsNkJBbEJzQnBnQztrQkFtQmxCLE9BUlIrOUI7VUFTS3NDO01BQ0Y7UUFBQTtvQ0FERUEsZ0NBcEJ3QnR4QjtPQXNCeEIsT0FYTGd2QjtNQWxCRjVnQixpQkFPNEJuZCxHQW9CckJxZ0M7TUF2QlAxakIsaUJBRzRCM2M7TUEwQkEsSUFBcEJzZ0Msb0JBekJOSDtNQTBCSyxLQUFBLHNDQURDRztrQ0FLRixPQWRBRixlQWNjOztpREFMWkU7OztJQUtjO0lBbEN0QjNqQixpQkFHNEIzYzt5QkF1QzlCLE9BdEJRb2dDLGVBc0JNO0lBREEsV0FyQ1ZEOztHQXNDVTtZQUdaampCLCtCQUFxRGdqQixVQUFTbGdDLEdBQUcrTzthQUMvRG94QjtLQU1GLEtBUHFERCxVQUN2RCxPQTdDRXhoQixRQTRDOEQxZTtTQVN2RGtNLElBVDhDZzBCO0tBU3pDLE9BQUEsV0FBTGgwQjtJQUFTO2FBRWQ2eEI7S0E1REY1Z0IsaUJBaUQ4RG5kLEdBQUcrTztLQTdDakU0TixpQkE2QzhEM2M7S0FhOUQsT0FaRW1nQztJQWNrQjthQUVkQztLQUNOO01BQU0sWUF4Rk45bUIsb0JBc0U4RHRaO2tCQW1CcEQsT0FSUis5QjtVQVNLd0M7TUFDRixHQUFBLHFDQURFQSx1QkFwQjBEeHhCO09Bc0IxRCxPQVhMZ3ZCO01BNURGNWdCLGlCQWlEOERuZCxHQXdCbEMsNkJBeEJrQ0E7TUE3QzlEMmMsaUJBNkM4RDNjO01BMEJsQyxJQUFwQnNnQyxvQkF6Qk5IO01BMEJLLEtBQUEsc0NBRENHO2tDQUtGLE9BZEFGLGVBY2M7O2lEQUxaRTs7O0lBS2M7SUE1RXRCM2pCLGlCQTZDOEQzYzt5QkF1Q2hFLE9BdEJRb2dDLGVBc0JNO0lBREEsV0FyQ1ZEOztHQXNDVTtZQUdaSyxxQkFBc0JOLFVBQVNsZ0MsR0FBRWlnQztJQUNlLFdBM0doRHRwQixJQTBHK0IzVztJQUNFLE9BckZqQ2dkO2FBb0ZzQmtqQixVQUFTbGdDLEdBQ0UsNENBREFpZ0M7R0FDMEI7WUFHM0RRLGFBQWF6Z0MsR0FBRUM7SUFBcUIsV0E5R3BDMFcsSUE4R2EzVztJQUFTLE9BQUEsNENBQVBDO0dBQWlDO1lBZWhEeWdDLGdCQUFnQjFnQyxHQUFFMmdDLE1BQUt2UyxLQUFFeGhCO0lBQzNCO0tBZHFCMUMsb0JBY0csd0NBRE5sSztLQUVJLE9BQUEsNkJBRkpBO0lBRWYsS0FBQSxxQ0FGaUIyZ0M7S0FLbEIsd0NBTGdCM2dDLE1BYkdrSyxtQkFhSWtrQixLQUFFeGhCO0tBS3pCLE9BQUE7O0lBYnVCO0tBQUE7T0FBQTtzQ0FRUDVNLE1BYkdrSyxtQkFhSWtrQixLQUFFeGhCO0tBUnZCLE9BQUE7S0FKQWlFLFFBQ0YsNkJBV2dCN1EsTUFBRTJnQzthQUFGM2dDO2tCQUpWa00sY0FBSyxXQUFMQSxHQUlZeTBCO0lBSHBCLE9BVEk5dkI7R0FrQlk7WUFHZHVMLE9BQU9wYyxHQUFFMmdDLE1BQUt6MEIsR0FBRVUsR0FUaEI4ekIsZ0JBU08xZ0MsR0FBRTJnQyxNQUFLejBCLEdBQUVVLElBQVksU0FBdUM7WUFDbkV1UCxVQUFVbmMsR0FBRUMsTUFBS2lNLEdBQUVVO0lBQUksT0FEdkJ3UCxPQUNVcGMsR0F6QlZ5Z0MsYUF5QlV6Z0MsR0FBRUMsT0FBS2lNLEdBQUVVO0dBQXNDO1lBR3ZEc2xCLEtBQUtoeUIsUUFBUyxPQUFBLGtDQUFUQSxXQUE0QjtZQURuQytPLEdBRUVqUCxHQUFFMmdDO0lBQ21CLFdBQUEsNkJBRHJCM2dDO0lBQ0MsR0FBQSxxQ0FEQzJnQztLQUVDLE9BQUE7SUFFVSxJQUFUemdDLFNBQVM7SUFsQmZ3Z0MsZ0JBY0UxZ0MsR0FBRTJnQyxNQURGek8sTUFLSWh5QjtJQUVKLE9BQUEsa0NBRklBO0dBRWE7WUFHbkJILE1BQU1DLEdBQUVDLE1BQU8sT0FYZmdQLEdBV01qUCxHQXRDTnlnQyxhQXNDTXpnQyxHQUFFQyxPQUFpQztZQUV6QzJnQyxhQUFhNWdDLEdBQUU2UTtJQUNqQjtLQUFJOUcsZUFBZSwrQkFESi9KLE1BQUU2UTtLQUdUeUMsSUFBSywrQkFGVHZKO0tBSUlxRixRQURFLCtCQURGa0UsR0FGSnZKO1NBRUl1SixHQU1MLE1BQUE7SUFKWSx3Q0FMQXRULE1BS1BvUDtJQUtSLE9BQUEsNkJBVmVwUCxNQUFFNlE7R0FVaUI7R0FTaEMsU0FBQWhCLFlBQU1neEIsVUFBSUM7SUFBVjtLQUNFLElBQUFDLHFCQUFBQyxXQUFBLFdBRElILFVBQ0pFO0tBQUEsd0JBQUFDOztJQUNBLElBQUFDLHFCQUFBQyxXQUFBLFdBRlFKLFVBRVJHO0lBQUEsd0JBQUFDO0dBQ2tCO0dBSlAsZ0JBQ2JyeEI7WUF1QlVpTCxhQUFBbFosR0FBQSxPQUFBQSxLQUFZO1lBQVp1L0IsaUJBQUF2L0IsR0FBQUUsR0FBQUYsT0FBQUUsWUFBWTtZQUpacy9CLGtCQUFBeC9CLEdBQUEsT0FBQUEsS0FBaUI7WUFBakJ5L0Isc0JBQUF6L0IsR0FBQUUsR0FBQUYsT0FBQUUsWUFBaUI7WUFOekJ3L0IsTUFBQTEvQixHQUFBLE9BQUFBLEtBQUs7WUFOR2lQLE1BQUFqUCxHQUFBLE9BQUFBLEtBQUs7WUFBTGtQLFVBQUFsUCxHQUFBRSxHQUFBRixPQUFBRSxZQUFLO2dCQWdCTEYsR0FBQUUsR0FBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFZO0dBQVo7SUFBQSxVQUFBdS9CO0lBQUFJOzt1QkFBQSxTQUFZOzs7T0FBWnptQjs7Z0JBSkFsWixHQUFBRSxHQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQWlCO0dBQWpCO0lBQUEsVUFBQXkvQjtJQUFBRzs7dUJBQUEsU0FBaUI7OztPQUFqQko7O2dCQU5SeC9CLEdBQUFFLEdBQUEsV0FBQUYsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUEsTUFBQUEsTUFBSztHQUFMOztJQUFBNi9CLDhCQUFBLFNBQUssbUJBQUxIO2dCQU5RMS9CLEdBQUFFLEdBQUEsV0FBQUEsR0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBSztHQUFMO0lBQUEsVUFBQWtQO0lBQUFRLDhCQUFBLFNBQUssbUJBQUxUO1lBRFp3QyxZQUFNcXVCLFVBQUlDO0lBQVY7S0FDWUM7S0FNUkM7S0FNUUM7S0FJQUM7S0FDUkM7S0FBQXpXLFVBQUEsOENBQUF5VztLQWxCSkMsZ0NBa0JJMVc7S0FEUUUsVUFBQSxxQ0FBQXNXO0tBakJaRyxrQ0FpQll6VyxlQWpCWndXO0tBYVlFLFVBQUEsc0JBQUFMO0tBYlpNLGtDQWFZRCxlQWJaRDtpQ0FBTVIsVUFBSUM7S0FPTlUsVUFBQSx1Q0FBQVI7S0FQSlMsa0NBT0lELGVBUEpEO3dCO0lBRVk7S0FBQXJXO0tBRlp3VyxrQ0FFWXhXLGVBRlp1VztLQUNZclcsVUFBQSxnREFBQTJWO0tBRFpZLGtDQUNZdlcsZUFEWnNXO0lBQUEsV0FBQUM7R0FvQjRCO1lBRTVCQyxlQUFBQztJQUFBLE9BdEJBcnZCLGtDQXNCQXF2QjtHQUFpRDtZQUU3Q0MsUUFBTTNpQyxHQUFJLHlDQUFKQSxNQUFxQjtZQUUzQmtZLFlBQVV5YixhQUFZaVAsYUFBWTVpQzs7S0FFbEMsSUFBSWdLLFNBRjhCaEs7S0FHbEMsU0FBSWlNLE1BQU1DLEdBQUksT0FBQSw4QkFIb0JsTSxHQUd4QmtNLEdBQTZCO0tBa0JuQztNQS9DTTIyQjtRQTZCTjUyQjttQkFxQm9CNk87V0FGZCxXQUFBLDZCQXBCTjlRLFFBRjhCaEs7V0FzQnhCLFdBQUE7V0FJUztZQUZLeVMsU0FFTCwrQkF4QmZ6SSxRQUY4QmhLO1lBd0JWd1M7WUFBQUU7WUFBQTVSO1lBQUEwQjtvQkFBQW1RLFdBQUFtd0IsT0FBQUM7WUFBQSxPQUFBLHNDQUFBRCxPQUFBQztXQUFTOzs7b0JBQVR6MEI7b0JBQUFrRTtvQkFBQUc7b0JBQUFuUTtvQkFBQTFCO29CQUFBNFI7b0JBQUFEO29CQUFBcUk7VUFFb0I7TUFwRGxDa29CO1FBNkJOLzJCO21CQWdCWW0xQjtXQUFxQixHQUFPLG1DQUE1QkE7O1dBQXFCLE1BQUE7VUFBK0I7TUE3QzFENkI7UUE2Qk5oM0I7bUJBVWFxMUI7V0FDVjtZQUFvQixPQUFBLGtDQURWQTtZQUNKLFFBQUE7dUJBQ0k7OztnQkFDTTEwQjtZQUFNLE9BQUEsV0FoQm5CK21CLGFBZ0JhL21COztlQUNDbW5CO1dBQU0sT0FBQSxXQWpCUjZPLGFBaUJFN087VUFBbUI7TUEzQ2pDeGlCO1FBNkJOdEY7bUJBR1k0RTtXQUNULEdBQUcsa0NBUHdCN1E7WUFRVixHQUFBLDZCQU5wQmdLLFFBSVk2RzthQUVKLE1BQUE7OztXQUNHLFdBQUEsNkJBUFg3RyxRQUlZNkc7V0FHRCxXQUFBO1dBQ3lCLFdBQUEsK0JBUnBDN0csUUFJWTZHO1dBSUcsR0FBQTtXQUFQLE1BQUE7VUFBdUQ7S0FwQ3pELFdBQUFVLFdBQ0ZEO0tBREUsV0FBQTJ4QixXQU9WeEI7S0FQVSxXQUFBdUIsdUJBYUZ4QjtLQWJFLFdBQUFxQixrQkFpQkZ0QjtLQUNSO0lBbUNxQjtrQkExQmtCMkI7MEI7WUEzQjNDN3ZCLDRCLG9CQTJCMkM2dkI7O0lBQVUsT0FBQSxtQ0FEZmxqQztHQTJCWjtHQUl4QixTQUFBMFcsWUFBTXlzQixVQUFJQztJQUFWOztPQUNFLElBQUFDLHFCQUFBQyxXQUFBLFdBRElILFVBQ0pFO09BQUEsd0JBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQUFBLFdBRlFKLFVBRVJHO09BQUEsd0JBQUFDOztPQUNBO1FBQUFDO1FBQUFDLFdBQUEscUNBQUFEO09BQUEsd0JBQUFDOztHQUNrQjtHQUxOLGlCQUNkaHRCO1lBT0V2SCxPQUFPblA7SUFDVDtLQUFvQixPQUFBLGtDQURYQTtLQUNILFFBQUE7Z0JBQ0ksV0FGREE7OzZCQUdPNE0sZ0JBQU0sV0FBTkE7UUFDQ21uQjtJQUFNLFdBQU5BO0dBQWdCO0dBSWpDLFNBQUE1YixZQUFNd3JCLFVBQUlDO0lBQVYsOEJBQ0U7O0tBQ0EsSUFBQUMscUJBQUFDLFdBQUEsV0FGSUgsVUFFSkU7S0FBQSx3QkFBQUM7O0lBQ0EsSUFBQUMscUJBQUFDLFdBQUEsV0FIUUosVUFHUkc7SUFBQSx3QkFBQUM7R0FDa0I7R0FMQSx1QkFDcEI3ckI7WUFPRXFELE1BQU14YixHQUFFNE07SUFDVixHQS9UQWxMOzs7aUJBK1QrRHVpQzs4QjtnQkFoRmpFNXdCLDRCLG9CQWdGaUU0d0I7O0tBQWpELGdFQUROamtDOztJQUVZO0tBQUEsT0F6RGxCMmlDLFFBdURNM2lDO0tBRUYsUUFBQTs7S0FJSixrQ0FOTUEsVUFBRTRNO1NBM0ZrQmlFLFFBMkZwQjdRLE1BM0ZrQm9HLE1BMkZsQnBHO0tBMUZQLEdBQUEsNkJBRHlCb0csUUFBRXlLLFFBYjVCK3ZCLGFBYTBCeDZCLEtBQUV5SztLQWtHMUI7Ozs2QkFKY3F6QixrQkFBTSxXQUFOQTtRQUNDblE7SUFBTSxXQUFOQTtHQUliO1lBR0ZyWSxVQUFVMWIsR0FBRTRNO0lBQ1IsWUFaSjRPLE1BV1V4YixHQUFFNE07a0NBRU47Ozs7Ozs7Ozs7R0FNNEU7WUFHbEY2TyxrQkFBa0J6YixHQUFFNE0sR0F0QnBCNE8sTUFzQmtCeGIsR0FBRTRNLElBQVksU0FBNkI7WUFDN0Q4TSxTQUFTMVosR0FBQUEsT0F4SlgwZ0MsZ0JBd0pXMWdDLE1BQUFBLE1BQUFBLGlCQUFxRTtHQUdoRixTQUFBdVksWUFBTTRyQixVQUFJQztJQUFWLDhCQUNFOztLQUNBLElBQUFDLHFCQUFBQyxXQUFBLFdBRklILFVBRUpFO0tBQUEsd0JBQUFDOztJQUNBLElBQUFDLHFCQUFBQyxXQUFBLFdBSFFKLFVBR1JHO0lBQUEsd0JBQUFDO0dBQ2tCO0dBTEssNEJBQ3pCanNCO1lBT0UwRCxjQUFjamMsR0FBRWlQO0lBQ2xCLEdBaFdBdk47Ozs7YUFrV2lFK2lDLHFCQUFBQzs4Qjs7VUFBQUMsV0FuSG5FdHhCLDRCLG9CQW1IbUVxeEI7VUFBQUUsZ0RBQUFIO3dCQUFBRSxjQUFBQzs7S0FBL0Q7OztXQUhjNWtDLEdBQUVpUDs7O0lBSUU7S0FBQSxPQTVGbEIwekIsUUF3RmMzaUM7S0FJVixRQUFBOzs7OEJBQ1U0TSxnQkFBTSxXQUFOQTtTQUNDbW5CO0tBQU0sV0FBTkE7O0lBR1U7S0FEckIvcEIsU0FSVWhLO0tBU1Y2a0MscUJBQXFCLDZCQURyQjc2QixRQVJVaEs7S0FXSyxPQUFBLDZCQUhmZ0s7S0FFQTg2QjtPQUNGLHFDQVhjNzFCO0lBQUZqUCxPQUFFaVA7T0FVWjYxQjtRQURBRDtNQWFhLDZCQWRiNzZCLFFBUlVoSyxNQUFFaVA7VUFBRmpQLE9BQUFBLGNBVmQwWixTQVVjMVo7WUFTVjZrQztLQVFELFdBakJXN2tDLFNBQUFBO0tBa0JYLDZCQVZDZ0ssUUFSVWhLOztJQXVCZDtHQUFFO1lBR0ZrYyxpQkFBaUJsYyxHQUFFQztJQUFPLE9BMUIxQmdjLGNBMEJpQmpjLEdBM01uQnlnQyxhQTJNbUJ6Z0MsTUFBRUM7R0FBd0Q7WUFFM0U4a0MsU0FBTzdsQixhQUFZcEUsY0FBYTVPLEdBQUV1eUI7SUFDcEMsR0E1WEEvOEI7S0E0WGM7OztPQURPb1o7O0lBS1QsY0FBQSxPQUFBO3dCO0lBRlY7S0FERTlhOztRQUNROzs7O1FBSFM4YTtRQUFab0U7YUFXTHJHO0tBR0MsV0FBQSxrQ0FaRDdZO0tBWUM7TUFFRSxHQUFBLG1DQWRIQSxVQUFBQSxPQUFBQTtNQWlCZTtPQUFURSxTQUFTLFdBbkJlZ00sR0FBRXV5QjtPQXFCM0IsT0FBQSxrQ0FuQkx6K0I7TUFtQkssU0FBNkMsT0FBQSxrQ0FuQmxEQSxVQWlCTUU7Ozs7O0tBRUQ7SUFBK0Q7SUFuQnBFRixPQVNBNlk7SUFqREZhLFNBd0NFMVo7SUFzQkosT0F0QklBO0dBdUJIO1lBR0MyUSxLQUFHdU8sYUFBWXloQjtJQUFPO0lBQUEsT0E1QnRCb0UsU0E0Qkc3bEIsYUFBWXloQixxQjtHQUF3QztZQUV2RHFFLFlBQVU5bEIsYUFBWWpmLE1BQUtpTSxHQUFFVTtJQUMvQixPQS9CRW00QixTQThCVTdsQixhQTNPWnVoQixhQTJPWXZoQixhQUFZamYsT0FBS2lNLEdBQUVVO0dBQ3VCO1lBR3BEdU8sUUFBTStELGFBQVlqZjtJQUFPLE9BTnpCMFEsS0FNTXVPLGFBL09SdWhCLGFBK09RdmhCLGFBQVlqZjtHQUFxRDtZQUd6RWdsQyxTQUFXclYsS0FBMEI1dkIsR0FBRWtsQztJQUN6QyxHQURhdFY7U0FBT0MsTUFBUEQsUUFBQWdPLE9BQU8vTjs7U0FBUCtOLE9BQU87SUFDVCxJQUFQckYsT0FBTzthQUNIckM7O01BR0Y7aUJBR0YsaUNBUEFxQyxVQUNJckM7Z0JBQVIsaUNBRElxQztLQVFPO0tBSkw7MEJBRHVFLGlCQUFLOzs7WUFBN0MsV0E1Wm5DcEQsUUFpTUFsbUIsR0F1TnFDalAsR0FJVyxXQUpUa2xDO0tBS25DLE9BQUE7Y0EvWkp4UztjQTZaQTtnQkE1WkFpRDs7aUJBNlpJLFdBNVpKUixRQXdaV3lJLHNCQUlnQixpQkFBSzs7O0lBS3ZCO0lBUEgxSDtJQVNSLE9BQUEsaUNBVklxQztHQVdhO1lBR2Y0TSxxQkFBc0J2SCxNQUFLNTlCLEdBQUVvbEM7SUFDL0IsT0FoQkVIO2FBZXNCckg7YUFBSzU5Qjs7Y0FDRCxJQUFzQixPQUFBLFdBRG5Cb2xDLGtCQUNXLE9BaFh4Q3p1QixJQStXMkIzVztjQUNxQixPQUFBO2FBQWlCO0dBQUM7WUFHbEVzYixhQUFjK0IsT0FBT3VnQixNQUFLNTlCLEdBQUVrUDtJQUM5QixHQURnQm1PLFdBR1BvUSxJQUhPcFEsVUFDWmdvQixVQUVLNVgsWUFGTDRYLFVBcFhGMXVCLElBbVgwQjNXO0lBTVgsT0F6QmZpbEM7YUFtQnFCckg7YUFBSzU5Qjs7Y0FPZSxXQTFYekMyVyxJQW1YMEIzVztjQU8xQixPQUFBO29EQU5FcWxDLGVBRDBCbjJCO2FBT2lDO0dBQUM7T0FTNURvMkI7WUFXRkMsZUFDSTNWLEtBQ0RnTyxpQkFHRDFlLGFBQ0NoVCxHQUNBNE07SUFFTCxHQVJNOFc7U0FBUUMsTUFBUkQsUUFBQXZTLFFBQVF3Uzs7U0FBUnhTLFFBQVE7SUFRZDtTQU4wQnVlLGlCQUFwQjRKLG9CQUFvQjVKOztTQUFwQjRKO0lBTU47U0FMaUIxSixnQkFBWHpGLFdBQVd5Rjs7U0FBWHpGLFdBQVc7SUFNYixPQUFBO2FBbGRGM0Q7YUF5Y0lyVjs7Y0FVTSxJQUFSeE0sWUFBWTtjQUNoQixHQVZLK3NCO21CQWFJNkgsU0FiSjdIO2VBY0Q7aUJBeGRGbEw7aUJBdWRPK1M7O2tCQUVBOztxQkFBQSw2QkFaTHZtQixnQkFNQXJPO2tCQU1LOzZCQXpRUCt2Qjs4QkE2UEUxaEIsYUFNQXJPOzRCQVFJLGtDQWZGd2xCOztpQkFnQmlDO21CQVJuQ3FQLFNBR0tEOzs7bUJBSExDLFNBRVE7dUJBV0p4TjtlQUVOLEdBQUcsc0NBZkR3TjtnQkFnQkcsT0FBQSxrQ0F4QkRyUDtrQkFEQW1QO2dCQTJCQyxPQUFBO3lCQXRlTDlTO3lCQXNlSzsyRUF4QkZ4bUI7eUJBZ0NEeTVCO2VBTlEsSUFBSjdPLElBQUksV0ExQlA1cUI7ZUEyQkUsT0FBQSxzQ0FEQzRxQjt5QkFFSjhPO3lCQUZRLFdBeGVWbFQsTUF3ZU1vRSxHQUVKOE87Y0FEcUU7dUJBQ3JFQTtlQUNGLEdBQUcsc0NBdkJERjtnQkF3QkcsT0FBQSxrQ0FoQ0RyUDs7eUJBR0R2ZDt3REFGRG9HOzZCQUVDcEc7O2lCQWJLN1ksT0FhTDZZO3dCQXZTSDJuQixhQXFTRXZoQixhQVhNamY7O2dCQUU2QjtpQkFEZGlQLFdBWXBCNEo7aUJBWmMrc0IsT0FZZC9zQjtpQkFYa0MsT0ExWXJDbkMsSUFtWkV1STs7bUJBVEE7a0RBRGUybUIsWUFBTTMyQjtlQWdCckIyQixXQTVSRjZ2QixnQkFzUkV4aEIsbUJBb0JJZ1o7O2NBWTJEO3VCQUMvRHlOLGtCQUFrQkc7ZUFDcEIsU0FEb0JBO2dCQUdlO2lCQUExQmhPLFFBSFdnTztpQkFHZSxPQUFBO2dCQUFqQiw4Q0FBVGhPOztlQUNULE9BUkU4TjtjQVFXO2NBRWYsT0FuQlExTjthQW1CQTtHQUFBO1lBR042TixNQUFRMW9CLE9BQU91Z0IsTUFBTTRILG1CQUFtQm5QLFVBQVNyMkIsR0FBRUMsTUFBS2lNO0lBQzFELEdBQUcsZ0NBRGtEak07Ozs2REFBQUE7Ozs7OztLQUVoRDs7SUFDbUUsT0FsRHRFc2xDO2FBK0NRbG9CLE9BQU91Z0IsTUFBTTRILG1CQUFtQm5QLFVBQVNyMkIsR0FBT2tNLE9BQUxqTTtHQUcrQjtZQUdsRitsQyxRQUFPM29CLE9BQU91Z0IsTUFBTTRILG1CQUFrQnhsQyxHQUFFQyxNQUFLaU07SUFDL0MsT0FQRTY1QjthQU1PMW9CO2FBQU91Z0I7YUFBTTRIOzthQUFrQnhsQzthQUFFQzs7Y0FFeEMsV0FGNkNpTTtjQUU3QyxPQUFBO2FBQ1M7R0FBQztZQUdWbVEsaUJBQW1CZ0IsT0FBT3VnQixNQUFNNEgsbUJBQWtCeGxDLEdBQUVrUCxVQUFTaEQ7SUFDckQsSUFBTnNOLFFBMWNGN0MsSUF5Y2tEM1c7T0FBL0JxZDs7TUFLWmdvQixVQUxZaG9CO01BRVg0b0I7O1NBbFVSaDNCO1dBZ1VrRGpQO1dBVXpDOzRDQUxGcWxDLFNBSkw3ckIsT0FEa0R0SztNQUVsRDIyQixPQUdLUjs7U0FIQ1ksYUFBTkosT0FEQXJzQjtJQXNCUSxPQWxGVityQjthQTZEUVUsU0FGa0JySSxNQUFNNEgsc0JBQWtCeGxDLEdBQVdrTSxPQUUzRDI1QixNQUZrRDMyQjtHQXVCVjtZQUcxQ2czQixtQkFBa0I3b0IsT0FBT3VnQixNQUFNNEgsbUJBQWtCeGxDLEdBQUVrUCxVQUFTaEQ7SUFDOUQsT0EzQkVtUTthQTBCa0JnQjthQUFPdWdCO2FBQU00SDthQUFrQnhsQzthQUFFa1A7O2NBRW5ELFdBRjREaEQ7Y0FFNUQsT0FBQTthQUNTO0dBQUM7WUFHVmk2QixhQUFhbm1DLEdBQUVDLE1BQUs2MkI7SUFDdEIsSUFBSXNQLFVBN0lBanJCLFFBNElXbmIsR0FBRUMsT0FDSDs7S0FlbUIsbUJBQ1Y7Ozs7SUFHMkQ7a0JBSjlFLFdBampCRmsxQixRQStQRXdOLFFBbVNBeUQ7SUFPRixPQUFBO2FBMWlCQXpROztjQTBpQkU7Z0JBemlCRlI7Z0JBaWlCb0IyQjt5QkFRSmgxQjtpQkFDTCxZQXBQVDBaLE1BNE9BNHFCOzs7Ozs7O2tCQWFLOzs7aUJBQ0gsdUJBUFl0a0M7Z0JBT0g7O0dBTVo7WUFHRHNiLFlBQVlwZCxHQUFFa007SUFDSixJQUFSbVIsUUFsZ0JGMUcsSUFpZ0JZM1c7aUJBRU5FO0tBQ1I7TUFBNEIsTUFwZ0IxQnlXLElBaWdCWTNXO01BR1ZzZCxXQUFXLDBDQUZYRDtLQUdKLFdBRlFuZCxRQUNKb2Q7SUFDWTtJQUZDLFVBQUEsV0FGRHBSOztHQUlBO1lBR2RtNkIsZUFBZXJtQyxHQUFJLE9BQUpBLEVBQUs7WUFDcEJzbUMsZUFBZXRtQyxHQUFJLE9BQUpBLEVBQUs7Ozs7Ozs7O1dBempCbEJzQjs7O09BaUNOc047T0FXSXJNO09BVEFxRztPQUNBeU87T0FDQXVCO09BQ0EvVDtPQUNBa3JCO09BQ0ExVztPQUNBOUY7T0FDQStGO09BTUEzQztPQUxBSTtPQW9CQW9HO09BQUFBO09BQ0E2aUI7T0FBQUE7T0FHQXJqQjtPQUdBSztPQTBDQUU7T0EwQ0FzakI7V0F5UkU4RTtPQVdGQztPQXhRQW5wQjtPQUNBRDtPQUVBbE47T0FXQWxQO09BcVZBb21DO09Bd0JBL29COztRQWxWRi9KO1FBc0JBb3ZCO1FBSUl2cUI7UUFUUTRDOztRQStDUjNMO1FBNEVBNDFCO1FBOEJBQzs7UUEzRkF4cEI7UUFXQUU7UUFXQUQ7O1FBN0VBa25COztRQXdGQTFtQjtRQTBCQUM7UUE4QkF2TDtRQU1Bd0s7T0FrQkZncUI7T0FJQTdwQjtPQTBFQXlxQjtPQU1BQztPQU1BM3BCO09BMEJBNnBCO09BcUNBRztPQUNBQzs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0Mza0JKLFNBQUFobEMsVUFBS2lsQztJQUFMO0tBQ0U7TUFBQXJNO01BQUFzTSxXQUFBLDBCQURHRCxVQUNIck07S0FBQSx3QkFBQXNNOztJQUNzQjtLQUFBQztLQUFBbitCLFVBQUEsc0JBQUFtK0I7S0FBdEJDLGdDQUFzQnArQjtJQUF0QixvQkFBQW8rQjtHQUNrQjtZQUVoQi9WLFFBQVE1QyxNQUFPLFdBQU0sMkJBQWJBLE9BQWlDO1lBRXpDNFksZUFBZ0J4OEI7SUFDbEIsR0FEa0JBOzt1REFBQUE7Ozs7OztLQUdoQjs7SUFFTSxXQUxVQTtHQUtBO1lBR2hCQSxPQUFpQm5LO0lBQ25CLFNBRG1CQSxNQUdKLE9BSElBO1FBRVgyRyxJQUZXM0c7SUFFTixPQUFBLDBCQUFMMkc7R0FDZTtZQUdyQitGLE1BQWdCMU07SUFDbEIsU0FEa0JBLFVBRVYyRyxJQUZVM0csTUFFTCxPQUFBLDJCQUFMMkc7SUFGVTNHOztHQUdVO1lBRzFCNG1DLEtBQWU1bUMsR0FBUzRNO0lBQzFCLFNBRGlCNU0sVUFFVDJHLElBRlMzRyxNQUVKLE9BQUEsMkJBQUwyRyxHQUZrQmlHO0lBQVQ1TSxPQUFBQTs7R0FHc0I7WUFHckM2bUMsUUFHUTdtQztJQUZWLFNBRVVBLFVBREYyRyxJQUNFM0csTUFERyxPQUFBLDJCQUFMMkc7YUFDRTNHOzs7S0FDYTs7SUFEYkEsT0FBQUE7O0dBRWdCO1lBR3hCK0UsS0FBZS9FLEdBQVdrTTtJQUM1QixTQURpQmxNLFVBRVQyRyxJQUZTM0csTUFFSixPQUFBLDBCQUFMMkcsR0FGb0J1RjtjQUFYbE07Ozs7TUFLYixXQUx3QmtNO01BS3hCOzs7Ozs7R0FDRTs7Ozs7Ozs7T0EvQ1I1SztPQXFCSW9MO09BZEFpNkI7T0FrQ0E1aEM7T0ExQkFvRjtPQVZBd21CO09BNEJBa1c7T0FOQUQ7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDeEJKLFNBQUFFLGdCQUFLekg7SUFBTDs7U0FDRTBIO3dDQURHMUgsVUFDSDBIOztRQUFBQztrREFBQUE7R0FJa0I7WUFtRGR4ckIsTUFBTXhiO0lBQUksT0FBQSxrQ0FBSkE7R0FBNEI7R0FHeEMsU0E2QklpbkMsUUFBQXJsQyxHQUFBLE9BQUFBLE1BQU87WUFIQ3NsQywwQkFBQXRsQyxHQUFBLE9BQUFBLEtBQXlCO1lBQXpCdWxDLDhCQUFBdmxDLEdBQUFFLEdBQUFGLE9BQUFFLFlBQXlCO1lBUnpCeXNCLFFBQUEzc0IsR0FBQSxPQUFBQSxLQUFPO1lBSFB3bEMsbUJBQUF4bEMsR0FBQSxPQUFBQSxLQUFrQjtZQUFsQnlsQyx1QkFBQXpsQyxHQUFBRSxHQUFBRixPQUFBRSxZQUFrQjtZQUxsQndsQyxpQkFBQTFsQyxHQUFBLE9BQUFBLEtBQWdCO1lBQWhCMmxDLHFCQUFBM2xDLEdBQUFFLEdBQUFGLE9BQUFFLFlBQWdCO1lBRnhCMGxDLHNCQUFBNWxDLEdBQUEsT0FBQUEsS0FBcUI7WUFIckI2bEMseUJBQUE3bEMsR0FBQSxPQUFBQSxLQUF3QjtZQUh4QjhsQyxvQkFBQTlsQyxHQUFBLE9BQUFBLEtBQW1CO2dCQTJCbkJBLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUU7R0FBTztHQUFQOztJQUFBNmxDOzBCQUFBLFNBQU8scUJBQVBWO2dCQUhRcmxDLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUY7R0FBeUI7R0FBekI7SUFBQSxVQUFBdWxDO0lBQUFTOzt1QkFBQSxTQUF5Qjs7O09BQXpCVjs7Z0JBWEF0bEMsR0FBQUU7SUFBQSxXQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQTtHQUFrQjtHQUFsQjtJQUFBLFVBQUF5bEM7SUFBQVE7O3VCQUFBLFNBQWtCOzs7T0FBbEJUOztnQkFMQXhsQyxHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQWdCO0dBQWhCO0lBQUEsVUFBQTJsQztJQUFBTzs7dUJBQUEsU0FBZ0I7OztPQUFoQlI7O2dCQUZSMWxDLEdBQUFFO0lBQUEsV0FBQUYsTUFBQUEsTUFBQUEsTUFBQUUsR0FBQUYsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUE7R0FBcUI7R0FBckI7O0lBQUFtbUM7O3VCQUFBLFNBQXFCOzs7T0FBckJQOztnQkFIQTVsQyxHQUFBRTtJQUFBLFdBQUFGLE1BQUFBLE1BQUFFLEdBQUFGLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBO0dBQXdCO0dBQXhCOztJQUFBb21DOzt1QkFBQSxTQUF3Qjs7O09BQXhCUDs7Z0JBSEE3bEMsR0FBQUU7SUFBQSxXQUFBRixNQUFBRSxHQUFBRixNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQTtHQUFtQjtHQUFuQjs7SUFBQXFtQzs7dUJBQUEsU0FBbUI7OztPQUFuQlA7O1lBd0pGcG1DLFVBMUpHNG1DO0lBQUw7S0FRSUM7S0FIQUM7S0FIQUM7S0FEQUM7S0FTUUM7S0FLQUM7S0FHQUM7S0FHQUM7S0FLQUM7S0FHUkM7S0FBQXZkLFVBQUEsNENBQUF1ZDtLQTdCSkMsZ0NBNkJJeGQ7S0FIUUUsVUFBQSxzQkFBQW9kO0tBMUJaRyxrQ0EwQll2ZCxlQTFCWnNkOzt5Qjs7O0lBcUJZO0tBQUFwZCxVQUFBLDRCQUFBaWQ7S0FyQlpLLGtDQXFCWXRkLGVBckJacWQ7S0FrQlkzRyxVQUFBLHNCQUFBc0c7S0FsQlpPLGtDQWtCWTdHLGVBbEJaNEc7O0tBZVkxRyxVQUFBLDRCQUFBbUc7S0FmWlMsa0NBZVk1RyxlQWZaMkc7S0FVWWpkLFVBQUEsc0JBQUF3YztLQVZaVyxrQ0FVWW5kLGVBVlprZDs7U0F4Q01FLHdCQURBQyxzQkFESjFDOztNOztLQUVJO01BQUEvWixVQUFBLDRDQUFBd2M7TUFGSkUsa0NBRUkxYyxlQUZKK1o7O007VUFDWTRDO3lDQXlDVHBCLFVBekNTb0I7O0tBQVI7TUFBQWhoQyxVQUFBLHVDQUFBOGdDO01BREpHLGtDQUNJamhDLGVBREorZ0M7S0FBQSxXQUFBRTs7SUFrREU7S0FBQXRkLFVBQUEsaUNBQUFrYztLQVJKcUIsa0NBUUl2ZCxlQVJKaWQ7S0FLSS9jO09BQUE7O1NBTEMrYjtTQUtERTtLQUxKcUIsa0NBS0l0ZCxlQUxKcWQ7S0FFSW5kLFVBQUEsc0JBQUFnYztLQUZKcUIsa0NBRUlyZCxlQUZKb2Q7S0FDSWxkLFVBQUEsc0JBQUErYjtLQURKcUIsa0NBQ0lwZCxlQURKbWQ7SUFBQSxXQUFBQztHQStCNEI7WUFFeEIvZ0MsVUFBVStxQixhQUFZaVc7SUFDeEI7O01BQ00zOUI7aUJBQU1DLEdBQUU4aEI7U0FBUSxPQUFFLFdBQVo5aEIsR0FBWSwwQkFBVjhoQixPQUZVNGI7UUFFbUI7O2lCQWdDekIzQztTQUNOLFdBQUEsa0NBRE1BO1NBQ04sV0FBQTtTQUFpQyxHQUFBLG1DQW5DckIyQztTQW1DYyxNQUFBO1FBQXdDOztpQkFONUQxQztTQUNUO2FBQU8sbUNBREVBO1VBQ1QsTUFBQTtTQUNPOztXQUFBO3FDQUZFQSwyQkE3Qk0wQztVQStCZixNQUFBO1NBQ0c7O1lBQUE7c0NBSE0xQywyQkE3Qk0wQztTQWdDWixXQUFBO1lBaENZQTtTQWdDMkMsTUFBQTtRQUFnQjs7O1NBVHRFLFlBQ007YUFDSDVXO1NBQWUsR0FBQSxrQ0FBZkE7U0FBUSxNQUFBO1FBQTRCOztpQkFSbENzVTtTQUNULEtBQU8sbUNBREVBO1VBQ1QsTUFBQTtTQUNPLEtBQUEsbUNBRkVBLGtCQWpCTXNDO1VBbUJmLE1BQUE7U0FDRzs7WUFBQSxtQ0FITXRDLGtCQWpCTXNDO1NBb0JaLFdBQUE7U0FDUyxHQUFBLDJCQXJCR0E7U0FxQlYsTUFBQTtRQUErQzs7aUJBUHRDcEM7U0FDZCxXQWZlb0M7O1NBZVUsR0FBQSwyQkFEWHBDO1NBQ0ksTUFBQTtRQUE2Qzs7aUJBUHREQztTQUNUOztXQURTQTtXQVJOOVQ7U0FXRDtpQkFYYWlXLGVBQUFBLFdBQUFBO1VBV2I7WUFBQTtnREFIT25DO1NBRUYsR0FBQTtTQUFQLE1BQUE7UUFFd0U7S0FWM0V4N0I7Z0JBSVl5N0I7UUFBdUIsR0FBTyxtQ0FBOUJBOztRQUF1QixNQUFBO09BQWdDO09BckN2RU87S0FpQ0loOEIsWUE5QkorN0I7S0E4QkkvN0IsWUEzQko4N0I7S0EyQkk5N0IsWUF6Qkk2N0I7S0F5Qko3N0IsWUFwQkk0N0I7S0FvQko1N0IsWUFUSTI3QjtnQkFTSjM3QixZQU5KMDdCO0tBT0E7O1VBa0NBNTVCO0tBQU87TUFBUEMsMEJBQUFEOztNQUFPOzs7O3VCQW9GVHpNLDBCLGNBekh3QnNvQzs7d0RBcUN0QjU3Qjs7Ozs7Ozs7R0FBMkU7WUFJN0VnUSxZQUFhNnJCLFVBQUlDLGFBQWpCQyxPQUFBLE9BZ0ZBem9DLFVBaEZhdW9DLFVBQWJFO0dBQXFEO1lBRWpEN3hCLFlBQVV5YixvQkFBYzN6QixHQUFJLE9BM0M5QjRJLFVBMkNZK3FCLGFBQWMzekI7R0FBMkI7R0FIN0MsYUFDVmdlLGFBRUk5RjtZQUdGOHhCLDBCQUEwQmhxQztJQUFJLGtDQUFKQTtHQUF3QztZQUVsRWlxQyxlQUFlanFDLEdBQUU0TTs7S0FBRjVNLE9BQUFBO0tBSWQsV0FBQSxtQ0FKY0E7S0FJZCxjQUFxQyxrQ0FKdkJBO0lBSTZDO2tCQUhqQmtNLEdBQUssT0FDOUMsV0FEeUNBLEdBRDFCVSxHQUNrQztJQUFuQztLQUFBLE9BQUEsMEJBREQ1TTtLQUNqQixPQUFBO0lBQ0ksT0FBQTtHQUUwRDtZQUc1RGtxQyxLQUFLbHFDO0lBQ1AsZUFET0E7O0lBQUFBO0lBSUwsMkJBSktBLE1BM0ZId2I7SUFnR0YsMkJBTEt4YjtrQkFNb0Q0TSxHQUFLLE9BYjlEcTlCLGVBT0tqcUMsR0FNb0Q0TSxHQUF1QjtJQUFoRiw2Q0FOSzVNO3dEQUFBQTtHQU82QztZQUdsRG1xQyxRQUFRbnFDLEdBQUVrTTtJQUdaO0tBQWdCLE9BQUEsd0NBSEpBO0tBR1JraUIsTUFBSTtJQUhFcHVCLFdBR05vdUIsS0FITXB1Qjs7R0FJZTtZQUd2Qm9xQyxVQUFRcHFDLEdBQUkseUNBQUpBLE9BQXVCO1lBRTNCcXFDLFVBQVVycUM7SUFDaEIsR0FEZ0JBLE1BQ2hCLE1BQUE7SUFDTyxLQUFBLG1DQUZTQSxNQUFBQTtLQUVoQixNQUFBO0lBQ1ksR0FBQSwyQkFISUE7S0FHaEIsTUFBQTtJQUNVLElBekhGMEosTUF5SEUsMkJBSk0xSjtJQUFBQSxPQUFBQTtJQU1HLElBM0hUc3FDLGVBMkhTLDZDQU5IdHFDO2tCQVFSaThCO0tBUlFqOEIsT0FBQUE7Z0JBUVJpOEIsV0FSUWo4QixNQW5CZGtxQyxLQW1CY2xxQztRQUFBQSxNQU9oQixPQWpDRWlxQyxlQTBCY2pxQyxHQXJITnNxQztLQXFJUiw2Q0FoQmN0cUMsTUFySE5zcUM7S0FzSUQsS0FBQSwyQkFqQk90cUMsT0FPaEIsT0FQTXFxQyxVQUFVcnFDO2lCQUFBQTtpQkFxQkY7U0FDSGd6QjtLQUNMLGtDQURLQTtLQXRCS2h6Qjs7SUF3Qm9CO0lBNUlsQyxrQ0FETTBKLHVCQUFFNGdDO0lBQ1IsY0FHRTdjO0ssa0JBQUFBO01BRFksTUFBQTtLQUNZLE9BQXhCQTs7MkRBSkkvakI7SUE2SEosT0FBQTtHQWdCZ0M7WUFHbENxUixnQkFBaUJ5cUIsbUJBQWtCK0U7SUFDckM7S0FBSTdDO09BQXNCLDZDQURXNkM7S0FXekIsT0FBQTtJQVRaO1lBRm1CL0U7WUFDZmtDO1lBRGlDNkM7WUFLWDs7Ozs7WUFKdEI3Qzs7R0FXSDtZQUdDOEMsWUFBYWhGLG1CQUFrQitFO0lBQ2pDLE9BaEJFeHZCO2FBZWF5cUI7YUFDb0IsNkNBREYrRTtHQUMwQztZQU12RTFsQyxPQUFTK3FCLEtBQTJCaGpCO0lBQUksR0FBL0JnakI7U0FBb0JDLE1BQXBCRCxRQUFBNFYsb0JBQW9CM1Y7O1NBQXBCMlY7SUFBOEQsT0FQekVnRixZQU9XaEYsdUJBQTJCNTRCO0dBQXdDO0dBSC9ELG9CQUNqQnRMLFdBRUl1RDtZQUdGOFEsU0FBUTZ2QixtQkFBbUJrQztJQUM3QixHQUFHLG1DQUQwQkE7Ozs7aURBQUFBOzs7Ozs7O0tBRzNCOztJQU1BLE9BbENBM3NCO2FBeUJReXFCO2FBU1IsNkNBVDJCa0M7R0FTa0M7WUFrQjdENTZCLFFBQVM5TSxHQUFFODZCO0lBN05DLElBQVJ6ZCxRQUFRO0lBQ1o7SztNQUVjLE9BQUE7U0FDSHpROztNLHVCQVFEQSxjQUFLLGtCQUFMQTtVQUNHb0I7TUFBTyx1QkFBUEE7OzBCQUhPLE9BVHBCLFdBNE5XOHNCLE1Bek5BbHVCLEdBTWU7S0FKbkI7YUFBQTs7O0lBSk07S0FBQSxPQUFBLGtDQUZUeVE7S0F3TmNuZDtJQXpNbEI7Szs7OztJQU1RO0tBTkp1cUMsc0RBeU1jdnFDO0tBQWR3cUMsbUJBeE5BcnRCLE9BZUFvdEI7T0E4TUt6cUM7S0E3TFB3YixNQXdMRWt2Qjs7S0FVSiwyQkFMUzFxQyxNQUxMMHFDO0tBV0QsR0FBQSxtQ0FOTTFxQyxNQUFBQSxPQS9FTHFxQyxVQStFS3JxQzs7SUFNMEMsT0FYakNFO0dBWU47WUFHWnlxQyxzQkFBc0J6cUM7SUFDeEIsVUFEd0JBOzs7O2dCQUFBQSxlQUVsQjBNLElBRmtCMU0sV0FFYixPQUFMME07UUFFSW9CLE1BSmM5TjtJQUlQLE1BQUEsNEJBQVA4TjtHQUFnQjtZQUd4QjQ4QixVQUFRNXFDLEdBQUVrTTtJQUFJLFdBakJkWSxRQWlCUTlNLEdBQUVrTTs7aURBUFZ5K0I7R0FPb0Q7WUFFcERFLGtCQUFrQjdxQyxHQUFFa007SUFDdEIsSUFBSXFCLElBRGdCdk47SUFFakIsR0FBQSx5QkFEQ3VOOzs7S0FHRjs7SUFJVSxJQUFSdTlCLE9BQVE7SUFDTCxLQUFBLG1DQVJIdjlCO0tBUUosTUFBQTthQUNJdzlCLGNBQWNDO0tBQVEsT0FBMUIsa0NBRklGO0lBRXFDO0lBQ3pDLElBQUEsT0FWSXY5Qjs7OztNQVdhLFdBZGZxOUIsVUFFa0I1cUMsR0FVaEIrcUM7TUFFRjtNQUFBOzs7OztrQkFFTTdxQztLQUNSLGtDQVBJNHFDO0tBT0osT0F4QkVILHNCQXVCTXpxQztJQUVvQjtJQUZYLFdBakNmNE0sUUFtQmtCOU0sWUFjYWdyQyxNQUFTLE9BQUEsV0FkcEI5K0IsTUFjd0I7O0dBRWxCO1lBRzFCKytCLG1CQUlHQyxLQUpzQmgvQjtJQUMzQjs7ZUFHS2cvQixrQ0FBQUEsU0FKc0I5YyxNQUFBbGlCO2VBSXRCZy9CO1VBQ0l4RDs7O09BR3FCTyx3QkFKekJpRDtPQUNJeEQsc0JBR3FCTztLQUVqQjtNQUFKam9DLElBM0VQMlYsWUFzRU8reEI7TUFMa0J0WjtpQkFXbEJ4aEI7U0FBSyxPQWhDWmcrQixVQStCTzVxQyxtQkFDMEIsT0FBckIsV0FYYWtNLEdBV2xCVSxHQUE2QjtRQUFDOztJQVJyQixPQUFBLHNCQUhTd2hCO0dBV2E7WUFHdEMrYyxvQkFJR0QsS0FKdUJoL0I7SUFDNUI7O2VBR0tnL0Isa0NBQUFBLFNBSnVCOWMsTUFBQWxpQjtlQUl2QmcvQjtVQUNJeEQ7OztPQUdxQk8sd0JBSnpCaUQ7T0FDSXhELHNCQUdxQk87S0FFakI7TUFBSmpvQyxJQXpGUDJWLFlBb0ZPK3hCO01BTG1CdFo7aUJBV25Cd0csSUFBR0M7U0FBTSxPQTlDaEIrVixVQTZDTzVxQyxtQkFDOEIsT0FBckIsV0FYVWtNLEdBV25CMG9CLElBQUdDLElBQWtDO1FBQUM7O0lBUjdCLE9BQUEsc0JBSFV6RztHQVdvQjtZQUc5Q2dkLGdCQUFnQnByQztrQkFJR3FyQztLQUNuQixJQUFJQyxvQ0FMWXRyQyxNQUtTOzs7O09BR3JCOztVQXpESjRxQztZQWlEZ0I1cUM7O2FBS1pzckM7YUFLTTtlQUFBLG1DQUxOQSx1QkFMWXRyQztjQVdKLGtDQVBPcXJDO3NEQUFBQTtZQVFvQjtPQUxyQztPQUFBOzs7Ozs7SUFNRTtJQVRVLE9BQUE7R0FTVDtZQUdMRSxxQkFBbUJ2ckM7SUFDckIsR0FBRyxtQ0FEa0JBLE1BQUFBO0tBRWhCLE9BQUE7Z0JBRmdCQTs7U0FLWmd6QjtLQUFRLE9BQUEsa0NBQVJBOztrQkFDd0JBLE1BTlpoekIsV0FNWWd6QixnQkFBeUM7SUFBOUMsT0FBQTtHQUFnRDs7Ozs7Ozs7O09BeEg1RTF4QjtPQXpIRXNIO09BOEhBK007T0FWQTYwQjtPQWhOSjFEO09BcVBJaDZCO09BaUJBODlCO09BRUFDO09BbUJBSTtPQWNBRTtPQWNBQztPQTFQQTFEO09BUVFKO09BcUVSMEM7T0E2TEF1QjtPQXBMQXJCO09BdEVRM2I7T0FnRlI0YjtPQU9BQzs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3RLQXZsQztJQUNBa3JCOzs7Ozs7Ozs7Ozs7Ozs7OztPQURBbHJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FDQWtyQjs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNFaUJUO0lBQUFOO0lBQUFEO0lBQUFIO0lBQUFwUztJQUFBd0U7SUFBQXlOO0lBQUF4TjtJQUFBc047SUFBQUY7SUFBQXZoQjtJQUFBb2hCO0lBQUF0bEI7SUFBQTBXO0lBQUF6VTtJQUFBdWlCO0lBQUE5SztJQUFBaEM7SUFBQWhmO0lBQUFrZTs7SUFBQTlkO0lBQUF1STtJQUFBRDtJQUVqQmhLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUlBOEksV0FBV0M7SUFBbUMsV0FBQSxXQU43QnlULDJCQU13RCxXQUp6RXhjO0lBSWlCLE9BQUEscURBQU4rSTtHQUF5RTtZQUVwRkMsV0FBV0QsS0FBSStvQixPQUFPNWxCO0lBQ3hCO0tBQUk5RixNQUFJLFdBUE5wRztLQVM2QixPQUFBLFdBWFp3YywyQkFTZnBXO0tBQ0E4RDtPQUNGLHFEQUhXbkIsS0FBSStvQjtJQUtqQixPQUFBLFdBYm1CL0Msd0JBU2Yzb0IsS0FDQThELG1CQUZvQmdDO0dBS3FCO0dBR2xCLElBQXpCdVUseUJBQXlCLFdBZHpCemdCO1lBZUF3TixjQUFjeE47SUFBSTtLQUFBLE9BQUEsV0FqQkRvdEIsa0JBaUJIcHRCO0tBQUksT0FBQTtJQUFBLHNEQUFKQTtHQUEwRDtZQUN4RXdyQyxtQkFBbUJ4ckM7SUFBK0IsV0FBQSxXQWxCakNnSyxRQWtCRWhLO0lBQVEsV0FBQTtHQUFrQztZQUM3RHlyQyxvQkFBb0J6ckM7SUFBcUMsV0FBQSxXQW5CeENnSyxRQW1CR2hLO0lBQXFDLE9BQUE7R0FBVTtZQUNuRTByQyx3QkFBd0IxckM7SUFBeUMsVUFBQSxXQXBCaERnSyxRQW9CT2hLO0lBQXlDLE9BQUE7R0FBVTtZQUMzRTJyQyxnQkFBZ0IzckM7SUFBaUMsVUFBQSxXQXJCaENnSyxRQXFCRGhLO0lBQWlDLE9BQUE7R0FBVTtZQUMzRGtnQixZQUFZbGdCLEdBQUksT0FBSkEsTUFBaUI7WUFDN0I4ZixzQkFBc0I5ZixHQUFHa00sR0FBSGxNLFlBQUdrTSxHQUFIbE0saUJBQThEO1lBQ3BGMmYsb0JBQW9CM2YsR0FBR2tNLEdBQUhsTSxZQUFHa00sR0FBSGxNLGlCQUEwRDtZQUU5RTRyQywyQkFBMkI1ckMsR0FBR2tNO0lBQ25CLElBQVQyL0IsU0FBUztJQUNiLDZCQUY2QjdyQyxPQUN6QjZyQyxRQUQ0QjMvQjtJQUg5QjRULHNCQUcyQjlmLEdBQUdrTTtJQUdoQyxPQUZJMi9CO0dBR0U7WUFHSkMseUJBQXlCOXJDLEdBQUdrTTtJQUNqQixJQUFUMi9CLFNBQVM7SUFDYiw2QkFGMkI3ckMsT0FDdkI2ckMsUUFEMEIzL0I7SUFUNUJ5VCxvQkFTeUIzZixHQUFHa007SUFHOUIsT0FGSTIvQjtHQUdFO1lBVUpFLHlCQUF5QkMsS0FBSTkvQjtJQUdKLElBVEZraUIsTUFTRSxzQkFISWxpQjtpQkFMQXVoQixHQUFLLFdBQUksV0FEZlcsS0FDTVgsR0FBYztJQUF2QztLQUFBLE1BQUEsMkJBS3FCdWU7O0tBSHpCcGU7O1NBQVFoc0IsNEJBQVUsc0JBQWxCZ3NCLEdBQVFoc0I7OztvQkFPSHFxQyxvQkFBTyxPQUFQQTs7OztHQUs2RTtZQUdsRkMsK0JBQWtDbHNDLEdBQUU2ckM7SUFDaEMsWUFBQSw2QkFEOEI3ckMsT0FBRTZyQztnQkFHcEMsT0FBQTtRQUNLMy9CO0lBSjZCbE0sUUFabEMrckMseUJBWWtDL3JDLE9BSTdCa007O0dBQ3dFO1lBRzdFaWdDLCtCQUFnQ25zQyxHQUFFNnJDO0lBQzlCLFlBQUEsNkJBRDRCN3JDLE9BQUU2ckM7Z0JBR2xDLE9BQUE7UUFDSzMvQjtJQUoyQmxNLFFBcEJoQytyQyx5QkFvQmdDL3JDLE9BSTNCa007O0dBQThFO1lBR25Ga2dDLGdCQUFnQnBzQyxHQUFHa007aUJBQ0Zxc0I7S0FDakIsT0FyREF6WTtjQW1EZ0I5Zjs7ZUFFdUMsVUFBQSxXQUZwQ2tNLEdBQUhsTTtlQUV1QyxPQUFBLGlDQUR0Q3U0QjtjQUMyRDtJQUFDO0lBRGpFLE9BQUE7R0FDa0U7WUFHOUU4VCxZQUFZcnNDLEdBQUdzc0M7aUJBQ0UvVDtLQUNqQixPQTFEQXpZO2NBd0RZOWY7O2VBR1AsVUFBQSxnQ0FIT0EsT0FBR3NzQztlQUdWO3lCQURMLGlDQURpQi9ULE1BREx2NEI7O2NBSTZCO0lBQUM7SUFIOUIsT0FBQTtHQUcrQjtZQUczQ3VzQyxlQUFldnNDO2lCQUNFdTRCO0tBQ2pCLE9BakVBelk7Y0ErRGU5Zjs7ZUFFdUIsT0FBdEMsaUNBRGlCdTRCLE1BREZ2NEI7Y0FFNkQ7SUFBQztJQURqRSxPQUFBO0dBQ2tFO1lBRzlFb2dCLFlBQVlwZ0IsR0FBSSxPQUFKQSxLQUFpQjtZQUU3QnFlLCtCQUF3Q3JlLEdBQUV3c0M7SUFBRnhzQyxRQUV2QyxzQ0FGeUN3c0M7O0dBRVM7WUFHbkRwdUIsK0JBQW9DcGU7SUFDdEMsNkNBRHNDQTtHQUN1QztZQUczRWlmLCtCQUFrQ2pmLEdBQUVrTSxHQUFGbE0sUUFBRWtNLFlBQXdDO1lBRTVFdWdDLCtCQUFpQ3pzQyxHQUFFa0ssbUJBQWtCZ0MsR0FBRVU7SUFDekQsaUNBRG1DNU0sV0FBRWtLLG1CQUFrQmdDLEdBQUVVO0lBQ3pELE9BQUEsV0FEbUM1TTtHQUVEO1lBR2hDNmUscUJBQXFCN2UsR0FBRWtNLEdBQUZsTSxZQUFFa00sYUFBZ0M7WUFDdkQ2UyxvQkFBb0IvZSxHQUFFa00sR0FBRmxNLFlBQUVrTSxhQUErQjtZQUVyRHdnQyxhQUFhMXNDLEdBQUVrTTtJQUNPLElBQXBCaEMsb0JBQW9CLFdBakhMc1MsMkJBZ0hKeGM7O0tBR2IsT0FYQXlzQywrQkFRYXpzQyxHQUNYa0ssbUJBRGFnQztJQUcwQztJQURwQyxPQUFBO0dBQ3FDO1lBRzFEeWdDLGNBQWMzc0MsR0FBRTRzQyxZQUFXMWdDO0lBQ0wsSUFBcEJoQyxvQkFBb0IsV0F2SExzUywyQkFzSEh4YzthQUVaNnNDLFVBQVVEO0tBY1o7TUFBeUI7S0FBQSxPQTlCekJIO2NBY2N6c0MsR0FDWmtLLG1CQUR5QmdDLEdBRWYwZ0M7SUFlcUQ7SUFFbkU7S0FBeUI7SUFBQSxJQUdyQixVQUFBLHlCQXBCQUMsV0FGY0QsYUFzQmQ7Ozs7OEJBSUY7OztHQUFFO1lBR0ZFLGtCQUFrQjlzQyxHQUFFeXRCLEdBQUV2aEI7aUJBQ3VCMGdDO0tBQzdDLE9BQUUsV0FGb0IxZ0MsR0FFcEIsK0JBRDJDMGdDO0lBQ2Q7SUFEUyxPQTlCeENELGNBNkJrQjNzQyxHQUNKLCtCQURNeXRCO0dBRVk7WUFHaENzZixtQkFBbUIvc0MsR0FBRTRzQyxZQUFXMWdDO0lBQ1YsSUFBcEJoQyxvQkFBb0IsV0F6SkxzUywyQkF3SkV4YzthQUVqQjZzQztLQUdGO01BQ0s7S0FBQSxPQXRETEosK0JBZ0RtQnpzQyxHQUNqQmtLLG1CQUQ4QmdDO0lBT3lCO0lBRTNEO0tBQXlCO0lBQUEsSUFJckIsVUFBQSx5QkFYQTJnQyxXQUZtQkQsYUFhbkI7Ozs7OEJBSUY7OztHQUFFO1lBR0ZJLHVCQUF1Qmh0QyxHQUFFeXRCLEdBQUV2aEI7SUFBSSxPQXBCL0I2Z0MsbUJBb0J1Qi9zQyxHQUE2QiwrQkFBM0J5dEIsSUFBRXZoQjtHQUFvRDtZQUsvRStnQywyQkFBMkJqdEM7SUFDN0IsT0FBQSxzQ0FENkJBO0dBQzhCO0dBSTlDLElBQVh1YztZQUVBRyxjQUFjMWMsR0FBRzJXO0lBQ25CLE9BSGE7aURBRUczVyxPQUFHMlcsS0FGakI0RjtHQUd3RTtZQUd4RTJ3QixVQUFVbHRDO0lBQ1osR0E3TG1CMEI7S0E2TEwsMkRBREYxQixHQTVMT3NCO0lBOExULElBQU5xVixNQUFNO0lBRkUzVyxPQUFBQTtJQUFBQSxRQUVSMlc7SUFGUTNXO0lBTVosaUNBTllBO0lBT3lCLElBQWpDbXRDLGlDQUFpQyxXQW5NbEJ0aUMsY0E0TFA3SztJQVFaLGFBQTBDa00sR0FBSyxPQUFBLFdBQUxBLE1BQVM7SUFBbkQseUJBUllsTTtJQUpWMGMsY0FJVTFjLEdBRVIyVztJQVFKLFdBdE1tQjJZLGFBNExQdHZCLEdBQUFBO0lBWVY7S0FBTSxZQUFBLHdDQVpJQTs7S0FlUzs7TUFETGlPO01BQUxEO01BQ1UsTUFBQTtLQUFqQjt5REFEWUMsYUFBTEQ7O0lBT21CO1dBckJsQmhPO0tBcUJrQixNQUFBO0tBQTFCb3RDLGFBQWE7SUFyQkxwdEMsUUFxQlJvdEM7SUFyQlFwdEMsUUF1QmEsV0FuTk42SyxjQTRMUDdLLEtBT1JtdEM7SUFQUW50QyxRQXdCd0IsZ0NBeEJ4QkEsT0FxQlJvdEM7SUFJRCxVQUFBLGlDQXpCU3B0QztJQXlCVDtLQUFxRDtNQUFBLE1BQUEsV0FyTnJDb3RCLGtCQTRMUHB0QjtZQXlCNEM7OztJQUFBLFFBQ25ELGlDQTFCT0E7SUEwQlAsYUFDbUNrTSxHQUFLLE9BQUEsV0FBTEEsTUFBUztJQUFqRCx5QkEzQllsTTtJQUFBQTtTQTVMTzBCLGNBQUFBO0lBMk5qQjs7TUFHYW5CO01BQUFDO01BQUEyMkIsZ0RBQUEzMkI7TUFBQTZzQyxpQ0FBQTlzQztvQkFBQTQyQixjQUFBa1c7O0lBRGM7S0FBQSxNQTFNM0I1QixvQkF5S1V6ckM7S0FpQ1MsTUFBQTtLQUFqQixVQUFDLFdBN05jc2lCLGNBNExQdGlCOzs7R0FrQ3lCO1lBR25Dc3RDO0lBQ0YsR0FsT21CNXJDO0tBa09MO0lBQ04sSUFBSjBFLE1BQUksV0FqT05wRztJQWtPQyxHQUFBLFdBcE9nQnV1QixTQW1PZm5vQjs7NENBbk9lOUUsV0FtT2Y4RTs7Ozs7O0tBR0Y7O0lBS0E7S0EvQ0E4bUMsVUF1Q0U5bUM7S0EzQ0ZzVyxjQTJDRXRXLEtBU21CO0tBQ2xCLEtBNU5Ib0gsY0FrTkVwSDtNQWVKLFdBbFBtQjZELHVCQW1PZjdELEtBQUFBO1NBbk9lMUU7T0FtUEw7TUFBQSxJQUFBLHNCQUNGLE1BQUEsV0FwUE80Z0IsY0FtT2ZsYztNQWdCVSxPQUFBOzs7R0FDNkI7WUFHekNtbkM7SUFDRixJQUFJdnRDLElBeFBleXVCO0lBd1BmenVCOzs7T0FJSTs7OztNQUEwRTs7R0FBQztZQUdqRnd0QztJQUNGLEdBaFFtQjlyQyxPQWdRTDtJQUVNLFVBQUE7OztHQUFVO1lBRzVCNGMsaUJBQWlCdGUsR0FBSSxPQUFKQSxNQUFzQjtZQUN2Q3VlLHFCQUFxQnZlLEdBQUV1MkIsR0FBRnYyQixRQUFFdTJCLFlBQTJCO1lBQ2xEcFksc0JBQXNCbmUsR0FBRXUyQixHQUFGdjJCLFFBQUV1MkIsWUFBNEI7WUFDcEQ3WCxRQUFNMWUsR0FBSSx3Q0FBSkEsT0FBcUI7WUFFM0J3ZSwyQkFBNkJvUixLQUFnQzV2QjtJQUMvRCxHQUQrQjR2QjtTQUF5QkMsTUFBekJELFFBQUE2ZCx5QkFBeUI1ZDs7U0FBekI0ZDtJQUMvQixHQUQrQkE7S0FDRixVQUFBLFdBM1FWcmdCLGtCQTBRNENwdEI7S0FDbEMsR0FBQTtNQUN4QixPQUFBOzs0Q0FGMERBO0dBR3BCO1lBR3pDMHRDLFlBQWFuZ0M7SUFDZixHQUFHLG1DQURZQTs7dURBQUFBOzs7Ozs7OztJQUdQLEdBQUEsbUNBSE9BO3dCQUlDdk4sR0FBSyxPQVpuQjBlLFFBWWMxZSxHQUFZO0tBQWpCLE9BQUE7O0lBRWUsSUFBcEIydEMsd0JBTlNwZ0M7aUJBT0Z2TjtLQURQMnRDO0tBR0MsT0FBQSxtQ0FIREE7ZUFJRztnQkFKSEEsdUJBTlNwZ0MsR0FSYm1SLFFBZVcxZTtJQU1DO0lBTk4sT0FBQTtHQU1RO1lBR2RvZixpQkFBaUJwZjtJQUVuQixLQUZtQkEsY0FBQUE7SUFJbUI7V0FKbkJBO0tBSW1CLE1BQUE7S0FBaEM0dEMsa0JBQTJCO0lBQy9CLE9BQUEsZ0NBTGlCNXRDLE9BSWI0dEM7R0FFaUI7WUFPZnpkLElBRVFud0I7SUFGQSxJQWVTNnRDO0lBWnZCO0tBQUcsR0FBQSxtQ0FZb0JBO01BWGxCLE9BT0hDLGVBVFk5dEM7S0FHRixjQUFBLDJCQUhFQTtlQUdGO0tBRUcsSUFRQSt0QyxTQVJBLDJCQUxEL3RDO0tBTVosV0FyVGVpSyx1QkErU0hqSyxHQWFDK3RDOzs7VUFBUUMsOEJBQUFIO01BQ3ZCO09BQU8sS0FBQSxzQkFkTzd0QyxNQWFDK3RDO1FBQ2YsTUFBQTtPQUNHLEdBQUEsbUNBRm9CQyxpQ0FJckIsMkJBakJZaHVDLE1BYUMrdEMsU0FJYixPQVJBRCxlQVRZOXRDO09BbUJULElBbkJZaXVDLDhCQWFNRDtPQVFyQixJQUFNLFVBQUEsV0FST0Q7YUFXRGhnQyxXQUFBQywwQkFBQUQ7O1dBWFNpZ0MsOEJBYk5DOztNQXlCSjtPQUFMQyxLQUFLO09BQ1EsTUFBQTtNQUFqQiw2REFESUEsTUFETWxnQztVQVhTNi9CLDRCQWJOSTs7O1NBYU1KLDRCQWJOSTs7R0FGMkM7WUFXMURILGVBQWU5dEM7SUFDVixjQUFBLDJCQURVQTtjQUNWO3dCQUNpQyxPQWJsQ213QixJQVdXbndCLEdBRTRCO0lBQTFCLFVBbERuQjBlLFFBZ0RpQjFlO0lBRVksT0FBQTtHQUFpQjtZQW1CNUM0cUMsVUFBUzErQjtJQUNYO0tBQUk5RixNQUFJLFdBNVVScEc7S0E2VUltdUMsUUFEQS9uQztLQUVBZ29DLGNBQWMsMkJBRGREO0tBRzRCLE1BQUEsV0FsVmYzeEIsMkJBOFVicFc7S0FHQThEO09BQ0Y7SUFFRiwyQkFMSWlrQyxXQUVBamtDLG1CQUpPZ0M7a0JBR1BraUM7aUJBS2dCLFdBclZIdGhDLFNBOFViMUcsS0FHQThELG1CQXBDRWltQixLQWlDRi9wQjtHQU9pRDtHQUl0QyxvQkFqS2ZzVztZQXFLQXNELFNBQVNoZ0IsR0FBSSxPQUFKQSxNQUFjOzs7Ozs7OztPQTdWTnNCO09BRWpCdEI7T0FGaUI0STtPQUFBNFQ7T0FBQXVTO09BQUFIO09BQUEza0I7T0FBQTZDO09BQUFraUI7T0FBQVg7T0FBQUg7T0FnQmpCek47T0FNQVA7T0FzS0FndEI7T0FxQ0FJO09BL01BOUI7T0FDQUM7T0FDQUM7T0FDQUM7T0FyQmlCcnBCO09BQUFoQztPQUFBOE07T0FBQXZpQjtPQUFBeVU7T0EwRWpCOHNCO09BWUFHO09BS0Fuc0I7T0FxTUFoQjtPQTlMQWhCO09BTEFDO09BN0ZpQjRDO09BQUFEO09BcVFqQjFDO09BQ0FDO09BQ0FKO09BaFBBMkI7T0FDQUg7T0FFQWlzQjtPQU9BRTtPQTBCQUk7T0FRQUM7T0FuRWlCM3NCO09BK0VqQjZzQjtPQTlEQTcrQjtPQStGQWsvQjtPQU1BQztPQTZCQUc7T0FLQUM7T0FvQkFDO09BdEVBL3RCO09BUUFGO09BREFGO09BTEE0dEI7T0F5RUFROzs7Ozs7Ozs7T0EzS0Fua0M7T0FFQUU7T0ErT0F1a0M7T0FRQUM7T0FTQTl1QjtPQVFBZ3ZCO09BTkFsdkI7d0NBbUVFb3NCOztPQWdCRjVxQjs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0NqV1k7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNFWnFPLFlBQVlua0IsbUJBQWtCZ0MsR0FBRVU7SUFBSSxPQUFBLG9CQUFRLGtCQUFoQzFDLG1CQUFrQmdDLEdBQUVVO0dBQXdDO1lBRXhFeWhDLHdCQUF3Qm5rQyxtQkFBa0JnQyxHQUFFVTtJQUM5QyxPQUFBOzthQUFpQzthQURQMUM7YUFBa0JnQzthQUFFVTtHQUNlO1lBRzNENFA7SUFBK0IsT0FBMEIsZ0JBQUE7R0FBTTtZQUMvRDRELG1CQUFpQixPQUFZLGdCQUFBLGtCQUFNO1lBQ25Da3VCLHNCQUFvQixPQUFZLGdCQUFBLGtCQUFNO1lBQ3RDcHVCO0lBQXFELFVBRHJEb3VCO0lBQ3FELE9BQUE7R0FBbUI7WUFDeEVDO0lBQW9CLGtCQUFBO0lBQTBCLE9BQUEsNEJBQVY7R0FBZTtZQUNuREM7SUFBaUI7SUFBZ0IsT0FBQSw0QkFBQTtHQUFrRDtZQUNuRnB2Qix3QkFBc0IsT0FBaUIsZ0JBQUEsa0JBQU07WUFDN0NJLHVCQUFxQixPQUFnQixnQkFBQSxrQkFBTTtZQUMzQzZzQixZQUFhQztJQUFXLE9BQUEsZ0JBQVksa0JBQXZCQTtHQUF1QztZQUNwRG1DO0lBQXdCLE9BQWdCLGdCQUFBO0dBQU07WUFDOUM5QztJQUE4RCxVQUQ5RDhDO0lBQzhELE9BQUE7R0FBdUI7WUFFckZwd0IsK0JBQXdDM1g7SUFDMUMsT0FBQSxnQkFBd0Msa0JBREVBO0dBQ007WUFHOUMwWCxzQ0FBeUMsT0FBb0MsZ0JBQUE7R0FBTTtZQUNuRkQsc0JBQXNCdXdCO0lBQU8sT0FBQSxnQkFBc0Isa0JBQTdCQTtHQUF3QztZQUM5RHpCLGtDQUFnQyxPQUEyQixnQkFBQTtHQUFNO1lBQ2pFdnVCLGVBQVcsT0FBTSxnQkFBQSxrQkFBTTtZQUV2QkYsMkJBQTRCaXZCLCtCQUM5QixPQUFtRCxnQkFEckJBLHdCQUNxQjtHQUFNO1lBR3ZEQyxZQUFhbmdDO0lBQ2Y7S0FBaUMsTUFBQSxnQkFEbEJBO0tBQ1htZ0MsY0FBYztLQUNkdG5DLE1BQUk7d0JBQ1MsT0FBakIsV0FGSXNuQyxhQUNBdG5DLEtBQzBCO0lBQXhCLE9BQUE7R0FBeUI7WUFHN0J5RSxvQkFBa0IsT0FBYSxnQkFBQSxrQkFBTTtZQUNyQ3VpQix3QkFBc0IsT0FBaUIsZ0JBQUEsa0JBQU07WUFJM0N2TDtJQUF5QixPQUFvQixnQ0FBQTtHQUFNO1lBQ25ESyx3QkFBc0JoVztJQUFJLE9BQUEsa0NBQXNCLGtCQUExQkE7R0FBbUM7WUFDekQ4VixzQkFBb0I5VjtJQUFJLE9BQUEsZ0NBQW9CLGtCQUF4QkE7R0FBaUM7WUFDckR5aUMsNkJBQTRCemlDO0lBQUksT0FBQSx1Q0FBMkIsa0JBQS9CQTtHQUF3QztZQUNwRTBpQywyQkFBMEIxaUM7SUFBSSxPQUFBLHFDQUF5QixrQkFBN0JBO0dBQXNDO1lBRWhFMmlDLGlDQUFrQ2hEO0lBQ3BDLE9BQUE7NkNBQWtDLGtCQURFQTtHQUNXO1lBRzdDaUQsaUNBQWdDakQ7SUFDbEMsT0FBQTs2Q0FBZ0Msa0JBREVBO0dBQ1c7WUFHM0NrRCx5QkFBdUI3a0MsbUJBQWtCZ0M7SUFDM0MsT0FBQTtxQ0FBdUIsa0JBREVoQyxtQkFBa0JnQztHQUNPO1lBR2hEOGlDLDBCQUF3QjlrQyxtQkFBbUJnQyxHQUFFdWhCO0lBQy9DLE9BQUE7O2FBQXdCO2FBREV2akI7YUFBbUJnQzthQUFFdWhCO0dBQ007R0FyQnpDOzs7O09BRVY1TDtPQUNBSztPQUNBRjtPQUNBMnNCO09BQ0FDO09BRUFDO09BSUFDO09BSUFDO09BSUFDOzs7Ozs7OztPQXRERnh5Qjs7Ozs7Ozs7O09BTkE2UjtPQUVBZ2dCOzs7T0FPQW51QjtPQURBb3VCO09BR0FFO09BREFEO09BR0EvdUI7T0FDQTZzQjtPQVBBanNCO09BS0FoQjtPQUlBdXNCO09BREE4QztPQVNBeEI7T0FOQTV1QjtPQUlBRDtPQUNBRDtPQUVBTztPQUVBRjtPQUlBa3ZCO09BTUE3aUM7T0FDQXVpQjs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDaENGLFNBQUE2aEIsUUFBQUMsT0FBQUMsT0FBQUM7SUFBQSxHQUFBLCtCQUFBRCxPQUFBQyxRQUFBO2NBQUFEO2VBQUFDLG9DQUFBQSxPQUFBOzttQkFBQUEscUNBQUFBO1NBQUFDLFlBQUFELFVBQUFFLFdBQUFIO0tBQ2UsT0FBQSxXQURmRCxPQUFBSSxVQUFBRDs7SUFBQSxPQUFBLHFCQUFBRixPQUFBQztHQUk2QjtZQUo3Qjl0QyxVQUFLMDFCO0lBQUw7UUFDRXVZO3VDQURHdlksVUFDSHVZO0dBRzJCO0dBTFgscUJBQ2xCTixTQUFBM3RDOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNERTRkO0lBQWlCLFVBQUE7SUFBQSxPQUFBO0dBQTBEO1lBQzNFbmYsTUFBTUU7SUFBeUIsVUFEL0JpZjtJQUNhLE9BQUEsOENBQVBqZjtHQUE4QztZQUNwRGdQLEdBQUcweEI7SUFBc0IsVUFGekJ6aEI7SUFFVSxPQUFBLDhDQUFQeWhCO0dBQTJDO1lBRTlDd0UscUJBQXNCdkgsTUFBS3dIO0lBQ1UsVUFMckNsbUI7SUFLRixPQUFBLHlDQUR3QjBlLFdBQUt3SDtHQUN1QztZQUdsRTlwQixhQUFjK0IsT0FBT3VnQixNQUFLMXVCO0lBQ1UsVUFUcENnUTtJQVNGLE9BQUE7MkNBRGdCN0IsT0FBT3VnQixXQUFLMXVCO0dBQ21DO1lBRzdENjJCLE1BQVExb0IsT0FBT3VnQixNQUFNNEgsbUJBQW1CblAsVUFBU3AyQixNQUFLaU07SUFDSyxVQWIzRGdUO0lBYUYsT0FBQTs7YUFEVTdCO2FBQU91Z0I7YUFBTTRIO2FBQW1CblA7O2FBQVNwMkI7YUFBS2lNO0dBQzRCO1lBR2xGODVCLFFBQU8zb0IsT0FBT3VnQixNQUFNNEgsbUJBQWtCdmxDLE1BQUtpTTtJQUNLLFVBakJoRGdUO0lBaUJGLE9BQUE7O2FBRFM3QjthQUFPdWdCO2FBQU00SDs7YUFBa0J2bEM7YUFBS2lNO0dBQzRCO1lBR3ZFaVEsVUFBVWxjLE1BQUtpTSxHQUFFVTtJQUEwQixVQXBCM0NzUztJQW9CcUIsT0FBQSw4Q0FBWGpmLE1BQUtpTSxHQUFFVTtHQUFtRDtZQUNwRXdQLE9BQU91a0IsTUFBS3owQixHQUFFVTtJQUF1QixVQXJCckNzUztJQXFCa0IsT0FBQSw4Q0FBWHloQixNQUFLejBCLEdBQUVVO0dBQWdEO1lBRTlEeVAsaUJBQWtCZ0IsT0FBT3VnQixNQUFNNEgsbUJBQWtCdDJCLFVBQVNoRDtJQUNDLFVBeEIzRGdUO0lBd0JGLE9BQUE7O2FBRG9CN0I7YUFBT3VnQjthQUFNNEg7O2FBQWtCdDJCO2FBQVNoRDtHQUM0QjtZQUd0Rmc2QixtQkFBbUI3b0IsT0FBT3VnQixNQUFNNEgsbUJBQWtCdDJCLFVBQVNoRDtJQUszRCxVQWhDQWdUO0lBNEJGLE9BQUE7O2FBRHFCN0I7YUFBT3VnQjthQUFNNEg7O2FBQWtCdDJCO2FBQVNoRDtHQU8xRDtZQUdEaTZCLGFBQWFsbUMsTUFBSzYyQjtJQUE2QixVQXJDL0M1WDtJQXFDc0IsT0FBQSw4Q0FBVGpmLE1BQUs2MkI7R0FBb0Q7WUFDdEUxWixZQUFZbFI7SUFBNEIsVUF0Q3hDZ1Q7SUFzQ2dCLE9BQUEsOENBQUpoVDtHQUE4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUt4RGlQLFFBQU1sYixNQUFPLE9BQUEsZ0JBM0NmaWYsZ0JBMkNRamYsTUFBa0M7WUFDeEMra0MsWUFBVS9rQyxNQUFLaU0sR0FBRVU7SUFBSSxPQUFBLGdCQTVDdkJzUyxnQkE0Q1lqZixNQUFLaU0sR0FBRVU7R0FBdUM7WUFDeEQrRCxLQUFHZ3dCLE1BQU8sT0FBQSxnQkE3Q1p6aEIsZ0JBNkNLeWhCLE1BQStCO1lBQ2xDb0UsU0FBT3BFLE1BQUt6MEIsR0FBRXV5QjtJQUFJLE9BQUEsZ0JBOUNwQnZmLGdCQThDU3loQixNQUFLejBCLEdBQUV1eUI7R0FBb0M7Ozs7Ozs7O09BekJwRHJpQjtPQURBRDtPQWxCQWxOO09BREFsUDtPQW9DQW9tQzs7Ozs7Ozs7UUFTRXBCO1FBRkFDOzs7Ozs7O1FBQ0FyMEI7UUFGQXdLO09BdkNGZ3FCO09BSUE3cEI7T0FJQXlxQjtPQUlBQztPQVdBRTtPQUpBN3BCO09BZUFlOzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMzQ0FveUIsTUFBTXh2QyxHQUFHaUYsTUFBTWlIO2lCQUNJaE07Y0FDWGcyQixLQUFLeHZCLEdBQUU2dkI7TUFDYixHQUFHLHFCQURRN3ZCLEdBRlAxRztPQUlDLE9BQUEsa0NBSFlFLFFBQ0pxMkI7bUJBR1lBLEdBQUssT0FIeEJMLEtBQUt4dkIsV0FHYzZ2QixHQUFtQjtNQUF2QyxVQUFBLFdBTFFycUIsR0FFRnhGLEdBQUU2dkIsb0JBRlR2MkIsR0FFTzBHLE9BQUFBO01BR1UsT0FBQTtLQUF1QjtZQUh0Q3d2QixRQUZDanhCO0lBT0U7SUFORyxPQUFBO0dBTUY7WUFHWkQsS0FBS2hGLEdBQUdpRixNQUFNaUg7SUFBSSxPQVZsQnNqQyxNQVVLeHZDLEdBQUdpRixzQkFBa0MySCxHQUFFNmdCLEdBQUssT0FBQSxXQUFuQ3ZoQixHQUE0QlUsR0FBRTZnQixHQUFVO0dBQUM7WUFFdkRnaUIsUUFBUXp2QyxHQUFHa007aUJBQ0x3cUI7S0FDTSxVQUFBLDBCQUROQTtLQUNNLE9BQUE7SUFBa0I7SUFEbkI7O09BYlg4WTtTQVlReHZDOztrQkFDNEIwRyxHQUFFZ3dCLElBQUc5cEI7dUJBQW1CMnBCLEdBQUssV0FBTEEsR0FBdEJHLElBQWtDO1VBQTFCLFVBQUEsV0FEbkN4cUIsR0FDeUJ4RixHQUFLa0c7VUFBZSxPQUFBO1NBQWdCOzs7WUFJeEUrcEIsSUFBSUMsSUFBSyxPQUxUNlksUUFLSTdZLG9CQUEwQm5KLEdBQUssT0FBTEEsRUFBTSxHQUFDO1lBQ3JDb0osU0FBU0Q7SUFBdUIsVUFSaEM1eEIsS0FRUzR4Qix1QkFBb0RFLEdBQUssT0FBTEEsRUFBTTtJQUFuQyxPQUFBO0dBQXFDO1lBRXJFNFksTUFBUTlmLEtBQW1CNXZCLEdBQUdrTTtJQUNoQyxHQURVMGpCLFNBQU1DLE1BQU5ELFFBRVJzYixNQUZjcmIsY0FFZHFiO2NBQUFBLGlDQUFBQTtLQUVtQyxPQXhCbkNzRSxNQW9CMkJ4dkMsZUFJYTBHLFVBQUsrbUIsR0FBSyxPQUFBLFdBSnBCdmhCLEdBSVV4RixHQUFLK21CLEdBQVU7SUFEcEI7S0FBQSxNQUFBLHNDQURuQ3lkLEtBRjhCaC9CO0tBR0osTUFBQTtJQUFqQixPQUxUMnFCLFNBS1MsMkJBSGtCNzJCO0dBSTZCO1lBR3hEMnZDLEtBQU8vZixLQUFtQjV2QixHQUFHa007SUFDL0IsR0FEUzBqQixTQUFNQyxNQUFORCxRQUVQc2IsTUFGYXJiLGNBRWJxYjtjQUFBQSxpQ0FBQUEsS0FFZSxPQW5CZnVFLFFBZTBCenZDLEdBQUdrTTtJQUdDO0tBQUEsTUFBQSxzQ0FEOUJnL0IsS0FGNkJoL0I7S0FHUixNQUFBO0lBQWpCLE9BYkp5cUIsSUFhSSwyQkFIc0IzMkI7R0FJQztZQUczQjR2QyxRQUFTMUUsS0FBSWxyQyxHQUFHa007aUJBQ1YyakM7a0JBRW9DM3BDLElBQUd1bkIsR0FBRThJLEdBQUssT0FBTEEsUUFBRjlJLEdBQUh2bkIsTUFBQUEsR0FBbUM7S0FBN0UsVUFBQSwyQkFIYWxHLEdBQ1A2dkM7S0FFTixPQUFBO0lBQStFO0lBRmpFLFVBUmRGLEtBT1N6RSxLQUFJbHJDLEdBQUdrTTs7O1lBTWhCNGpDLFlBQWE1RSxLQUFJbHJDLEdBQUdrTTtJQUFJLElBQUEsc0JBQUEsTUFieEJ5akMsS0FhYXpFLEtBQUlsckMsR0FBR2tNO0lBQUksT0FBQTtHQUFtQztZQUUzRDZqQyxZQUFhN0UsS0FBSWxyQyxHQUFHa007aUJBQ2RsTTtLQUNLLFVBQUEsMkJBRExBO0tBQ0ssT0FBQTtJQUFpQjtJQURsQixVQWhCVjJ2QyxLQWVhekUsS0FBSWxyQyxHQUFHa007OztZQUtwQjhqQyxVQUFVaHdDLEdBQUdrTTthQUNQK2pDLElBQUl2cEM7S0FDVixHQUFHLHFCQURPQSxHQURBMUc7TUFHTCxPQUFBO2tCQUlEc1A7TSxPQUFBQTtnQkFBa0IsMENBQWxCQTtnQkFORTJnQyxJQUFJdnBDOztLQUlHLFVBQUEsV0FMQXdGLEdBQ0h4RixvQkFEQTFHLEdBQ0EwRyxPQUFBQTs7SUFNd0I7SUFFcEMsT0FSUXVwQztHQVFIO1lBR0hDLE1BQU1sd0MsR0FBR2tNO0lBQ1gsT0FiRThqQzthQVlNaHdDO3NCQUNZMEcsR0FBRXlwQzsyQkFDWjVaLEdBQ1IsT0FEUUEsWUFEVTd2QixHQUFFeXBDLFVBRWE7Y0FEckIsVUFBQSxXQUZIamtDLEdBQ1N4RixHQUFFeXBDOzs7R0FFYztZQUdsQ2xTLEtBQUtqK0IsR0FBR2tNO0lBQ1YsT0FuQkU4akM7YUFrQktod0M7NkJBQ2Vtd0M7MkJBQ1o1WixHQUNSLE9BRFFBLFFBRFk0WixTQUVRO2NBRGhCLFVBQUEsV0FGSmprQyxHQUNZaWtDOzs7R0FFUztZQUc3QkMsUUFBUXB3QyxHQUFHa007d0I7SUFFWDs7T0ExQkE4akM7U0F3QlFod0M7a0JBRVkwRyxHQUFFeXBDO3VCQUNaNVosR0FDUixPQURRQSxZQUNtQjtVQURmLFVBQUEsV0FISHJxQixHQUVTeEYsR0FBRXlwQzs7Ozs7WUFRdEJFLFNBQVNyd0MsR0FBR2tNO3dCO0lBRVo7O09BcENBOGpDO1NBa0NTaHdDO2tCQUVXMEcsR0FBRXlwQzt1QkFDWjVaLEdBQ1IsT0FEUUEsWUFDdUI7VUFEbkIsVUFBQSxXQUhGcnFCLEdBRVF4RixHQUFFeXBDOzs7OztZQVF0QnByQyxLQUFNbW1DLEtBQUlsckMsR0FBR2tNO0lBQUksT0F2RWpCd2pDLE1BdUVNeEUsS0FBSWxyQyxtQkFBOEI0TSxHQUFLLE9BQUEsV0FBaENWLEdBQTJCVSxHQUFRO0dBQUM7WUFDakQ5SCxJQUFLb21DLEtBQUlsckMsR0FBR2tNO0lBQUksT0FqRWhCeWpDLEtBaUVLekUsS0FBSWxyQyxtQkFBNkI0TSxHQUFLLE9BQUEsV0FBL0JWLEdBQTBCVSxHQUFRO0dBQUM7WUFDL0MwakMsV0FBWXBGLEtBQUlsckMsR0FBR2tNO0lBQUksT0FyRHZCNGpDLFlBcURZNUUsS0FBSWxyQyxtQkFBb0M0TSxHQUFLLE9BQUEsV0FBdENWLEdBQWlDVSxHQUFRO0dBQUM7WUFDN0QyakMsT0FBUXJGLEtBQUlsckMsR0FBR2tNO0lBQUksT0E1RG5CMGpDLFFBNERRMUUsS0FBSWxyQyxtQkFBZ0M0TSxHQUFLLE9BQUEsV0FBbENWLEdBQTZCVSxHQUFRO0dBQUM7WUFDckQ0akMsV0FBWXRGLEtBQUlsckMsR0FBR2tNO0lBQUksT0FyRHZCNmpDLFlBcURZN0UsS0FBSWxyQyxtQkFBb0M0TSxHQUFLLE9BQUEsV0FBdENWLEdBQWlDVSxHQUFRO0dBQUM7WUFDN0Q2akMsU0FBU3p3QyxHQUFHa007SUFBSSxPQWpEaEI4akMsVUFpRFNod0MsbUJBQTZCNE0sR0FBSyxPQUFBLFdBQS9CVixHQUEwQlUsR0FBUTtHQUFDO1lBQy9DdkgsT0FBT3JGLEdBQUdrTTtJQUFJLE9BMUJka2tDLFFBMEJPcHdDLG1CQUEyQjRNLEdBQUssT0FBQSxXQUE3QlYsR0FBd0JVLEdBQVE7R0FBQztZQUMzQ3hILFFBQVFwRixHQUFHa007SUFBSSxPQWpCZm1rQyxTQWlCUXJ3QyxtQkFBNEI0TSxHQUFLLE9BQUEsV0FBOUJWLEdBQXlCVSxHQUFRO0dBQUM7WUFDN0MzSCxLQUFNaW1DLEtBQUkzOUIsR0FBR3JCO3NCO0lBQUksT0FQakJwSCxJQU9Nb21DLEtBQW9CLDJCQUFoQjM5QixTQUFHckI7R0FBdUM7Ozs7Ozs7O09BbkdwRHNqQztPQVVBeHFDO09BdURBaTVCO09BTkFpUztPQXFDQU87T0FqREFUO09Ba0RBM3FDO09BMUJBK3FDO09BMkJBaHJDO09BakJBaXJDO09BaEVBMVo7T0FDQUU7T0FpRkE1eEI7T0FSQUY7T0F2RUEycUM7T0F3RUE1cUM7T0FqRUE2cUM7T0FtRUFZO09BNURBWDtPQTJEQVU7T0FyREFSO09BdURBVTtPQXJEQVQ7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMxQ0FQLE1BQU14dkMsR0FBR2lGLE1BQU1pSDtpQkFDSWhNO2NBQ1hnMkIsS0FBS2wyQixHQUFFMEcsR0FBRTZ2QjtNQUNmLEtBRFd2MkIsR0FFSCxPQUFBLGtDQUhTRSxRQUNGcTJCO1VBR1JDLEtBSEl4MkIsTUFHVHl0QixJQUhTenRCO21CQUdrQnUyQixHQUFLLE9BSDVCTCxLQUdDTSxJQUhNOXZCLFdBR2dCNnZCLEdBQXNCO01BQXRDLFVBQUEsV0FMQXJxQixHQUVBeEYsR0FBRTZ2QixHQUdiOUk7TUFBdUIsT0FBQTtLQUEwQjtZQUg3Q3lJLEtBRkZsMkIsTUFBR2lGO0lBT0k7SUFOQyxPQUFBO0dBTUE7WUFHZEQsS0FBS2hGLEdBQUdpRixNQUFNaUg7SUFBSSxPQVZsQnNqQyxNQVVLeHZDLEdBQUdpRixzQkFBa0MySCxHQUFFNmdCLEdBQUssT0FBQSxXQUFuQ3ZoQixHQUE0QlUsR0FBRTZnQixHQUFVO0dBQUM7WUFFdkRnaUIsUUFBUXp2QyxHQUFHa007SUFDYjtLQUFBO0tBQUE7T0FiRXNqQztTQVlReHZDOztrQkFDZTBHLEdBQUVnd0IsSUFBRzlwQjt1QkFDcEIycEIsR0FDUixXQURRQSxHQURpQkcsSUFFbEI7VUFESyxVQUFBLFdBRkR4cUIsR0FDWXhGLEdBQUtrRzs7O0lBQTlCLE9BQUE7R0FHWTtZQUdWK3BCLElBQUlDLElBQUssT0FQVDZZLFFBT0k3WSxvQkFBMEJuSixHQUFLLE9BQUxBLEVBQU0sR0FBQztZQUNyQ29KLFNBQVNEO0lBQXVCLFVBVmhDNXhCLEtBVVM0eEIsdUJBQW9ERSxHQUFLLE9BQUxBLEVBQU07SUFBbkMsT0FBQTtHQUFxQztZQUVyRTRZLE1BQVE5ZixLQUFtQjV2QixHQUFHa007SUFDaEMsR0FEVTBqQixTQUFNQyxNQUFORCxRQUVSc2IsTUFGY3JiLGNBRWRxYjtjQUFBQSxpQ0FBQUE7S0FFbUMsT0ExQm5Dc0UsTUFzQjJCeHZDLGVBSWEwRyxVQUFLK21CLEdBQUssT0FBQSxXQUpwQnZoQixHQUlVeEYsR0FBSyttQixHQUFVO0lBRHJCO0tBQUEsTUFBQSxzQ0FEbEN5ZCxLQUY4QmgvQjtLQUdMLE1BQUE7SUFBaEIsT0FMVDJxQixTQUtTLDBCQUhrQjcyQjtHQUk2QjtZQUd4RDJ2QyxLQUFPL2YsS0FBbUI1dkIsR0FBR2tNO0lBQy9CLEdBRFMwakIsU0FBTUMsTUFBTkQsUUFFUHNiLE1BRmFyYixjQUVicWI7Y0FBQUEsaUNBQUFBLEtBRWUsT0FyQmZ1RSxRQWlCMEJ6dkMsR0FBR2tNO0lBR0E7S0FBQSxNQUFBLHNDQUQ3QmcvQixLQUY2QmgvQjtLQUdULE1BQUE7SUFBaEIsT0FiSnlxQixJQWFJLDBCQUhzQjMyQjtHQUlDO1lBRzNCNHZDLFFBQVMxRSxLQUFJbHJDLEdBQUdrTTtpQkFDVjJqQztrQkFDMEMzcEMsSUFBR3VuQixHQUFFOEksR0FBSyxPQUFMQSxRQUFGOUksR0FBSHZuQixNQUFBQSxHQUFtQztLQUE1RSxVQUFBLDBCQUZNbEcsR0FDUDZ2QztLQUNDLE9BQUE7SUFBOEU7SUFEdkUsVUFSZEYsS0FPU3pFLEtBQUlsckMsR0FBR2tNOzs7WUFLaEI0akMsWUFBYTVFLEtBQUlsckMsR0FBR2tNO0lBQUksSUFBQSxzQkFBQSxNQVp4QnlqQyxLQVlhekUsS0FBSWxyQyxHQUFHa007SUFBSSxPQUFBO0dBQWtDO1lBQzFENmpDLFlBQWE3RSxLQUFJbHJDLEdBQUdrTTtJQUFJLElBQUEsc0JBQUEsTUFieEJ5akMsS0FhYXpFLEtBQUlsckMsR0FBR2tNO0lBQUksT0FBQTtHQUE4QjtZQUV0RDhqQyxVQUFVaHdDLEdBQUdrTTtJQUNmLFNBQVE4akMsVUFBVWh3QyxHQUFHa00sR0FBRXhGO0tBQ3JCLEtBRGdCMUcsR0FFUixPQUFBO1NBQ0Ewd0MsS0FIUTF3QyxNQUdkMndDLEtBSGMzd0M7a0JBTVhzUDtNLE9BQUFBO2dCQUFrQiwwQ0FBbEJBO2dCQU5DMGdDLFVBR0VVLElBSFd4a0MsR0FBRXhGOztLQUlQLFVBQUEsV0FKS3dGLEdBQUV4RixHQUduQmlxQzs7SUFHaUM7SUFFckMsT0FSUVgsVUFESWh3QyxHQUFHa007R0FTQztZQUdkZ2tDLE1BQU1sd0MsR0FBR2tNO0lBQ1gsT0FiRThqQzthQVlNaHdDO3NCQUNZMEcsR0FBRXlwQzsyQkFDWjVaLEdBQ1IsT0FEUUEsWUFEVTd2QixHQUFFeXBDLFVBRWE7Y0FEckIsVUFBQSxXQUZIamtDLEdBQ1N4RixHQUFFeXBDOzs7R0FFYztZQUdsQ2xTLEtBQUtqK0IsR0FBR2tNO0lBQ1YsT0FuQkU4akM7YUFrQktod0M7NkJBQ2Vtd0M7MkJBQ1o1WixHQUNSLE9BRFFBLFFBRFk0WixTQUVRO2NBRGhCLFVBQUEsV0FGSmprQyxHQUNZaWtDOzs7R0FFUztZQUc3QkMsUUFBUXB3QyxHQUFHa007d0I7SUFFWDs7T0ExQkE4akM7U0F3QlFod0M7a0JBRVkwRyxHQUFFeXBDO3VCQUNaNVosR0FDUixPQURRQSxZQUNtQjtVQURmLFVBQUEsV0FISHJxQixHQUVTeEYsR0FBRXlwQzs7Ozs7WUFRdEJFLFNBQVNyd0MsR0FBR2tNO3dCO0lBRVo7O09BcENBOGpDO1NBa0NTaHdDO2tCQUVXMEcsR0FBRXlwQzt1QkFDWjVaLEdBQ1IsT0FEUUEsWUFDdUI7VUFEbkIsVUFBQSxXQUhGcnFCLEdBRVF4RixHQUFFeXBDOzs7OztZQVF0QnByQyxLQUFNbW1DLEtBQUlsckMsR0FBR2tNO0lBQUksT0FsRWpCd2pDLE1Ba0VNeEUsS0FBSWxyQyxtQkFBOEI0TSxHQUFLLE9BQUEsV0FBaENWLEdBQTJCVSxHQUFRO0dBQUM7WUFDakQ5SCxJQUFLb21DLEtBQUlsckMsR0FBR2tNO0lBQUksT0E1RGhCeWpDLEtBNERLekUsS0FBSWxyQyxtQkFBNkI0TSxHQUFLLE9BQUEsV0FBL0JWLEdBQTBCVSxHQUFRO0dBQUM7WUFDL0MyakMsT0FBUXJGLEtBQUlsckMsR0FBR2tNO0lBQUksT0F0RG5CMGpDLFFBc0RRMUUsS0FBSWxyQyxtQkFBZ0M0TSxHQUFLLE9BQUEsV0FBbENWLEdBQTZCVSxHQUFRO0dBQUM7WUFDckQwakMsV0FBWXBGLEtBQUlsckMsR0FBR2tNO0lBQUksT0FsRHZCNGpDLFlBa0RZNUUsS0FBSWxyQyxtQkFBb0M0TSxHQUFLLE9BQUEsV0FBdENWLEdBQWlDVSxHQUFRO0dBQUM7WUFDN0Q0akMsV0FBWXRGLEtBQUlsckMsR0FBR2tNO0lBQUksT0FsRHZCNmpDLFlBa0RZN0UsS0FBSWxyQyxtQkFBb0M0TSxHQUFLLE9BQUEsV0FBdENWLEdBQWlDVSxHQUFRO0dBQUM7WUFDN0Q2akMsU0FBU3p3QyxHQUFHa007SUFBSSxPQWpEaEI4akMsVUFpRFNod0MsbUJBQTZCNE0sR0FBSyxPQUFBLFdBQS9CVixHQUEwQlUsR0FBUTtHQUFDO1lBQy9DdkgsT0FBT3JGLEdBQUdrTTtJQUFJLE9BMUJka2tDLFFBMEJPcHdDLG1CQUEyQjRNLEdBQUssT0FBQSxXQUE3QlYsR0FBd0JVLEdBQVE7R0FBQztZQUMzQ3hILFFBQVFwRixHQUFHa007SUFBSSxPQWpCZm1rQyxTQWlCUXJ3QyxtQkFBNEI0TSxHQUFLLE9BQUEsV0FBOUJWLEdBQXlCVSxHQUFRO0dBQUM7WUFDN0MzSCxLQUFNaW1DLEtBQUkzOUIsR0FBR3JCO3NCO0lBQUksT0FQakJwSCxJQU9Nb21DLEtBQW9CLDJCQUFoQjM5QixTQUFHckI7R0FBc0M7Ozs7Ozs7O09BaEduRHNqQztPQVVBeHFDO09Bb0RBaTVCO09BTkFpUztPQXFDQU87T0FqREFUO09Ba0RBM3FDO09BMUJBK3FDO09BMkJBaHJDO09BakJBaXJDO09BM0RBMVo7T0FDQUU7T0E0RUE1eEI7T0FSQUY7T0FsRUEycUM7T0FtRUE1cUM7T0E1REE2cUM7T0E2REFZO09BdERBWDtPQXVEQVU7T0FsREFSO09BbURBVTtPQWxEQVQ7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUN2Q0FhLE9BQU81d0MsR0FBRXNULEdBQUdwSDtpQkFDTjBqQjt5QkFDb0IsT0FEcEJBLElBQ3VCO0tBQWIsT0FBQSx5QkFGVDV2QixHQUFFc1Q7SUFFcUI7SUFEbEIsVUFBQSxXQURBcEgsR0FDRSx5QkFEUGxNLEdBQUVzVDs7O1lBS1R1OUIsT0FBTzd3QyxHQUFFc1QsR0FBR3BIO2lCQUNOakQsTUFDUixPQUFBLHlCQUZTakosR0FBRXNULEdBQ0hySyxNQUNjO0lBRFAsVUFBQSxXQUREaUQsR0FDRyx5QkFEUmxNLEdBQUVzVDs7O1lBS1R3OUIsVUFBVzVGLEtBQUlsckMsR0FBR2tNO0lBQW1CLFVBQUEseUJBQXRCbE07SUFBTyxPQUFBLDJDQUFYa3JDLFVBQU9oL0I7R0FBa0M7WUFDcERuSCxLQUFNbW1DLEtBQUlsckMsR0FBR2tNO0lBQW1CLFVBQUEseUJBQXRCbE07SUFBTyxPQUFBLDJDQUFYa3JDLFVBQU9oL0I7R0FBa0M7WUFDL0N3akMsTUFBT3hFLEtBQUlsckMsR0FBR2tNOztLQUF1QyxJQUFXakQsaUJBQUxGO0tBQWMsT0FBQSxXQUEzRG1ELEdBQTZDbkQsS0FBS0U7SUFBc0I7SUFBckQsVUFBQSw0QkFBdEJqSjtJQUEwQyxPQUFBLDJDQUE5Q2tyQztHQUErRTtZQUV0RmxtQyxLQUFLaEYsR0FBR2lGLE1BQU1pSDtJQUNoQixhQUNxQ25ELEtBQUtFLE1BQUs4bkMsT0FBUyxlQUFuQmhvQyxLQUFLRSxPQUFLOG5DLE9BQTZCO0lBQTFFLElBREVDLGdDQUNGLHlCQUZLaHhDO0lBSVAsYUFBc0RrRztLQUFMLElBQWMrQyxpQkFBTEY7S0FBYyxPQUFBLFdBSnhEbUQsR0FJMENuRCxLQUFLRSxNQUFUL0M7SUFBa0M7SUFBdkMsT0FBQTs7YUFIN0M4cUM7YUFETS9yQzs7R0FJOEU7WUFHdEZnc0MsV0FBV2p4QyxHQUFHaUYsTUFBTWlIO0lBQ3RCLGFBQytCbkQsS0FBS0UsTUFBSzhuQyxPQUFTLGVBQW5CaG9DLEtBQUtFLE9BQUs4bkMsT0FBNkI7SUFBcEUsSUFERUcsZ0NBQ0YseUJBRldseEM7SUFJYixhQUFzRGtHO0tBQUwsSUFBYytDLGlCQUFMRjtLQUFjLE9BQUEsV0FKbERtRCxHQUlvQ25ELEtBQUtFLE1BQVQvQztJQUFrQztJQUF2QyxPQUFBOzthQUg3Q2dyQzthQURZanNDOztHQUl3RTtHQUl4RixTQUdZL0UsT0FBQTBCLEdBQUEsT0FBQUEsS0FBTTtZQWdDaEJrdUMsWUFBY2xnQixLQUFtQjV2QixHQUFHa007SUFDdEMsR0FEZ0IwakIsU0FBTUMsTUFBTkQsUUFBQXNiLE1BQU1yYixjQUFOcWI7Y0FBQUEsaUNBQUFBO0tBMUJDO01BQWJ2NEIsYUFBYSx3QkEwQmtCM1M7TUF6Qi9CbXhDLFdBQVcscUNBeUJvQm54Qzs7aUJBeEJkZ3pCO3NCQWdCSnZGO1VBQ1g7V0FJSyxNQUFBLG9DQUxNQTtXQUdULE1BQUEsOEJBckJKOWE7VUFxQkksT0FBQSxrQ0FuQmFxZ0I7U0FxQmtEO3NCQWpCM0Ryc0IsVUFBZTJNO1VBQXBCLElBQWFySyxpQkFBTEY7O1dBQ1csWUFBcEIsT0FBQSxXQURxQnVLLEdBQWYzTTtXQUtBO1lBRkdzQztZQUNEckM7Y0FDRixvQ0FMQUQsR0FOUmdNLFlBTVc1SixLQUdBRTtXQVFMLE9BQUEsV0FYaUJxSyxHQUliMU07VUFPQTtVQVZILFVBQUEsV0FtQjJCc0YsR0FwQnZCbkQsS0FBS0U7VUFDTSxPQUFBO1NBVVg7U0FDSCxPQUFBOztrQkFqQlJrb0M7Ozs7UUFzQm9FO0tBckJ4RCxPQUFBOztJQTRCSCxJQUFQMW1DO0lBQ0osYUFDc0IxQixLQUFLRTtLQUNiLElBQU5TLFVBRGNYLEtBQUtFO0tBRnZCd0IsY0FHSWYsS0FISmU7S0FLQSxPQUZJZjtJQUVEO0lBSEwsSUFERTBuQyxVQUNGLHlCQU4rQnB4Qzt3QkFpQmpDLGdDQVpJb3hDLFNBckNNbHhDLFFBaUQwQjtpQkFKOUJ3SjtLQURvQyxJQUN6QlQsT0FBWFMsUUFBRVgsTUFBRlc7a0JBQ1ErakIsR0FEUi9qQixTQUNRK2pCLFlBQ087S0FESCxVQUFBLFdBZGtCdmhCLEdBYTVCbkQsS0FBU0U7O0lBRUs7SUFITDtLQUFBLE1BQUEsMEJBUmJ3QjtLQVFGLE1BQUEsK0NBWll5Z0M7O0dBaUJzQjtZQUdwQ29GLFdBQVlwRixLQUFJbHJDLEdBQUdrTTtJQUFJLE9BcEJ2QjRqQzthQW9CWTVFLEtBQUlsckMsbUJBQTBDaUosTUFBUSxPQUFBLFdBQS9DaUQsR0FBdUNqRCxNQUFjO0dBQUM7WUFFekVvb0MsWUFBYW5HLEtBQUlsckMsR0FBR2tNO0lBQ3RCLE9BdkJFNGpDO2FBc0JhNUU7YUFBSWxyQztzQkFDUytJLEtBQUtFOzJCQUN2QnN0QixHQUNSLE9BRFFBLFFBRHVCdHRCLFVBRUY7Y0FEakIsVUFBQSxXQUZRaUQsR0FDTW5EOzs7R0FFSTtZQUc5QnduQyxPQUFRckYsS0FBSWxyQyxHQUFHa007SUFDakIsT0E3QkU0akM7YUE0QlE1RTthQUFJbHJDOzZCQUNxQmlKOzJCQUN6QnN0QixHQUNSLE9BRFFBLFFBRHlCdHRCLFVBRUo7Y0FEakIsVUFBQSxXQUZHaUQsR0FDa0JqRDs7O0dBRUg7WUFHOUIybUMsUUFBUzFFLEtBQUlsckMsR0FBR2tNO0lBQ2xCLE9BbkNFNGpDO2FBa0NTNUU7YUFBSWxyQztzQkFDYStJLEtBQUtFOzJCQUN2QnN0QixHQUNSLE9BRFFBLFFBRHVCdHRCLFVBRUY7Y0FEakIsVUFBQSxXQUZJaUQsR0FDVW5ELEtBQUtFOzs7R0FFRDtZQUc5QjBtQyxLQUFNekUsS0FBSWxyQyxHQUFHa007SUFDZixPQXpDRTRqQzthQXdDTTVFO2FBQUlsckM7c0JBQ2dCK0ksS0FBS0U7MkJBQ3ZCdzFCLEdBQ1IsV0FEUUEsR0FDRjtjQURNLFVBQUEsV0FGQ3Z5QixHQUNhbkQsS0FBS0U7OztHQUV4QjtZQUdQbkUsSUFBS29tQyxLQUFJbHJDLEdBQUdrTTtJQUFJLE9BTmhCeWpDLEtBTUt6RSxLQUFJbHJDLG1CQUFtQ2lKLE1BQVEsT0FBQSxXQUF4Q2lELEdBQWdDakQsTUFBYztHQUFDO1lBRTNEcW9DLE1BQU9wRyxLQUFJeDdCLElBQUdDLElBQUl6RDtJQUNwQixhQUdVcWxDLE9BQVMsT0FBQSxXQUFUQSxVQUFpQjtpQkFEQ3hvQyxLQUFJMDFCO0tBQUssMkJBQWdCLE9BQWhCLFdBSGpCdnlCLEdBR1FuRCxLQUFJMDFCLEdBQTZCO0lBQUM7SUFDekQsT0FoQ0g2UixXQTRCT3BGLEtBR1AseUJBSFd4N0IsSUFBR0M7R0FJWTtZQUcxQmduQixJQUFJMzJCLEdBQUksT0FUUjhFLE9BU0k5RSxpQkFBSSxjQUFjOzs7Ozs7OztPQXZIdEI0d0M7T0FLQUM7T0FLQUM7T0FDQS9yQztPQUNBMnFDO09Ba0dBNXFDO09BTkE2cUM7T0ExRkEzcUM7T0FPQWlzQztPQWlFQUk7T0FNQWQ7T0FNQVg7T0FkQVU7T0FwQkFSO09BZ0RBd0I7T0FPQTNhOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMxSEE2YTtJQUFVLHVCQUNQL2pCLGNBQUssT0FBTEE7UUFDR3pmO0lBQU8sT0FBQSx3QkFBUEE7R0FBOEQ7WUFHcEV5akMsUUFBa0JDLFVBQXNEeGxDO2lCQUcxQlU7eUJBSS9CLE9BSGIsV0FKc0VWLEdBRzFCVSxHQUk1QjtLQUFkLE9BQUE7SUFBZTtJQUpuQixJQURFd2hCLE1BQ0YsNkJBSGtCc2pCO2lCQVNGOWtDO0tBQUssVUFBQSxXQVBuQndoQixLQU9jeGhCO0tBZE4sT0FBQSw4Q0FBVjRrQztJQWNvQztJQUF6QixPQUFBO0dBQTBCO1lBR3JDOWMsS0FBS3hvQjs7S0FHSCxPQUZKLDJEQURPQTtJQU1BO0lBSkwsSUFERWtpQixNQUNGOztLQU1zQixVQUFBLFdBUHBCQTtLQWJNLE9BQUEsOENBTFJvakI7SUF5QnNDO0lBQTNCLE9BQUE7R0FBNEI7Ozs7O3dDQXBCdkNDLFNBWUEvYzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNUSWQsU0FBT2huQjtJQUFJLE9BQWdCLDJDQUFwQkE7R0FBNEI7WUFFbkNrbkIsS0FBSzl6QixHQUFHa007O0tBQ1MsWUFFUCxPQUFBO1NBREhVO0tBQUssT0FBQSxXQUZKVixHQUVEVTtJQUN3QjtJQUZkLE9BQUEsdUNBRFo1TTtHQUcwQjtHQUl6QjtJQUFOOEU7OztnQkFESTlFLEdBQUdrTTtxQkFBMkJ0SyxHQUFLLE9BQTVCLDRCQUF1QkEsR0FBM0JzSyxHQUErQztRQUF6QixPQUFBLHVDQUF6QmxNO09BQW1EOzRDQU52RDh6QixNQUZBRixVQVNBOXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNYSjZzQyxRQUFRamlDLElBQUdDLElBQUlvbkIsSUFBSTZhOztTQUVqQmppQyxlQURJRDtLQUVSLE9BQUEsNEJBRlFBLElBQ0pDLElBRmFvbkIsSUFBSTZhOzswREFBWGxpQyxJQUFHQzs7O1lBU1Bpa0IsU0FBT2huQjtJQUFJLE9BQWdCLDJDQUFwQkE7R0FBMEI7WUFFakNrbkIsS0FBSzl6QixHQUFHa007aUJBR040ckI7S0FGZSxTQUVmQSxVQUFvQixPQUFBLHVDQUFwQkE7U0FER2xyQixJQUNIa3JCO0tBRFEsT0FBQSxXQUZGNXJCLEdBRUhVO0lBQ3VDO0lBRjNCLE9BQUEsdUNBRFo1TTtHQUd1QztHQUl0QztJQUFOOEU7OztnQkFESTlFLEdBQUdrTTtxQkFBMkJ0SyxHQUFLLE9BQTVCLDRCQUF1QkEsR0FBM0JzSyxHQUErQztRQUF6QixPQUFBLHVDQUF6QmxNO09BQW1EOzRDQU52RDh6QixNQU9BaHZCLEtBVEE4dUI7Ozs7Ozs7Ozs7OztZQVlKaWUsS0FBS3BrQixHQUFJLE9BQWdCLDJDQUFwQkEsSUFBNkI7WUFDbENxa0IsTUFBTUMsUUFBUyxPQUFBLDJCQURmRixNQUNNRSxRQUFvQztZQUMxQ0MsVUFBVWh5QyxHQUFHa007aUJBQTJCdEssR0FBSyxPQUE1Qiw0QkFBdUJBLEdBQTNCc0ssR0FBcUQ7SUFBL0IsT0FBQSx1Q0FBekJsTTtHQUF5RDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUZuRTZ4QztPQUNBQztPQUNBRTtPQXZCQUw7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNMRWhXO0lBS3FCc1c7SUFBQUM7SUFPbkJ0ZTtJQVBtQkU7O0lBQUFxZTs7Ozs7O1lBU25CQyxNQUFNbG1DLEdBQUV1aEI7SUFDVixjQUlZNGtCLElBQUdDO0tBQU0sT0FBYyxrQ0FBdkJELFFBQUdDO0lBQThCO2tCQURsQ3BtQyxHQUFFdWhCLEdBQUssT0FBQSxXQUFQdmhCLEdBQUV1aEIsR0FBUTtJQUNkLE9BQUEsNkNBTEN2aEIsR0FBRXVoQjtHQUtvQztHQUd0QztJQUFOM29CO2tEQVZBOHVCLFVBRUF3ZSxPQVFBdHRDOzs7Ozs7Ozs7Ozs7OztJQWpCbUJ5dEM7SUFBQUM7SUFnQ0Y7WUFNckJYLEtBQUsvWjtJQUF3QixVQUFBLDRCQUF4QkE7SUFBd0IsT0FBQTtHQUFtQjtZQUNoRDJhLE9BQU96eUM7SUFBSSxPQUFBLHVDQUFKQTtHQUFxQztZQUM1QzB5QyxPQUFPMWtDO0lBQXNCLFVBQUEsaUNBQXRCQTtJQUFzQixPQUFBO0dBQXFCO1lBQ2xEMmtDLGNBQWMzeUM7SUFBSTtzQjtrREFBSkE7R0FBNEM7WUFDMUQ4M0IsTUFBTThhLEtBQUk5d0MsR0FBRSt3QztJQUEwQixVQUFBLG9DQUFoQ0QsS0FBSTl3QyxHQUFFK3dDO0lBQTBCLE9BQUE7R0FBOEI7WUFDcEVDLFFBQVExeEM7SUFBdUIsVUFBQSw4QkFBdkJBO0lBQXVCLE9BQUE7R0FBdUI7WUFDdEQyeEMsYUFBYUg7SUFBc0IsVUFBQSw4QkFBdEJBO0lBQXNCLE9BQUE7R0FBMkI7WUFDOURJLE9BQU9qQjtJQUFTLE9BQUEsc0JBRGhCZ0IsY0FDT2hCO0dBQXFDO1lBQzVDa0IsSUFBSWp6QyxHQUFHaXpDO0lBQU07c0JBQUEsT0FBQSxxQkFBTkE7SUFBd0IsT0FBQSx1Q0FBM0JqekM7R0FBOEM7WUFDbERrekMsTUFBTWx6QyxHQUFHaXpDO0lBQU07c0JBQUEsT0FBQSxxQkFBTkE7SUFBd0IsT0FBQSx1Q0FBM0JqekM7R0FBZ0Q7WUFDdERtekMsV0FBV256QyxHQUFHaXpDO0lBQU07c0JBQUEsT0FBQSxxQkFBTkE7SUFBd0IsT0FBQSx1Q0FBM0JqekM7R0FBcUQ7WUFFaEVvekMsUUFBUXB6QyxHQUFFYyxTQUFROEwsR0FBRXRNO2lCQUNDTjtLQUFLLE9BQTVCLDhCQUF1QkEsR0FEWGMsU0FBUThMLEdBQUV0TTtJQUM0QztJQUFoRCxPQUFBLHVDQURSTjtHQUN5RDtZQUdqRXF6QyxjQUFjVDtJQUFzQixVQUFBLDhCQUF0QkE7SUFBc0IsT0FBQTtHQUE0QjtZQUNoRVUsZUFBZTFsQjtJQUFJO0tBQUE7S0FBYSxNQUFBLHVDQUFqQkE7SUFBSSxPQUFBO0dBQXdEO1lBQzNFMmxCLG9CQUFvQjNsQjtJQUFJO0tBQUE7S0FBYSxNQUFBLHVDQUFqQkE7SUFBSSxPQUFBO0dBQTZEO1lBRXJGNGxCLHVCQUF1QjVsQjtJQUN6QjtLQUFBO0tBQWEsTUFBQSx1Q0FEWUE7SUFDekIsT0FBQTtHQUFnRTtZQUc5RDZsQixZQUFZN2xCLEdBQUcxaEI7O0tBQ3NCLElBQVM2USxtQkFBSDZRO0tBQzNDLEdBRDJDQTtNQU01QjtPQURQOGlCLEtBTG1DOWlCO09BS3pDK2lCLEtBTHlDL2lCOzs7VUFNbEI7ZUFFaEIxdEI7V0FBVSwyQkFBVkE7O2NBREd3ekM7VUFBaUIsMEJBRnJCaEQsUUFFSWdELGVBUGtDMzJCO1NBUUw7T0FGMUIsTUFBQSxXQVBBN1EsR0FNYnlrQztNQUN1QixPQUFBOztLQUhJO01BQUEsTUFBQSwwQkFIaUI1ekI7TUFHeEM0MkIsV0FBUztLQUNHLE9BQUE7OERBRFpBO0lBS29DO0lBUkwsT0FBQSwyQ0FEekIvbEI7R0FTOEI7R0FHaEMsSUFBVmdtQixVQUFVO1lBRVZDLFdBQVVuYixhQUFhdkksS0FBSytFLE1BQU0xeUIsTUFBTUMsTUFBS3lKO0lBQy9DLGFBRUk2cUI7S0FGcUUsU0FFckVBLE9BQWMsT0FBZEE7U0FETS9vQixNQUNOK29CO0tBRGEsV0FBTSw4QkFBYi9vQjtJQUNXO0lBRlIsVUFBQSxXQWxGVDJ0QixVQWlGZ0NuNUIsU0FBTUMsTUFBOUJpMkIsYUFBYXZJLEtBQUsrRSxNQUFpQmhwQjtJQUMwQixPQUFBO0dBRXBEO1lBR25CNG5DLGNBQWVwYixhQUFhdkksS0FBSytFLE1BQU0xeUIsTUFBTUMsTUFBS3lKO0lBQ3BEO0tBQUE7S0FBYSxNQVBYMm5DLFdBTWVuYixhQUFhdkksS0FBSytFLE1BQU0xeUIsTUFBTUMsTUFBS3lKO0lBQ3BELE9BQUE7R0FBOEU7WUFJMUVzakMsTUFBTXpoQixNQUFXbnBCLEtBQUtzSDthQUNoQmdxQixLQUFLeHZCLEdBQUU5QjtLLFlBQ0wsT0FBQSxxQkFES0E7U0FFTDhyQyxlQUFOQztrQkFDUy9yQyxLQUNULE9BSklzeEIsS0FBS3h2QixXQUdBOUIsS0FESDhyQyxJQUVhO3VCQTVGQTVjLE1BMkZKLFdBSks1bkIsR0FDWHhGLEdBQUU5QixLQUVYK3JDOztJQUlKLE9BTlF6YSxRQURXdHhCLEtBQVhtcEI7R0FPTztZQUdiL29CLEtBQUtoRixHQUFHaUYsTUFBTWlIO0lBQUksT0FWbEJzakMsTUFVS3h2QyxHQUFHaUYsc0JBQWtDMkgsR0FBRTZnQixHQUFLLE9BQUEsV0FBbkN2aEIsR0FBNEJVLEdBQUU2Z0IsR0FBVTtHQUFDO1lBWXZEaWlCLE1BQVE5ZixLQUFtQjV2QixHQUFHa007SUFDaEMsR0FEVTBqQixTQUFNQyxNQUFORCxRQUVSc2IsTUFGY3JiLGNBRWRxYjtjQUFBQSxpQ0FBQUE7S0FFbUMsT0ExQm5Dc0UsTUFzQjJCeHZDLGVBSWEwRyxVQUFLK21CLEdBQUssT0FBQSxXQUpwQnZoQixHQUlVeEYsR0FBSyttQixHQUFVO0lBRHJCO0tBQUEsTUFBQSxzQ0FEbEN5ZCxLQUY4QmgvQjtLQUdMLE1BQUE7SUFBaEIsT0FBQSxxQkFBQSwwQkFIa0JsTTtHQUk2QjtZQUd4RDJ2QyxLQUFPL2YsS0FBbUI1dkIsR0FBR2tNO0lBQy9CLEdBRFMwakIsU0FBTUMsTUFBTkQsUUFFUHNiLE1BRmFyYixjQUVicWI7Y0FBQUEsaUNBQUFBO0tBbEJGO0tBQUEsT0FBQTtjQXBHdUJzSDtjQXVGckJoRDtnQkE2QjBCeHZDOzt5QkFoQkgwRyxHQUFFZ3dCLElBQUc5cEI7OEJBQ3BCMnBCLEdBQ1IsV0FEUUEsR0FEaUJHLElBRWxCOzBDQURLLFdBZWlCeHFCLEdBaEJOeEYsR0FBS2tHOzs7O0lBbUJDO0tBQUEsTUFBQSxzQ0FEN0JzK0IsS0FGNkJoL0I7S0FHVCxNQUFBO0lBQWhCLE9BQUEsZ0JBQUEsMEJBSHNCbE07R0FJQztZQUczQjh2QyxZQUFhNUUsS0FBSWxyQyxHQUFHa007SUFBSTtJQUFBLE9BQUEsV0EzSEhzbUMsY0FvSHJCN0MsS0FPYXpFLEtBQUlsckMsR0FBR2tNO0dBQXNDO1lBQzFENmpDLFlBQWE3RSxLQUFJbHJDLEdBQUdrTTtJQUFJO0lBQUEsT0FBQSxXQTVISHNtQyxjQW9IckI3QyxLQVFhekUsS0FBSWxyQyxHQUFHa007R0FBa0M7WUFFdEQwakMsUUFBUzFFLEtBQUlsckMsR0FBR2tNO0lBQ2xCLE9BSkU0akM7YUFHUzVFO2FBQUlsckM7c0JBQ1kwRyxHQUFFK21COzJCQUNuQjhJLEdBQ1IsT0FEUUEsUUFEbUI5SSxPQUVEO3VDQURkLFdBRkl2aEIsR0FDU3hGLEdBQUUrbUI7O0dBRUE7WUFHM0J1aUIsVUFBVWh3QyxHQUFHa007YUFDUDhqQyxVQUFVaHdDLEdBQUdrTSxHQUFFeEY7S0FDckIsS0FEZ0IxRyxHQUVSLE9BQUE7U0FDQTB3QyxLQUhRMXdDLE1BR2Qyd0MsS0FIYzN3QztrQkFNWHNQO00sT0FBQUEsT0FBa0IscUJBQWxCQSxRQU5DMGdDLFVBR0VVLElBSFd4a0MsR0FBRXhGOzt1QkFySUFvdEIsTUF5SVAsV0FKSzVuQixHQUFFeEYsR0FHbkJpcUM7SUFHaUM7SUFFckMsT0FSUVgsVUFESWh3QyxHQUFHa007R0FTQztZQUtkZ2tDLE1BQU1sd0MsR0FBR2tNO0lBQ1gsT0FmRThqQzthQWNNaHdDO3NCQUNZMEcsR0FBRXlwQzsyQkFDWjVaLEdBQ1IsT0FEUUEsWUFEVTd2QixHQUFFeXBDLFVBRWE7dUNBRHJCLFdBRkhqa0MsR0FDU3hGLEdBQUV5cEM7O0dBRWM7WUFHbENsUyxLQUFLaitCLEdBQUdrTTtJQUNWLE9BckJFOGpDO2FBb0JLaHdDOzZCQUNZbXdDOzJCQUNUNVosR0FDUixPQURRQSxRQURTNFosU0FFVzt1Q0FEaEIsV0FGSmprQyxHQUNTaWtDO2FBVDZCO0dBV2pCO1lBRzdCQyxRQUFRcHdDLEdBQUdrTTt3Qjs7O2FBMUJYOGpDO2VBMEJRaHdDO3dCQUVZMEcsR0FBRXlwQzs2QkFDWjVaLEdBQ1IsT0FEUUEsWUFDbUI7eUNBRGYsV0FISHJxQixHQUVTeEYsR0FBRXlwQzs7OztZQVF0QkUsU0FBU3J3QyxHQUFHa007d0I7OzthQXBDWjhqQztlQW9DU2h3Qzt3QkFFVzBHLEdBQUV5cEM7NkJBQ1o1WixHQUNSLE9BRFFBLFlBQ3VCO3lDQURuQixXQUhGcnFCLEdBRVF4RixHQUFFeXBDOzs7O1lBUXRCcHJDLEtBQU1tbUMsS0FBSWxyQyxHQUFHa007SUFBSSxPQXJFakJ3akMsTUFxRU14RSxLQUFJbHJDLG1CQUE4QjRNLEdBQUssT0FBQSxXQUFoQ1YsR0FBMkJVLEdBQVE7R0FBQztZQUNqRGdKLE1BQUtzMUIsS0FBSWxyQyxHQUFHa007SUFBSSxPQS9EaEJ5akMsS0ErREt6RSxLQUFJbHJDLG1CQUE2QjRNLEdBQUssT0FBQSxXQUEvQlYsR0FBMEJVLEdBQVE7R0FBQztZQUMvQzJqQyxPQUFRckYsS0FBSWxyQyxHQUFHa007SUFBSSxPQXREbkIwakMsUUFzRFExRSxLQUFJbHJDLG1CQUFnQzRNLEdBQUssT0FBQSxXQUFsQ1YsR0FBNkJVLEdBQVE7R0FBQztZQUNyRDBqQyxXQUFZcEYsS0FBSWxyQyxHQUFHa007SUFBSSxPQTFEdkI0akMsWUEwRFk1RSxLQUFJbHJDLG1CQUFvQzRNLEdBQUssT0FBQSxXQUF0Q1YsR0FBaUNVLEdBQVE7R0FBQztZQUM3RDRqQyxXQUFZdEYsS0FBSWxyQyxHQUFHa007SUFBSSxPQTFEdkI2akMsWUEwRFk3RSxLQUFJbHJDLG1CQUFvQzRNLEdBQUssT0FBQSxXQUF0Q1YsR0FBaUNVLEdBQVE7R0FBQztZQUM3RDZqQyxTQUFTendDLEdBQUdrTTtJQUFJLE9BbkRoQjhqQyxVQW1EU2h3QyxtQkFBNkI0TSxHQUFLLE9BQUEsV0FBL0JWLEdBQTBCVSxHQUFRO0dBQUM7WUFDL0N2SCxPQUFPckYsR0FBR2tNO0lBQUksT0ExQmRra0MsUUEwQk9wd0MsbUJBQTJCNE0sR0FBSyxPQUFBLFdBQTdCVixHQUF3QlUsR0FBUTtHQUFDO1lBQzNDeEgsUUFBUXBGLEdBQUdrTTtJQUFJLE9BakJmbWtDLFNBaUJRcndDLG1CQUE0QjRNLEdBQUssT0FBQSxXQUE5QlYsR0FBeUJVLEdBQVE7R0FBQztZQUM3QzNILEtBQU1pbUMsS0FBSTM5QixHQUFHckI7c0I7SUFBSSxPQVBqQjBKLE1BT01zMUIsS0FBb0IsMkJBQWhCMzlCLFNBQUdyQjtHQUFzQztZQUdqRGlxQixzQkFBc0JDLE9BQU1scUI7O0s7VUFFeEJrcUI7TUFBUyxPQUZiRCxzQkFFSUMsT0FGd0JscUI7O1NBR3RCNm5DO0tBQVMsT0FBQSxxQkFBVEE7O3NCQWhNYWpnQixNQThMZCxXQUR1QjVuQixHQUFOa3FCOzs7Ozs7Ozs7Ozs7Ozs7OztPQTdMSCtiOzs7T0FBQXJlOzs7T0FBQW9lO09BQUFEOzs7OztRQUFBTTtRQUFBQztzQkFBQTFlO09Bc0N2QitkO09BQ0FZO09BQ0FDO09BQ0FDO09BQ0E3YTtPQUNBZ2I7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FZQUc7T0FFQUM7T0FNQUM7O1FBS0V0RTtRQVVBeHFDO1FBdURBaTVCO1FBTkFpUztRQXFDQU87UUFuREFUO1FBb0RBM3FDO1FBMUJBK3FDO1FBMkJBaHJDO1FBakJBaXJDOzs7UUFrQkFwckM7UUFSQUY7UUFyRUEycUM7UUFzRUE5NUI7UUEvREErNUI7UUFnRUFZO1FBdERBWDtRQXVEQVU7UUExREFSO1FBMkRBVTtRQTFEQVQ7T0FpRUU1Wjs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMzTEpxWixNQUFNeHZDLEdBQUdpRixNQUFNaUg7SUFBZSxVQUFBLDJCQUF4QmxNO0lBQWEsT0FBQSwrQ0FBVmlGLE1BQU1pSDtHQUF5QztZQUN4RGxILEtBQUtoRixHQUFHaUYsTUFBTWlIO0lBQWMsVUFBQSwyQkFBdkJsTTtJQUFhLE9BQUEsK0NBQVZpRixNQUFNaUg7R0FBd0M7WUFDdER5cUIsSUFBSTMyQjtJQUFJO0tBQUE7S0FBUyxNQUFBLDJCQUFiQTtLQUFJLE1BQUE7SUFBQSxPQUFBO0dBQTRDO1lBQ3BENjJCLFNBQVM3MkI7SUFBa0IsVUFBQSwyQkFBbEJBO0lBQWtCLE9BQUE7R0FBaUI7WUFDNUMrRSxLQUFNbW1DLEtBQUlsckMsR0FBR2tNO0lBQW1CLFVBQUEsMkJBQXRCbE07SUFBTyxPQUFBLDJDQUFYa3JDLFVBQU9oL0I7R0FBdUM7WUFDcER3akMsTUFBT3hFLEtBQUlsckMsR0FBR2tNO0lBQW9CLFVBQUEsMkJBQXZCbE07SUFBTyxPQUFBLDJDQUFYa3JDLFVBQU9oL0I7R0FBd0M7WUFDdERwSCxJQUFLb21DLEtBQUlsckMsR0FBR2tNO0lBQUk7S0FBQTtLQUFjLE1BQUEsMkJBQXJCbE07S0FBTyxNQUFBLDJDQUFYa3JDLFVBQU9oL0I7SUFBSSxPQUFBO0dBQW9EO1lBQ3BFeWpDLEtBQU16RSxLQUFJbHJDLEdBQUdrTTtJQUFJO0tBQUE7S0FBZSxNQUFBLDJCQUF0QmxNO0tBQU8sTUFBQSwyQ0FBWGtyQyxVQUFPaC9CO0lBQUksT0FBQTtHQUFxRDtZQUN0RWpILEtBQU1pbUMsS0FBSTM5QixHQUFHckI7SUFBSTtLQUFBO0tBQUEsTUFBQSwyQ0FBWGcvQixLQUFJMzlCLEdBQUdyQjtJQUFJLE9BQUE7R0FBcUM7WUFDdERxa0MsT0FBUXJGLEtBQUlsckMsR0FBR2tNO0lBQUk7S0FBQTtLQUFpQixNQUFBLDJCQUF4QmxNO0tBQU8sTUFBQSwyQ0FBWGtyQyxVQUFPaC9CO0lBQUksT0FBQTtHQUF1RDtZQUMxRTBqQyxRQUFTMUUsS0FBSWxyQyxHQUFHa007SUFBSTtLQUFBO0tBQWtCLE1BQUEsMkJBQXpCbE07S0FBTyxNQUFBLDJDQUFYa3JDLFVBQU9oL0I7SUFBSSxPQUFBO0dBQXdEO1lBQzVFb2tDLFdBQVlwRixLQUFJbHJDLEdBQUdrTTtJQUFJO0tBQUE7S0FBcUIsTUFBQSwyQkFBNUJsTTtLQUFPLE1BQUEsMkNBQVhrckMsVUFBT2gvQjtJQUFJLE9BQUE7R0FBMkQ7WUFDbEY0akMsWUFBYTVFLEtBQUlsckMsR0FBR2tNO0lBQUk7S0FBQTtLQUFzQixNQUFBLDJCQUE3QmxNO0tBQU8sTUFBQSwyQ0FBWGtyQyxVQUFPaC9CO0lBQUksT0FBQTtHQUE0RDtZQUVwRnNrQyxXQUFZdEYsS0FBSWxyQyxHQUFHa007SUFDckI7aUJBQStDdWhCO0tBQUssSUFBQSxzQkFBQSxNQUFBLFdBRC9CdmhCLEdBQzBCdWhCO0tBQUssT0FBQTtJQUFxQjtJQUFwRDtLQUFBLE1BQUEsMkJBREh6dEI7S0FDbEIsTUFBQSwyQ0FEY2tyQztJQUNkLE9BQUE7R0FDaUI7WUFHZjZFLFlBQWE3RSxLQUFJbHJDLEdBQUdrTTtJQUN0QjtpQkFBZ0R4RixHQUFFK21CO0tBQUssSUFBQSxzQkFBQSxNQUFBLFdBRGpDdmhCLEdBQzBCeEYsR0FBRSttQjtLQUFLLE9BQUE7SUFBdUI7SUFBeEQ7S0FBQSxNQUFBLDJCQURIenRCO0tBQ25CLE1BQUEsMkNBRGVrckM7SUFDZixPQUFBO0dBQ2lCO1lBR2Z1RixTQUFTendDLEdBQUdrTTtJQUFrQixVQUFBLDJCQUFyQmxNO0lBQU8sT0FBQSwrQ0FBSmtNO0dBQXNDO1lBQ2xEOGpDLFVBQVVod0MsR0FBR2tNO0lBQW1CLFVBQUEsMkJBQXRCbE07SUFBTyxPQUFBLCtDQUFKa007R0FBdUM7WUFDcEQreEIsS0FBS2orQixHQUFHa007SUFBYyxVQUFBLDJCQUFqQmxNO0lBQU8sT0FBQSwrQ0FBSmtNO0dBQWtDO1lBQzFDZ2tDLE1BQU1sd0MsR0FBR2tNO0lBQWUsVUFBQSwyQkFBbEJsTTtJQUFPLE9BQUEsK0NBQUprTTtHQUFtQztZQUM1QzlHLFFBQVFwRixHQUFHa007SUFBaUIsVUFBQSwyQkFBcEJsTTtJQUFPLE9BQUEsK0NBQUprTTtHQUFxQztZQUNoRG1rQyxTQUFTcndDLEdBQUdrTTtJQUFrQixVQUFBLDJCQUFyQmxNO0lBQU8sT0FBQSxnREFBSmtNO0dBQXNDO1lBQ2xEN0csT0FBT3JGLEdBQUdrTTtJQUFnQixVQUFBLDJCQUFuQmxNO0lBQU8sT0FBQSwrQ0FBSmtNO0dBQW9DO1lBQzlDa2tDLFFBQVFwd0MsR0FBR2tNO0lBQWlCLFVBQUEsMkJBQXBCbE07SUFBTyxPQUFBLCtDQUFKa007R0FBcUM7Ozs7Ozs7O09BL0JoRHNqQztPQUNBeHFDO09BeUJBaTVCO09BQ0FpUztPQUhBTztPQUNBVDtPQUtBM3FDO09BQ0ErcUM7T0FIQWhyQztPQUNBaXJDO09BM0JBMVo7T0FDQUU7T0FLQTV4QjtPQUpBRjtPQUNBMnFDO09BQ0E1cUM7T0FDQTZxQztPQUVBWTtPQUNBWDtPQUNBVTtPQUNBUjtPQUVBVTtPQUtBVDs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNsQkFpRSxVQUVJcGtCO0ksR0FBQUEsU0FBTUMsTUFBTkQsUUFBQXNiLE1BQU1yYixjQUFOcWI7b0JBRUFqbUMsTUFDQWd2QyxRQUNBQztLQUdOLFVBUE1oSjtNQStCVztPQURNeEQsc0JBOUJqQndEO09BK0JBaUosV0FBVyx3Q0FETXpNO09BSWIxSztrQkFBS3QyQixHQUFFMUcsR0FBR28wQzs7V0FFVixZQUFBLDhCQUZPcDBDOzhCQUFHbzBDO21DQUlMaHVDLGtCQUFId0c7d0JBSU0ycEI7MEJBQ0Q2ZCxHQUNSLGtCQXhDSEYsUUF1Q1dFLEdBREM3ZCxHQUVDOytEQVZDNmQ7OytCQVF1QyxrQkF2Q3JESCxRQStCU3Z0QyxHQUlIa0csR0FJeUQ7V0FBL0MsV0FBQSxxQ0FYaEJ1bkM7a0JBR0luWDtvQkFBS3QyQjtvQkFJQU47O1VBTUs7VUFURixVQUFBLHNDQUpaK3RDOzs7TUFlSyxPQVpEblgsYUFZQywwQ0E1Q0wvM0I7O3FCQUZBaW1DOztPQVNJaFY7a0JBQUt4dkIsR0FBRTFHLEdBQUdvMEM7VUFDVixZQUFBLDhCQURPcDBDO3NCQUVILE9BQUEsMENBRk1vMEM7a0NBR0xodUMsa0JBQUh3Rzt1QkFDRzJwQjtXQUNULE9BTElMLEtBQUt4dkIsV0FHQU4sS0FFTSxXQVZmOHRDLFFBS2NFLEdBSUw3ZDtVQUNrQjtVQURkLFVBQUEsV0FWYjBkLFFBTVN2dEMsR0FHSGtHOztTQUVxQjtNQUUvQixPQVBRc3BCLFdBUEpqeEI7O0tBMkJLO01BWFNvdkMsTUFXVCwwQ0EzQkxwdkM7TUFnQlN5QjtNQUFFTjtNQUFHZ3VDLElBQUFDO0tBQ2hCO01BQU0sWUFBQSw4QkFET2p1QztrQkFFSCxPQUZNZ3VDO01BT0U7O09BUExudUM7T0FHTDJHOztrQkFIUXduQztXLGdCQU9GN2Q7eUJBQ0Q2ZCxHQUNSLGtCQXZCSEYsUUFzQldFLEdBREM3ZCxHQUVDOytEQVRDNmQ7O1dBQUFBO09BT0UsTUFBQSxXQXRCaEJILFFBZVN2dEMsR0FHSGtHO09BSFEwbkM7T0FBTEMsTUFBQTd0QztPQUFBQSxJQUFBNnRDO09BQUVudUMsTUFBQUg7T0FBR211QyxJQUFBRTtNQTRCSTs7WUFHdEI5RSxNQUFNeHZDLEdBQUdpRixNQUFNaUg7SUFDakI7S0FNVSxJQUFTcXFCO0tBQU0sT0FBQSwwQ0FBTkE7SUFBZTt3QkFIakIzcEIsR0FBRzBHO0tBQWYsSUFBU2lqQixjQUFIN3ZCO2tCQUNFNnZCLEdBQ1QsT0FBRSxXQUZjampCLE9BQVQ1TSxXQUNFNnZCLElBQ0c7S0FEQyxVQUFBLFdBTEFycUIsR0FJTnhGLEdBQUc2dkIsR0FBRzNwQjs7SUFFQTtJQUNQLE9BQUEsK0JBUEY1TSxVQUFHaUY7R0FPdUI7WUFLaENELEtBQUtoRixHQUFHaUYsTUFBTWlIO0lBQ2hCO2lCQUFzQ3FxQixHQUFFM3BCLEdBQUcwRztLQUFLLFVBQUEsV0FEaENwSCxHQUNzQnFxQixHQUFFM3BCO0tBQVEsT0FBQSw4Q0FBTDBHO0lBQWdCO0lBQTNELE9BQUEsK0JBRE90VCxHQUFHaUY7R0FDaUU7WUFHekUweEIsSUFBSTMyQjtpQkFDRWk4QjtLQUtTLFVBQUEsMEJBTFRBO0tBS1MsT0FBQTtJQUFjO0lBSjdCOztPQU5BajNCO1NBSUloRjs7a0JBRW9CdzBDLE9BQU0xZDt1QkFDcEJscUIsR0FDUixXQURRQSxHQURjNG5DLE9BRVo7NkRBRmtCMWQ7Ozs7WUFPOUJELFNBQVM3MkIsR0FBSSxPQWJiZ0YsS0FhU2hGLHNCQUErQjhCLEdBQUssT0FBTEEsRUFBTSxHQUFDO1lBRS9Da3VDLFVBQVVod0MsR0FBR2tNO0lBQ2YsU0FBUThqQyxVQUFVaHdDLEdBQUdrTSxHQUFFeEY7S0FDZixZQUFBLDhCQURVMUc7aUJBRU4sT0FBQTs2QkFDQ2sxQixtQkFBSHB6QjtrQkFHSHdOO00sT0FBQUE7Z0JBQWtCLDBDQUFsQkE7Z0JBTkMwZ0MsVUFHSzlhLE1BSFFocEIsR0FBRXhGOztLQUlQLFVBQUEsV0FKS3dGLEdBQUV4RixHQUdiNUU7O0lBRzJCO0lBRXJDLE9BUlFrdUMsVUFESWh3QyxHQUFHa007R0FTQztZQUdkZ2tDLE1BQU1sd0MsR0FBR2tNO0lBQ1gsT0FiRThqQzthQVlNaHdDO3NCQUNZMEcsR0FBRXlwQzsyQkFDWjVaLEdBQ1IsT0FEUUEsWUFEVTd2QixHQUFFeXBDLFVBRWE7Y0FEckIsVUFBQSxXQUZIamtDLEdBQ1N4RixHQUFFeXBDOzs7R0FFYztZQUdsQ2xTLEtBQUtqK0IsR0FBR2tNO0lBQ1YsT0FuQkU4akM7YUFrQktod0M7NkJBQ2Vtd0M7MkJBQ1o1WixHQUNSLE9BRFFBLFFBRFk0WixTQUVRO2NBRGhCLFVBQUEsV0FGSmprQyxHQUNZaWtDOzs7R0FFUztZQUc3QkMsUUFBUXB3QyxHQUFHa007d0I7SUFFWDs7T0ExQkE4akM7U0F3QlFod0M7a0JBRVkwRyxHQUFFeXBDO3VCQUNaNVosR0FDUixPQURRQSxZQUNtQjtVQURmLFVBQUEsV0FISHJxQixHQUVTeEYsR0FBRXlwQzs7Ozs7WUFRdEJFLFNBQVNyd0MsR0FBR2tNO3dCO0lBRVo7O09BcENBOGpDO1NBa0NTaHdDO2tCQUVXMEcsR0FBRXlwQzt1QkFDWjVaLEdBQ1IsT0FEUUEsWUFDdUI7VUFEbkIsVUFBQSxXQUhGcnFCLEdBRVF4RixHQUFFeXBDOzs7OztZQVF0QlQsTUFBT3hFLEtBQUlsckMsR0FBR2tNO0lBQ2hCLHlCQUEwRCxTQUFFO0lBQWhCLE9BM0gxQzhuQyxVQTBITzlJLEtBQUlsckMsTUFBR2tNO0dBQzZDO1lBRzNEeWpDLEtBQU16RSxLQUFJbHJDLEdBQUdrTTtpQkFDUHdxQjtLQUdTLFVBQUEsMEJBSFRBO0tBR1MsT0FBQTtJQUFhO2lCQUZzQ0EsSUFBR0gsR0FBSyxXQUFMQSxHQUFIRyxJQUFlO2lCQUFuRGh3QixHQUFFa0csR0FBSyxPQUFBLFdBRnhCVixHQUVpQnhGLEdBQUVrRyxHQUFVO0lBQTFDLFVBaElBb25DLFVBOEhNOUksS0FBSWxyQzs7O1lBVVY4dkMsWUFBYTVFLEtBQUlsckMsR0FBR2tNO2lCQUNkd3FCO0tBV1MsVUFBQSwwQkFYVEE7S0FXUyxPQUFBO0lBQWE7aUJBTGJBLElBQUcrZDtLQUNkLEtBRGNBLFNBRUosT0FGQy9kO1NBR0pILElBSE9rZTtLQUdGLFdBQUxsZSxHQUhJRztJQUdRO2lCQUxSaHdCLEdBQUVrRyxHQUFLLE9BQUEsV0FMRlYsR0FLTHhGLEdBQUVrRyxHQUFVO0lBSDNCLFVBMUlBb25DLFVBd0lhOUksS0FBSWxyQzs7O1lBZWpCK3ZDLFlBQWE3RSxLQUFJbHJDLEdBQUdrTTtJQUFJLElBQUEseUJBQUEsTUF6QnhCeWpDLEtBeUJhekUsS0FBSWxyQyxHQUFHa007SUFBSSxPQUFBO0dBQWtDO1lBRTFEMGpDLFFBQVMxRSxLQUFJbHJDLEdBQUdrTTtJQUNsQixPQWxCRTRqQzthQWlCUzVFO2FBQUlsckM7c0JBQ1kwRyxHQUFFa0c7a0MsbUJBQUFBO2NBQ2pCLFVBQUEsV0FGTVYsR0FDU3hGLEdBQUVrRzs7O0dBR1g7WUFHaEI3SCxLQUFNbW1DLEtBQUlsckMsR0FBR2tNO0lBQUksT0F0Q2pCd2pDLE1Bc0NNeEUsS0FBSWxyQyxtQkFBOEI0TSxHQUFLLE9BQUEsV0FBaENWLEdBQTJCVSxHQUFRO0dBQUM7WUFDakQ5SCxJQUFLb21DLEtBQUlsckMsR0FBR2tNO0lBQUksT0FuQ2hCeWpDLEtBbUNLekUsS0FBSWxyQyxtQkFBNkI0TSxHQUFLLE9BQUEsV0FBL0JWLEdBQTBCVSxHQUFRO0dBQUM7WUFDL0MyakMsT0FBUXJGLEtBQUlsckMsR0FBR2tNO0lBQUksT0FUbkIwakMsUUFTUTFFLEtBQUlsckMsbUJBQWdDNE0sR0FBSyxPQUFBLFdBQWxDVixHQUE2QlUsR0FBUTtHQUFDO1lBQ3JEMGpDLFdBQVlwRixLQUFJbHJDLEdBQUdrTTtJQUFJLE9BM0J2QjRqQyxZQTJCWTVFLEtBQUlsckMsbUJBQW9DNE0sR0FBSyxPQUFBLFdBQXRDVixHQUFpQ1UsR0FBUTtHQUFDO1lBQzdENGpDLFdBQVl0RixLQUFJbHJDLEdBQUdrTTtJQUFJLE9BYnZCNmpDLFlBYVk3RSxLQUFJbHJDLG1CQUFvQzRNLEdBQUssT0FBQSxXQUF0Q1YsR0FBaUNVLEdBQVE7R0FBQztZQUM3RDZqQyxTQUFTendDLEdBQUdrTTtJQUFJLE9BdkZoQjhqQyxVQXVGU2h3QyxtQkFBNkI0TSxHQUFLLE9BQUEsV0FBL0JWLEdBQTBCVSxHQUFRO0dBQUM7WUFDL0N2SCxPQUFPckYsR0FBR2tNO0lBQUksT0FoRWRra0MsUUFnRU9wd0MsbUJBQTJCNE0sR0FBSyxPQUFBLFdBQTdCVixHQUF3QlUsR0FBUTtHQUFDO1lBQzNDeEgsUUFBUXBGLEdBQUdrTTtJQUFJLE9BdkRmbWtDLFNBdURRcndDLG1CQUE0QjRNLEdBQUssT0FBQSxXQUE5QlYsR0FBeUJVLEdBQVE7R0FBQztZQUM3QzNILEtBQU1pbUMsS0FBSTM5QixHQUFHckI7c0I7SUFBSSxPQVBqQnBILElBT01vbUMsS0FBb0IsOEJBQWhCMzlCLFNBQUdyQjtHQUEwQzs7Ozs7Ozs7T0FySHZEc2pDO09BWUF4cUM7T0FpQ0FpNUI7T0FOQWlTO09BMkVBTztPQXZGQVQ7T0F3RkEzcUM7T0FoRUErcUM7T0FpRUFockM7T0F2REFpckM7T0E3Q0ExWjtPQVNBRTtPQTRGQTV4QjtPQVJBRjtPQXRDQTJxQztPQXVDQTVxQztPQW5DQTZxQztPQW9DQVk7T0FUQVg7T0FVQVU7T0EzQkFSO09BNEJBVTtPQWJBVDs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM1SkFod0M7SUFDQWtQO0lBQ0E4MkI7SUFDQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGQWwzQjtPQURBbFA7T0FFQWdtQztPQUNBSTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDTnNCO0lBQXRCdU87SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FHRixTQUFBMUYsUUFBQUUsT0FBQUM7SUFBQSxHQUFBLCtCQUFBRCxPQUFBQyxRQUFBO2dCQUFBRDtlQUFBQyxnQ0FBQUEsT0FBQTs7bUJBQUFBLHFDQUFBQSxPQUFBO29DQUFBRCxPQUFBQztHQUk2QjtZQUo3Qjl0QyxpQkFBQSxrQ0FJNkI7WUFFekJvUixNQUF5QnF0QixPQUFBNlUsTyxhQU43QjNGLFFBTTZCbFAsT0FBQTZVO1lBRXpCakQsUUFBUy9qQjtrQkFDSEE7S0FDUixPQUFNLHlCQURFQSxlQUhObGI7OztJQU1ZO0lBSEYsV0FBQSxzQ0FERGtiOzs7WUE2Q0RpbkIsWUFBQWp6QyxHQUFBLE9BQUFBLEtBQVc7WUFBWGt6QyxnQkFBQWx6QyxHQUFBRSxHQUFBRixPQUFBRSxZQUFXO2dCQUFYRixHQUFBRSxHQUFBLFdBQUFGLE1BQUFFLEdBQUFGLE1BQVc7R0FBWDtJQUFBLFVBQUFrekM7SUFVSUM7MEJBVkosU0FBVyx5QkFBWEY7WUFKWjcyQjtJQUFBLElBQ0lnM0Isd0JBR1FDLDRCQUpaQzt3QjtJQVFJO0tBQUFDO0tBUkpDLGtDQVFJRCxlQVJKRDtjQUlZRDtTQUFBeG9COzs7TUFDTjRvQixRQURNSjtNQUFBeG9COztrRUFDTjRvQjtJQURNO0tBSlpDLGtDQUlZN29CLGVBSloyb0I7S0FDSXpvQixVQUFBLHNCQUFBcW9CO0tBREpPLGtDQUNJNW9CLGVBREoyb0I7SUFBQSxXQUFBQztHQVU0QjtZQUV4QjNzQyxVQUFVNUk7SUFDWjtLQUN3QixZQUFBLDBCQUFWKzBDLGVBRkYvMEM7O1VBUThCZ3pCO01BQWUsS0FBQSxrQ0FBZkE7T0FBUSxNQUFBOztLQVpoRDtLQU9BOztVQVFBamxCOztNQUFBQywwQkFBQUQ7a0NBdkJKaVEsWUFZY2hlO3dEQVdWZ087Ozs7Ozs7O0dBQW9GO1lBT3BGcVAsTUFBTXJkO0lBQ1IsY0FEUUE7ZUFBQUE7O2dDQUkwQzs7O0dBQWdCO1lBR2hFdzFDLHVCQUF1QngxQztJQUN6QixZQUR5QkE7a0NBRU87UUFDQ2d6QjtJQUMvQixrQ0FEK0JBO0lBSFJoekI7O0dBS29CO1lBRzNDeTFDLCtCQUFtQ3oxQztJQUNyQyxZQURxQ0E7a0NBRUwsT0FBQSxXQUZLQTtRQUdKMDFDO3lCQUUvQixPQUFBLFdBTG1DMTFDLFNBS1o7SUFEVCxXQUFBLGtDQURpQjAxQzs7R0FFUjtHQWtCM0IsU0FFSUMsU0FBQS96QyxHQUFBLE9BQUFBLEtBQVE7WUFEUmcwQyxNQUFBaDBDLEdBQUEsT0FBQUEsS0FBSztnQkFDTEEsR0FBQUUsR0FBQSxXQUFBRixNQUFBRSxHQUFRO0dBQVI7O0lBQUErekM7MEJBQUEsU0FBUSxzQkFBUkY7Z0JBREEvekMsR0FBQUUsR0FBQSxXQUFBQSxHQUFBRixNQUFLO0dBQUw7O0lBQUFrMEMsOEJBQUEsU0FBSyxtQkFBTEY7WUFESmhuQyxZQUFLbW5DO0lBQUw7S0FFSUM7S0FEQUM7S0FDQTlxQixVQUFBLHNCQXRFSm5OLGFBc0VJZzRCO0tBRkpFLGdDQUVJL3FCO1dBREE4cUI7O09BTkY7UUFBQUUsV0FNRUY7K0I7UUFORkcsV0FBQSx1Q0FBQUQ7UUFNRTlxQiwyQkFORitxQjs7O09BQ0E7UUFBQUMsV0FLRUo7OztXO2VBTE9LOzhDQUlOUCxVQUpNTzs7UUFBVEMsV0FBQSx1Q0FBQUY7UUFLRWhyQiwyQkFMRmtyQjs7O09BQ0E7UUFBQUMsV0FJRVA7UUFKRlEsV0FJRVI7UUFKRlMsV0FBQSxzQkFBQUQ7OztXO2VBQW1CRTs7OzttREFHaEJaLFVBSGdCWTs7UUFBbkJDLFdBQUEsdUNBQUFKO1FBSUVuckIsMkJBSkZxckIsY0FBQUU7O0lBSUUsSUFESkMsa0NBQ0l4ckIsZUFESjZxQjtJQUFBLFdBQUFXO0dBSTRCO1lBNEJ4QkMsY0FBYzkyQztJQUNoQixZQURnQkE7OztXQUVUMEcsY0FBSyxPQUFBLGtDQUFMQTs7V0FDRDZ0QztPQUFLLE9BQUEsa0NBQUxBOztXQUNRd0M7T0FBTSxPQUFBLGtDQUFOQTs7R0FBc0I7WUFnQmxDQywwQkFBQXAxQyxHQUFBLE9BQUFBLEtBQXlCO1lBRDdCaU87SUFBQTtLQUVJb25DO0tBREFDO0tBREpDO3lCO0lBRUk7S0FBQXRzQixVQUFBLHVDQUFBb3NCO0tBRkpHLGtDQUVJdnNCLGVBRkpzc0I7S0FDSXBzQixVQUFBLHNCQUFBbXNCO0tBREpHLGtDQUNJdHNCLGVBREpxc0I7SUFBQSxXQUFBQztHQUk0QjtZQUV4Qm5sQixLQUFLbHlCLEdBQUU4QixHQUFJLE9BQUEsa0NBQU45QixNQUFFOEIsR0FBdUI7WUE4Q3hCdzFDLFVBQUExMUMsR0FBQSxPQUFBQSxNQUFTO1lBQVQyMUMsY0FBQTMxQyxHQUFBRSxHQUFBRixRQUFBRSxZQUFTO1lBUGpCMDFDLGNBQUE1MUMsR0FBQSxPQUFBQSxLQUFhO1lBRmI2MUMsZ0JBQUE3MUMsR0FBQSxPQUFBQSxLQUFlO1lBZlA4MUMsU0FBQTkxQyxHQUFBLE9BQUFBLEtBQVE7WUFBUisxQyxhQUFBLzFDLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVE7WUFIUjgxQyxZQUFBaDJDLEdBQUEsT0FBQUEsS0FBVztZQUFYaTJDLGdCQUFBajJDLEdBQUFFLEdBQUFGLE9BQUFFLFlBQVc7Z0JBMkJYRixHQUFBRTtJQUFBO1lBQUFGO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFFO1lBQUFGO0dBQVM7R0FBVDtJQUFBLFVBQUEyMUM7SUFBQU87MEJBQUEsU0FBUyx1QkFBVFI7Z0JBUFIxMUMsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtHQUFhO0dBQWI7O0lBQUFtMkM7O3VCQUFBLFNBQWE7OztPQUFiUDs7Z0JBRkE1MUMsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFlO0dBQWY7O0lBQUFvMkM7O3VCQUFBLFNBQWU7OztPQUFmUDs7Z0JBZlE3MUMsR0FBQUU7SUFBQTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBRTtZQUFBRjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFRO0dBQVI7SUFBQSxVQUFBKzFDO0lBQUFNOzBCQUFBLFNBQVEsc0JBQVJQO2dCQUhBOTFDLEdBQUFFO0lBQUE7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUU7WUFBQUY7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7R0FBVztHQUFYO0lBQUEsVUFBQWkyQztJQUFBSzswQkFBQSxTQUFXLHlCQUFYTjtZQW9DWk8sYUFwRE1DLFVBQUlDOztLQUVOQztLQUVRQztLQUVBQztLQVVBQztLQUdBQztLQUtBQztLQWdCUkM7S0FGQUM7S0FGQUM7S0FGQUM7S0FTUUM7S0FLUkM7S0FoREpDOzt5Qjs7O0lBZ0RJO0tBQUFDLFVBQUEsOEJBQUFGO0tBaERKRyxrQ0FnRElELGVBaERKRDtLQTJDWUcsVUFBQSxzQkEzS1ZyN0IsYUEyS1VnN0I7S0EzQ1pNLGtDQTJDWUQsZUEzQ1pEO0tBd0NJRyxVQUFBLDRDQUFBWDtLQXhDSlksa0NBd0NJRCxlQXhDSkQ7S0FzQ0lHLFVBQUEsNENBQUFaO0tBdENKYSxrQ0FzQ0lELGVBdENKRDt3QixPQTVERTVxQyxZQTRESXdwQztJQW9DRjtLQUFBdUIsVUFBQSxpQ0FBQWI7S0FwQ0pjLGtDQW9DSUQsZUFwQ0pEO0tBa0NJRyxVQUFBLDJCQTNDRmhxQyxhQTJDRWtwQztLQWxDSmUsa0NBa0NJRCxlQWxDSkQ7S0F3QllHLFVBQUEsc0JBQUFwQjtLQXhCWnFCLGtDQXdCWUQsZUF4QlpEO0tBbUJZRyxVQUFBLDRDQUFBdkI7S0FuQlp3QixrQ0FtQllELGVBbkJaRDtLQWdCWUcsVUFBQSxzQkFBQTFCO0tBaEJaMkIsa0NBZ0JZRCxlQWhCWkQ7S0FNWUcsVUFBQSwyQkFOTmpDLFVBTU1JO0tBTlo4QixtQ0FNWUQsZUFOWkQ7SUFJWSxHQUFBN0I7S0FBQTtNQUFBZ0MsUUFBQWhDO01BQUFpQyxVQUFBLDBCQUFBRDtNQUFBRSw0QkFBQUQ7TUFKWkUsa0JBSVlELFNBSlpIOztTQUFBSSxjQUFBSjtJQUVJO0tBQUFLLFVBQUEsK0NBQUFyQztLQUZKc0Msb0NBRUlELGVBRkpEO0lBQUEsV0FBQUU7O1lBc0RJQyxLQUFLNzZDLEdBQUksbUNBQUpBLE1BQXFCO1lBQzFCMk8sUUFBT2UsSUFBZUMsSUFBSyxPQUFBLHNCQUFwQkQsSUFBZUMsSUFBcUI7WUFDM0NqQixVQUFRZ0IsSUFBR0MsSUFBSyxnQ0FBUkQsT0FBR0MsT0FBNEI7WUFDdkMybkIsVUFBVXQzQixHQUFJLHlDQUFKQSxNQUF5QjtZQUNuQzg2QyxlQUFlOTZDO0lBQUkseUNBQUpBO0dBQThCO1lBQzdDbTlCLE9BQU9uOUIsR0FBSSx5Q0FBSkEsTUFBc0I7WUFDN0IrNkMsV0FBUy82QyxHQUFJLHlDQUFKQSxNQUF3QjtZQUNqQ21LLE9BQU9uSyxHQUFJLGtDQUFKQSxNQUF5QjtZQUNoQ2d5QixTQUFTaHlCO0lBQUksV0FEYm1LLE9BQ1NuSztJQUFJLE9BQUE7R0FBWTtZQUV6QmtZLFlBQVU4aUM7SUFDWjs7TUFDTS91QztpQkFBTUMsR0FBRThoQjtTQUFRLE9BQUUsV0FBWjloQixHQUFZLDBCQUFWOGhCLE9BRkZndEI7UUFFK0I7O2lCQXFDekJwdEI7dUJBQ1crbkI7VUE1TnpCL3NDLFVBNE55QitzQztVQUVYLEdBQUEsbUNBRldBLGFBeENqQnFGOztVQTBDRCxNQUFBO1NBQXlDO1NBRjVCLE9BQUEseUJBRE5wdEI7UUFHbUM7O2lCQWZuQzRwQjtTQUdUO2VBaENQeGxCLFNBRVVncEIsWUE4QjZCLDJCQUh2QnhEO1VBR2dCLE1BQUE7dUJBQ1F5RDtVQUMvQjtXQW5KUDtZQURJaHZDO3VCQUFNQyxHQUFFOGhCO2VBQVEsT0FBRSxXQUFaOWhCLEdBQVksMEJBQVY4aEIsT0FtSjBCaXRCO2NBbkpHO1lBQ3pDOztlQU1XLFlBQ007bUJBQ0h0RjtlQUFZLE9BekUxQi9zQyxVQXlFYytzQztjQUF3QztXQVRsRDFwQzs7Y0FHTyxtQkFDZ0I7a0JBQ1R2RjtjQUFnQixHQUFBLG1DQUFoQkE7Y0FBUyxNQUFBO2FBQWU7YUFaMUNvdkM7V0FPSTdwQyxZQU5KNHBDOztnQkFpQkE5bkM7V0FDQTtZQURBQywwQkFBQUQ7O1lBQ0E7Ozs7OztxQkFwQkphLDRCLGNBMkowQ3FzQzs7O3lEQXhJdENqdEM7Ozs7Ozs7OztzQkF3SXNDaXRDOzs7aUJBaElqQ3YwQyxxQkFBSyxrQ0FBTEE7Ozs7Y0FDRDZ0QztxQkFBSyxrQ0FBTEE7Ozs7Y0FDUXdDO3FCQUFNLGtDQUFOQTs7VUFnSUU7VUFBUCxNQUFBO1NBQW1DO1NBRnJDLDJCQUpTUztTQVFOLFdBMUNWbGdCLFVBT1UwakI7U0FtQ0EsV0FBQTtTQUF3QixHQUFBLDJCQVJsQnhEO1NBUVcsTUFBQTtRQUFxQzs7aUJBbkJoREM7dUJBQzJCdnJDO1VBQ2xDLEdBQU8sbUNBRDJCQSxNQWpCakM4dUM7VUFrQkQsTUFBQTtTQUF3RDtTQUQxRCwyQkFEU3ZEO1NBQ1Q7VUFBQTtVQU1PLE9BQUEsMkJBUEVBO1VBTUwsT0FBQSxnQ0E5RlRUO1NBMkZZLEtBQUE7VUFBUCxNQUFBO1NBTUcsV0EzQlZobEIsU0FFVWdwQjtTQXlCQSxXQUFBO1NBQXVCLEdBQUEsMkJBVGpCdkQ7U0FTVSxNQUFBO1FBQXVDOztpQkFoQmpEQztTQUNUO2lCQVZHc0Q7VUFhRSxPQWhCWjd3QyxPQUdVNndDO1VBYUUsT0FBQTtVQUFBLGVBcEJaMWpCLFVBT1UwakI7VUFZQyxPQUFBLGtDQUhLdEQ7U0FDRixHQUFBO1NBQVAsTUFBQTtRQUcrQztLQVhsRHpyQztnQkFLdUIyckM7UUFBZSxHQUFPLG1DQUF0QkE7UUFBZSxNQUFBO09BQXlCO09BdkQzRE07S0FrREpqc0MsWUEvQ0lnc0M7S0ErQ0poc0MsWUFoQ0orckM7S0FnQ0kvckMsWUE5Qko4ckM7S0E4Qkk5ckMsWUF2Qkk2ckM7S0FLUjtLQW1CQTs7VUEwQ0EvcEM7S0FBTztNQUFQQywwQkFBQUQ7O01BQU87NkI7Ozs7OztlQXpEWG9xQyw2QixxQkFZYzZDOzt5REE2Q1ZodEM7Ozs7Ozs7O0dBQWtGO0dBSXBGLFNBQUFrdEM7SUFBQSxNQUFBO0dBQWlDO1lBQ2pDN25DLFlBQUs4bkMsVUFBTEM7SUFBQSxPQTlERmpELGFBOERPZ0QsVUFETEQsaUJBQ0FFO0dBQW1EO0dBTW5ELFNBQUFDO0lBQUEsTUFBQTtHQUFpQztZQUNqQzNrQyxZQUFLNGtDLFVBQUxDO0lBQUEsT0FyRUZwRCxhQXFFT21ELFVBRExELG1CQUNBRTtHQUFtRDtHQUt4QyxJQUFUQztZQUVBemdDLGdCQUFpQjY4QixhQUFhcHhDLE1BQU1pMUM7SUFGcENEO0lBaUJzQjtLQUFBLE9BQUE7S0FUTixPQUFBO0tBREwsT0FBQTtLQVFPLE9BQUE7S0FERSxPQUFBO0tBSFAsT0FBQTtLQVBYeDdDOztRQUpGdzdDO1FBRThCaDFDO1FBQU1pMUM7UUFBbkI3RDs7Ozs7Ozs7O0lBa0JuQixPQWhCSTUzQztHQWdCSDtZQUdDMDdDLHFCQUFxQjlEO0lBQ3ZCLEtBQUcsbUNBRG9CQTtLQUdsQixPQUhrQkE7O3dEQUFBQTs7Ozs7R0FHUDtZQUdkL3lDLE9BQVEreUMsYUFBYXB4QztJQUN2QixHQURVb3hDO1NBR0Q5MUMsSUFIQzgxQyxnQkFDTk0sZ0JBUEZ3RCxxQkFTTzU1Qzs7U0FGTG8yQztJQUtJO0tBQUpsNEM7T0FqQ0YrYSxnQkE0QkVtOUIsZUFEbUIxeEMsTUFNb0M7SUFFM0Qsa0NBRkl4RztPQXJWRjIwQyxvQkFvUEF6OEIsWUFpR0VsWTtJQUlKLFdBSklBLEdBQUFBO0dBSUE7WUFHRjI3QyxnQkFBZ0IzN0M7SUFDbEIsV0FEa0JBLE1BQ2YsT0E1R0RtSyxPQTJHZ0JuSztJQUNjLEtBQTdCLG9EQWhIRHMzQixVQStHZ0J0M0I7S0FHVjtNQUFBLE9BQUEsa0NBSFVBO01BR1YsZUFIVUEsT0FJQzs7O0lBRmQsT0FBQSxrQ0FGYUE7R0FJZTtZQUcvQnMrQixNQUFNdCtCO0lBQ1IsR0FyV0UwMEM7OztpQkFxV3dEa0g7OEI7Z0JBNUg1RHpELDZCLHFCQTRINER5RDs7S0FBN0IsK0NBRHJCNTdDOztPQW5XTjIwQyxvQkFvUEF6OEIsWUErR01sWTtJQUdELGVBekhMczNCLFVBc0hNdDNCO2VBR0Q7SUFFTCxrQ0FMTUE7SUFNSCxHQXZISGd5QixTQWlITWh5QjtLQVFKLDJCQVJJQSxNQTNNSjgyQztLQW9OQSwyQkFUSTkyQzs7SUFTSixPQWhCRjI3QyxnQkFPTTM3QztHQVVZO1lBR2xCNjdDLFdBQVc3N0M7SUFDYixHQWxYRTAwQzs7O2lCQWtYNkRvSDs4QjtnQkF6SWpFM0QsNkIscUJBeUlpRTJEOztLQUFsQyxvREFEaEI5N0M7O09BaFhYMjBDLG9CQW9QQXo4QixZQTRIV2xZO0lBR04sZUFySUw4NkMsZUFrSVc5NkM7ZUFHTjtJQUVMLGtDQUxXQTtrQkFNMEIrN0MsT0FBUyxPQXJNNUM3cEIsS0FxTW1DNnBCLG1CQUFnRDtJQUFyRiwyQkFOVy83QztJQU9YLDJCQVBXQTtJQVFYLDJCQVJXQTtJQXBCWDI3QyxnQkFvQlczN0M7SUFTWCxPQXRCQXMrQixNQWFXdCtCO0dBV0g7WUFHUmc4QywrQkFBc0NwRSxhQUFZMXJDO0lBQ3BELElBQVcsUUFoRFRySCxPQStDc0MreUMsb0JBQ2pDcUUsY0FBSHI2Qzt5QkFDa0IsT0E3QnBCMDhCLE1BNEJLMmQsR0FDc0I7SUFBeEIsV0FBQSxXQUYrQy92QyxHQUM3Qyt2QztJQUNQO0lBQUEsT0FESXI2QztHQUVIO1lBR0NzNkMsY0FBZXRFLGFBQWF1RSxvQkFBbUJqd0M7SUFDakQsS0FEOEJpd0M7S0FFekIsT0FSSEgsK0JBTWVwRSxhQUFnQzFyQztJQUlwQyxJQUFBLFFBekRYckgsT0FxRGUreUMsb0JBSVJxRSxjQUFIcjZDOztLQXJDSjA4QixNQXFDTzJkO0tBUUEsT0FBQTtJQUNTO3lCQUhBLE9BQ0YsV0FYaUMvdkMsR0FJeEMrdkMsR0FNWTtJQUpqQjs7T0FBQTs7SUFERjtJQUFBLE9BRElyNkM7R0FVRjtZQUdGdzZDLGNBQWV4RSxhQUFZMXJDO0lBQzdCLElBQVcsUUF2RVRySCxPQXNFZSt5QyxvQkFDVnFFLGNBQUhyNkM7O0tBdENGaTZDLFdBc0NFajZDO0tBUUcsT0FBQTtJQUNTO3lCQUhBLE9BQ0YsV0FSZXNLLEdBQ3pCdEssR0FNZTtJQUpqQjs7T0FBQTs7SUFERjtJQUFBLE9BRE9xNkM7R0FVTjtZQUdDSSxpQkFBaUJyOEMsR0FBRTIxQztJQUNyQiw0QkFEcUJBLFVBalZqQnQ0QjtJQW9WRjtLQUFNLFlBQUEsMkJBSFdyZDtpQkFJUDtLQUVMO01BREUrN0M7TUFDRixPQUFBLG1DQU5ZLzdDLE1BS1YrN0M7S0FDRixXQUFBO0tBRU8sMkJBUksvN0M7UUFBRTIxQztNQVlQO09BREFFLGFBWE9GOztrQkFLWm9HO1csZ0JBT2lFTyxjQUMvRCxPQS9QUHBxQixLQXVQSzZwQixPQU9pRU8sY0FDMUI7O1dBUnZDUDtPQU9LLE9BOVVWdEcsK0JBNlVVSTtNQUNMOzs7TUE5UEwzakIsS0F1UEs2cEI7O0dBV0Y7WUFhTFEsWUFBWXY4QyxHQUFFMjFDO0lBQ1IsV0FoTk54ckMsT0ErTVluSztJQUNQLEtBQUE7S0FBUCxNQUFBO0lBQ2EsSUFBVEUsU0FBUywyQkFGQ0Y7SUFBQUEsT0FBQUE7SUE3QlpxOEMsaUJBNkJZcjhDLEdBQUUyMUM7SUFwR2RnRyxnQkFvR1kzN0M7SUFLZCxPQUhJRTtHQUlFO1lBR0pzOEMsUUFBUXg4QyxHQUFHeThDLGtCQUFpQjlHO0lBQzlCLEtBQU8sbUNBRE04RztLQUNiLE1BQUE7SUFDdUIsV0ExTnJCdHlDLE9Bd05Rbks7SUFFUCxHQUFBLG1DQUZVeThDO1NBakJUdjhDLFNBaUJNRjtLQUFBQSxPQWhCRTtLQUM2QixXQUFBLDJCQUZyQ0U7S0FpQk1GLE9BQUFBO0tBdENScThDLGlCQXNDUXI4QyxHQUFvQjIxQztLQTdHNUJnRyxnQkE2R1EzN0M7S0FiVixPQUpJRTs7SUFpQk1GLE9BQUFBLE9BQUd5OEM7SUF0Q1hKLGlCQXNDUXI4QyxHQUFvQjIxQztJQU9mLElBQVQrRyxXQUFTLCtCQVBGRDtJQVFYLDJCQVJRejhDLE1BT0owOEMsY0FQT0Q7SUE3R1hkLGdCQTZHUTM3QztJQVNSLE9BRkkwOEM7R0FHRztZQUdQQyxrQkFBZ0IzOEMsR0FBRTQzQztJQUNGLElBQWRNLGdCQTlJRndELHFCQTZJa0I5RDtJQUFGNTNDLE9BQ2RrNEM7SUFFSixPQTdIRXlELGdCQTBIZ0IzN0M7R0FHRDtZQWlCZjQ4QyxZQUdzRUM7SUFGeEUsR0E1ZUVuSTs7O2lCQTRld0RvSTs4QjtnQkFuUTVEM0UsNkIscUJBbVE0RDJFOztLQUE3QiwrQ0FFMkNEOztPQTdldEVsSSxvQkFvUEF6OEIsWUF5UHNFMmtDO0lBQXJFLFdBaFFEdmxCLFVBZ1FzRXVsQjtJQUFyRSxXQUFBO0lBQWlCLElBQUE7eUI7Ozs7Ozs7Y0FyUXRCMUUsNkIscUJBcVEwRTBFOzs7Ozs7R0FBVTtZQUdoRkUsYUFBYS84QztJQUNmO0tBcEJvRCxLQUF6QywyQkFtQklBLFdBOVBiZ3lCLFNBOFBhaHlCO01BbEJNO09BQWZnOUMsZUFBZSwyQkFrQk5oOUM7T0FqQlQyMUMsV0FEQXFIO09BRUosUUFGSUE7OzthQUdHaHFCO1NBQVEsa0NBQVJBOzs7U0FDc0IsSUFBdkJFLG1CQUF1QixrQkFsQzdCcXBCLFlBZ0RhdjhDLEdBakJUMjFDO1NBR1Usa0NBQVJ6aUI7OztTQUVXO1VBRFkrcEI7VUFBbEJSO1VBQ00sa0JBM0JqQkQsUUF1Q2F4OEMsR0FiRnk4QyxrQkFKUDlHO1NBS0Ysa0NBRDJCc0g7Ozs7S0FjL0IsT0FySkV0QixnQkFvSmEzN0M7O0dBRUU7WUFHZms5Qyw2QkFBNkJsOUMsR0FBRzhPO0lBWGhDOHRDLFlBVzZCNThDO0lBRS9CLDJCQUZrQzhPLE1BQUg5TztJQUUvQixPQVBFKzhDLGFBSzZCLzhDO0dBR2pCO1lBR1ptOUMsWUFBWW45QyxHQUFHOE87SUFOZm91Qyw2QkFNWWw5QyxHQUFHOE87SUFDakIsT0E1UUVpc0MsV0EyUVkvNkM7R0FFSjtZQVVSbzlDLE1BQU9wOUMsR0FBRWl1QixHQUFJLE9BWmJrdkIsWUFZT245QyxHQUFFaXVCLEdBQXlCO1lBRWxDb3ZCLHVCQUF1QnI5QyxHQUFFOHhCO0lBL0J6QjhxQixZQStCdUI1OEM7SUFFekIsMkJBRnlCQSxNQUFFOHhCO0lBRTNCLE9BM0JFaXJCLGFBeUJ1Qi84QztHQUdYO1lBR1pzOUMsUUFBTXQ5QyxHQUFFOHhCO0lBTlJ1ckIsdUJBTU1yOUMsR0FBRTh4QjtJQUNWLE9BaFNFaXBCLFdBK1JNLzZDO0dBRUU7WUFHUnU5QyxpQkFBaUJ2OUMsR0FBR2tNOztLQUV0QixPQXpTRW9yQixVQXVTaUJ0M0I7Ozs7ZUFFa0I7aUJBRmZrTSxZQUV1QnVoQixHQUFLLE9BYmhENHZCLHVCQVdpQnI5QyxHQUUwQnl0QixHQUErQjtJQUFFO0lBRGpFLFdBclNYc3RCLFdBb1NpQi82Qzs7O1lBS2pCdzlDLGNBQWN4OUMsR0FBRXl0QjtJQUFJLE9BNVNwQjZKLFVBNFNjdDNCO2NBQStDO2NBVjdEczlDLFFBVWN0OUMsR0FBRXl0QjtHQUFzRDtZQUV0RWd3QiwrQkFBK0J6OUMsR0FBRXl0QjtJQUM1QixlQS9TTDZKLFVBOFMrQnQzQjtrQkFsQi9CcTlDLHVCQWtCK0JyOUMsR0FBRXl0QjtHQUNpQjtZQUdsRGl3Qix3QkFBeUIvSCxVQVVOZ0k7SUFUckIsS0FEMkJoSSxVQUVqQjtJQUVMO0tBREVFLGFBSG9CRjtLQUl0QixPQUFBLG1DQU1nQmdJLFVBUGQ5SDtJQUNGLFdBQUE7SUFFRDtLQUFBOzs7Ozs7O2NBL1BKeGlDLDRCLGVBbVFxQnNxQzs7a0NBcmZyQjMvQixZQThlTzYzQjs7Ozs7OztHQU8wQjtZQUcvQitILFdBQVlqSSxVQUFTMzFDLEdBQUU2OUM7SUFDekIsR0E5aUJFbko7OztpQkE4aUJzRG9KOzhCO2dCQXJVMUQzRiw2QixxQkFxVTBEMkY7O0tBQTNCLG9DQURKRCxPQUFGNzlDOztPQTVpQnJCMjBDLG9CQW9QQXo4QixZQXdUcUJsWTtJQUVFLE9BZnZCMDlDLHdCQWFZL0gsVUFBUzMxQztHQUdZO1lBR2pDKzlDLGFBQWNwSSxVQUFTMzFDLEdBQUV3OEM7SUFOekJvQixXQU1jakksVUFBUzMxQztJQUV0QixHQWxVRGd5QixTQWdVdUJoeUIsSUFHakIsT0F4VU5zM0IsVUFxVXVCdDNCO0lBS2hCLEdBQUEsMkJBTGdCQTtLQU92QixrQkFBSSxXQVBxQnc4QyxTQUFGeDhDLEdBQVQyMUM7SUFLZCxNQUFBO0dBRXlCO1lBR3pCcUkscUJBQXNCdkI7SUFDeEIsS0FEd0JBLGtCQUVkO1FBQ0h3QixxQkFIaUJ4QjtJQUluQixHQUFBLG1DQURFd0I7Ozs7aURBQUFBOzs7OztLQUVBOztJQUFBLE9BRkFBO0dBR1c7WUFHaEJDLFNBQVd2SSxVQUFVOEcsa0JBQWlCejhDO0lBQ2pCLElBQW5CaStDLHFCQVZGRCxxQkFTcUJ2QjtJQUVFLE9BckJ2QnNCO2FBbUJXcEk7YUFBMkIzMUM7c0JBRVZBLEdBQUUyMUM7Y0FBWSxPQTlIMUM2RyxRQThINEJ4OEMsR0FEMUJpK0Msb0JBQzRCdEk7YUFBZ0Q7R0FBQztZQUcvRXdJLFdBQVV4SSxVQUFTMzFDO0lBQUksT0F4QnZCKzlDLGFBd0JVcEksVUFBUzMxQyxHQTFJbkJ1OEM7R0EwSTJEO1lBQzNEMXFCLEtBQUs3eEIsR0FBSSxrQ0FBSkEsTUFBdUI7WUFFNUIwTSxNQUFNMU0sR0FSTmsrQyxlQVFNbCtDLElBRStCLFNBQUU7WUFHdkNnMEIsS0FBTzJoQixVQUFVOEcsa0JBQWlCejhDO0lBQ2IsSUFBbkJpK0MscUJBdkJGRCxxQkFzQmlCdkI7SUF0Q2pCbUIsV0FzQ09qSSxVQUEyQjMxQztJQUc5QixJQUNKNEIsSUFqQkFzOEMsU0FhT3ZJLGNBQ0xzSSxxQkFEZ0NqK0M7Y0FJbEM0Qiw0QkFBQUE7OztpQkFFcUJveEI7U0FDbkIsT0FFRTs7a0JBVDhCaHpCOzBCQUNoQ2krQyxvQkFLbUJqckIsT0FOZDJpQjtRQVM4RDtLQUhyRCxPQUFBOztJQUZPLE9BQUEsMENBQXZCL3pDO0dBS3NFO1lBR3RFdzhDLE9BQU16SSxVQUFTMzFDO0lBbERmNDlDLFdBa0RNakksVUFBUzMxQztJQUVkLEdBOVdEZ3lCLFNBNFdlaHlCO0tBSVosR0FyWEhzM0IsVUFpWGV0M0I7TUFLVixPQUFBOzs7aUJBRWtCZ3pCO1NBQ25CLE9BQThCLDJCQVJuQmh6QixjQU9RZ3pCLE9BUGpCMmlCO1FBUXVFO0tBRDNELE9BQUE7O0lBR1gsS0FBQSwyQkFWUTMxQztLQVVmLE1BQUE7SUFDTyxzQkF6S1B1OEMsWUE4SmV2OEMsR0FBVDIxQztJQVdDLE9BQUE7R0FBK0I7WUFHdEMwSSxTQUFVMUksVUFBUzMxQzs7Szs7Ozs7O1NBRWY4eEI7S0FBUyxPQUFUQTs7SUFESSxXQWZSc3NCLE9BY1V6SSxVQUFTMzFDOzs7WUFNbkJzK0MsaUJBQWlCdCtDO0lBdEVqQjQ5QyxjQXNFaUI1OUM7SUFFWixLQWxZTGd5QixTQWdZaUJoeUIsSUFHZCxPQUFBO0lBQ0csR0F6WU5zM0IsVUFxWWlCdDNCO0tBS2QsT0FBQTtJQUVHLFlBQUEsMkJBUFdBOzs7O1VBUXNCZ3pCO01BSXJDLE9BQUEsa0NBSnFDQTs7O2tCQU1oQkE7S0FDbkIsT0FBOEIsMkJBZmpCaHpCLGNBY01nekI7SUFDbUQ7SUFEeEQsT0FBQTtHQUMwRDtZQUc1RXVyQixZQUFZditDO3lCQUE2RCxPQTFEekVtK0MsY0EwRFluK0MsR0FBdUU7SUFBNUQsV0FsQnZCcytDLGlCQWtCWXQrQztJQUFnQyxPQUFBO0dBQXdDO1lBRXBGdytDLCtCQUFnQ3grQyxHQUFFd0M7a0JBRWhDaXJCO0tBRG1DLFVBQ25DQSw0QkFBQUE7Ozs7O2tFQUZnQ2pyQjs7Ozs7Ozs7O0tBRVQsT0FBdkJpckI7SUFNdUM7SUFQdkIsV0FIbEI4d0IsWUFFZ0N2K0M7SUFDSyxPQUFBO0dBT0k7WUFLekN5K0MsYUFBYzlJLFVBQVMzMUMsR0FBRzArQztJQXZHMUJkLFdBdUdjakksVUFBUzMxQztJQUV0QixHQUFBLG1DQUZ5QjArQzs7eURBQUFBOzs7Ozs7S0FHdkI7O2tCQUNnQjNnQjtLQUNOLElBQVQ3OUIsU0FBUztjQUNMZzJCO01BQ2EsSUFBZnlvQixlQUFlLDJCQUZqQnorQztNQUdLLEtBQUEsbUNBREh5K0MsY0FQb0JEO09BUXhCLE1BQUE7TUFDRyxHQUFBLG1DQUZDQyxjQVBvQkQ7T0FVRixPQUFBO3VDQU5MM2dCLHdCQUNmNzlCOztPQVFJO1FBQzJCOztXQUFBLG1DQVA3QnkrQzs7NkJBRkZ6K0M7UUFTK0QsT0FBQSxrQ0FWaEQ2OUI7O1dBV1Q5UDtPQUNKLDJCQURJQSxHQVZOL3RCO09BV0UsT0FWRWcyQjtNQVdLO01BTFQsV0E3RUpsQyxLQWlFYzJoQixjQUFZK0ksYUFPcEJDLG1CQVBpQjMrQztNQWFmLE9BQUE7S0FJSztLQUViLE9BYlFrMkI7SUFhRDtJQWZPLE9BQUE7R0FlTjtZQUdSMG9CLG1CQUFtQjUrQztJQUNyQixHQXhiRWd5QixTQXVibUJoeUI7S0FHaEIsT0FBQSx5QkFIZ0JBO2VBSWQ7ZUFscUJIMnhDO2dCQXFxQkU7aUNBUGUzeEMsT0F4a0JqQnkxQztrQkFvbEJtQmxnQjtLQUdpQyxXQXZjdERwckIsT0F3Ym1Cbks7S0FlZixPQUFBLDJCQWZlQSxVQUFBQSxpQkFZRXUxQjtJQUdrRDtJQUh2RCxPQUFBO0dBR3dEO1lBTXhFc3BCLGlCQUFpQjcrQztJQUNuQixHQUFHLHdCQURnQkEsUUFFZCxPQXZCSDQrQyxtQkFxQmlCNStDO0lBSWpCLGNBQ29Ca00sR0FBSyxPQUFBLFdBQUxBLE1BQVM7SUFEN0IsV0FBQSx5QkFKaUJsTTtJQUlqQixPQXZyQkUyeEMsUUF1ckJGO0dBRXlCO1lBS3pCbU4sYUFBYTkrQyxHQUFHNCtDO0lBQ2xCO0tBNW5CWUcsVUEybkJHLytDO0tBQ1gyMUMsZUE1bkJRb0oscUJBMm5CTUg7SUFBSDUrQyxZQUNYMjFDLFVBRFczMUM7SUFHZixPQUZJMjFDO0dBRUk7WUFzQkpxSixzQkFBWWgvQyxjQUFLLE9BQUxBO1lBRVoyVixTQUFRc3BDLFVBQVVDO2FBN0JHQywwQkFvQzBCLE9BN0NqRE4saUJBc0NVSSxVQU9nRTtJQXBDaEMsV0FBQSx5QkE2QnRCQyxnQkE3QkdDO0lBOEJ2Qjs7YUFEb0JEO2FBM0JwQko7ZUEyQlVHOytCQUtGLE9BaEVSTCxtQkEyRG9CTSxZQUtpQjs7R0FHbEM7WUFTTC9tQztJQUFBO0lBQ0UsSUFBQWluQyxxQkFBQUMsV0Fsc0JGcmhDLFlBa3NCRW9oQztJQUFBLHlCQUFBQztHQUdrQjtHQUxMLGtCQUNmbG5DO1lBT0VtbkMsU0FDR3BCLFVBQ0N0dUIsS0FDRjV2QixHQUNDaUYsTUFDQWlIO0lBRUwsR0FMTTBqQixTQUFVQyxNQUFWRCxRQUFBMnZCLFVBQVUxdkIsY0FBVjB2QjtjQUFBQTs7TUFLRjVKO1FBTEU0Sjs7O1dBckRKVDthQXNERTkrQzs7Y0FXb0QsT0FBQTthQUFVOztTQUpyRDYxQyxhQVJQMEosWUFLRjVKLGVBR1NFO09BdHdCWGxCLG9CQW9QQXo4QixZQTJnQkVsWTtJQWhPRjA5Qyx3QkFvT0UvSCxVQUpBMzFDO2tCQWVpQnEyQjs7ZUFJWEgsS0FBS0s7T0FDTCxZQUFBLFdBdEJMMm5CLFVBTUR2SSxVQUpBMzFDOztZQXNCTThCO1FBQUssT0FBQSxXQXBCVm9LLEdBaUJVcXFCLEdBR0x6MEIsR0FFSmdYOzs7UUFIUSxPQUFBLGtDQU5PdWQsVUFJTkU7NEJBSTZDLE9BSmxETCxLQUFLSyxHQUltRDtPQUF0QyxXQXBLMUIrbkIsaUJBNklFdCtDO09BdUIrQyxPQUFBO01BQWU7ZUFDNUQ4WSxXQUFTeWQ7T0FDWCw0QkFyQkFvZixVQTFxQkFIO09BK3JCQSxPQU5NdGYsS0FLS0s7TUFFTDthQVBBTCxLQWxCTGp4QjtLQTJCTTtLQVhULFdBQUE7S0FDSSxPQUFBO0lBVUs7SUFiSyxPQUFBO0dBYUo7WUFHVkQsS0FBT3U2QyxTQUFTOUMsa0JBQWlCejhDLEdBQUdpRixNQUFNaUg7a0JBQ29CcXFCLEdBQUV0SSxHQUFFaUk7S0FDbEUsV0FBQSxXQUYwQ2hxQixHQUNvQnFxQixHQUFFdEk7S0FDaEUsT0FBQSwrQ0FEa0VpSTtJQUNwRDtJQUQyQyxPQW5DekRvcEI7O2M7ZSxPQXZMQXBCLGVBeU5nQnpCOzthQUFUOEM7YUFBMEJ2L0M7YUFBR2lGOztHQUVyQjtZQUdmTyxPQUFNKzVDLFNBQVF2L0MsR0FBR2lGLE1BQU1pSDtJQUN6QixPQXhDRW96QzthQWxMQW5CO2FBeU5Nb0I7YUFBUXYvQzthQUFHaUY7c0JBQ3dCc3hCLEdBQUUzcEIsR0FBRXNwQjtjQUFRLFdBQUEsV0FEOUJocUIsR0FDa0JxcUIsR0FBRTNwQjtjQUFVLE9BQUEsK0NBQVJzcEI7YUFBc0I7R0FBQztZQUdwRXNwQixzQkFBdUI3SixVQUFTMzFDLEdBQUdpRixNQUFNaUg7a0JBS2pDcXFCLEdBQUUzcEIsR0FBRXNwQixNQUFRLE9BQUssV0FBYkEsTUFBYSxXQUxnQmhxQixHQUtqQ3FxQixHQUFFM3BCLElBQXNCO09BTFQrb0MsY0FTYnZCLElBVGF1Qiw0QkFTYnZCO0lBSlAsT0FoREhrTCxTQWxMQW5CLGtCQTZOZ0NuK0MsR0FBR2lGO0dBU0Y7WUFHakN3NkMsOEJBQWdDN3ZCLEtBQTJCMWpCLEdBQUVVO0lBQy9ELEdBRGtDZ2pCO1NBQW9CQyxNQUFwQkQsUUFBQTRWLG9CQUFvQjNWOztTQUFwQjJWO0lBQ2xDLEtBRGtDQSxtQkFFN0IsT0FBQSxXQUZ3RHQ1QixHQUFFVTs7SyxtQkFXbEQ7S0FDMEM7TUFBN0NvQjtNQUE2QyxPQUFBLHFDQUE3Q0E7TUFBd0IsT0FBQTtLQUFxQixPQUFBOzt5QkFIdEMsa0JBVDRDOUIsR0FBRVUsR0FTM0M7SUFKaEI7WUFBQTs7R0FPNkU7WUFHL0U3SCxLQUFPeWdDLG1CQUFtQitaLFNBQVM5QyxrQkFBaUJ6OEMsR0FBR2tNO0lBQ3pELE9BckNFbEg7YUFvQzBCdTZDO2FBQVM5QzthQUFpQno4Qzs7NkJBQ0NpdUI7Y0FDckQsT0FqQkF3eEIsOEJBZU9qYSxtQkFBZ0R0NUIsR0FDRitoQjthQUNEO0dBQUM7WUFHckQxb0IsT0FBTWlnQyxtQkFBbUIrWixTQUFRdi9DLEdBQUdrTTtJQUN0QyxPQTVFRW96QzthQWxMQW5CO2FBNlB5Qm9CO2FBQVF2L0M7OzZCQUNjNE0sR0FBRXNwQjttQ0FDa0IsT0FBQSxXQURsQkEsU0FDeUI7Y0FBMUU7c0JBdEJBdXBCLDhCQW9CTWphLG1CQUE4QnQ1QixHQUNXVTtjQUNVLE9BQUE7YUFBaUI7R0FBQztZQU0zRTh5QyxzQkFDRy9KLFVBQ0MvbEIsS0FDRCt2Qix3QkFDRDMvQyxHQUNDa007SUFFTCxHQUxNMGpCO1NBQW9CQyxNQUFwQkQsUUFBQTRWLG9CQUFvQjNWOztTQUFwQjJWO0lBbFRKa1ksd0JBaVRHL0gsVUFHRDMxQztPQURDMi9DO1NBUUlDLDJCQVJKRDtLQVNFLEdBQUEsbUNBREVDOzs7OzsrQ0FBQUE7Ozs7Ozs7TUFHSDs7U0FORkMsMkJBR0tEOzs7U0FITEM7SUFZSjtLQUFJenhCO09BbEJFb1g7O1VBc0JFNTRCO1VBQ0YsSUFBSSxXQXBCTFYsR0FtQkdVLElBQ0U7Z0JBQ0ZtQjtXQUF3QjtZQUF4QkMsMEJBQUFEO1lBQXdCLE9BQUE7V0FBakIsT0FBQSw4Q0FBUEM7O1NBQWdEO1VBckJuRDlCO2tCQXVCZ0JtcUI7O2VBSVhoWjtPQUFXLElBQ1R5aUMsWUF6QlJEO09BMEJBO1FBQUcsR0FBQSxtQ0FES0M7U0FFSDtpQ0FBd0IsT0FIdkJ6aUMsU0FHK0I7VUFBaEMsT0FBQTtTQUFjLE9BQUE7O1FBRVgsWUExU1Y4Z0MsV0FzUUd4SSxVQUdEMzFDOzs7VUFrQ1ksT0FBQSxrQ0FWS3EyQjtTQWNTO2lDQUFnQyxPQVZwRGhaLFNBVTREO1VBQXhDLE9BdlE1QmloQyxpQkFpT0V0K0M7U0FzQ2lELE9BQUE7O1lBSHpDNE07UUFDSixXQXBCSndoQixLQW1CUXhoQjtRQUNKLElBUEltekMsY0FBQUQsbUJBQUFBLFlBQUFDOztNQUQrQztNQVl6RCxPQVpRMWlDO0tBWUE7S0FkUixXQUFBO0tBQ0ksT0FBQTtJQWFJO0lBaEJNLE9BQUE7R0FnQkw7WUFHVDJpQyxNQUFNaGdEO0lBQUksT0E1RFYrRTs7OzthQTRETS9FOztjQUF5QixPQUFBO2FBQVM7R0FBQztZQUN6Q2lnRCxnQkFBZ0JqZ0Q7SUFBSSxPQWpHcEJnRjs7O2FBaUdnQmhGOztzQkFBNEJrZ0QsS0FBSWp5QjtjQUFLLFdBQVRpeUIsTUFBdUIsMkJBQW5CanlCOzthQUFrQztHQUFDO1lBRW5Ga3lCLFNBQVNDO0lBQ0UsSUFBVGxnRCxTQUFTO3lCQU1iLE9BTklBLE9BTUU7SUFKSjs7T0FsRUE2RTs7OztTQStEU3E3QztrQkFHV255QjtVQUNsQiwyQkFEa0JBLEdBRmxCL3RCO1VBR0EsT0FBQTtTQUNTOztHQUVQO1lBR0pvRixRQUFRMUQ7SUFBSSxJQUFBLHVCQUFBLE9BVlp1K0MsU0FVUXYrQztJQUFJLE9BQUE7R0FBNEI7WUFFeEN5K0MscUJBQXFCcmdEO2tCQUNKdTRCOzBCQUVILE9BRGQsaUNBRGlCQSxNQUVnQjtLQURqQzs7UUFoRUFtbkI7Ozs7VUE4RHFCMS9DO21CQUVXeXRCLEdBQUssT0FBQSxpQ0FEcEI4SyxNQUNlOUssR0FBdUI7S0FDbkQsT0FBQTtJQUE2QjtJQUZyQixPQUFBO0dBRXNCO1lBb0JsQzZ5QixxQkFBcUIzNUM7SUFDdkI7S0FBVyxRQXRsQlQ5QjtLQXNsQktvM0M7S0FBSHI2QztLQUNBcXNCLElBQUk7YUFDSnN5QjtLQUNLLGVBQUEsMkJBRkx0eUI7Z0JBRUs7S0FHVSxXQXBhakJtdkIsTUE4WktuQixHQUNIaHVCO0tBS2UsT0FBQTtJQUFZO2FBRXZCK08sZ0JBQUtyMkI7S0FDWCxHQWpzQkEyd0IsVUF3ckJLMmtCO01BU0wsTUFBQTtLQUNvQjtNQUFoQnVFLGdCQUFnQix5Q0FGVDc1QztNQUdMLFFBQUEscUNBREY2NUM7O01BUkZEO01BUWtCLE9BQUE7O2VBQWhCQztlQU1GQzs7U0FKS3ZuQztLQUFRLGtCQUFBLE9BQUEsdUJBS2Jna0IsaUJBTEtoa0I7O0tBQVEsT0FLYmdrQix1QkFMS2hrQjtJQUdvQzthQUV6Q2drQjtLQUFZLFlBZlpxakIsb0JBcGtCRmppQixNQWtrQksyZDtTQXFCTXQxQyxjQUFIOG1CO0tBQ04sMkJBckJBUSxHQW9CTVI7S0FDTixrQkFBQSxPQUFBLHVCQWRJdVAsWUFhS3IyQjs7S0FDVCxPQWRJcTJCLGtCQWFLcjJCO0lBRUg7YUFmRnV2QixLQUFLdnZCLEcsdUJBQUxxMkIsVUFBS3IyQjthQVNUczJCLGlCLHVCQUFBQzthQURBdWpCLHVCQUF1QnZuQztLQUFjLGVBeHNCdkNvZSxVQXdyQksya0I7bUJBaUJIaGYsVUFEdUIvakI7SUFBK0M7SUFSbEVnZCxLQVRldnZCO0lBMEJ2QixPQXpCSS9FO0dBMEJIO1lBR0M4K0MsYUFDR3hDLFVBQ0RkLE9BQ0FnRCxPQUNBTyxRQUNDejBDO0lBRUwsR0F6OEJFeW9DLG9CQW9QQXo4QixZQWl0QkVrb0MsUUFqdEJGbG9DLFlBa3RCRXlvQztJQU9PLElBQVBDLE9Bek9BanJDLFNBaU9BeXFDLE9BQ0FPLFNBUUFoTCxXQTVPQXFKLFdBMk9BNEI7YUFLQUM7S0FBWSxJQW5PTzdnRCxJQThObkI0Z0Q7S0E3TkYsT0FBQSx5QkFEcUI1Z0QsVUFBQUE7SUFtT2tCO2tCQUNwQkU7O2VBSWY0Z0Q7T0F2bUJKakYsV0FxbEJFdUU7T0FhQVM7T0FPQSxPQUFBLGtDQU5pQjNnRDtNQU9FO2VBRWJnMkI7T0FDTixHQWh2QkZvQixVQXl0QkVxcEIsU0F3QkssT0FQSEc7T0FTTSxZQUFBLFdBN0JQNUMsY0FXRHZJLFdBVEF5Szs7WUErQlEzeUI7UUFBSyxPQUFBLFdBN0JadmhCLEdBNkJPdWhCLEdBS04zVTs7O1FBdkJGK25DO1FBZ0JJLE9BQUEsa0NBZmEzZ0Q7OzRCQXFCQyxPQVpaZzJCLFFBWW1CO09BQWpCOzJCO09BRCtDO1FBQUEsT0F4dkJ6RGlILE9BdXRCRXdqQjttQkFpQ2dEOzJCO09BQWpDO1FBQUEsT0FyWGpCckMsaUJBbVZFOEI7UUFrQ00sV0FBRTtRQURKLE9BQUE7T0FFSSxPQUFBO01BQWtCO2VBQ3hCdG5DLFdBQVM2VTtPQUNYLEdBN3ZCRjJKLFVBeXRCRXFwQixTQXFDSyxPQXBCSEc7T0FzQmUsSUFBWHBKLFdBQVcsV0F6Q2pCMEYsT0FFQXVELFFBbUNXaHpCO09BaDVCWDZuQix1QkFxM0JBRzs0QkFpQ3lCLE9BbkJuQnpmLFFBbUIwQjtPQUFqQixPQUFBLHlDQUZUd2hCO01BRTJCO01BRW5DLE9BckJReGhCO0tBcUJEO0tBNUJQLFdBQUE7S0FDSSxPQUFBO0lBMkJHO0lBOUJPLE9BQUE7R0E4Qk47WUFHUnFxQixTQUFXOUQsa0JBQWlCMkQsT0FBTU8sUUFBUXowQztrQkFDMkIraEIsR0FBRTNhO0tBQUssV0FBQSxXQURsQ3BILEdBQzJCK2hCO0tBQU8sT0FBQSwrQ0FBTDNhO0lBQWM7SUFBckIsT0FuRGhFb3RDOztjO2UsT0E3WEF4QyxlQSthV3pCOzthQTdlWFc7YUE2ZTRCZ0Q7YUFBTU87O0dBQ29EO1lBR3RGSSxXQUFTWCxPQUFNTyxRQUFRejBDO0lBQ3pCLE9BdkRFdzBDO2FBeFhBdkM7YUEzREFiO2FBeWVTOEM7YUFBTU87c0JBQ2dDL3pDLEdBQUUwRyxHQUFLLE9BQUUsV0FBUEEsR0FBTyxXQURqQ3BILEdBQ3dCVSxJQUFjO0dBQUM7WUFHOURvMEMsWUFBYXZFLGtCQUFpQjJELE9BQU1PO0lBQ3RDLGNBQXVFMXlCLEdBQUUzYSxHQUFLLE9BQUEsV0FBTEEsR0FBRjJhLEdBQVU7SUFBZixPQTNEaEV5eUI7O2M7ZSxPQTdYQXhDLGVBdWJhekI7O2FBcmZiVzthQXFmOEJnRDthQUFNTzs7R0FDNEM7WUFHaEZNLFFBQVFqdEIsTUFBS29wQixPQUFNZ0QsT0FBT2wwQztJQUM1QixjQUF5QzFGO0ssbURBQUFBOztJQUE5QjtLQUFQQSxPQUFPLDRCQURVNDVDO0tBRUEsUUFuckJuQnY3QyxVQWtyQkUyQjtLQUNRbTZDO0tBQVJ6Z0Q7eUJBQ3NELE9BaHFCeERvK0IsTUErcEJVcWlCLFFBQzBEO0lBQWpFLFdBakVIRCxhQThEUTFzQixNQUFLb3BCLE9BQU1nRCxPQUVUTyxRQUZnQnowQztJQUc1QjtJQUFBLE9BREloTTtHQUVFO1lBR0o0RSxJQUFNMjNDLGtCQUFpQjJELE9BQU9sMEM7a0JBQzJCK2hCLEdBQUUzYTtLQUFLLFdBQUEsV0FEbENwSCxHQUMyQitoQjtLQUFPLE9BQUEsK0NBQUwzYTtJQUFjO0lBQXJCLE9BUnBEMnRDOztjO2UsT0EzYkEvQyxlQWtjTXpCOzthQWhnQk5XO2FBZ2dCdUJnRDs7R0FDbUQ7WUFHMUV4NkMsTUFBSXc2QyxPQUFPbDBDO0lBQUksT0FYZiswQzthQXRiQTlDO2FBM0RBYjthQTRmSThDO3NCQUFnRHh6QyxHQUFFMEcsR0FBSyxPQUFFLFdBQVBBLEdBQU8sV0FBbERwSCxHQUF5Q1UsSUFBYztHQUFDO1lBRW5FczBDLGdCQUFpQnpFLGtCQUFpQjJELE9BQU9sMEM7a0JBQ2dCK2hCLEdBQUUzYTtLQUMzRCxPQUFFLFdBRHlEQSxHQUN6RCwyQkFEdUQyYSxHQURoQi9oQjtJQUVoQjtJQUQyQixPQWRwRCswQzs7YztlLE9BM2JBL0MsZUF3Y2lCekI7O2FBdGdCakJXO2FBc2dCa0NnRDs7R0FFUjtZQUcxQjlQLFdBQWFtTSxrQkFBaUIyRCxPQUFPbDBDO0lBQ3ZDLE9BWkVwSDthQVdhMjNDO2FBQWlCMkQ7c0JBQ0tueUI7Y0FBSyxPQUExQywrQ0FBcUNBLEdBREUvaEI7YUFDaUM7R0FBQztZQUd2RWkxQyxhQUFZMUUsa0JBQWlCMkQsT0FBT2wwQztrQkFDcUIraEIsR0FBRTNhO21CQUM3Qm1hLEdBQUssT0ExeUJuQ3F0QixlQXd5QjZCc0YsYUFFNkMsV0FGdENsMEMsR0FFTnVoQixHQUErQztLQUEzRSxPQUFBLFdBRHlEbmEsR0FDekQsMkJBRHVEMmE7SUFDc0I7SUFEM0IsT0F2QnBEZ3pCOztjO2UsT0EzYkEvQyxlQWlkWXpCOzthQS9nQlpXO2FBK2dCNkJnRDs7R0FFbUQ7WUFHaEZnQixtQkFBcUIzRSxrQkFBaUIyRCxPQUFPbjdDLE1BQU1pSDtJQUN6QyxJQUFSc29DLFlBRDJDdnZDO0lBRVIsT0FYckNxckM7YUFTcUJtTTthQUFpQjJEO3NCQUVJM3lCOzttQkFDL0JBLGNBQUg3Z0I7ZUFGTjRuQyxXQUVNNW5DO2VBRVIsT0FGVzZnQjs7Y0FBSSxXQUFBLFdBSG9DdmhCLEdBQ2pEc29DLFVBQ3dDL21COzs7R0FHeEM7WUFHRjR6QixxQkFBb0I1RSxrQkFBaUIyRCxPQUFPbjdDLE1BQU1pSDtJQUN4QyxJQUFSc29DLFlBRDBDdnZDO0lBRVIsT0FmcENrOEM7YUFhb0IxRTthQUFpQjJEO3NCQUVJM3lCO2NBQ3pDO2VBQVcsUUFBQSxXQUh1Q3ZoQixHQUNoRHNvQyxVQUN1Qy9tQjtlQUNsQzZ6QjtlQUFIMTBDO2NBRkY0bkMsV0FFRTVuQztjQUVKLE9BRk8wMEM7YUFFTjtHQUFDO1lBR0ZDLFlBQWE5RSxrQkFBaUIyRCxPQUFPbjdDLE1BQU1pSDtJQUM3QyxPQVRFbTFDO2FBUWE1RTthQUFpQjJEO2FBQU9uN0M7c0JBQ2tCdXZDLE9BQU01bkM7Y0FDN0Q7ZUFBZSxRQUFBLFdBRjRCVixHQUNZc29DLE9BQU01bkM7ZUFDbEQycEI7ZUFBUGlyQjtjQUNKLFdBRElBLGFBQU9qckI7YUFDRTtHQUFDO1lBR2RnYSxPQUFPNlAsT0FBT2wwQztJQUFJLE9BM0JsQmkxQztnQkEyQk9mLGdCQUFvQzN5QixHQUFLLE9BQUcsV0FBckN2aEIsR0FBNkJ1aEIsU0FBQUEsT0FBaUM7R0FBQztZQUU3RWtELFFBQVEvQztJQUNGLElBQUo1dEIsSUFod0JGK2Esc0JBZ3dCZ0UsMkJBRHhENlM7SUFFVixrQ0FESTV0QjtJQXh0QkYyN0MsZ0JBd3RCRTM3QztJQUVKLE9BRklBO0dBR0g7WUFHQ3loRCxhQUFXLE9BUFg5d0IsV0FPcUI7WUFFckIrd0IsVUFBVWowQjtJQUNaLElBQXFCLFFBOXVCbkI1b0IsaUJBOHVCVTg4QyxtQkFBUkM7SUFwakJGdkUsdUJBb2pCVXNFLFFBREFsMEI7SUF6dEJWNlEsTUEwdEJVcWpCO0lBRVosT0FGSUM7R0FHRTtZQUdKeGtCLE9BQWF6MkIsR0FBR3VGO0lBSWxCLFNBQUkyMUMsT0FBUy9xQixHQUFFNXFCO0tBQ1AsWUFBQSxxQ0FESzRxQjtpQkFFRCxPQUFBLHlDQUZDQSxHQUFFNXFCO1NBR051aEI7S0FBSyxPQUFBLFdBSEN2aEIsR0FHTnVoQjtJQUFRO0lBRXVCLE9BeHNCdEN5dUI7OztzQkF3c0IyQ3lGO3VCQUNuQ3pyQixLQUFLdnZCOztnQkFFTjtpQkFDSyxPQUFBO3NDQUNDQSxjQUFIaUc7Z0JBQ0gsR0FyMkJQMHFCLFVBKzFCMkNxcUI7aUJBTWQsT0FBQTtxQ0FBNkMsT0FMbEV6ckIsS0FJS3Z2QixHQUNtRTtnQkFBaEIsT0FYOURrN0MsT0F4akJGdkUsUUE2akIyQ3FFLFFBS2pDLzBDO2VBQ3NFO2VBSHpFLE9BUkxpMUMsT0FPQSxXQVhjMzFDLEdBVUh2RjtjQUttRTtxQkFMeEV1dkIsS0FWS3Z2QjthQWlCUDtHQUFDO1lBR1BtN0MsWUFBWTNRO0lBQ2QsT0FwdEJFK0s7OztzQkFvdEIyQ3lGO3VCQVduQ3pyQixLQUFLNnJCO2VBQ1g7O2lCQXYzQkZ6cUIsVUEyMkIyQ3FxQjtzQkFZbEIsOEJBRFpJO2dCQXpuQmJuRixZQThtQjJDK0U7Z0JBZ0JxQjtpQkFBQSxPQXYzQmhFeDNDLE9BdTJCMkN3M0M7aUJBQ2hCNUssV0FEZ0I0SztpQkFnQm5DeFEsV0FMSzRRO2lCQVZjcjdDLElBQUFxd0M7Z0JBQ3pCO2lCQUFHLEtBQUEsbUNBRHNCcndDO2tCQUlqQixZQUFBLDhCQVdGeXFDOzs7O29CQWZVNlE7b0JBTU5wMUM7bUJBQ04sMkJBUnFDKzBDLFdBTy9CLzBDO21CQUNOLElBUHFCMm5DLE1BQUE3dEMsV0FlbkJ5cUMsV0FmVTZRLFlBQVN0N0MsSUFBQTZ0Qzs7OztpQkF6bUIzQndJLGFBd21CMkM0RTtpQkFrQnpCO3lDQUNkLE9BUkl6ckIsS0FLQWliLFVBR1M7a0JBREMsT0ExM0JsQjRKLFdBdzJCMkM0Rzs7Ozs7ZUFhcEMsT0FBQTtjQU1XO2NBbkJwQixPQVdVenJCLEtBWklpYjthQXNCQztHQUFDO1lBT2Q4USxZQUFZamlEOztLQUVOLFlBNWlCTm0rQyxjQTBpQlluK0M7O2dEQWxnQlpzK0MsaUJBa2dCWXQrQztTQUlONE07S0FBSyxtQkFBTEE7SUFDMEQ7SUFKdEMsT0FBQTtHQUl1QztZQUdqRXMxQyxnQkFBZ0JDO0lBQ2xCO0tBQTRCO09BOXlCMUJ0OUM7O0tBOHlCVXU5QztLQUFSekI7S0FJQTBCO2FBQ0FDO0tBREFEO0tBR0MsV0FBQSxtQ0FIREE7S0FHQyxjQWp5QkgvakIsTUEweEJVOGpCO0lBTzBDO0lBRXRELHFCQVFHLE9BWkNFLDRCQVkwQjtJQU56QjtLQUFBO09BelRINUM7Ozs7U0E2U2dCeUM7a0JBWXdCL0I7VUFQdENpQzsrQkFXTSxPQVZOQyw0QkFVaUM7VUFEZDtXQUFBLE9BL0lyQnRCLGVBNEl3Q1osT0FYOUJnQzs7O1NBZTBCOztJQU50QztJQUFBLE9BVEl6QjtHQW1CRTtZQUdKdmlCLFdBQVcrakI7SUFDYixHQXBwQ0V4TixvQkFvcEN1Qix5QkFEWndOLFFBLzVCWGpxQztJQWk2QmMsT0F6QmRncUMsZ0JBekVBdnhCLFFBZ0dXd3hCO0dBRW1CO1lBRzlCN1EsTUFBTTZRLFFBQVFsVDtJQUNoQixLQURRa1QsUUFFQSxPQWhHTlY7T0E4Rk1VO0tBTUs7TUFBQSxRQS8wQlh0OUM7TUErMEJPbzNDO01BQUhyNkM7O3dCQUN1QixnQ0FQckJ1Z0QsUUF4eUJOdEcsWUEreUJ5RDtNQUFwRCxPQWg3QkwxZSxPQSs2Qk84ZTtLQUNQO0tBQUE7TUFBQTs7O1NBQzRCLElBQWNwbkIsY0FBUkQ7U0FBa0IsT0FBQSxXQVJ0Q3FhLFNBUW9CcmEsSUFBUUM7UUFBd0I7TUFBOUQwdEIsT0FBTztNQUNQQztpQkFBWXBDLE9BQU1xQztTQUNwQixVQURvQkEsd0JBRVY7YUFDSjNnRCxJQUhjMmdEO1NBR0ssT0FBQSw2QkFKdkJGLFVBSUl6Z0QsR0FIUXMrQztRQUdxQjtNQUU3QnNDOztTQVVOO1VBQU0sWUFBQSw2QkFoQkpIOzZCQTd6Qkpqa0IsTUEyekJPMmQ7VUFxQkk7O1dBREVtRTtXQUFIdCtDO1dBQ0MsV0F0OEJYdzFCLFVBaTdCTzJrQjtxQkFxQkk7VUExcUJYb0IsdUJBcXBCT3BCLEdBb0JHbjZDO1VBSUQsV0FBQSw0QkF0Qkx5Z0Q7VUFzQkssR0FBQTtXQUNPO21DQUFpQyxPQXAxQmpEamtCLE1BMnpCTzJkLEdBeUJpRDtZQUF4QyxPQTNMaEIrRSxlQXNMYVosT0FwQk5uRTtXQXlCK0IsT0FBQTs7VUFFeEIsSUFDSnh1QixJQWhuQlYwd0IsY0F3bUJhaUM7b0JBUUgzeUIsNEJBQUFBO1dBSUE7Ozs2QkFHUUE7Z0JBaENkKzBCLFlBaUJTcEMsT0FlSzN5QjtnQkFDUixPQTVCRmkxQjtlQTZCc0I7ZUFIcEIsV0FsbUJWdEUsVUFvbEJhZ0M7ZUFlQyxPQUFBO2NBRWdCO1lBTHBCLE9BOThCVnJGLFdBODZCT2tCO1dBaUNPLE9BQUE7O1VBOUJWdUcsWUFpQlNwQyxPQVFIM3lCOztRQVNzQjs7aUJBR0kyeUI7dUJBQ3hCM3lCLEdBQ1IsT0F2Q0ErMEIsWUFxQ2dDcEMsT0FDeEIzeUIsR0FDVztTQURQLFdBem1CaEIyd0IsVUF3bUJvQ2dDOzs7TUFEaEN1QztRQUNGLDhDQTlDSVI7S0FrRE47c0NBTElRLGNBL0JJRDtLQW9DUixPQTVDSTlnRDs7UUFIRncrQyxRQUhJK0I7SUFHTyxPQUFYL0I7R0FnREQ7WUFHRHdDLFlBQVlUO0lBRVo7S0FERXZnRDtPQWoxQkZvNkM7O2tCQWsxQjBDQztVQUN4QyxJQUFJMkUsT0E3ZUpqckMsU0EwZVV3c0MsUUFFOEJsRyxJQUVwQ3RHLFdBaGZKcUosV0ErZUk0QjtVQUV3QyxPQTVZOUNyN0M7OzJCQTJZTW93QzttQkFKTXdNOzRCQUt1Qy9CLE9BQVMsT0F2TjVEWSxlQXVObURaLE9BSFRuRSxHQUdxQztTQUFDO3lCQUV2RCxPQWwzQnpCM2QsTUEyMkJZNmpCLFFBT3lCO0lBQWxDLFdBdCtCSGhsQixPQWcrQkV2N0I7SUFNSjtJQUFBLE9BTklBO0dBT0g7WUFHQ2IsT0FBT29oRDtJQUNULE9BNTFCRW5HOztzQkE0MUJ3Q0M7NEJBQ05tRSxPQUFTLE9BL04zQ1ksZUErTmtDWixPQURNbkUsR0FDc0I7Y0FBakMsT0FBQTswREFGdEJrRzthQUV3RDtHQUFDO1lBR2hFVSxLQUFLN2lELEdBQUc4aUQ7SUFDVjtLQUF1QixRQWg1QnJCaitDO0tBZzVCV2srQztLQUFUQztLQUNtQixVQWo1QnJCbitDO0tBaTVCV28rQztLQUFUQztLQUNBQztLQUNBeE47T0F6aEJGbUo7U0FxaEJLOStDOztVQU1ILElBQUlvakQsMkJBSEpEOztXO3FCQUdJQzs7O1VBRUY7c0JBN2pCSnhFLG1CQXVqQldxRTtXQU1QLE9BM3RDRnRSLFlBOHBCRmlOLG1CQXNqQldtRTs7U0FlK0M7S0FHckRNLGlCQWxCTU4sYUFDQUU7YUFrQk5LLFlBQVlEO0tBRWQsS0FBTywwQkFGT0EsWUFyZ0NqQi9yQixZQXdnQ1EsT0FIUytyQjtLQWpCZkY7bUJBdUJtRGxILEdBQUssV0EzZ0MxRDNrQixVQTJnQ3FEMmtCLEdBQXNCO0tBQXJELElBQWJzSCxlQUFhLDBCQU5MRjtLQU9ULEdBQUEseUJBRENFLGVBcjVCVGpsQixNQTIzQkt0K0I7S0EyQmlDLE9BRDdCdWpEO0lBRU87a0JBRU5GO0tBZVQseUJBZlNBLFlBejVCVi9rQjtLQXc2QkMsT0FBQTtJQUNTO0lBZlA7S0FBQTtPQS9kSHQ1QjtpQkFvY0Uyd0M7O1NBSkczMUM7U0FtQkFxakQ7a0JBWTREQSxZQUFXbFY7VUFDdEQsSUFBYm9WLGVBWkpELFlBVzRERDtVQUV6RCxHQUFBLHlCQURDRTtXQUVDLE9BQUE7O1dBT2MsSUFBYkYsYUFyQk5DLFlBWUlDO3lCQVUyQnRIO1lBOXhCcENXLFlBOHhCb0NYOzBCQXR3QmR4dUIsR0FBSyxPQUFBLDJCQXN3QlN3dUIsTUF0d0JkeHVCLEdBQTZCO1lBQXJELDJCQTJ2QjhFMGdCO1lBM3ZCOUUsT0FsQkU0TyxhQXd4Qm9DZDtXQUEyQztXQUF4RSx5QkFESW9IO1dBQ0osT0FESUE7VUFFTTsyQkEzQ1RQO1dBc0N1QztZQUFBLE9BQUEsMEJBTnRDUyxjQTlnQ1R4STttQkFvaENrQzs7V0FDYztZQUFBLE9BQUEsMEJBUHZDd0ksY0E5Z0NUeEk7bUJBcWhDOEI7O1NBSVo7O0lBekJwQjtJQTZCQSxXQTlDSWlJLFNBQ0FFO0dBNkNZO1lBR2RNLFNBeGxDUXhqRCxHQXdsQ0d3RyxNQUFrQixJQXhsQ3JCMUUsUUF3bENHMEUsT0F4bENIeEcsT0FBQThCLFlBd2xDZ0M7Ozs7Ozs7O09BeGlDNUNxMkM7T0FBQUE7V0FxRUV6aEMsYUF6REV3QjtXQWtERjdFLGFBbERFNkU7T0FnSkFna0M7T0FpQkFFO09BdEVBdjNDO09BMnVCQTQ4QztPQVBBOXdCO09BU0Erd0I7T0FPQXRrQjtPQW9CQTBrQjtPQTZCQUc7T0FqeEJBM2pCO09BYUF1ZDtPQW5JQXZrQjtPQUVBNkY7V0E1T0Y4UixTQUFBM3RDO09BMnJCRXU5QztPQXJCQUQ7V0FobEJFcEo7T0FnbkJGc0o7T0F4ZEEzMEM7T0FDQTZuQjtPQUZBK29CO09BK1JBdUM7T0FOQUQ7T0FkQUY7T0FOQUQ7T0ErQkFLO09BS0FDO09BRUFDO09BdURBenBCO09BWUFvcUI7T0FjQUM7T0F1Q0FJO09BOUVBUDtPQUtBQztPQUNBdHNCO09BRUFubEI7T0FvVEF5ekM7T0EvUUE3QjtPQWtCQUM7T0FFQUM7O09Bd0pBeDVDO09BS0FRO09BSUFnNkM7T0EyQkF6NkM7T0FLQVE7T0FRQW02QztPQXFLQWE7T0FJQVE7T0FJQUM7T0FXQWw4QztPQUlBYztPQUVBczdDO09BOEJBSztPQXpCQWpSO09BSUE2UTtPQUtBQztPQVFBQztPQWNBOVE7T0FrR0FuUztPQXZCQThqQjtPQTRCQTVRO09BaUVBdndDO09BWEE2aEQ7T0FnQkFDO09BalZBeEM7T0F1QkFDO09BdENBTjtPQUNBQztPQVlBMzZDO09BanFCQXUxQztPQUNBbHNDO09BQ0FEO09BeENRa3BDO09Ba1JSK0U7T0F2ZEFqSTtPQUNBQztPQWd4Q0E2Tzs7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDaHdDc0JsMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbEIxQixTQUdZbTFDLGdCQUFBN2hELEdBQUEsT0FBQUEsS0FBZTtZQUFmOGhELG9CQUFBOWhELEdBQUFFLEdBQUFGLE9BQUFFLFlBQWU7WUFEdkI2aEQsTUFBQS9oRCxHQUFBLE9BQUFBLEtBQUs7WUFETGdpRCxjQUFBaGlELEdBQUEsT0FBQUEsS0FBYTtnQkFFTEEsR0FBQUUsR0FBQSxXQUFBRixNQUFBQSxNQUFBRSxHQUFlO0dBQWY7SUFBQSxVQUFBNGhEO0lBQUFHOzt1QkFBQSxTQUFlOzs7T0FBZko7O2dCQURSN2hELEdBQUFFLEdBQUEsV0FBQUYsTUFBQUUsR0FBQUYsTUFBSztHQUFMOztJQUFBa2lELDhCQUFBLFNBQUssbUJBQUxIO2dCQURBL2hELEdBQUFFLEdBQUEsV0FBQUEsR0FBQUYsTUFBQUEsTUFBYTtHQUFiOztJQUFBbWlEOzt1QkFBQSxTQUFhOzs7T0FBYkg7O1lBTUFJLGtCQUFnQmhrRDtJQUFJLHlDQUFKQTtHQUErQjtZQUMvQ2d5QixTQUFTaHlCLEdBQUksOEJBQUpBLE1BQW1DO1lBRTVDNEksVUFBVStxQixvQkFBZTN6Qjs7Y0FFckJpTSxNQUFNQyxHQUFJLE9BQUEsOEJBRldsTSxHQUVma00sR0FBNkI7S0FLbkM7TUFqQlkrM0M7UUFZWmg0QzttQkFLWXczQztXQUNUO1lBQWVseEMsTUFDYixrQ0FGT2t4QztZQUNNaHhDLFNBRUwsdUJBVlF6UztZQVFId1M7WUFBQUU7WUFBQTVSO1lBQUEwQjtvQkFBQW1RLFdBQUF1eEMsT0FBQUM7WUFBQSxPQUFBLHNCQUFBRCxPQUFBQztXQUFJOzs7b0JBQUo3MUM7b0JBQUFrRTtvQkFBQUc7b0JBQUFuUTtvQkFBQTFCO29CQUFBNFI7b0JBQUFEO29CQUFBRjtVQUU0Qjt1QjtLQUx6QztNQWZPNnhDLFlBWVpuNEMsTUFHWTtNQWZBbzRDLG9CQVlacDRDLE1BRW9CLHVCQUpkMG5CO0tBVk0sV0FBQTB3QixtQkFDaEJOO0tBRGdCLFdBQUFLLFdBRWhCTjtLQUNRLE9BQUEsV0FIUUcscUJBR1JKO0lBaUI0QztpQkFUYlM7Y0FYckNqbEIsZ0I7S0FHTTtNQURSa2xCLFlBU3VDRDtNQVZ2Q0Usb0JBVXVDRjtNQVIvQkcsc0JBUStCSDtNQVIvQmw4QztRQUFBLDRDQUFBcThDO01BSFpDLGdDQUdZdDhDO01BRFJFO1FBQUEsdURBQUFpOEM7TUFGSkksa0NBRUlyOEMsZUFGSm84QztNQUNJbDhDLFVBQUEsdUJBREU2MkIsVUFDRm1sQjtNQURKSSxrQ0FDSXA4QyxlQURKbThDO0tBQUEsV0FBQUM7O0lBV3FELE9BQUEsbUNBRHhCNWtEO0dBVTRCO1lBR3JENnhCLEtBQUs3eEIsR0FBSSw4QkFBSkEsTUFBK0I7WUFFcEM2a0QsU0FBUzdrRDtJQUNYLEdBbEJFZ3lCLFNBaUJTaHlCOzs7S0FDUTs7a0NBRFJBO0dBRXlCO1lBR2xDc0IsVUFBVWhCLGtCQUFZTjtJQUFZLElBQVM4a0QsUUFQM0NqekIsS0FPc0I3eEI7aUNBQVpNLFdBQWlDd2tEOztZQUc3QzltQyxZQUFZK21DLFVBQVpDO0lBQUEsT0FIRTFqRCxVQUdVeWpELHFCQUFaQztHQUEwRDtZQUV0RDlzQyxZQUFVeWIsYUFBWTN6QjtJQUFJLE9BekI1QjRJLFVBeUJZK3FCLDJCLFlBQVkzekI7R0FBa0M7R0FIMUMscUJBQ2xCZ2UsYUFFSTlGO1lBSUp0SixZQUFZOHlCLFVBQVp1akI7SUFBQSxPQVRFM2pELFVBU1VvZ0MscUJBQVp1akI7R0FBb0Q7WUFFaEQ1c0MsWUFBVXNiLGFBQVkzekI7SUFBSSxPQS9CNUI0SSxVQStCWStxQiwyQixZQUFZM3pCO0dBQWtDO0dBSDNDLG9CQUNqQjRPLGFBRUl5SjtZQUdGTyxVQUFXNVksR0FBMEIsT0FBMUJBLEVBQTJCO1lBQ3RDa2xELFdBQVlsbEQsR0FBMkIsT0FBM0JBLEVBQTRCO1lBRXhDNkU7SUFDRjtLQUVvQixNQUFBO0tBRFYsTUFBQTtJQURWLFdBQWtCO0dBR2pCO1lBR0NzZ0QsY0FBY25sRDtJQUNoQixHQS9DRWd5QixTQThDY2h5QjtLQUNoQixNQUFBO0lBQ1EsSUFBSjRCLElBQUksdUJBRlE1QjtJQUdoQix3QkFIZ0JBO0lBSWhCLGlDQUpnQkE7SUFBQUEsT0FLSztJQUNyQixPQUpJNEI7R0FJSDtZQUdDd2pELGFBQWFwbEQ7SUFDZixHQXhERWd5QixTQXVEYWh5Qjs7O0tBQ0k7O0lBQUEsT0FWakJtbEQsY0FTYW5sRDtHQUVBO1lBR2JxbEQsU0FBU3JsRCxHQUFJLE9BNURiZ3lCLFNBNERTaHlCLGFBZFRtbEQsY0FjU25sRCxJQUE2RDtZQUVsRXNsRCxLQUFLdGxEO0lBQ1gsR0EvREVneUIsU0E4RFNoeUI7S0FJSywwQkFDZCxPQUxJc2xELEtBQUt0bEQsR0FLSCxHQURRLE1BbkVkZ2tELGtCQStEU2hrRDs7O0lBRUMsVUFsQlZtbEQsY0FnQlNubEQ7SUFFQyxPQUFBO0dBR0g7WUFHUDJNLElBQUkzTSxHQUFFOEI7SUFDUix3QkFETTlCLE1BQUU4QjtJQUNSLE9BQUEsa0NBRE05QjtHQUVpQztZQUdyQzZ3QyxPQUFPN3dDLEdBQUdrTSxHQUFJLE9BTGRTLElBS08zTSxHQUFhLFdBQVZrTSxHQTVEVjJsQixLQTRETzd4QixLQUF5QjtZQUNoQ3VsRCxXQUFXdmxELEdBQUdrTSxHQUFJLE9BTmxCUyxJQU1XM00sR0FBYSxXQUFWa00sR0EzRGQyNEMsU0EyRFc3a0QsS0FBNkI7WUFDeEN3bEQsUUFBTXhsRCxHQUFJLHdDQUFKQSxNQUFxQjtZQUV2QnlsRCxJQUFJemxELEdBQUU4QjtJQUNaLEdBaEZFa3dCLFNBK0VRaHlCO0tBVFIyTSxJQVNRM00sR0FBRThCO0tBR1YsT0FBQTs7d0JBSUEsT0FQSTJqRCxJQUFJemxELEdBQUU4QixHQU9IO0lBRE8sVUFSZDBqRCxRQUVReGxEOztHQU9BO1lBR1IwbEQsZ0JBQWdCMWxEO0lBQ2xCO0tBQVcsUUFBQTtLQUFKaThDO0tBQUhyNkM7YUFDSXMwQjs7TUFFTixHQUFPLGtDQUhGK2xCO09BVUEsT0FBQTtNQUxHLFlBbkNSb0osU0E2QmdCcmxEO2tCQU9KLE9BTE5rMkI7VUFNR3pJOzBCQUVMLE9BUkV5SSxRQVFLO01BRE8sVUFBQSxrQ0FSYitsQixHQU9JeHVCOztLQUdLO0tBUkEsVUE3RmR1MkIsa0JBMEZnQmhrRDs7O0lBYUgsVUFYUGsyQjtJQVdSO0lBQUEsT0FaSXQwQjtHQWFIOzs7Ozs7OztPQWpGQ047OztPQWlCQXVEO09BdkNBbXRCO09BK0VJeXpCO09BVEo5NEM7T0FLQWtrQztPQUNBMFU7T0F4Q0Ezc0M7T0FDQXNzQztPQXRDQWxCO09BK0RJc0I7T0FGSkQ7T0FMQUQ7T0FzQkFJO09BOURBM3pCO09BRUFnekI7T0F3RUFhOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQzVGRTdnRCxPQUFPcUg7SUFDRyxJQUFSbVIsUUFBUTtJQUNaO0tBR0ssT0FITCxzREFGU25SO0lBT0Q7SUFIVyxVQUFBLGtDQUhmbVI7SUFDSixXQURJQTtHQU9IO1lBR0Nzb0MsZ0JBQWdCejVDO0lBQ04sSUFBUm1SLFFBQVE7SUFDWjtLQUdLLE9BSEwsc0RBRmtCblI7SUFPVjtJQUhXLFVBQUEsa0NBSGZtUjtJQUNKLFdBRElBO0dBT0g7WUFHQ3dpQixLQUFLNy9CLEdBQUksT0FBSkEsS0FBWTtZQUNqQjRsRCxTQUFTNWxEO0lBQUksT0FBQSx5Q0FBSkE7R0FBcUI7WUFHOUI2bEQsTUFBTTdsRCxHQUZJLGtDQUVKQSxVQUNSLE9BRFFBLEtBRUY7WUFHSjhsRCxVQUFVOWxEO0lBQUksSUFBQSxpQkFBQSxNQUxkNmxELE1BS1U3bEQ7SUFBSSxPQUFBO0dBQWtCO1lBQ2hDNHpCLFNBQU9obkI7SUFBSSxPQWhDWC9IOztjQWdDNkIsT0FBbEIsMENBQUorSDthQUE4QjtHQUFDO1lBRXRDa25CLEtBQUs5ekIsR0FBR2tNO0lBQ1YsT0FuQ0VySDs7MkJBb0NTK0gsR0FDVCxPQU5BazVDLFVBTVUsV0FIRjU1QyxHQUVDVSxJQUNNO2NBREYsVUFMYms1QyxVQUdLOWxEOzs7R0FHVztHQUlWO0lBQU44RTs7O2dCQURJOUUsR0FBR2tNO1FBQUksT0F4Q1hySDs7a0JBd0M2QixVQVQ3QmloRCxVQVNJOWxEO2tCQUFPLE9BQUEsOENBQUprTTtpQkFBdUM7T0FBQzs0Q0FOL0M0bkIsTUFGQUYsVUFTQTl1Qjs7Ozs7Ozs7Ozs7O1lBTUZpaEQsT0FBTS9sRCxHQUFFa007SUFBSSxPQUFVOzthQUFoQmxNO3NCQUFxQjRNO2NBQUssT0EvQzlCL0gsdUJBK0NnRCxPQUFsQixXQUF4QnFILEdBQW1CVSxHQUEwQjthQUFDO0dBQUM7WUFDdkRvNUMsVUFBVWhtRCxHQUFJLHlDQUFKQSxNQUF3QjtZQUNsQzZ6QixjQUFjN3pCO0lBQUksNENBQUpBO0dBQW1DO1lBQ2pENnhCLEtBQUs3eEIsR0FBSSw0Q0FBSkEsTUFBMEI7WUFDL0I2a0QsU0FBUzdrRDtJQUFJLElBQUEsaUJBQVcsTUFEeEI2eEIsS0FDUzd4QjtJQUFJLE9BQUE7R0FBNkI7Ozs7Ozs7O09BbkR4QzZFO09BV0E4Z0Q7T0FlQUU7T0FLQUM7T0FUQWptQjtPQUNBK2xCOzs7Ozs7Ozs7Ozs7T0F3QkZHO09BR0FsMEI7T0FDQWd6QjtPQUZBaHhCO09BREFteUI7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0N2REosU0FBQTFrRCxVQUFLKzlCO0lBQUw7S0FBYzRtQjs0Q0FBVDVtQjtLQUFTSyxVQUFBLGdDQUFBdW1CO0tBQWR4bUIsZ0NBQWNDO0lBQWQsV0FBQUQ7R0FBOEQ7WUFFMUQ1NkIsY0FBWSxXQUFVLGtDQUFpQjtZQUN2Q2c3QixLQUFLNy9CO2lCQUF5Qmd6QixNQUFRLE9BQUEsMkJBQWpDaHpCLE1BQXlCZ3pCLE1BQWtDO0lBQXZDLE9BQUE7R0FBd0M7WUFDakVrekIsT0FBT2xtRCxHQUFFNE07aUJBQWdEb21CLE1BQVEsT0FBcEQsa0NBQTRDQSxNQUFoRHBtQixHQUF3RTtJQUF4RCxVQUFBLDJCQUFsQjVNO0lBQTZDLE9BQUE7R0FBOEI7WUFFbEY0L0IsVUFBVTUvQixHQUFFNE07aUJBQ2FvbUIsTUFBUSxPQUFuQyxrQ0FBMkJBLE1BRGJwbUIsR0FDcUM7SUFBbkQsMkJBRFk1TTtzQ0FBQUE7R0FFTzs7Ozs7OztVQVJyQnNCLFdBRUl1RCxRQUVBcWhELFFBRUF0bUIsV0FIQUM7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDR0E4TSxjQUFjQyxZQUFXMWdDO0lBQTZCLFVBQUE7SUFBekIsT0FBQTthQUFXLDZDQUExQjBnQyxZQUFXMWdDO0dBQWlEO1lBRTFFNGdDLGtCQUFrQkYsWUFBVzFnQztJQUFpQyxVQUFBO0lBQTdCLE9BQUE7YUFBVyw2Q0FBMUIwZ0MsWUFBVzFnQztHQUFxRDtZQUNsRjZnQyxtQkFBbUJILFlBQVcxZ0M7SUFBa0MsVUFBQTtJQUE5QixPQUFBO2FBQVcsNkNBQTFCMGdDLFlBQVcxZ0M7R0FBc0Q7WUFFcEY4Z0MsdUJBQXVCSixZQUFXMWdDO0lBQ0YsVUFBQTtJQUFsQyxPQUFBO2FBQVcsNkNBRGMwZ0MsWUFBVzFnQztHQUNrQjtPQU10RDVLO1lBRUl1RCxPQUFPcUg7SUFBNEIsVUFBQTtJQUF4QixPQUFBLFdBQVcsNkNBQWZBO0dBQXFDO0dBTG5DLElBTVRpNkMsOEJBTlMsWUFHYjdrRCxXQUVJdUQsUUFDQXNoRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BZkZ4WjtPQUVBRztPQUNBQztPQUVBQzs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDUFc7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNFVDkwQixZQUFVMVYsTUFBS3hDLEdBQUVzQixXQUFVNEs7O0ssbUJBU2xCOztNQUNIOEI7MkJBVlcxTSxXQUFGdEI7dURBVVRnTzt5REFWSXhMOzs7OztJQUVWLFVBQUEsNkRBRjJCMEo7OztZQWdCM0JrNkMsY0FBWXBtRCxHQUFFa00sR0FBRW02QyxtQkFBa0JyNEI7OztNLG1CQVV6QjtNQUdnQztPQUZuQ2hnQjt3REFBQUE7T0FFbUMsTUFBQSwwQkFiUGdnQjs7Ozs7Ozs7TUFRckIsT0FBRSxXQVJEOWhCLEdBUUMsMEJBUm1COGhCLE9BQXRCaHVCO0tBUXNCO0tBTGxDO1lBQUE7Ozt1REFIZ0JxbUQ7O0dBbkJQLGdCQUdUbnVDLGFBZ0JBa3VDOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDcUVXOTNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbkJhO0lBbkMxQnZPO0lBQ0FrUDtJQUNBMHRCO0lBQ0F4SDtJQUNBUTtJQUNBYjtJQUNBaVI7SUFDQXpSO0lBQ0E1YTtJQUNBc2hCO0lBQ0FXO0lBQ0FqSjtJQUNBeVQ7SUFDQXpMO0lBQ0FFO0lBT0FpbkI7SUFHQXlFO0lBR0FDOzs7Ozs7SUFRMEI7Ozs7OztJQWFuQixJQU1NOXpDLFNBTk47SUFDbUI7SUFDQTtJQUNBO0lBQ0E7SUFDbkI7S0FDTUYsTUFETjtLQUNNQztLQUFBRTtLQUFBNVI7S0FBQTBCO2FBQUFtUSxXQUFBdzhCLE9BQUFDO0tBQUEsT0FBQSxzQkFBQUQsT0FBQUM7SUFBRzs7O01BQUg5Z0M7TUFBQWtFO01BQUFHO01BQUFuUTtNQUFBMUI7TUFBQTRSO01BQUFEO01BQUFGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXREYnhTO09BQ0FrUDtPQUNBMHRCO09BQ0F4SDtPQUNBUTtPQUNBYjtPQUNBaVI7T0FDQXpSO09BQ0E1YTtPQUNBc2hCO09BQ0FXO09BQ0FqSjtPQUNBeVQ7T0FDQXpMO09BQ0FFO09BT0FpbkI7T0FHQXlFO09BR0FDOzs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiaW5jbHVkZSBDb3JlLkNvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbigqIFthZnRlcl0gaXMgbGlrZSBbYWRkXSwgYnV0IGRlYWxzIG5pY2VseSB3aXRoIHRoZSBjYXNlIG9mIG92ZXJmbG93IGJ5IGluc3RlYWQgcmV0dXJuaW5nXG4gICBbbWF4X3ZhbHVlXS4gIFRpbWUtc291cmNlIGZ1bmN0aW9ucyB1c2UgW2FmdGVyXSB0byBhdm9pZCBpbW1lZGlhdGVseSBmaXJpbmcgZXZlbnRzIHRoYXRcbiAgIHNob3VsZCBuZXZlciBmaXJlLCBkdWUgdG8gdGhlIG92ZXJmbG93IGxlYWRpbmcgdG8gYSBuZWdhdGl2ZSB0aW1lIHRoYXQgYXBwZWFycyB0byBiZSBpblxuICAgdGhlIHBhc3QuICBXZSBkb24ndCBjaGVjayB1bmRlcmZsb3cgYmVjYXVzZSB0aGF0IGlzIHZlcnkgdW5saWtlbHksIHJlcXVpcmluZyBib3RoIGFcbiAgIG5lZ2F0aXZlIHRpbWUgYW5kIGEgbmVnYXRpdmUgc3Bhbi4gKilcbmxldCBhZnRlciB0IHNwYW4gPVxuICBsZXQgcmVzdWx0ID0gYWRkIHQgc3BhbiBpblxuICBpZiBTcGFuLiggPiApIHNwYW4gU3Bhbi56ZXJvICYmIHJlc3VsdCA8IHQgdGhlbiBtYXhfdmFsdWVfZm9yXzF1c19yb3VuZGluZyBlbHNlIHJlc3VsdFxuOztcbiIsIm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiBDb3JlXG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnlcbmluY2x1ZGUgQXN5bmNfa2VybmVsX2NvbmZpZy5QcmludF9kZWJ1Z19tZXNzYWdlc19mb3JcblxubGV0IGxvZyBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgZXByaW50ZlxuICAgIFwiJXNcXG4lIVwiXG4gICAgKFNleHAudG9fc3RyaW5nX2h1bVxuICAgICAgIChbJXNleHBfb2Y6IFNleHAudCAqIFRpbWVfbnMudCAqIHN0cmluZyAqIGFdXG4gICAgICAgICAgKCFBc3luY19rZXJuZWxfY29uZmlnLnRhc2tfaWQgKCksIFRpbWVfbnMubm93ICgpLCBtZXNzYWdlLCBhKSkpXG47O1xuXG5sZXQgbG9nX3N0cmluZyBtZXNzYWdlID0gbG9nIG1lc3NhZ2UgKCkgWyVzZXhwX29mOiB1bml0XVxuIiwibW9kdWxlIERlYnVnX2luX3RoaXNfZGlyZWN0b3J5ID0gRGVidWdcbm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiEgQ29yZVxuaW5jbHVkZSBJbnQuUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgRGVidWcgPSBEZWJ1Z19pbl90aGlzX2RpcmVjdG9yeVxubW9kdWxlIFRpbWVfbnMgPSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5XG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcblxubW9kdWxlIE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlID1cbiAgQXN5bmNfa2VybmVsX2NvbmZpZy5NYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuXG5sZXQgY29uY2F0ID0gU3RyaW5nLmNvbmNhdFxubGV0IGVwcmludCA9IENvcmUuRGVidWcuZXByaW50XG5sZXQgZXByaW50X3MgPSBDb3JlLkRlYnVnLmVwcmludF9zXG5sZXQgZXByaW50cyA9IENvcmUuRGVidWcuZXByaW50c1xubGV0IHByaW50X3Mgc2V4cCA9IHByaW50ZiBcIiVzXFxuJSFcIiAoc2V4cCB8PiBTZXhwLnRvX3N0cmluZ19odW0pXG5sZXQgc2VjID0gVGltZV9ucy5TcGFuLm9mX3NlY1xuXG4oKiBXZSBkb24ndCB3YW50IHRvIHVzZSB0aGVzZSBtb2R1bGVzIGluIEFzeW5jX2tlcm5lbCwgdG8gYXZvaWQgZGlmZmljdWx0aWVzIHdpdGhcbiAgIHVzaW5nIGl0IG9uIGpzX29mX29jYW1sLiAqKVxubW9kdWxlIFRocmVhZCA9IHN0cnVjdCBlbmRcbm1vZHVsZSBVbml4ID0gc3RydWN0IGVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTm9ybWFsXG4gIHwgTG93XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgbm9ybWFsID0gTm9ybWFsXG5sZXQgbG93ID0gTG93XG4iLCIoKiBUaGlzIGZpbGUgZGVmaW5lcyB0aGUgbXV0dWFsbHkgcmVjdXJzaXZlIHR5cGVzIGF0IHRoZSBoZWFydCBvZiBBc3luYy4gIFRoZSBmdW5jdGlvbnNcbiAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZXMgYXJlIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgZmlsZShzKSBmb3IgZWFjaCBtb2R1bGUuXG4gICBUaGlzIGZpbGUgc2hvdWxkIGRlZmluZSBvbmx5IHR5cGVzLCBub3QgZnVuY3Rpb25zLCBzaW5jZSBmdW5jdGlvbnMgZGVmaW5lZCBpbnNpZGUgdGhlXG4gICByZWN1cnNpdmUgbW9kdWxlcyBhcmUgbm90IGlubGluZWQuXG5cbiAgIElmIHlvdSBuZWVkIHRvIGFkZCBmdW5jdGlvbmFsaXR5IHRvIGEgbW9kdWxlIGJ1dCBkb2luZyBzbyB3b3VsZCBjcmVhdGUgYSBkZXBlbmRlbmN5XG4gICBjeWNsZSwgc3BsaXQgdGhlIGZpbGUgaW50byBwaWVjZXMgYXMgbmVlZGVkIHRvIGJyZWFrIHRoZSBjeWNsZSwgZS5nLiBzY2hlZHVsZXIwLm1sLFxuICAgc2NoZWR1bGVyMS5tbCwgc2NoZWR1bGVyLm1sLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIHJlYyBDZWxsIDogc2lnXG4gIHR5cGUgYW55ID1cbiAgICBbIGBFbXB0eVxuICAgIHwgYEVtcHR5X29uZV9oYW5kbGVyXG4gICAgfCBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICB8IGBGdWxsXG4gICAgfCBgSW5kaXJcbiAgICBdXG5cbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIDpcbiAgICAgICAgeyBtdXRhYmxlIHJ1biA6ICdhIC0+IHVuaXRcbiAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgOyBtdXRhYmxlIHByZXYgOiAnYSBIYW5kbGVyLnRcbiAgICAgICAgOyBtdXRhYmxlIG5leHQgOiAnYSBIYW5kbGVyLnRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSB0XG4gICAgfCBFbXB0eV9vbmVfaGFuZGxlciA6XG4gICAgICAgICgnYSAtPiB1bml0KSAqIEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX2hhbmRsZXIgXSkgdFxuICAgIHwgRW1wdHkgOiAoJ2EsIFs+IGBFbXB0eSBdKSB0XG4gICAgfCBGdWxsIDogJ2EgLT4gKCdhLCBbPiBgRnVsbCBdKSB0XG4gICAgfCBJbmRpciA6ICdhIEl2YXIudCAtPiAoJ2EsIFs+IGBJbmRpciBdKSB0XG5lbmQgPVxuICBDZWxsXG5cbmFuZCBIYW5kbGVyIDogc2lnXG4gIHR5cGUgJ2EgdCA9ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgQ2VsbC50XG5lbmQgPVxuICBIYW5kbGVyXG5cbmFuZCBJdmFyIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjZWxsIDogKCdhLCBDZWxsLmFueSkgQ2VsbC50IH1cblxuICBtb2R1bGUgSW1tdXRhYmxlIDogc2lnXG4gICAgdHlwZSAnYSB0ID0geyBjZWxsIDogKCdhLCBDZWxsLmFueSkgQ2VsbC50IH1cbiAgZW5kXG5lbmQgPVxuICBJdmFyXG5cbmFuZCBEZWZlcnJlZCA6IHNpZ1xuICB0eXBlICsnYSB0XG5lbmQgPVxuICBEZWZlcnJlZFxuXG5hbmQgRXhlY3V0aW9uX2NvbnRleHQgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICA7IHByaW9yaXR5IDogUHJpb3JpdHkudFxuICAgIDsgbG9jYWxfc3RvcmFnZSA6IFVuaXZfbWFwLnRcbiAgICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICAgIH1cbmVuZCA9XG4gIEV4ZWN1dGlvbl9jb250ZXh0XG5cbmFuZCBGb3J3YXJkaW5nIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgfCBEZXRhY2hlZFxuICAgIHwgUGFyZW50IG9mIE1vbml0b3IudFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4blxuZW5kID1cbiAgRm9yd2FyZGluZ1xuXG5hbmQgTW9uaXRvciA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbmFtZSA6IEluZm8udFxuICAgIDsgaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgb3B0aW9uXG4gICAgOyBpZCA6IGludFxuICAgIDsgbXV0YWJsZSBuZXh0X2Vycm9yIDogZXhuIEl2YXIudFxuICAgIDsgbXV0YWJsZSBoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyA6IChFeGVjdXRpb25fY29udGV4dC50ICogKGV4biAtPiB1bml0KSkgQmFnLnRcbiAgICA7IG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVGFpbC50IGxpc3RcbiAgICA7IG11dGFibGUgaGFzX3NlZW5fZXJyb3IgOiBib29sXG4gICAgOyBtdXRhYmxlIGZvcndhcmRpbmcgOiBGb3J3YXJkaW5nLnRcbiAgICB9XG5lbmQgPVxuICBNb25pdG9yXG5cbmFuZCBUYWlsIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBuZXh0IDogJ2EgU3RyZWFtLm5leHQgSXZhci50IH1cbmVuZCA9XG4gIFRhaWxcblxuYW5kIFN0cmVhbSA6IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBuZXh0IERlZmVycmVkLnRcblxuICBhbmQgJ2EgbmV4dCA9XG4gICAgfCBOaWxcbiAgICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5lbmQgPVxuICBTdHJlYW1cblxuKCogV2UgYXZvaWQgdXNpbmcgW21vZHVsZSByZWNdIHRvIGRlZmluZSBbQnZhcl0sIHNvIHRoYXQgW3RvX3JlcHJdIGFuZCBbb2ZfcmVwcl0gYXJlXG4gICBpbmxpbmVkLiAqKVxubW9kdWxlIEJ2YXIgOiBzaWdcbiAgdHlwZSAoJ2EsIC0ncGVybWlzc2lvbikgdFxuXG4gICgqKiBbcmVwcl0gZXhpc3RzIHNvIHRoYXQgd2UgbWF5IGhpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIGEgW0J2YXIudF0sIGFuZCB0aGVuIGFkZCBhXG4gICAgICBwaGFudG9tIHR5cGUgdG8gaXQgdXBzdHJlYW0uICBXaXRob3V0IHRoaXMsIHRoZSBwaGFudG9tIHR5cGUgdmFyaWFibGUgd291bGQgYWxsb3dcbiAgICAgIGZvciBhbnl0aGluZyB0byBiZSBjb2VyY2VkIGluIGFuZCBvdXQsIHNpbmNlIGl0IGlzIHVudXNlZC4gKilcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHZhbCBvZl9yZXByIDogJ2EgcmVwciAtPiAoJ2EsICdwZXJtaXNzaW9uKSB0XG4gIHZhbCB0b19yZXByIDogKCdhLCAncGVybWlzc2lvbikgdCAtPiAnYSByZXByXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHR5cGUgKCdhLCAncGVybWlzc2lvbikgdCA9ICdhIHJlcHJcblxuICBsZXQgdG9fcmVwciB0ID0gdFxuICBsZXQgb2ZfcmVwciB0ID0gdFxuZW5kXG5cbm1vZHVsZSByZWMgRXZlbnQgOiBzaWdcbiAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IEZpcmVkXG4gICAgICB8IEhhcHBlbmluZ1xuICAgICAgfCBTY2hlZHVsZWRcbiAgICAgIHwgVW5zY2hlZHVsZWRcbiAgZW5kXG5cbiAgbW9kdWxlIE9wdGlvbiA6IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50XG4gICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICB9XG5lbmQgPVxuICBFdmVudFxuXG5hbmQgRXh0ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgdCA9IFQgOiBFeGVjdXRpb25fY29udGV4dC50ICogKCdhIC0+IHVuaXQpICogJ2EgLT4gdFxuZW5kID1cbiAgRXh0ZXJuYWxfam9iXG5cbmFuZCBKb2IgOiBzaWdcbiAgdHlwZSBzbG90cyA9IChFeGVjdXRpb25fY29udGV4dC50LCBPYmoudCAtPiB1bml0LCBPYmoudCkgUG9vbC5TbG90cy50M1xuICB0eXBlIHQgPSBzbG90cyBQb29sLlBvaW50ZXIudFxuZW5kID1cbiAgSm9iXG5cbmFuZCBKb2Jfb3JfZXZlbnQgOiBzaWdcbiAgdHlwZSB0XG5lbmQgPVxuICBKb2Jfb3JfZXZlbnRcblxuYW5kIEpvYl9wb29sIDogc2lnXG4gIHR5cGUgdCA9IEpvYi5zbG90cyBQb29sLnRcbmVuZCA9XG4gIEpvYl9wb29sXG5cbmFuZCBKb2JfcXVldWUgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnNfbGVmdF90aGlzX2N5Y2xlIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnMgOiBPYmoudCBVbmlmb3JtX2FycmF5LnRcbiAgICA7IG11dGFibGUgbWFzayA6IGludFxuICAgIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICAgIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICB9XG5lbmQgPVxuICBKb2JfcXVldWVcblxuYW5kIEpvYnMgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgOyBtdXRhYmxlIGpvYl9wb29sIDogSm9iX3Bvb2wudFxuICAgIDsgbm9ybWFsIDogSm9iX3F1ZXVlLnRcbiAgICA7IGxvdyA6IEpvYl9xdWV1ZS50XG4gICAgfVxuZW5kID1cbiAgSm9ic1xuXG5hbmQgU2NoZWR1bGVyIDogc2lnXG5cbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgY2hlY2tfYWNjZXNzIDogKHVuaXQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGpvYl9wb29sIDogSm9iX3Bvb2wudFxuICAgIDsgbm9ybWFsX3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICAgIDsgbG93X3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICAgIDsgdmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyA6IFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci50IERlcXVlLnRcbiAgICA7IG11dGFibGUgbWFpbl9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgdW5jYXVnaHRfZXhuIDogKEV4bi50ICogU2V4cC50KSBvcHRpb25cbiAgICA7IG11dGFibGUgY3ljbGVfY291bnQgOiBpbnRcbiAgICA7IG11dGFibGUgY3ljbGVfc3RhcnQgOiBUaW1lX25zLnRcbiAgICA7IG11dGFibGUgaW5fY3ljbGUgOiBib29sXG4gICAgOyBtdXRhYmxlIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA6IEN5Y2xlX2hvb2sudCBsaXN0XG4gICAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgOiAoQ3ljbGVfaG9va19oYW5kbGUudCwgQ3ljbGVfaG9vay50KSBIYXNodGJsLnRcbiAgICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA6IEN5Y2xlX2hvb2sudCBsaXN0XG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIDogKEN5Y2xlX2hvb2tfaGFuZGxlLnQsIEN5Y2xlX2hvb2sudCkgSGFzaHRibC50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgICA7IG11dGFibGUgdG90YWxfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIHRpbWVfc291cmNlIDogcmVhZF93cml0ZSBUaW1lX3NvdXJjZS50MVxuICAgIDsgZXh0ZXJuYWxfam9icyA6IEV4dGVybmFsX2pvYi50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgICA7IG11dGFibGUgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgOiB1bml0IC0+IHVuaXRcbiAgICA7IG11dGFibGUgam9iX3F1ZXVlZF9ob29rIDogKFByaW9yaXR5LnQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSB5aWVsZCA6ICh1bml0LCByZWFkX3dyaXRlKSBCdmFyLnRcbiAgICA7IG11dGFibGUgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gICAgOyBtdXRhYmxlIGNoZWNrX2ludmFyaWFudHMgOiBib29sXG4gICAgOyBtdXRhYmxlIG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIDogTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUudFxuICAgIDsgbXV0YWJsZSByZWNvcmRfYmFja3RyYWNlcyA6IGJvb2xcbiAgICB9XG5lbmQgPVxuICBTY2hlZHVsZXJcblxuYW5kIEN5Y2xlX2hvb2sgOiBzaWdcbiAgdHlwZSB0ID0gdW5pdCAtPiB1bml0XG5lbmQgPVxuICBDeWNsZV9ob29rXG5cbmFuZCBDeWNsZV9ob29rX2hhbmRsZSA6IFVuaXF1ZV9pZC5JZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuYW5kIFRpbWVfc291cmNlX2lkIDogVW5pcXVlX2lkLklkID0gVW5pcXVlX2lkLkludDYzICgpXG5cbmFuZCBUaW1lX3NvdXJjZSA6IHNpZ1xuICB0eXBlIC0ncncgdDEgPVxuICAgIHsgaWQgOiBUaW1lX3NvdXJjZV9pZC50XG4gICAgOyBtdXRhYmxlIGFkdmFuY2VfZXJyb3JzIDogRXJyb3IudCBsaXN0XG4gICAgOyBtdXRhYmxlIGFtX2FkdmFuY2luZyA6IGJvb2xcbiAgICA7IGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC50XG4gICAgOyBtdXRhYmxlIGZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50XG4gICAgOyBtdXRhYmxlIG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udFxuICAgIDsgaGFuZGxlX2ZpcmVkIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnQgLT4gdW5pdFxuICAgIDsgaXNfd2FsbF9jbG9jayA6IGJvb2xcbiAgICA7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgfVxuZW5kID1cbiAgVGltZV9zb3VyY2VcblxuYW5kIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlciA6IHNpZ1xuICBtb2R1bGUgRXhlY19yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgIDsgZXhlYyA6IHVuaXQgLT4gRXhlY19yZXN1bHQudFxuICAgIH1cbmVuZCA9XG4gIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlclxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5tb25pdG9yXG5cbm1vZHVsZSBGb3J3YXJkaW5nID0gVHlwZXMuRm9yd2FyZGluZ1xuXG50eXBlIHQgPSBUeXBlcy5Nb25pdG9yLnQgPVxuICB7IG5hbWUgOiBJbmZvLnRcbiAgOyBoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCBvcHRpb25cbiAgOyBpZCA6IGludFxuICA7IG11dGFibGUgbmV4dF9lcnJvciA6IGV4biBUeXBlcy5JdmFyLnRcbiAgOyAoKiBbTW9uaXRvci5zZW5kX2V4bl0gc2NoZWR1bGVzIGEgam9iIGZvciBlYWNoIGVsZW1lbnQgb2YgW2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzXS4gKilcbiAgICBtdXRhYmxlIGhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIDogKFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgKiAoZXhuIC0+IHVuaXQpKSBCYWcudFxuICA7ICgqIFtNb25pdG9yLnNlbmRfZXhuXSBleHRlbmRzIGVhY2ggdGFpbCBpbiBbdGFpbHNfZm9yX2FsbF9lcnJvcnNdLiAqKVxuICAgIG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVHlwZXMuVGFpbC50IGxpc3RcbiAgOyBtdXRhYmxlIGhhc19zZWVuX2Vycm9yIDogYm9vbFxuICA7IG11dGFibGUgZm9yd2FyZGluZyA6IEZvcndhcmRpbmcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHNdXG5cbmxldCBkZXNjcmlwdGlvbiB0ID1cbiAgbWF0Y2ggdC5oZXJlIHdpdGhcbiAgfCBOb25lIC0+IFslc2V4cCAodC5uYW1lIDogSW5mby50KV1cbiAgfCBTb21lIGhlcmUgLT4gWyVzZXhwICh0Lm5hbWUgOiBJbmZvLnQpLCAoaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQpXVxuOztcblxubGV0IGRlc2NyaXB0aW9ucyA9XG4gIGxldCByZWMgbG9vcCB0IGFjID1cbiAgICBsZXQgYWMgPSBkZXNjcmlwdGlvbiB0IDo6IGFjIGluXG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IERldGFjaGVkIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPiBMaXN0LnJldiBhY1xuICAgIHwgUGFyZW50IHQgLT4gbG9vcCB0IGFjXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXVxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwIChkZXNjcmlwdGlvbnMgdCA6IFNleHAudCBsaXN0KV1cblxubGV0IG5leHRfaWQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcblxubGV0IGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSBwYXJlbnQgPVxuICBsZXQgaWQgPSBuZXh0X2lkICgpIGluXG4gIGxldCBuYW1lID1cbiAgICBtYXRjaCBpbmZvLCBuYW1lIHdpdGhcbiAgICB8IFNvbWUgaSwgTm9uZSAtPiBpXG4gICAgfCBTb21lIGksIFNvbWUgcyAtPiBJbmZvLnRhZyBpIH50YWc6c1xuICAgIHwgTm9uZSwgU29tZSBzIC0+IEluZm8ub2Zfc3RyaW5nIHNcbiAgICB8IE5vbmUsIE5vbmUgLT4gSW5mby5jcmVhdGUgXCJpZFwiIGlkIFslc2V4cF9vZjogaW50IFNleHBfaGlkZGVuX2luX3Rlc3QudF1cbiAgaW5cbiAgbGV0IHQgPVxuICAgIHsgbmFtZVxuICAgIDsgaGVyZVxuICAgIDsgZm9yd2FyZGluZyA9XG4gICAgICAgIChtYXRjaCBwYXJlbnQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IFJlcG9ydF91bmNhdWdodF9leG5cbiAgICAgICAgIHwgU29tZSBwYXJlbnQgLT4gUGFyZW50IHBhcmVudClcbiAgICA7IGlkXG4gICAgOyBuZXh0X2Vycm9yID0geyBjZWxsID0gRW1wdHkgfVxuICAgIDsgaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgPSBCYWcuY3JlYXRlICgpXG4gICAgOyB0YWlsc19mb3JfYWxsX2Vycm9ycyA9IFtdXG4gICAgOyBoYXNfc2Vlbl9lcnJvciA9IGZhbHNlXG4gICAgfVxuICBpblxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImNyZWF0ZWQgbW9uaXRvclwiIHQgWyVzZXhwX29mOiB0XTtcbiAgdFxuOztcblxubGV0IG1haW4gPSBjcmVhdGVfd2l0aF9wYXJlbnQgfm5hbWU6XCJtYWluXCIgTm9uZVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5cbnR5cGUgdCA9IFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgPVxuICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgOyBwcmlvcml0eSA6IFByaW9yaXR5LnRcbiAgOyBsb2NhbF9zdG9yYWdlIDogVW5pdl9tYXAudFxuICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBtYWluID1cbiAgeyBtb25pdG9yID0gTW9uaXRvci5tYWluXG4gIDsgcHJpb3JpdHkgPSBQcmlvcml0eS5ub3JtYWxcbiAgOyBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuZW1wdHlcbiAgOyBiYWNrdHJhY2VfaGlzdG9yeSA9IFtdXG4gIH1cbjs7XG5cbmxldCBjcmVhdGVfbGlrZSA/bW9uaXRvciA/cHJpb3JpdHkgP2xvY2FsX3N0b3JhZ2UgdCA9XG4gIGxldCBtb25pdG9yID0gT3B0aW9uLnZhbHVlIG1vbml0b3IgfmRlZmF1bHQ6dC5tb25pdG9yIGluXG4gIHsgbW9uaXRvclxuICA7IHByaW9yaXR5ID0gT3B0aW9uLnZhbHVlIHByaW9yaXR5IH5kZWZhdWx0OnQucHJpb3JpdHlcbiAgOyBsb2NhbF9zdG9yYWdlID0gT3B0aW9uLnZhbHVlIGxvY2FsX3N0b3JhZ2UgfmRlZmF1bHQ6dC5sb2NhbF9zdG9yYWdlXG4gIDsgYmFja3RyYWNlX2hpc3RvcnkgPSB0LmJhY2t0cmFjZV9oaXN0b3J5XG4gIH1cbjs7XG5cbmxldCBmaW5kX2xvY2FsIHQga2V5ID0gVW5pdl9tYXAuZmluZCB0LmxvY2FsX3N0b3JhZ2Uga2V5XG5cbmxldCB3aXRoX2xvY2FsIHQga2V5IGRhdGEgPVxuICB7IHQgd2l0aCBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuY2hhbmdlIHQubG9jYWxfc3RvcmFnZSBrZXkgfmY6KGZ1biBfIC0+IGRhdGEpIH1cbjs7XG5cbmxldCByZWNvcmRfYmFja3RyYWNlIHQgPVxuICB7IHQgd2l0aCBiYWNrdHJhY2VfaGlzdG9yeSA9IEJhY2t0cmFjZS5nZXQgKCkgOjogdC5iYWNrdHJhY2VfaGlzdG9yeSB9XG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFR5cGVzLkV4dGVybmFsX2pvYlxuXG5sZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCI8am9iPlwiXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gUG9vbFxuXG5sZXQgZHVtbXlfZSA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbmxldCBkdW1teV9mIDogT2JqLnQgLT4gdW5pdCA9IGlnbm9yZVxubGV0IGR1bW15X2EgOiBPYmoudCA9IE9iai5yZXByICgpXG5cbnR5cGUgc2xvdHMgPSAoRXhlY3V0aW9uX2NvbnRleHQudCwgT2JqLnQgLT4gdW5pdCwgKE9iai50W0BzZXhwLm9wYXF1ZV0pKSBTbG90cy50M1xuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSB0ID0gc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9IFBvb2wuaW52YXJpYW50IGlnbm9yZSB0XG5sZXQgY3JlYXRlICgpID0gY3JlYXRlIFNsb3RzLnQzIH5jYXBhY2l0eToxIH5kdW1teTooZHVtbXlfZSwgZHVtbXlfZiwgZHVtbXlfYSlcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBKb2JfcG9vbC5zbG90cyBQb29sLlBvaW50ZXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgRXZlbnQgPSBUeXBlcy5FdmVudFxubW9kdWxlIEpvYiA9IFR5cGVzLkpvYlxuaW5jbHVkZSBUeXBlcy5Kb2Jfb3JfZXZlbnRcblxuKCogVGhpcyByZWRlZmluaXRpb24gb2YgW0V2ZW50XSBpcyBoZXJlIHNvIHRoZSB0eXBlIGNoZWNrcyBhcmUgcmlnaHQgbmV4dCB0b1xuICAgW09iai5tYWdpY11zLiAqKVxubW9kdWxlIF8gOiBzaWcgZW5kID0gc3RydWN0XG4gIG9wZW4gVHlwZXNcbiAgb3BlbiBFdmVudFxuXG4gIHR5cGUgX3QgPSB0ID1cbiAgICB7ICgqIG11c3QgbmV2ZXIgYmUgaW1tZWRpYXRlICopXG4gICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbiAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICA7IG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgXyA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEVuc3VyZV9wcml2YXRlX2ludCAoTSA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBpbnRcbiAgICBlbmQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBfdCA9IE0udFxuICBlbmRcblxuICBpbmNsdWRlIEVuc3VyZV9wcml2YXRlX2ludCAoSm9iKVxuZW5kXG5cbmxldCBvZl9ldmVudCBldmVudCA6IHQgPSBPYmoubWFnaWMgKGV2ZW50IDogRXZlbnQudClcbmxldCBvZl9qb2Igam9iIDogdCA9IE9iai5tYWdpYyAoam9iIDogSm9iLnQpXG5sZXQgaXNfZXZlbnQgKHQgOiB0KSA9IE9iai5pc19ibG9jayAoT2JqLnJlcHIgdClcbmxldCBpc19qb2IgKHQgOiB0KSA9IE9iai5pc19pbnQgKE9iai5yZXByIHQpXG5cbm1vZHVsZSBNYXRjaCA9IHN0cnVjdFxuICB0eXBlIF8ga2luZCA9XG4gICAgfCBFdmVudCA6IEV2ZW50LnQga2luZFxuICAgIHwgSm9iIDogSm9iLnQga2luZFxuXG4gIHR5cGUgcGFja2VkID0gSyA6IF8ga2luZCAtPiBwYWNrZWQgW0BAdW5ib3hlZF1cblxuICBsZXQga2luZCB0ID0gaWYgaXNfZXZlbnQgdCB0aGVuIEsgRXZlbnQgZWxzZSBLIEpvYlxuICBsZXQgcHJvamVjdCAodHlwZSBhKSAoXyA6IGEga2luZCkgam9iX29yX2V2ZW50ID0gKE9iai5tYWdpYyA6IHQgLT4gYSkgam9iX29yX2V2ZW50XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUeXBlcy5TY2hlZHVsZXJcblxubGV0IGV2ZW50cyB0ID0gdC50aW1lX3NvdXJjZS5ldmVudHNcblxubGV0IHNldF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgKCogQXZvaWQgYSBjYW1sX21vZGlmeSBpbiBtb3N0IGNhc2VzLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGV4ZWN1dGlvbl9jb250ZXh0KVxuICB0aGVuIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCA8LSBleGVjdXRpb25fY29udGV4dFxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjBcblxubGV0IGR1bW15X2UgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG5sZXQgZHVtbXlfZiA6IE9iai50IC0+IHVuaXQgPSBpZ25vcmVcbmxldCBkdW1teV9hIDogT2JqLnQgPSBPYmoucmVwciAoKVxubGV0IHNsb3RzX3Blcl9lbHQgPSAzXG5cbm1vZHVsZSBBID0gVW5pZm9ybV9hcnJheVxuXG4oKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgc3BlY2lhbGl6ZWQgW0ZsYXRfcXVldWVdLCBkb25lIGZvciByZWFzb25zIG9mIHNwZWVkLiAqKVxudHlwZSB0ID0gVHlwZXMuSm9iX3F1ZXVlLnQgPVxuICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gIDsgbXV0YWJsZSBqb2JzX2xlZnRfdGhpc19jeWNsZSA6IGludFxuICA7ICgqIFtqb2JzXSBpcyBhbiBhcnJheSBvZiBsZW5ndGggW2NhcGFjaXR5IHQgKiBzbG90c19wZXJfZWx0XSwgd2hlcmUgZWFjaCBlbHQgaGFzIHRoZVxuICAgICAgIHRocmVlIGNvbXBvbmVudHMgb2YgYSBqb2IgKFtleGVjdXRpb25fY29udGV4dF0sIFtmXSwgW2FdKSBpbiBjb25zZWN1dGl2ZSBzcG90cyBpblxuICAgICAgIFtqb2JzXS4gIFtlbnF1ZXVlXSBkb3VibGVzIHRoZSBsZW5ndGggb2YgW2pvYnNdIGlmIFtqb2JzXSBpcyBmdWxsLiAgW2pvYnNdIG5ldmVyXG4gICAgICAgc2hyaW5rcy4gIFtqb2JzXSBpcyBzb21ld2hhdCBsaWtlIGEgW0NvcmUuUG9vbF0gc3BlY2lhbGl6ZWQgdG8gMy10dXBsZXM7IHdlXG4gICAgICAgZG9uJ3QgdXNlIFtQb29sXSBiZWNhdXNlIHRoYXQgaW1wbGVtZW50cyBhIHNldCwgd2hlcmUgW2pvYnNdIGlzIGEgcXVldWUuICopXG4gICAgbXV0YWJsZSBqb2JzIDogKE9iai50IEEudFtAc2V4cC5vcGFxdWVdKVxuICA7ICgqIFttYXNrXSBpcyBbY2FwYWNpdHkgdCAtIDFdLCBhbmQgaXMgdXNlZCBmb3IgcXVpY2tseSBjb21wdXRpbmcgW2kgbW9kIChjYXBhY2l0eVxuICAgICAgIHQpXSAqKVxuICAgIG11dGFibGUgbWFzayA6IGludFxuICA7ICgqIFtmcm9udF0gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBqb2IgaW4gdGhlIHF1ZXVlLiAgVGhlIGFycmF5IGluZGV4IG9mIHRoYXQgam9iJ3NcbiAgICAgICBleGVjdXRpb24gY29udGV4dCBpcyBbZnJvbnQgKiBzbG90c19wZXJfZWx0XS4gKilcbiAgICBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgb2Zmc2V0IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKiBzbG90c19wZXJfZWx0XG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bnVtX2pvYnNfcnVuOihjaGVjayAoZnVuIG51bV9qb2JzX3J1biAtPiBhc3NlcnQgKG51bV9qb2JzX3J1biA+PSAwKSkpXG4gICAgICB+am9ic19sZWZ0X3RoaXNfY3ljbGU6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnNfbGVmdF90aGlzX2N5Y2xlIC0+IGFzc2VydCAoam9ic19sZWZ0X3RoaXNfY3ljbGUgPj0gMCkpKVxuICAgICAgfmpvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnMgLT5cbiAgICAgICAgICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgICAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudFxuICAgICAgICAgICAgICAgKE9iai5vYmogKEEuZ2V0IGpvYnMgKG9mZnNldCB0IGkpKSA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpXG4gICAgICAgICAgIGRvbmUpKVxuICAgICAgfm1hc2s6XG4gICAgICAgIChjaGVjayAoZnVuIG1hc2sgLT5cbiAgICAgICAgICAgbGV0IGNhcGFjaXR5ID0gbWFzayArIDEgaW5cbiAgICAgICAgICAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gICAgICAgICAgIGFzc2VydCAoY2FwYWNpdHkgKiBzbG90c19wZXJfZWx0ID0gQS5sZW5ndGggdC5qb2JzKSkpXG4gICAgICB+ZnJvbnQ6XG4gICAgICAgIChjaGVjayAoZnVuIGZyb250IC0+XG4gICAgICAgICAgIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KSkpXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5IHQpKSkpXG47O1xuXG5sZXQgY3JlYXRlX2FycmF5IH5jYXBhY2l0eSA9IEEuY3JlYXRlX29ial9hcnJheSB+bGVuOihjYXBhY2l0eSAqIHNsb3RzX3Blcl9lbHQpXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgY2FwYWNpdHkgPSAxIGluXG4gIHsgbnVtX2pvYnNfcnVuID0gMFxuICA7IGpvYnNfbGVmdF90aGlzX2N5Y2xlID0gMFxuICA7IGpvYnMgPSBjcmVhdGVfYXJyYXkgfmNhcGFjaXR5XG4gIDsgbWFzayA9IGNhcGFjaXR5IC0gMVxuICA7IGZyb250ID0gMFxuICA7IGxlbmd0aCA9IDBcbiAgfVxuOztcblxubGV0IGNsZWFyIHQgPVxuICB0LmZyb250IDwtIDA7XG4gIHQubGVuZ3RoIDwtIDA7XG4gIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPC0gMFxuOztcblxubGV0IGdyb3cgdCA9XG4gIGxldCBvbGRfY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGxldCBuZXdfY2FwYWNpdHkgPSBvbGRfY2FwYWNpdHkgKiAyIGluXG4gIGxldCBvbGRfam9icyA9IHQuam9icyBpblxuICBsZXQgb2xkX2Zyb250ID0gdC5mcm9udCBpblxuICBsZXQgbGVuMSA9IEludC5taW4gdC5sZW5ndGggKG9sZF9jYXBhY2l0eSAtIG9sZF9mcm9udCkgKiBzbG90c19wZXJfZWx0IGluXG4gIGxldCBsZW4yID0gKHQubGVuZ3RoICogc2xvdHNfcGVyX2VsdCkgLSBsZW4xIGluXG4gIGxldCBuZXdfam9icyA9IGNyZWF0ZV9hcnJheSB+Y2FwYWNpdHk6bmV3X2NhcGFjaXR5IGluXG4gIEEuYmxpdFxuICAgIH5sZW46bGVuMVxuICAgIH5zcmM6b2xkX2pvYnNcbiAgICB+c3JjX3Bvczoob2xkX2Zyb250ICogc2xvdHNfcGVyX2VsdClcbiAgICB+ZHN0Om5ld19qb2JzXG4gICAgfmRzdF9wb3M6MDtcbiAgQS5ibGl0IH5sZW46bGVuMiB+c3JjOm9sZF9qb2JzIH5zcmNfcG9zOjAgfmRzdDpuZXdfam9icyB+ZHN0X3BvczpsZW4xO1xuICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgdC5qb2JzIDwtIG5ld19qb2JzO1xuICB0LmZyb250IDwtIDBcbjs7XG5cbmxldCBzZXQgKHR5cGUgYSkgdCBpIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGxldCBvZmZzZXQgPSBvZmZzZXQgdCBpIGluXG4gIEEudW5zYWZlX3NldCB0LmpvYnMgb2Zmc2V0IChPYmoucmVwciAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSk7XG4gIEEudW5zYWZlX3NldCB0LmpvYnMgKG9mZnNldCArIDEpIChPYmoucmVwciAoZiA6IGEgLT4gdW5pdCkpO1xuICBBLnVuc2FmZV9zZXQgdC5qb2JzIChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgKGEgOiBhKSlcbjs7XG5cbmxldCBlbnF1ZXVlIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gZ3JvdyB0O1xuICBzZXQgdCB0Lmxlbmd0aCBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiSm9icy5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgZ290IG5lZ2F0aXZlIG51bWJlclwiIChuIDogaW50KSAodCA6IHQpXTtcbiAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSBuXG47O1xuXG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gdC5sZW5ndGggPiAwICYmIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPiAwXG5cbmxldCBydW5fam9iIHQgKHNjaGVkdWxlciA6IFNjaGVkdWxlci50KSBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICB0Lm51bV9qb2JzX3J1biA8LSB0Lm51bV9qb2JzX3J1biArIDE7XG4gIFNjaGVkdWxlci5zZXRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0O1xuICBmIGFcbjs7XG5cbmxldCBydW5fZXh0ZXJuYWxfam9icyB0IChzY2hlZHVsZXIgOiBTY2hlZHVsZXIudCkgPVxuICBsZXQgZXh0ZXJuYWxfam9icyA9IHNjaGVkdWxlci5leHRlcm5hbF9qb2JzIGluXG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCBleHRlcm5hbF9qb2JzID4gMCBkb1xuICAgIGxldCAoRXh0ZXJuYWxfam9iLlQgKGV4ZWN1dGlvbl9jb250ZXh0LCBmLCBhKSkgPVxuICAgICAgVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gZXh0ZXJuYWxfam9ic1xuICAgIGluXG4gICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGFcbiAgZG9uZVxuOztcblxubGV0IHJ1bl9qb2JzICh0eXBlIGEpIHQgc2NoZWR1bGVyID1cbiAgKCogV2UgZG8gdGhlIFt0cnktd2l0aF0gb3V0c2lkZSBvZiB0aGUgW3doaWxlXSBiZWNhdXNlIGl0IGlzIGNoZWFwZXIgdGhhbiBkb2luZyBhXG4gICAgIFt0cnktd2l0aF0gZm9yIGVhY2ggam9iLiAqKVxuICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGJlZm9yZSBlbnRlcmluZyB0aGUgbG9vcCwgc2luY2UgaXQgbWlnaHQgZW5xdWV1ZSBhIGpvYixcbiAgICAgY2hhbmdpbmcgW3QubGVuZ3RoXS4gKilcbiAgdHJ5XG4gICAgcnVuX2V4dGVybmFsX2pvYnMgdCBzY2hlZHVsZXI7XG4gICAgd2hpbGUgY2FuX3J1bl9hX2pvYiB0IGRvXG4gICAgICBsZXQgdGhpc19qb2IgPSBvZmZzZXQgdCAwIGluXG4gICAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50ID1cbiAgICAgICAgT2JqLm9iaiAoQS51bnNhZmVfZ2V0IHQuam9icyB0aGlzX2pvYilcbiAgICAgIGluXG4gICAgICBsZXQgZiA6IGEgLT4gdW5pdCA9IE9iai5vYmogKEEudW5zYWZlX2dldCB0LmpvYnMgKHRoaXNfam9iICsgMSkpIGluXG4gICAgICBsZXQgYSA6IGEgPSBPYmoub2JqIChBLnVuc2FmZV9nZXQgdC5qb2JzICh0aGlzX2pvYiArIDIpKSBpblxuICAgICAgKCogV2UgY2xlYXIgb3V0IHRoZSBqb2IgcmlnaHQgbm93IHNvIHRoYXQgaXQgaXNuJ3QgbGl2ZSBhdCB0aGUgbmV4dCBtaW5vclxuICAgICAgICAgY29sbGVjdGlvbi4gIFdlIHRyaWVkIG5vdCBkb2luZyB0aGlzIGFuZCBzYXcgc2lnbmlmaWNhbnQgKDE1JSBvciBzbykgcGVyZm9ybWFuY2VcbiAgICAgICAgIGhpdHMgZHVlIHRvIHNwdXJpb3VzIHByb21vdGlvbi4gKilcbiAgICAgIHNldCB0IDAgZHVtbXlfZSBkdW1teV9mIGR1bW15X2E7XG4gICAgICB0LmZyb250IDwtICh0LmZyb250ICsgMSkgbGFuZCB0Lm1hc2s7XG4gICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgICB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIDwtIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgLSAxO1xuICAgICAgKCogSXQgaXMgT0sgaWYgW3J1bl9qb2JdIG9yIFtydW5fZXh0ZXJuYWxfam9ic10gcmFpc2VzLCBpbiB3aGljaCBjYXNlIHRoZSBleG4gaXNcbiAgICAgICAgIGhhbmRsZWQgYnkgdGhlIG91dGVyIHRyeS13aXRoLiAgVGhlIG9ubHkgc2lkZSBlZmZlY3RzIHdlIGhhdmUgZG9uZSBhcmUgdG8gdGFrZVxuICAgICAgICAgdGhlIGpvYiBvdXQgb2YgdGhlIHF1ZXVlIGFuZCBkZWNyZW1lbnQgW2pvYnNfbGVmdF90aGlzX2N5Y2xlXS4gIFtydW5fam9iXSBvclxuICAgICAgICAgW3J1bl9leHRlcm5hbF9qb2JzXSBtYXkgc2lkZSBlZmZlY3QgW3RdLCBlaXRoZXIgYnkgZW5xdWV1ZWluZyBqb2JzLCBvciBieVxuICAgICAgICAgY2xlYXJpbmcgW3RdLiAqKVxuICAgICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGF0IGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBbd2hpbGVdIGxvb3AsIGZvciBmYWlybmVzcy4gKilcbiAgICAgIHJ1bl9leHRlcm5hbF9qb2JzIHQgc2NoZWR1bGVyXG4gICAgZG9uZTtcbiAgICBPayAoKVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgKCogV2UgY2FsbCBbRXhuLmJhY2t0cmFjZV0gaW1tZWRpYXRlbHkgYWZ0ZXIgY2F0Y2hpbmcgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiwgdG9cbiAgICAgICBlbnN1cmUgdGhlcmUgaXMgbm8gaW50ZXJ2ZW5pbmcgY29kZSB0aGF0IGludGVyZmVyZXMgd2l0aCB0aGUgZ2xvYmFsIGJhY2t0cmFjZVxuICAgICAgIHN0YXRlLiAqKVxuICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgRXJyb3IgKGV4biwgYmFja3RyYWNlKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVGltZV9ucyA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfbnNcblxuICBleHRlcm5hbCBmb3JtYXQgOiBmbG9hdCAtPiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjb3JlX3RpbWVfbnNfZm9ybWF0XCJcblxuICAoKiBXZSB1c2UgYSBtb3JlIHBsZWFzYW50IGZvcm1hdCB0aGFuIFtDb3JlLlRpbWVfbnMuc2V4cF9vZl90XSxcbiAgICAgd2hpY2ggaGFzIHRvIGJlIG1lc3NpZXIgZm9yIHJvdW5kIHRyaXBwYWJpbGl0eS4gKilcbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBbJXNleHBcbiAgICAgIChmb3JtYXQgKHQgfD4gdG9fc3Bhbl9zaW5jZV9lcG9jaCB8PiBTcGFuLnRvX3NlYykgXCIlWS0lbS0lZFQlSDolTTolUyV6XCIgOiBzdHJpbmcpXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWluZ193aGVlbC5BbGFybVxuXG4gIGxldCBpc19udWxsIHQgPSBwaHlzX2VxdWFsIHQgKG51bGwgKCkpXG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA9IFRpbWluZ193aGVlbC5BbGFybV9wcmVjaXNpb25cblxubGV0IGRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZyA9XG4gICgqIDEvOHRoIG9mIGEgbWlsbGlzZWNvbmQgYWxhcm1fcHJlY2lzaW9uIHNlZW1zIHN1ZmZpY2llbnQgdG8gYXZvaWQgaGF2aW5nIG1hbnkgYWxhcm1zXG4gICAgIGluIHRoZSBzYW1lIGludGVydmFsLCB3aGljaCBhdm9pZHMgcXVhZHJhdGljIGluc2VydGlvbiBzb3J0IHdoZW4gZmlyaW5nIGFsYXJtcy4gIEFuZFxuICAgICB0aGUgbGV2ZWwgYml0cyBnaXZlIHVzIGxldmVscyBvZiA+MXMsID4xbSwgPjFoLCA+MWQuICBTZWUgdGVzdCBpblxuICAgICBbLi4vdGVzdC90ZXN0X3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sXS4gKilcbiAgVGltaW5nX3doZWVsLkNvbmZpZy5jcmVhdGVcbiAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi4oZGl2IGFib3V0X29uZV9taWxsaXNlY29uZCB+cG93MjozKVxuICAgIH5sZXZlbF9iaXRzOihUaW1pbmdfd2hlZWwuTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFsgMTM7IDY7IDY7IDUgXSlcbiAgICAoKVxuOztcblxudHlwZSBjYWxsYmFjayA9IHVuaXQgLT4gdW5pdFxuXG5tb2R1bGUgSWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZFxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gICAgbW9kdWxlIFN0YXR1cyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gVHlwZXMuRXZlbnQuU3RhdHVzLnQgPVxuICAgICAgICB8IEZpcmVkICgqIGluIFtmaXJlZF9ldmVudHNdLCByZWFkeSB0byBydW4gKilcbiAgICAgICAgfCBIYXBwZW5pbmcgKCogY3VycmVudGx5IHJ1bm5pbmcgdGhlIGNhbGxiYWNrICopXG4gICAgICAgIHwgU2NoZWR1bGVkICgqIGluIHRoZSB0aW1pbmcgd2hlZWwgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCAoKiBub3QgaW4gdGltaW5nIHdoZWVsIG9yIFtmaXJlZF9ldmVudHNdICopXG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgICAgbGV0IHRyYW5zaXRpb25faXNfYWxsb3dlZCB+ZnJvbSB+dG9fID1cbiAgICAgICAgbWF0Y2ggZnJvbSwgdG9fIHdpdGhcbiAgICAgICAgfCBGaXJlZCwgSGFwcGVuaW5nICgqIHN0YXJ0ZWQgcnVubmluZyBjYWxsYmFjayAqKVxuICAgICAgICB8IEZpcmVkLCBVbnNjaGVkdWxlZCAoKiBhYm9ydGVkICopXG4gICAgICAgICgqIFtyZXNjaGVkdWxlXypdIGdvZXMgdGhyb3VnaCBhbiBpbnRlcm1lZGlhdGUgW0ZpcmVkLCBVbnNjaGVkdWxlZF0gc3RhdGUsXG4gICAgICAgICAgIHNvIHdlIG5ldmVyIHRyYW5zaXRpb24gZnJvbSBbRmlyZWRdIGRpcmVjdGx5IHRvIFtTY2hlZHVsZWRdLiAqKVxuICAgICAgICB8IEhhcHBlbmluZywgU2NoZWR1bGVkICgqIGZvciByZXBlYXRpbmcgZXZlbnRzICopXG4gICAgICAgIHwgSGFwcGVuaW5nLCBVbnNjaGVkdWxlZCAoKiBldmVudCBjYWxsYmFjayBmaW5pc2hlZCAqKVxuICAgICAgICB8IFNjaGVkdWxlZCwgRmlyZWQgKCogbW92ZWQgZnJvbSB0aW1pbmcgd2hlZWwgdG8gW2ZpcmVkX2V2ZW50c10gKilcbiAgICAgICAgfCBTY2hlZHVsZWQsIFVuc2NoZWR1bGVkICgqIGFib3J0ZWQgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCwgRmlyZWQgKCogZXZlbnQgc2NoZWR1bGVkIGluIHRoZSBwYXN0ICopXG4gICAgICAgIHwgVW5zY2hlZHVsZWQsIFNjaGVkdWxlZCAoKiBldmVudCBzY2hlZHVsZWQgaW4gdGhlIGZ1dHVyZSAqKSAtPiB0cnVlXG4gICAgICAgIHwgKEZpcmVkIHwgSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQpLCBfIC0+IGZhbHNlXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgdHlwZSBldmVudCA9IFR5cGVzLkV2ZW50LnRcblxuICAgIGxldCBzZXhwX29mX2V2ZW50XG4gICAgICAgICAgKHsgYWxhcm0gPSBfXG4gICAgICAgICAgIDsgYXRcbiAgICAgICAgICAgOyBjYWxsYmFjayA9IF9cbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IF9cbiAgICAgICAgICAgOyBpbnRlcnZhbFxuICAgICAgICAgICA7IG5leHRfZmlyZWQgPSBfXG4gICAgICAgICAgIDsgcHJldl9maXJlZCA9IF9cbiAgICAgICAgICAgOyBzdGF0dXNcbiAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgZXZlbnQpXG4gICAgICA9XG4gICAgICBbJXNleHBcbiAgICAgICAgeyBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgICA7IGF0IDogVGltZV9ucy50XG4gICAgICAgIDsgaW50ZXJ2YWwgOiAoVGltZV9ucy5TcGFuLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pXG4gICAgICAgIH1dXG4gICAgOztcblxuICAgIG1vZHVsZSBPcHRpb24gPSBzdHJ1Y3RcbiAgICAgICgqIFRoaXMgcmVkZWZpbml0aW9uIG9mIFtFdmVudF0gaXMgaGVyZSBzbyB0aGUgdHlwZSBjaGVja3MgYXJlIHJpZ2h0IG5leHRcbiAgICAgICAgIHRvIFtPYmoubWFnaWNdcy4gKilcbiAgICAgIG1vZHVsZSBFdmVudF9pc19ibG9jayA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgb3BlbiBUeXBlc1xuICAgICAgICBvcGVuIEV2ZW50XG5cbiAgICAgICAgdHlwZSBfdCA9IHQgPVxuICAgICAgICAgIHsgKCogbXVzdCBuZXZlciBiZSBpbW1lZGlhdGUgKilcbiAgICAgICAgICAgIG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwuQWxhcm0udFxuICAgICAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgICAgIDsgY2FsbGJhY2sgOiB1bml0IC0+IHVuaXRcbiAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgICAgIDsgbXV0YWJsZSBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50IG9wdGlvblxuICAgICAgICAgIDsgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgICAgICA7IG11dGFibGUgcHJldl9maXJlZCA6IE9wdGlvbi50XG4gICAgICAgICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50XG4gICAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50Lk9wdGlvbi50XG5cbiAgICAgICgqIFVzaW5nIGFuIGltbWVkaWF0ZSByYXRoZXIgdGhhbiBhIHN0YXRpY2FsbHktYWxsb2NhdGVkIHJlY29yZCBoZXJlIHNlZW1zIHRvXG4gICAgICAgICBpbXByb3ZlIHBlcmZvcm1hbmNlIG5vdGljZWFibHkgKFsuLi9iZW5jaC9iaW4vYmVuY2hfdGltZV9zb3VyY2UuZXhlXSBiZW5jaG1hcmtcbiAgICAgICAgIGlzIGZhc3RlciBieSB+MTBucyBwZXIgYWxhcm0pLCBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgYXZvaWRzIHRoZSBleHBlbnNpdmVcbiAgICAgICAgIHBhcnRzIG9mIGNhbWxfbW9kaWZ5LiAqKVxuICAgICAgbGV0IG5vbmUgPSAoT2JqLm1hZ2ljIE5vbmUgOiB0KSAoKiBhbiBhcmJpdHJhcnkgaW1tZWRpYXRlICopXG5cbiAgICAgIGxldCBzb21lID0gKE9iai5tYWdpYyA6IFR5cGVzLkV2ZW50LnQgLT4gdClcbiAgICAgIGxldCBpc19ub25lIHQgPSBwaHlzX2VxdWFsIHQgbm9uZVxuICAgICAgbGV0IGlzX3NvbWUgdCA9IG5vdCAoaXNfbm9uZSB0KVxuICAgICAgbGV0IGZpcnN0X3NvbWUgdDEgdDIgPSBpZiBpc19zb21lIHQxIHRoZW4gdDEgZWxzZSB0MlxuXG4gICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgIG1vZHVsZSBPcHRpb25hbF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgICAgICBsZXQgaXNfbm9uZSA9IGlzX25vbmVcbiAgICAgICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gKE9iai5tYWdpYyA6IHQgLT4gVHlwZXMuRXZlbnQudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgb3BlbiBPcHRpb25hbF9zeW50YXhcblxuICAgICAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICAgICAgbWF0Y2glb3B0aW9uYWwgdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBbJXNleHAgKCldXG4gICAgICAgIHwgU29tZSBldmVudCAtPiBbJXNleHAgKGV2ZW50IDogZXZlbnQpXVxuICAgICAgOztcblxuICAgICAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGRlZmF1bHRcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgdmFsdWVfZXhuIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHJhaXNlX3MgWyVzZXhwIFwiW1N5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50Lk9wdGlvbi52YWx1ZV9leG4gTm9uZV1cIl1cbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fb3B0aW9uIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IFNvbWUgZXZlbnRcbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gc29tZSBldmVudFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50LnQgPVxuICAgICAgeyAoKiBbYWxhcm1dIGlzIG5vbi1udWxsIGlmZiB0aGUgZXZlbnQgaXMgaW4gdGhlIHRpbWluZyB3aGVlbC4gKilcbiAgICAgICAgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IEFsYXJtLnRcbiAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIDsgKCogW2ludGVydmFsXSBpcyB0aGUgcGVyaW9kIGZvciB0aGUgcGVyaW9kaWMgZXZlbnRzLiAqKVxuICAgICAgICBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgICA7ICgqIFtuZXh0X2ZpcmVkXSBhbmQgW3ByZXZfZmlyZWRdIGNyZWF0ZSBhIGRvdWJseS1saW5rZWQgKG5vbi1jaXJjdWxhcikgbGlzdCBvZlxuICAgICAgICAgICBmaXJlZCBldmVudHMsIGxpbmtlZCB2aWEgdGhlc2UgZmllbGRzLiBBbiBldmVudCBpcyBhZGRlZCB0byB0aGUgbGlzdCB3aGVuXG4gICAgICAgICAgIGl0IGZpcmVzLCBlaXRoZXIgYmVjYXVzZSBpdCBpcyBhZGRlZCB3aXRoIGEgdGltZSBpbiB0aGUgcGFzdCwgb3JcbiAgICAgICAgICAgYmVjYXVzZSB0aW1lIGFkdmFuY2VzLiBbYWR2YW5jZV9ieV9hbGFybXNdIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50c1xuICAgICAgICAgICBpbiBbbmV4dF9maXJlZF0gYW5kIHJ1bnMgdGhlbSwgZW1wdHlpbmcgdGhlIGxpc3QuIFtub25lXSBpcyB1c2VkIHRvXG4gICAgICAgICAgIGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0IG9mIGZpcmVkIGV2ZW50cy4gKilcbiAgICAgICAgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgIGxldCBzZXhwX29mX3QgPSBbJXNleHBfb2Y6IGV2ZW50XVxuXG4gICAgbGV0IGludmFyaWFudCB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgICB+YWxhcm06XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAgICAgKEFsYXJtLmlzX251bGwgYWxhcm0pXG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBGaXJlZCB8IEhhcHBlbmluZyB8IFVuc2NoZWR1bGVkIC0+IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfCBTY2hlZHVsZWQgLT4gZmFsc2UpKSlcbiAgICAgICAgICB+YXQ6aWdub3JlXG4gICAgICAgICAgfmNhbGxiYWNrOmlnbm9yZVxuICAgICAgICAgIH5leGVjdXRpb25fY29udGV4dDppZ25vcmVcbiAgICAgICAgICB+aW50ZXJ2YWw6aWdub3JlXG4gICAgICAgICAgfm5leHRfZmlyZWQ6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbCAobmV4dF9maXJlZCA6IE9wdGlvbi50KSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgKCogW25leHRfZmlyZWRdIGNhbiBiZSBbTm9uZV0gZXZlbiBpZiB0aGUgZXZlbnQgc3RhdHVzIGlzIEZpcmVkLCBhc3N1bWluZ1xuICAgICAgICAgICAgICAgICAgICBpdCdzIGF0IHRoZSBlbmQgb2YgdGhlIGZpcmVkIGV2ZW50cyBsaXN0ICopXG4gICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dF9maXJlZCAtPlxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBTdGF0dXMudF0gdC5zdGF0dXMgfmV4cGVjdDpGaXJlZDtcbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChPcHRpb24uc29tZSB0KSBuZXh0X2ZpcmVkLnByZXZfZmlyZWQpKSlcbiAgICAgICAgICB+cHJldl9maXJlZDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHByZXZfZmlyZWQgLT5cbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsIChwcmV2X2ZpcmVkIDogT3B0aW9uLnQpIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAoKiBbcHJldl9maXJlZF0gY2FuIGJlIFtOb25lXSBldmVuIGlmIHRoZSBldmVudCBzdGF0dXMgaXMgRmlyZWQsIGFzc3VtaW5nXG4gICAgICAgICAgICAgICAgICAgIGl0J3MgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlyZWQgZXZlbnRzIGxpc3QgKilcbiAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgIHwgU29tZSBwcmV2X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFN0YXR1cy50XSB0LnN0YXR1cyB+ZXhwZWN0OkZpcmVkO1xuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgKE9wdGlvbi5zb21lIHQpIHByZXZfZmlyZWQubmV4dF9maXJlZCkpKVxuICAgICAgICAgIH5zdGF0dXM6aWdub3JlKVxuICAgIDs7XG5cbiAgICBsZXQgc2V0X3N0YXR1cyB0IHRvXyA9XG4gICAgICBsZXQgZnJvbSA9IHQuc3RhdHVzIGluXG4gICAgICBpZiBub3QgKFN0YXR1cy50cmFuc2l0aW9uX2lzX2FsbG93ZWQgfmZyb20gfnRvXylcbiAgICAgIHRoZW5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgWyVoZXJlXVxuICAgICAgICAgICAgICBcImJ1ZyAtLSBzZXRfc3RhdHVzIHRyYW5zaXRpb24gbm90IGFsbG93ZWRcIlxuICAgICAgICAgICAgICAoZnJvbSA6IFN0YXR1cy50KVxuICAgICAgICAgICAgICAodG9fIDogU3RhdHVzLnQpXG4gICAgICAgICAgICAgIH5ldmVudDoodCA6IHQpXTtcbiAgICAgIHQuc3RhdHVzIDwtIHRvX1xuICAgIDs7XG5cbiAgICBsZXQgc2V0X3N0YXR1c19pZiB+aXMgdCB0b18gPSBpZiBTdGF0dXMuZXF1YWwgaXMgdC5zdGF0dXMgdGhlbiBzZXRfc3RhdHVzIHQgdG9fXG4gICAgbGV0IHNjaGVkdWxlZF9hdCA9IGF0XG4gIGVuZFxuXG4gIG1vZHVsZSBKb2Jfb3JfZXZlbnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEpvYl9vcl9ldmVudFxuXG4gICAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICAgIGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICAgICAgbGV0IChLIGspID0ga2luZCB0IGluXG4gICAgICBtYXRjaCBrLCBwcm9qZWN0IGsgdCB3aXRoXG4gICAgICB8IEV2ZW50LCBldmVudCAtPiBbJXNleHAgKGV2ZW50IDogRXZlbnQudCldXG4gICAgICB8IEpvYiwgXyAtPlxuICAgICAgICAoKiBXZSBkb24ndCBkaXNwbGF5IHRoZSBbSm9iLnRdcyBpbiBbZXZlbnRzXSBiZWNhdXNlIHRob3NlIGFyZVxuICAgICAgICAgICBwb29sIHBvaW50ZXJzLCB3aGljaCBhcmUgdW5pbmZvcm1hdGl2ZS4gKilcbiAgICAgICAgWyVtZXNzYWdlIFwiPEpvYi50PlwiXVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgLSdydyB0ID0gJ3J3IFR5cGVzLlRpbWVfc291cmNlLnQxID1cbiAgICB7IGlkIDogSWQudFxuICAgIDsgKCogW2FkdmFuY2VfZXJyb3JzXSBhY2N1bXVsYXRlcyBlcnJvcnMgcmFpc2VkIGJ5IGFsYXJtcyBydW4gYnlcbiAgICAgICAgIFthZHZhbmNlX2J5X2FsYXJtc10uICopXG4gICAgICBtdXRhYmxlIGFkdmFuY2VfZXJyb3JzIDogRXJyb3IudCBsaXN0XG4gICAgOyAoKiBbYW1fYWR2YW5jaW5nXSBpcyB0cnVlIG9ubHkgZHVyaW5nIFthZHZhbmNlX2J5X2FsYXJtc10sIGFuZCBpcyB1c2VkIHRvIGNhdXNlXG4gICAgICAgICBjYWxsYmFja3MgdG8gcmFpc2UgaWYgdGhleSBjYWxsIFthZHZhbmNlX2J5X2FsYXJtc10uICopXG4gICAgICBtdXRhYmxlIGFtX2FkdmFuY2luZyA6IGJvb2xcbiAgICA7IGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC50XG4gICAgOyAoKiBbZmlyZWRfZXZlbnRzXSBpcyB0aGUgZnJvbnQgb2YgdGhlIGRvdWJseS1saW5rZWQgbGlzdCBvZiBmaXJlZCBldmVudHMsXG4gICAgICAgICB3aGljaCBpcyBzdG9yZWQgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBbRXZlbnQuYXRdLiAqKVxuICAgICAgbXV0YWJsZSBmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udFxuICAgIDsgKCogW21vc3RfcmVjZW50bHlfZmlyZWRdIGlzIHRoZSBldmVudCB0aGF0IHdhcyBtb3N0IHJlY2VudGx5IGluc2VydGVkIGludG9cbiAgICAgICAgIFtmaXJlZF9ldmVudHNdLiBJdCBpcyB1c2VkIGFzIGFuIG9wdGltaXphdGlvbiB0byBhbGxvdyBpbnNlcnRpb24gb2ZcbiAgICAgICAgIHN1YnNlcXVlbnQgZXZlbnRzIHRvIHN0YXJ0IGxhdGVyIGluIHRoZSBsaXN0IHJhdGhlciB0aGFuIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICBJdCBzcGVjaWZpY2FsbHkgYXZvaWRzIHF1YWRyYXRpYyBiZWhhdmlvciB3aGVuIGluc2VydGluZyBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgIHRoYXQgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHRpbWUgLS0gdGhlIHRpbWUgc291cmNlIGZpcmVzIHN1Y2ggZXZlbnRzIGluXG4gICAgICAgICB0aGUgb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBhbmQgd2Ugd2FudCB0aGVtIHRvIGJlIGluIHRoYXQgc2FtZSBvcmRlciBpblxuICAgICAgICAgW2ZpcmVkX2V2ZW50c10uICopXG4gICAgICBtdXRhYmxlIG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udFxuICAgIDsgKCogV2Ugc3RvcmUgW2hhbmRsZV9maXJlZF0gaW4gW3RdIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgZXZlcnkgdGltZSB3ZSBjYWxsXG4gICAgICAgICBbYWR2YW5jZV9jbG9ja10uICopXG4gICAgICBoYW5kbGVfZmlyZWQgOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50IC0+IHVuaXRcbiAgICA7IGlzX3dhbGxfY2xvY2sgOiBib29sXG4gICAgOyBzY2hlZHVsZXIgOiBTY2hlZHVsZXIwLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICAgICAgX1xuICAgICAgICB7IGlkID0gX1xuICAgICAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgICAgICA7IGFtX2FkdmFuY2luZyA9IF9cbiAgICAgICAgOyBldmVudHNcbiAgICAgICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgICAgIDsgaGFuZGxlX2ZpcmVkID0gX1xuICAgICAgICA7IGlzX3dhbGxfY2xvY2tcbiAgICAgICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgICAgICA7IHNjaGVkdWxlciA9IF9cbiAgICAgICAgfVxuICAgID1cbiAgICBsZXQgbm93ID0gVGltaW5nX3doZWVsLm5vdyBldmVudHMgaW5cbiAgICBpZiBpc193YWxsX2Nsb2NrXG4gICAgdGhlbiBbJW1lc3NhZ2UgXCJ3YWxsX2Nsb2NrXCIgKG5vdyA6IFRpbWVfbnMudCldXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYWxsX2V2ZW50cyA9IHJlZiBbXSBpblxuICAgICAgVGltaW5nX3doZWVsLml0ZXIgZXZlbnRzIH5mOihmdW4gYWxhcm0gLT5cbiAgICAgICAgYWxsX2V2ZW50cyA6PSAoQWxhcm0uYXQgZXZlbnRzIGFsYXJtLCBBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pIDo6ICFhbGxfZXZlbnRzKTtcbiAgICAgIGxldCBldmVudHMgPVxuICAgICAgICBMaXN0LnNvcnQgIWFsbF9ldmVudHMgfmNvbXBhcmU6KGZ1biAoYXQxLCBfKSAoYXQyLCBfKSAtPiBUaW1lX25zLmNvbXBhcmUgYXQxIGF0MilcbiAgICAgICAgfD4gTGlzdC5tYXAgfmY6c25kXG4gICAgICBpblxuICAgICAgWyVtZXNzYWdlIFwiXCIgKG5vdyA6IFRpbWVfbnMudCkgKGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IGxpc3QpXSlcbiAgOztcblxuICBsZXQgdGltaW5nX3doZWVsX25vdyB0ID0gVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c1xuXG4gIGxldCBpc19pbl9maXJlZF9ldmVudHMgPVxuICAgIGxldCByZWMgc2VhcmNoIGN1cnJlbnQgfnRhcmdldF9ldmVudCA9XG4gICAgICBtYXRjaCVvcHRpb25hbCAoY3VycmVudCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSBjdXJyZW50IC0+XG4gICAgICAgIHBoeXNfZXF1YWwgY3VycmVudCB0YXJnZXRfZXZlbnQgfHwgc2VhcmNoIGN1cnJlbnQubmV4dF9maXJlZCB+dGFyZ2V0X2V2ZW50XG4gICAgaW5cbiAgICBmdW4gdCB0YXJnZXRfZXZlbnQgLT4gc2VhcmNoIHQuZmlyZWRfZXZlbnRzIH50YXJnZXRfZXZlbnRcbiAgOztcblxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyAodHlwZSBydykgfmpvYjooam9iX2ludmFyaWFudCA6IEpvYi50IC0+IHVuaXQpICh0IDogcncgdCkgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5pZDppZ25vcmVcbiAgICAgICAgfmFkdmFuY2VfZXJyb3JzOmlnbm9yZVxuICAgICAgICB+YW1fYWR2YW5jaW5nOmlnbm9yZVxuICAgICAgICB+ZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGV2ZW50cyAtPlxuICAgICAgICAgICAgIFRpbWluZ193aGVlbC5pbnZhcmlhbnQgaWdub3JlIGV2ZW50cztcbiAgICAgICAgICAgICBUaW1pbmdfd2hlZWwuaXRlciBldmVudHMgfmY6KGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIGV2ZW50cyBhbGFybSBpblxuICAgICAgICAgICAgICAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gICAgICAgICAgICAgICBsZXQgKEsgaykgPSBraW5kIGpvYl9vcl9ldmVudCBpblxuICAgICAgICAgICAgICAgbWF0Y2ggaywgcHJvamVjdCBrIGpvYl9vcl9ldmVudCB3aXRoXG4gICAgICAgICAgICAgICB8IEpvYiwgam9iIC0+IGpvYl9pbnZhcmlhbnQgam9iXG4gICAgICAgICAgICAgICB8IEV2ZW50LCBldmVudCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgYWxhcm0gZXZlbnQuYWxhcm0pO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdIGV2ZW50LmF0IH5leHBlY3Q6KEFsYXJtLmF0IGV2ZW50cyBhbGFybSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEV2ZW50LlN0YXR1cy50XSBldmVudC5zdGF0dXMgfmV4cGVjdDpTY2hlZHVsZWQ7XG4gICAgICAgICAgICAgICAgIEV2ZW50LmludmFyaWFudCBldmVudCkpKVxuICAgICAgICB+ZmlyZWRfZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIChmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udCkgLT5cbiAgICAgICAgICAgICBsZXQgcmVjIGNoZWNrX2V2ZW50IChjdXJyZW50IDogRXZlbnQudCkgPVxuICAgICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBjdXJyZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpKTtcbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBjdXJyZW50Lm5leHRfZmlyZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIGN1cnJlbnQuYXQgbmV4dC5hdCk7XG4gICAgICAgICAgICAgICAgIGNoZWNrX2V2ZW50IG5leHRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBmaXJlZF9ldmVudHMgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBjaGVja19ldmVudCBldmVudCkpXG4gICAgICAgIH5oYW5kbGVfZmlyZWQ6aWdub3JlXG4gICAgICAgIH5pc193YWxsX2Nsb2NrOmlnbm9yZVxuICAgICAgICB+bW9zdF9yZWNlbnRseV9maXJlZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwgKG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBhc3NlcnQgKGlzX2luX2ZpcmVkX2V2ZW50cyB0IGV2ZW50KSkpXG4gICAgICAgIH5zY2hlZHVsZXI6aWdub3JlKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9IGludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIF8gLT4gKCkpIHRcbmVuZFxuXG5vcGVuIFQxXG5cbnR5cGUgdCA9IHJlYWQgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5sZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gcmVhZF93cml0ZSBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmVuZFxuXG5sZXQgaWQgdCA9IHQuaWRcbmxldCBpc193YWxsX2Nsb2NrIHQgPSB0LmlzX3dhbGxfY2xvY2tcbmxldCBsZW5ndGggdCA9IFRpbWluZ193aGVlbC5sZW5ndGggdC5ldmVudHNcbmxldCBtYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgPSBUaW1pbmdfd2hlZWwubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0LmV2ZW50c1xubGV0IHJlYWRfb25seSAodCA6IFs+IHJlYWQgXSBUMS50KSA9ICh0IDo+IHQpXG5cbigqIFtmaXJlIHQgZXZlbnRdIHNldHMgW2V2ZW50LnN0YXR1cyA9IEZpcmVkXSBhbmQgaW5zZXJ0cyBbZXZlbnRdIGludG9cbiAgIFt0LmZpcmVkX2V2ZW50c10gaW4gc29ydGVkIHRpbWUgb3JkZXIuICopXG5sZXQgZmlyZSB0IChldmVudCA6IEV2ZW50LnQpID1cbiAgRXZlbnQuc2V0X3N0YXR1cyBldmVudCBGaXJlZDtcbiAgZXZlbnQuYWxhcm0gPC0gQWxhcm0ubnVsbCAoKTtcbiAgbGV0ICgpID1cbiAgICAoKiBJZiBbZXZlbnRdIGJlbG9uZ3MgYWZ0ZXIgW3QubW9zdF9yZWNlbnRseV9maXJlZF0sIHRoZW4gd2Ugc3RhcnQgdGhlXG4gICAgICAgaW5zZXJ0aW9uIHRoZXJlIHJhdGhlciB0aGFuIGF0IHRoZSBmcm9udCBvZiBbdC5maXJlZF9ldmVudHNdLiBUaGlzIHdvcmtzXG4gICAgICAgbmljZWx5IGlmIHdlJ3JlIGdldHRpbmcgdGhlIGFsYXJtcyBpbiBub24tZGVjcmVhc2luZyB0aW1lIG9yZGVyLCB3aGljaCBpc1xuICAgICAgIGNsb3NlIHRvIHdoYXQgW1RpbWluZ193aGVlbF0gcHJvdmlkZXMgKGFsdGhvdWdoIFtUaW1pbmdfd2hlZWxdIGRvZXNuJ3RcbiAgICAgICBndWFyYW50ZWUgdGltZSBvcmRlcmluZyBmb3IgdGltZXMgaW4gdGhlIHNhbWUgaW50ZXJ2YWwpLiAqKVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIHdoZW4gVGltZV9ucy4oIDw9ICkgbW9zdF9yZWNlbnRseV9maXJlZC5hdCBldmVudC5hdCAtPlxuICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkO1xuICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSBtb3N0X3JlY2VudGx5X2ZpcmVkLm5leHRfZmlyZWRcbiAgICB8IF8gLT5cbiAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIHQuZmlyZWRfZXZlbnRzXG4gIGluXG4gIHQubW9zdF9yZWNlbnRseV9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudDtcbiAgKCogV2UgdXNlIFtUaW1lX25zLiggPD0gKV0gcmF0aGVyIHRoYW4gWzxdIHNvIHRoYXQgW2V2ZW50XSBpcyBhZGRlZCBhZnRlciBvdGhlclxuICAgICBldmVudHMgYXQgdGhlIHNhbWUgdGltZS4gU2luY2UgW1RpbWluZ193aGVlbF0gZmlyZXMgYWxhcm1zIGluIGEgYnVja2V0IGluXG4gICAgIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQsIHVzaW5nIFs8PV0ga2VlcHMgZXZlbnRzIGF0IHRoZSBzYW1lXG4gICAgIHRpbWUgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC4gKilcbiAgd2hpbGVcbiAgICBtYXRjaCVvcHRpb25hbCAoZXZlbnQubmV4dF9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIG5leHQgLT5cbiAgICAgIGxldCBjb250aW51ZSA9IFRpbWVfbnMuKCA8PSApIG5leHQuYXQgZXZlbnQuYXQgaW5cbiAgICAgIGlmIGNvbnRpbnVlXG4gICAgICB0aGVuIChcbiAgICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkO1xuICAgICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIG5leHQubmV4dF9maXJlZCk7XG4gICAgICBjb250aW51ZVxuICBkb1xuICAgICgpXG4gIGRvbmU7XG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICBpblxuICBtYXRjaCVvcHRpb25hbCAoZXZlbnQucHJldl9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gIHwgTm9uZSAtPiB0LmZpcmVkX2V2ZW50cyA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICB8IFNvbWUgcHJldiAtPiBwcmV2Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbjs7XG5cbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gdC5ldmVudHNcbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuXG5sZXQgbmV4dF9hbGFybV9ydW5zX2F0IHQgPVxuICBpZiBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuICB0aGVuIFNvbWUgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgZWxzZSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuOztcblxubGV0IG5vdyB0ID0gaWYgdC5pc193YWxsX2Nsb2NrIHRoZW4gVGltZV9ucy5ub3cgKCkgZWxzZSB0aW1pbmdfd2hlZWxfbm93IHRcbmxldCB0aW1pbmdfd2hlZWxfbm93ID0gdGltaW5nX3doZWVsX25vd1xuXG5sZXQgc2NoZWR1bGUgdCAoZXZlbnQgOiBFdmVudC50KSA9XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgU2NoZWR1bGVkO1xuICBldmVudC5hbGFybSA8LSBUaW1pbmdfd2hlZWwuYWRkIHQuZXZlbnRzIH5hdDpldmVudC5hdCAoZXZlbnQgfD4gSm9iX29yX2V2ZW50Lm9mX2V2ZW50KVxuOztcblxubGV0IHJlbW92ZV9mcm9tX2ZpcmVkIHQgKGV2ZW50IDogRXZlbnQudCkgfm5ld19zdGF0dXMgPVxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIGV2ZW50IG1vc3RfcmVjZW50bHlfZmlyZWRcbiAgICAgIHRoZW5cbiAgICAgICAgdC5tb3N0X3JlY2VudGx5X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5maXJzdF9zb21lIGV2ZW50Lm5leHRfZmlyZWQgZXZlbnQucHJldl9maXJlZFxuICBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5wcmV2X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gdC5maXJlZF9ldmVudHMgPC0gZXZlbnQubmV4dF9maXJlZFxuICAgIHwgU29tZSBwcmV2IC0+IHByZXYubmV4dF9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkXG4gIGluXG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBldmVudC5wcmV2X2ZpcmVkXG4gIGluXG4gIGV2ZW50Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgbmV3X3N0YXR1c1xuOztcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgRXZlbnRcblxuICBsZXQgY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgPVxuICAgIHsgYWxhcm0gPSBBbGFybS5udWxsICgpXG4gICAgOyBhdFxuICAgIDsgY2FsbGJhY2tcbiAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gdC5zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuICAgIDsgaW50ZXJ2YWxcbiAgICA7IG5leHRfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgcHJldl9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzdGF0dXMgPSBVbnNjaGVkdWxlZFxuICAgIH1cbiAgOztcblxuICBsZXQgYWRkIHQgZXZlbnQgPVxuICAgIGlmIFRpbWVfbnMuKCA8PSApIGV2ZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gICAgdGhlbiBmaXJlIHQgZXZlbnRcbiAgICBlbHNlIHNjaGVkdWxlIHQgZXZlbnRcbiAgOztcblxuICBsZXQgY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsIH5jYWxsYmFjayA9XG4gICAgbGV0IGV2ZW50ID0gY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgaW5cbiAgICBhZGQgdCBldmVudDtcbiAgICBldmVudFxuICA7O1xuXG4gIGxldCBhdCB0IGF0IGNhbGxiYWNrID0gY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG5cbiAgbGV0IGFmdGVyIHQgc3BhbiBjYWxsYmFjayA9XG4gICAgY3JlYXRlX2FuZF9hZGQgdCB+YXQ6KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuKSB+aW50ZXJ2YWw6Tm9uZSB+Y2FsbGJhY2tcbiAgOztcblxuICBsZXQgcmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByZWNpc2lvbiB0IHNwYW4gPVxuICAgIGxldCBhbGFybV9wcmVjaXNpb24gPSBhbGFybV9wcmVjaXNpb24gdCBpblxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDwgKSBzcGFuIGFsYXJtX3ByZWNpc2lvblxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnRlcnZhbCBzcGFuIHNtYWxsZXIgdGhhbiBhbGFybSBwcmVjaXNpb25cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udClcbiAgICAgICAgICAgIChhbGFybV9wcmVjaXNpb24gOiBUaW1lX25zLlNwYW4udCldXG4gIDs7XG5cbiAgbGV0IGF0X2ludGVydmFscyB0IHNwYW4gY2FsbGJhY2sgPVxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIGNyZWF0ZV9hbmRfYWRkIHQgfmF0Oihub3cgdCkgfmludGVydmFsOihTb21lIHNwYW4pIH5jYWxsYmFja1xuICA7O1xuXG4gIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBDdXJyZW50bHlfaGFwcGVuaW5nXG4gICAgICB8IFByZXZpb3VzbHlfdW5zY2hlZHVsZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgYWJvcnQgdCAoZXZlbnQgOiB0KSA6IEFib3J0X3Jlc3VsdC50ID1cbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgSGFwcGVuaW5nIC0+XG4gICAgICAobWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBDdXJyZW50bHlfaGFwcGVuaW5nXG4gICAgICAgfCBTb21lIChfIDogVGltZV9ucy5TcGFuLnQpIC0+XG4gICAgICAgICBldmVudC5pbnRlcnZhbCA8LSBOb25lO1xuICAgICAgICAgT2spXG4gICAgfCBGaXJlZCAtPlxuICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpVbnNjaGVkdWxlZDtcbiAgICAgIE9rXG4gICAgfCBTY2hlZHVsZWQgLT5cbiAgICAgIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgVW5zY2hlZHVsZWQ7XG4gICAgICBUaW1pbmdfd2hlZWwucmVtb3ZlIHQuZXZlbnRzIGV2ZW50LmFsYXJtO1xuICAgICAgZXZlbnQuYWxhcm0gPC0gQWxhcm0ubnVsbCAoKTtcbiAgICAgIE9rXG4gICAgfCBVbnNjaGVkdWxlZCAtPiBQcmV2aW91c2x5X3Vuc2NoZWR1bGVkXG4gIDs7XG5cbiAgbGV0IGFib3J0X2lmX3Bvc3NpYmxlIHQgZXZlbnQgPSBpZ25vcmUgKGFib3J0IHQgZXZlbnQgOiBBYm9ydF9yZXN1bHQudClcblxuICBsZXQgYWJvcnRfZXhuIHQgZXZlbnQgPVxuICAgIG1hdGNoIGFib3J0IHQgZXZlbnQgd2l0aFxuICAgIHwgT2sgLT4gKClcbiAgICB8IHJlYXNvbiAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltTeW5jaHJvbm91c190aW1lX3NvdXJjZS5hYm9ydF9leG5dIGNhbm5vdCBhYm9ydCBldmVudFwiXG4gICAgICAgICAgICAocmVhc29uIDogQWJvcnRfcmVzdWx0LnQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgdCBjYWxsYmFjayA9IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdDpUaW1lX25zLmVwb2NoIH5pbnRlcnZhbDpOb25lIH5jYWxsYmFja1xuXG4gIGxldCBzY2hlZHVsZV9hdF9pbnRlcm5hbCB0IChldmVudCA6IHQpIGF0IH5pbnRlcnZhbCA9XG4gICAgKCogW0ZpcmVkXSBpcyBkaXNhbGxvd2VkIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSBlbnRlcmluZyBpbnRvIGFuIGluZmluaXRlIGxvb3AuICBUaGVcbiAgICAgICB1c2VyIGNvdWxkIHNwZWNpZnkgW2F0XSBpbiB0aGUgcGFzdCB3aGljaCB3b3VsZCBjb25zdGFudGx5IGFkZCBbY2FsbGJhY2tdIHRvIHRoZVxuICAgICAgIGJhY2sgb2YgW3QubmV4dF9maXJlZF0gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbSBbY2FsbGJhY2tdLiAqKVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCAoSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgRmlyZWQpIGFzIHN0YXR1cyAtPlxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICBbJXNleHAgXCJjYW5ub3Qgc2NoZWR1bGUgYW4gZXZlbnQgd2l0aCBzdGF0dXNcIiwgKHN0YXR1cyA6IEV2ZW50LlN0YXR1cy50KV1cbiAgICB8IFVuc2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGV2ZW50LmludGVydmFsIDwtIGludGVydmFsO1xuICAgICAgYWRkIHQgZXZlbnQ7XG4gICAgICBPayAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV9hdCB0IGV2ZW50IGF0ID0gc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCBldmVudCBhdCB+aW50ZXJ2YWw6Tm9uZVxuICBsZXQgc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gc2NoZWR1bGVfYXQgdCBldmVudCAoVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW4pXG5cbiAgbGV0IHNjaGVkdWxlX2F0X2ludGVydmFscyB0IGV2ZW50IHNwYW4gPVxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIHNjaGVkdWxlX2F0X2ludGVybmFsIHQgZXZlbnQgKG5vdyB0KSB+aW50ZXJ2YWw6KFNvbWUgc3BhbilcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IGV2ZW50IGF0IDogdW5pdCA9XG4gICAgbWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICB8IEZpcmVkIC0+XG4gICAgICByZW1vdmVfZnJvbV9maXJlZCB0IGV2ZW50IH5uZXdfc3RhdHVzOlVuc2NoZWR1bGVkO1xuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgSGFwcGVuaW5nIC0+XG4gICAgICAoKiBIYXBwZW5pbmcgZXZlbnRzIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBbZmlyZWRdLiAqKVxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgU2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGlmIFRpbWVfbnMuKCA+ICkgYXQgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgICAgIHRoZW4gVGltaW5nX3doZWVsLnJlc2NoZWR1bGUgdC5ldmVudHMgZXZlbnQuYWxhcm0gfmF0XG4gICAgICBlbHNlIChcbiAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBldmVudC5hbGFybTtcbiAgICAgICAgZmlyZSB0IGV2ZW50KVxuICAgIHwgVW5zY2hlZHVsZWQgLT5cbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgZXZlbnQuaW50ZXJ2YWwgPC0gTm9uZTtcbiAgICAgIGFkZCB0IGV2ZW50XG4gIDs7XG5cbiAgbGV0IHJlc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gcmVzY2hlZHVsZV9hdCB0IGV2ZW50IChUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhbilcblxuZW5kXG5cbmxldCBydW5fYWZ0ZXIgdCBzcGFuIGNhbGxiYWNrID0gaWdub3JlIChFdmVudC5hZnRlciB0IHNwYW4gY2FsbGJhY2sgOiBFdmVudC50KVxubGV0IHJ1bl9hdCB0IGF0IGNhbGxiYWNrID0gaWdub3JlIChFdmVudC5hdCB0IGF0IGNhbGxiYWNrIDogRXZlbnQudClcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMgdCBzcGFuIGNhbGxiYWNrID1cbiAgaWdub3JlIChFdmVudC5hdF9pbnRlcnZhbHMgdCBzcGFuIGNhbGxiYWNrIDogRXZlbnQudClcbjs7XG5cbnR5cGUgc2VuZF9leG4gPSBNb25pdG9yMC50IC0+ID9iYWNrdHJhY2U6WyBgR2V0IHwgYFRoaXMgb2YgQmFja3RyYWNlLnQgXSAtPiBleG4gLT4gdW5pdFxuXG5sZXQgcnVuX2ZpcmVkX2V2ZW50cyB0IH4oc2VuZF9leG4gOiBzZW5kX2V4biBvcHRpb24pID1cbiAgbGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPSB0LnNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGluXG4gIHdoaWxlXG4gICAgbWF0Y2glb3B0aW9uYWwgKHQuZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgZXZlbnQgLT5cbiAgICAgIChtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgICAgIHwgSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBGaXJlZCAtPlxuICAgICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpIYXBwZW5pbmc7XG4gICAgICAgICAoKiBXZSBzZXQgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgW2V2ZW50LmNhbGxiYWNrXSBydW5zIGluIHRoZSBzYW1lIGNvbnRleHRcbiAgICAgICAgICAgIHRoYXQgd2FzIGluIHBsYWNlIHdoZW4gW2V2ZW50XSB3YXMgY3JlYXRlZC4gKilcbiAgICAgICAgIFNjaGVkdWxlcjAuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQuc2NoZWR1bGVyIGV2ZW50LmV4ZWN1dGlvbl9jb250ZXh0O1xuICAgICAgICAgKCogQW55IG1vZGlmaWNhdGlvbiBvZiBbc3RhdHVzXSBiZWxvdyBuZWVkcyB0byBmaXJzdCBjaGVjayB0aGF0IHRoZSBldmVudCBpc1xuICAgICAgICAgICAgc3RpbGwgW0hhcHBlbmluZ10uIElmIHRoZSBldmVudCBzdGF0dXMgaXMgbm90IFtIYXBwZW5pbmddIHRoZW4gdGhlIGV2ZW50J3NcbiAgICAgICAgICAgIGNhbGxiYWNrIG11c3QgaGF2ZSByZXNjaGVkdWxlZCB0aGUgZXZlbnQuIEluIHRoYXQgY2FzZSwgZG8gbm90IHNldCB0aGUgc3RhdHVzXG4gICAgICAgICAgICBvciBhdHRlbXB0IHRvIHJlc2NoZWR1bGUgYSByZXBlYXRpbmcgZXZlbnQuXG5cbiAgICAgICAgICAgIFRoaXMgY29kZSBjb3VsZCBiZSBtdWNoIHNpbXBsZXIgaWYgd2UgaW1tZWRpYXRlbHkgcmVzY2hlZHVsZWQgdGhlIGV2ZW50IGJlZm9yZVxuICAgICAgICAgICAgcnVubmluZyB0aGUgY2FsbGJhY2sgKG5vIG5lZWQgZm9yIHRoZSBIYXBwZW5pbmcgc3RhdGUgdGhlbikuIE9uZSByZWFzb24gd2VcbiAgICAgICAgICAgIGRvbid0IGRvIHRoYXQgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVzY2hlZHVsZSBhIHBlcmlvZGljXG4gICAgICAgICAgICBldmVudCBpZiBpdHMgY2FsbGJhY2sgcmFpc2VzLiAqKVxuICAgICAgICAgKG1hdGNoIGV2ZW50LmNhbGxiYWNrICgpIHdpdGhcbiAgICAgICAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgICAgIChtYXRjaCBzZW5kX2V4biB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+IHQuYWR2YW5jZV9lcnJvcnMgPC0gRXJyb3Iub2ZfZXhuIGV4biA6OiB0LmFkdmFuY2VfZXJyb3JzXG4gICAgICAgICAgICAgfCBTb21lIHNlbmRfZXhuIC0+XG4gICAgICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgICAgICAgICAgICAgc2VuZF9leG4gZXZlbnQuZXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciBleG4gfmJhY2t0cmFjZTooYFRoaXMgYmFja3RyYWNlKSk7XG4gICAgICAgICAgICBFdmVudC5zZXRfc3RhdHVzX2lmIH5pczpIYXBwZW5pbmcgZXZlbnQgVW5zY2hlZHVsZWRcbiAgICAgICAgICB8ICgpIC0+XG4gICAgICAgICAgICAobWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBFdmVudC5zZXRfc3RhdHVzX2lmIH5pczpIYXBwZW5pbmcgZXZlbnQgVW5zY2hlZHVsZWRcbiAgICAgICAgICAgICB8IFNvbWUgaW50ZXJ2YWwgLT5cbiAgICAgICAgICAgICAgIGlmIEV2ZW50LlN0YXR1cy5lcXVhbCBIYXBwZW5pbmcgZXZlbnQuc3RhdHVzXG4gICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgKCogVGhlIGV2ZW50J3MgY2FsbGJhY2sgZGlkIG5vdCByZXNjaGVkdWxlIHRoZSBldmVudC4gU28gcmVzY2hlZHVsZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0aW5nIHRpbWVyIGJhc2VkIG9uIHRoZSBsYXN0IFthdF0gdGltZS4gKilcbiAgICAgICAgICAgICAgICAgZXZlbnQuYXRcbiAgICAgICAgICAgICAgICAgPC0gVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICAgICAgICB+YmFzZTpldmVudC5hdFxuICAgICAgICAgICAgICAgICAgICAgIH5hZnRlcjoodGltaW5nX3doZWVsX25vdyB0KVxuICAgICAgICAgICAgICAgICAgICAgIH5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgc2NoZWR1bGUgdCBldmVudCkpKTtcbiAgICAgICAgIHRydWUpXG4gIGRvXG4gICAgKClcbiAgZG9uZTtcbiAgU2NoZWR1bGVyMC5zZXRfZXhlY3V0aW9uX2NvbnRleHQgdC5zY2hlZHVsZXIgY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuOztcblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4biA9XG4gIFRpbWluZ193aGVlbC5hZHZhbmNlX2Nsb2NrIHQuZXZlbnRzIH50b18gfmhhbmRsZV9maXJlZDp0LmhhbmRsZV9maXJlZDtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG4gPVxuICBUaW1pbmdfd2hlZWwuZmlyZV9wYXN0X2FsYXJtcyB0LmV2ZW50cyB+aGFuZGxlX2ZpcmVkOnQuaGFuZGxlX2ZpcmVkO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuID1cbiAgYWR2YW5jZV9jbG9jayB0IH50b18gfnNlbmRfZXhuO1xuICBmaXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuID1cbiAgaWYgdC5hbV9hZHZhbmNpbmdcbiAgdGhlblxuICAgIHJhaXNlX3MgWyVzZXhwIFwiY2Fubm90IGNhbGwgW2FkdmFuY2VfYnlfYWxhcm1zXSBvciBbYWR2YW5jZV9kaXJlY3RseV0gZnJvbSBjYWxsYmFja1wiXTtcbiAgdC5hbV9hZHZhbmNpbmcgPC0gdHJ1ZTtcbiAgKG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICAgfCBbXSAtPiAoKVxuICAgfCBfIC0+IHQuYWR2YW5jZV9lcnJvcnMgPC0gW10pO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgZmluaXNoX2FkdmFuY2luZyB0ID1cbiAgdC5hbV9hZHZhbmNpbmcgPC0gZmFsc2U7XG4gIG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICB8IFtdIC0+IE9rICgpXG4gIHwgZXJyb3JzIC0+XG4gICAgdC5hZHZhbmNlX2Vycm9ycyA8LSBbXTtcbiAgICBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJvcnMpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXMgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFjb250aW51ZSBkb1xuICAgIGlmIFRpbWluZ193aGVlbC5pc19lbXB0eSB0LmV2ZW50c1xuICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICBlbHNlIChcbiAgICAgIGxldCBtaW5fYWxhcm1fdGltZSA9IFRpbWluZ193aGVlbC5taW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQuZXZlbnRzIGluXG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBtaW5fYWxhcm1fdGltZSB0b19cbiAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgIGVsc2VcbiAgICAgICAgKCogV2UgdXNlIHRoZSBhY3R1YWwgYWxhcm0gdGltZSwgcmF0aGVyIHRoYW4gW25leHRfYWxhcm1fZmlyZXNfYXRdLCBzbyBhcyBub3QgdG9cbiAgICAgICAgICAgZXhwb3NlIChvciBhY2N1bXVsYXRlIGVycm9ycyBhc3NvY2lhdGVkIHdpdGgpIHRoZSBwcmVjaXNpb24gb2ZcbiAgICAgICAgICAgW1RpbWluZ193aGVlbF0uICopXG4gICAgICAgIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fOm1pbl9hbGFybV90aW1lIH5zZW5kX2V4bilcbiAgZG9uZTtcbiAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuO1xuICBmaW5pc2hfYWR2YW5jaW5nIHRcbjs7XG5cbmxldCBhZHZhbmNlX2J5X21heF9hbGFybXNfaW5fZWFjaF90aW1pbmdfd2hlZWxfaW50ZXJ2YWwgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFjb250aW51ZSBkb1xuICAgIGlmIFRpbWluZ193aGVlbC5pc19lbXB0eSB0LmV2ZW50c1xuICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHQuZXZlbnRzIGluXG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBuZXh0X2FsYXJtX2ZpcmVzX2F0IHRvX1xuICAgICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgICAgZWxzZVxuICAgICAgICAoKiBXZSB1c2UgdGhlIGFjdHVhbCBhbGFybSB0aW1lLCByYXRoZXIgdGhhbiBbbmV4dF9hbGFybV9maXJlc19hdF0sIHNvIGFzIG5vdCB0b1xuICAgICAgICAgICBleHBvc2UgKG9yIGFjY3VtdWxhdGUgZXJyb3JzIGFzc29jaWF0ZWQgd2l0aCkgdGhlIHByZWNpc2lvbiBvZlxuICAgICAgICAgICBbVGltaW5nX3doZWVsXS4gKilcbiAgICAgICAgYWR2YW5jZV9pbnRlcm5hbFxuICAgICAgICAgIHRcbiAgICAgICAgICB+dG9fOihUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0LmV2ZW50cylcbiAgICAgICAgICB+c2VuZF9leG4pXG4gIGRvbmU7XG4gIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgYWR2YW5jZV9kaXJlY3RseSB0IH50b18gPVxuICBsZXQgc2VuZF9leG4gPSBOb25lIGluXG4gIHByZXBhcmVfdG9fYWR2YW5jZSB0IH5zZW5kX2V4bjtcbiAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuO1xuICBmaW5pc2hfYWR2YW5jaW5nIHRcbjs7XG5cbmxldCBkdXJhdGlvbl9vZiB0IGYgPVxuICBsZXQgc3RhcnQgPSBub3cgdCBpblxuICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICBsZXQgZHVyYXRpb24gPSBUaW1lX25zLmRpZmYgKG5vdyB0KSBzdGFydCBpblxuICByZXN1bHQsIGR1cmF0aW9uXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX3RpbWluZ193aGVlbF9pbnRlcnZhbCB0ID1cbiAgVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0LmV2ZW50c1xuOztcblxubGV0IGhhc19ldmVudHNfdG9fcnVuIHQgPSBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuaW5jbHVkZSBTY2hlZHVsZXIwXG5tb2R1bGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcbm1vZHVsZSBFdmVudCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50XG5tb2R1bGUgQWxhcm0gPSBUaW1pbmdfd2hlZWwuQWxhcm1cbm1vZHVsZSBKb2Jfb3JfZXZlbnQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS5Kb2Jfb3JfZXZlbnRcblxubGV0IGRlYnVnID0gRGVidWcuc2NoZWR1bGVyXG5cbm1vZHVsZSBJdmFyID0gc3RydWN0XG4gIG9wZW4gVHlwZXMuSXZhclxuXG4gIGxldCBjcmVhdGVfd2l0aF9jZWxsIGNlbGwgPSB7IGNlbGwgfVxuICBsZXQgY3JlYXRlICgpID0gY3JlYXRlX3dpdGhfY2VsbCBFbXB0eVxuXG4gIGxldCBjcmVhdGVfZnVsbCAodHlwZSBhKSAoYSA6IGEpID1cbiAgICAoKiBXZSBhbGxvY2F0ZSBhbiBpbW11dGFibGUgaXZhciBhbmQgdGhlbiBjYXN0IGl0IHRvIGEgbXV0YWJsZSBpdmFyLiAgVGhlIGltbXV0YWJpbGl0eVxuICAgICAgIGFsbG93cyBPQ2FtbCB0byBzdGF0aWNhbGx5IGFsbG9jYXRlIHRoZSBpdmFyIGlmIFthXSBpcyBjb25zdGFudC4gIFRoaXMgY2FzdCBpcyBzYWZlXG4gICAgICAgYmVjYXVzZSBhIGZ1bGwgaXZhciBpcyBuZXZlciBtdXRhdGVkLiAgV2UgYWxzbyBiZWxpZXZlIHRoYXQgd2Ugd2lsbCBub3QgdHJpZ2dlclxuICAgICAgIGZsYW1iZGEgdG8gc3B1cmlvdXNseSByZXBvciB3YXJuaW5nIDU5LCBtdXRhdGlvbiBvZiBrbm93biBpbW11dGFibGUgZGF0YS4gIEFsbFxuICAgICAgIG11dGF0aW9ucyBvZiBhbiBpdmFyIGNlbGwsIGkuZS4gW2Zvby5jZWxsIDwtIC4uLl0sIGFyZSBkaXJlY3RseSBwcmVjZWRlZCBieSBhXG4gICAgICAgW21hdGNoIGZvby5jZWxsXSB0aGF0IHByZXZlbnRzIHRoZSBbRnVsbF0gY2FzZSBmcm9tIHJlYWNoaW5nIHRoZSBtb2RpZmljYXRpb24uICBTb1xuICAgICAgIGZsYW1iZGEgc2hvdWxkIGFsd2F5cyBlbGltaW5hdGUgdGhlIFtmb28uY2VsbCA8LSAuLi5dIG9mIGEgY29uc3RhbnQgW0Z1bGxdIGl2YXIsXG4gICAgICAgYW5kIG5vdCB3YXJuLiAqKVxuICAgIChPYmoubWFnaWMgOiBhIEltbXV0YWJsZS50IC0+IGEgdCkgeyBjZWxsID0gRnVsbCBhIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQnZhciA9IHN0cnVjdFxuICBvcGVuIFR5cGVzLkJ2YXJcblxuICBsZXQgY3JlYXRlICgpID0gb2ZfcmVwciB7IGhhc19hbnlfd2FpdGVycyA9IGZhbHNlOyBpdmFyID0gSXZhci5jcmVhdGUgKCkgfVxuZW5kXG5cbm1vZHVsZSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV4ZWNfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVHlwZXMuVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLkV4ZWNfcmVzdWx0LnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICB0eXBlIHQgPSBUeXBlcy5WZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCA9XG4gICAgeyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IGV4ZWMgOiB1bml0IC0+IEV4ZWNfcmVzdWx0LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlciB+ZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCkgfmV4ZWM6aWdub3JlKVxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IFNjaGVkdWxlcjAudCA9XG4gIHsgKCogW2NoZWNrX2FjY2Vzc10gb3B0aW9uYWxseSBob2xkcyBhIGZ1bmN0aW9uIHRvIHJ1biB0byBjaGVjayB3aGV0aGVyIGFjY2VzcyB0byBbdF0gaXNcbiAgICAgICBjdXJyZW50bHkgYWxsb3dlZC4gIEl0IGlzIHVzZWQgdG8gZGV0ZWN0IGludmFsaWQgYWNjZXNzIHRvIHRoZSBzY2hlZHVsZXIgZnJvbSBhXG4gICAgICAgdGhyZWFkLiAqKVxuICAgIG11dGFibGUgY2hlY2tfYWNjZXNzIDogKHVuaXQgLT4gdW5pdCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgOyBub3JtYWxfcHJpb3JpdHlfam9icyA6IEpvYl9xdWV1ZS50XG4gIDsgbG93X3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgOiBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCBEZXF1ZS50XG4gIDsgbXV0YWJsZSBtYWluX2V4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICA7IG11dGFibGUgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgKCogVGhlIHNjaGVkdWxlciBjYWxscyBbZ290X3VuY2F1Z2h0X2V4bl0gd2hlbiBhbiBleGNlcHRpb24gYnViYmxlcyB0byB0aGUgdG9wIG9mIHRoZVxuICAgICBtb25pdG9yIHRyZWUgd2l0aG91dCBiZWluZyBoYW5kbGVkLiAgVGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRvIG5ldmVyIHJ1biBhbm90aGVyXG4gICAgIGpvYiBhZnRlciB0aGlzIGJ5IGNhbGxpbmcgW2NsZWFyXSBhbmQgYmVjYXVzZSBbZW5xdWV1ZV9qb2JdIHdpbGwgbmV2ZXIgYWRkIGFub3RoZXJcbiAgICAgam9iLiAqKVxuICA7IG11dGFibGUgdW5jYXVnaHRfZXhuIDogKEV4bi50ICogU2V4cC50KSBvcHRpb25cbiAgOyBtdXRhYmxlIGN5Y2xlX2NvdW50IDogaW50XG4gIDsgbXV0YWJsZSBjeWNsZV9zdGFydCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgaW5fY3ljbGUgOiBib29sXG4gIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgOiAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pIGxpc3RcbiAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA6IChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkgbGlzdFxuICA7IHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgbGFzdF9jeWNsZV90aW1lIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgOyBtdXRhYmxlIHRvdGFsX2N5Y2xlX3RpbWUgOiBUaW1lX25zLlNwYW4udFxuICA7IG11dGFibGUgdGltZV9zb3VyY2UgOiByZWFkX3dyaXRlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnRcbiAgKCogW2V4dGVybmFsX2pvYnNdIGlzIGEgcXVldWUgb2YgYWN0aW9ucyBzZW50IGZyb20gb3V0c2lkZSBvZiBhc3luYy4gIFRoaXMgaXMgZm9yIHRoZVxuICAgICBjYXNlIHdoZXJlIHdlIHdhbnQgdG8gc2NoZWR1bGUgYSBqb2Igb3IgZmlsbCBhbiBpdmFyIGZyb20gYSBjb250ZXh0IHdoZXJlIGl0IGlzIG5vdFxuICAgICBzYWZlIHRvIHJ1biBhc3luYyBjb2RlLCBiZWNhdXNlIHRoZSBhc3luYyBsb2NrIGlzbid0IGhlbGQuICBGb3IgaW5zdGFuY2U6IC0gaW4gYW5cbiAgICAgT0NhbWwgZmluYWxpemVyLCBhcyB0aGV5IGNhbiBydW4gYXQgYW55IHRpbWUgaW4gYW55IHRocmVhZC5cblxuICAgICBUaGUgd2F5IHRvIGRvIGl0IGlzIHRvIHF1ZXVlIGEgdGh1bmsgaW4gW2V4dGVybmFsX2pvYnNdIGFuZCBjYWxsXG4gICAgIFt0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgdGhlIHNjaGVkdWxlclxuICAgICB0aGF0IG5ldyBhY3Rpb25zIGFyZSBhdmFpbGFibGUuXG5cbiAgICAgV2hlbiB1c2luZyBBc3luYyBvbiB1bml4LCBbdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2tdIGlzIHNldCBpbiBbQXN5bmNfdW5peF1cbiAgICAgdG8gY2FsbCBbSW50ZXJydXB0b3IudGhyZWFkX3NhZmVfaW50ZXJydXB0XSwgd2hpY2ggd2lsbCB3YWtlIHVwIHRoZVxuICAgICBbQXN5bmNfdW5peF0gc2NoZWR1bGVyIGFuZCBydW4gYSBjeWNsZS5cblxuICAgICBOb3RlIHRoYXQgdGhpcyBob29rIG1pZ2h0IGJlIHVzZWQgaW4gb3RoZXIgY29udGV4dCAoanNfb2Zfb2NhbWwsIG1pcmFnZSkuXG5cbiAgICAgV2hlbiBydW5uaW5nIGEgY3ljbGUsIHdlIHB1bGwgZXh0ZXJuYWwgYWN0aW9ucyBhdCBldmVyeSBqb2IgYW5kIHBlcmZvcm0gdGhlbVxuICAgICBpbW1lZGlhdGVseS4gKilcbiAgOyBleHRlcm5hbF9qb2JzIDogRXh0ZXJuYWxfam9iLnQgVGhyZWFkX3NhZmVfcXVldWUudFxuICA7IG11dGFibGUgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgOiB1bml0IC0+IHVuaXRcbiAgKCogW2pvYl9xdWV1ZWRfaG9va10gYW5kIFtldmVudF9hZGRlZF9ob29rXSBhaW0gdG8gYmUgdXNlZCBieSBqc19vZl9vY2FtbC4gKilcbiAgKCogV2UgdXNlIFtfIG9wdGlvbl0gaGVyZSBiZWNhdXNlIHRob3NlIGhvb2tzIHdpbGwgbm90IGJlIHNldCBpbiB0aGUgY29tbW9uIGNhc2VcbiAgICAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgZXh0cmEgZnVuY3Rpb24gY2FsbHMuICopXG4gIDsgbXV0YWJsZSBqb2JfcXVldWVkX2hvb2sgOiAoUHJpb3JpdHkudCAtPiB1bml0KSBvcHRpb25cbiAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICA7IG11dGFibGUgeWllbGQgOiAoKHVuaXQsIHJlYWRfd3JpdGUpIFR5cGVzLkJ2YXIudFtAc2V4cC5vcGFxdWVdKVxuICA7IG11dGFibGUgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gOlxuICAgICAgKCh1bml0LCByZWFkX3dyaXRlKSBUeXBlcy5CdmFyLnRbQHNleHAub3BhcXVlXSAoKiBjb25maWd1cmF0aW9uKikpXG4gIDsgbXV0YWJsZSBjaGVja19pbnZhcmlhbnRzIDogYm9vbFxuICA7IG11dGFibGUgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgOiBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS50XG4gIDsgbXV0YWJsZSByZWNvcmRfYmFja3RyYWNlcyA6IGJvb2xcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgdW5jYXVnaHRfZXhuX3Vud3JhcHBlZCA9IHVuY2F1Z2h0X2V4blxuXG5sZXQgdW5jYXVnaHRfZXhuIHQgPVxuICBtYXRjaCB0LnVuY2F1Z2h0X2V4biB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoZXhuLCBzZXhwKSAtPlxuICAgIFNvbWUgKEVycm9yLmNyZWF0ZSBcInVuaGFuZGxlZCBleGNlcHRpb25cIiAoZXhuLCBzZXhwKSBbJXNleHBfb2Y6IEV4bi50ICogU2V4cC50XSlcbjs7XG5cbmxldCBudW1fcGVuZGluZ19qb2JzIHQgPVxuICBKb2JfcXVldWUubGVuZ3RoIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgKyBKb2JfcXVldWUubGVuZ3RoIHQubG93X3ByaW9yaXR5X2pvYnNcbjs7XG5cbmxldCBudW1fam9ic19ydW4gdCA9XG4gIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5ub3JtYWxfcHJpb3JpdHlfam9ic1xuICArIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5sb3dfcHJpb3JpdHlfam9ic1xuOztcblxubGV0IGxhc3RfY3ljbGVfbnVtX2pvYnMgdCA9IHQubGFzdF9jeWNsZV9udW1fam9ic1xuXG5sZXQgdW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsIH5zdWJsaXN0OnNtYWxsIGxhcmdlID1cbiAgbGV0IHJlbW92ZSBsIHggPVxuICAgIG1hdGNoIExpc3Quc3BsaXRfd2hpbGUgbCB+ZjooZnVuIHkgLT4gbm90IChlcXVhbCB5IHgpKSB3aXRoXG4gICAgfCBfLCBbXSAtPiBOb25lXG4gICAgfCBsLCBfIDo6IHIgLT4gU29tZSAobCBAIHIpXG4gIGluXG4gIE9wdGlvbi5pc19zb21lXG4gICAgKExpc3QuZm9sZCBzbWFsbCB+aW5pdDooU29tZSBsYXJnZSkgfmY6KGZ1biBhY2MgeCAtPlxuICAgICAgIE9wdGlvbi5iaW5kIGFjYyB+ZjooZnVuIGwgLT4gcmVtb3ZlIGwgeCkpKVxuOztcblxubGV0IGNoZWNrX2hvb2tfdGFibGVfaW52YXJpYW50IHRhYmxlIGxpc3QgPVxuICAoKiBZb3UgY2FuIGluIGZhY3QgaGF2ZSBob29rcyBpbiB0aGUgbGlzdCBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBlbnRyeSBpblxuICAgICB0aGUgdGFibGUuIFN1Y2ggaG9va3MgY2FuIG5ldmVyIGJlIHJlbW92ZWQuICopXG4gIGFzc2VydCAodW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsOnBoeXNfZXF1YWwgfnN1Ymxpc3Q6KEhhc2h0YmwuZGF0YSB0YWJsZSkgbGlzdClcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y2hlY2tfYWNjZXNzOmlnbm9yZVxuICAgICAgfmpvYl9wb29sOihjaGVjayBKb2JfcG9vbC5pbnZhcmlhbnQpXG4gICAgICB+bm9ybWFsX3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+bG93X3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+dmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyczpcbiAgICAgICAgKGNoZWNrIChmdW4gcSAtPiBEZXF1ZS5pdGVyIHEgfmY6VmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLmludmFyaWFudCkpXG4gICAgICB+bWFpbl9leGVjdXRpb25fY29udGV4dDooY2hlY2sgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50KVxuICAgICAgfmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudClcbiAgICAgIH51bmNhdWdodF9leG46XG4gICAgICAgIChjaGVjayAoZnVuIHVuY2F1Z2h0X2V4biAtPlxuICAgICAgICAgICBpZiBpc19zb21lIHVuY2F1Z2h0X2V4biB0aGVuIGFzc2VydCAobnVtX3BlbmRpbmdfam9icyB0ID0gMCkpKVxuICAgICAgfmN5Y2xlX2NvdW50OihjaGVjayAoZnVuIGN5Y2xlX2NvdW50IC0+IGFzc2VydCAoY3ljbGVfY291bnQgPj0gMCkpKVxuICAgICAgfmN5Y2xlX3N0YXJ0Omlnbm9yZVxuICAgICAgfmluX2N5Y2xlOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9zdGFydDppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSAtPlxuICAgICAgICAgICBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudFxuICAgICAgICAgICAgIHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZVxuICAgICAgICAgICAgIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0KSlcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfZW5kOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgLT5cbiAgICAgICAgICAgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQpKVxuICAgICAgfmxhc3RfY3ljbGVfdGltZTppZ25vcmVcbiAgICAgIH50b3RhbF9jeWNsZV90aW1lOmlnbm9yZVxuICAgICAgfmxhc3RfY3ljbGVfbnVtX2pvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGxhc3RfY3ljbGVfbnVtX2pvYnMgLT4gYXNzZXJ0IChsYXN0X2N5Y2xlX251bV9qb2JzID49IDApKSlcbiAgICAgIH50aW1lX3NvdXJjZTpcbiAgICAgICAgKGNoZWNrXG4gICAgICAgICAgIChTeW5jaHJvbm91c190aW1lX3NvdXJjZS5SZWFkX3dyaXRlLmludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIGpvYiAtPlxuICAgICAgICAgICAgICBhc3NlcnQgKFBvb2wucG9pbnRlcl9pc192YWxpZCB0LmpvYl9wb29sIGpvYikpKSlcbiAgICAgIH5leHRlcm5hbF9qb2JzOmlnbm9yZVxuICAgICAgfnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rOmlnbm9yZVxuICAgICAgfmpvYl9xdWV1ZWRfaG9vazppZ25vcmVcbiAgICAgIH5ldmVudF9hZGRlZF9ob29rOmlnbm9yZVxuICAgICAgfnlpZWxkOmlnbm9yZVxuICAgICAgfnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluOmlnbm9yZVxuICAgICAgfmNoZWNrX2ludmFyaWFudHM6aWdub3JlXG4gICAgICB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGU6aWdub3JlXG4gICAgICB+cmVjb3JkX2JhY2t0cmFjZXM6aWdub3JlXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pICh0IDogdCldXG47O1xuXG5sZXQgZnJlZV9qb2IgdCBqb2IgPSBQb29sLmZyZWUgdC5qb2JfcG9vbCBqb2JcblxubGV0IGVucXVldWUgdCAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSBmIGEgPVxuICAoKiBJZiB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLCB3ZSBkb24ndCBhZGQgdGhlIGpvYiwgc2luY2Ugd2UgZG9uJ3Qgd2FudCBhbnkgam9ic1xuICAgICB0byBydW4gb25jZSB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLiAqKVxuICBpZiBpc19ub25lIHQudW5jYXVnaHRfZXhuXG4gIHRoZW4gKFxuICAgIGxldCBwcmlvcml0eSA9IGV4ZWN1dGlvbl9jb250ZXh0LnByaW9yaXR5IGluXG4gICAgbGV0IGpvYl9xdWV1ZSA9XG4gICAgICBtYXRjaCBwcmlvcml0eSB3aXRoXG4gICAgICB8IE5vcm1hbCAtPiB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICAgICB8IExvdyAtPiB0Lmxvd19wcmlvcml0eV9qb2JzXG4gICAgaW5cbiAgICBKb2JfcXVldWUuZW5xdWV1ZSBqb2JfcXVldWUgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgIG1hdGNoIHQuam9iX3F1ZXVlZF9ob29rIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgZiAtPiBmIHByaW9yaXR5KVxuOztcblxubGV0IGVucXVldWVfam9iIHQgam9iIH5mcmVlX2pvYiA9XG4gIGxldCBqb2JfcG9vbCA9IHQuam9iX3Bvb2wgaW5cbiAgZW5xdWV1ZVxuICAgIHRcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MClcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MSlcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50Mik7XG4gIGlmIGZyZWVfam9iIHRoZW4gUG9vbC5mcmVlIHQuam9iX3Bvb2wgam9iXG47O1xuXG5sZXQgaGFuZGxlX2ZpcmVkICh0aW1lX3NvdXJjZSA6IF8gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEudCkgam9iX29yX2V2ZW50ID1cbiAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICB8IEpvYiwgam9iIC0+IGVucXVldWVfam9iIHRpbWVfc291cmNlLnNjaGVkdWxlciBqb2IgfmZyZWVfam9iOnRydWVcbiAgfCBFdmVudCwgZXZlbnQgLT4gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuZmlyZSB0aW1lX3NvdXJjZSBldmVudFxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICBsZXQgcmVjIHQgPVxuICAgIHsgY2hlY2tfYWNjZXNzID0gTm9uZVxuICAgIDsgam9iX3Bvb2wgPSBKb2JfcG9vbC5jcmVhdGUgKClcbiAgICA7IG5vcm1hbF9wcmlvcml0eV9qb2JzID0gSm9iX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgbG93X3ByaW9yaXR5X2pvYnMgPSBKb2JfcXVldWUuY3JlYXRlICgpXG4gICAgOyB2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzID0gRGVxdWUuY3JlYXRlICgpXG4gICAgOyBtYWluX2V4ZWN1dGlvbl9jb250ZXh0ID0gRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgIDsgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbiAgICA7IHVuY2F1Z2h0X2V4biA9IE5vbmVcbiAgICA7IGN5Y2xlX3N0YXJ0ID0gbm93XG4gICAgOyBjeWNsZV9jb3VudCA9IDBcbiAgICA7IGluX2N5Y2xlID0gZmFsc2VcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA9IFtdXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgPSBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlKVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA9IFtdXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZSlcbiAgICA7IGxhc3RfY3ljbGVfdGltZSA9IHNlYyAwLlxuICAgIDsgbGFzdF9jeWNsZV9udW1fam9icyA9IDBcbiAgICA7IHRvdGFsX2N5Y2xlX3RpbWUgPSBzZWMgMC5cbiAgICA7IHRpbWVfc291cmNlXG4gICAgOyBleHRlcm5hbF9qb2JzID0gVGhyZWFkX3NhZmVfcXVldWUuY3JlYXRlICgpXG4gICAgOyB0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayA9IGlnbm9yZVxuICAgIDsgam9iX3F1ZXVlZF9ob29rID0gTm9uZVxuICAgIDsgZXZlbnRfYWRkZWRfaG9vayA9IE5vbmVcbiAgICA7IHlpZWxkID0gQnZhci5jcmVhdGUgKClcbiAgICA7IHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID0gQnZhci5jcmVhdGUgKCkgKCogY29uZmlndXJhdGlvbiAqKVxuICAgIDsgY2hlY2tfaW52YXJpYW50cyA9IEFzeW5jX2tlcm5lbF9jb25maWcuY2hlY2tfaW52YXJpYW50c1xuICAgIDsgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgPVxuICAgICAgICBBc3luY19rZXJuZWxfY29uZmlnLm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlXG4gICAgOyByZWNvcmRfYmFja3RyYWNlcyA9IEFzeW5jX2tlcm5lbF9jb25maWcucmVjb3JkX2JhY2t0cmFjZXNcbiAgICB9XG4gIGFuZCBldmVudHMgPVxuICAgIFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzpBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0Om5vd1xuICBhbmQgdGltZV9zb3VyY2UgOiBfIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnQgPVxuICAgIHsgaWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZC5jcmVhdGUgKClcbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gW11cbiAgICA7IGFtX2FkdmFuY2luZyA9IGZhbHNlXG4gICAgOyBldmVudHNcbiAgICA7IGhhbmRsZV9maXJlZCA9IChmdW4gYWxhcm0gLT4gaGFuZGxlX2ZpcmVkIHRpbWVfc291cmNlIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKVxuICAgIDsgZmlyZWRfZXZlbnRzID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IGlzX3dhbGxfY2xvY2sgPSB0cnVlXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHNjaGVkdWxlciA9IHRcbiAgICB9XG4gIGluXG4gIHRcbjs7XG5cbmxldCBpc19kZWFkIHQgPSBpc19zb21lIHQudW5jYXVnaHRfZXhuXG5sZXQgc2V0X2NoZWNrX2FjY2VzcyB0IGYgPSB0LmNoZWNrX2FjY2VzcyA8LSBmXG5cbmxldCB0X3JlZiA9XG4gIG1hdGNoIFJlc3VsdC50cnlfd2l0aCBjcmVhdGUgd2l0aFxuICB8IE9rIHQgLT4gcmVmIHRcbiAgfCBFcnJvciBleG4gLT5cbiAgICBEZWJ1Zy5sb2cgXCJBc3luYyBjYW5ub3QgY3JlYXRlIGl0cyByYXcgc2NoZWR1bGVyXCIgZXhuIFslc2V4cF9vZjogZXhuXTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBjaGVja19hY2Nlc3MgdCA9XG4gIG1hdGNoIHQuY2hlY2tfYWNjZXNzIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBmIC0+IGYgKClcbjs7XG5cbmxldCB0ICgpID1cbiAgbGV0IHQgPSAhdF9yZWYgaW5cbiAgY2hlY2tfYWNjZXNzIHQ7XG4gIHRcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgPVxuICBpZiB0LnJlY29yZF9iYWNrdHJhY2VzXG4gIHRoZW4gRXhlY3V0aW9uX2NvbnRleHQucmVjb3JkX2JhY2t0cmFjZSB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbiAgZWxzZSB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbjs7XG5cbmxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSB0IHRtcF9jb250ZXh0IH5mIHggPVxuICBsZXQgb2xkX2NvbnRleHQgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgaW5cbiAgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgdG1wX2NvbnRleHQ7XG4gIHByb3RlY3R4IH5mIHggfmZpbmFsbHk6KGZ1biBfIC0+IHNldF9leGVjdXRpb25fY29udGV4dCB0IG9sZF9jb250ZXh0KVxuOztcblxubGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgdCB0bXBfY29udGV4dCB+ZiA9IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxIHQgdG1wX2NvbnRleHQgfmYgKClcblxubGV0IGNyZWF0ZV9qb2IgKHR5cGUgYSkgdCBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBpZiBQb29sLmlzX2Z1bGwgdC5qb2JfcG9vbCB0aGVuIHQuam9iX3Bvb2wgPC0gUG9vbC5ncm93IHQuam9iX3Bvb2w7XG4gIFBvb2wubmV3M1xuICAgIHQuam9iX3Bvb2xcbiAgICBleGVjdXRpb25fY29udGV4dFxuICAgIChPYmoubWFnaWMgKGYgOiBhIC0+IHVuaXQpIDogT2JqLnQgLT4gdW5pdClcbiAgICAoT2JqLnJlcHIgKGEgOiBhKSlcbjs7XG5cbmxldCBnb3RfdW5jYXVnaHRfZXhuIHQgZXhuIHNleHAgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImdvdF91bmNhdWdodF9leG5cIiAoZXhuLCBzZXhwKSBbJXNleHBfb2Y6IEV4bi50ICogU2V4cC50XTtcbiAgTGlzdC5pdGVyIFsgdC5ub3JtYWxfcHJpb3JpdHlfam9iczsgdC5sb3dfcHJpb3JpdHlfam9icyBdIH5mOkpvYl9xdWV1ZS5jbGVhcjtcbiAgdC51bmNhdWdodF9leG4gPC0gU29tZSAoZXhuLCBzZXhwKVxuOztcblxuKCogW3N0YXJ0X2N5Y2xlIHQgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHldIGVuYWJsZXMgc3Vic2VxdWVudCBjYWxscyBvZiBbcnVuX2pvYnNdXG4gICB0byBydW4gdXAgdG8gW21heF9udW1fam9ic19wZXJfcHJpb3JpdHldIGpvYnMgb2YgZWFjaCBwcmlvcml0eSBsZXZlbC4gKilcbmxldCBzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5ID1cbiAgbGV0IG4gPSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5yYXcgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSBpblxuICBKb2JfcXVldWUuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgbjtcbiAgSm9iX3F1ZXVlLnNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0Lmxvd19wcmlvcml0eV9qb2JzIG5cbjs7XG5cbigqIFtydW5fam9icyB0XSByZW1vdmVzIGpvYnMgZnJvbSBbdF0gb25lIGF0IGEgdGltZSBhbmQgcnVucyB0aGVtLCBzdG9wcGluZyBhcyBzb29uXG4gICBhcyBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGlzIHJhaXNlZCwgb3Igd2hlbiBubyBtb3JlIGpvYnMgY2FuIGJlIHJ1biBhdCBhbnkgcHJpb3JpdHksXG4gICBhcyBwZXIgW35tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XS4gKilcbmxldCByZWMgcnVuX2pvYnMgdCA9XG4gIG1hdGNoIEpvYl9xdWV1ZS5ydW5fam9icyB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzIHQgd2l0aFxuICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gIHwgT2sgKCkgLT5cbiAgICAobWF0Y2ggSm9iX3F1ZXVlLnJ1bl9qb2JzIHQubG93X3ByaW9yaXR5X2pvYnMgdCB3aXRoXG4gICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgfCBPayAoKSAtPlxuICAgICAgIGlmIEpvYl9xdWV1ZS5jYW5fcnVuX2Ffam9iIHQubm9ybWFsX3ByaW9yaXR5X2pvYnNcbiAgICAgICB8fCBKb2JfcXVldWUuY2FuX3J1bl9hX2pvYiB0Lmxvd19wcmlvcml0eV9qb2JzXG4gICAgICAgdGhlbiBydW5fam9icyB0XG4gICAgICAgZWxzZSBPayAoKSlcbjs7XG5cbmxldCBzdGFiaWxpemUgdCA9XG4gIHN0YXJ0X2N5Y2xlXG4gICAgdFxuICAgIH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5OlxuICAgICAgKE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLmNyZWF0ZV9leG4gSW50Lm1heF92YWx1ZSk7XG4gIG1hdGNoIHJ1bl9qb2JzIHQgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGV4biwgX2JhY2t0cmFjZSkgLT4gRXJyb3IgZXhuXG47O1xuXG5sZXQgY3JlYXRlX3RpbWVfc291cmNlXG4gICAgICA/KHRpbWluZ193aGVlbF9jb25maWcgPSBBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcpXG4gICAgICB+bm93XG4gICAgICAoKVxuICA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBsZXQgZXZlbnRzID0gVGltaW5nX3doZWVsLmNyZWF0ZSB+Y29uZmlnOnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0Om5vdyBpblxuICBsZXQgcmVjIHRpbWVfc291cmNlIDogXyBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50ID1cbiAgICB7IGlkID0gVHlwZXMuVGltZV9zb3VyY2VfaWQuY3JlYXRlICgpXG4gICAgOyBhZHZhbmNlX2Vycm9ycyA9IFtdXG4gICAgOyBhbV9hZHZhbmNpbmcgPSBmYWxzZVxuICAgIDsgZXZlbnRzXG4gICAgOyBoYW5kbGVfZmlyZWQgPSAoZnVuIGFsYXJtIC0+IGhhbmRsZV9maXJlZCB0aW1lX3NvdXJjZSAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSlcbiAgICA7IGZpcmVkX2V2ZW50cyA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBpc193YWxsX2Nsb2NrID0gZmFsc2VcbiAgICA7IG1vc3RfcmVjZW50bHlfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgc2NoZWR1bGVyID0gdFxuICAgIH1cbiAgaW5cbiAgdGltZV9zb3VyY2Vcbjs7XG5cbmxldCB3YWxsX2Nsb2NrICgpID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UucmVhZF9vbmx5ICh0ICgpKS50aW1lX3NvdXJjZVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxubW9kdWxlIENlbGwgPSBUeXBlcy5DZWxsXG5cbnR5cGUgYW55ID1cbiAgWyBgRW1wdHlcbiAgfCBgRW1wdHlfb25lX2hhbmRsZXJcbiAgfCBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgfCBgRnVsbFxuICB8IGBJbmRpclxuICBdXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLkl2YXIudCA9IHsgbXV0YWJsZSBjZWxsIDogKCdhLCBhbnkpIGNlbGwgfVxuXG4oKiBUaGUgWydiXSBpcyB1c2VkIHRvIGVuY29kZSB0aGUgY29uc3RydWN0b3IuICBUaGlzIGFsbG93cyB1cyB0byB3cml0ZSBmdW5jdGlvbnMgdGhhdFxuICAgdGFrZSBvbmx5IG9uZSBvZiB0aGUgY29uc3RydWN0b3JzLCB3aXRoIG5vIHJ1bnRpbWUgdGVzdC5cblxuICAgV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHRoZSBkaXJlY3RlZCBncmFwaCB3aXRoIGl2YXJzIGFzIG5vZGVzIGFuZCBbSW5kaXJdcyBhc1xuICAgZWRnZXMgaXMgYWN5Y2xpYy4gIFRoZSBvbmx5IGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBhbiBbSW5kaXJdIGFyZSBbc3F1YXNoXSBhbmRcbiAgIFtjb25uZWN0XSwgYW5kIGZvciB0aG9zZSwgdGhlIHRhcmdldCBvZiB0aGUgW0luZGlyXSBpcyBhbHdheXMgYSBub24tW0luZGlyXS4gIFRodXMsIHRoZVxuICAgbmV3bHkgYWRkZWQgZWRnZXMgYXJlIG5ldmVyIHBhcnQgb2YgYSBjeWNsZS4gKilcbmFuZCAoJ2EsICdiKSBjZWxsID0gKCdhLCAnYikgVHlwZXMuQ2VsbC50ID1cbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyA6XG4gICAgICB7ICgqIFtydW5dIGlzIG11dGFibGUgc28gd2UgY2FuIHNldCBpdCB0byBbaWdub3JlXSB3aGVuIHRoZSBoYW5kbGVyIGlzIHJlbW92ZWQuXG4gICAgICAgICAgIFRoaXMgaXMgdXNlZCB3aGVuIHdlIGluc3RhbGwgYSBoYW5kbGVyIG9uIGEgZnVsbCBpdmFyIHNpbmNlIGl0IGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgIGFkZGVkIHRvIHRoZSBzY2hlZHVsZXIuICopXG4gICAgICAgIG11dGFibGUgcnVuIDogJ2EgLT4gdW5pdFxuICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIDsgKCogW3ByZXZdIGFuZCBbbmV4dF0gY2lyY3VsYXJseSBkb3VibHkgbGluayBhbGwgaGFuZGxlcnMgb2YgdGhlIHNhbWUgaXZhci4gKilcbiAgICAgICAgbXV0YWJsZSBwcmV2IDogKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG4gICAgICA7IG11dGFibGUgbmV4dCA6ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICAgICAgfVxuICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICB8IEVtcHR5X29uZV9oYW5kbGVyIDpcbiAgICAgICgnYSAtPiB1bml0KSAqIEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9oYW5kbGVyIF0pIGNlbGxcbiAgfCBFbXB0eSA6ICgnYSwgWz4gYEVtcHR5IF0pIGNlbGxcbiAgfCBGdWxsIDogJ2EgLT4gKCdhLCBbPiBgRnVsbCBdKSBjZWxsXG4gIHwgSW5kaXIgOiAnYSB0IC0+ICgnYSwgWz4gYEluZGlyIF0pIGNlbGxcblxubW9kdWxlIEhhbmRsZXIgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG5cbiAgbGV0IHJ1biAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0LnJ1blxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5leGVjdXRpb25fY29udGV4dFxuICBsZXQgcHJldiAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0LnByZXZcbiAgbGV0IG5leHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5uZXh0XG4gIGxldCBzZXRfcnVuIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5ydW4gPC0geFxuICBsZXQgc2V0X3ByZXYgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpIHggPSB0LnByZXYgPC0geFxuICBsZXQgc2V0X25leHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpIHggPSB0Lm5leHQgPC0geFxuXG4gIGxldCBjcmVhdGUgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICAoKiBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2Y6XG5cbiAgICAgICB7W1xuICAgICAgICAgbGV0IHJlYyB0ID1cbiAgICAgICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgICAgICB7IHJ1blxuICAgICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHRcbiAgICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdFxuICAgICAgICAgICAgIDsgbmV4dCAgICAgICAgICAgICAgPSB0IH1cbiAgICAgICAgIGluXG4gICAgICAgICBoMSBdfVxuXG4gICAgICAgSG93ZXZlciB0aGUgY29tcGlsYXRpb24gb2YgcmVjdXJzaXZlIHZhbHVlIGluIE9DYW1sIGlzIG5vdCBvcHRpbWFsOiB0aGUgdmFsdWUgaXNcbiAgICAgICBhbGxvY2F0ZWQgdHdpY2UgYW5kIGNvcGllZCBvbmNlICh3aXRoIGEgbG9vcCBjYWxsaW5nIGNhbWxfbW9kaWZ5KS4gIFRoaXMgaXMgbm90XG4gICAgICAgbmVjZXNzYXJ5IGZvciBzaW1wbGUgcmVjdXJzaXZlIGRlZmluaXRpb25zIGxpa2UgdGhpcyBvbmUuXG5cbiAgICAgICBJbnN0ZWFkIHdlIGFsbG9jYXRlIHRoZSB2YWx1ZSB3aXRoIGR1bW15IGZpZWxkcyBhbmQgdXBkYXRlIHRoZW0gYWZ0ZXIuICopXG4gICAgbGV0IHQgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW47IGV4ZWN1dGlvbl9jb250ZXh0OyBwcmV2ID0gT2JqLm1hZ2ljIE5vbmU7IG5leHQgPSBPYmoubWFnaWMgTm9uZSB9XG4gICAgaW5cbiAgICBzZXRfcHJldiB0IHQ7XG4gICAgc2V0X25leHQgdCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlMiBydW4xIGV4ZWN1dGlvbl9jb250ZXh0MSBydW4yIGV4ZWN1dGlvbl9jb250ZXh0MiA9XG4gICAgKCogQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mOlxuXG4gICAgICAge1tcbiAgICAgICAgIGxldCByZWMgdDEgPVxuICAgICAgICAgICB7IHJ1biAgICAgICAgICAgICAgID0gcnVuMVxuICAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gZXhlY3V0aW9uX2NvbnRleHQxXG4gICAgICAgICAgIDsgcHJldiAgICAgICAgICAgICAgPSB0MlxuICAgICAgICAgICA7IG5leHQgICAgICAgICAgICAgID0gdDIgfVxuICAgICAgICAgYW5kIHQyID1cbiAgICAgICAgICAgeyBydW4gICAgICAgICAgICAgICA9IHJ1bjJcbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MlxuICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdDFcbiAgICAgICAgICAgOyBuZXh0ICAgICAgICAgICAgICA9IHQxIH1cbiAgICAgICAgIGluXG4gICAgICAgICB0MSBdfSAqKVxuICAgIGxldCB0MSA9XG4gICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgICAgICB7IHJ1biA9IHJ1bjFcbiAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MVxuICAgICAgICA7IHByZXYgPSBPYmoubWFnaWMgTm9uZVxuICAgICAgICA7IG5leHQgPSBPYmoubWFnaWMgTm9uZVxuICAgICAgICB9XG4gICAgaW5cbiAgICBsZXQgdDIgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW4gPSBydW4yOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MjsgcHJldiA9IHQxOyBuZXh0ID0gdDEgfVxuICAgIGluXG4gICAgc2V0X3ByZXYgdDEgdDI7XG4gICAgc2V0X25leHQgdDEgdDI7XG4gICAgdDFcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCAoZXhlY3V0aW9uX2NvbnRleHQgdCk7XG4gICAgbGV0IHIgPSByZWYgKG5leHQgdCkgaW5cbiAgICB3aGlsZSBub3QgKHBoeXNfZXF1YWwgIXIgdCkgZG9cbiAgICAgIGxldCB0MSA9ICFyIGluXG4gICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgKHByZXYgKG5leHQgdDEpKSB0MSk7XG4gICAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgKGV4ZWN1dGlvbl9jb250ZXh0IHQxKTtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaXNfc2luZ2xldG9uIHQgPSBwaHlzX2VxdWFsIHQgKG5leHQgdClcblxuICBsZXQgbGVuZ3RoIHQgPVxuICAgIGxldCBuID0gcmVmIDEgaW5cbiAgICBsZXQgciA9IHJlZiAobmV4dCB0KSBpblxuICAgIHdoaWxlIG5vdCAocGh5c19lcXVhbCAhciB0KSBkb1xuICAgICAgaW5jciBuO1xuICAgICAgciA6PSBuZXh0ICFyXG4gICAgZG9uZTtcbiAgICAhblxuICA7O1xuXG4gIGxldCBlbnF1ZXVlIHQgc2NoZWR1bGVyIHYgPSBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgKGV4ZWN1dGlvbl9jb250ZXh0IHQpIChydW4gdCkgdlxuXG4gIGxldCBzY2hlZHVsZV9qb2JzIHQgdiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgZW5xdWV1ZSB0IHNjaGVkdWxlciB2O1xuICAgIGxldCByID0gcmVmIChuZXh0IHQpIGluXG4gICAgd2hpbGUgbm90IChwaHlzX2VxdWFsICFyIHQpIGRvXG4gICAgICBlbnF1ZXVlICFyIHNjaGVkdWxlciB2O1xuICAgICAgciA6PSBuZXh0ICFyXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCB1bmxpbmsgdCA9XG4gICAgc2V0X3ByZXYgKG5leHQgdCkgKHByZXYgdCk7XG4gICAgc2V0X25leHQgKHByZXYgdCkgKG5leHQgdCk7XG4gICAgc2V0X3ByZXYgdCB0O1xuICAgIHNldF9uZXh0IHQgdFxuICA7O1xuXG4gIGxldCBhZGQgdCBydW4gZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgIGxldCByZXN1bHQgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgeyBydW47IGV4ZWN1dGlvbl9jb250ZXh0OyBwcmV2ID0gcHJldiB0OyBuZXh0ID0gdCB9XG4gICAgaW5cbiAgICBzZXRfbmV4dCAocHJldiB0KSByZXN1bHQ7XG4gICAgc2V0X3ByZXYgdCByZXN1bHQ7XG4gICAgcmVzdWx0XG4gIDs7XG5cbiAgKCogW3NwbGljZSB0MSB0Ml0gY3JlYXRlczpcblxuICAgICB7dlxuICAgICAgIC0tPiB0MSA8LS0+IC4uLiA8LS0+IGxhc3QxIDwtLT4gdDIgPC0tPiAuLi4gPC0tPiBsYXN0MiA8LS1cbiAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICB2fSAqKVxuICBsZXQgc3BsaWNlIHQxIHQyID1cbiAgICBsZXQgbGFzdDEgPSBwcmV2IHQxIGluXG4gICAgbGV0IGxhc3QyID0gcHJldiB0MiBpblxuICAgIHNldF9uZXh0IGxhc3QxIHQyO1xuICAgIHNldF9uZXh0IGxhc3QyIHQxO1xuICAgIHNldF9wcmV2IHQxIGxhc3QyO1xuICAgIHNldF9wcmV2IHQyIGxhc3QxXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCAocnVuLCBleGVjdXRpb25fY29udGV4dCkgOjogbCAtPlxuICAgICAgbGV0IGZpcnN0ID0gY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCBpblxuICAgICAgbGV0IHJlYyBsb29wIHByZXYgbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+IHNldF9wcmV2IGZpcnN0IHByZXZcbiAgICAgICAgfCAocnVuLCBleGVjdXRpb25fY29udGV4dCkgOjogbCAtPlxuICAgICAgICAgIGxldCB0ID1cbiAgICAgICAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldjsgbmV4dCA9IGZpcnN0IH1cbiAgICAgICAgICBpblxuICAgICAgICAgIHNldF9uZXh0IHByZXYgdDtcbiAgICAgICAgICBsb29wIHQgbFxuICAgICAgaW5cbiAgICAgIGxvb3AgZmlyc3QgbDtcbiAgICAgIFNvbWUgZmlyc3RcbiAgOztcblxuICBsZXQgdG9fbGlzdCBmaXJzdCA9XG4gICAgbGV0IHJlYyBsb29wIHQgYWNjID1cbiAgICAgIGxldCBhY2MgPSAocnVuIHQsIGV4ZWN1dGlvbl9jb250ZXh0IHQpIDo6IGFjYyBpblxuICAgICAgaWYgcGh5c19lcXVhbCB0IGZpcnN0IHRoZW4gYWNjIGVsc2UgbG9vcCAocHJldiB0KSBhY2NcbiAgICBpblxuICAgIGxvb3AgKHByZXYgZmlyc3QpIFtdXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBfICh0IDogXyB0KSA9XG4gICAgbGV0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB7IHJ1biA9IF87IGV4ZWN1dGlvbl9jb250ZXh0OyBuZXh0ID0gXzsgcHJldiA9IF8gfSkgPVxuICAgICAgdFxuICAgIGluXG4gICAgWyVtZXNzYWdlIChleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpXVxuICA7O1xuZW5kXG5cbnR5cGUgJ2EgaXZhciA9ICdhIHRcblxuKCogQ29tcGlsZWQgYXMgdGhlIGlkZW50aXR5LiAqKVxubGV0IGNlbGxfb2ZfaGFuZGxlciA6IF8gSGFuZGxlci50IC0+IF8gPSBmdW5jdGlvblxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgeCAtPiAoeCA6PiAoXywgYW55KSBjZWxsKVxuOztcblxubGV0IGVxdWFsICh0IDogXyB0KSB0JyA9IHBoeXNfZXF1YWwgdCB0J1xubGV0IGluZGlyIHQgPSB7IGNlbGwgPSBJbmRpciB0IH1cblxuaW5jbHVkZSBTY2hlZHVsZXIuSXZhclxuXG4oKiBbc3F1YXNoIHRdIHJldHVybnMgdGhlIG5vbi1bSW5kaXJdIGl2YXIgYXQgdGhlIGVuZCBvZiB0aGUgKHBvc3NpYmx5IGVtcHR5KSBjaGFpbiBvZlxuICAgW0luZGlyXXMgc3RhcnRpbmcgd2l0aCBbdF0gYW5kIGVuc3VyZXMgdGhhdCBhbGwgW0luZGlyXXMgYWxvbmcgdGhhdCBjaGFpbiBhcmUgcmVwbGFjZWRcbiAgIHdpdGggYW4gW0luZGlyXSBwb2ludGluZyB0byB0aGUgZW5kIG9mIHRoZSBjaGFpbi4gKilcbmxldCBzcXVhc2ggPVxuICBsZXQgcmVjIGZvbGxvdyBpbmRpciB0ID1cbiAgICAoKiBbaW5kaXIgPSBJbmRpciB0XSAqKVxuICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgfCBJbmRpciB0JyBhcyBpbmRpcicgLT4gZm9sbG93IGluZGlyJyB0J1xuICAgIHwgXyAtPiBpbmRpclxuICBpblxuICBsZXQgcmVjIHVwZGF0ZSB0IGluZGlyID1cbiAgICBtYXRjaCB0LmNlbGwgd2l0aFxuICAgIHwgSW5kaXIgdCcgLT5cbiAgICAgIHQuY2VsbCA8LSBpbmRpcjtcbiAgICAgIHVwZGF0ZSB0JyBpbmRpclxuICAgIHwgXyAtPiB0XG4gIGluXG4gIGZ1biB0IC0+XG4gICAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgICB8IEluZGlyIHQnIC0+XG4gICAgICAobWF0Y2ggdCcuY2VsbCB3aXRoXG4gICAgICAgfCBJbmRpciB0JycgYXMgaW5kaXIgLT4gdXBkYXRlIHQgKGZvbGxvdyBpbmRpciB0JycpXG4gICAgICAgfCBfIC0+IHQnICgqIG5vdGhpbmcgdG8gZG8sIHNpbmNlIFt0XSBpcyBhIGNoYWluIHdpdGggYSBzaW5nbGUgW0luZGlyXSAqKSlcbiAgICB8IF8gLT4gdFxuOztcblxuKCogbm90aGluZyB0byBkbywgc2luY2UgW3RdIGlzbid0IGFuIFtJbmRpcl0uICopXG5cbmxldCBpbnZhcmlhbnQgYV9pbnZhcmlhbnQgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gYV9pbnZhcmlhbnQgYVxuICB8IEVtcHR5IC0+ICgpXG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgKF8sIGV4ZWN1dGlvbl9jb250ZXh0KSAtPlxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCBleGVjdXRpb25fY29udGV4dFxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPiBIYW5kbGVyLmludmFyaWFudCBoYW5kbGVyXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0IDogU2V4cC50ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBMaXN0IFsgQXRvbSBcIkZ1bGxcIjsgc2V4cF9vZl9hIGEgXVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gQXRvbSBcIkVtcHR5XCJcbjs7XG5cbmxldCBwZWVrIHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IFNvbWUgYVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gTm9uZVxuOztcblxubGV0IHZhbHVlIHQgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGggPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IGFcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+XG4gICAgZmFpbHdpdGggaWZfZW1wdHlfdGhlbl9mYWlsd2l0aFxuOztcblxubGV0IHZhbHVlX2V4biB0ID0gdmFsdWUgdCB+aWZfZW1wdHlfdGhlbl9mYWlsd2l0aDpcIkl2YXIudmFsdWVfZXhuIGNhbGxlZCBvbiBlbXB0eSBpdmFyXCJcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBfIC0+IGZhbHNlXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiB0cnVlXG47O1xuXG5sZXQgaXNfZnVsbCB0ID0gbm90IChpc19lbXB0eSB0KVxuXG5sZXQgZmlsbCB0IHYgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBfIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiSXZhci5maWxsIG9mIGZ1bGwgaXZhclwiICh0IDogXyB0KV1cbiAgfCBFbXB0eSAtPiB0LmNlbGwgPC0gRnVsbCB2XG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIC0+XG4gICAgdC5jZWxsIDwtIEZ1bGwgdjtcbiAgICBTY2hlZHVsZXIuKGVucXVldWUgKHQgKCkpKSBleGVjdXRpb25fY29udGV4dCBydW4gdlxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPlxuICAgIHQuY2VsbCA8LSBGdWxsIHY7XG4gICAgSGFuZGxlci5zY2hlZHVsZV9qb2JzIGhhbmRsZXIgdlxuOztcblxubGV0IHJlbW92ZV9oYW5kbGVyIHQgKGhhbmRsZXIgOiBfIEhhbmRsZXIudCkgPVxuICBIYW5kbGVyLnNldF9ydW4gaGFuZGxlciBpZ25vcmU7XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gLT5cbiAgICAoKiBUaGVzZSBhcmUgb25seSBwb3NzaWJsZSBpZiBbaGFuZGxlcl0gd2FzIGFscmVhZHkgcmVtb3ZlZC4gICopXG4gICAgKClcbiAgfCBGdWxsIF8gLT5cbiAgICAoKiBUaGlzIGlzIHBvc3NpYmxlIGlmIFt0XSB3YXMgZmlsbGVkIGJlZm9yZSB3ZSB0cnkgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLiAgRS5nLlxuICAgICAgIFtEZWZlcnJlZC5jaG9vc2VdIHdpbGwgZG8gdGhpcy4gKilcbiAgICAoKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgY2VsbCAtPlxuICAgIGlmIEhhbmRsZXIuaXNfc2luZ2xldG9uIGhhbmRsZXJcbiAgICB0aGVuIHQuY2VsbCA8LSBFbXB0eVxuICAgIGVsc2UgKFxuICAgICAgaWYgcGh5c19lcXVhbCBoYW5kbGVyIGNlbGwgdGhlbiB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLm5leHQgaGFuZGxlcik7XG4gICAgICBIYW5kbGVyLnVubGluayBoYW5kbGVyKVxuOztcblxubGV0IGFkZF9oYW5kbGVyIHQgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEVtcHR5IC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXI7XG4gICAgaGFuZGxlclxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnIGluXG4gICAgdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyO1xuICAgIGhhbmRsZXJcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT4gSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHRcbiAgfCBGdWxsIHYgLT5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXIuY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCBpblxuICAgICgqIFtydW5dIGNhbGxzIFtoYW5kbGVyLnJ1bl0sIHdoaWNoLCBpZiBbaGFuZGxlcl0gaGFzIGJlZW4gcmVtb3ZlZCwgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgIHRvIFtpZ25vcmVdLiAqKVxuICAgIGxldCBydW4gdiA9IEhhbmRsZXIucnVuIGhhbmRsZXIgdiBpblxuICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2O1xuICAgIGhhbmRsZXJcbjs7XG5cbmxldCBoYXNfaGFuZGxlcnMgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiB0cnVlXG4gIHwgRW1wdHkgfCBGdWxsIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCB1cG9uJyB0IHJ1biA9IGFkZF9oYW5kbGVyIHQgcnVuIFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpXG5cbigqIFt1cG9uXSBpcyBjb25jZXB0dWFsbHkgdGhlIHNhbWUgYXM6XG5cbiAgIHtbXG4gICAgIGxldCB1cG9uIHQgZiA9IGlnbm9yZSAodXBvbicgdCBydW4pIF19XG5cbiAgIEhvd2V2ZXIsIGJlbG93IGlzIGEgbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHdvcnRoIGRvaW5nIGJlY2F1c2UgW3Vwb25dXG4gICBpcyB2ZXJ5IHdpZGVseSB1c2VkIGFuZCBpcyBzbyBtdWNoIG1vcmUgY29tbW9uIHRoYW4gW3Vwb24nXS4gIFRoZSBiZWxvdyBpbXBsZW1lbnRhdGlvblxuICAgYXZvaWRzIHRoZSB1c2Ugb2YgdGhlIGJhZyBvZiBoYW5kbGVycyBpbiB0aGUgZXh0cmVtZWx5IGNvbW1vbiBjYXNlIG9mIG9uZSBoYW5kbGVyIGZvclxuICAgdGhlIGRlZmVycmVkLiAqKVxubGV0IHVwb24gdCBydW4gPVxuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIHYgLT4gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gIHwgRW1wdHkgLT4gdC5jZWxsIDwtIEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KVxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgdC5jZWxsXG4gICAgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPlxuICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHQgOiBfIEhhbmRsZXIudClcbjs7XG5cbigqIFtjb25uZWN0XSB0YWtlcyBpdmFycyBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdLCBhbmQgbWFrZXMgW2JpbmRfcmhzXVxuICAgYmUgYW4gW0luZGlyXSBwb2ludGluZyB0byB0aGUgbm9uLWluZGlyIGNlbGwgcmVhY2hhYmxlIGZyb20gW2JpbmRfcmVzdWx0XS4gIE9uIGVudHJ5XG4gICB0byBbY29ubmVjdF0sIFtiaW5kX3Jlc3VsdF0gYW5kIFtiaW5kX3Joc10gbWF5IGJlIGNoYWlucywgc2luY2UgW2JpbmRfcmhzXSBpcyBhblxuICAgYXJiaXRyYXJ5IHVzZXItc3VwcGxpZWQgZGVmZXJyZWQsIGFuZCBbYmluZF9yZXN1bHRdIGlzIHJldHVybmVkIHRvIHRoZSB1c2VyIHByaW9yIHRvXG4gICBiZWluZyBbY29ubmVjdF1lZCwgYW5kIG1heSBoYXZlIGJlZW4gY29udmVydGVkIHRvIGFuIGluZGlyZWN0aW9uIGluIHRoZSBjYXNlIG9mXG4gICByaWdodC1uZXN0ZWQgYmluZHMuXG5cbiAgIFRoZSBwdXJwb3NlIG9mIFtjb25uZWN0XSBpcyB0byBtYWtlIHRhaWwtcmVjdXJzaXZlIGJpbmQgbG9vcHMgdXNlIGNvbnN0YW50IHNwYWNlLlxuICAgRS5nLjpcblxuICAge1tcbiAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgIGlmIGkgPSAwXG4gICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgICBlbHNlIChcbiAgICAgICAgIGxldCViaW5kICgpID0gYWZ0ZXIgKHNlYyAxLikgaW5cbiAgICAgICAgIGxvb3AgKGkgLSAxKSkgXX1cblxuICAgW2Nvbm5lY3RdIG1ha2VzIGludGVybWVkaWF0ZSBiaW5kIHJlc3VsdHMgYWxsIGJlIFtJbmRpcl1zIHBvaW50aW5nIGF0IHRoZSBvdXRlcm1vc3RcbiAgIGJpbmQsIHJhdGhlciB0aGFuIGJlaW5nIGEgbGluZWFyLWxlbmd0aCBjaGFpbiwgd2l0aCBlYWNoIHBvaW50aW5nIHRvIHRoZSBwcmV2aW91cyBvbmUuXG4gICBUaGVuLCBzaW5jZSB0aGUgcHJvZ3JhbSBpcyBvbmx5IGhvbGRpbmcgb24gdG8gdGhlIGlubmVybW9zdCBhbmQgb3V0ZXJtb3N0IGJpbmRzIGFsbCB0aGVcbiAgIGludGVybWVkaWF0ZSBvbmVzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICAgW2Nvbm5lY3RdIHdvcmtzIGJ5IHNxdWFzaGluZyBpdHMgYXJndW1lbnRzIHNvIHRoYXQgdGhlIFtiaW5kX3Joc10gYWx3YXlzIHBvaW50cyBhdCB0aGVcbiAgIHVsdGltYXRlIHJlc3VsdC4gKilcbmxldCBjb25uZWN0ID1cbiAgKCogW3JlcG9pbnRfaW5kaXJzIH5pdmFyIH5pbmRpciB+YmluZF9yZXN1bHRdIHJlcG9pbnRzIHRvIFtpbmRpcl0gYWxsIHRoZSBpdmFycyBpbiB0aGVcbiAgICAgY2hhaW4gcmVhY2hhYmxlIGZyb20gW2l2YXJdLCBhbmQgcmV0dXJucyB0aGUgbm9uLVtJbmRpcl0gY2VsbCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICBjaGFpbi4gIEFmdGVyIHJlcG9pbnRpbmcsIHdlIHdpbGwgbWVyZ2UgdGhlIGhhbmRsZXJzIGluIHRoYXQgY2VsbCB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICBpbiBbYmluZF9yZXN1bHRdLCBhbmQgcHV0IHRoZSBtZXJnZWQgc2V0IG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0uICopXG4gIGxldCByZWMgcmVwb2ludF9pbmRpcnMgfml2YXIgfmluZGlyIH5iaW5kX3Jlc3VsdCA9XG4gICAgbGV0IGNlbGwgPSBpdmFyLmNlbGwgaW5cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IEluZGlyIGl2YXInIC0+XG4gICAgICBpdmFyLmNlbGwgPC0gaW5kaXI7XG4gICAgICByZXBvaW50X2luZGlycyB+aXZhcjppdmFyJyB+aW5kaXIgfmJpbmRfcmVzdWx0XG4gICAgfCBGdWxsIF8gLT4gY2VsbFxuICAgIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPlxuICAgICAgKCogSXQgaXMgcG9zc2libGUgdGhhdCBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdIGFyZSBub3QgZXF1YWwsIGJ1dCB0aGVpciBjaGFpbnNcbiAgICAgICAgIG9mIGluZGlycyBsZWFkIHRvIHRoZSBzYW1lIG5vbi1bSW5kaXJdIGNlbGwsIGluIHdoaWNoIGNhc2Ugd2UgY2Fubm90IHNldCB0aGF0XG4gICAgICAgICBjZWxsIHRvIHBvaW50IHRvIGl0c2VsZiwgYmVjYXVzZSB0aGF0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xlLiAqKVxuICAgICAgaWYgbm90IChwaHlzX2VxdWFsIGl2YXIgYmluZF9yZXN1bHQpIHRoZW4gaXZhci5jZWxsIDwtIGluZGlyO1xuICAgICAgY2VsbFxuICBpblxuICBmdW4gfmJpbmRfcmVzdWx0IH5iaW5kX3JocyAtPlxuICAgIGlmIG5vdCAocGh5c19lcXVhbCBiaW5kX3Jlc3VsdCBiaW5kX3JocylcbiAgICB0aGVuIChcbiAgICAgIGxldCBiaW5kX3Jlc3VsdCA9IHNxdWFzaCBiaW5kX3Jlc3VsdCBpblxuICAgICAgbGV0IGluZGlyID0gSW5kaXIgYmluZF9yZXN1bHQgaW5cbiAgICAgIGxldCBiaW5kX3Joc19jb250ZW50cyA9IHJlcG9pbnRfaW5kaXJzIH5pdmFyOmJpbmRfcmhzIH5pbmRpciB+YmluZF9yZXN1bHQgaW5cbiAgICAgICgqIHVwZGF0ZSBbYmluZF9yZXN1bHRdIHdpdGggdGhlIHVuaW9uIG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0gYW5kXG4gICAgICAgICBbYmluZF9yaHNdICopXG4gICAgICBtYXRjaCBiaW5kX3Jlc3VsdC5jZWxsLCBiaW5kX3Joc19jb250ZW50cyB3aXRoXG4gICAgICB8IEluZGlyIF8sIF8gfCBfLCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdIGFuZCBbcmVwb2ludF9pbmRpcnNdICopXG4gICAgICAoKiBbY29ubmVjdF0gaXMgb25seSB1c2VkIGluIGJpbmQsIHdob3NlIGl2YXIgaXMgb25seSBldmVyIGV4cG9ydGVkIGFzIGEgcmVhZC1vbmx5XG4gICAgICAgICBkZWZlcnJlZC4gIFRodXMsIFtiaW5kX3Jlc3VsdF0gbXVzdCBiZSBlbXB0eS4gKilcbiAgICAgIHwgRnVsbCBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBfLCBFbXB0eSAtPiAoKVxuICAgICAgfCBFbXB0eSwgXyAtPiBiaW5kX3Jlc3VsdC5jZWxsIDwtIGJpbmRfcmhzX2NvbnRlbnRzXG4gICAgICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSwgRnVsbCB2IC0+XG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gYmluZF9yaHNfY29udGVudHM7XG4gICAgICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gICAgICB8IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIpLCBGdWxsIHYgLT5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBiaW5kX3Joc19jb250ZW50cztcbiAgICAgICAgSGFuZGxlci5zY2hlZHVsZV9qb2JzIGhhbmRsZXIgdlxuICAgICAgfCAoIEVtcHR5X29uZV9oYW5kbGVyIChydW4xLCBleGVjdXRpb25fY29udGV4dDEpXG4gICAgICAgICwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjIsIGV4ZWN1dGlvbl9jb250ZXh0MikgKSAtPlxuICAgICAgICBsZXQgaGFuZGxlcjEgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgaW5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjFcbiAgICAgIHwgKCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMSlcbiAgICAgICAgLCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMiwgZXhlY3V0aW9uX2NvbnRleHQyKSApIC0+XG4gICAgICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlcjEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgOiBfIEhhbmRsZXIudClcbiAgICAgIHwgKCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMSwgZXhlY3V0aW9uX2NvbnRleHQxKVxuICAgICAgICAsIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIyKSApIC0+XG4gICAgICAgIGxldCBoYW5kbGVyMSA9IEhhbmRsZXIuYWRkIGhhbmRsZXIyIHJ1bjEgZXhlY3V0aW9uX2NvbnRleHQxIGluXG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXIxXG4gICAgICB8ICggKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjEpXG4gICAgICAgICwgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjIpICkgLT4gSGFuZGxlci5zcGxpY2UgaGFuZGxlcjEgaGFuZGxlcjIpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgSXZhciA9IEl2YXIwXG5tb2R1bGUgSGFuZGxlciA9IEl2YXIuSGFuZGxlclxuXG4oKiBEZWZlcnJlZHMgcHJlc2VudCBhIGNvdmFyaWFudCB2aWV3IG9mIGl2YXJzLiAgV2UgY291bGQgYWN0dWFsbHkgaW1wbGVtZW50IGRlZmVycmVkc1xuICAgdXNpbmcgYSByZWNvcmQgb2YgY2xvc3VyZXMsIGFzIGluIHRoZSBbZXNzZW5jZV9vZl9kZWZlcnJlZF0gcmVjb3JkIGJlbG93LCBmb3Igd2hpY2ggdGhlXG4gICBPQ2FtbCB0eXBlIGNoZWNrZXIgY2FuIGluZmVyIGNvdmFyaWFuY2UuICBIb3dldmVyLCBkb2luZyBzbyB3b3VsZCBtYWtlIFtJdmFyLnJlYWRdIHZlcnlcbiAgIGNvc3RseSwgYmVjYXVzZSBpdCB3b3VsZCBoYXZlIHRvIGFsbG9jYXRlIGxvdHMgb2YgY2xvc3VyZXMgYW5kIGEgcmVjb3JkLiAgSW5zdGVhZCBvZlxuICAgZG9pbmcgdGhpcywgd2UgbWFrZSBkZWZlcnJlZHMgYW4gYWJzdHJhY3QgY292YXJpYW50IHR5cGUsIHdoaWNoIGNvbmNyZXRlbHkgaXMganVzdCB0aGVcbiAgIGl2YXIsIGFuZCB1c2UgW09iai5tYWdpY10gdG8gY29udmVydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIGEgZGVmZXJyZWQgYW5kIGl0cyBjb25jcmV0ZVxuICAgcmVwcmVzZW50YXRpb24gYXMgYW4gaXZhci4gIFRoaXMgW09iai5tYWdpY10gaXMgc2FmZSBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpc1xuICAgYWx3YXlzIGp1c3QgYW4gaXZhciwgYW5kIHRoZSBjb3ZhcmlhbmNlIGZvbGxvd3MgZnJvbSB0aGUgZmFjdCB0aGF0IGFsbCB0aGUgZGVmZXJyZWRcbiAgIG9wZXJhdGlvbnMgYXJlIGVxdWl2YWxlbnQgdG8gdGhvc2UgaW1wbGVtZW50ZWQgZGlyZWN0bHkgb24gdG9wIG9mIHRoZVxuICAgW2Vzc2VuY2Vfb2ZfZGVmZXJyZWRdLlxuXG4gICB7W1xuICAgICB0eXBlICgrJ2EsICdleGVjdXRpb25fY29udGV4dCkgZXNzZW5jZV9vZl9kZWZlcnJlZCA9XG4gICAgICAgeyBwZWVrICAgICAgICAgICAgICAgICAgICAgIDogdW5pdCAtPiAnYSBvcHRpb25cbiAgICAgICA7IGlzX2RldGVybWluZWQgICAgICAgICAgICAgOiB1bml0IC0+IGJvb2xcbiAgICAgICA7IHVwb24gICAgICAgICAgICAgICAgICAgICAgOiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgIDsgdXBvbicgICAgICAgICAgICAgICAgICAgICA6ICgnYSAtPiB1bml0KSAtPiBVbnJlZ2lzdGVyLnRcbiAgICAgICA7IGluc3RhbGxfcmVtb3ZhYmxlX2hhbmRsZXIgOiAoJ2EsICdleGVjdXRpb25fY29udGV4dCkgUmF3X2hhbmRsZXIudCAtPiBVbnJlZ2lzdGVyLnQ7IH0gXX0gKilcblxudHlwZSArJ2EgdCA9ICdhIFR5cGVzLkRlZmVycmVkLnRcblxuKCogdGhlIGFic3RyYWN0IGNvdmFyaWFudCB0eXBlLCBlcXVpdmFsZW50IHRvIGl2YXIgKilcblxubGV0IG9mX2l2YXIgKHR5cGUgYSkgKGl2YXIgOiBhIEl2YXIudCkgOiBhIHQgPSBPYmoubWFnaWMgaXZhclxubGV0IHRvX2l2YXIgKHR5cGUgYSkgdCA6IGEgSXZhci50ID0gT2JqLm1hZ2ljICh0IDogYSB0KVxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgKHRvX2l2YXIgdClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBJdmFyLnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX2l2YXIgdClcbmxldCBwZWVrIHQgPSBJdmFyLnBlZWsgKHRvX2l2YXIgdClcbmxldCByZXR1cm4gYSA9IG9mX2l2YXIgKEl2YXIuY3JlYXRlX2Z1bGwgYSlcbmxldCBpc19kZXRlcm1pbmVkIHQgPSBJdmFyLmlzX2Z1bGwgKHRvX2l2YXIgdClcblxubGV0IHZhbHVlX2V4biB0ID1cbiAgSXZhci52YWx1ZVxuICAgICh0b19pdmFyIHQpXG4gICAgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGg6XCJEZWZlcnJlZC52YWx1ZV9leG4gY2FsbGVkIG9uIHVuZGV0ZXJtaW5lZCBkZWZlcnJlZFwiXG47O1xuXG5sZXQgdXBvbiB0IGYgPSBJdmFyLnVwb24gKHRvX2l2YXIgdCkgZlxuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZiByZXN1bHQ7XG4gIG9mX2l2YXIgcmVzdWx0XG47O1xuXG4oKiBkb24ndCB1c2UgW2NyZWF0ZV0gaGVyZSBhcyBpdCB3b3VsZCBhbGxvY2F0ZSBvbmUgbW9yZSBjbG9zdXJlICopXG5sZXQgYmluZCB0IH5mID1cbiAgbGV0IGJpbmRfcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmNvbm5lY3QgfmJpbmRfcmVzdWx0IH5iaW5kX3JoczoodG9faXZhciAoZiBhKSkpO1xuICBvZl9pdmFyIGJpbmRfcmVzdWx0XG47O1xuXG5sZXQgYWRkX2hhbmRsZXIgdCBmIGV4ZWN1dGlvbl9jb250ZXh0ID0gSXZhci5hZGRfaGFuZGxlciAodG9faXZhciB0KSBmIGV4ZWN1dGlvbl9jb250ZXh0XG5sZXQgcmVtb3ZlX2hhbmRsZXIgdCBoID0gSXZhci5yZW1vdmVfaGFuZGxlciAodG9faXZhciB0KSBoXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMFxuaW5jbHVkZSBJdmFyMFxuXG5sZXQgcmVhZCA9IERlZmVycmVkLm9mX2l2YXJcbmxldCBmaWxsX2lmX2VtcHR5IHQgdiA9IGlmIGlzX2VtcHR5IHQgdGhlbiBmaWxsIHQgdlxuXG5pbmNsdWRlXG4gIEJpbmFibGUuT2ZfYmluYWJsZTFfd2l0aG91dF91dWlkIFtAYWxlcnQgXCItbGVnYWN5XCJdXG4gICAgKE9wdGlvbilcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fYmluYWJsZSB0ID0gcGVlayB0XG5cbiAgICAgIGxldCBvZl9iaW5hYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IGNyZWF0ZSAoKVxuICAgICAgICB8IFNvbWUgYSAtPiBjcmVhdGVfZnVsbCBhXG4gICAgICA7O1xuICAgIGVuZClcbiIsIigqKiBbTW9uYWRfc2VxdWVuY2UuU10gaXMgYSBnZW5lcmljIGludGVyZmFjZSBzcGVjaWZ5aW5nIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aCBhXG4gICAgY29udGFpbmVyIGFuZCBhIG1vbmFkLiAgSXQgaXMgc3BlY2lhbGl6ZWQgdG8gdGhlIFtEZWZlcnJlZF0gbW9uYWQgYW5kIHVzZWQgd2l0aFxuICAgIHZhcmlvdXMgY29udGFpbmVycyBpbiBtb2R1bGVzIFtEZWZlcnJlZC5BcnJheV0sIFtEZWZlcnJlZC5MaXN0XSwgW0RlZmVycmVkLlF1ZXVlXSwgYW5kXG4gICAgW0RlZmVycmVkLlNlcXVlbmNlXS4gIFRoZSBbTW9uYWRfc2VxdWVuY2UuaG93XSB0eXBlIHNwZWNpZmllcyB0aGUgcGFyYWxsZWxpc20gb2ZcbiAgICBjb250YWluZXIgaXRlcmF0b3JzLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSBob3cgPVxuICBbIGBQYXJhbGxlbCAoKiogbGlrZSBbYE1heF9jb25jdXJyZW50X2pvYnMgSW50Lm1heF92YWx1ZV0gKilcbiAgfCBgU2VxdWVudGlhbFxuICAoKiogW2BTZXF1ZW50aWFsXSBpcyBvZnRlbiBidXQgbm90IGFsd2F5cyB0aGUgc2FtZSBhcyBbYE1heF9jb25jdXJyZW50X2pvYnMgMV1cbiAgICAgIChmb3IgZXhhbXBsZSwgdGhleSBkaWZmZXIgaW4gdGhlIFtPcl9lcnJvcl0gbW9uYWQpLiAqKVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG9mIGludFxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgbW9uYWRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGZvbGRpIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGludCAtPiAnYiAtPiAnYSAtPiAnYiBtb25hZCkgLT4gJ2IgbW9uYWRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIG1vbmFkXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSAtPiBib29sIG1vbmFkKSAtPiAnYSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gKGludCAqICdhKSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIG9wdGlvbiBtb25hZFxuICB2YWwgZmluZF9tYXBpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiBvcHRpb24gbW9uYWRcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGxpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgYWxsIDogJ2EgbW9uYWQgdCAtPiAnYSB0IG1vbmFkXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgbW9uYWQgdCAtPiB1bml0IG1vbmFkXG5cbiAgKCoqIHsyIERlZmVycmVkIGl0ZXJhdG9yc31cblxuICAgICAgSW4gdGhlIGZvbGxvd2luZywgdGhlIGRlZmF1bHQgW2hvd10gaXMgW2BTZXF1ZW50aWFsXSAqKVxuXG4gIHZhbCBpbml0IDogP2hvdzpob3cgLT4gaW50IC0+IGY6KGludCAtPiAnYSBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgaXRlciA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCBtb25hZCkgLT4gdW5pdCBtb25hZFxuICB2YWwgaXRlcmkgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiB1bml0IG1vbmFkKSAtPiB1bml0IG1vbmFkXG4gIHZhbCBtYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBtYXBpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGZpbHRlciA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgZmlsdGVyaSA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGZpbHRlcl9tYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbiBtb25hZCkgLT4gJ2IgdCBtb25hZFxuICB2YWwgZmlsdGVyX21hcGkgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXBpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2IgdCBtb25hZCkgLT4gJ2IgdCBtb25hZFxuZW5kXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5pbmNsdWRlIERlZmVycmVkMFxuXG4oKiBUbyBhdm9pZCBhIHNwYWNlIGxlYWssIGl0IGlzIG5lY2Vzc2FyeSB0aGF0IFtuZXZlcl0gYWxsb2NhdGVzIGEgbmV3IGl2YXIgd2hlbmV2ZXIgaXQgaXNcbiAgIGNhbGxlZC4gIENvZGUgY2FuIGJpbmQgb24gW25ldmVyICgpXSwgc28gaWYgd2UgcmUtdXNlZCB0aGUgaXZhciwgd2UgY291bGQgZW5kbGVzc2x5XG4gICBhY2N1bXVsYXRlIGhhbmRsZXJzLiAqKVxubGV0IG5ldmVyICgpID0gSXZhci5yZWFkIChJdmFyLmNyZWF0ZSAoKSlcblxubW9kdWxlIE0gPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIERlZmVycmVkMFxuXG4gICAgbGV0IG1hcCB0IH5mID1cbiAgICAgICgqIFdlIG1hbnVhbGx5IGlubGluZSBbRGVmZXJyZWQuY3JlYXRlXSBoZXJlLCBiZWNhdXNlIHRoZSBub24tZmxhbWJkYSBjb21waWxlciBpc24ndFxuICAgICAgICAgYWJsZSB0byBvcHRpbWl6ZSBhd2F5IHRoZSBjbG9zdXJlIHRoYXQgd291bGQgYmUgYmUgY3JlYXRlZC4gKilcbiAgICAgIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmZpbGwgcmVzdWx0IChmIGEpKTtcbiAgICAgIG9mX2l2YXIgcmVzdWx0XG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbmluY2x1ZGUgTVxuXG4oKiBXZSByZWJpbmQgYWxsIHRoZSB2YXJpb3VzIFtyZXR1cm5dcyBiZWNhdXNlIHRoZSB1c2Ugb2YgdGhlIFtNb25hZC5NYWtlXSBmdW5jdG9yXG4gICBjYXVzZXMgdGhlIGNvbXBpbGVyIHRvIG5vdCBpbmxpbmUgW3JldHVybl0sIGFuZCBoZW5jZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvXG4gICBzdGF0aWNhbGx5IGFsbG9jYXRlIGNvbnN0YW50cyBsaWtlIFtyZXR1cm4gKCldLiAgQnkgcmViaW5kaW5nIFtyZXR1cm5dIGFzXG4gICBbRGVmZXJyZWQwLnJldHVybl0sIHRoZSBjb21waWxlciBjYW4gc2VlIHRoYXQ6XG5cbiAgIHtbXG4gICAgIHJldHVybiBhID0geyBJdmFyLkltbXV0YWJsZS4gY2VsbCA9IEZ1bGwgYSB9IF19XG5cbiAgIEFuZCBoZW5jZSwgaWYgW2FdIGlzIGNvbnN0YW50LCB0aGVuIHRoZSByZXR1cm4gaXMgY29uc3RhbnQgYW5kIGNhbiBiZSBzdGF0aWNhbGx5XG4gICBhbGxvY2F0ZWQuICBXaGVuIGNvbXBpbGluZyB3aXRoIGZsYW1iZGEsIHRoZSBjb21waWxlciBpbmxpbmVzIFtyZXR1cm5dIGFuZCB0aGlzIG1hbnVhbFxuICAgcmViaW5kaW5nIHdvdWxkIG5vdCBoZWxwOyB3ZSd2ZSBkZWNpZGVkIHRvIGRvIGl0IGFueXdheSBzbyB0aGF0IG5vbi1mbGFtYmRhIGJ1aWxkc1xuICAgZ2V0IHRoZSBvcHRpbWl6YXRpb24uICopXG5sZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBpbmNsdWRlIE0uTGV0X3N5bnRheFxuXG4gIGxldCByZXR1cm4gPSBEZWZlcnJlZDAucmV0dXJuXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIE0uTGV0X3N5bnRheC5MZXRfc3ludGF4XG5cbiAgICBsZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuICBlbmRcbmVuZFxuXG5vcGVuIExldF9zeW50YXhcblxuKCogV2Ugc2hhZG93IFthbGxdIG9uLXB1cnBvc2UgaGVyZSwgc2luY2UgdGhlIGRlZmF1bHQgZGVmaW5pdGlvbiBpbnRyb2R1Y2VzIGEgY2hhaW4gb2ZcbiAgIGJpbmRzIGFzIGxvbmcgYXMgdGhlIGxpc3QuICopXG5sZXQgYWxsID0gYE1ha2Vfc3VyZV90b19kZWZpbmVfYWxsX2Vsc2V3aGVyZVxubGV0IF8gPSBhbGxcbmxldCB1bml0ID0gcmV0dXJuICgpXG5cbmxldCBib3RoIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gcmVzdWx0IC0+IHVwb24gdDEgKGZ1biBhMSAtPiB1cG9uIHQyIChmdW4gYTIgLT4gSXZhci5maWxsIHJlc3VsdCAoYTEsIGEyKSkpKVxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBsZXQgKCA+Pj4gKSA9IHVwb25cbiAgbGV0IHBweF9ib3RoID0gYm90aFxuZW5kXG5cbm9wZW4gSW5maXhcblxubGV0IGRvbid0X3dhaXRfZm9yIChfIDogdW5pdCB0KSA9ICgpXG5cbm1vZHVsZSBDaG9pY2UgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdCA9IFQgOiAnYiBEZWZlcnJlZDAudCAqICgnYiAtPiAnYSkgLT4gJ2EgdFxuXG4gIGxldCBtYXAgKFQgKHQsIGYxKSkgfmY6ZjIgPSBUICh0LCBmdW4geCAtPiBmMiAoZjEgeCkpXG5lbmRcblxubW9kdWxlIFVucmVnaXN0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhpcyByZXByZXNlbnRhdGlvbiBzYXZlcyAybiB3b3JkcyBmb3IgYSBsaXN0IG9mIG4gY2hvaWNlcy4gKilcbiAgdHlwZSB0ID1cbiAgICB8IE5pbCA6IHRcbiAgICB8IENvbnMgOiAnYSBEZWZlcnJlZDAudCAqICdhIERlZmVycmVkMC5IYW5kbGVyLnQgKiB0IC0+IHRcblxuICBsZXQgcmVjIHByb2Nlc3MgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh0LCBoYW5kbGVyLCByZXN0KSAtPlxuICAgICAgcmVtb3ZlX2hhbmRsZXIgdCBoYW5kbGVyO1xuICAgICAgcHJvY2VzcyByZXN0XG4gIDs7XG5lbmRcblxubGV0IGNob2ljZSB0IGYgPSBDaG9pY2UuVCAodCwgZilcblxubGV0IGVuYWJsZWQgY2hvaWNlcyA9XG4gIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgdW5yZWdpc3RlcnMgPSByZWYgVW5yZWdpc3Rlci5OaWwgaW5cbiAgbGV0IHJlYWR5IF8gPVxuICAgIGlmIEl2YXIuaXNfZW1wdHkgcmVzdWx0XG4gICAgdGhlbiAoXG4gICAgICBVbnJlZ2lzdGVyLnByb2Nlc3MgIXVucmVnaXN0ZXJzO1xuICAgICAgSXZhci5maWxsIHJlc3VsdCAoZnVuICgpIC0+XG4gICAgICAgIExpc3QucmV2XG4gICAgICAgICAgKExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OltdIH5mOihmdW4gYWMgKENob2ljZS5UICh0LCBmKSkgLT5cbiAgICAgICAgICAgICBtYXRjaCBwZWVrIHQgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBhY1xuICAgICAgICAgICAgIHwgU29tZSB2IC0+IGYgdiA6OiBhYykpKSlcbiAgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkgaW5cbiAgdW5yZWdpc3RlcnNcbiAgOj0gTGlzdC5mb2xkIGNob2ljZXMgfmluaXQ6VW5yZWdpc3Rlci5OaWwgfmY6KGZ1biBhY2MgKENob2ljZS5UICh0LCBfKSkgLT5cbiAgICBDb25zICh0LCBEZWZlcnJlZDAuYWRkX2hhbmRsZXIgdCByZWFkeSBleGVjdXRpb25fY29udGV4dCwgYWNjKSk7XG4gIEl2YXIucmVhZCByZXN1bHRcbjs7XG5cbmxldCByZWMgY2hvb3NlX3Jlc3VsdCBjaG9pY2VzID1cbiAgbWF0Y2ggY2hvaWNlcyB3aXRoXG4gIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ2hvaWNlLlQgKHQsIGYpIDo6IGNob2ljZXMgLT5cbiAgICAobWF0Y2ggcGVlayB0IHdpdGhcbiAgICAgfCBOb25lIC0+IGNob29zZV9yZXN1bHQgY2hvaWNlc1xuICAgICB8IFNvbWUgdiAtPiBmIHYpXG47O1xuXG5sZXQgY2hvb3NlIGNob2ljZXMgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHVucmVnaXN0ZXJzID0gcmVmIFVucmVnaXN0ZXIuTmlsIGluXG4gIGxldCByZWFkeSBfID1cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgVW5yZWdpc3Rlci5wcm9jZXNzICF1bnJlZ2lzdGVycztcbiAgICAgIEl2YXIuZmlsbCByZXN1bHQgKGNob29zZV9yZXN1bHQgY2hvaWNlcykpXG4gIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGluXG4gIHVucmVnaXN0ZXJzXG4gIDo9IExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OlVucmVnaXN0ZXIuTmlsIH5mOihmdW4gYWNjIChDaG9pY2UuVCAodCwgXykpIC0+XG4gICAgQ29ucyAodCwgRGVmZXJyZWQwLmFkZF9oYW5kbGVyIHQgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQsIGFjYykpO1xuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG5sZXQgYW55X2YgdHMgZiA9IGNob29zZSAoTGlzdC5tYXAgdHMgfmY6KGZ1biB0IC0+IGNob2ljZSB0IGYpKVxubGV0IGFueSB0cyA9IGFueV9mIHRzIEZuLmlkXG5sZXQgYW55X3VuaXQgdHMgPSBhbnlfZiB0cyAoRm4uaWdub3JlIDogdW5pdCAtPiB1bml0KVxuXG5sZXQgZm9yXyBzdGFydCB+dG9fIH5kb18gPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+IHRvX1xuICAgIHRoZW4gcmV0dXJuICgpXG4gICAgZWxzZSAoXG4gICAgICBsZXQlYmluZCAoKSA9IGRvXyBpIGluXG4gICAgICBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3Agc3RhcnRcbjs7XG5cbmxldCByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZiA9XG4gIGNyZWF0ZSAoZnVuIGZpbmlzaGVkIC0+XG4gICAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICAgIGYgc3RhdGVcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBgUmVwZWF0IHN0YXRlIC0+IGxvb3Agc3RhdGVcbiAgICAgIHwgYEZpbmlzaGVkIHJlc3VsdCAtPiBJdmFyLmZpbGwgZmluaXNoZWQgcmVzdWx0XG4gICAgaW5cbiAgICBsb29wIHN0YXRlKVxuOztcblxubGV0IGZvcmV2ZXIgc3RhdGUgZiA9XG4gIHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSAoZnVuIHN0YXRlIC0+XG4gICAgbGV0JW1hcCBzdGF0ZSA9IGYgc3RhdGUgaW5cbiAgICBgUmVwZWF0IHN0YXRlKVxuICA+Pj4gbmV2ZXJfcmV0dXJuc1xuOztcblxudHlwZSBob3cgPSBNb25hZF9zZXF1ZW5jZS5ob3cgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIHR5cGUgTW9uYWRfc2VxdWVuY2UgPSBNb25hZF9zZXF1ZW5jZS5TIHdpdGggdHlwZSAnYSBtb25hZCA6PSAnYSB0XG5cblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgfCB4IDo6IHhzIC0+IGYgYiB4ID4+PiBmdW4gYiAtPiBsb29wIHhzIGJcbiAgICBpblxuICAgIGxvb3AgdCBpbml0KVxuOztcblxubGV0IHNlcW1hcCB0IH5mID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYnMgYSAtPiBmIGEgPj58IGZ1biBiIC0+IGIgOjogYnMpID4+fCBMaXN0LnJldlxubGV0IGFsbCBkcyA9IHNlcW1hcCBkcyB+ZjpGbi5pZFxubGV0IGFsbF91bml0IGRzID0gZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZClcbmxldCBvayB4ID0geCA+PnwgZnVuIHggLT4gT2sgeFxuIiwib3BlbiBEZWZlcnJlZDFcbmluY2x1ZGUgSW5maXhcbmluY2x1ZGUgTGV0X3N5bnRheFxuXG5sZXQgY2hvaWNlID0gY2hvaWNlXG5sZXQgY2hvb3NlID0gY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBkb24ndF93YWl0X2ZvclxubGV0IG5ldmVyID0gbmV2ZXJcbmxldCByZXR1cm4gPSByZXR1cm5cbmxldCB1cG9uID0gdXBvblxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdSA9XG4gIHwgRW1wdHkgb2YgJ2EgSXZhci50XG4gIHwgRnVsbFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSAnYSB0ID0gJ2EgdSByZWYgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IEZ1bGwgLT4gKClcbiAgICB8IEVtcHR5IGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKVxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHQgPSByZWYgKEVtcHR5IGl2YXIpIGluXG4gIHQsIEl2YXIucmVhZCBpdmFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIG1hdGNoICF0IHdpdGhcbiAgfCBFbXB0eSBfIC0+IHRydWVcbiAgfCBGdWxsIC0+IGZhbHNlXG47O1xuXG5sZXQgZmlsbCB0IGEgPVxuICBtYXRjaCAhdCB3aXRoXG4gIHwgRW1wdHkgaSAtPlxuICAgIHQgOj0gRnVsbDtcbiAgICBJdmFyLmZpbGwgaSBhXG4gIHwgRnVsbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcImF0dGVtcHQgdG8gZmlsbCBmdWxsIGl2YXJcIl1cbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgU3RyZWFtID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG5leHQgRGVmZXJyZWQudFxuXG4gIGFuZCAnYSBuZXh0ID0gJ2EgVHlwZXMuU3RyZWFtLm5leHQgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mICdhICogJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGxldCByZWMgbG9vcCBkIGFjIDogU2V4cC50ID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgICB8IE5vbmUgLT4gTGlzdCAoTGlzdC5yZXYgKFNleHAuQXRvbSBcIi4uLlwiIDo6IGFjKSlcbiAgICAgIHwgU29tZSBOaWwgLT4gTGlzdCAoTGlzdC5yZXYgYWMpXG4gICAgICB8IFNvbWUgKENvbnMgKGEsIHQpKSAtPiBsb29wIHQgKHNleHBfb2ZfYSBhIDo6IGFjKVxuICAgIGluXG4gICAgbG9vcCB0IFtdXG4gIDs7XG5cbiAgbGV0IG5leHQgdCA9IHRcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5UYWlsLnQgPVxuICB7ICgqIFtuZXh0XSBwb2ludHMgYXQgdGhlIHRhaWwgb2YgdGhlIHN0cmVhbSAqKSBtdXRhYmxlIG5leHQgOiAnYSBTdHJlYW0ubmV4dCBJdmFyLnQgfVxuW0BAZGVyaXZpbmcgZmllbGRzXVxuXG5sZXQgc2V4cF9vZl90IF8gdCA6IFNleHAudCA9XG4gIEF0b20gKGlmIEl2YXIuaXNfZW1wdHkgdC5uZXh0IHRoZW4gXCI8b3BlbiB0YWlsPlwiIGVsc2UgXCI8Y2xvc2VkIHRhaWw+XCIpXG47O1xuXG5sZXQgY3JlYXRlICgpID0geyBuZXh0ID0gSXZhci5jcmVhdGUgKCkgfVxubGV0IGNvbGxlY3QgdCA9IEl2YXIucmVhZCAobmV4dCB0KVxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIChuZXh0IHQpXG5cbmxldCBmaWxsX2V4biB0IHYgPVxuICBpZiBpc19jbG9zZWQgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwic3RyZWFtIGlzIGNsb3NlZFwiXSBlbHNlIEl2YXIuZmlsbCAobmV4dCB0KSB2XG47O1xuXG5sZXQgY2xvc2VfZXhuIHQgPSBmaWxsX2V4biB0IE5pbFxubGV0IGNsb3NlX2lmX29wZW4gdCA9IGlmIG5vdCAoaXNfY2xvc2VkIHQpIHRoZW4gSXZhci5maWxsIChuZXh0IHQpIE5pbFxuXG5sZXQgZXh0ZW5kIHQgdiA9XG4gIGxldCBuZXh0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZmlsbF9leG4gdCAoQ29ucyAodiwgSXZhci5yZWFkIG5leHQpKTtcbiAgdC5uZXh0IDwtIG5leHRcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxubW9kdWxlIFN0cmVhbSA9IFRhaWwuU3RyZWFtXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5pbmNsdWRlIE1vbml0b3JcblxudHlwZSBtb25pdG9yID0gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm5hbWU6aWdub3JlXG4gICAgICB+aGVyZTppZ25vcmVcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5mb3J3YXJkaW5nOmlnbm9yZVxuICAgICAgfm5leHRfZXJyb3I6KGNoZWNrIChmdW4gbmV4dF9lcnJvciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgbmV4dF9lcnJvcikpKVxuICAgICAgfmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfnRhaWxzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfmhhc19zZWVuX2Vycm9yOmlnbm9yZSlcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSlcbmxldCBjdXJyZW50ICgpID0gRXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSlcblxudHlwZSAnYSB3aXRoX29wdGlvbmFsX21vbml0b3JfbmFtZSA9XG4gID9oZXJlOlNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgLT4gP2luZm86SW5mby50IC0+ID9uYW1lOnN0cmluZyAtPiAnYVxuXG5sZXQgZGV0YWNoIHQgPSB0LmZvcndhcmRpbmcgPC0gRGV0YWNoZWRcblxudHlwZSBoYW5kbGVyX3N0YXRlID1cbiAgfCBVbmluaXRpYWxpemVkXG4gIHwgUnVubmluZyBvZiAoRXhlY3V0aW9uX2NvbnRleHQudCAqIChleG4gLT4gdW5pdCkpIEJhZy5FbHQudFxuICB8IFRlcm1pbmF0ZWRcblxubGV0IGRldGFjaF9hbmRfaXRlcl9lcnJvcnMgdCB+ZiA9XG4gIGRldGFjaCB0O1xuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gIGxldCBoYW5kbGVyX3N0YXRlX3JlZiA9IHJlZiBVbmluaXRpYWxpemVkIGluXG4gIGxldCBydW5fZiBleG4gPVxuICAgIG1hdGNoICFoYW5kbGVyX3N0YXRlX3JlZiB3aXRoXG4gICAgfCBVbmluaXRpYWxpemVkIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgVGVybWluYXRlZCAtPiAoKVxuICAgIHwgUnVubmluZyBiYWdfZWx0IC0+XG4gICAgICAodHJ5IGYgZXhuIHdpdGhcbiAgICAgICB8IGlubmVyX2V4biAtPlxuICAgICAgICAgaGFuZGxlcl9zdGF0ZV9yZWYgOj0gVGVybWluYXRlZDtcbiAgICAgICAgIEJhZy5yZW1vdmUgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyBiYWdfZWx0O1xuICAgICAgICAgKCogW3J1bl9mXSBhbHdheXMgcnVucyBpbiBbZXhlY3V0aW9uX2NvbnRleHRdLiAgSGVuY2UsIFtyYWlzZSBpbm5lcl9leG5dIHNlbmRzXG4gICAgICAgICAgICBbaW5uZXJfZXhuXSB0byBbZXhlY3V0aW9uX2NvbnRleHRdJ3MgbW9uaXRvciwgaS5lLiB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlblxuICAgICAgICAgICAgW2RldGFjaF9hbmRfaXRlcl9lcnJvcnNdIHdhcyBjYWxsZWQuICopXG4gICAgICAgICByYWlzZSBpbm5lcl9leG4pXG4gIGluXG4gIGhhbmRsZXJfc3RhdGVfcmVmXG4gIDo9IFJ1bm5pbmcgKEJhZy5hZGQgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyAoZXhlY3V0aW9uX2NvbnRleHQsIHJ1bl9mKSlcbjs7XG5cbmxldCBkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gdCA9XG4gIGRldGFjaCB0O1xuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIHQudGFpbHNfZm9yX2FsbF9lcnJvcnMgPC0gdGFpbCA6OiB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzO1xuICBUYWlsLmNvbGxlY3QgdGFpbFxuOztcblxubGV0IGdldF9uZXh0X2Vycm9yIHQgPSBJdmFyLnJlYWQgdC5uZXh0X2Vycm9yXG5cbmxldCBkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIHQgPVxuICBkZXRhY2ggdDtcbiAgZ2V0X25leHRfZXJyb3IgdFxuOztcblxubGV0IGNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSAoKSA9XG4gIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gIGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSAoU29tZSBwYXJlbnQpXG47O1xuXG5tb2R1bGUgTW9uaXRvcl9leG4gPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGV4biA6IGV4blxuICAgIDsgYmFja3RyYWNlIDogQmFja3RyYWNlLnQgb3B0aW9uXG4gICAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgICA7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICB9XG5cbiAgbGV0IGJhY2t0cmFjZSB0ID0gdC5iYWNrdHJhY2VcbiAgbGV0IGV4dHJhY3RfZXhuIHQgPSB0LmV4blxuXG4gIGxldCBiYWNrdHJhY2VfdHJ1bmNhdGlvbl9oZXVyaXN0aWNzID1cbiAgICBsZXQgam9iX3F1ZXVlID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJqb2JfcXVldWUubWxcXFwiXCIgaW5cbiAgICBsZXQgZGVmZXJyZWQwID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJkZWZlcnJlZDAubWxcXFwiXCIgaW5cbiAgICBsZXQgZGVmZXJyZWQxID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJkZWZlcnJlZDEubWxcXFwiXCIgaW5cbiAgICBsZXQgbW9uaXRvciA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwibW9uaXRvci5tbFxcXCJcIiBpblxuICAgIGxldCBpbXBvcnQwID0gXCJSYWlzZWQgYXQgZmlsZSBcXFwiaW1wb3J0MC5tbFxcXCJcIiBpblxuICAgIGxldCBlcnJvciA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwiZXJyb3IubWxcXFwiXCIgaW5cbiAgICBmdW4gdHJhY2VzIC0+XG4gICAgICAoKiAuLi90ZXN0L3Rlc3RfdHJ5X3dpdGhfZXJyb3JfZGlzcGxheS5tbCBtYWtlcyBzdXJlIHRoaXMgc3RheXMgdXAtdG8tZGF0ZS4gKilcbiAgICAgIGxldCB0cmFjZXMgPVxuICAgICAgICBtYXRjaCB0cmFjZXMgd2l0aFxuICAgICAgICB8IHQxIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQxIH5wcmVmaXg6aW1wb3J0MCAtPlxuICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgfCB0MiA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MiB+cHJlZml4OmVycm9yIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgICB8IHQzIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQzIH5wcmVmaXg6ZXJyb3IgLT4gcmVzdFxuICAgICAgICAgICAgICB8IF8gLT4gcmVzdClcbiAgICAgICAgICAgfCBfIC0+IHJlc3QpXG4gICAgICAgIHwgXyAtPiB0cmFjZXNcbiAgICAgIGluXG4gICAgICBtYXRjaCBMaXN0LnJldiB0cmFjZXMgd2l0aFxuICAgICAgfCB0MSA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MSB+cHJlZml4OmpvYl9xdWV1ZSAtPlxuICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICB8IHQyIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQyIH5wcmVmaXg6am9iX3F1ZXVlIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgdDIgOjogcmVzdFxuICAgICAgICAgICAgICB3aGVuIFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDpkZWZlcnJlZDBcbiAgICAgICAgICAgICAgICAoKiBiaW5kICopXG4gICAgICAgICAgICAgICAgfHwgU3RyaW5nLmlzX3ByZWZpeCB0MiB+cHJlZml4OmRlZmVycmVkMVxuICAgICAgICAgICAgICAgICgqIG1hcCAqKVxuICAgICAgICAgICAgICAgIHx8IFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDptb25pdG9yXG4gICAgICAgICAgICAgICgqIHRyeV93aXRoICopIC0+IExpc3QucmV2IHJlc3RcbiAgICAgICAgICAgIHwgXyAtPiBMaXN0LnJldiByZXN0KVxuICAgICAgICAgfCBfIC0+IExpc3QucmV2IHJlc3QpXG4gICAgICB8IF8gLT4gdHJhY2VzXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB7IGV4bjsgYmFja3RyYWNlOyBiYWNrdHJhY2VfaGlzdG9yeTsgbW9uaXRvciB9ID1cbiAgICBsZXQgbW9uaXRvciA9XG4gICAgICBsZXQgbmFtZSA9XG4gICAgICAgIG1hdGNoIEluZm8udG9fc3RyaW5nX2h1bSBtb25pdG9yLm5hbWUgd2l0aFxuICAgICAgICB8IFwiXCIgLT4gTm9uZVxuICAgICAgICB8IHMgLT4gU29tZSBzXG4gICAgICBpblxuICAgICAgbGV0IHBvcyA9XG4gICAgICAgIG1hdGNoIG1vbml0b3IuaGVyZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBoZXJlIC0+XG4gICAgICAgICAgKCogV2UgZGlzcGxheSB0aGUgZnVsbCBmaWxlbmFtZSwgd2hlcmVhcyBiYWNrdHJhY2VzIG9ubHkgaGF2ZSBiYXNlbmFtZXMsIGJ1dFxuICAgICAgICAgICAgIHBlcmhhcHMgdGhhdCdzIHdoYXQgc2hvdWxkIGNoYW5nZS4gKilcbiAgICAgICAgICBsZXQgY29sdW1uID0gaGVyZS5wb3NfY251bSAtIGhlcmUucG9zX2JvbCBpblxuICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICgqIFdlIGhpZGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgd2hlbiBbYW1fcnVubmluZ190ZXN0XSB0byBtYWtlIHRlc3Qgb3V0cHV0XG4gICAgICAgICAgICAgICBtb3JlIHJvYnVzdC4gIFRoaXMgc2F2ZXMgcGVvcGxlIG1hbnVhbGx5IGhpZGluZyB0aGUgbnVtYmVycyBvciBldmVuIHdvcnNlLFxuICAgICAgICAgICAgICAgbGVhdmluZyB0aGVtIGluIHRlc3Qgb3V0cHV0LiAgSGlkaW5nIGluIHRlc3QgaXMgZGlmZmVyZW50IGNob2ljZSBmb3JcbiAgICAgICAgICAgICAgIGJlaGF2aW9yIHRoYW4gb3VyIGNvZGViYXNlIG1ha2VzIGZvciBbQmFja3RyYWNlLmVsaWRlXSwgd2hpY2ggaGFzIGRlZmF1bHRcbiAgICAgICAgICAgICAgIFtmYWxzZV0sIGFuZCB0aHVzIHNob3dzIGJhY2t0cmFjZXMgaW4gdGVzdC4gIFRoZXJlIGFyZSBhIGNvdXBsZSByZWFzb25zIGZvclxuICAgICAgICAgICAgICAgdGhpcyBkaWZmZXJlbnQgY2hvaWNlLiAgRmlyc3QsIGV4cGVjdC10ZXN0IG1hY2hpbmVyeSBoYXMgY2hlY2sgdG8gcHJldmVudFxuICAgICAgICAgICAgICAgYmFja3RyYWNlcyBmcm9tIGFwcGVhcmluZyBpbiB0ZXN0IG91dHB1dC4gIEl0IGhhcyBubyBzdWNoIGNoZWNrcyBmb3IgbGluZVxuICAgICAgICAgICAgICAgYW5kIGNvbHVtbiBudW1iZXJzLiAgU2Vjb25kLCB3aGVuIHRoZXJlIGlzIGEgcmVhbCBlcnJvciBhbmQgeW91IHdhbnQgdG8gc2VlXG4gICAgICAgICAgICAgICB0aGUgYmFja3RyYWNlLCB0aHJvd2luZyBhd2F5IHRoZSB3aG9sZSBiYWNrdHJhY2UgbG9zZXMgYSBsb3Qgb2YgcG90ZW50aWFsbHlcbiAgICAgICAgICAgICAgIHVzZWZ1bCBpbmZvcm1hdGlvbiB0aGF0IG1heSBiZSBoYXJkIHRvIHJlY292ZXIuICBXaGVyZWFzIHdlJ3JlIGp1c3RcbiAgICAgICAgICAgICAgIHRocm93aW5nIGEgd2F5IGEgbGluZSBudW1iZXIgYW5kIGNvbHVtbiwgd2hpY2ggYXJlIGEgbWlub3IgY29udmVuaWVuY2VcbiAgICAgICAgICAgICAgIGdpdmVuIHRoYXQgdGhlIGZpbGVuYW1lIGhhcyBtb3N0IG9mIHRoZSBpbmZvcm1hdGlvbi4gKilcbiAgICAgICAgICAgIChpZiBhbV9ydW5uaW5nX3Rlc3RcbiAgICAgICAgICAgICB0aGVuIHNwcmludGYgXCJmaWxlICVTLCBsaW5lIExJTkUsIGNoYXJhY3RlcnMgQzEtQzJcIiBoZXJlLnBvc19mbmFtZVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIHNwcmludGZcbiAgICAgICAgICAgICAgICAgXCJmaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgICAgaGVyZS5wb3NfZm5hbWVcbiAgICAgICAgICAgICAgICAgaGVyZS5wb3NfbG51bVxuICAgICAgICAgICAgICAgICBjb2x1bW5cbiAgICAgICAgICAgICAgICAgY29sdW1uKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHBvcywgbmFtZSB3aXRoXG4gICAgICB8IE5vbmUsIE5vbmUgLT4gW11cbiAgICAgIHwgU29tZSBwb3MsIE5vbmUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgYXQgJXNcIiBwb3MgXVxuICAgICAgfCBOb25lLCBTb21lIG5hbWUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgJXNcIiBuYW1lIF1cbiAgICAgIHwgU29tZSBwb3MsIFNvbWUgbmFtZSAtPiBbIHNwcmludGYgXCJDYXVnaHQgYnkgbW9uaXRvciAlcyBhdCAlc1wiIG5hbWUgcG9zIF1cbiAgICBpblxuICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgbGV0IGJhY2t0cmFjZSA9XG4gICAgICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgICB8IFNvbWUgYmFja3RyYWNlIC0+IEJhY2t0cmFjZS50b19zdHJpbmdfbGlzdCBiYWNrdHJhY2VcbiAgICAgIGluXG4gICAgICBiYWNrdHJhY2VfdHJ1bmNhdGlvbl9oZXVyaXN0aWNzIGJhY2t0cmFjZSBAIG1vbml0b3JcbiAgICBpblxuICAgIGxldCBsaXN0X2lmX25vdF9lbXB0eSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgXyA6OiBfIGFzIGwgLT4gU29tZSBsXG4gICAgaW5cbiAgICBbJXNleHBcbiAgICAgIChleG4gOiBleG4pXG4gICAgLCAobGlzdF9pZl9ub3RfZW1wdHkgYmFja3RyYWNlIDogKHN0cmluZyBsaXN0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAsIGBiYWNrdHJhY2VfaGlzdG9yeVxuICAgICAgICAobGlzdF9pZl9ub3RfZW1wdHkgYmFja3RyYWNlX2hpc3RvcnkgOiAoQmFja3RyYWNlLnQgbGlzdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXVxuICA7O1xuZW5kXG5cbmV4Y2VwdGlvbiBNb25pdG9yX2V4biBvZiBNb25pdG9yX2V4bi50XG5cbmxldCAoKSA9XG4gIFNleHBsaWIuQ29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNb25pdG9yX2V4bl0gKGZ1bmN0aW9uXG4gICAgfCBNb25pdG9yX2V4biB0IC0+IFslc2V4cCBcIm1vbml0b3IubWwuRXJyb3JcIiA6OiAodCA6IE1vbml0b3JfZXhuLnQpXVxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgZXh0cmFjdF9leG4gZXhuID1cbiAgbWF0Y2ggZXhuIHdpdGhcbiAgfCBNb25pdG9yX2V4biBlcnJvciAtPiBlcnJvci5leG5cbiAgfCBleG4gLT4gZXhuXG47O1xuXG5sZXQgc2VuZF9leG4gdCA/KGJhY2t0cmFjZSA9IGBHZXQpIGV4biA9XG4gIGxldCBleG4gPVxuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgfCBNb25pdG9yX2V4biBfIC0+IGV4blxuICAgIHwgXyAtPlxuICAgICAgbGV0IGJhY2t0cmFjZSA9XG4gICAgICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgICAgIHwgYEdldCAtPiBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50X2Zvcl9leG4gZXhuXG4gICAgICAgIHwgYFRoaXMgYiAtPiBTb21lIGJcbiAgICAgIGluXG4gICAgICBsZXQgYmFja3RyYWNlX2hpc3RvcnkgPSAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSkuYmFja3RyYWNlX2hpc3RvcnkgaW5cbiAgICAgIE1vbml0b3JfZXhuIHsgTW9uaXRvcl9leG4uZXhuOyBiYWNrdHJhY2U7IGJhY2t0cmFjZV9oaXN0b3J5OyBtb25pdG9yID0gdCB9XG4gIGluXG4gIGlmIERlYnVnLm1vbml0b3Jfc2VuZF9leG4gdGhlbiBEZWJ1Zy5sb2cgXCJNb25pdG9yLnNlbmRfZXhuXCIgKHQsIGV4bikgWyVzZXhwX29mOiB0ICogZXhuXTtcbiAgdC5oYXNfc2Vlbl9lcnJvciA8LSB0cnVlO1xuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIEl2YXIuZmlsbCB0Lm5leHRfZXJyb3IgZXhuO1xuICAgIHQubmV4dF9lcnJvciA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgICBtYXRjaCB0LmZvcndhcmRpbmcgd2l0aFxuICAgIHwgRGV0YWNoZWQgLT5cbiAgICAgIGlmIERlYnVnLm1vbml0b3Jfc2VuZF9leG5cbiAgICAgIHRoZW5cbiAgICAgICAgRGVidWcubG9nIFwiTW9uaXRvci5zZW5kX2V4biBmb3VuZCBsaXN0ZW5pbmcgbW9uaXRvclwiICh0LCBleG4pIFslc2V4cF9vZjogdCAqIGV4bl07XG4gICAgICBCYWcuaXRlciB0LmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIH5mOihmdW4gKGV4ZWN1dGlvbl9jb250ZXh0LCBmKSAtPlxuICAgICAgICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBleG4pO1xuICAgICAgTGlzdC5pdGVyIHQudGFpbHNfZm9yX2FsbF9lcnJvcnMgfmY6KGZ1biB0YWlsIC0+IFRhaWwuZXh0ZW5kIHRhaWwgZXhuKVxuICAgIHwgUGFyZW50IHBhcmVudCAtPiBsb29wIHBhcmVudFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPlxuICAgICAgKCogRG8gbm90IGNoYW5nZSB0aGlzIGJyYW5jaCB0byBwcmludCB0aGUgZXhjZXB0aW9uIG9yIHRvIGV4aXQuICBIYXZpbmcgdGhlXG4gICAgICAgICBzY2hlZHVsZXIgcmFpc2UgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHRoZSBuZWNlc3NhcnkgYmVoYXZpb3IgZm9yIHByb2dyYW1zXG4gICAgICAgICB0aGF0IGNhbGwgW1NjaGVkdWxlci5nb10gYW5kIHdhbnQgdG8gaGFuZGxlIGl0LiAqKVxuICAgICAgU2NoZWR1bGVyLihnb3RfdW5jYXVnaHRfZXhuICh0ICgpKSkgZXhuICghQXN5bmNfa2VybmVsX2NvbmZpZy50YXNrX2lkICgpKVxuICBpblxuICBsb29wIHRcbjs7XG5cbm1vZHVsZSBFeHBvcnRlZF9mb3Jfc2NoZWR1bGVyID0gc3RydWN0XG4gIGxldCB3aXRoaW5fY29udGV4dCBjb250ZXh0IGYgPVxuICAgIFNjaGVkdWxlci4od2l0aF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGNvbnRleHQgfmY6KGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggUmVzdWx0LnRyeV93aXRoIGYgd2l0aFxuICAgICAgfCBPayB4IC0+IE9rIHhcbiAgICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICAgIHNlbmRfZXhuIChFeGVjdXRpb25fY29udGV4dC5tb25pdG9yIGNvbnRleHQpIGV4biB+YmFja3RyYWNlOmBHZXQ7XG4gICAgICAgIEVycm9yICgpKVxuICA7O1xuXG4gIHR5cGUgJ2Egd2l0aF9vcHRpb25zID0gP21vbml0b3I6dCAtPiA/cHJpb3JpdHk6UHJpb3JpdHkudCAtPiAnYVxuXG4gIGxldCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBsZXQgdG1wX2NvbnRleHQgPVxuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2UgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpID9tb25pdG9yID9wcmlvcml0eVxuICAgIGluXG4gICAgd2l0aGluX2NvbnRleHQgdG1wX2NvbnRleHQgZlxuICA7O1xuXG4gIGxldCB3aXRoaW4nID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgfCBPayBkIC0+IGRcbiAgOztcblxuICBsZXQgd2l0aGluX3YgP21vbml0b3IgP3ByaW9yaXR5IGYgPVxuICAgIG1hdGNoIHdpdGhpbl9nZW4gP21vbml0b3IgP3ByaW9yaXR5IGYgd2l0aFxuICAgIHwgRXJyb3IgKCkgLT4gTm9uZVxuICAgIHwgT2sgeCAtPiBTb21lIHhcbiAgOztcblxuICBsZXQgd2l0aGluID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+ICgpXG4gICAgfCBPayAoKSAtPiAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgeCA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgU2NoZWR1bGVyLmVucXVldWVcbiAgICAgIHNjaGVkdWxlclxuICAgICAgKEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlXG4gICAgICAgICAoU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyKVxuICAgICAgICAgP21vbml0b3JcbiAgICAgICAgID9wcmlvcml0eSlcbiAgICAgIHdvcmtcbiAgICAgIHhcbiAgOztcblxuICBsZXQgc2NoZWR1bGUgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgPSBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgKClcblxuICBsZXQgc2NoZWR1bGUnID1cbiAgICAoKiBGb3IgcGVyZm9ybWFuY2UsIHdlIHVzZSBbc2NoZWR1bGVfd2l0aF9kYXRhXSB3aXRoIGEgY2xvc2VkIGZ1bmN0aW9uLCBhbmQgaW5saW5lXG4gICAgICAgW0RlZmVycmVkLmNyZWF0ZV0uICopXG4gICAgbGV0IHVwb25fd29ya19maWxsX2kgKHdvcmssIGkpID0gdXBvbiAod29yayAoKSkgKGZ1biBhIC0+IEl2YXIuZmlsbCBpIGEpIGluXG4gICAgZnVuID9tb25pdG9yID9wcmlvcml0eSB3b3JrIC0+XG4gICAgICBsZXQgaSA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHVwb25fd29ya19maWxsX2kgKHdvcmssIGkpO1xuICAgICAgSXZhci5yZWFkIGlcbiAgOztcblxuICBsZXQgcHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQgZiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gICAgc3RhZ2UgKGZ1biBhIC0+IFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGEpXG4gIDs7XG5cbiAgbGV0IHByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0JyBmID1cbiAgICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBzY2hlZHVsZXIgaW5cbiAgICBsZXQgY2FsbF9hbmRfZmlsbCAoZiwgYSwgaSkgPSB1cG9uIChmIGEpIChmdW4gciAtPiBJdmFyLmZpbGwgaSByKSBpblxuICAgIHN0YWdlIChmdW4gYSAtPlxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaSAtPlxuICAgICAgICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgY2FsbF9hbmRfZmlsbCAoZiwgYSwgaSkpKVxuICA7O1xuZW5kXG5cbm9wZW4gRXhwb3J0ZWRfZm9yX3NjaGVkdWxlclxuXG5sZXQgc3RyZWFtX2l0ZXIgc3RyZWFtIH5mID1cbiAgbGV0IHJlYyBsb29wIHN0cmVhbSA9XG4gICAgU3RyZWFtLm5leHQgc3RyZWFtXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHYsIHN0cmVhbSkgLT5cbiAgICAgIGxvb3Agc3RyZWFtO1xuICAgICAgZiB2XG4gIGluXG4gIGxvb3Agc3RyZWFtXG47O1xuXG4oKiBBbiBbJ2EgT2tfYW5kX2V4bnMudF0gcmVwcmVzZW50cyB0aGUgb3V0cHV0IG9mIGEgY29tcHV0YXRpb24gcnVubmluZyBpbiBhIGRldGFjaGVkXG4gICBtb25pdG9yLiAqKVxubW9kdWxlIE9rX2FuZF9leG5zID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBvayA6ICdhIERlZmVycmVkLnRcbiAgICA7IGV4bnMgOiBleG4gU3RyZWFtLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW4gZiA9XG4gICAgKCogV2UgY2FsbCBbY3JlYXRlX3dpdGhfcGFyZW50IE5vbmVdIGJlY2F1c2UgW21vbml0b3JdIGRvZXMgbm90IG5lZWQgYSBwYXJlbnQuICBJdFxuICAgICAgIGRvZXMgbm90IGJlY2F1c2Ugd2UgY2FsbCBbZGV0YWNoX2FuZF9nZXRfZXJyb3Jfc3RyZWFtIG1vbml0b3JdIGFuZCBkZWFsIHdpdGggdGhlXG4gICAgICAgZXJyb3JzIGV4cGxpY2l0bHksIHRodXMgW3NlbmRfZXhuXSB3b3VsZCBuZXZlciBwcm9wYWdhdGUgYW4gZXhuIHBhc3QgW21vbml0b3JdLiAqKVxuICAgIGxldCBtb25pdG9yID0gY3JlYXRlX3dpdGhfcGFyZW50ID9oZXJlID9pbmZvID9uYW1lIE5vbmUgaW5cbiAgICBsZXQgZXhucyA9IGRldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yIGluXG4gICAgbGV0IG9rID1cbiAgICAgIG1hdGNoIHJ1biB3aXRoXG4gICAgICB8IGBOb3cgLT4gd2l0aGluJyB+bW9uaXRvciBmXG4gICAgICB8IGBTY2hlZHVsZSAtPiBzY2hlZHVsZScgfm1vbml0b3IgZlxuICAgIGluXG4gICAgeyBvazsgZXhucyB9XG4gIDs7XG5lbmRcblxubGV0IGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgIHJlc3VsdFxuICAgICAgZXhuc1xuICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0XG4gID1cbiAgaWYgSXZhcl9maWxsZXIuaXNfZW1wdHkgcmVzdWx0X2ZpbGxlclxuICB0aGVuIChcbiAgICBJdmFyX2ZpbGxlci5maWxsIHJlc3VsdF9maWxsZXIgcmVzdWx0O1xuICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zKVxuOztcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGhfbG9nX2V4biA6IChleG4gLT4gdW5pdCkgcmVmID1cbiAgICByZWYgKGZ1biBleG4gLT5cbiAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiZmFpbGVkIHRvIHNldCBbTW9uaXRvci5FeHBlcnQudHJ5X3dpdGhfbG9nX2V4bl1cIiAoZXhuIDogRXhuLnQpXSlcbiAgOztcbmVuZFxuXG5sZXQgbWFrZV9oYW5kbGVfZXhuIHJlc3QgPVxuICBtYXRjaCByZXN0IHdpdGhcbiAgfCBgTG9nIC0+XG4gICAgKCogV2UgYXJlIGNhcmVmdWwgdG8gbm90IGNsb3NlIG92ZXIgY3VycmVudCBjb250ZXh0LCB3aGljaCBpcyBub3QgbmVlZGVkLiAqKVxuICAgICFFeHBlcnQudHJ5X3dpdGhfbG9nX2V4blxuICB8IGBSYWlzZSAtPlxuICAgIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gICAgZnVuIGV4biAtPiBzZW5kX2V4biBwYXJlbnQgZXhuID9iYWNrdHJhY2U6Tm9uZVxuICB8IGBDYWxsIGYgLT5cbiAgICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICAgIGZ1biBleG4gLT4gd2l0aGluIH5tb25pdG9yOnBhcmVudCAoZnVuICgpIC0+IGYgZXhuKVxuOztcblxubGV0IHRyeV93aXRoXG4gICAgICA/aGVyZVxuICAgICAgP2luZm9cbiAgICAgID8obmFtZSA9IFwiXCIpXG4gICAgICA/ZXh0cmFjdF9leG46KGRvX2V4dHJhY3RfZXhuID0gZmFsc2UpXG4gICAgICA/KHJ1biA9IGBOb3cpXG4gICAgICA/KHJlc3QgPSBgUmFpc2UpXG4gICAgICBmXG4gID1cbiAgbGV0IHsgT2tfYW5kX2V4bnMub2s7IGV4bnMgfSA9IE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyB+bmFtZSB+cnVuIGYgaW5cbiAgbGV0IGhhbmRsZV9leG4gPSBtYWtlX2hhbmRsZV9leG4gcmVzdCBpblxuICBsZXQgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IGV4bnMgPSBzdHJlYW1faXRlciBleG5zIH5mOmhhbmRsZV9leG4gaW5cbiAgKCogV2UgcnVuIFt3aXRoaW4nIH5tb25pdG9yOm1haW5dIHRvIGF2b2lkIGhvbGRpbmcgb24gdG8gcmVmZXJlbmNlcyB0byB0aGUgZXZhbHVhdGlvblxuICAgICBjb250ZXh0IGluIHdoaWNoIFt0cnlfd2l0aF0gd2FzIGNhbGxlZC4gIFRoaXMgYXZvaWRzIGEgc3BhY2UgbGVhayB3aGVuIGEgY2hhaW4gb2ZcbiAgICAgW3RyeV93aXRoXSdzIGFyZSBydW4gZWFjaCBuZXN0ZWQgd2l0aGluIHRoZSBwcmV2aW91cyBvbmUuICBXaXRob3V0IHRoZSBbd2l0aGluJ10sIHRoZVxuICAgICBlcnJvciBoYW5kbGluZyBmb3IgdGhlIGlubmVybW9zdCBbdHJ5X3dpdGhdIHdvdWxkIGtlZXAgYWxpdmUgdGhlIGVudGlyZSBjaGFpbi4gKilcbiAgd2l0aGluJyB+bW9uaXRvcjptYWluIChmdW4gKCkgLT5cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIG9rXG4gICAgdGhlbiAoXG4gICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQgZXhucztcbiAgICAgIHJldHVybiAoT2sgKERlZmVycmVkLnZhbHVlX2V4biBvaykpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlc3VsdF9maWxsZXIsIHJlc3VsdCA9IEl2YXJfZmlsbGVyLmNyZWF0ZSAoKSBpblxuICAgICAgdXBvbiBvayAoZnVuIHJlcyAtPlxuICAgICAgICBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gICAgICAgICAgcmVzdWx0X2ZpbGxlclxuICAgICAgICAgIChPayByZXMpXG4gICAgICAgICAgZXhuc1xuICAgICAgICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCk7XG4gICAgICB1cG9uIChTdHJlYW0ubmV4dCBleG5zKSAoZnVuY3Rpb25cbiAgICAgICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgIHwgQ29ucyAoZXhuLCBleG5zKSAtPlxuICAgICAgICAgIGxldCBleG4gPSBpZiBkb19leHRyYWN0X2V4biB0aGVuIGV4dHJhY3RfZXhuIGV4biBlbHNlIGV4biBpblxuICAgICAgICAgIGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgICAgICAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgICAgICAgIChFcnJvciBleG4pXG4gICAgICAgICAgICBleG5zXG4gICAgICAgICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQpO1xuICAgICAgcmVzdWx0KSlcbjs7XG5cbmxldCB0cnlfd2l0aF9vcl9lcnJvciA/aGVyZSA/aW5mbyA/KG5hbWUgPSBcInRyeV93aXRoX29yX2Vycm9yXCIpID9leHRyYWN0X2V4biA/cmVzdCBmID1cbiAgdHJ5X3dpdGggZiA/aGVyZSA/aW5mbyB+bmFtZSA/ZXh0cmFjdF9leG4gfnJ1bjpgTm93ID9yZXN0ID4+fCBPcl9lcnJvci5vZl9leG5fcmVzdWx0XG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbl9vcl9lcnJvclxuICAgICAgP2hlcmVcbiAgICAgID9pbmZvXG4gICAgICA/KG5hbWUgPSBcInRyeV93aXRoX2pvaW5fb3JfZXJyb3JcIilcbiAgICAgID9leHRyYWN0X2V4blxuICAgICAgP3Jlc3RcbiAgICAgIGZcbiAgPVxuICB0cnlfd2l0aF9vcl9lcnJvciBmID9oZXJlID9pbmZvIH5uYW1lID9leHRyYWN0X2V4biA/cmVzdCA+PnwgT3JfZXJyb3Iuam9pblxuOztcblxubGV0IHByb3RlY3QgP2hlcmUgP2luZm8gPyhuYW1lID0gXCJNb25pdG9yLnByb3RlY3RcIikgP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgZiB+ZmluYWxseSA9XG4gIGxldCViaW5kIHIgPSB0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP2hlcmUgP2luZm8gP3J1biA/cmVzdCB+bmFtZSBmIGluXG4gIGxldCVtYXAgZnIgPVxuICAgIHRyeV93aXRoXG4gICAgICB+ZXh0cmFjdF9leG46ZmFsc2VcbiAgICAgID9oZXJlXG4gICAgICA/aW5mb1xuICAgICAgfnJ1bjpgU2NoZWR1bGUgKCogY29uc2lkZXIgW35ydW46YE5vd10gKilcbiAgICAgID9yZXN0XG4gICAgICB+bmFtZTpcImZpbmFsbHlcIlxuICAgICAgZmluYWxseVxuICBpblxuICBtYXRjaCByLCBmciB3aXRoXG4gIHwgRXJyb3IgZXhuLCBFcnJvciBmaW5hbGx5X2V4biAtPlxuICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiQXN5bmMgZmluYWxseVwiIChleG4gOiBleG4pIChmaW5hbGx5X2V4biA6IGV4bildXG4gIHwgRXJyb3IgZSwgT2sgKCkgfCBPayBfLCBFcnJvciBlIC0+IHJhaXNlIGVcbiAgfCBPayByLCBPayAoKSAtPiByXG47O1xuXG5sZXQgaGFuZGxlX2Vycm9ycyA/aGVyZSA/aW5mbyA/bmFtZSBmIGhhbmRsZXIgPVxuICBsZXQgeyBPa19hbmRfZXhucy5vazsgZXhucyB9ID0gT2tfYW5kX2V4bnMuY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW46YE5vdyBmIGluXG4gIHN0cmVhbV9pdGVyIGV4bnMgfmY6aGFuZGxlcjtcbiAgb2tcbjs7XG5cbmxldCBjYXRjaF9zdHJlYW0gP2hlcmUgP2luZm8gP25hbWUgZiA9XG4gIGxldCB7IE9rX2FuZF9leG5zLmV4bnM7IF8gfSA9XG4gICAgT2tfYW5kX2V4bnMuY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW46YE5vdyAoZnVuICgpIC0+XG4gICAgICBmICgpO1xuICAgICAgcmV0dXJuICgpKVxuICBpblxuICBleG5zXG47O1xuXG5sZXQgY2F0Y2ggP2hlcmUgP2luZm8gP25hbWUgZiA9XG4gIG1hdGNoJW1hcCBTdHJlYW0ubmV4dCAoY2F0Y2hfc3RyZWFtID9oZXJlID9pbmZvID9uYW1lIGYpIHdpdGhcbiAgfCBDb25zICh4LCBfKSAtPiB4XG4gIHwgTmlsIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiTW9uaXRvci5jYXRjaCBnb3QgdW5leHBlY3RlZCBlbXB0eSBzdHJlYW1cIl1cbjs7XG5cbmxldCBjYXRjaF9lcnJvciA/aGVyZSA/aW5mbyA/bmFtZSBmID0gY2F0Y2ggP2hlcmUgP2luZm8gP25hbWUgZiA+PnwgRXJyb3Iub2ZfZXhuXG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgbGV0IHBhcmVudCB0ID1cbiAgICBtYXRjaCB0LmZvcndhcmRpbmcgd2l0aFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPiBOb25lXG4gICAgfCBQYXJlbnQgcGFyZW50IC0+IFNvbWUgcGFyZW50XG4gICAgfCBEZXRhY2hlZCAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IGRlcHRoIHQgPVxuICAgIGxldCByZWMgbG9vcCB0IG4gPVxuICAgICAgbWF0Y2ggcGFyZW50IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IG5cbiAgICAgIHwgU29tZSB0IC0+IGxvb3AgdCAobiArIDEpXG4gICAgaW5cbiAgICBsb29wIHQgMFxuICA7O1xuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcbmluY2x1ZGUgVGFpbC5TdHJlYW1cblxubGV0IGZpcnN0X2V4biB0ID1cbiAgbWF0Y2glbWFwIG5leHQgdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiU3RyZWFtLmZpcnN0IG9mIGVtcHR5IHN0cmVhbVwiXVxuICB8IENvbnMgKHgsIF8pIC0+IHhcbjs7XG5cbmxldCBmb2xkJyB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgYiA9XG4gICAgICB1cG9uIChuZXh0IHQpIChmdW5jdGlvblxuICAgICAgICB8IE5pbCAtPiBJdmFyLmZpbGwgcmVzdWx0IGJcbiAgICAgICAgfCBDb25zICh2LCB0KSAtPiB1cG9uIChmIGIgdikgKGxvb3AgdCkpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbigqIFtmb2xkXSBpcyBpbXBsZW1lbnRlZCB0byBhdm9pZCBwZXItc3RyZWFtLWVsZW1lbnQgZGVmZXJyZWQgb3ZlcmhlYWQgaW4gdGhlIGNhc2Ugd2hlblxuICAgbXVsdGlwbGUgc3RyZWFtIGVsZW1lbnRzIGFyZSBhdmFpbGFibGUgc2ltdWx0YW5lb3VzbHkuICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgYiA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB1cG9uIChuZXh0IHQpIChmdW4gbmV4dCAtPiBsb29wX25leHQgbmV4dCBiKVxuICAgICAgfCBTb21lIG5leHQgLT4gbG9vcF9uZXh0IG5leHQgYlxuICAgIGFuZCBsb29wX25leHQgbmV4dCBiID1cbiAgICAgIG1hdGNoIG5leHQgd2l0aFxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCBiXG4gICAgICB8IENvbnMgKHYsIHQpIC0+IGxvb3AgdCAoZiBiIHYpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbmxldCBsZW5ndGggdCA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBfIC0+IG4gKyAxKVxubGV0IGl0ZXInIHQgfmYgPSBmb2xkJyB0IH5pbml0OigpIH5mOihmdW4gKCkgdiAtPiBmIHYpXG5cbmxldCBjbG9zZWQgdCA9XG4gIG1hdGNoIERlZmVycmVkLnBlZWsgKG5leHQgdCkgd2l0aFxuICB8IFNvbWUgTmlsIC0+IHJldHVybiAoKVxuICB8IF8gLT4gaXRlcicgdCB+ZjooZnVuIF8gLT4gcmV0dXJuICgpKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGRvbid0X3dhaXRfZm9yXG4gICAgKGl0ZXInIHQgfmY6KGZ1biBhIC0+XG4gICAgICAgZiBhO1xuICAgICAgIHJldHVybiAoKSkpXG47O1xuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gICgqIGNvbGxlY3QgYmVmb3JlIGNhbGxpbmcgW2ZdLCBpbiBjYXNlIFtmXSBpbW1lZGlhdGVseSBleHRlbmRzLiAqKVxuICBsZXQgdCA9IFRhaWwuY29sbGVjdCB0YWlsIGluXG4gIGYgdGFpbDtcbiAgdFxuOztcblxubGV0IHVuZm9sZCBiIH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCBiID1cbiAgICAgIHVwb24gKGYgYikgKGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgIHwgU29tZSAoYSwgYikgLT5cbiAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIGE7XG4gICAgICAgICAgbG9vcCBiKVxuICAgIGluXG4gICAgbG9vcCBiKVxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KTtcbiAgICBUYWlsLmNsb3NlX2V4biB0YWlsKVxuOztcblxubGV0IHRvX2xpc3QgcyA9IGZvbGQnIHMgfmluaXQ6W10gfmY6KGZ1biBiIGEgLT4gcmV0dXJuIChhIDo6IGIpKSA+PnwgTGlzdC5yZXZcbmxldCBjb3B5X3RvX3RhaWwgdCB0YWlsID0gaXRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChUYWlsLmV4dGVuZCB0YWlsIGEpKVxuXG5sZXQgYXBwZW5kIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0MSB0YWlsKSAoZnVuICgpIC0+XG4gICAgICB1cG9uIChjb3B5X3RvX3RhaWwgdDIgdGFpbCkgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSkpXG47O1xuXG5sZXQgY29uY2F0IHQgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvbiAoaXRlcicgdCB+ZjooZnVuIHQgLT4gY29weV90b190YWlsIHQgdGFpbCkpIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyJyB0IH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gdiAtPlxuICAgICAgICAgbWF0Y2glbWFwIGYgdiB3aXRoXG4gICAgICAgICB8IGZhbHNlIC0+ICgpXG4gICAgICAgICB8IHRydWUgLT4gVGFpbC5leHRlbmQgdGFpbCB2KSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKVxuXG5sZXQgZmlsdGVyX21hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT5cbiAgICAgICAgIG1hdGNoJW1hcCBmIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICB8IFNvbWUgdiAtPiBUYWlsLmV4dGVuZCB0YWlsIHYpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcl9tYXAnIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IG1hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT4gZiB2ID4+fCBUYWlsLmV4dGVuZCB0YWlsKSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXAnIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IGZpcnN0X24gcyBuID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCBzIG4gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgZWxzZVxuICAgICAgICB1cG9uIChuZXh0IHMpIChmdW5jdGlvblxuICAgICAgICAgIHwgTmlsIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgICAgICB8IENvbnMgKHgsIHQpIC0+XG4gICAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIHg7XG4gICAgICAgICAgICBsb29wIHQgKG4gLSAxKSlcbiAgICBpblxuICAgIGxvb3AgcyBuKVxuOztcblxubGV0IGF2YWlsYWJsZV9ub3cgdCA9XG4gIGxldCByZWMgbG9vcCB0IGFjID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgICB8IE5vbmUgfCBTb21lIE5pbCAtPiBMaXN0LnJldiBhYywgdFxuICAgIHwgU29tZSAoQ29ucyAoeCwgdCkpIC0+IGxvb3AgdCAoeCA6OiBhYylcbiAgaW5cbiAgbG9vcCB0IFtdXG47O1xuXG5sZXQgc3BsaXQgPyhzdG9wID0gRGVmZXJyZWQubmV2ZXIgKCkpID8oZiA9IGZ1biBfIC0+IGBDb250aW51ZSkgdCA9XG4gIGxldCByZWFzb25fZm9yX3N0b3BwaW5nID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHByZWZpeCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIGxldCBmaW5pc2ggdiA9XG4gICAgVGFpbC5jbG9zZV9leG4gcHJlZml4O1xuICAgIEl2YXIuZmlsbCByZWFzb25fZm9yX3N0b3BwaW5nIHZcbiAgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIGNob29zZSBbIGNob2ljZSBzdG9wIChmdW4gKCkgLT4gYFN0b3BwZWQpOyBjaG9pY2UgKG5leHQgdCkgKGZ1biBvIC0+IGBOZXh0IG8pIF1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IGBTdG9wcGVkIC0+IGZpbmlzaCAoYFN0b3BwZWQgdClcbiAgICB8IGBOZXh0IG8gLT5cbiAgICAgIChtYXRjaCBvIHdpdGhcbiAgICAgICB8IE5pbCAtPiBmaW5pc2ggYEVuZF9vZl9zdHJlYW1cbiAgICAgICB8IENvbnMgKGEsIHQpIC0+XG4gICAgICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICAgICB8IGBDb250aW51ZSAtPlxuICAgICAgICAgICAgVGFpbC5leHRlbmQgcHJlZml4IGE7XG4gICAgICAgICAgICBsb29wIHRcbiAgICAgICAgICB8IGBGb3VuZCBiIC0+IGZpbmlzaCAoYEZvdW5kIChiLCB0KSkpKVxuICBpblxuICBsb29wIHQ7XG4gIFRhaWwuY29sbGVjdCBwcmVmaXgsIEl2YXIucmVhZCByZWFzb25fZm9yX3N0b3BwaW5nXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IF8sIGZvdW5kID0gc3BsaXQgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gYEZvdW5kIGEgZWxzZSBgQ29udGludWUpIGluXG4gIG1hdGNoJW1hcCBmb3VuZCB3aXRoXG4gIHwgYFN0b3BwZWQgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCAoYEVuZF9vZl9zdHJlYW0gfCBgRm91bmQgXykgYXMgeCAtPiB4XG47O1xuXG5sZXQgdW5ncm91cCB0ID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gbCAtPlxuICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeCk7XG4gICAgICAgICByZXR1cm4gKCkpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBpbnRlcmxlYXZlIHRzID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgICgqIFRoZSBpbnRlcmxlYXZlZCBzdHJlYW0gc2hvdWxkIGJlIGNsb3NlZCB3aGVuIHRoZSBvdXRlciBzdHJlYW0gYW5kIGFsbCBvZlxuICAgICAgIHRoZSBpbm5lciBzdHJlYW1zIGhhdmUgYmVlbiBjbG9zZWQuICBLZWVwIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiBvcGVuXG4gICAgICAgc3RyZWFtcyBhbmQgY2xvc2UgdGhlIGludGVybGVhdmVkIHN0cmVhbSB3aGVuIHRoYXQgY291bnQgYmVjb21lc1xuICAgICAgIHplcm8uICopXG4gICAgbGV0IG51bV9vcGVuID0gcmVmIDEgaW5cbiAgICAoKiAxIGZvciB0aGUgb3V0ZXIgc3RyZWFtIHRoYXQgaXMgb3BlbiAqKVxuICAgIGxldCBjbG9zZSAoKSA9XG4gICAgICBudW1fb3BlbiA6PSAhbnVtX29wZW4gLSAxO1xuICAgICAgaWYgIW51bV9vcGVuID0gMCB0aGVuIFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICBpblxuICAgIGxldCBvdXRlcl9jbG9zZWQgPVxuICAgICAgaXRlcicgdHMgfmY6KGZ1biB0IC0+XG4gICAgICAgIG51bV9vcGVuIDo9ICFudW1fb3BlbiArIDE7XG4gICAgICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0IHRhaWwpIGNsb3NlO1xuICAgICAgICByZXR1cm4gKCkpXG4gICAgaW5cbiAgICB1cG9uIG91dGVyX2Nsb3NlZCBjbG9zZSlcbjs7XG5cbmxldCB0YWtlX3VudGlsIHQgZCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICB1cG9uXG4gICAgICAgIChjaG9vc2UgWyBjaG9pY2UgZCAoZnVuICgpIC0+IGBTdG9wKTsgY2hvaWNlIChuZXh0IHQpIChmdW4geiAtPiBgTmV4dCB6KSBdKVxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IGBTdG9wIHwgYE5leHQgTmlsIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgICAgICB8IGBOZXh0IChDb25zICh4LCB0KSkgLT5cbiAgICAgICAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgeDtcbiAgICAgICAgICAgIGxvb3AgdClcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHknIHQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICBuZXh0IHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCAoKVxuICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgICAgfnJ1bjpcbiAgICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgIH5yZXN0OmBSYWlzZVxuICAgICAgICAgIChmdW4gKCkgLT4gZiB4KVxuICAgICAgICA+Pj4gZnVuIHogLT5cbiAgICAgICAgbG9vcCB0O1xuICAgICAgICAobWF0Y2ggeiB3aXRoXG4gICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICB8IEVycm9yIGUgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlKVxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIHQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICBuZXh0IHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCAoKVxuICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICAoKiBXZSBpbW1lZGlhdGVseSBjYWxsIFtsb29wXSwgdGh1cyBtYWtpbmcgdGhlIGl0ZXIgZHVyYWJsZS4gIEFueSBleGNlcHRpb25zXG4gICAgICAgICAgIHJhaXNlZCBieSBbZl0gd2lsbCBub3QgcHJldmVudCB0aGUgbG9vcCBmcm9tIGNvbnRpbnVpbmcsIGFuZCB3aWxsIGdvIHRvIHRoZVxuICAgICAgICAgICBtb25pdG9yIG9mIHdob21ldmVyIGNhbGxlZCBbaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmRdLiAqKVxuICAgICAgICBsb29wIHQ7XG4gICAgICAgIGYgeFxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseSB0IH5mID0gZG9uJ3Rfd2FpdF9mb3IgKGl0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIHQgfmYpXG5cbmxldCBvZl9mdW4gZiA9XG4gIHVuZm9sZCAoKSB+ZjooZnVuICgpIC0+XG4gICAgbGV0JW1hcCBhID0gZiAoKSBpblxuICAgIFNvbWUgKGEsICgpKSlcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdwZXJtaXNzaW9uKSB0ID0gKCdhLCAncGVybWlzc2lvbikgVHlwZXMuQnZhci50XG5cbnR5cGUgJ2EgcmVwciA9ICdhIFR5cGVzLkJ2YXIucmVwciA9XG4gIHsgbXV0YWJsZSBoYXNfYW55X3dhaXRlcnMgOiBib29sXG4gIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSByZXByIFslc2V4cF9vZjogXyByZXByXSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgcmVwciBmIGluXG4gICAgRmllbGRzX29mX3JlcHIuaXRlclxuICAgICAgfmhhc19hbnlfd2FpdGVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gaGFzX2FueV93YWl0ZXJzIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaGFzX2hhbmRsZXJzIHJlcHIuaXZhciB0aGVuIGFzc2VydCBoYXNfYW55X3dhaXRlcnMpKVxuICAgICAgfml2YXI6XG4gICAgICAgIChjaGVjayAoZnVuIGl2YXIgLT5cbiAgICAgICAgICAgSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgaXZhcjtcbiAgICAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSkpXG47O1xuXG5sZXQgc2V4cF9vZl90IF8gXyB0ID1cbiAgbGV0IHsgaGFzX2FueV93YWl0ZXJzOyBpdmFyID0gXyB9ID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgKCogV2UgZG9uJ3Qgc2hvdyBbaXZhcl0gYmVjYXVzZSBpdCdzIGFsd2F5cyBlbXB0eS4gKilcbiAgWyVtZXNzYWdlIChoYXNfYW55X3dhaXRlcnMgOiBib29sKV1cbjs7XG5cbmluY2x1ZGUgU2NoZWR1bGVyMS5CdmFyXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICBpZiByZXByLmhhc19hbnlfd2FpdGVyc1xuICB0aGVuIChcbiAgICByZXByLmhhc19hbnlfd2FpdGVycyA8LSBmYWxzZTtcbiAgICBJdmFyLmZpbGwgcmVwci5pdmFyIGE7XG4gICAgcmVwci5pdmFyIDwtIEl2YXIuY3JlYXRlICgpKVxuOztcblxubGV0IHdhaXQgdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgcmVwci5oYXNfYW55X3dhaXRlcnMgPC0gdHJ1ZTtcbiAgSXZhci5yZWFkIHJlcHIuaXZhclxuOztcblxubGV0IGhhc19hbnlfd2FpdGVycyB0ID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICByZXByLmhhc19hbnlfd2FpdGVyc1xuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5cbmxldCBkZWJ1ZyA9IERlYnVnLmNsb2NrXG5cbm1vZHVsZSBBbGFybSA9IFRpbWluZ193aGVlbC5BbGFybVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCBjaG9vc2UgPSBEZWZlcnJlZC5jaG9vc2VcbmxldCBjaG9pY2UgPSBEZWZlcnJlZC5jaG9pY2VcbmxldCAoID4+PiApID0gdXBvblxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuVDFcblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICAgICAgX1xuICAgICAgICB7IGlkID0gX1xuICAgICAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgICAgICA7IGFtX2FkdmFuY2luZyA9IF9cbiAgICAgICAgOyBldmVudHNcbiAgICAgICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgICAgIDsgaGFuZGxlX2ZpcmVkID0gX1xuICAgICAgICA7IGlzX3dhbGxfY2xvY2tcbiAgICAgICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgICAgICA7IHNjaGVkdWxlciA9IF9cbiAgICAgICAgfVxuICAgID1cbiAgICBpZiBpc193YWxsX2Nsb2NrXG4gICAgdGhlbiBbJW1lc3NhZ2UgXCI8d2FsbF9jbG9jaz5cIl1cbiAgICBlbHNlXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgKGlzX3dhbGxfY2xvY2sgOiBib29sKVxuICAgICAgICAgICgqIFdlIGRvbid0IGRpc3BsYXkgdGhlIFtKb2IudF1zIGluIFtldmVudHNdIGJlY2F1c2UgdGhvc2UgYXJlXG4gICAgICAgICAgICAgcG9vbCBwb2ludGVycywgd2hpY2ggYXJlIHVuaW5mb3JtYXRpdmUuICopXG4gICAgICAgICAgKGV2ZW50cyA6IF8gVGltaW5nX3doZWVsLnQpXVxuICA7O1xuZW5kXG5cbm9wZW4gVDFcblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gcmVhZF93cml0ZSBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmVuZFxuXG50eXBlIHQgPSByZWFkIFQxLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCA9IGludmFyaWFudFxubGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5sZXQgcmVhZF9vbmx5ICh0IDogWz4gcmVhZCBdIFQxLnQpID0gKHQgOj4gdClcbmxldCBjcmVhdGUgPSBTY2hlZHVsZXIuY3JlYXRlX3RpbWVfc291cmNlXG5sZXQgd2FsbF9jbG9jayA9IFNjaGVkdWxlci53YWxsX2Nsb2NrXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIHQuZXZlbnRzXG5sZXQgaXNfd2FsbF9jbG9jayB0ID0gdC5pc193YWxsX2Nsb2NrXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcbmxldCB0aW1pbmdfd2hlZWxfbm93IHQgPSBUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzXG5sZXQgaWQgdCA9IHQuaWRcblxubW9kdWxlIElkID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLklkXG5cbmxldCBub3cgdCA9XG4gIGlmIHQuaXNfd2FsbF9jbG9ja1xuICB0aGVuXG4gICAgKCogRm9yIHRoZSB3YWxsLWNsb2NrIHRpbWUtc291cmNlLCB3ZSB1c2UgW1RpbWVfbnMubm93ICgpXSByYXRoZXIgdGhhblxuICAgICAgIFtUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzXS4gIFRoZSBsYXR0ZXIgaXMgb25seSB1cGRhdGVkIGF0IHRoZSBzdGFydCBvZiBlYWNoXG4gICAgICAgY3ljbGUuICBUaGVyZSBjYW4gYmUgc3Vic3RhbnRpYWwgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gd2hlbiBwZW9wbGUgZG8gbG9uZ1xuICAgICAgIHJ1bm5pbmcgY29tcHV0YXRpb25zIG9yIG1peCBibG9ja2luZyBjb2RlIHdpdGggYXN5bmMuICBBbmQgaHVtYW5zIGV4cGVjdCB0aGF0XG4gICAgICAgd2FsbC1jbG9jayB0aW1lIGlzIGJhc2VkIG9uIFtUaW1lLm5vd10sIG5vdCBzb21lIGFydGlmYWN0IG9mIGFzeW5jXG4gICAgICAgaW1wbGVtZW50YXRpb24uICopXG4gICAgVGltZV9ucy5ub3cgKClcbiAgZWxzZSB0aW1pbmdfd2hlZWxfbm93IHRcbjs7XG5cbigqIFdlIHByZWFsbG9jYXRlIFtzZW5kX2V4bl0gdG8gYXZvaWQgYWxsb2NhdGluZyBpdCBvbiBlYWNoIGNhbGwgdG8gW2FkdmFuY2VfY2xvY2tdLiAqKVxubGV0IHNlbmRfZXhuID0gU29tZSBNb25pdG9yLnNlbmRfZXhuXG5sZXQgYWR2YW5jZV9kaXJlY3RseSB0IH50b18gPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYWR2YW5jZV9jbG9jayB0IH50b18gfnNlbmRfZXhuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9ieSB0IGJ5ID0gYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcbmxldCBhZHZhbmNlID0gYWR2YW5jZV9kaXJlY3RseVxubGV0IGFkdmFuY2VfYnkgPSBhZHZhbmNlX2RpcmVjdGx5X2J5XG5sZXQgZmlyZV9wYXN0X2FsYXJtcyB0ID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG5cbmxldCB5aWVsZCB0ID0gQnZhci53YWl0IChTY2hlZHVsZXIueWllbGQgdC5zY2hlZHVsZXIpXG5cbmxldCBhZHZhbmNlX2J5X2FsYXJtcyA/d2FpdF9mb3IgdCB+dG9fID1cbiAgbGV0IHJ1bl9xdWV1ZWRfYWxhcm1zICgpID1cbiAgICAoKiBFdmVyeSB0aW1lIHdlIHdhbnQgdG8gcnVuIHF1ZXVlZCBhbGFybXMgd2UgbmVlZCB0byB5aWVsZCBjb250cm9sIGJhY2sgdG8gdGhlXG4gICAgICAgW0FzeW5jLlNjaGVkdWxlcl0gYW5kIFt3YWl0X2Zvcl0gYW55IGxvZ2ljIHRoYXQgaXMgc3VwcG9zZWQgdG8gZmluaXNoIGF0IHRoaXMgdGltZVxuICAgICAgIGJlZm9yZSBhZHZhbmNpbmcuICBJZiBubyBbd2FpdF9mb3JdIGxvZ2ljIGlzIHNwZWNpZmllZCB3ZSBjYW4gc2ltcGx5IHlpZWxkIGNvbnRyb2xcbiAgICAgICBieSBpbnZva2luZyBbeWllbGQgdF0sIHdoaWNoIGVucXVldWVzIGFub3RoZXIgam9iIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBqb2JcbiAgICAgICBxdWV1ZSBzbyBhbGFybSBqb2JzIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJ1biBiZWZvcmUgd2UgYWR2YW5jZS4gKilcbiAgICBtYXRjaCB3YWl0X2ZvciB3aXRoXG4gICAgfCBOb25lIC0+IHlpZWxkIHRcbiAgICB8IFNvbWUgZiAtPiBmICgpXG4gIGluXG4gIGxldCBmaW5pc2ggKCkgPVxuICAgIGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fO1xuICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAoKiBzbyB0aGF0IGFsYXJtcyBzY2hlZHVsZWQgYXQgb3IgYmVmb3JlIFt0b19dIGZpcmUgKilcbiAgICBydW5fcXVldWVkX2FsYXJtcyAoKVxuICBpblxuICBsZXQgcmVjIHdhbGtfYWxhcm1zICgpID1cbiAgICBtYXRjaCBUaW1pbmdfd2hlZWwubWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQuZXZlbnRzIHdpdGhcbiAgICB8IE5vbmUgLT4gZmluaXNoICgpXG4gICAgfCBTb21lIG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCAtPlxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHRvX1xuICAgICAgdGhlbiBmaW5pc2ggKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzptaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWw7XG4gICAgICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAgICAgbGV0IHF1ZXVlZF9hbGFybXNfcmFuID0gcnVuX3F1ZXVlZF9hbGFybXMgKCkgaW5cbiAgICAgICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBxdWV1ZWRfYWxhcm1zX3JhblxuICAgICAgICB0aGVuIHdhbGtfYWxhcm1zICgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCViaW5kICgpID0gcXVldWVkX2FsYXJtc19yYW4gaW5cbiAgICAgICAgICB3YWxrX2FsYXJtcyAoKSkpXG4gIGluXG4gIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgKCogVGhpcyBmaXJzdCBbcnVuX3F1ZXVlZF9hbGFybXNdIGNhbGwgYWxsb3dzIFtDbG9ja19ucy5ldmVyeV0gdGhlIG9wcG9ydHVuaXR5IHRvIHJ1blxuICAgICBpdHMgY29udGludWF0aW9uIGRlZmVycmVkcyBzbyB0aGF0IHRoZXkgY2FuIHJlc2NoZWR1bGUgYWxhcm1zLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgdXNlZnVsIGluIG91ciBcImFkdmFuY2UgaGl0cyBpbnRlcm1lZGlhdGUgYWxhcm1zXCIgdW5pdCB0ZXN0IGJlbG93LCBidXQgbGlrZWx5IHVzZWZ1bFxuICAgICBpbiBvdGhlciBjYXNlcyB3aGVyZSBbZXZlcnldIGlzIHN5bmNocm9ub3VzbHkgZm9sbG93ZWQgYnkgW2FkdmFuY2VdLiAqKVxuICBsZXQlYmluZCAoKSA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gIHdhbGtfYWxhcm1zICgpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfdGltaW5nX3doZWVsX2ludGVydmFsID93YWl0X2ZvciB0IH50b18gPVxuICBsZXQgcnVuX3F1ZXVlZF9hbGFybXMgKCkgPVxuICAgICgqIEV2ZXJ5IHRpbWUgd2Ugd2FudCB0byBydW4gcXVldWVkIGFsYXJtcyB3ZSBuZWVkIHRvIHlpZWxkIGNvbnRyb2wgYmFjayB0byB0aGVcbiAgICAgICBbQXN5bmMuU2NoZWR1bGVyXSBhbmQgW3dhaXRfZm9yXSBhbnkgbG9naWMgdGhhdCBpcyBzdXBwb3NlZCB0byBmaW5pc2ggYXQgdGhpcyB0aW1lXG4gICAgICAgYmVmb3JlIGFkdmFuY2luZy4gIElmIG5vIFt3YWl0X2Zvcl0gbG9naWMgaXMgc3BlY2lmaWVkIHdlIGNhbiBzaW1wbHkgeWllbGQgY29udHJvbFxuICAgICAgIGJ5IGludm9raW5nIFt5aWVsZCB0XSwgd2hpY2ggZW5xdWV1ZXMgYW5vdGhlciBqb2IgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZWR1bGVyIGpvYlxuICAgICAgIHF1ZXVlIHNvIGFsYXJtIGpvYnMgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuIGJlZm9yZSB3ZSBhZHZhbmNlLiAqKVxuICAgIG1hdGNoIHdhaXRfZm9yIHdpdGhcbiAgICB8IE5vbmUgLT4geWllbGQgdFxuICAgIHwgU29tZSBmIC0+IGYgKClcbiAgaW5cbiAgbGV0IGZpbmlzaCAoKSA9XG4gICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b187XG4gICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgICgqIHNvIHRoYXQgYWxhcm1zIHNjaGVkdWxlZCBhdCBvciBiZWZvcmUgW3RvX10gZmlyZSAqKVxuICAgIHJ1bl9xdWV1ZWRfYWxhcm1zICgpXG4gIGluXG4gIGxldCByZWMgd2Fsa19hbGFybXMgKCkgPVxuICAgIG1hdGNoIG5leHRfYWxhcm1fZmlyZXNfYXQgdCB3aXRoXG4gICAgfCBOb25lIC0+IGZpbmlzaCAoKVxuICAgIHwgU29tZSBuZXh0X2FsYXJtX2ZpcmVzX2F0IC0+XG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBuZXh0X2FsYXJtX2ZpcmVzX2F0IHRvX1xuICAgICAgdGhlbiBmaW5pc2ggKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzooVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdC5ldmVudHMpO1xuICAgICAgICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICAgICAgIGxldCBxdWV1ZWRfYWxhcm1zX3JhbiA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gICAgICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgcXVldWVkX2FsYXJtc19yYW5cbiAgICAgICAgdGhlbiB3YWxrX2FsYXJtcyAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQlYmluZCAoKSA9IHF1ZXVlZF9hbGFybXNfcmFuIGluXG4gICAgICAgICAgd2Fsa19hbGFybXMgKCkpKVxuICBpblxuICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICgqIFRoaXMgZmlyc3QgW3J1bl9xdWV1ZWRfYWxhcm1zXSBjYWxsIGFsbG93cyBbQ2xvY2tfbnMuZXZlcnldIHRoZSBvcHBvcnR1bml0eSB0byBydW5cbiAgICAgaXRzIGNvbnRpbnVhdGlvbiBkZWZlcnJlZHMgc28gdGhhdCB0aGV5IGNhbiByZXNjaGVkdWxlIGFsYXJtcy4gIFRoaXMgaXMgcGFydGljdWxhcmx5XG4gICAgIHVzZWZ1bCBpbiBvdXIgXCJhZHZhbmNlIGhpdHMgaW50ZXJtZWRpYXRlIGFsYXJtc1wiIHVuaXQgdGVzdCBiZWxvdywgYnV0IGxpa2VseSB1c2VmdWxcbiAgICAgaW4gb3RoZXIgY2FzZXMgd2hlcmUgW2V2ZXJ5XSBpcyBzeW5jaHJvbm91c2x5IGZvbGxvd2VkIGJ5IFthZHZhbmNlXS4gKilcbiAgbGV0JWJpbmQgKCkgPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICB3YWxrX2FsYXJtcyAoKVxuOztcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zX2J5ID93YWl0X2ZvciB0IGJ5ID1cbiAgYWR2YW5jZV9ieV9hbGFybXMgP3dhaXRfZm9yIHQgfnRvXzooVGltZV9ucy5hZnRlciAobm93IHQpIGJ5KVxuOztcblxubGV0IHNwYW5fdG9fdGltZSB0IHNwYW4gPSBUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhblxuXG5sZXQgc2NoZWR1bGVfam9iIHQgfmF0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGxldCBhbGFybSA9XG4gICAgVGltaW5nX3doZWVsLmFkZFxuICAgICAgdC5ldmVudHNcbiAgICAgIH5hdFxuICAgICAgKEpvYl9vcl9ldmVudC5vZl9qb2IgKFNjaGVkdWxlci5jcmVhdGVfam9iIHQuc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSkpXG4gIGluXG4gIChtYXRjaCB0LnNjaGVkdWxlci5ldmVudF9hZGRlZF9ob29rIHdpdGhcbiAgIHwgTm9uZSAtPiAoKVxuICAgfCBTb21lIGYgLT4gZiBhdCk7XG4gIGFsYXJtXG47O1xuXG5sZXQgcnVuX2F0X2ludGVybmFsIHQgdGltZSBmIGEgPVxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0LnNjaGVkdWxlciBpblxuICBpZiBUaW1lX25zLiggPiApIHRpbWUgKFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHMpXG4gIHRoZW4gc2NoZWR1bGVfam9iIHQgfmF0OnRpbWUgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG4gIGVsc2UgKFxuICAgIFNjaGVkdWxlci5lbnF1ZXVlIHQuc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgYTtcbiAgICBBbGFybS5udWxsICgpKVxuOztcblxubGV0IHJ1bl9hdCB0IHRpbWUgZiBhID0gaWdub3JlIChydW5fYXRfaW50ZXJuYWwgdCB0aW1lIGYgYSA6IF8gQWxhcm0udClcbmxldCBydW5fYWZ0ZXIgdCBzcGFuIGYgYSA9IHJ1bl9hdCB0IChzcGFuX3RvX3RpbWUgdCBzcGFuKSBmIGFcblxubGV0IGF0ID1cbiAgbGV0IGZpbGwgcmVzdWx0ID0gSXZhci5maWxsIHJlc3VsdCAoKSBpblxuICBmdW4gdCB0aW1lIC0+XG4gICAgaWYgVGltZV9ucy4oIDw9ICkgdGltZSAoVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50cylcbiAgICB0aGVuIHJldHVybiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICBpZ25vcmUgKHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZmlsbCByZXN1bHQgOiBfIEFsYXJtLnQpO1xuICAgICAgSXZhci5yZWFkIHJlc3VsdClcbjs7XG5cbmxldCBhZnRlciB0IHNwYW4gPSBhdCB0IChzcGFuX3RvX3RpbWUgdCBzcGFuKVxuXG5sZXQgcmVtb3ZlX2FsYXJtIHQgYWxhcm0gOiB1bml0ID1cbiAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIHQuZXZlbnRzIGFsYXJtIGluXG4gIChsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gICBtYXRjaCBrLCBwcm9qZWN0IGsgam9iX29yX2V2ZW50IHdpdGhcbiAgIHwgSm9iLCBqb2IgLT4gU2NoZWR1bGVyLmZyZWVfam9iIHQuc2NoZWR1bGVyIGpvYlxuICAgfCBFdmVudCwgXyAtPlxuICAgICAoKiBUaGlzIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgW2FsYXJtXSBvbmx5IGV2ZXIgY29tZXMgZnJvbSBbRXZlbnQuYWxhcm1dIHdoaWNoIG9ubHlcbiAgICAgICAgZXZlciBnZXRzIHBvcHVsYXRlZCBieSBhIGNhbGwgdG8gW3NjaGVkdWxlX2pvYl0uICopXG4gICAgIGFzc2VydCBmYWxzZSk7XG4gIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgYWxhcm1cbjs7XG5cbmxldCByZW1vdmVfYWxhcm1faWZfc2NoZWR1bGVkIHQgYWxhcm0gPVxuICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzIGFsYXJtIHRoZW4gcmVtb3ZlX2FsYXJtIHQgYWxhcm1cbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBtb2R1bGUgRmlyZWQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICB7IG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50XG4gICAgOyBtdXRhYmxlIGZpcmUgOiB1bml0IC0+IHVuaXRcbiAgICA7ICgqIEFzIGxvbmcgYXMgW0l2YXIuaXNfZW1wdHkgZmlyZWRdLCB3ZSBoYXZlIG5vdCB5ZXQgY29tbWl0dGVkIHRvIHdoZXRoZXIgdGhlIGV2ZW50XG4gICAgICAgICB3aWxsIGhhcHBlbiBvciBiZSBhYm9ydGVkLiAgV2hlbiBbSXZhci5pc19lbXB0eSBmaXJlZF0sIHRoZSBhbGFybSBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAgYmUgaW4gdGhlIHRpbWluZyB3aGVlbCAtLSBpZiBpdCBpc24ndCwgdGhlbiB0aGVyZSdzIGEgam9iIGluIEFzeW5jJ3Mgam9iIHF1ZXVlXG4gICAgICAgICB0aGF0IHdpbGwgZmlyZSB0aGUgZXZlbnQsIHVubGVzcyBpdCBpcyBhYm9ydGVkIGJlZm9yZSB0aGF0IGpvYiBjYW4gcnVuLiAqKVxuICAgICAgZmlyZWQgOiAoJ2EsICdoKSBGaXJlZC50IEl2YXIudFxuICAgIDsgKCogW251bV9maXJlc190b19za2lwXSBpcyB1c2VkIHRvIHJlc2NoZWR1bGUgZXZlbnRzIHRoYXQgaGF2ZSBmaXJlZCBhbmQgZW50ZXJlZCB0aGVcbiAgICAgICAgIEFzeW5jIGpvYiBxdWV1ZSwgYnV0IGhhdmUgbm90IHlldCBydW4uICBUaG9zZSBqb2JzIG9ubHkgcnVuIGlmIFtudW1fZmlyZXNfdG9fc2tpcFxuICAgICAgICAgPSAwXSwgYW5kIG90aGVyd2lzZSBqdXN0IGRlY3JlbWVudCBpdC4gIFNvLCB0byByZXNjaGVkdWxlIGFuIGV2ZW50IGluIHN1Y2ggYVxuICAgICAgICAgc3RhdGUsIHdlIGluY3JlbWVudCBbbnVtX2ZpcmVzX3RvX3NraXBdIGFuZCBhZGQgYSBuZXcgYWxhcm0gdG8gdGhlIHRpbWluZ1xuICAgICAgICAgd2hlZWwuICopXG4gICAgICBtdXRhYmxlIG51bV9maXJlc190b19za2lwIDogaW50XG4gICAgOyAoKiBbc2NoZWR1bGVkX2F0XSBpcyB0aGUgdGltZSBhdCB3aGljaCBbdF0gaGFzIG1vc3QgcmVjZW50bHkgYmVlbiBzY2hlZHVsZWQgdG8gZmlyZS5cbiAgICAgICAgIFdoaWxlIFt0LmFsYXJtXSBpcyBzdGlsbCBpbiB0aGUgdGltaW5nIHdoZWVsLCB0aGlzIGlzIHRoZSBzYW1lIGFzIFtBbGFybS5hdFxuICAgICAgICAgdC5hbGFybV0uICopXG4gICAgICBtdXRhYmxlIHNjaGVkdWxlZF9hdCA6IFRpbWVfbnMudFxuICAgIDsgdGltZV9zb3VyY2UgOiBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZmlyZWQgdCA9IEl2YXIucmVhZCB0LmZpcmVkXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBpbnZhcmlhbnRfaCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmFsYXJtOlxuICAgICAgICAgIChjaGVjayAoZnVuIGFsYXJtIC0+XG4gICAgICAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuZmlyZWRcbiAgICAgICAgICAgICB0aGVuIGFzc2VydCAobm90IChUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybSkpXG4gICAgICAgICAgICAgZWxzZSBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybVxuICAgICAgICAgICAgIHRoZW4gYXNzZXJ0IChKb2Jfb3JfZXZlbnQuaXNfam9iIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKSkpXG4gICAgICAgIH5maXJlOmlnbm9yZVxuICAgICAgICB+ZmlyZWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gKGZpcmVkIDogXyBGaXJlZC50IEl2YXIudCkgLT5cbiAgICAgICAgICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgZmlyZWQpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gaW52YXJpYW50X2EgYVxuICAgICAgICAgICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gaW52YXJpYW50X2ggaCkpXG4gICAgICAgIH5udW1fZmlyZXNfdG9fc2tpcDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBudW1fZmlyZXNfdG9fc2tpcCAtPiBhc3NlcnQgKG51bV9maXJlc190b19za2lwID49IDApKSlcbiAgICAgICAgfnNjaGVkdWxlZF9hdDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBzY2hlZHVsZWRfYXQgLT5cbiAgICAgICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgICAgICBzY2hlZHVsZWRfYXRcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDooQWxhcm0uYXQgZXZlbnRzIHQuYWxhcm0pKSlcbiAgICAgICAgfnRpbWVfc291cmNlOmlnbm9yZSlcbiAgOztcblxuICBtb2R1bGUgU3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZV9ucy50XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHN0YXR1cyB0IDogXyBTdGF0dXMudCA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIHQuZmlyZWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gU2NoZWR1bGVkX2F0IHQuc2NoZWR1bGVkX2F0XG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IEFib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gSGFwcGVuZWQgaFxuICA7O1xuXG4gIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBhYm9ydCB0IGEgOiBfIEFib3J0X3Jlc3VsdC50ID1cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LmFib3J0XCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChmaXJlZCB0KSB3aXRoXG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IFByZXZpb3VzbHlfYWJvcnRlZCBhXG4gICAgfCBTb21lIChIYXBwZW5lZCBoKSAtPiBQcmV2aW91c2x5X2hhcHBlbmVkIGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEl2YXIuZmlsbCB0LmZpcmVkIChBYm9ydGVkIGEpO1xuICAgICAgcmVtb3ZlX2FsYXJtX2lmX3NjaGVkdWxlZCB0LnRpbWVfc291cmNlIHQuYWxhcm07XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCBhYm9ydF9leG4gdCBhID1cbiAgICBtYXRjaCBhYm9ydCB0IGEgd2l0aFxuICAgIHwgT2sgLT4gKClcbiAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgXyAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJDbG9jay5FdmVudC5hYm9ydF9leG4gZmFpbGVkIHRvIGFib3J0IGV2ZW50IHRoYXQgcHJldmlvdXNseSBoYXBwZW5lZFwiXVxuICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIF8gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQ2xvY2suRXZlbnQuYWJvcnRfZXhuIGZhaWxlZCB0byBhYm9ydCBldmVudCB0aGF0IHByZXZpb3VzbHkgYWJvcnRlZFwiXVxuICA7O1xuXG4gIGxldCBhYm9ydF9pZl9wb3NzaWJsZSB0IGEgPSBpZ25vcmUgKGFib3J0IHQgYSA6IF8gQWJvcnRfcmVzdWx0LnQpXG4gIGxldCBzY2hlZHVsZSB0ID0gdC5hbGFybSA8LSBydW5fYXRfaW50ZXJuYWwgdC50aW1lX3NvdXJjZSB0LnNjaGVkdWxlZF9hdCB0LmZpcmUgKClcblxuICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCByZXNjaGVkdWxlX2F0IHQgYXQgOiBfIFJlc2NoZWR1bGVfcmVzdWx0LnQgPVxuICAgIGlmIGRlYnVnXG4gICAgdGhlblxuICAgICAgRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucmVzY2hlZHVsZV9hdFwiICh0LCBhdCkgWyVzZXhwX29mOiAoXywgXykgdCAqIFRpbWVfbnMudF07XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoZmlyZWQgdCkgd2l0aFxuICAgIHwgU29tZSAoQWJvcnRlZCBhKSAtPiBQcmV2aW91c2x5X2Fib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gUHJldmlvdXNseV9oYXBwZW5lZCBoXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBpc19pbl90aW1pbmdfd2hlZWwgPSBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtIGluXG4gICAgICBsZXQgYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlX2Z1dHVyZSA9XG4gICAgICAgIFRpbWVfbnMuKCA+ICkgYXQgKFRpbWluZ193aGVlbC5ub3cgZXZlbnRzKVxuICAgICAgaW5cbiAgICAgIHQuc2NoZWR1bGVkX2F0IDwtIGF0O1xuICAgICAgKG1hdGNoIGFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZV9mdXR1cmUsIGlzX2luX3RpbWluZ193aGVlbCB3aXRoXG4gICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gKClcbiAgICAgICB8IGZhbHNlLCB0cnVlIC0+XG4gICAgICAgICB0LnRpbWVfc291cmNlLmhhbmRsZV9maXJlZCB0LmFsYXJtO1xuICAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSBldmVudHMgdC5hbGFybVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgIHQubnVtX2ZpcmVzX3RvX3NraXAgPC0gdC5udW1fZmlyZXNfdG9fc2tpcCArIDE7XG4gICAgICAgICBzY2hlZHVsZSB0XG4gICAgICAgfCB0cnVlLCB0cnVlIC0+IFRpbWluZ193aGVlbC5yZXNjaGVkdWxlIGV2ZW50cyB0LmFsYXJtIH5hdCk7XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCByZXNjaGVkdWxlX2FmdGVyIHQgc3BhbiA9IHJlc2NoZWR1bGVfYXQgdCAoc3Bhbl90b190aW1lIHQudGltZV9zb3VyY2Ugc3BhbilcblxuICBsZXQgcnVuX2F0IHRpbWVfc291cmNlIHNjaGVkdWxlZF9hdCBmIHogPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucnVuX2F0XCIgc2NoZWR1bGVkX2F0IFslc2V4cF9vZjogVGltZV9ucy50XTtcbiAgICBsZXQgdCA9XG4gICAgICB7IGFsYXJtID0gQWxhcm0ubnVsbCAoKVxuICAgICAgOyBmaXJlID0gaWdub3JlICgqIHNldCBiZWxvdyAqKVxuICAgICAgOyBmaXJlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICA7IG51bV9maXJlc190b19za2lwID0gMFxuICAgICAgOyBzY2hlZHVsZWRfYXRcbiAgICAgIDsgdGltZV9zb3VyY2UgPSByZWFkX29ubHkgdGltZV9zb3VyY2VcbiAgICAgIH1cbiAgICBpblxuICAgIGxldCBmaXJlICgpID1cbiAgICAgICgqIFtmaXJlXSBydW5zIGluIGFuIEFzeW5jIGpvYi4gIFRoZSBldmVudCBtYXkgaGF2ZSBiZWVuIGFib3J0ZWQgYWZ0ZXIgdGhlIGpvYlxuICAgICAgICAgd2FzIGVucXVldWVkLCBzbyBbZmlyZV0gbXVzdCBjaGVjayBbZmlyZWRdLiAqKVxuICAgICAgaWYgSXZhci5pc19lbXB0eSB0LmZpcmVkXG4gICAgICB0aGVuXG4gICAgICAgIGlmIHQubnVtX2ZpcmVzX3RvX3NraXAgPiAwXG4gICAgICAgIHRoZW4gdC5udW1fZmlyZXNfdG9fc2tpcCA8LSB0Lm51bV9maXJlc190b19za2lwIC0gMVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZiB6IGluXG4gICAgICAgICAgKCogW2Ygel0gbWF5IGhhdmUgYWJvcnRlZCB0aGUgZXZlbnQsIHNvIHdlIG11c3QgY2hlY2sgW2ZpcmVkXSBhZ2Fpbi4gKilcbiAgICAgICAgICBpZiBJdmFyLmlzX2VtcHR5IHQuZmlyZWQgdGhlbiBJdmFyLmZpbGwgdC5maXJlZCAoSGFwcGVuZWQgcmVzdWx0KSlcbiAgICBpblxuICAgIHQuZmlyZSA8LSBmaXJlO1xuICAgIHNjaGVkdWxlIHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBhdCB0aW1lX3NvdXJjZSB0aW1lID0gcnVuX2F0IHRpbWVfc291cmNlIHRpbWUgaWdub3JlICgpXG5cbiAgbGV0IHJ1bl9hZnRlciB0aW1lX3NvdXJjZSBzcGFuIGYgYSA9XG4gICAgcnVuX2F0IHRpbWVfc291cmNlIChzcGFuX3RvX3RpbWUgdGltZV9zb3VyY2Ugc3BhbikgZiBhXG4gIDs7XG5cbiAgbGV0IGFmdGVyIHRpbWVfc291cmNlIHNwYW4gPSBhdCB0aW1lX3NvdXJjZSAoc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW4pXG5lbmRcblxubGV0IGF0X3RpbWVzID8oc3RvcCA9IERlZmVycmVkLm5ldmVyICgpKSB0IG5leHRfdGltZSA9XG4gIGxldCB0YWlsID0gVGFpbC5jcmVhdGUgKCkgaW5cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBjaG9vc2VcbiAgICAgIFsgY2hvaWNlIHN0b3AgKGZ1biAoKSAtPiBgU3RvcCk7IGNob2ljZSAoYXQgdCAobmV4dF90aW1lICgpKSkgKGZ1biAoKSAtPiBgVGljaykgXVxuICAgID4+PiBmdW5jdGlvblxuICAgIHwgYFN0b3AgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgIHwgYFRpY2sgLT5cbiAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgKCk7XG4gICAgICBsb29wICgpXG4gIGluXG4gIGxvb3AgKCk7XG4gIFRhaWwuY29sbGVjdCB0YWlsXG47O1xuXG5sZXQgYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgdCBjb21wdXRlX3NwYW4gPVxuICBhdF90aW1lcyB0ID9zdG9wIChmdW4gKCkgLT4gVGltZV9ucy5hZnRlciAobm93IHQpIChjb21wdXRlX3NwYW4gKCkpKVxuOztcblxubGV0IGF0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgdCBpbnRlcnZhbCA9XG4gIGxldCBzdGFydCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT4gbm93IHRcbiAgaW5cbiAgYXRfdGltZXMgdCA/c3RvcCAoZnVuICgpIC0+XG4gICAgVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlOnN0YXJ0IH5hZnRlcjoobm93IHQpIH5pbnRlcnZhbCAoKSlcbjs7XG5cbm1vZHVsZSBDb250aW51ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgSW1tZWRpYXRlbHlcbiAgICB8IEFmdGVyIG9mIFRpbWVfbnMuU3Bhbi50XG4gICAgfCBOZXh0X211bHRpcGxlIG9mIFRpbWVfbnMudCAqIFRpbWVfbnMuU3Bhbi50XG5cbiAgbGV0IGltbWVkaWF0ZWx5ID0gSW1tZWRpYXRlbHlcblxuICBsZXQgYXQgdCB0aW1lX3NvdXJjZSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBJbW1lZGlhdGVseSAtPiBUaW1pbmdfd2hlZWwubm93IHRpbWVfc291cmNlLmV2ZW50c1xuICAgIHwgQWZ0ZXIgc3BhbiAtPiBzcGFuX3RvX3RpbWUgdGltZV9zb3VyY2Ugc3BhblxuICAgIHwgTmV4dF9tdWx0aXBsZSAoYmFzZSwgaW50ZXJ2YWwpIC0+XG4gICAgICBUaW1lX25zLm5leHRfbXVsdGlwbGUgfmJhc2UgfmFmdGVyOihub3cgdGltZV9zb3VyY2UpIH5pbnRlcnZhbCAoKVxuICA7O1xuZW5kXG5cbmxldCBydW5fcmVwZWF0ZWRseVxuICAgICAgPyhzdGFydCA9IHJldHVybiAoKSlcbiAgICAgID9zdG9wXG4gICAgICA/KGNvbnRpbnVlX29uX2Vycm9yID0gdHJ1ZSlcbiAgICAgID8oZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKSlcbiAgICAgIHRcbiAgICAgIH5mXG4gICAgICB+Y29udGludWVcbiAgPVxuICBzdGFydFxuICA+Pj4gZnVuICgpIC0+XG4gIGxldCBhbGFybSA9IHJlZiAoQWxhcm0ubnVsbCAoKSkgaW5cbiAgbGV0IHN0b3AgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgU29tZSBzdG9wIC0+XG4gICAgICB1cG9uIHN0b3AgKGZ1biAoKSAtPlxuICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzICFhbGFybVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByZW1vdmVfYWxhcm0gdCAhYWxhcm07XG4gICAgICAgICAgSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpKSk7XG4gICAgICBzdG9wXG4gIGluXG4gICgqIFtydW5fZl0sIFtjb250aW51ZV9mXSwgYW5kIFtjb250aW51ZV90cnlfd2l0aF0gYXJlIGRlZmluZWQgc28gdGhhdCB3ZSBhbGxvY2F0ZSB0aGVpclxuICAgICBjbG9zdXJlcyBvbmNlLCBub3Qgb25jZSBwZXIgaXRlcmF0aW9uLiAqKVxuICBsZXQgcmVjIHJ1bl9mICgpID1cbiAgICAoKiBCZWZvcmUgY2FsbGluZyBbZl0sIHdlIHN5bmNocm9ub3VzbHkgY2hlY2sgd2hldGhlciBbc3RvcF0gaXMgZGV0ZXJtaW5lZC4gKilcbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICB0aGVuIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKVxuICAgIGVsc2UgaWYgY29udGludWVfb25fZXJyb3JcbiAgICB0aGVuIE1vbml0b3IudHJ5X3dpdGggZiB+cnVuOmBOb3cgfnJlc3Q6YFJhaXNlID4+PiBjb250aW51ZV90cnlfd2l0aFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGQgPSBmICgpIGluXG4gICAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIGQgdGhlbiBjb250aW51ZV9mICgpIGVsc2UgZCA+Pj4gY29udGludWVfZilcbiAgYW5kIGNvbnRpbnVlX2YgKCkgPVxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgc3RvcFxuICAgIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpXG4gICAgZWxzZSBhbGFybSA6PSBydW5fYXRfaW50ZXJuYWwgdCAoQ29udGludWUuYXQgY29udGludWUgdCkgcnVuX2YgKClcbiAgYW5kIGNvbnRpbnVlX3RyeV93aXRoIG9yX2Vycm9yID1cbiAgICAobWF0Y2ggb3JfZXJyb3Igd2l0aFxuICAgICB8IE9rICgpIC0+ICgpXG4gICAgIHwgRXJyb3IgZXJyb3IgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlcnJvcik7XG4gICAgY29udGludWVfZiAoKVxuICBpblxuICBydW5fZiAoKVxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCB0IHNwYW4gZiA9XG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2UuZXZlcnkgZ290IG5vbnBvc2l0aXZlIHNwYW5cIiAoc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV07XG4gIHJ1bl9yZXBlYXRlZGx5IHQgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgfmYgfmNvbnRpbnVlOihBZnRlciBzcGFuKVxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBzcGFuIGYgPVxuICBldmVyeScgdCA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZDpOb25lIHNwYW4gKGZ1biAoKSAtPlxuICAgIGYgKCk7XG4gICAgcmV0dXJuICgpKVxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgbGV0IG5vdyA9IG5vdyB0IGluXG4gIGxldCBiYXNlLCBzdGFydCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgTm9uZSAtPiBub3csIE5vbmVcbiAgICB8IFNvbWUgc3RhcnQgLT5cbiAgICAgICggc3RhcnRcbiAgICAgICwgU29tZVxuICAgICAgICAgIChhdFxuICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAoVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICB+YmFzZTpzdGFydFxuICAgICAgICAgICAgICAgIH5hZnRlcjpub3dcbiAgICAgICAgICAgICAgICB+Y2FuX2VxdWFsX2FmdGVyOnRydWVcbiAgICAgICAgICAgICAgICB+aW50ZXJ2YWwpKSApXG4gIGluXG4gIHJ1bl9yZXBlYXRlZGx5XG4gICAgdFxuICAgID9zdGFydFxuICAgID9zdG9wXG4gICAgP2NvbnRpbnVlX29uX2Vycm9yXG4gICAgfmZcbiAgICB+Y29udGludWU6KE5leHRfbXVsdGlwbGUgKGJhc2UsIGludGVydmFsKSlcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciB0IGludGVydmFsIChmdW4gKCkgLT5cbiAgICBmICgpO1xuICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCB3aXRoX3RpbWVvdXQgdCBzcGFuIGQgPVxuICBsZXQgdGltZW91dCA9IEV2ZW50LmFmdGVyIHQgc3BhbiBpblxuICBjaG9vc2VcbiAgICAoKiBUaGUgY29kZSBiZWxvdyBkb2VzIGV4aGF1c3RpdmUgY2FzZSBhbmFseXNpcyBpbiBib3RoIFtjaG9pY2Vdcy4gIEJlY2F1c2UgW3RpbWVvdXRdXG4gICAgICAgZG9lcyBub3QgZXNjYXBlIHRoZSBzY29wZSBvZiB0aGlzIGZ1bmN0aW9uLCBjZXJ0YWluIGNhc2VzIHNob3VsZCBiZSBpbXBvc3NpYmxlLCBhbmRcbiAgICAgICBhcmUgbWFya2VkIGFzIHN1Y2ggd2l0aCBleGNlcHRpb25zLiAgV2UgZG8gbm90IGV4cGVjdCB0aG9zZSBleGNlcHRpb25zIHRvIG9jY3VyLFxuICAgICAgIGJ1dCBpZiB0aGV5IGRvLCBpdCBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFtjaG9vc2VdIHJhdGhlciB0aGFuXG4gICAgICAgW3dpdGhfdGltZW91dF0uICopXG4gICAgWyBjaG9pY2UgZCAoZnVuIHYgLT5cbiAgICAgICAgKG1hdGNoIEV2ZW50LmFib3J0IHRpbWVvdXQgKCkgd2l0aFxuICAgICAgICAgKCogW1ByZXZpb3VzbHlfaGFwcGVuZWRdIGNhbiBvY2N1ciBpZiBib3RoIFtkXSBhbmQgW3dhaXRdIGJlY29tZSBkZXRlcm1pbmVkIGF0XG4gICAgICAgICAgICB0aGUgc2FtZSB0aW1lLCBlLmcuIFt3aXRoX3RpbWVvdXQgKHNlYyAwLikgKHJldHVybiAoKSldLiAqKVxuICAgICAgICAgfCBPayB8IFByZXZpb3VzbHlfaGFwcGVuZWQgKCkgLT4gKClcbiAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+XG4gICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1Zzogc2hvdWxkIG9ubHkgYWJvcnQgb25jZVwiXSk7XG4gICAgICAgIGBSZXN1bHQgdilcbiAgICA7IGNob2ljZSAoRXZlbnQuZmlyZWQgdGltZW91dCkgKGZ1bmN0aW9uXG4gICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gYFRpbWVvdXRcbiAgICAgICAgfCBBYm9ydGVkICgpIC0+XG4gICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1ZzogYm90aCBjb21wbGV0ZWQgYW5kIHRpbWVkIG91dFwiXSlcbiAgICBdXG47O1xuXG5sZXQgZHVyYXRpb25fb2YgdCBmID1cbiAgbGV0IHN0YXJ0ID0gbm93IHQgaW5cbiAgbGV0JW1hcCByZXN1bHQgPSBmICgpIGluXG4gIGxldCBkdXJhdGlvbiA9IFRpbWVfbnMuZGlmZiAobm93IHQpIHN0YXJ0IGluXG4gIHJlc3VsdCwgZHVyYXRpb25cbjs7XG5cbmxldCBvZl9zeW5jaHJvbm91cyB0ID0gdFxubGV0IHRvX3N5bmNocm9ub3VzIHQgPSB0XG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgXyB0ID1cbiAgfCBTdGFjayA6ICdhIFN0YWNrLnQgLT4gJ2EgdFxuICB8IENvdW50ZXIgOiB7IG11dGFibGUgbGVuZ3RoIDogaW50IH0gLT4gdW5pdCB0XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID0gU3RhY2sgKFN0YWNrLm9mX2xpc3QgbGlzdClcblxubGV0IGNyZWF0ZV9jb3VudGVyIH5sZW5ndGggPVxuICBpZiBsZW5ndGggPCAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJbU3RhY2tfb3JfY291bnRlci5jcmVhdGVfY291bnRlcl0gZ290IG5lZ2F0aXZlIGxlbmd0aFwiIChsZW5ndGggOiBpbnQpXTtcbiAgQ291bnRlciB7IGxlbmd0aCB9XG47O1xuXG5sZXQgbGVuZ3RoICh0eXBlIGEpICh0IDogYSB0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2subGVuZ3RoIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGhcbjs7XG5cbmxldCBjbGVhciAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLmNsZWFyIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGggPC0gMFxuOztcblxubGV0IHB1c2ggKHR5cGUgYSkgKHQgOiBhIHQpIGEgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLnB1c2ggcyBhXG4gIHwgQ291bnRlciByIC0+IHIubGVuZ3RoIDwtIHIubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9leG4gKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5wb3BfZXhuIHNcbiAgfCBDb3VudGVyIHIgLT5cbiAgICBpZiByLmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIltTdGFja19vcl9jb3VudGVyLnBvcF9leG5dIG9mIGVtcHR5IHN0YWNrXCJdO1xuICAgIHIubGVuZ3RoIDwtIHIubGVuZ3RoIC0gMVxuOztcblxubGV0IGl0ZXIgKHR5cGUgYSkgKHQgOiBhIHQpIH4oZiA6IGEgLT4gdW5pdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLml0ZXIgcyB+ZlxuICB8IENvdW50ZXIgciAtPlxuICAgIGZvciBfID0gMSB0byByLmxlbmd0aCBkb1xuICAgICAgZiAoKVxuICAgIGRvbmVcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbnR5cGUgJ2Egb3V0Y29tZSA9XG4gIFsgYE9rIG9mICdhXG4gIHwgYEFib3J0ZWRcbiAgfCBgUmFpc2VkIG9mIGV4blxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgSW50ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGUgOiAoJ2EgLT4gJ2IgRGVmZXJyZWQudCkgLT4gJ2EgdCAqICdiIG91dGNvbWUgRGVmZXJyZWQudFxuXG4gICgqIEV2ZXJ5IGludGVybmFsIGpvYiB3aWxsIGV2ZW50dWFsbHkgYmUgZWl0aGVyIFtydW5dIG9yIFthYm9ydF1lZCwgYnV0IG5vdCBib3RoLiAqKVxuXG4gIHZhbCBydW4gOiAnYSB0IC0+ICdhIC0+IFsgYE9rIHwgYFJhaXNlZCBdIERlZmVycmVkLnRcbiAgdmFsIGFib3J0IDogXyB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgc3RhcnQgOiBbIGBBYm9ydCB8IGBTdGFydCBvZiAnYSBdIEl2YXIudFxuICAgIDsgb3V0Y29tZSA6IFsgYE9rIHwgYEFib3J0ZWQgfCBgUmFpc2VkIF0gRGVmZXJyZWQudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlIHdvcmsgPVxuICAgIGxldCBzdGFydCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgbGV0IHJlc3VsdCA9XG4gICAgICBtYXRjaCViaW5kIEl2YXIucmVhZCBzdGFydCB3aXRoXG4gICAgICB8IGBBYm9ydCAtPiByZXR1cm4gYEFib3J0ZWRcbiAgICAgIHwgYFN0YXJ0IGEgLT5cbiAgICAgICAgKG1hdGNoJW1hcFxuICAgICAgICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgICAgICAgfnJ1bjpcbiAgICAgICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgICAgICAoZnVuICgpIC0+IHdvcmsgYSlcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgT2sgYSAtPiBgT2sgYVxuICAgICAgICAgfCBFcnJvciBleG4gLT4gYFJhaXNlZCBleG4pXG4gICAgaW5cbiAgICBsZXQgb3V0Y29tZSA9XG4gICAgICBtYXRjaCVtYXAgcmVzdWx0IHdpdGhcbiAgICAgIHwgYE9rIF8gLT4gYE9rXG4gICAgICB8IGBBYm9ydGVkIC0+IGBBYm9ydGVkXG4gICAgICB8IGBSYWlzZWQgXyAtPiBgUmFpc2VkXG4gICAgaW5cbiAgICBsZXQgdCA9IHsgc3RhcnQ7IG91dGNvbWUgfSBpblxuICAgIHQsIHJlc3VsdFxuICA7O1xuXG4gIGxldCBydW4gdCBhID1cbiAgICBJdmFyLmZpbGwgdC5zdGFydCAoYFN0YXJ0IGEpO1xuICAgIG1hdGNoJW1hcCB0Lm91dGNvbWUgd2l0aFxuICAgIHwgYEFib3J0ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCAoYE9rIHwgYFJhaXNlZCkgYXMgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IGFib3J0IHQgPSBJdmFyLmZpbGwgdC5zdGFydCBgQWJvcnRcbmVuZFxuXG50eXBlICdhIHQgPVxuICB7IGNvbnRpbnVlX29uX2Vycm9yIDogYm9vbFxuICA7IG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnRcbiAgOyAoKiBbam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXSBob2xkcyByZXNvdXJjZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBpbiB1c2UgYnkgYVxuICAgICAgIHJ1bm5pbmcgam9iLiAqKVxuICAgIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSA6ICdhIFN0YWNrX29yX2NvdW50ZXIudFxuICA7XG4gICAgKCogW2pvYnNfd2FpdGluZ190b19zdGFydF0gaXMgdGhlIHF1ZXVlIG9mIGpvYnMgdGhhdCBoYXZlbid0IHlldCBzdGFydGVkLiAqKVxuICAgIGpvYnNfd2FpdGluZ190b19zdGFydCA6ICdhIEludGVybmFsX2pvYi50IFF1ZXVlLnRcbiAgOyAoKiBbMCA8PSBudW1fam9ic19ydW5uaW5nIDw9IG1heF9jb25jdXJyZW50X2pvYnNdLiAqKVxuICAgIG11dGFibGUgbnVtX2pvYnNfcnVubmluZyA6IGludFxuICA7ICgqIFtjYXBhY2l0eV9hdmFpbGFibGVdIGlzIFtTb21lIGl2YXJdIGlmIHVzZXIgY29kZSBoYXMgY2FsbGVkIFtjYXBhY2l0eV9hdmFpbGFibGUgdF1cbiAgICAgICBhbmQgaXMgd2FpdGluZyB0byBiZSBub3RpZmllZCB3aGVuIGNhcGFjaXR5IGlzIGF2YWlsYWJsZSBpbiB0aGUgdGhyb3R0bGUuXG4gICAgICAgW21heWJlX3N0YXJ0X2pvYl0gd2lsbCBmaWxsIFtpdmFyXSB3aGVuIGNhcGFjaXR5IGJlY29tZXMgYXZhaWxhYmxlLCBpLmUuIHdoZW5cbiAgICAgICBbam9ic193YWl0aW5nX3RvX3N0YXJ0XSBpcyBlbXB0eSBhbmQgW251bV9qb2JzX3J1bm5pbmcgPCBtYXhfY29uY3VycmVudF9qb2JzXS4gKilcbiAgICBtdXRhYmxlIGNhcGFjaXR5X2F2YWlsYWJsZSA6IHVuaXQgSXZhci50IG9wdGlvblxuICA7ICgqIFtpc19kZWFkXSBpcyB0cnVlIGlmIFt0XSB3YXMga2lsbGVkIGR1ZSB0byBhIGpvYiByYWlzaW5nIGFuIGV4Y2VwdGlvbiBvciBba2lsbCB0XVxuICAgICAgIGJlaW5nIGNhbGxlZC4gKilcbiAgICBtdXRhYmxlIGlzX2RlYWQgOiBib29sXG4gIDsgKCogW2NsZWFuc10gaG9sZHMgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gY2xlYW4gZWFjaCByZXNvdXJjZSB3aGVuIFt0XSBpc1xuICAgICAgIGtpbGxlZC4gKilcbiAgICBtdXRhYmxlIGNsZWFucyA6ICgnYSAtPiB1bml0IERlZmVycmVkLnQpIGxpc3RcbiAgOyAoKiBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF0gaXMgdGhlIG51bWJlciBvZiByZXNvdXJjZXMgd2hvc2UgY2xlYW4gZnVuY3Rpb25zIGhhdmVcbiAgICAgICBub3QgeWV0IGNvbXBsZXRlZC4gIFdoaWxlIFt0XSBpcyBhbGl2ZSwgW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPVxuICAgICAgIG1heF9jb25jdXJyZW50X2pvYnNdLiAgT25jZSBbdF0gaXMga2lsbGVkLCBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF0gZGVjcmVhc2VzIHRvXG4gICAgICAgemVybyBvdmVyIHRpbWUgYXMgdGhlIGNsZWFuIGZ1bmN0aW9ucyBjb21wbGV0ZS4gKilcbiAgICBtdXRhYmxlIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgOiBpbnRcbiAgOyAoKiBbY2xlYW5lZF0gYmVjb21lcyBkZXRlcm1pbmVkIHdoZW4gW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIHJlYWNoZXMgemVybyxcbiAgICAgICBpLmUuIGFmdGVyIFt0XSBpcyBraWxsZWQgYW5kIGFsbCBpdHMgY2xlYW4gZnVuY3Rpb25zIGNvbXBsZXRlLiAqKVxuICAgIGNsZWFuZWQgOiB1bml0IEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y29udGludWVfb25fZXJyb3I6aWdub3JlXG4gICAgICB+bWF4X2NvbmN1cnJlbnRfam9iczpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2NvbmN1cnJlbnRfam9icyAtPiBhc3NlcnQgKG1heF9jb25jdXJyZW50X2pvYnMgPiAwKSkpXG4gICAgICB+am9iX3Jlc291cmNlc19ub3RfaW5fdXNlOlxuICAgICAgICAoY2hlY2sgKGZ1biBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgLT5cbiAgICAgICAgICAgU3RhY2tfb3JfY291bnRlci5pdGVyIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSB+ZjppbnZhcmlhbnRfYTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBTdGFja19vcl9jb3VudGVyLmxlbmd0aCBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VcbiAgICAgICAgICAgICA9IGlmIHQuaXNfZGVhZCB0aGVuIDAgZWxzZSB0Lm1heF9jb25jdXJyZW50X2pvYnMgLSB0Lm51bV9qb2JzX3J1bm5pbmcpKSlcbiAgICAgIH5qb2JzX3dhaXRpbmdfdG9fc3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuY3Rpb24gam9ic193YWl0aW5nX3RvX3N0YXJ0IC0+XG4gICAgICAgICAgIGlmIHQuaXNfZGVhZCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgam9ic193YWl0aW5nX3RvX3N0YXJ0KSkpXG4gICAgICB+bnVtX2pvYnNfcnVubmluZzpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX2pvYnNfcnVubmluZyAtPlxuICAgICAgICAgICBhc3NlcnQgKG51bV9qb2JzX3J1bm5pbmcgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobnVtX2pvYnNfcnVubmluZyA8PSB0Lm1heF9jb25jdXJyZW50X2pvYnMpO1xuICAgICAgICAgICBpZiBudW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydCkpKVxuICAgICAgfmNhcGFjaXR5X2F2YWlsYWJsZTpcbiAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgfCBTb21lIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSlcbiAgICAgIH5pc19kZWFkOmlnbm9yZVxuICAgICAgfmNsZWFuczppZ25vcmVcbiAgICAgIH5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0+XG4gICAgICAgICAgIGFzc2VydCAobnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDw9IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gICAgICAgICAgIGlmIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPCB0Lm1heF9jb25jdXJyZW50X2pvYnMgdGhlbiBhc3NlcnQgdC5pc19kZWFkKSlcbiAgICAgIH5jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBjbGVhbmVkIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCBjbGVhbmVkIHRoZW4gYXNzZXJ0ICh0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPSAwKSkpXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaHJvdHRsZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgKHQgOiBfIHQpXVxuOztcblxubW9kdWxlIFQyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2tpbmQpIHQgPSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgdFxuZW5kXG5cbmxldCBudW1fam9ic193YWl0aW5nX3RvX3N0YXJ0IHQgPSBRdWV1ZS5sZW5ndGggdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnRcblxubGV0IGNsZWFuX3Jlc291cmNlIHQgYSA9XG4gIERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCB0LmNsZWFucyB+ZjooZnVuIGYgLT4gZiBhKSlcbiAgPj4+IGZ1biAoKSAtPlxuICB0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPC0gdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0gMTtcbiAgaWYgdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gMCB0aGVuIEl2YXIuZmlsbCB0LmNsZWFuZWQgKClcbjs7XG5cbmxldCBraWxsIHQgPVxuICBpZiBub3QgdC5pc19kZWFkXG4gIHRoZW4gKFxuICAgIHQuaXNfZGVhZCA8LSB0cnVlO1xuICAgIFF1ZXVlLml0ZXIgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgfmY6SW50ZXJuYWxfam9iLmFib3J0O1xuICAgIFF1ZXVlLmNsZWFyIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0O1xuICAgIFN0YWNrX29yX2NvdW50ZXIuaXRlciB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSB+ZjooZnVuIGEgLT4gY2xlYW5fcmVzb3VyY2UgdCBhKTtcbiAgICBTdGFja19vcl9jb3VudGVyLmNsZWFyIHQuam9iX3Jlc291cmNlc19ub3RfaW5fdXNlKVxuOztcblxubGV0IGF0X2tpbGwgdCBmID1cbiAgKCogV2UgcHJlc2VydmUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgZXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGdvIHRvIHRoZSBtb25pdG9yXG4gICAgIGluIGVmZmVjdCB3aGVuIFthdF9raWxsXSB3YXMgY2FsbGVkLiAqKVxuICBsZXQgZiA9IHVuc3RhZ2UgKE1vbml0b3IuRXhwb3J0ZWRfZm9yX3NjaGVkdWxlci5wcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCcgZikgaW5cbiAgdC5jbGVhbnMgPC0gZiA6OiB0LmNsZWFuc1xuOztcblxubGV0IGNsZWFuZWQgdCA9IEl2YXIucmVhZCB0LmNsZWFuZWRcblxubGV0IHJlYyBzdGFydF9qb2IgdCA9XG4gIGFzc2VydCAobm90IHQuaXNfZGVhZCk7XG4gIGFzc2VydCAodC5udW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgYXNzZXJ0IChub3QgKFF1ZXVlLmlzX2VtcHR5IHQuam9ic193YWl0aW5nX3RvX3N0YXJ0KSk7XG4gIGxldCBqb2IgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmpvYnNfd2FpdGluZ190b19zdGFydCBpblxuICB0Lm51bV9qb2JzX3J1bm5pbmcgPC0gdC5udW1fam9ic19ydW5uaW5nICsgMTtcbiAgbGV0IGpvYl9yZXNvdXJjZSA9IFN0YWNrX29yX2NvdW50ZXIucG9wX2V4biB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBpblxuICBJbnRlcm5hbF9qb2IucnVuIGpvYiBqb2JfcmVzb3VyY2VcbiAgPj4+IGZ1biByZXMgLT5cbiAgdC5udW1fam9ic19ydW5uaW5nIDwtIHQubnVtX2pvYnNfcnVubmluZyAtIDE7XG4gIChtYXRjaCByZXMgd2l0aFxuICAgfCBgT2sgLT4gKClcbiAgIHwgYFJhaXNlZCAtPiBpZiBub3QgdC5jb250aW51ZV9vbl9lcnJvciB0aGVuIGtpbGwgdCk7XG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIGNsZWFuX3Jlc291cmNlIHQgam9iX3Jlc291cmNlXG4gIGVsc2UgKFxuICAgIFN0YWNrX29yX2NvdW50ZXIucHVzaCB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBqb2JfcmVzb3VyY2U7XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydClcbiAgICB0aGVuIHN0YXJ0X2pvYiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCB0LmNhcGFjaXR5X2F2YWlsYWJsZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBpdmFyIC0+XG4gICAgICAgIEl2YXIuZmlsbCBpdmFyICgpO1xuICAgICAgICB0LmNhcGFjaXR5X2F2YWlsYWJsZSA8LSBOb25lKSlcbjs7XG5cbmxldCBjcmVhdGVfaW50ZXJuYWwgfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9IFN0YWNrX29yX2NvdW50ZXIubGVuZ3RoIGpvYl9yZXNvdXJjZXMgaW5cbiAgeyBjb250aW51ZV9vbl9lcnJvclxuICA7IG1heF9jb25jdXJyZW50X2pvYnNcbiAgOyBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgPSBqb2JfcmVzb3VyY2VzXG4gIDsgam9ic193YWl0aW5nX3RvX3N0YXJ0ID0gUXVldWUuY3JlYXRlICgpXG4gIDsgbnVtX2pvYnNfcnVubmluZyA9IDBcbiAgOyBjYXBhY2l0eV9hdmFpbGFibGUgPSBOb25lXG4gIDsgaXNfZGVhZCA9IGZhbHNlXG4gIDsgY2xlYW5zID0gW11cbiAgOyBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gbWF4X2NvbmN1cnJlbnRfam9ic1xuICA7IGNsZWFuZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICB9XG47O1xuXG5sZXQgY3JlYXRlX3dpdGggfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBjcmVhdGVfaW50ZXJuYWwgfmNvbnRpbnVlX29uX2Vycm9yIChTdGFja19vcl9jb3VudGVyLm9mX2xpc3Qgam9iX3Jlc291cmNlcylcbjs7XG5cbm1vZHVsZSBTZXF1ZW5jZXIgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID8oY29udGludWVfb25fZXJyb3IgPSBmYWxzZSkgYSA9IGNyZWF0ZV93aXRoIH5jb250aW51ZV9vbl9lcnJvciBbIGEgXVxuZW5kXG5cbmxldCBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgaWYgbWF4X2NvbmN1cnJlbnRfam9icyA8PSAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaHJvdHRsZS5jcmVhdGUgcmVxdWlyZXMgcG9zaXRpdmUgbWF4X2NvbmN1cnJlbnRfam9icywgYnV0IGdvdFwiXG4gICAgICAgICAgKG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnQpXTtcbiAgY3JlYXRlX2ludGVybmFsXG4gICAgfmNvbnRpbnVlX29uX2Vycm9yXG4gICAgKFN0YWNrX29yX2NvdW50ZXIuY3JlYXRlX2NvdW50ZXIgfmxlbmd0aDptYXhfY29uY3VycmVudF9qb2JzKVxuOztcblxubW9kdWxlIEpvYiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHsgaW50ZXJuYWxfam9iIDogJ2EgSW50ZXJuYWxfam9iLnRcbiAgICA7IHJlc3VsdCA6IFsgYE9rIG9mICdiIHwgYEFib3J0ZWQgfCBgUmFpc2VkIG9mIGV4biBdIERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IHJlc3VsdCB0ID0gdC5yZXN1bHRcbiAgbGV0IGFib3J0IHQgPSBJbnRlcm5hbF9qb2IuYWJvcnQgdC5pbnRlcm5hbF9qb2JcblxuICBsZXQgY3JlYXRlIGYgPVxuICAgIGxldCBpbnRlcm5hbF9qb2IsIHJlc3VsdCA9IEludGVybmFsX2pvYi5jcmVhdGUgZiBpblxuICAgIHsgaW50ZXJuYWxfam9iOyByZXN1bHQgfVxuICA7O1xuZW5kXG5cbmxldCBlbnF1ZXVlJyB0IGYgPVxuICBsZXQgam9iID0gSm9iLmNyZWF0ZSBmIGluXG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIEpvYi5hYm9ydCBqb2JcbiAgZWxzZSAoXG4gICAgUXVldWUuZW5xdWV1ZSB0LmpvYnNfd2FpdGluZ190b19zdGFydCBqb2IuaW50ZXJuYWxfam9iO1xuICAgIGlmIHQubnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9icyB0aGVuIHN0YXJ0X2pvYiB0KTtcbiAgSm9iLnJlc3VsdCBqb2Jcbjs7XG5cbmxldCBoYW5kbGVfZW5xdWV1ZV9yZXN1bHQgcmVzdWx0ID1cbiAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgfCBgT2sgYSAtPiBhXG4gIHwgYEFib3J0ZWQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJ0aHJvdHRsZSBhYm9ydGVkIGpvYlwiXVxuICB8IGBSYWlzZWQgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IGVucXVldWUgdCBmID0gZW5xdWV1ZScgdCBmID4+fCBoYW5kbGVfZW5xdWV1ZV9yZXN1bHRcblxubGV0IGVucXVldWVfZXhjbHVzaXZlIHQgZiA9XG4gIGxldCBuID0gdC5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gIGlmIEludC4oID49ICkgbiAxXzAwMF8wMDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslc2V4cFxuICAgICAgICBcIltlbnF1ZXVlX2V4Y2x1c2l2ZV0gd2FzIGNhbGxlZCB3aXRoIGEgdmVyeSBsYXJnZSB2YWx1ZSBvZiBcXFxuICAgICAgICAgW21heF9jb25jdXJyZW50X2pvYnNdLiBUaGlzIGRvZXNuJ3Qgd29yay5cIl07XG4gIGxldCBkb25lXyA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGFzc2VydCAobiA+IDApO1xuICBsZXQgZl9wbGFjZWhvbGRlciBfc2xvdCA9IEl2YXIucmVhZCBkb25lXyBpblxuICBmb3IgXyA9IDEgdG8gbiAtIDEgZG9cbiAgICBkb24ndF93YWl0X2ZvciAoZW5xdWV1ZSB0IGZfcGxhY2Vob2xkZXIpXG4gIGRvbmU7XG4gIGxldCVtYXAgcmVzdWx0ID0gZW5xdWV1ZScgdCAoZnVuIF9zbG90IC0+IGYgKCkpIGluXG4gIEl2YXIuZmlsbCBkb25lXyAoKTtcbiAgaGFuZGxlX2VucXVldWVfcmVzdWx0IHJlc3VsdFxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdyB+aG93IH5mID1cbiAgc3RhZ2VcbiAgICAobWF0Y2ggaG93IHdpdGhcbiAgICAgfCBgUGFyYWxsZWwgLT4gZlxuICAgICB8IChgU2VxdWVudGlhbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgIGxldCBtYXhfY29uY3VycmVudF9qb2JzID1cbiAgICAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICAgICB8IGBTZXF1ZW50aWFsIC0+IDFcbiAgICAgICAgIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPiBtYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgaW5cbiAgICAgICBsZXQgdCA9IGNyZWF0ZSB+Y29udGludWVfb25fZXJyb3I6ZmFsc2Ugfm1heF9jb25jdXJyZW50X2pvYnMgaW5cbiAgICAgICBmdW4gYSAtPiBlbnF1ZXVlIHQgKGZ1biAoKSAtPiBmIGEpKVxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZiA9XG4gIHN0YWdlXG4gICAgKG1hdGNoIGhvdyB3aXRoXG4gICAgIHwgYFBhcmFsbGVsIC0+IGZcbiAgICAgfCAoYFNlcXVlbnRpYWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9XG4gICAgICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgICAgfCBgU2VxdWVudGlhbCAtPiAxXG4gICAgICAgICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT4gbWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgIGluXG4gICAgICAgbGV0IHQgPSBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIH5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gICAgICAgZnVuIGExIGEyIC0+IGVucXVldWUgdCAoZnVuICgpIC0+IGYgYTEgYTIpKVxuOztcblxubGV0IHByaW9yX2pvYnNfZG9uZSB0ID1cbiAgKCogV2UgcXVldWUgW3QubWF4X2NvbmN1cnJlbnRfam9ic10gZHVtbXkgam9icyBhbmQgd2hlbiB0aGV5IGFyZSBhbGwgc3RhcnRlZCB3ZSBrbm93XG4gICAgIHRoYXQgYWxsIHByaW9yIGpvYnMgZmluaXNoZWQuICBXZSBtYWtlIHN1cmUgdGhhdCBhbGwgZHVtbXkgam9icyB3YWl0IGZvciB0aGUgbGFzdCBvbmVcbiAgICAgdG8gZ2V0IHN0YXJ0ZWQgYmVmb3JlIGZpbmlzaGluZy4gKilcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gYWxsX2R1bW15X2pvYnNfcnVubmluZyAtPlxuICAgIGxldCBkdW1teV9qb2JzX3J1bm5pbmcgPSByZWYgMCBpblxuICAgIGZvciBfID0gMSB0byB0Lm1heF9jb25jdXJyZW50X2pvYnMgZG9cbiAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgIChlbnF1ZXVlIHQgKGZ1biBfIC0+XG4gICAgICAgICAgIGluY3IgZHVtbXlfam9ic19ydW5uaW5nO1xuICAgICAgICAgICBpZiAhZHVtbXlfam9ic19ydW5uaW5nID0gdC5tYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgICAgIHRoZW4gSXZhci5maWxsIGFsbF9kdW1teV9qb2JzX3J1bm5pbmcgKCk7XG4gICAgICAgICAgIEl2YXIucmVhZCBhbGxfZHVtbXlfam9ic19ydW5uaW5nKSlcbiAgICBkb25lKVxuOztcblxubGV0IGNhcGFjaXR5X2F2YWlsYWJsZSB0ID1cbiAgaWYgbnVtX2pvYnNfcnVubmluZyB0IDwgbWF4X2NvbmN1cnJlbnRfam9icyB0XG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgKFxuICAgIG1hdGNoIHQuY2FwYWNpdHlfYXZhaWxhYmxlIHdpdGhcbiAgICB8IFNvbWUgaXZhciAtPiBJdmFyLnJlYWQgaXZhclxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+IHQuY2FwYWNpdHlfYXZhaWxhYmxlIDwtIFNvbWUgaXZhcikpXG47O1xuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcblxubGV0IGNyZWF0ZSA9IFNjaGVkdWxlcjEuY3JlYXRlX3RpbWVfc291cmNlXG5sZXQgd2FsbF9jbG9jayA9IFNjaGVkdWxlcjEud2FsbF9jbG9ja1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cbmluY2x1ZGUgKFNjaGVkdWxlciA6IG1vZHVsZSB0eXBlIG9mIFNjaGVkdWxlciB3aXRoIG1vZHVsZSBCdmFyIDo9IFNjaGVkdWxlci5CdmFyKVxuXG5sZXQgdCA9IFNjaGVkdWxlci50XG5cbmluY2x1ZGUgTW9uaXRvci5FeHBvcnRlZF9mb3Jfc2NoZWR1bGVyXG5cbmxldCBmaW5kX2xvY2FsIGtleSA9IEV4ZWN1dGlvbl9jb250ZXh0LmZpbmRfbG9jYWwgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBrZXlcblxubGV0IHdpdGhfbG9jYWwga2V5IHZhbHVlIH5mID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9XG4gICAgRXhlY3V0aW9uX2NvbnRleHQud2l0aF9sb2NhbCAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0KSBrZXkgdmFsdWVcbiAgaW5cbiAgd2l0aF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0IH5mXG47O1xuXG5sZXQgbWFpbl9leGVjdXRpb25fY29udGV4dCA9ICh0ICgpKS5tYWluX2V4ZWN1dGlvbl9jb250ZXh0XG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gbnVtX3BlbmRpbmdfam9icyB0ID4gMCB8fCBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkXG5sZXQgaGFzX3VwY29taW5nX2V2ZW50IHQgPSBub3QgKFRpbWluZ193aGVlbC5pc19lbXB0eSAoZXZlbnRzIHQpKVxubGV0IG5leHRfdXBjb21pbmdfZXZlbnQgdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0IChldmVudHMgdClcbmxldCBuZXh0X3VwY29taW5nX2V2ZW50X2V4biB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIChldmVudHMgdClcbmxldCBldmVudF9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gKGV2ZW50cyB0KVxubGV0IGN5Y2xlX3N0YXJ0IHQgPSB0LmN5Y2xlX3N0YXJ0XG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmYgPSB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCA8LSBmIDo6IHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0XG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCB0IH5mID0gdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIGYgOjogdC5ydW5fZXZlcnlfY3ljbGVfZW5kXG5cbmxldCBhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayB0IH5mID1cbiAgbGV0IGhhbmRsZSA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLmNyZWF0ZSAoKSBpblxuICBIYXNodGJsLmFkZF9leG4gdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgfmtleTpoYW5kbGUgfmRhdGE6ZjtcbiAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY7XG4gIGhhbmRsZVxuOztcblxubGV0IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayB0IH5mID1cbiAgbGV0IGhhbmRsZSA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLmNyZWF0ZSAoKSBpblxuICBIYXNodGJsLmFkZF9leG4gdC5ydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIH5rZXk6aGFuZGxlIH5kYXRhOmY7XG4gIHJ1bl9ldmVyeV9jeWNsZV9lbmQgdCB+ZjtcbiAgaGFuZGxlXG47O1xuXG4oKiBVbmJlbGlldmFibGUgdGhhdCBbTGlzdC5yZW1vdmVdIGlzIG5vdCBhIHRoaW5nICopXG5sZXQgbGlzdF9yZW1vdmVfZmlyc3QgbHN0IH5mID1cbiAgbWF0Y2ggTGlzdC5zcGxpdF93aGlsZSB+ZjooZnVuIHggLT4gbm90IChmIHgpKSBsc3Qgd2l0aFxuICB8IF8sIFtdIC0+IE5vbmVcbiAgfCBsLCBfIDo6IHIgLT4gU29tZSAobCBAIHIpXG47O1xuXG5sZXQgcmVtb3ZlX3NpbmdsZV9jeWNsZV9ob29rIGxzdCBmID1cbiAgKCogUmVtb3ZlIGEgc2luZ2xlIGluc3RhbmNlIG9mIFtmXSBmcm9tIFtsc3RdLiBNb3JlIHRoYW4gb25lIGluc3RhbmNlIG1heSBiZSBwcmVzZW50LFxuICAgICBidXQgcmVtb3ZhbCBpcyByZWZlcmVuY2UtY291bnRlZCBieSBbcnVuX2V2ZXJ5X2N5Y2xlXyhzdGFydHxlbmQpX3N0YXRlXSB0YWJsZXMuICopXG4gIG1hdGNoIGxpc3RfcmVtb3ZlX2ZpcnN0IH5mOihwaHlzX2VxdWFsIGYpIGxzdCB3aXRoXG4gIHwgU29tZSBsc3QgLT4gbHN0XG4gIHwgTm9uZSAtPlxuICAgICgqIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLCBzZWUgdGhlIFtpbnZhcmlhbnRdIGluIFtzY2hlZHVsZXIxLm1sXS4gKilcbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJTY2hlZHVsZXIucmVtb3ZlX3NpbmdsZV9jeWNsZV9ob29rIGNhbGxlZCB3aXRoIGEgaG9vayB0aGF0IGlzbid0IHJlZ2lzdGVyZWRcIl1cbjs7XG5cbmxldCByZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va19leG4gdCBoYW5kbGUgPVxuICBtYXRjaCBIYXNodGJsLmZpbmRfYW5kX3JlbW92ZSB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBzdGFydCBob29rIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cIlxuICB8IFNvbWUgZiAtPlxuICAgIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCBmXG47O1xuXG5sZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biB0IGhhbmRsZSA9XG4gIG1hdGNoIEhhc2h0YmwuZmluZF9hbmRfcmVtb3ZlIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBlbmQgaG9vayB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXCJcbiAgfCBTb21lIGYgLT4gdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQgZlxuOztcblxubGV0IG1hcF9jeWNsZV90aW1lcyB0IH5mID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgKGYgdC5sYXN0X2N5Y2xlX3RpbWUpKSlcbjs7XG5cbmxldCBsb25nX2N5Y2xlcyB0IH5hdF9sZWFzdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPlxuICAgICAgaWYgVGltZV9ucy5TcGFuLiggPj0gKSB0Lmxhc3RfY3ljbGVfdGltZSBhdF9sZWFzdFxuICAgICAgdGhlbiBUYWlsLmV4dGVuZCB0YWlsIHQubGFzdF9jeWNsZV90aW1lKSlcbjs7XG5cbmxldCBjeWNsZV9udW1fam9icyB0ID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgdC5sYXN0X2N5Y2xlX251bV9qb2JzKSlcbjs7XG5cbmxldCBjeWNsZV9jb3VudCB0ID0gdC5jeWNsZV9jb3VudFxuXG5sZXQgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgaW50ID1cbiAgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuICA8LSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5jcmVhdGVfZXhuIGludFxuOztcblxubGV0IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgPVxuICBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5yYXcgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuOztcblxubGV0IHNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayB0IGYgPSB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDwtIGZcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LmV4dGVybmFsX2pvYnMgKEV4dGVybmFsX2pvYi5UIChleGVjdXRpb25fY29udGV4dCwgZiwgYSkpO1xuICB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rICgpXG47O1xuXG5sZXQgc2V0X2V2ZW50X2FkZGVkX2hvb2sgdCBmID0gdC5ldmVudF9hZGRlZF9ob29rIDwtIFNvbWUgZlxubGV0IHNldF9qb2JfcXVldWVkX2hvb2sgdCBmID0gdC5qb2JfcXVldWVkX2hvb2sgPC0gU29tZSBmXG5cbmxldCBjcmVhdGVfYWxhcm0gdCBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIEdjLkV4cGVydC5BbGFybS5jcmVhdGUgKGZ1biAoKSAtPlxuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiAoKSlcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyIHQgaGVhcF9ibG9jayBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIGxldCBmaW5hbGl6ZXIgaGVhcF9ibG9jayA9XG4gICAgKCogSGVyZSB3ZSBjYW4gYmUgaW4gYW55IHRocmVhZCwgYW5kIG1heSBub3QgYmUgaG9sZGluZyB0aGUgYXN5bmMgbG9jay4gIFNvLCB3ZSBjYW5cbiAgICAgICBvbmx5IGRvIHRocmVhZC1zYWZlIHRoaW5ncy5cblxuICAgICAgIEJ5IHB1dHRpbmcgW2hlYXBfYmxvY2tdIGluIFtleHRlcm5hbF9qb2JzXSwgd2UgYXJlIGtlZXBpbmcgaXQgYWxpdmUgdW50aWwgdGhlIG5leHRcbiAgICAgICB0aW1lIHRoZSBhc3luYyBzY2hlZHVsZXIgZ2V0cyBhcm91bmQgdG8gZGVxdWV1ZWluZyBpdC4gIENhbGxpbmdcbiAgICAgICBbdC50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10gZW5zdXJlcyB0aGF0IHdpbGwgaGFwcGVuIGluIHNob3J0IG9yZGVyLiAgVGh1cyxcbiAgICAgICB3ZSBhcmUgbm90IGRyYW1hdGljYWxseSBpbmNyZWFzaW5nIHRoZSBsaWZldGltZSBvZiBbaGVhcF9ibG9ja10sIHNpbmNlIHRoZSBPQ2FtbFxuICAgICAgIHJ1bnRpbWUgYWxyZWFkeSByZXN1cnJlY3RlZCBbaGVhcF9ibG9ja10gc28gdGhhdCB3ZSBjb3VsZCByZWZlciB0byBpdCBoZXJlLiAgVGhlXG4gICAgICAgT0NhbWwgcnVudGltZSBhbHJlYWR5IHJlbW92ZWQgdGhlIGZpbmFsaXplciBmdW5jdGlvbiB3aGVuIGl0IG5vdGljZWQgW2hlYXBfYmxvY2tdXG4gICAgICAgY291bGQgYmUgZmluYWxpemVkLCBzbyB0aGVyZSBpcyBubyBpbmZpbml0ZSBsb29wIGluIHdoaWNoIHdlIGFyZSBjYXVzaW5nIHRoZVxuICAgICAgIGZpbmFsaXplciB0byBydW4gYWdhaW4uICBBbHNvLCBPQ2FtbCBkb2VzIG5vdCBpbXBvc2UgYW55IHJlcXVpcmVtZW50IG9uIGZpbmFsaXplclxuICAgICAgIGZ1bmN0aW9ucyB0aGF0IHRoZXkgbmVlZCB0byBkaXNwb3NlIG9mIHRoZSBibG9jaywgc28gaXQncyBmaW5lIHRoYXQgd2Uga2VlcFxuICAgICAgIFtoZWFwX2Jsb2NrXSBhcm91bmQgdW50aWwgbGF0ZXIuICopXG4gICAgaWYgRGVidWcuZmluYWxpemVycyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJlbnF1ZXVlaW5nIGZpbmFsaXplclwiO1xuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBoZWFwX2Jsb2NrXG4gIGluXG4gIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiYWRkaW5nIGZpbmFsaXplclwiO1xuICAoKiBXZSB1c2UgW0NhbWwuR2MuZmluYWxpc2VdIGluc3RlYWQgb2YgW0NvcmUuR2MuYWRkX2ZpbmFsaXplcl0gYmVjYXVzZSB0aGUgbGF0dGVyXG4gICAgIGhhcyBpdHMgb3duIHdyYXBwZXIgYXJvdW5kIFtDYW1sLkdjLmZpbmFsaXNlXSB0byBydW4gZmluYWxpemVycyBzeW5jaHJvbm91c2x5LiAqKVxuICB0cnkgQ2FtbC5HYy5maW5hbGlzZSBmaW5hbGl6ZXIgaGVhcF9ibG9jayB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgKCogW0hlYXBfYmxvY2tdIGVuc3VyZXMgdGhhdCB0aGlzIHdpbGwgb25seSBmYWlsIGZvciBzdGF0aWMgZGF0YSwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgICAgIGNhbiBkcm9wIHRoZSBmaW5hbGl6ZXIgc2luY2UgdGhlIGJsb2NrIHdpbGwgbmV2ZXIgYmUgY29sbGVjdGVkLiopXG4gICAgKClcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyX2V4biB0IHggZiA9XG4gIGFkZF9maW5hbGl6ZXIgdCAoSGVhcF9ibG9jay5jcmVhdGVfZXhuIHgpIChmdW4gaGVhcF9ibG9jayAtPlxuICAgIGYgKEhlYXBfYmxvY2sudmFsdWUgaGVhcF9ibG9jaykpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplcl9sYXN0IHQgaGVhcF9ibG9jayBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIGxldCBmaW5hbGl6ZXIgKCkgPVxuICAgICgqIEhlcmUgd2UgY2FuIGJlIGluIGFueSB0aHJlYWQsIGFuZCBtYXkgbm90IGJlIGhvbGRpbmcgdGhlIGFzeW5jIGxvY2suICBTbywgd2UgY2FuXG4gICAgICAgb25seSBkbyB0aHJlYWQtc2FmZSB0aGluZ3MuICopXG4gICAgaWYgRGVidWcuZmluYWxpemVyc1xuICAgIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImVucXVldWVpbmcgZmluYWxpemVyICh1c2luZyAnbGFzdCcgc2VtYW50aWMpXCI7XG4gICAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdCBleGVjdXRpb25fY29udGV4dCBmICgpXG4gIGluXG4gIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiYWRkaW5nIGZpbmFsaXplciAodXNpbmcgJ2xhc3QnIHNlbWFudGljKVwiO1xuICAoKiBXZSB1c2UgW0NhbWwuR2MuZmluYWxpc2VfbGFzdF0gaW5zdGVhZCBvZiBbQ29yZS5HYy5hZGRfZmluYWxpemVyX2xhc3RdIGJlY2F1c2VcbiAgICAgdGhlIGxhdHRlciBoYXMgaXRzIG93biB3cmFwcGVyIGFyb3VuZCBbQ2FtbC5HYy5maW5hbGlzZV9sYXN0XSB0byBydW4gZmluYWxpemVyc1xuICAgICBzeW5jaHJvbm91c2x5LiAqKVxuICB0cnkgQ2FtbC5HYy5maW5hbGlzZV9sYXN0IGZpbmFsaXplciBoZWFwX2Jsb2NrIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICAoKiBbSGVhcF9ibG9ja10gZW5zdXJlcyB0aGF0IHRoaXMgd2lsbCBvbmx5IGZhaWwgZm9yIHN0YXRpYyBkYXRhLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgY2FuIGRyb3AgdGhlIGZpbmFsaXplciBzaW5jZSB0aGUgYmxvY2sgd2lsbCBuZXZlciBiZSBjb2xsZWN0ZWQuKilcbiAgICAoKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gdCB4IGYgPSBhZGRfZmluYWxpemVyX2xhc3QgdCAoSGVhcF9ibG9jay5jcmVhdGVfZXhuIHgpIGZcblxuKCoqIFtmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZF0gc2V0cyB0aGUgbnVtYmVyIG9mIG5vcm1hbCBqb2JzIGFsbG93ZWQgdG8gcnVuIGluIHRoaXNcbiAgICBjeWNsZSB0byB6ZXJvLiAgVGh1cywgYWZ0ZXIgdGhlIGN1cnJlbnRseSBydW5uaW5nIGpvYiBjb21wbGV0ZXMsIHRoZSBzY2hlZHVsZXIgd2lsbFxuICAgIHN3aXRjaCB0byBsb3cgcHJpb3JpdHkgam9icyBhbmQgdGhlbiBlbmQgdGhlIGN1cnJlbnQgY3ljbGUuICopXG5sZXQgZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmQgdCA9XG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5ub3JtYWxfcHJpb3JpdHlfam9icyAwXG47O1xuXG4oKiBXZSBwcmVhbGxvY2F0ZSBbc2VuZF9leG5dIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgb24gZWFjaCBjYWxsIHRvIFthZHZhbmNlX2Nsb2NrXS4gKilcbmxldCBzZW5kX2V4biA9IFNvbWUgTW9uaXRvci5zZW5kX2V4blxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH5ub3cgPVxuICBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYWR2YW5jZV9pbnRlcm5hbCB0LnRpbWVfc291cmNlIH50b186bm93IH5zZW5kX2V4blxuOztcblxubGV0IHJ1bl9jeWNsZSB0ID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJydW5fY3ljbGUgc3RhcnRpbmdcIiB0IFslc2V4cF9vZjogdF07XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICB0LmN5Y2xlX2NvdW50IDwtIHQuY3ljbGVfY291bnQgKyAxO1xuICB0LmN5Y2xlX3N0YXJ0IDwtIG5vdztcbiAgdC5pbl9jeWNsZSA8LSB0cnVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnlpZWxkICgpO1xuICBsZXQgbnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlID0gbnVtX2pvYnNfcnVuIHQgaW5cbiAgTGlzdC5pdGVyIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IH5mOihmdW4gZiAtPiBmICgpKTtcbiAgYWR2YW5jZV9jbG9jayB0IH5ub3c7XG4gIHN0YXJ0X2N5Y2xlIHQgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHk6dC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZTtcbiAgbGV0IHJlYyBydW5fam9icyB0ID1cbiAgICBtYXRjaCBTY2hlZHVsZXIucnVuX2pvYnMgdCB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgKGV4biwgYmFja3RyYWNlKSAtPlxuICAgICAgTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBleG4gfmJhY2t0cmFjZTooYFRoaXMgYmFja3RyYWNlKTtcbiAgICAgICgqIFtydW5fam9ic10gc3RvcHBlZCBkdWUgdG8gYW4gZXhuLiAgVGhlcmUgbWF5IHN0aWxsIGJlIGpvYnMgdGhhdCBjb3VsZCBiZVxuICAgICAgICAgcnVuIHRoaXMgY3ljbGUsIHNvIFtydW5fam9ic10gYWdhaW4uICopXG4gICAgICBydW5fam9icyB0XG4gIGluXG4gIHJ1bl9qb2JzIHQ7XG4gIGxldCBjeWNsZV90aW1lID0gVGltZV9ucy5kaWZmIChUaW1lX25zLm5vdyAoKSkgdC5jeWNsZV9zdGFydCBpblxuICB0Lmxhc3RfY3ljbGVfdGltZSA8LSBjeWNsZV90aW1lO1xuICB0Lmxhc3RfY3ljbGVfbnVtX2pvYnMgPC0gbnVtX2pvYnNfcnVuIHQgLSBudW1fam9ic19ydW5fYXRfc3RhcnRfb2ZfY3ljbGU7XG4gIHQudG90YWxfY3ljbGVfdGltZSA8LSBUaW1lX25zLlNwYW4uKHQudG90YWxfY3ljbGVfdGltZSArIGN5Y2xlX3RpbWUpO1xuICBpZiBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluICYmIG51bV9wZW5kaW5nX2pvYnMgdCA9IDBcbiAgdGhlbiBCdmFyLmJyb2FkY2FzdCB0LnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluICgpO1xuICBMaXN0Lml0ZXIgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIH5mOihmdW4gZiAtPiBmICgpKTtcbiAgdC5pbl9jeWNsZSA8LSBmYWxzZTtcbiAgaWYgZGVidWdcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJydW5fY3ljbGUgZmluaXNoZWRcIlxuICAgICAgKHVuY2F1Z2h0X2V4biB0LCBpc19zb21lIChuZXh0X3VwY29taW5nX2V2ZW50IHQpKVxuICAgICAgWyVzZXhwX29mOiBFcnJvci50IG9wdGlvbiAqIGJvb2xdXG47O1xuXG5sZXQgcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiAoKSA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gc3RhcnRpbmdcIjtcbiAgbGV0IHQgPSB0ICgpIGluXG4gIGlmIGlzX2RlYWQgdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiBjYW5ub3QgcHJvY2VlZCAtLSBzY2hlZHVsZXIgaXMgZGVhZFwiXG4gICAgICAgICAgfnNjaGVkdWxlcjoodCA6IHQpXTtcbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBydW5fY3ljbGUgdDtcbiAgICBhZHZhbmNlX2Nsb2NrIHQgfm5vdzooVGltZV9ucy5ub3cgKCkpO1xuICAgIGlmIGNhbl9ydW5fYV9qb2IgdCB0aGVuIGxvb3AgKClcbiAgaW5cbiAgbG9vcCAoKTtcbiAgKCogUmVzZXQgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgdG8gbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHdoZW4gd2UncmUgbm90IGluXG4gICAgIGEgam9iLCBbY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IG1haW5fZXhlY3V0aW9uX2NvbnRleHRdLiAqKVxuICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB0Lm1haW5fZXhlY3V0aW9uX2NvbnRleHQ7XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gZmluaXNoZWRcIjtcbiAgT3B0aW9uLml0ZXIgKHVuY2F1Z2h0X2V4biB0KSB+ZjpFcnJvci5yYWlzZVxuOztcblxubGV0IG1ha2VfYXN5bmNfdW51c2FibGUgKCkgPVxuICBsZXQgdCA9ICF0X3JlZiBpblxuICB0LmNoZWNrX2FjY2Vzc1xuICA8LSBTb21lXG4gICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgIHJhaXNlX3MgWyVzZXhwIFwiQXN5bmMgc2NoZWR1bGVyIGlzIHVudXNhYmxlIGR1ZSB0byBbbWFrZV9hc3luY191bnVzYWJsZV1cIl0pXG47O1xuXG5sZXQgcmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3MgKCkgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJyZXNldF9pbl9mb3JrZWRfcHJvY2Vzc1wiO1xuICAoKiBUaGVyZSBpcyBubyBuZWVkIHRvIGVtcHR5IFttYWluX21vbml0b3JfaG9sZV0uICopXG4gIFNjaGVkdWxlci4odF9yZWYgOj0gY3JlYXRlICgpKVxuOztcblxubGV0IGNoZWNrX2ludmFyaWFudHMgdCA9IHQuY2hlY2tfaW52YXJpYW50c1xubGV0IHNldF9jaGVja19pbnZhcmlhbnRzIHQgYiA9IHQuY2hlY2tfaW52YXJpYW50cyA8LSBiXG5sZXQgc2V0X3JlY29yZF9iYWNrdHJhY2VzIHQgYiA9IHQucmVjb3JkX2JhY2t0cmFjZXMgPC0gYlxubGV0IHlpZWxkIHQgPSBCdmFyLndhaXQgdC55aWVsZFxuXG5sZXQgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gPyhtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ID0gZmFsc2UpIHQgPVxuICBpZiBtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICYmIG51bV9wZW5kaW5nX2pvYnMgdCA9IDBcbiAgdGhlbiByZXR1cm4gKClcbiAgZWxzZSBCdmFyLndhaXQgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpblxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIueWllbGRfZXZlcnkgZ290IG5vbnBvc2l0aXZlIGNvdW50XCIgKG4gOiBpbnQpXVxuICBlbHNlIGlmIG4gPSAxXG4gIHRoZW4gc3RhZ2UgKGZ1biB0IC0+IHlpZWxkIHQpXG4gIGVsc2UgKFxuICAgIGxldCBjb3VudF91bnRpbF95aWVsZCA9IHJlZiBuIGluXG4gICAgc3RhZ2UgKGZ1biB0IC0+XG4gICAgICBkZWNyIGNvdW50X3VudGlsX3lpZWxkO1xuICAgICAgaWYgIWNvdW50X3VudGlsX3lpZWxkID4gMFxuICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBjb3VudF91bnRpbF95aWVsZCA6PSBuO1xuICAgICAgICB5aWVsZCB0KSkpXG47O1xuXG5sZXQgdG90YWxfY3ljbGVfdGltZSB0ID1cbiAgKCogQWRqdXN0IGZvciB0aGUgZmFjdCB0aGUgY2FsbGVyJ3MgcHJvYmFibHkgYW4gQXN5bmMgam9iLiAqKVxuICBpZiB0LmluX2N5Y2xlXG4gIHRoZW4gKFxuICAgIGxldCB0aGlzX2N5Y2xlX3RpbWUgPSBUaW1lX25zLihkaWZmIChub3cgKCkpIHQuY3ljbGVfc3RhcnQpIGluXG4gICAgVGltZV9ucy5TcGFuLih0LnRvdGFsX2N5Y2xlX3RpbWUgKyB0aGlzX2N5Y2xlX3RpbWUpKVxuICBlbHNlIHQudG90YWxfY3ljbGVfdGltZVxuOztcblxubW9kdWxlIFZlcnlfbG93X3ByaW9yaXR5X3dvcmsgPSBzdHJ1Y3RcbiAgbW9kdWxlIFdvcmtlcl9yZXN1bHQgPSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIuRXhlY19yZXN1bHRcblxuXG4gIGxldCByZWMgcnVuIHQgPSBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nOjFfMDAwXG5cbiAgYW5kIHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPVxuICAgIGlmIG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSAwXG4gICAgdGhlbiB5aWVsZF90aGVuX3J1biB0XG4gICAgZWxzZSBpZiBub3QgKERlcXVlLmlzX2VtcHR5IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycylcbiAgICB0aGVuIChcbiAgICAgIGxldCB3b3JrZXIgPSBEZXF1ZS5kZXF1ZXVlX2Zyb250X2V4biB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgaW5cbiAgICAgIHNldF9leGVjdXRpb25fY29udGV4dCB0IHdvcmtlci5leGVjdXRpb25fY29udGV4dDtcbiAgICAgIHJ1bl93b3JrZXIgdCB3b3JrZXIgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcpXG5cbiAgYW5kIHlpZWxkX3RoZW5fcnVuIHQgPVxuICAgIGlmIG5vdCAoRGVxdWUuaXNfZW1wdHkgdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzKVxuICAgIHRoZW4gRGVmZXJyZWQudXBvbiAoeWllbGQgdCkgKGZ1biAoKSAtPiBydW4gdClcblxuICBhbmQgcnVuX3dvcmtlciB0IHdvcmtlciB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9XG4gICAgYXNzZXJ0IChwaHlzX2VxdWFsIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCB3b3JrZXIuZXhlY3V0aW9uX2NvbnRleHQpO1xuICAgIGlmIG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSAwXG4gICAgdGhlbiAoXG4gICAgICBEZXF1ZS5lbnF1ZXVlX2Zyb250IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyB3b3JrZXI7XG4gICAgICB5aWVsZF90aGVuX3J1biB0KVxuICAgIGVsc2UgKFxuICAgICAgbGV0IG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nIC0gMSBpblxuICAgICAgbWF0Y2ggd29ya2VyLmV4ZWMgKCkgd2l0aFxuICAgICAgfCBGaW5pc2hlZCAtPiBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nXG4gICAgICB8IE5vdF9maW5pc2hlZCAtPiBydW5fd29ya2VyIHQgd29ya2VyIH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nXG4gICAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgbGV0IGJ0ID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgICAgICBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4biB+YmFja3RyYWNlOihgVGhpcyBidCk7XG4gICAgICAgIHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcpXG4gIDs7XG5cbiAgbGV0IGVucXVldWUgfmYgPVxuICAgIGxldCB0ID0gdCAoKSBpblxuICAgIGxldCBxdWV1ZSA9IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyBpblxuICAgIGxldCBydW5uaW5nID0gbm90IChEZXF1ZS5pc19lbXB0eSBxdWV1ZSkgaW5cbiAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2UgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCkgfnByaW9yaXR5Okxvd1xuICAgIGluXG4gICAgRGVxdWUuZW5xdWV1ZV9iYWNrIHF1ZXVlIHsgZXhlY3V0aW9uX2NvbnRleHQ7IGV4ZWMgPSBmIH07XG4gICAgaWYgbm90IHJ1bm5pbmcgdGhlbiBlbnF1ZXVlIHQgZXhlY3V0aW9uX2NvbnRleHQgcnVuIHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX2JlbmNoID0gc3RydWN0XG4gIGxldCBhZHZhbmNlX2Nsb2NrID0gYWR2YW5jZV9jbG9ja1xuZW5kXG5cbmxldCBpbl9jeWNsZSB0ID0gdC5pbl9jeWNsZVxuIiwidHlwZSB0ID0gdW5pdCAtPiB1bml0XG5cbm1vZHVsZSBIYW5kbGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUudFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2NoZWR1bGVyXG5cbmxldCBlbnF1ZXVlX2pvYiBleGVjdXRpb25fY29udGV4dCBmIGEgPSBlbnF1ZXVlICh0ICgpKSBleGVjdXRpb25fY29udGV4dCBmIGFcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfam9iIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iICh0ICgpKSBleGVjdXRpb25fY29udGV4dCBmIGFcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSlcbmxldCBjeWNsZV9jb3VudCAoKSA9IGN5Y2xlX2NvdW50ICh0ICgpKVxubGV0IGN5Y2xlX3N0YXJ0X25zICgpID0gY3ljbGVfc3RhcnQgKHQgKCkpXG5sZXQgY3ljbGVfc3RhcnQgKCkgPSBUaW1lX25zLnRvX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdCAoY3ljbGVfc3RhcnRfbnMgKCkpXG5sZXQgY3ljbGVfdGltZXNfbnMgKCkgPSBtYXBfY3ljbGVfdGltZXMgKHQgKCkpIH5mOkZuLmlkXG5sZXQgY3ljbGVfdGltZXMgKCkgPSBtYXBfY3ljbGVfdGltZXMgKHQgKCkpIH5mOlRpbWVfbnMuU3Bhbi50b19zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3RcbmxldCB0b3RhbF9jeWNsZV90aW1lICgpID0gdG90YWxfY3ljbGVfdGltZSAodCAoKSlcbmxldCBsYXN0X2N5Y2xlX3RpbWUgKCkgPSBsYXN0X2N5Y2xlX3RpbWUgKHQgKCkpXG5sZXQgbG9uZ19jeWNsZXMgfmF0X2xlYXN0ID0gbG9uZ19jeWNsZXMgKHQgKCkpIH5hdF9sZWFzdFxubGV0IGV2ZW50X3ByZWNpc2lvbl9ucyAoKSA9IGV2ZW50X3ByZWNpc2lvbiAodCAoKSlcbmxldCBldmVudF9wcmVjaXNpb24gKCkgPSBUaW1lX25zLlNwYW4udG9fc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IChldmVudF9wcmVjaXNpb25fbnMgKCkpXG5cbmxldCBzZXRfbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgaSA9XG4gIHNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSAodCAoKSkgaVxuOztcblxubGV0IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlICgpID0gbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgKHQgKCkpXG5sZXQgc2V0X3JlY29yZF9iYWNrdHJhY2VzIGJvb2wgPSBzZXRfcmVjb3JkX2JhY2t0cmFjZXMgKHQgKCkpIGJvb2xcbmxldCBmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCAoKSA9IGZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kICh0ICgpKVxubGV0IHlpZWxkICgpID0geWllbGQgKHQgKCkpXG5cbmxldCB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA/bWF5X3JldHVybl9pbW1lZGlhdGVseSAoKSA9XG4gIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID9tYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICh0ICgpKVxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgbGV0IHlpZWxkX2V2ZXJ5ID0gU3RhZ2VkLnVuc3RhZ2UgKHlpZWxkX2V2ZXJ5IH5uKSBpblxuICBsZXQgdCA9IHQgKCkgaW5cbiAgc3RhZ2UgKGZ1biAoKSAtPiB5aWVsZF9ldmVyeSB0KVxuOztcblxubGV0IG51bV9qb2JzX3J1biAoKSA9IG51bV9qb2JzX3J1biAodCAoKSlcbmxldCBudW1fcGVuZGluZ19qb2JzICgpID0gbnVtX3BlbmRpbmdfam9icyAodCAoKSlcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiA9IHJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW5cbiAgbGV0IGxhc3RfY3ljbGVfbnVtX2pvYnMgKCkgPSBsYXN0X2N5Y2xlX251bV9qb2JzICh0ICgpKVxuICBsZXQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IGYgPSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgKHQgKCkpIH5mXG4gIGxldCBydW5fZXZlcnlfY3ljbGVfZW5kIGYgPSBydW5fZXZlcnlfY3ljbGVfZW5kICh0ICgpKSB+ZlxuICBsZXQgYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgfmYgPSBhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayAodCAoKSkgfmZcbiAgbGV0IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayB+ZiA9IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayAodCAoKSkgfmZcblxuICBsZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuIGhhbmRsZSA9XG4gICAgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuICh0ICgpKSBoYW5kbGVcbiAgOztcblxuICBsZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biBoYW5kbGUgPVxuICAgIHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gKHQgKCkpIGhhbmRsZVxuICA7O1xuXG4gIGxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IGV4ZWN1dGlvbl9jb250ZXh0IGYgPVxuICAgIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpIGV4ZWN1dGlvbl9jb250ZXh0IH5mXG4gIDs7XG5cbiAgbGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxIGV4ZWN1dGlvbl9jb250ZXh0IH5mIHggPVxuICAgIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxICh0ICgpKSBleGVjdXRpb25fY29udGV4dCB+ZiB4XG4gIDs7XG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBTY2hlZHVsZXJcbiIsIigqKiBTY2hlZHVsZSBqb2JzIHRvIHJ1biBhdCBhIHRpbWUgaW4gdGhlIGZ1dHVyZS5cblxuICAgIFRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIHVzZXMgYSBoZWFwIG9mIGV2ZW50cywgb25lIGZvciBlYWNoIGpvYiB0aGF0IG5lZWRzIHRvXG4gICAgcnVuIGluIHRoZSBmdXR1cmUuICBUaGUgQXN5bmMgc2NoZWR1bGVyIGlzIHJlc3BvbnNpYmxlIGZvciB3YWtpbmcgdXAgYXQgdGhlIHJpZ2h0IHRpbWVcbiAgICB0byBydW4gdGhlIGpvYnMuICopXG5cbm9wZW4gQ29yZVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBPcl90aW1lb3V0ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgUmVzdWx0IG9mICdhXG4gICAgfCBgVGltZW91dFxuICAgIF1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDbG9jayA9IHNpZ1xuICBtb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxuICBtb2R1bGUgVGltZSA6IHNpZ1xuICAgIG1vZHVsZSBTcGFuIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICBlbmRcblxuICAgIHR5cGUgdFxuICBlbmRcblxuICAoKiogW3J1bl9hdCB0aW1lIGYgYV0gcnVucyBbZiBhXSBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIFt0aW1lXS4gIElmIFt0aW1lXSBpcyBpbiB0aGVcbiAgICAgIHBhc3QsIHRoZW4gW3J1bl9hdF0gd2lsbCBpbW1lZGlhdGVseSBzY2hlZHVsZSBhIGpvYiBbdF0gdGhhdCB3aWxsIHJ1biBbZiBhXS4gIEluIG5vXG4gICAgICBzaXR1YXRpb24gd2lsbCBbcnVuX2F0XSBhY3R1YWxseSBjYWxsIFtmXSBpdHNlbGYuICBUaGUgY2FsbCB0byBbZl0gd2lsbCBhbHdheXMgYmUgaW5cbiAgICAgIGFub3RoZXIgam9iLiAqKVxuICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG5cbiAgKCoqIFtydW5fYWZ0ZXJdIGlzIGxpa2UgW3J1bl9hdF0sIGV4Y2VwdCB0aGF0IG9uZSBzcGVjaWZpZXMgYSB0aW1lIHNwYW4gcmF0aGVyIHRoYW4gYW5cbiAgICAgIGFic29sdXRlIHRpbWUuICopXG4gIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqKiBbYXQgdGltZV0gcmV0dXJucyBhIGRlZmVycmVkIFtkXSB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgYWZ0ZXIgW3RpbWVdLiAqKVxuICB2YWwgYXQgOiBUaW1lLnQgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgKCoqIFthZnRlcl0gaXMgbGlrZSBbYXRdLCBleGNlcHQgdGhhdCBvbmUgc3BlY2lmaWVzIGEgdGltZSBzcGFuIHJhdGhlciB0aGFuIGFuIGFic29sdXRlXG4gICAgICB0aW1lLiAqKVxuICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiB1bml0IERlZmVycmVkLnRcblxuICAoKiogW3dpdGhfdGltZW91dCBzcGFuIGRdIHJldHVybnMgYSBkZWZlcnJlZCB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgYWZ0ZXIgZWl0aGVyXG4gICAgICBbc3Bhbl0gZWxhcHNlcyBvciBbZF0gaXMgZGV0ZXJtaW5lZCwgcmV0dXJuaW5nIGVpdGhlciBbYFRpbWVvdXRdIG9yIFtgUmVzdWx0XVxuICAgICAgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBzdWNjZWVkZWQgZmlyc3QuICBBdCB0aGUgdGltZSB0aGUgcmV0dXJuZWQgZGVmZXJyZWQgYmVjb21lc1xuICAgICAgZGV0ZXJtaW5lZCwgYm90aCB0aGluZ3MgbWF5IGhhdmUgaGFwcGVuZWQsIGluIHdoaWNoIGNhc2UgW2BSZXN1bHRdIGlzIGdpdmVuXG4gICAgICBwcmVmZXJlbmNlLiAqKVxuICB2YWwgd2l0aF90aW1lb3V0IDogVGltZS5TcGFuLnQgLT4gJ2EgRGVmZXJyZWQudCAtPiAnYSBPcl90aW1lb3V0LnQgRGVmZXJyZWQudFxuXG4gICgqKiBFdmVudHMgcHJvdmlkZSB2YXJpYW50cyBvZiBbcnVuX2F0XSBhbmQgW3J1bl9hZnRlcl0gd2l0aCB0aGUgYWJpbGl0eSB0byBhYm9ydCBvclxuICAgICAgcmVzY2hlZHVsZSBhbiBldmVudCB0aGF0IGhhc24ndCB5ZXQgaGFwcGVuZWQuICBPbmNlIGFuIGV2ZW50IGhhcHBlbnMgb3IgaXMgYWJvcnRlZCxcbiAgICAgIEFzeW5jIGRvZXNuJ3QgdXNlIGFueSBzcGFjZSBmb3IgdHJhY2tpbmcgaXQuICopXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBzY2hlZHVsZWRfYXQgOiAoXywgXykgdCAtPiBUaW1lLnRcblxuICAgIG1vZHVsZSBTdGF0dXMgOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgICAgIHwgU2NoZWR1bGVkX2F0IG9mIFRpbWUudFxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgICgqKiBJZiBbc3RhdHVzXSByZXR1cm5zIFtTY2hlZHVsZWRfYXQgdGltZV0sIGl0IGlzIHBvc3NpYmxlIHRoYXQgW3RpbWUgPCBUaW1lLm5vdyAoKV1cbiAgICAgICAgaWYgQXN5bmMncyBzY2hlZHVsZXIgaGFzbid0IHlldCBnb3R0ZW4gdGhlIGNoYW5jZSB0byB1cGRhdGUgaXRzIGNsb2NrLCBlLmcuLCBkdWVcbiAgICAgICAgdG8gdXNlciBqb2JzIHJ1bm5pbmcuICopXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcblxuICAgICgqKiBMZXQgW3QgPSBydW5fYXQgdGltZSBmIHpdLiAgQXQgW3RpbWVdLCB0aGlzIHJ1bnMgW2Ygel0gYW5kIHRyYW5zaXRpb25zIFtzdGF0dXMgdF1cbiAgICAgICAgdG8gW0hhcHBlbmVkIGhdLCB3aGVyZSBbaF0gaXMgcmVzdWx0IG9mIFtmIHpdLlxuXG4gICAgICAgIE1vcmUgcHJlY2lzZWx5LCBhdCBbdGltZV0sIHByb3ZpZGVkIFthYm9ydCB0IGFdIGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGNhbGxlZCxcbiAgICAgICAgdGhpcyB3aWxsIGNhbGwgW2Ygel0sIHdpdGggdGhlIGd1YXJhbnRlZSB0aGF0IFtzdGF0dXMgdCA9IFNjaGVkdWxlZF9hdCB0aW1lXS4gIElmXG4gICAgICAgIFtmIHpdIHJldHVybnMgW2hdIGFuZCBkaWQgbm90IGNhbGwgW2Fib3J0IHQgYV0sIHRoZW4gW3N0YXR1cyB0XSBiZWNvbWVzIFtIYXBwZW5lZFxuICAgICAgICBoXS4gIElmIFtmIHpdIGNhbGxzIFthYm9ydCB0IGFdLCB0aGVuIHRoZSByZXN1bHQgb2YgW2ZdIGlzIGlnbm9yZWQsIGFuZCBbc3RhdHVzIHRdXG4gICAgICAgIGlzIFtBYm9ydGVkIGFdLlxuXG4gICAgICAgIElmIFtmIHpdIHJhaXNlcywgdGhlbiBbc3RhdHVzIHRdIGRvZXMgbm90IHRyYW5zaXRpb24gYW5kIHJlbWFpbnMgW1NjaGVkdWxlZF9hdFxuICAgICAgICB0aW1lXSwgYW5kIHRoZSBleGNlcHRpb24gaXMgc2VudCB0byB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlbiBbcnVuX2F0XSB3YXNcbiAgICAgICAgY2FsbGVkLiAqKVxuICAgIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCd6IC0+ICdoKSAtPiAneiAtPiAoXywgJ2gpIHRcblxuICAgIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgKCoqIFthYm9ydCB0XSBjaGFuZ2VzIFtzdGF0dXMgdF0gdG8gW0Fib3J0ZWRdIGFuZCByZXR1cm5zIFtPa10sIHVubGVzcyBbdF1cbiAgICAgICAgcHJldmlvdXNseSBoYXBwZW5lZCBvciB3YXMgcHJldmlvdXNseSBhYm9ydGVkLiAqKVxuICAgIHZhbCBhYm9ydCA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gKCdhLCAnaCkgQWJvcnRfcmVzdWx0LnRcblxuICAgICgqKiBbYWJvcnRfZXhuIHQgYV0gcmV0dXJucyBbdW5pdF0gaWYgW2Fib3J0IHQgYSA9IGBPa10sIGFuZCBvdGhlcndpc2UgcmFpc2VzLiAqKVxuICAgIHZhbCBhYm9ydF9leG4gOiAoJ2EsICdoKSB0IC0+ICdhIC0+IHVuaXRcblxuICAgICgqKiBbYWJvcnRfaWZfcG9zc2libGUgdCBhID0gaWdub3JlIChhYm9ydCB0IGEpXS4gKilcbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuXG4gICAgbW9kdWxlIEZpcmVkID0gVGltZV9zb3VyY2UuRXZlbnQuRmlyZWRcblxuICAgIHZhbCBmaXJlZCA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgRmlyZWQudCBEZWZlcnJlZC50XG5cbiAgICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5SZXNjaGVkdWxlX3Jlc3VsdFxuXG4gICAgKCoqIFtyZXNjaGVkdWxlX2F0IHRdIGFuZCBbcmVzY2hlZHVsZV9hZnRlciB0XSBjaGFuZ2UgdGhlIHRpbWUgdGhhdCBbdF0gd2lsbCBmaXJlLCBpZlxuICAgICAgICBwb3NzaWJsZSwgYW5kIGlmIG5vdCwgZ2l2ZSBhIHJlYXNvbiB3aHkuICBMaWtlIFtydW5fYXRdLCBpZiB0aGUgcmVxdWVzdGVkIHRpbWUgaXNcbiAgICAgICAgaW4gdGhlIHBhc3QsIHRoZSBldmVudCB3aWxsIGJlIHNjaGVkdWxlZCB0byBydW4gaW1tZWRpYXRlbHkuICBJZiBbcmVzY2hlZHVsZV9hdCB0XG4gICAgICAgIHRpbWUgPSBPa10sIHRoZW4gc3Vic2VxdWVudGx5IFtzY2hlZHVsZWRfYXQgdCA9IHRpbWVdLiAgKilcbiAgICB2YWwgcmVzY2hlZHVsZV9hdCA6ICgnYSwgJ2gpIHQgLT4gVGltZS50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcblxuICAgIHZhbCByZXNjaGVkdWxlX2FmdGVyIDogKCdhLCAnaCkgdCAtPiBUaW1lLlNwYW4udCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG5cbiAgICAoKiogW2F0IHRpbWVdICAgIGlzIFtydW5fYXQgICAgdGltZSBpZ25vcmUgKCldLlxuICAgICAgICBbYWZ0ZXIgdGltZV0gaXMgW3J1bl9hZnRlciB0aW1lIGlnbm9yZSAoKV0uXG5cbiAgICAgICAgWW91IHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSB0aGUgW3J1bl8qXSBmdW5jdGlvbnMsIHdoaWNoIGFsbG93IHlvdSB0b1xuICAgICAgICBzeW5jaHJvbm91c2x5IHVwZGF0ZSBzdGF0ZSB2aWEgYSB1c2VyLXN1cHBsaWVkIGZ1bmN0aW9uIHdoZW4gdGhlIGV2ZW50XG4gICAgICAgIHRyYW5zaXRpb25zIHRvIFtIYXBwZW5lZF0uICBUaGF0IGlzLCB0aGVyZSBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBydW5fYXQgdGltZSBmICgpIF19XG5cbiAgICAgICAgYW5kOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBhdCB0aW1lIGluXG4gICAgICAgICAgZmlyZWQgdFxuICAgICAgICAgID4+PiBmdW5jdGlvblxuICAgICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gZiAoKVxuICAgICAgICAgIHwgQWJvcnRlZCAoKSAtPiAoKSBdfVxuXG4gICAgICAgIFdpdGggW3J1bl9hdF0sIGlmIFtzdGF0dXMgdCA9IEhhcHBlbmVkXSwgb25lIGtub3dzIHRoYXQgW2ZdIGhhcyBydW4uICBXaXRoIFthdF1cbiAgICAgICAgYW5kIFtmaXJlZF0sIG9uZSBkb2VzIG5vdCBrbm93IHdoZXRoZXIgW2ZdIGhhcyB5ZXQgcnVuOyBpdCBtYXkgc3RpbGwgYmUgc2NoZWR1bGVkXG4gICAgICAgIHRvIHJ1bi4gIFRodXMsIHdpdGggW2F0XSBhbmQgW2ZpcmVkXSwgaXQgaXMgZWFzeSB0byBpbnRyb2R1Y2UgYSByYWNlLiAgRm9yXG4gICAgICAgIGV4YW1wbGUsIGNvbnNpZGVyIHRoZXNlIHR3byBjb2RlIHNuaXBwZXRzOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5hZnRlciAoc2VjIDIuKSBpblxuICAgICAgICAgIHVwb24gKEV2ZW50LmZpcmVkIHQpIChmdW5jdGlvblxuICAgICAgICAgICAgfCBBYm9ydGVkICgpIC0+ICgpXG4gICAgICAgICAgICB8IEhhcHBlbmVkICgpIC0+IHByaW50ZiBcIlRpbWVyIGZpcmVkXCIpO1xuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5ydW5fYWZ0ZXIgKHNlYyAyLikgcHJpbnRmIFwiVGltZXIgZmlyZWRcIiBpblxuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIEluIGJvdGggc25pcHBldHMsIGlmIFtFdmVudC5hYm9ydF0gcmV0dXJucyBbT2tdLCBcIlRpbWVyIGZpcmVkXCIgaXMgbmV2ZXIgcHJpbnRlZC5cbiAgICAgICAgSG93ZXZlciwgdGhlIGZpcnN0IHNuaXBwZXQgbWlnaHQgcHJpbnQgXCJFdmVudCBvY2N1cnJlZCBhZnRlciB0aW1lciBmaXJlZFwiIGFuZCB0aGVuXG4gICAgICAgIFwiVGltZXIgZmlyZWRcIi4gIFRoaXMgY29uZnVzZWQgb3JkZXJpbmcgY2Fubm90IGhhcHBlbiB3aXRoIFtFdmVudC5ydW5fYWZ0ZXJdLiAqKVxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdFxuXG4gICAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gKF8sIHVuaXQpIHRcbiAgZW5kXG5cbiAgKCoqIFthdF92YXJ5aW5nX2ludGVydmFscyBmID9zdG9wXSByZXR1cm5zIGEgc3RyZWFtIHdob3NlIG5leHQgZWxlbWVudCBiZWNvbWVzXG4gICAgICBkZXRlcm1pbmVkIGJ5IGNhbGxpbmcgW2YgKCldIGFuZCB3YWl0aW5nIGZvciB0aGF0IGFtb3VudCBvZiB0aW1lLCBhbmQgdGhlbiBsb29waW5nXG4gICAgICB0byBkZXRlcm1pbmUgc3Vic2VxdWVudCBlbGVtZW50cy4gIFRoZSBzdHJlYW0gd2lsbCBlbmQgYWZ0ZXIgW3N0b3BdIGJlY29tZXNcbiAgICAgIGRldGVybWluZWQuICopXG4gIHZhbCBhdF92YXJ5aW5nX2ludGVydmFsc1xuICAgIDogID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+ICh1bml0IC0+IFRpbWUuU3Bhbi50KVxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcblxuICAoKiogW2F0X2ludGVydmFscyBpbnRlcnZhbCA/c3RhcnQgP3N0b3BdIHJldHVybnMgYSBzdHJlYW0gd2hvc2UgZWxlbWVudHMgd2lsbCBiZWNvbWVcbiAgICAgIGRldGVybWluZWQgYXQgbm9ubmVnYXRpdmUgaW50ZWdlciBtdWx0aXBsZXMgb2YgW2ludGVydmFsXSBhZnRlciB0aGUgW3N0YXJ0XSB0aW1lLFxuICAgICAgdW50aWwgW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZDpcblxuICAgICAge3ZcbiAgICAgICAgc3RhcnQgKyAwICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAxICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAyICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAzICogaW50ZXJ2YWxcbiAgICAgICAgLi4uXG4gICAgICB2fVxuXG4gICAgICBOb3RlIHRoYXQgb25seSBlbGVtZW50cyB0aGF0IGFyZSBzdHJpY3RseSBpbiB0aGUgZnV0dXJlIGV2ZXIgYmVjb21lIGRldGVybWluZWQuXG4gICAgICBJbiBwYXJ0aWN1bGFyLCBpZiBbc3RhcnRdIGlzIG5vdCBpbiB0aGUgZnV0dXJlLCBvciBbc3RhcnRdIGlzIG5vdCBwcm92aWRlZCxcbiAgICAgIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBlbGVtZW50IGJlZm9yZSB0aGUgW2ludGVydmFsXSBoYXMgcGFzc2VkLlxuXG4gICAgICBJZiB0aGUgaW50ZXJ2YWwgaXMgdG9vIHNtYWxsIG9yIHRoZSBDUFUgaXMgdG9vIGxvYWRlZCwgW2F0X2ludGVydmFsc10gd2lsbCBza2lwXG4gICAgICB1bnRpbCB0aGUgbmV4dCB1cGNvbWluZyBtdWx0aXBsZSBvZiBbaW50ZXJ2YWxdIGFmdGVyIFtzdGFydF0uICopXG4gIHZhbCBhdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50XG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG5cbiAgKCoqIFtldmVyeScgP3N0YXJ0ID9zdG9wIHNwYW4gZl0gcnVucyBbZiAoKV0gZXZlcnkgW3NwYW5dIGFtb3VudCBvZiB0aW1lIHN0YXJ0aW5nIHdoZW5cbiAgICAgIFtzdGFydF0gYmVjb21lcyBkZXRlcm1pbmVkIGFuZCBzdG9wcGluZyB3aGVuIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQuICBbZXZlcnknXVxuICAgICAgd2FpdHMgdW50aWwgdGhlIG91dGNvbWUgb2YgW2YgKCldIGJlY29tZXMgZGV0ZXJtaW5lZCBiZWZvcmUgd2FpdGluZyBmb3IgdGhlIG5leHRcbiAgICAgIFtzcGFuXS5cblxuICAgICAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0IGlmIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQsIGV2ZW4gZHVyaW5nIGV2YWx1YXRpb24gb2YgW2ZdLFxuICAgICAgdGhlbiBbZl0gd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGJ5IGEgc3Vic2VxdWVudCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG5cbiAgICAgIEl0IGlzIGFuIGVycm9yIGZvciBbc3Bhbl0gdG8gYmUgbm9ucG9zaXRpdmUuXG5cbiAgICAgIFtjb250aW51ZV9vbl9lcnJvcl0gY29udHJvbHMgd2hhdCBzaG91bGQgaGFwcGVuIGlmIFtmXSByYWlzZXMgYW4gZXhjZXB0aW9uLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlXSwgaXRlcmF0aW9uIG9ubHkgY29udGludWVzIGlmIFtmXSBzdWNjZXNzZnVsbHlcbiAgICAgIHJldHVybnMgYSBkZWZlcnJlZCBhbmQgdGhhdCBkZWZlcnJlZCBpcyBkZXRlcm1pbmVkLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLCBpdGVyYXRpb24gYWxzbyBjb250aW51ZXMgaWYgW2ZdIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICBJZiBbZl0gcmFpc2VzIGFuIGV4Y2VwdGlvbiBhc3luY2hyb25vdXNseSwgdGhpcyBtYXkgY2F1c2UgdXMgdG8gcHJvY2VlZCB3aXRoIHRoZVxuICAgICAgbmV4dCBpdGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIGNhbGwgdG8gW2ZdIGlzIHN0aWxsIHJ1bm5pbmcuXG5cbiAgICAgIEV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBhcmUgYWx3YXlzIHNlbnQgdG8gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW4gW2V2ZXJ5J10gd2FzXG4gICAgICBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLlxuXG4gICAgICBJZiBbZmluaXNoZWRdIGlzIHN1cHBsaWVkLCBbZXZlcnknXSB3aWxsIGZpbGwgaXQgb25jZSBhbGwgb2YgdGhlIGZvbGxvd2luZyBiZWNvbWVcbiAgICAgIGRldGVybWluZWQ6IFtzdGFydF0sIFtzdG9wXSwgYW5kIHRoZSBvdXRjb21lIG9mIHRoZSBmaW5hbCBjYWxsIHRvIFtmXS4gKilcbiAgdmFsIGV2ZXJ5J1xuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+ID9maW5pc2hlZDp1bml0IEl2YXIudFxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2V2ZXJ5ID9zdGFydCA/c3RvcCBzcGFuIGZdIGlzXG4gICAgICBbZXZlcnknID9zdGFydCA/c3RvcCBzcGFuIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKV0uICopXG4gIHZhbCBldmVyeVxuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3Agc3BhbiBmXSBydW5zIFtmKCldIGF0IGluY3JlbWVudHMgb2YgW3N0YXJ0ICsgaSAqXG4gICAgICBzcGFuXSBmb3Igbm9ubmVnYXRpdmUgaW50ZWdlcnMgW2ldLCB1bnRpbCBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkLlxuICAgICAgSWYgdGhlIHJlc3VsdCBvZiBbZl0gaXMgbm90IGRldGVybWluZWQgZmFzdCBlbm91Z2ggdGhlbiB0aGUgbmV4dCBpbnRlcnZhbChzKVxuICAgICAgYXJlIHNraXBwZWQgc28gdGhhdCB0aGVyZSBhcmUgbmV2ZXIgbXVsdGlwbGUgY29uY3VycmVudCBpbnZvY2F0aW9ucyBvZiBbZl0gaW5cbiAgICAgIGZsaWdodC5cblxuICAgICAgRXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGFyZSBhbHdheXMgc2VudCB0byBtb25pdG9yIGluIGVmZmVjdCB3aGVuXG4gICAgICBbcnVuX2F0X2ludGVydmFscyddIHdhcyBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLiAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFscydcbiAgICA6ICA/c3RhcnQ6VGltZS50ICgqKiBkZWZhdWx0IGlzIFtUaW1lLm5vdyAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW3J1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBzcGFuIGZdIGlzIGVxdWl2YWxlbnQgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhblxuICAgICAgICAgIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKSBdfSAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2R1cmF0aW9uX29mIGZdIGludm9rZXMgW2YgKCldIGFuZCBtZWFzdXJlcyBob3cgbG9uZyBpdCB0YWtlcyBmcm9tIHRoZSBpbnZvY2F0aW9uXG4gICAgICB0byBhZnRlciB0aGUgZGVmZXJyZWQgaXMgZGV0ZXJtaW5lZC5cblxuICAgICAgTm90ZSB0aGF0IHRoZSBtZWFzdXJlbWVudCBpcyBub3QgZXhhY3Q7IGJlY2F1c2UgaXQgaW52b2x2ZXMgYW4gYWRkaXRpb25hbCBtYXAgb24gdGhlXG4gICAgICBkZWZlcnJlZCwgdGhlIHRpbWluZyBhbHNvIGluY2x1ZGVzIHRoZSBkdXJhdGlvbiBvZiBqb2JzIGluIHRoZSBqb2IgcXVldWUgd2hlbiBbZiAoKV1cbiAgICAgIGlzIGRldGVybWluZWQuICopXG4gIHZhbCBkdXJhdGlvbl9vZiA6ICh1bml0IC0+ICdhIERlZmVycmVkLnQpIC0+ICgnYSAqIFRpbWUuU3Bhbi50KSBEZWZlcnJlZC50XG5lbmRcblxuKCoqIFtDbG9ja19kZXByZWNhdGVkXSBpcyB1c2VkIGluIFtSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXSB0byBjcmVhdGUgYSBjbG9ja1xuICAgIG1vZHVsZSBpbiB3aGljaCBhbGwgZnVuY3Rpb25zIGFyZSBkZXByZWNhdGVkLiAqKVxubW9kdWxlIHR5cGUgQ2xvY2tfZGVwcmVjYXRlZCA9IHNpZ1xuICBtb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxuICBtb2R1bGUgVGltZSA6IHNpZ1xuICAgIG1vZHVsZSBTcGFuIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICBlbmRcblxuICAgIHR5cGUgdFxuICBlbmRcblxuICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgcnVuX2FmdGVyIDogVGltZS5TcGFuLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhdCA6IFRpbWUudCAtPiB1bml0IERlZmVycmVkLnQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IHVuaXQgRGVmZXJyZWQudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHdpdGhfdGltZW91dCA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gJ2EgT3JfdGltZW91dC50IERlZmVycmVkLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGVcbiAgICAgIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgc2NoZWR1bGVkX2F0IDogKF8sIF8pIHQgLT4gVGltZS50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgdmFsIGFib3J0IDogKCdhLCAnaCkgdCAtPiAnYSAtPiAoJ2EsICdoKSBBYm9ydF9yZXN1bHQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhYm9ydF9leG4gOiAoJ2EsICdoKSB0IC0+ICdhIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBGaXJlZCA9IFRpbWVfc291cmNlLkV2ZW50LkZpcmVkXG5cbiAgICB2YWwgZmlyZWQgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIEZpcmVkLnQgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBSZXNjaGVkdWxlX3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LlJlc2NoZWR1bGVfcmVzdWx0XG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hdCA6ICgnYSwgJ2gpIHQgLT4gVGltZS50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hZnRlciA6ICgnYSwgJ2gpIHQgLT4gVGltZS5TcGFuLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdCBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoXywgdW5pdCkgdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cbiAgZW5kXG5cbiAgdmFsIGF0X3ZhcnlpbmdfaW50ZXJ2YWxzXG4gICAgOiAgP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gKHVuaXQgLT4gVGltZS5TcGFuLnQpXG4gICAgLT4gdW5pdCBBc3luY19zdHJlYW0udFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGF0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnRcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBldmVyeSdcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiA/ZmluaXNoZWQ6dW5pdCBJdmFyLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgZXZlcnlcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBkdXJhdGlvbl9vZiA6ICh1bml0IC0+ICdhIERlZmVycmVkLnQpIC0+ICgnYSAqIFRpbWUuU3Bhbi50KSBEZWZlcnJlZC50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cbmVuZFxuXG4oKiogQGlubGluZSAqKVxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgW0BAQHdhcm5pbmcgXCItM1wiXVxuXG4gIG1vZHVsZSBfIChDIDogQ2xvY2spIDogQ2xvY2tfZGVwcmVjYXRlZCA9IENcblxuICBtb2R1bGUgXyAoQyA6IENsb2NrX2RlcHJlY2F0ZWQpIDogQ2xvY2sgPSBDXG5lbmQgOlxuc2lnIGVuZClcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBDbG9jayA9IENsb2NrX2ludGYuQ2xvY2tcbm1vZHVsZSB0eXBlIENsb2NrX2RlcHJlY2F0ZWQgPSBDbG9ja19pbnRmLkNsb2NrX2RlcHJlY2F0ZWRcblxubW9kdWxlIE9yX3RpbWVvdXQgPSBDbG9ja19pbnRmLk9yX3RpbWVvdXRcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5cbmxldCB0aW1lX3NvdXJjZSAoKSA9IChTY2hlZHVsZXIudCAoKSkudGltZV9zb3VyY2UgfD4gVGltZV9zb3VyY2Uub2Zfc3luY2hyb25vdXNcbmxldCBhZnRlciBzcGFuID0gVGltZV9zb3VyY2UuYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuXG5sZXQgYXQgdGltZSA9IFRpbWVfc291cmNlLmF0ICh0aW1lX3NvdXJjZSAoKSkgdGltZVxuXG5sZXQgYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgY29tcHV0ZV9zcGFuID1cbiAgVGltZV9zb3VyY2UuYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgKHRpbWVfc291cmNlICgpKSBjb21wdXRlX3NwYW5cbjs7XG5cbmxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wIGludGVydmFsID1cbiAgVGltZV9zb3VyY2UuYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCAodGltZV9zb3VyY2UgKCkpIGludGVydmFsXG47O1xuXG5sZXQgZXZlcnknID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgP2ZpbmlzaGVkIHNwYW4gZiA9XG4gIFRpbWVfc291cmNlLmV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmID1cbiAgVGltZV9zb3VyY2UuZXZlcnkgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IHJ1bl9hZnRlciBzcGFuIGYgYSA9IFRpbWVfc291cmNlLnJ1bl9hZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZiBhXG5sZXQgcnVuX2F0IHRpbWUgZiBhID0gVGltZV9zb3VyY2UucnVuX2F0ICh0aW1lX3NvdXJjZSAoKSkgdGltZSBmIGFcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBpbnRlcnZhbCBmID1cbiAgVGltZV9zb3VyY2UucnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yICh0aW1lX3NvdXJjZSAoKSkgaW50ZXJ2YWwgZlxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgaW50ZXJ2YWwgZiA9XG4gIFRpbWVfc291cmNlLnJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgP3N0YXJ0XG4gICAgP3N0b3BcbiAgICA/Y29udGludWVfb25fZXJyb3JcbiAgICAodGltZV9zb3VyY2UgKCkpXG4gICAgaW50ZXJ2YWxcbiAgICBmXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0IHNwYW4gZCA9IFRpbWVfc291cmNlLndpdGhfdGltZW91dCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZFxubGV0IGR1cmF0aW9uX29mIGYgPSBUaW1lX3NvdXJjZS5kdXJhdGlvbl9vZiAodGltZV9zb3VyY2UgKCkpIGZcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgVGltZV9zb3VyY2UuRXZlbnRcblxuICBsZXQgYWZ0ZXIgc3BhbiA9IGFmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhblxuICBsZXQgcnVuX2FmdGVyIHNwYW4gZiBhID0gcnVuX2FmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhbiBmIGFcbiAgbGV0IGF0IHRpbWUgPSBhdCAodGltZV9zb3VyY2UgKCkpIHRpbWVcbiAgbGV0IHJ1bl9hdCB0aW1lIGYgeiA9IHJ1bl9hdCAodGltZV9zb3VyY2UgKCkpIHRpbWUgZiB6XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCBpIGIgPVxuICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0XG4gICAgICB0aGVuIEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgZWxzZSBmIGkgYiB0LihpKSA+Pj4gZnVuIGIgLT4gbG9vcCAoaSArIDEpIGJcbiAgICBpblxuICAgIGxvb3AgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPSBmb2xkaSB0IH5pbml0OltdIH5mOihmdW4gaSBicyBhIC0+IGYgaSBhID4+fCBmdW4gYiAtPiBiIDo6IGJzKSBpblxuICBBcnJheS5vZl9saXN0IChDb3JlLkxpc3QucmV2IGJzKVxuOztcblxubGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbmxldCBhbGxfdW5pdCBkcyA9IERlZmVycmVkLmlnbm9yZV9tIChmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKSlcblxubGV0IGl0ZXJpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuOztcblxubGV0IG1hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgIGFsbCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBzZXFtYXBpIHQgfmZcbjs7XG5cbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYm9vbHMgPSBtYXBpIHQgP2hvdyB+ZiBpblxuICBBcnJheS5vZl9saXN0X3JldlxuICAgIChBcnJheS5mb2xkMl9leG4gdCBib29scyB+aW5pdDpbXSB+ZjooZnVuIGFjIHggYiAtPiBpZiBiIHRoZW4geCA6OiBhYyBlbHNlIGFjKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSA/aG93IHQgfmYgPSBtYXBpIHQgP2hvdyB+ZiA+PnwgQXJyYXkuZmlsdGVyX29wdFxuXG5sZXQgY29uY2F0X21hcGkgP2hvdyB0IH5mID1cbiAgbGV0JW1hcCB0ID0gbWFwaSB0ID9ob3cgfmYgaW5cbiAgQXJyYXkuY29uY2F0IChBcnJheS50b19saXN0IHQpXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRcbiAgICB0aGVuIHJldHVybiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCViaW5kIGYgaSB0LihpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYXV4IChpICsgMSlcbiAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGF1eCAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXIgP2hvdyB0IH5mID0gZmlsdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID0gY29uY2F0X21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0ID9ob3cgbiB+ZiA9IG1hcCA/aG93IChBcnJheS5pbml0IG4gfmY6Rm4uaWQpIH5mXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBpIGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgfCB4IDo6IHhzIC0+IGYgaSBiIHggPj4+IGZ1biBiIC0+IGxvb3AgeHMgKGkgKyAxKSBiXG4gICAgaW5cbiAgICBsb29wIHQgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6W10gfmY6KGZ1biBpIGJzIGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgYSBpblxuICAgIGIgOjogYnMpXG4gID4+fCBMaXN0LnJldlxuOztcblxubGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbmxldCBhbGxfdW5pdCBkcyA9IERlZmVycmVkLmlnbm9yZV9tIChmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKSlcblxubGV0IGl0ZXJpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG47O1xuXG5sZXQgbWFwaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsIChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG47O1xuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBsZXQlbWFwIGJvb2xzID0gbWFwaSB0ID9ob3cgfmYgaW5cbiAgTGlzdC5yZXYgKExpc3QuZm9sZDJfZXhuIHQgYm9vbHMgfmluaXQ6W10gfmY6KGZ1biBhYyB4IGIgLT4gaWYgYiB0aGVuIHggOjogYWMgZWxzZSBhYykpXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgP2hvdyB0IH5mID0gbWFwaSB0ID9ob3cgfmYgPj58IExpc3QuZmlsdGVyX29wdFxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV0dXJuIE5vbmVcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgdGwgfmYgKGkgKyAxKVxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGZpbmRfbWFwaSB0IH5mIDBcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBfIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG47O1xuXG5sZXQgaXRlciA/aG93IHQgfmYgPSBpdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgP2hvdyBuIH5mID0gbWFwID9ob3cgKExpc3QuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgTGlzdCA9IERlZmVycmVkX2xpc3RcblxudHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNYXAudFxuXG5sZXQgY2hhbmdlIHQgayB+ZiA9XG4gIGxldCVtYXAgb3B0ID0gZiAoTWFwLmZpbmQgdCBrKSBpblxuICBNYXAuY2hhbmdlIHQgayB+ZjooZnVuIF8gLT4gb3B0KVxuOztcblxubGV0IHVwZGF0ZSB0IGsgfmYgPVxuICBsZXQlbWFwIGRhdGEgPSBmIChNYXAuZmluZCB0IGspIGluXG4gIE1hcC5zZXQgdCB+a2V5OmsgfmRhdGFcbjs7XG5cbmxldCBpdGVyX2tleXMgP2hvdyB0IH5mID0gTGlzdC5pdGVyID9ob3cgKE1hcC5rZXlzIHQpIH5mXG5sZXQgaXRlciA/aG93IHQgfmYgPSBMaXN0Lml0ZXIgP2hvdyAoTWFwLmRhdGEgdCkgfmZcbmxldCBpdGVyaSA/aG93IHQgfmYgPSBMaXN0Lml0ZXIgP2hvdyAoTWFwLnRvX2FsaXN0IHQpIH5mOihmdW4gKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhKVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyID1cbiAgICBNYXAuZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBhbGlzdClcbiAgaW5cbiAgTGlzdC5mb2xkIGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyIH5pbml0IH5mOihmdW4gYWMgKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhIGFjKVxuOztcblxubGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9XG4gIGxldCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciA9XG4gICAgTWFwLmZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWxpc3QgLT4gKGtleSwgZGF0YSkgOjogYWxpc3QpXG4gIGluXG4gIExpc3QuZm9sZCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciB+aW5pdCB+ZjooZnVuIGFjIChrZXksIGRhdGEpIC0+IGYgfmtleSB+ZGF0YSBhYylcbjs7XG5cbm1vZHVsZSBKb2IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgeyBrZXkgOiAnYVxuICAgIDsgZGF0YSA6ICdiXG4gICAgOyBtdXRhYmxlIHJlc3VsdCA6ICdjIG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzXVxuZW5kXG5cbmxldCBmaWx0ZXJfbWFwaV9zZXF1ZW50aWFsIHQgfmYgPVxuICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIHQgaW5cbiAgbGV0IHNlcXVlbmNlID0gTWFwLnRvX3NlcXVlbmNlIH5vcmRlcjpgSW5jcmVhc2luZ19rZXkgdCBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgU2VxdWVuY2UuZGVsYXllZF9mb2xkXG4gICAgICBzZXF1ZW5jZVxuICAgICAgfmluaXQ6QmFzZS5NYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcbiAgICAgIH5mOihmdW4gcyAoa2V5LCBkYXRhKSB+ayAtPlxuICAgICAgICB1cG9uIChmIH5rZXkgfmRhdGEpIChmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBrIHNcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IHMgPVxuICAgICAgICAgICAgICBCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy5hZGRfZXhuXG4gICAgICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgayBzKSlcbiAgICAgIH5maW5pc2g6KGZ1biB4IC0+XG4gICAgICAgIEl2YXIuZmlsbFxuICAgICAgICAgIGl2YXJcbiAgICAgICAgICAoTWFwLlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZVxuICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgKEJhc2UuTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5CdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWUgeCkpKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgU2VxdWVudGlhbCAtPiBmaWx0ZXJfbWFwaV9zZXF1ZW50aWFsIHQgfmZcbiAgfCBgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfIC0+XG4gICAgbGV0IGpvYnMgPSByZWYgW10gaW5cbiAgICBsZXQgam9iX21hcCA9XG4gICAgICBNYXAubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBsZXQgam9iID0geyBKb2Iua2V5OyBkYXRhOyByZXN1bHQgPSBOb25lIH0gaW5cbiAgICAgICAgam9icyA6PSBqb2IgOjogIWpvYnM7XG4gICAgICAgIGpvYilcbiAgICBpblxuICAgIGxldCVtYXAgKCkgPVxuICAgICAgTGlzdC5pdGVyIH5ob3cgKEJhc2UuTGlzdC5yZXYgIWpvYnMpIH5mOihmdW5jdGlvblxuICAgICAgICB8IHsgSm9iLmtleTsgZGF0YTsgcmVzdWx0ID0gXyB9IGFzIGpvYiAtPlxuICAgICAgICAgIGxldCVtYXAgeCA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICAgIGpvYi5yZXN1bHQgPC0geClcbiAgICBpblxuICAgIE1hcC5maWx0ZXJfbWFwIGpvYl9tYXAgfmY6Sm9iLnJlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGZpbHRlcl9rZXlzID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGtleSBpblxuICAgIGlmIGIgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlciA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGRhdGEgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBtYXBpID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIHogPSBmIH5rZXkgfmRhdGEgaW5cbiAgICBTb21lIHopXG47O1xuXG5sZXQgbWFwID9ob3cgdCB+ZiA9IG1hcGkgP2hvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IG1lcmdlID9ob3cgdDEgdDIgfmYgPVxuICBmaWx0ZXJfbWFwXG4gICAgP2hvd1xuICAgIChNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5IHogLT4gU29tZSAoZnVuICgpIC0+IGYgfmtleSB6KSkpXG4gICAgfmY6KGZ1biB0aHVuayAtPiB0aHVuayAoKSlcbjs7XG5cbmxldCBhbGwgdCA9IG1hcCB0IH5mOkZuLmlkXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IHJlcmFpc2UgPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiBFeG4ucmVyYWlzZSBleG4gXCJjYXVnaHQgZXhjZXB0aW9uIGluIG1lbW9pemVkIGZ1bmN0aW9uXCJcbjs7XG5cbmxldCBnZW5lcmFsICh0eXBlIGEpIChoYXNoYWJsZSA6IChtb2R1bGUgSGFzaGFibGUuU19wbGFpbiB3aXRoIHR5cGUgdCA9IGEpKSBmID1cbiAgbGV0IG1vZHVsZSBIYXNoYWJsZSA9ICh2YWwgaGFzaGFibGUpIGluXG4gIGxldCBmID1cbiAgICBNZW1vLmdlbmVyYWwgfmhhc2hhYmxlOkhhc2hhYmxlLmhhc2hhYmxlIChmdW4gYSAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIH5ydW46YE5vd1xuICAgICAgICAoZnVuICgpIC0+IGYgYSkpXG4gIGluXG4gIFN0YWdlZC5zdGFnZSAoZnVuIGEgLT4gZiBhID4+fCByZXJhaXNlKVxuOztcblxubGV0IHVuaXQgZiA9XG4gIGxldCBmID1cbiAgICBNZW1vLnVuaXQgKGZ1biAoKSAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIH5ydW46YE5vd1xuICAgICAgICBmKVxuICBpblxuICBTdGFnZWQuc3RhZ2UgKGZ1biAoKSAtPiBmICgpID4+fCByZXJhaXNlKVxuOztcbiIsIm9wZW4gQ29yZVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE9wdGlvbi50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCByZXR1cm4gYSA9IERlZmVycmVkLnJldHVybiAoU29tZSBhKVxuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgU29tZSBhIC0+IGYgYVxuICAgICAgICB8IE5vbmUgLT4gRGVmZXJyZWQucmV0dXJuIE5vbmUpXG4gICAgOztcblxuICAgIGxldCBtYXAgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBPcHRpb24ubWFwIHIgfmYpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2Vycm9yKSB0ID0gKCdhLCAnZXJyb3IpIFJlc3VsdC50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBsZXQlbWFwIHQxID0gdDFcbiAgYW5kIHQyID0gdDIgaW5cbiAgUmVzdWx0LmNvbWJpbmUgdDEgdDIgfm9rIH5lcnJcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHJldHVybiBhID0gRGVmZXJyZWQucmV0dXJuIChPayBhKVxuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgT2sgYSAtPiBmIGFcbiAgICAgICAgfCBFcnJvciBfIGFzIGVycm9yIC0+IERlZmVycmVkLnJldHVybiBlcnJvcilcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXAgciB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgZmFpbCB4ID0gRGVmZXJyZWQucmV0dXJuIChFcnJvciB4KVxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxubGV0IG1hcF9lcnJvciB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXBfZXJyb3IgciB+ZilcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBNb25pdG9yID0gc3RydWN0XG4gIGxldCB0cnlfd2l0aCA9IE1vbml0b3IudHJ5X3dpdGhcbmVuZFxuXG4oKiBDb3BpZWQgdG8gW2VhZ2VyX2RlZmVycmVkX29yX2Vycm9yLm1sXS4gIFRoZXJlIHNob3VsZCBiZSBubyBkaWZmcyBiZWxvdyB0aGlzIGxpbmUuICopXG5cbmluY2x1ZGUgKERlZmVycmVkX3Jlc3VsdCA6IE1vbmFkLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIERlZmVycmVkX3Jlc3VsdC50KVxuXG50eXBlICdhIHQgPSAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgbGV0IGFwcGx5IGYgeCA9XG4gICAgICBEZWZlcnJlZF9yZXN1bHQuY29tYmluZVxuICAgICAgICBmXG4gICAgICAgIHhcbiAgICAgICAgfm9rOihmdW4gZiB4IC0+IGYgeClcbiAgICAgICAgfmVycjooZnVuIGUxIGUyIC0+IEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAoKiBmcm9tIEFwcGxpY2F0aXZlLk1ha2UgKilcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gIGVuZFxuZW5kXG5cbm9wZW4gTGV0X3N5bnRheFxuXG5sZXQgZmFpbCBlcnJvciA9IERlZmVycmVkLnJldHVybiAoUmVzdWx0LmZhaWwgZXJyb3IpXG5sZXQgb2tfZXhuIHQgPSBEZWZlcnJlZC5tYXAgdCB+ZjpPcl9lcnJvci5va19leG5cbmxldCBvZl9leG4gZXhuID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5vZl9leG4gZXhuKVxubGV0IG9mX2V4bl9yZXN1bHQgdCA9IERlZmVycmVkLm1hcCB0IH5mOk9yX2Vycm9yLm9mX2V4bl9yZXN1bHRcbmxldCBlcnJvciBtc2cgdiBzZXhwX29mID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvciBtc2cgdiBzZXhwX29mKVxubGV0IGVycm9yX3Mgc2V4cCA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3JfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtc2cgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBtc2cpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IGtzcHJpbnRmIGVycm9yX3N0cmluZyBmb3JtYXRcbmxldCB0YWcgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZ19zX2xhenkgfnRhZylcblxubGV0IHRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRGVmZXJyZWQubWFwIHQgfmY6KGZ1biB0IC0+IE9yX2Vycm9yLnRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgbXNnID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci51bmltcGxlbWVudGVkIG1zZylcbmxldCBjb21iaW5lX2Vycm9ycyBsID0gRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuY29tYmluZV9lcnJvcnNcbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5maWx0ZXJfb2tfYXRfbGVhc3Rfb25lXG47O1xuXG5sZXQgZmluZF9tYXBfb2sgbCB+ZiA9XG4gIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAobCwgW10pIChmdW4gKGwsIGVycm9ycykgLT5cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBsZXQgZXJyb3JzID0gRXJyb3Iub2ZfbGlzdCAoTGlzdC5yZXYgZXJyb3JzKSBpblxuICAgICAgRGVmZXJyZWQucmV0dXJuIChgRmluaXNoZWQgKEVycm9yIGVycm9ycykpXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgRGVmZXJyZWQubWFwIChmIGhkKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBFcnJvciBjdXJyZW50X2Vycm9yIC0+IGBSZXBlYXQgKHRsLCBjdXJyZW50X2Vycm9yIDo6IGVycm9ycylcbiAgICAgICAgfCBPayByZXN1bHQgLT4gYEZpbmlzaGVkIChPayByZXN1bHQpKSlcbjs7XG5cbmxldCBva191bml0ID0gcmV0dXJuICgpXG5cbmxldCB0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmID1cbiAgRGVmZXJyZWQubWFwIChNb25pdG9yLnRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOihmdW5jdGlvblxuICAgIHwgRXJyb3IgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuKVxuICAgIHwgT2sgXyBhcyBvayAtPiBvaylcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYgPVxuICBEZWZlcnJlZC5tYXAgKHRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOk9yX2Vycm9yLmpvaW5cbjs7XG5cbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGxldCBmb2xkaSBsaXN0IH5pbml0OmFjYyB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIGFjY1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQlYmluZCBhY2MgPSBmIGkgYWNjIGhkIGluXG4gICAgICAgIGxvb3AgKGkgKyAxKSBhY2MgdGxcbiAgICBpblxuICAgIGxvb3AgMCBhY2MgbGlzdFxuICA7O1xuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbiAgbGV0IHNlcW1hcGkgdCB+ZiA9XG4gICAgZm9sZGkgdCB+aW5pdDpbXSB+ZjooZnVuIGkgYnMgYSAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICAgIGIgOjogYnMpXG4gICAgPj58IExpc3QucmV2XG4gIDs7XG5cbiAgbGV0IGFsbCA9IGFsbFxuICBsZXQgYWxsX3VuaXQgPSBhbGxfdW5pdFxuXG4gIGxldCBpdGVyaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgYWxsX3VuaXQgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG4gIDs7XG5cbiAgbGV0IG1hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICAgIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbiAgbGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG4gIGxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgeCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHJldHVybiBOb25lXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCViaW5kIGYgaSBoZCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHRsIH5mIChpICsgMSlcbiAgICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gICAgaW5cbiAgICBmaW5kX21hcGkgdCB+ZiAwXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5cbiAgbGV0IGZpbmRpIHQgfmYgPVxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID1cbiAgICBmaW5kX21hcCB0IH5mOihmdW4gZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiB0cnVlXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiBmYWxzZVxuICAgIHwgTm9uZSAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaWx0ZXIgP2hvdyB0IH5mID0gZmlsdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgaW5pdCA/aG93IG4gfmYgPSBtYXAgP2hvdyAoTGlzdC5pbml0IG4gfmY6Rm4uaWQpIH5mXG5lbmRcblxubGV0IHJlYyByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZiA9XG4gIG1hdGNoJWJpbmQgZiBzdGF0ZSB3aXRoXG4gIHwgYFJlcGVhdCBzdGF0ZSAtPiByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZlxuICB8IGBGaW5pc2hlZCBzdGF0ZSAtPiByZXR1cm4gc3RhdGVcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgTGlzdCA9IERlZmVycmVkX2xpc3RcblxuKCogV2UgaW1wbGVtZW50IGFsbCBvZiB0aGUgW1F1ZXVlXSBvcGVyYXRpb25zIGJ5IGNvbnZlcnRpbmcgdGhlIHF1ZXVlIHRvIGEgbGlzdCBhbmQgdGhlblxuICAgdXNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgW0xpc3RdIG9wZXJhdGlvbi4gIFdlIHVzZSBsaXN0cyByYXRoZXIgdGhhbiBhcnJheXMgYmVjYXVzZVxuICAgYXJyYXlzIGxvbmdlciB0aGFuIGEgY2VydGFpbiBsZW5ndGggYXJlIGFsbG9jYXRlZCBpbiB0aGUgbWFqb3IgaGVhcCwgd2hpY2ggY2FuIGNhdXNlXG4gICB1bm5lY2Vzc2FyeSBwcm9tb3Rpb24gb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gIEFsc28sIHdoZW4gb25lIGlzIGZvbGRpbmcgb3JcbiAgIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LCB0aGUgZW50aXJlIGFycmF5IG11c3QgYmUga2VwdCBhbGl2ZS4gIFdoZW4gZm9sZGluZyBvclxuICAgaXRlcmF0aW5nIG92ZXIgYSBsaXN0LCBvbmx5IHRoZSByZW1haW5pbmcgdGFpbCBvZiB0aGUgbGlzdCBpcyBrZXB0IGFsaXZlLiAgU28sIHVzaW5nXG4gICBhcnJheXMgcmF0aGVyIHRoYW4gbGlzdHMgd291bGQgaW5jcmVhc2UgdGhlIGxpdmUtc3BhY2UgbmVlZGVkIGJ5IHRoZSBwcm9ncmFtLiAqKVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9IExpc3QuZm9sZGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmluaXQgfmZcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBMaXN0LmZvbGQgKFF1ZXVlLnRvX2xpc3QgdCkgfmluaXQgfmZcbmxldCBhbGwgdCA9IExpc3QuYWxsIChRdWV1ZS50b19saXN0IHQpID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgYWxsX3VuaXQgdCA9IExpc3QuYWxsX3VuaXQgKFF1ZXVlLnRvX2xpc3QgdClcbmxldCBpdGVyID9ob3cgdCB+ZiA9IExpc3QuaXRlciA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgaXRlcmkgP2hvdyB0IH5mID0gTGlzdC5pdGVyaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgbWFwID9ob3cgdCB+ZiA9IExpc3QubWFwID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBtYXBpID9ob3cgdCB+ZiA9IExpc3QubWFwaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgaW5pdCA/aG93IG4gfmYgPSBMaXN0LmluaXQgP2hvdyBuIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBMaXN0LmZpbHRlcl9tYXAgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyX21hcGkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxuXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPVxuICBMaXN0LmNvbmNhdF9tYXAgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZjooZnVuIHggLT4gZiB4ID4+fCBRdWV1ZS50b19saXN0KVxuICA+PnwgUXVldWUub2ZfbGlzdFxuOztcblxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9XG4gIExpc3QuY29uY2F0X21hcGkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZjooZnVuIGkgeCAtPiBmIGkgeCA+PnwgUXVldWUudG9fbGlzdClcbiAgPj58IFF1ZXVlLm9mX2xpc3Rcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID0gTGlzdC5maW5kX21hcCAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZpbmRfbWFwaSB0IH5mID0gTGlzdC5maW5kX21hcGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kIHQgfmYgPSBMaXN0LmZpbmQgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kaSB0IH5mID0gTGlzdC5maW5kaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZvcl9hbGwgdCB+ZiA9IExpc3QuZm9yX2FsbCAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBMaXN0LmZvcl9hbGxpIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZXhpc3RzIHQgfmYgPSBMaXN0LmV4aXN0cyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IExpc3QuZXhpc3RzaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbigqIFtmb2xkX21hcGkgP2hvdyB0IH5pbml0IH5tYXBpX2YgfmZvbGRfZl0gaXMgYSBtb3JlIGVmZmljaWVudCB2ZXJzaW9uIG9mOlxuXG4gICB7W1xuICAgICBmb2xkIH5pbml0IH5mOihmdW4gYiBhIC0+IHJldHVybiAoZm9sZF9mIGIgYSkpIChtYXBpIHQgP2hvdyB+ZjptYXBpX2YpIF19XG5cbiAgIEl0IGF2b2lkcyBjcmVhdGluZyB0aGUgaW50ZXJtZWRpYXRlIHNlcXVlbmNlIHRoYXQgd291bGQgcmVzdWx0IGZyb20gW21hcGldLCBhbmRcbiAgIGFsbG93cyB0aGUgW2ZvbGRdIHRvIHByb2NlZWQgY29uY3VycmVudGx5IHdpdGggdGhlIFttYXBpXSwgc28gdGhhdCBvbmUgY2FuIGFjY3VtdWxhdGVcbiAgIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSwgcG9zc2libHkgYXZvaWRpbmcgY3JlYXRpbmcgYW4gaW50ZXJtZWRpYXRlIHN0cnVjdHVyZVxuICAgKGUuZy4gW2l0ZXJpXSBhbmQgW2ZpbHRlcl9tYXBdIHVzZXMgW2ZvbGRfbWFwaV0gdG8gZG8gdGhpcykuICopXG5sZXQgZm9sZF9tYXBpXG4gICAgICAodHlwZSBhIGIgYylcbiAgICAgID8oaG93ID0gYFNlcXVlbnRpYWwpXG4gICAgICAodCA6IGEgU2VxdWVuY2UudClcbiAgICAgIH4oaW5pdCA6IGMpXG4gICAgICB+KG1hcGlfZiA6IGludCAtPiBhIC0+IGIgRGVmZXJyZWQudClcbiAgICAgIH4oZm9sZF9mIDogYyAtPiBiIC0+IGMpXG4gIDogYyBEZWZlcnJlZC50XG4gID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgU2VxdWVudGlhbCAtPlxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjKSA9XG4gICAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IHJldHVybiBjXG4gICAgICB8IFNvbWUgKGEsIHQpIC0+XG4gICAgICAgIGxldCViaW5kIGIgPSBtYXBpX2YgaSBhIGluXG4gICAgICAgIGxvb3AgKGkgKyAxKSB0IChmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHQgaW5pdFxuICB8IGBQYXJhbGxlbCAtPlxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjIERlZmVycmVkLnQpID1cbiAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY1xuICAgICAgfCBTb21lIChhLCB0KSAtPlxuICAgICAgICBsb29wXG4gICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgIHRcbiAgICAgICAgICAobGV0JWJpbmQgYiA9IG1hcGlfZiBpIGEgaW5cbiAgICAgICAgICAgbGV0JW1hcCBjID0gYyBpblxuICAgICAgICAgICBmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHQgKHJldHVybiBpbml0KVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT5cbiAgICBsZXQgdGhyb3R0bGUgPSBUaHJvdHRsZS5jcmVhdGUgfm1heF9jb25jdXJyZW50X2pvYnMgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIGluXG4gICAgKCogW2xvb3BdIGZvcmNlcyB0aGUgaW5wdXQgc2VxdWVuY2UgYW5kIGVucXVldWVzIGEgdGhyb3R0bGUgam9iIG9ubHkgaWYgdGhlcmUgaXNcbiAgICAgICBjYXBhY2l0eSBhdmFpbGFibGUuICopXG4gICAgbGV0IHJlYyBsb29wIGkgdCAoYyA6IGMgRGVmZXJyZWQudCkgPVxuICAgICAgbGV0JWJpbmQgKCkgPSBUaHJvdHRsZS5jYXBhY2l0eV9hdmFpbGFibGUgdGhyb3R0bGUgaW5cbiAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY1xuICAgICAgfCBTb21lIChhLCB0KSAtPlxuICAgICAgICBsb29wXG4gICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgIHRcbiAgICAgICAgICAobGV0JWJpbmQgYiA9IFRocm90dGxlLmVucXVldWUgdGhyb3R0bGUgKGZ1biAoKSAtPiBtYXBpX2YgaSBhKSBpblxuICAgICAgICAgICBsZXQlbWFwIGMgPSBjIGluXG4gICAgICAgICAgIGZvbGRfZiBjIGIpXG4gICAgaW5cbiAgICBsb29wIDAgdCAocmV0dXJuIGluaXQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIFNlcXVlbmNlLmRlbGF5ZWRfZm9sZFxuICAgIHRcbiAgICB+aW5pdDooMCwgaW5pdClcbiAgICB+ZjooZnVuIChpLCBiKSBhIH5rIC0+XG4gICAgICBsZXQlYmluZCBiID0gZiBpIGIgYSBpblxuICAgICAgayAoaSArIDEsIGIpKVxuICAgIH5maW5pc2g6KGZ1biAoXywgYikgLT4gcmV0dXJuIGIpXG47O1xuXG4oKiBbZm9sZF0gaXMgbm90IGltcGxlbWVudGVkIGluIHRlcm1zIG9mIFtmb2xkaV0gdG8gc2F2ZSB0aGUgaW50ZXJtZWRpYXRlIGNsb3N1cmVcbiAgIGFsbG9jYXRpb24uICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgU2VxdWVuY2UuZGVsYXllZF9mb2xkIHQgfmluaXQgfmY6KGZ1biBiIGEgfmsgLT4gZiBiIGEgPj49IGspIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgYWxsIHQgPVxuICBsZXQlbWFwIHJlcyA9XG4gICAgZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWNjdW0gZCAtPlxuICAgICAgbGV0JW1hcCBhID0gZCBpblxuICAgICAgYSA6OiBhY2N1bSlcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgcmVzKVxuOztcblxubGV0IGFsbF91bml0IHQgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSB2IC0+IHYpXG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgZmluZF9tYXBpIHQgfmYgaSA9XG4gICAgbWF0Y2ggU2VxdWVuY2UubmV4dCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmV0dXJuIE5vbmVcbiAgICB8IFNvbWUgKHYsIHJlc3QpIC0+XG4gICAgICAobWF0Y2glYmluZCBmIGkgdiB3aXRoXG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwaSByZXN0IH5mIChpICsgMSlcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICBpblxuICBmaW5kX21hcGkgdCB+ZiAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXJpID9ob3cgdCB+ZiA6IHVuaXQgRGVmZXJyZWQudCA9XG4gIGZvbGRfbWFwaSA/aG93IHQgfm1hcGlfZjpmIH5pbml0OigpIH5mb2xkX2Y6KGZ1biAoKSAoKSAtPiAoKSlcbjs7XG5cbmxldCBtYXBpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPVxuICAgIGZvbGRfbWFwaSA/aG93IHQgfm1hcGlfZjooZnVuIGkgYSAtPiBmIGkgYSkgfmluaXQ6W10gfmZvbGRfZjooZnVuIGJzIGIgLT4gYiA6OiBicylcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgYnMpXG47O1xuXG4oKiBbZmlsdGVyX21hcGldIGlzIGltcGxlbWVudGVkIHVzaW5nIFtmb2xkX21hcGldIHJhdGhlciB0aGFuIFttYXBdIHNvIHRoYXQgd2UgbmV2ZXIgbmVlZFxuICAgdG8ga2VlcCBhIGxvbmcgc3RyZWFtIG9mIGludGVybWVkaWF0ZSBbTm9uZV0gcmVzdWx0cyBpbiB0aGUgYWNjdW11bGF0b3IsIG9ubHkgdG8gbGF0ZXJcbiAgIGZpbHRlciB0aGVtIGFsbCBvdXQuICopXG5sZXQgZmlsdGVyX21hcGkgP2hvdyB0IH5mID1cbiAgbGV0JW1hcCBicyA9XG4gICAgZm9sZF9tYXBpXG4gICAgICB0XG4gICAgICA/aG93XG4gICAgICB+bWFwaV9mOihmdW4gaSBhIC0+IGYgaSBhKVxuICAgICAgfmluaXQ6W11cbiAgICAgIH5mb2xkX2Y6KGZ1biBicyBtYXliZV92IC0+XG4gICAgICAgIG1hdGNoIG1heWJlX3Ygd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYnNcbiAgICAgICAgfCBTb21lIGIgLT4gYiA6OiBicylcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgYnMpXG47O1xuXG5sZXQgY29uY2F0X21hcGkgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmYgPj58IFNlcXVlbmNlLmNvbmNhdFxuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCVtYXAgZiBpIGEgd2l0aFxuICAgIHwgdHJ1ZSAtPiBTb21lIGFcbiAgICB8IGZhbHNlIC0+IE5vbmUpXG47O1xuXG5sZXQgaXRlciA/aG93IHQgfmYgPSBpdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgP2hvdyBuIH5mID0gbWFwID9ob3cgKFNlcXVlbmNlLmluaXQgbiB+ZjpGbi5pZCkgfmZcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIENsb2NrX25zID0gQ2xvY2tfbnNcbm1vZHVsZSBUaW1lX25zID0gVGltZV9uc1xubW9kdWxlIFRpbWUgPSBUaW1lXG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9zY2hlZHVsZXJcbm1vZHVsZSBEYXRlID0gRGF0ZVxuXG5sZXQgYWZ0ZXIgPSBDbG9ja19ucy5hZnRlclxubGV0IGF0ID0gQ2xvY2tfbnMuYXRcbmxldCBldmVyeSA9IENsb2NrX25zLmV2ZXJ5XG5sZXQgd2l0aF90aW1lb3V0ID0gQ2xvY2tfbnMud2l0aF90aW1lb3V0XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxuXG5sZXQgc2hvd19kZWJ1Z19tZXNzYWdlcyA9IHJlZiBmYWxzZVxubGV0IGNoZWNrX2ludmFyaWFudCA9IHJlZiBmYWxzZVxuXG5tb2R1bGUgRmx1c2hlZF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBPa1xuICAgIHwgYFJlYWRlcl9jbG9zZWRcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuXG4gIGxldCBjb21iaW5lIChsIDogdCBEZWZlcnJlZC50IGxpc3QpID1cbiAgICBsZXQlbWFwIGwgPSBEZWZlcnJlZC5hbGwgbCBpblxuICAgIG1hdGNoIExpc3QubWVtIGwgYFJlYWRlcl9jbG9zZWQgfmVxdWFsIHdpdGhcbiAgICB8IHRydWUgLT4gYFJlYWRlcl9jbG9zZWRcbiAgICB8IGZhbHNlIC0+IGBPa1xuICA7O1xuZW5kXG5cbigqIEEgW0NvbnN1bWVyLnRdIGFjdHMgYXMgdGhlIG1vbml0b3Igb2Ygc29tZSBwcm9jZXNzIHRoYXQgcmVhZHMgdmFsdWVzIGZyb20gYSBwaXBlIGFuZFxuICAgcHJvY2Vzc2VzIHRoZW0sIGFsbG93aW5nIHRoYXQgcHJvY2VzczpcbiAgIC0gdG8gY29tbXVuaWNhdGUgdGhhdCBpdCBoYXMgdGFrZW4gcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB2YWx1ZXNcbiAgIC0gdG8gc2lnbmFsIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHdpdGggdGhlIHZhbHVlcyB0byBpbnRlcmVzdGVkIHBhcnRpZXMgKHZpYVxuICAgICBbZG93bnN0cmVhbV9mbHVzaGVkXSlcblxuICAgSXQgaXMgdXNlZCBpbiB0d28gc3RlcHM6XG5cbiAgIDEuIGNhbGxpbmcgW0NvbnN1bWVyLnN0YXJ0XSBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGNvbnN1bWVyIHRha2VzIHZhbHVlcyBvdXQgb2YgdGhlXG4gICBQaXBlIHZpYSBbcmVhZF0gb3IgW3JlYWQnXS5cblxuICAgMi4gY2FsbGluZyBbQ29uc3VtZXIudmFsdWVzX3NlbnRfZG93bnN0cmVhbV0uXG5cbiAgIEJ5IGNhbGxpbmcgW3ZhbHVlc19zZW50X2Rvd25zdHJlYW1dIG9uZSBhc3NlcnRzIHRoYXQgdGhlIFtkb3duc3RyZWFtX2ZsdXNoZWRdIGZ1bmN0aW9uXG4gICBzdXBwbGllZCB0byBbY3JlYXRlXSB3aWxsIG5vdyB3YWl0IGZvciB0aGlzIHZhbHVlLlxuXG4gICBJZiBubyBbQ29uc3VtZXIudF0gaXMgc3VwcGxpZWQgd2hlbiBhIHZhbHVlIGlzIHJlYWQgdGhlbiB0aGUgdmFsdWUgaXMgZGVmaW5lZCB0byBiZVxuICAgZmx1c2hlZCBhdCB0aGF0IHRpbWUuICopXG5tb2R1bGUgQ29uc3VtZXIgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGNyZWF0ZVxuICAgIDogIHBpcGVfaWQ6aW50XG4gICAgLT4gZG93bnN0cmVhbV9mbHVzaGVkOih1bml0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudClcbiAgICAtPiB0XG5cbiAgdmFsIHBpcGVfaWQgOiB0IC0+IGludFxuICB2YWwgc3RhcnQgOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW0gOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgOiB0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBwaXBlX2lkIDogaW50XG4gICAgOyAoKiBbdmFsdWVzX3JlYWRdIHJlZmxlY3RzIHdoZXRoZXIgdmFsdWVzIHRoZSBjb25zdW1lciBoYXMgcmVhZCBmcm9tIHRoZSBwaXBlIGhhdmUgYmVlblxuICAgICAgICAgc2VudCBkb3duc3RyZWFtIG9yIGlmIG5vdCwgaG9sZHMgYW4gaXZhciB0aGF0IGlzIHRvIGJlIGZpbGxlZCB3aGVuIHRoZXkgYXJlLiAqKVxuICAgICAgbXV0YWJsZSB2YWx1ZXNfcmVhZCA6XG4gICAgICAgIFsgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gb2YgdW5pdCBJdmFyLnQgXVxuICAgIDsgKCogW2Rvd25zdHJlYW1fZmx1c2hlZCAoKV0gcmV0dXJucyB3aGVuIGFsbCBwcmlvciB2YWx1ZXMgdGhhdCB0aGUgY29uc3VtZXIgaGFzXG4gICAgICAgICBwYXNzZWQgZG93bnN0cmVhbSBoYXZlIGJlZW4gZmx1c2hlZCBhbGwgdGhlIHdheSBkb3duIHRoZSBjaGFpbiBvZiBwaXBlcy4gKilcbiAgICAgIGRvd25zdHJlYW1fZmx1c2hlZCA6IHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfnBpcGVfaWQ6aWdub3JlXG4gICAgICAgIH52YWx1ZXNfcmVhZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPiAoKVxuICAgICAgICAgICAgIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSlcbiAgICAgICAgfmRvd25zdHJlYW1fZmx1c2hlZDppZ25vcmVcbiAgICB3aXRoXG4gICAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLkNvbnN1bWVyLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSB+cGlwZToodCA6IHQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgfnBpcGVfaWQgfmRvd25zdHJlYW1fZmx1c2hlZCA9XG4gICAgeyBwaXBlX2lkOyB2YWx1ZXNfcmVhZCA9IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtOyBkb3duc3RyZWFtX2ZsdXNoZWQgfVxuICA7O1xuXG4gIGxldCBzdGFydCB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBfIC0+ICgpXG4gICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPlxuICAgICAgdC52YWx1ZXNfcmVhZCA8LSBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gKEl2YXIuY3JlYXRlICgpKVxuICA7O1xuXG4gIGxldCB2YWx1ZXNfc2VudF9kb3duc3RyZWFtIHQgPVxuICAgIG1hdGNoIHQudmFsdWVzX3JlYWQgd2l0aFxuICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT4gKClcbiAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBpdmFyIC0+XG4gICAgICBJdmFyLmZpbGwgaXZhciAoKTtcbiAgICAgIHQudmFsdWVzX3JlYWQgPC0gYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW1cbiAgOztcblxuICBsZXQgdmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZCB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+IHQuZG93bnN0cmVhbV9mbHVzaGVkICgpXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gd2hlbl9zZW50X2Rvd25zdHJlYW0gLT5cbiAgICAgIGxldCViaW5kICgpID0gSXZhci5yZWFkIHdoZW5fc2VudF9kb3duc3RyZWFtIGluXG4gICAgICB0LmRvd25zdHJlYW1fZmx1c2hlZCAoKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBCbG9ja2VkX3JlYWQgPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9yZWFkLnRdIHJlcHJlc2VudHMgYSBibG9ja2VkIHJlYWQgYXR0ZW1wdC4gIElmIHNvbWVvbmUgcmVhZHMgZnJvbSBhbiBlbXB0eVxuICAgICBwaXBlLCB0aGV5IGVucXVldWUgYSBbQmxvY2tlZF9yZWFkLnRdIGluIHRoZSBxdWV1ZSBvZiBbYmxvY2tlZF9yZWFkc10uICBMYXRlciwgd2hlblxuICAgICB2YWx1ZXMgYXJlIHdyaXR0ZW4gdG8gYSBwaXBlLCB0aGF0IHdpbGwgY2F1c2Ugc29tZSBudW1iZXIgb2YgYmxvY2tlZCByZWFkcyB0byBiZVxuICAgICBmaWxsZWQsIGZpcnN0IGNvbWUgZmlyc3Qgc2VydmUuICBUaGUgYmxvY2tlZC1yZWFkIGNvbnN0cnVjdG9yIHNwZWNpZmllcyBob3cgbWFueVxuICAgICB2YWx1ZXMgYSByZWFkIHNob3VsZCBjb25zdW1lIGZyb20gdGhlIHBpcGUgd2hlbiBpdCBnZXRzIGl0cyB0dXJuLlxuXG4gICAgIElmIGEgcGlwZSBpcyBjbG9zZWQsIHRoZW4gYWxsIGJsb2NrZWQgcmVhZHMgd2lsbCBiZSBmaWxsZWQgd2l0aCBbYEVvZl0uICopXG4gIHR5cGUgJ2Egd2FudHMgPVxuICAgIHwgWmVybyBvZiBbIGBFb2YgfCBgT2sgXSBJdmFyLnRcbiAgICB8IE9uZSBvZiBbIGBFb2YgfCBgT2sgb2YgJ2EgXSBJdmFyLnRcbiAgICB8IEF0X21vc3Qgb2YgaW50ICogWyBgRW9mIHwgYE9rIG9mICdhIFF1ZXVlLnQgXSBJdmFyLnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2FudHMgOiAnYSB3YW50c1xuICAgIDsgY29uc3VtZXIgOiBDb25zdW1lci50IG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH53YW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBaZXJvIF8gfCBPbmUgXyAtPiAoKVxuICAgICAgICAgICAgIHwgQXRfbW9zdCAoaSwgXykgLT4gYXNzZXJ0IChpID4gMCkpKVxuICAgICAgICB+Y29uc3VtZXI6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBjb25zdW1lciAtPiBDb25zdW1lci5pbnZhcmlhbnQgY29uc3VtZXIpKVxuICAgIHdpdGhcbiAgICB8IGV4biAtPlxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLkJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiBfIHQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgd2FudHMgY29uc3VtZXIgPSB7IHdhbnRzOyBjb25zdW1lciB9XG5cbiAgbGV0IGlzX2VtcHR5IHQgPVxuICAgIG1hdGNoIHQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpIC0+IEl2YXIuaXNfZW1wdHkgaVxuICAgIHwgT25lIGkgLT4gSXZhci5pc19lbXB0eSBpXG4gICAgfCBBdF9tb3N0IChfLCBpKSAtPiBJdmFyLmlzX2VtcHR5IGlcbiAgOztcblxuICBsZXQgZmlsbF93aXRoX2VvZiB0ID1cbiAgICBtYXRjaCB0LndhbnRzIHdpdGhcbiAgICB8IFplcm8gaSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gICAgfCBPbmUgaSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gICAgfCBBdF9tb3N0IChfLCBpKSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gIDs7XG5lbmRcblxubW9kdWxlIEJsb2NrZWRfZmx1c2ggPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9mbHVzaC50XSByZXByZXNlbnRzIGEgYmxvY2tlZCBmbHVzaCBvcGVyYXRpb24sIHdoaWNoIGNhbiBiZSBlbmFibGVkIGJ5IGFcbiAgICAgZnV0dXJlIHJlYWQuICBJZiBzb21lb25lIGRvZXMgW2ZsdXNoZWQgcF0gb24gYSBwaXBlLCB0aGF0IGJsb2NrcyB1bnRpbCBldmVyeXRoaW5nXG4gICAgIHRoYXQncyBjdXJyZW50bHkgaW4gdGhlIHBpcGUgYXQgdGhhdCBwb2ludCBoYXMgZHJhaW5lZCBvdXQgb2YgdGhlIHBpcGUuICBXaGVuIHdlIGNhbGxcbiAgICAgW2ZsdXNoZWRdLCBpdCByZWNvcmRzIHRoZSB0b3RhbCBhbW91bnQgb2YgZGF0YSB0aGF0IGhhcyBiZWVuIHdyaXR0ZW4gc28gZmFyIGluXG4gICAgIFtmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXS4gIFdlIGZpbGwgdGhlIFtGbHVzaC50XSB3aXRoIFtgT2tdIHdoZW4gdGhpcyBhbW91bnQgb2ZcbiAgICAgZGF0YSBoYXMgYmVlbiByZWFkIGZyb20gdGhlIHBpcGUuXG5cbiAgICAgQSBbQmxvY2tlZF9mbHVzaC50XSBjYW4gYWxzbyBiZSBmaWxsZWQgd2l0aCBbYFJlYWRlcl9jbG9zZWRdLCB3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgIHJlYWRlciBlbmQgb2YgdGhlIHBpcGUgaXMgY2xvc2VkLCBhbmQgd2UgYXJlIHRodXMgc3VyZSB0aGF0IHRoZSB1bnJlYWQgZWxlbWVudHNcbiAgICAgcHJlY2VkaW5nIHRoZSBmbHVzaCB3aWxsIG5ldmVyIGJlIHJlYWQuICopXG4gIHR5cGUgdCA9XG4gICAgeyBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gICAgOyByZWFkeSA6IFsgYE9rIHwgYFJlYWRlcl9jbG9zZWQgXSBJdmFyLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgZmlsbCB0IHYgPSBJdmFyLmZpbGwgdC5yZWFkeSB2XG5lbmRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyAoKiBbaWRdIGlzIGFuIGludGVnZXIgdXNlZCB0byBkaXN0aW5ndWlzaCBwaXBlcyB3aGVuIGRlYnVnZ2luZy4gKilcbiAgICBpZCA6IGludCBTZXhwX2hpZGRlbl9pbl90ZXN0LnRcbiAgOyAoKiBbaW5mb10gaXMgdXNlci1wcm92aWRlZCBhcmJpdHJhcnkgc2V4cCwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gKilcbiAgICBtdXRhYmxlIGluZm8gOiBTZXhwLnQgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gIDsgKCogW2J1ZmZlcl0gaG9sZHMgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHBpcGUgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZWFkLiAqKVxuICAgIG11dGFibGUgYnVmZmVyIDogJ2EgUXVldWUudFxuICA7ICgqIFtzaXplX2J1ZGdldF0gZ292ZXJucyBwdXNoYmFjayBvbiB3cml0ZXJzIHRvIHRoZSBwaXBlLlxuXG4gICAgICAgVGhlcmUgaXMgKm5vKiBpbnZhcmlhbnQgdGhhdCBbUXVldWUubGVuZ3RoIGJ1ZmZlciA8PSBzaXplX2J1ZGdldF0uICBUaGVyZSBpcyBub1xuICAgICAgIGhhcmQgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGNhbiBiZSBzdHVmZmVkIGludG8gdGhlIFtidWZmZXJdLlxuICAgICAgIFRoaXMgaXMgZHVlIHRvIHRoZSB3YXkgd2UgaGFuZGxlIHdyaXRlcy4gIFdoZW4gd2UgZG8gYSB3cml0ZSwgYWxsIG9mIHRoZSB2YWx1ZXNcbiAgICAgICB3cml0dGVuIGFyZSBpbW1lZGlhdGVseSBlbnF1ZXVlZCBpbnRvIFtidWZmZXJdLiAgQWZ0ZXIgdGhlIHdyaXRlLCBpZiBbUXVldWUubGVuZ3RoXG4gICAgICAgYnVmZmVyIDw9IHQuc2l6ZV9idWRnZXRdLCB0aGVuIHRoZSB3cml0ZXIgd2lsbCBiZSBub3RpZmllZCB0byBjb250aW51ZSB3cml0aW5nLlxuICAgICAgIEFmdGVyIHRoZSB3cml0ZSwgaWYgW2xlbmd0aCB0ID4gdC5zaXplX2J1ZGdldF0sIHRoZW4gdGhlIHdyaXRlIHdpbGwgYmxvY2sgdW50aWwgdGhlXG4gICAgICAgcGlwZSBpcyB1bmRlciBidWRnZXQuICopXG4gICAgbXV0YWJsZSBzaXplX2J1ZGdldCA6IGludFxuICA7ICgqIFtwdXNoYmFja10gaXMgdXNlZCB0byBnaXZlIGZlZWRiYWNrIHRvIHdyaXRlcnMgYWJvdXQgd2hldGhlciB0aGV5IHNob3VsZCB3cml0ZSB0b1xuICAgICAgIHRoZSBwaXBlLiAgW3B1c2hiYWNrXSBpcyBmdWxsIGlmZiBbbGVuZ3RoIHQgPD0gdC5zaXplX2J1ZGdldCB8fCBpc19jbG9zZWQgdF0uICopXG4gICAgbXV0YWJsZSBwdXNoYmFjayA6IHVuaXQgSXZhci50XG4gIDsgKCogW251bV92YWx1ZXNfcmVhZF0ga2VlcHMgdHJhY2sgb2YgdGhlIHRvdGFsIG51bWJlciBvZiB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gcmVhZFxuICAgICAgIGZyb20gdGhlIHBpcGUuICBXZSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dCBvdmVyZmxvdyBpbiBbbnVtX3ZhbHVlc19yZWFkXS4gIFlvdSdkXG4gICAgICAgbmVlZCB0byB3cml0ZSAyXjYyIGVsZW1lbnRzIHRvIHRoZSBwaXBlLCB3aGljaCB3b3VsZCB0YWtlIGFib3V0IDE0NiB5ZWFycywgYXQgYVxuICAgICAgIGZsb3cgcmF0ZSBvZiAxIHNpemUtdW5pdC9uYW5vc2Vjb25kLiAqKVxuICAgIG11dGFibGUgbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gIDsgKCogW2Jsb2NrZWRfZmx1c2hlc10gaG9sZHMgZmx1c2hlcyB3aG9zZSBwcmVjZWRpbmcgZWxlbWVudHMgaGF2ZSBub3QgYmVlbiBjb21wbGV0ZWx5XG4gICAgICAgcmVhZC4gIEZvciBlYWNoIGJsb2NrZWQgZmx1c2gsIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIHJlYWQgZnJvbSB0aGVcbiAgICAgICBwaXBlIGluIG9yZGVyIHRvIGZpbGwgdGhlIGZsdXNoIGlzICAgICAgICAgICAgICAgICAgICAgICAgOlxuXG4gICAgICAgZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZCAtIG51bV92YWx1ZXNfcmVhZFxuXG4gICAgICAgS2VlcGluZyB0aGUgZGF0YSBpbiB0aGlzIGZvcm0gYWxsb3dzIHVzIHRvIGNoYW5nZSBhIHNpbmdsZSBmaWVsZChudW1fdmFsdWVzX3JlYWQpXG4gICAgICAgd2hlbiB3ZSBjb25zdW1lIHZhbHVlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIHdob2xlIHF1ZXVlIG9mXG4gICAgICAgZmx1c2hlcy4gKilcbiAgICBibG9ja2VkX2ZsdXNoZXMgOiBCbG9ja2VkX2ZsdXNoLnQgUXVldWUudFxuICA7ICgqIFtibG9ja2VkX3JlYWRzXSBob2xkcyByZWFkcyB0aGF0IGFyZSB3YWl0aW5nIG9uIGRhdGEgdG8gYmUgd3JpdHRlbiB0byB0aGUgcGlwZS4gKilcbiAgICBibG9ja2VkX3JlYWRzIDogJ2EgQmxvY2tlZF9yZWFkLnQgUXVldWUudFxuICA7ICgqIFtjbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSB3cml0ZSBlbmQgb2YgdGhlIHBpcGUuICopXG4gICAgY2xvc2VkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbcmVhZF9jbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSByZWFkIGVuZCBvZiB0aGUgcGlwZS4gKilcbiAgICByZWFkX2Nsb3NlZCA6IHVuaXQgSXZhci50XG4gIDsgKCogW2NvbnN1bWVyc10gaXMgYSBsaXN0IG9mIGFsbCBjb25zdW1lcnMgdGhhdCBtYXkgYmUgaGFuZGxpbmcgdmFsdWVzIHJlYWQgZnJvbSB0aGVcbiAgICAgICBwaXBlLiAqKVxuICAgIG11dGFibGUgY29uc3VtZXJzIDogQ29uc3VtZXIudCBsaXN0XG4gIDsgKCogW3Vwc3RyZWFtX2ZsdXNoZWRzXSBoYXMgYSBmdW5jdGlvbiBmb3IgZWFjaCBwaXBlIGltbWVkaWF0ZWx5IHVwc3RyZWFtIG9mIHRoaXMgb25lLlxuICAgICAgIFRoYXQgZnVuY3Rpb24gd2Fsa3MgdG8gdGhlIGhlYWQocykgb2YgdGhlIHVwc3RyZWFtIHBpcGUsIGFuZCBjYWxsc1xuICAgICAgIFtkb3duc3RyZWFtX2ZsdXNoZWRdIG9uIHRoZSBoZWFkKHMpLiAgU2VlIHRoZSBkZWZpbml0aW9uIG9mIFt1cHN0cmVhbV9mbHVzaGVkXVxuICAgICAgIGJlbG93LiAqKVxuICAgIHVwc3RyZWFtX2ZsdXNoZWRzIDogKHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KSBCYWcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgcGlwZSA9ICgnYSwgJ3BoYW50b20pIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGhhc2ggdCA9IEhhc2h0YmwuaGFzaCB0LmlkXG5sZXQgZXF1YWwgKHQxIDogKF8sIF8pIHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IGNvbXBhcmUgdDEgdDIgPSBJbnQuY29tcGFyZSB0MS5pZCB0Mi5pZFxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIHQuY2xvc2VkXG5sZXQgaXNfcmVhZF9jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LnJlYWRfY2xvc2VkXG5sZXQgY2xvc2VkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZWRcbmxldCBwdXNoYmFjayB0ID0gSXZhci5yZWFkIHQucHVzaGJhY2tcbmxldCBsZW5ndGggdCA9IFF1ZXVlLmxlbmd0aCB0LmJ1ZmZlclxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIHRyeVxuICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5pbmZvOmlnbm9yZVxuICAgICAgfmJ1ZmZlcjppZ25vcmVcbiAgICAgIH5zaXplX2J1ZGdldDooY2hlY2sgKGZ1biBzaXplX2J1ZGdldCAtPiBhc3NlcnQgKHNpemVfYnVkZ2V0ID49IDApKSlcbiAgICAgIH5wdXNoYmFjazpcbiAgICAgICAgKGNoZWNrIChmdW4gcHVzaGJhY2sgLT5cbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBCb29sLmVxdWFsXG4gICAgICAgICAgICAgICAoSXZhci5pc19mdWxsIHB1c2hiYWNrKVxuICAgICAgICAgICAgICAgKGxlbmd0aCB0IDw9IHQuc2l6ZV9idWRnZXQgfHwgaXNfY2xvc2VkIHQpKSkpXG4gICAgICB+bnVtX3ZhbHVlc19yZWFkOmlnbm9yZVxuICAgICAgfmJsb2NrZWRfZmx1c2hlczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9mbHVzaGVzIC0+XG4gICAgICAgICAgIFF1ZXVlLml0ZXIgYmxvY2tlZF9mbHVzaGVzIH5mOihmdW4gKGYgOiBCbG9ja2VkX2ZsdXNoLnQpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChmLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPiB0Lm51bV92YWx1ZXNfcmVhZCkpO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIExpc3QuaXNfc29ydGVkXG4gICAgICAgICAgICAgICB+Y29tcGFyZTpJbnQuY29tcGFyZVxuICAgICAgICAgICAgICAgKExpc3QubWFwXG4gICAgICAgICAgICAgICAgICAoUXVldWUudG9fbGlzdCBibG9ja2VkX2ZsdXNoZXMpXG4gICAgICAgICAgICAgICAgICB+ZjpCbG9ja2VkX2ZsdXNoLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQpKTtcbiAgICAgICAgICAgaWYgaXNfZW1wdHkgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9mbHVzaGVzKSkpXG4gICAgICB+YmxvY2tlZF9yZWFkczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9yZWFkcyAtPlxuICAgICAgICAgICAoKiBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgbm8gb25lIGlzIHdhaXRpbmcgZm9yIGl0LiAgVGhpcyB3b3VsZCBuZWVkIHRvIGNoYW5nZSBpZlxuICAgICAgICAgICAgICB3ZSBldmVyIGltcGxlbWVudCBbcmVhZF9leGFjdGx5XSBhcyBhbiBhdG9taWMgb3BlcmF0aW9uLiAqKVxuICAgICAgICAgICBpZiBub3QgKGlzX2VtcHR5IHQpIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSBibG9ja2VkX3JlYWRzKTtcbiAgICAgICAgICAgUXVldWUuaXRlciBibG9ja2VkX3JlYWRzIH5mOihmdW4gcmVhZCAtPlxuICAgICAgICAgICAgIEJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgcmVhZDtcbiAgICAgICAgICAgICBhc3NlcnQgKEJsb2NrZWRfcmVhZC5pc19lbXB0eSByZWFkKSk7XG4gICAgICAgICAgICgqIFlvdSBuZXZlciBibG9jayB0cnlpbmcgdG8gcmVhZCBhIGNsb3NlZCBwaXBlLiAqKVxuICAgICAgICAgICBpZiBpc19jbG9zZWQgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9yZWFkcykpKVxuICAgICAgfmNsb3NlZDppZ25vcmVcbiAgICAgIH5yZWFkX2Nsb3NlZDppZ25vcmVcbiAgICAgIH5jb25zdW1lcnM6XG4gICAgICAgIChjaGVjayAoZnVuIGwgLT5cbiAgICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biBjb25zdW1lciAtPlxuICAgICAgICAgICAgIENvbnN1bWVyLmludmFyaWFudCBjb25zdW1lcjtcbiAgICAgICAgICAgICBhc3NlcnQgKENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXIgPSB0LmlkKSkpKVxuICAgICAgfnVwc3RyZWFtX2ZsdXNoZWRzOmlnbm9yZVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiAoXywgXykgdCldXG47O1xuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIHR5cGUgcGhhbnRvbSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICdhIHQgPSAoJ2EsIHBoYW50b20pIHBpcGUgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5lbmRcblxubW9kdWxlIFdyaXRlciA9IHN0cnVjdFxuICB0eXBlIHBoYW50b20gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0ID0gKCdhLCBwaGFudG9tKSBwaXBlIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuZW5kXG5cbmxldCBpZF9yZWYgPSByZWYgMFxuXG5sZXQgY3JlYXRlX2ludGVybmFsIH5zaXplX2J1ZGdldCB+aW5mbyB+aW5pdGlhbF9idWZmZXIgPVxuICBpbmNyIGlkX3JlZjtcbiAgbGV0IHQgPVxuICAgIHsgaWQgPSAhaWRfcmVmXG4gICAgOyBpbmZvXG4gICAgOyBjbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgcmVhZF9jbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDtcbiAgICAgIHNpemVfYnVkZ2V0XG4gICAgOyBwdXNoYmFjayA9IEl2YXIuY3JlYXRlICgpXG4gICAgOyBidWZmZXIgPSBpbml0aWFsX2J1ZmZlclxuICAgIDsgbnVtX3ZhbHVlc19yZWFkID0gMFxuICAgIDsgYmxvY2tlZF9mbHVzaGVzID0gUXVldWUuY3JlYXRlICgpXG4gICAgOyBibG9ja2VkX3JlYWRzID0gUXVldWUuY3JlYXRlICgpXG4gICAgOyBjb25zdW1lcnMgPSBbXVxuICAgIDsgdXBzdHJlYW1fZmx1c2hlZHMgPSBCYWcuY3JlYXRlICgpXG4gICAgfVxuICBpblxuICB0XG47O1xuXG5sZXQgdmFsaWRhdGVfc2l6ZV9idWRnZXQgc2l6ZV9idWRnZXQgPVxuICBpZiBzaXplX2J1ZGdldCA8IDBcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIm5lZ2F0aXZlIHNpemVfYnVkZ2V0XCIgKHNpemVfYnVkZ2V0IDogaW50KV1cbiAgZWxzZSBzaXplX2J1ZGdldFxuOztcblxubGV0IGNyZWF0ZSA/c2l6ZV9idWRnZXQgP2luZm8gKCkgPVxuICBsZXQgc2l6ZV9idWRnZXQgPVxuICAgIG1hdGNoIHNpemVfYnVkZ2V0IHdpdGhcbiAgICB8IFNvbWUgdiAtPiB2YWxpZGF0ZV9zaXplX2J1ZGdldCB2XG4gICAgfCBOb25lIC0+IDBcbiAgaW5cbiAgbGV0IHQgPSBjcmVhdGVfaW50ZXJuYWwgfnNpemVfYnVkZ2V0IH5pbmZvIH5pbml0aWFsX2J1ZmZlcjooUXVldWUuY3JlYXRlICgpKSBpblxuICAoKiBpbml0aWFsbHksIHRoZSBwaXBlIGRvZXMgbm90IHB1c2hiYWNrICopXG4gIEl2YXIuZmlsbCB0LnB1c2hiYWNrICgpO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIHQsIHRcbjs7XG5cbmxldCB1cGRhdGVfcHVzaGJhY2sgdCA9XG4gIGlmIGxlbmd0aCB0IDw9IHQuc2l6ZV9idWRnZXQgfHwgaXNfY2xvc2VkIHRcbiAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgdC5wdXNoYmFjayAoKVxuICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LnB1c2hiYWNrXG4gIHRoZW4gdC5wdXNoYmFjayA8LSBJdmFyLmNyZWF0ZSAoKVxuOztcblxubGV0IGNsb3NlIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJjbG9zZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgbm90IChpc19jbG9zZWQgdClcbiAgdGhlbiAoXG4gICAgSXZhci5maWxsIHQuY2xvc2VkICgpO1xuICAgIGlmIGlzX2VtcHR5IHRcbiAgICB0aGVuIChcbiAgICAgIFF1ZXVlLml0ZXIgdC5ibG9ja2VkX3JlYWRzIH5mOkJsb2NrZWRfcmVhZC5maWxsX3dpdGhfZW9mO1xuICAgICAgUXVldWUuY2xlYXIgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdClcbjs7XG5cbmxldCBjbG9zZV9yZWFkIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJjbG9zZV9yZWFkXCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBpZiBub3QgKGlzX3JlYWRfY2xvc2VkIHQpXG4gIHRoZW4gKFxuICAgIEl2YXIuZmlsbCB0LnJlYWRfY2xvc2VkICgpO1xuICAgIFF1ZXVlLml0ZXIgdC5ibG9ja2VkX2ZsdXNoZXMgfmY6KGZ1biBmbHVzaCAtPiBCbG9ja2VkX2ZsdXNoLmZpbGwgZmx1c2ggYFJlYWRlcl9jbG9zZWQpO1xuICAgIFF1ZXVlLmNsZWFyIHQuYmxvY2tlZF9mbHVzaGVzO1xuICAgIFF1ZXVlLmNsZWFyIHQuYnVmZmVyO1xuICAgIHVwZGF0ZV9wdXNoYmFjayB0O1xuICAgICgqIHdlIGp1c3QgY2xlYXJlZCB0aGUgYnVmZmVyLCBzbyBtYXkgbmVlZCB0byBmaWxsIFt0LnB1c2hiYWNrXSAqKVxuICAgIGNsb3NlIHQpXG47O1xuXG5sZXQgY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uID9zaXplX2J1ZGdldCBmID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gIHVwb24gKGYgdykgKGZ1biAoKSAtPiBjbG9zZSB3KTtcbiAgclxuOztcblxubGV0IGNyZWF0ZV9yZWFkZXIgP3NpemVfYnVkZ2V0IH5jbG9zZV9vbl9leGNlcHRpb24gZiA9XG4gIGlmIG5vdCBjbG9zZV9vbl9leGNlcHRpb25cbiAgdGhlbiBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gP3NpemVfYnVkZ2V0IGZcbiAgZWxzZSAoXG4gICAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgIChNb25pdG9yLnByb3RlY3RcbiAgICAgICAgIH5ydW46XG4gICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICAgKGZ1biAoKSAtPiBmIHcpXG4gICAgICAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICAgICAgIGNsb3NlIHc7XG4gICAgICAgICAgIHJldHVybiAoKSkpO1xuICAgIHIpXG47O1xuXG5sZXQgY3JlYXRlX3dyaXRlciA/c2l6ZV9idWRnZXQgZiA9XG4gIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChNb25pdG9yLnByb3RlY3RcbiAgICAgICB+cnVuOlxuICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgfnJlc3Q6YExvZ1xuICAgICAgIChmdW4gKCkgLT4gZiByKVxuICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgICAgIGNsb3NlX3JlYWQgcjtcbiAgICAgICAgIHJldHVybiAoKSkpO1xuICB3XG47O1xuXG5sZXQgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyID1cbiAgT3B0aW9uLml0ZXIgY29uc3VtZXIgfmY6Q29uc3VtZXIuc3RhcnQ7XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbWF0Y2ggUXVldWUucGVlayB0LmJsb2NrZWRfZmx1c2hlcyB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGZsdXNoIC0+XG4gICAgICBpZiB0Lm51bV92YWx1ZXNfcmVhZCA+PSBmbHVzaC5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXG4gICAgICB0aGVuIChcbiAgICAgICAgaWdub3JlIChRdWV1ZS5kZXF1ZXVlX2V4biB0LmJsb2NrZWRfZmx1c2hlcyA6IEJsb2NrZWRfZmx1c2gudCk7XG4gICAgICAgIChtYXRjaCBjb25zdW1lciB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGBPa1xuICAgICAgICAgfCBTb21lIGNvbnN1bWVyIC0+XG4gICAgICAgICAgIHVwb24gKENvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgY29uc3VtZXIpIChmdW4gZmx1c2hfcmVzdWx0IC0+XG4gICAgICAgICAgICAgQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGZsdXNoX3Jlc3VsdCkpO1xuICAgICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpXG47O1xuXG4oKiBbY29uc3VtZV9hbGwgdF0gcmVhZHMgYWxsIHRoZSBlbGVtZW50cyBpbiBbdF0uICopXG5sZXQgY29uc3VtZV9hbGwgdCBjb25zdW1lciA9XG4gIGxldCByZXN1bHQgPSB0LmJ1ZmZlciBpblxuICB0LmJ1ZmZlciA8LSBRdWV1ZS5jcmVhdGUgKCk7XG4gIHQubnVtX3ZhbHVlc19yZWFkIDwtIHQubnVtX3ZhbHVlc19yZWFkICsgUXVldWUubGVuZ3RoIHJlc3VsdDtcbiAgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyO1xuICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgcmVzdWx0XG47O1xuXG5sZXQgY29uc3VtZV9vbmUgdCBjb25zdW1lciA9XG4gIGFzc2VydCAobGVuZ3RoIHQgPj0gMSk7XG4gIGxldCByZXN1bHQgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmJ1ZmZlciBpblxuICB0Lm51bV92YWx1ZXNfcmVhZCA8LSB0Lm51bV92YWx1ZXNfcmVhZCArIDE7XG4gIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gIHJlc3VsdFxuOztcblxubGV0IGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lciA9XG4gIGFzc2VydCAobWF4X3F1ZXVlX2xlbmd0aCA+PSAwKTtcbiAgaWYgbWF4X3F1ZXVlX2xlbmd0aCA+PSBsZW5ndGggdFxuICB0aGVuIGNvbnN1bWVfYWxsIHQgY29uc3VtZXJcbiAgZWxzZSAoXG4gICAgdC5udW1fdmFsdWVzX3JlYWQgPC0gdC5udW1fdmFsdWVzX3JlYWQgKyBtYXhfcXVldWVfbGVuZ3RoO1xuICAgIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgICBsZXQgcmVzdWx0ID0gUXVldWUuY3JlYXRlIH5jYXBhY2l0eTptYXhfcXVldWVfbGVuZ3RoICgpIGluXG4gICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnQuYnVmZmVyIH5kc3Q6cmVzdWx0IH5sZW46bWF4X3F1ZXVlX2xlbmd0aCAoKTtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgICByZXN1bHQpXG47O1xuXG5sZXQgc2V0X3NpemVfYnVkZ2V0IHQgc2l6ZV9idWRnZXQgPVxuICBsZXQgc2l6ZV9idWRnZXQgPSB2YWxpZGF0ZV9zaXplX2J1ZGdldCBzaXplX2J1ZGdldCBpblxuICB0LnNpemVfYnVkZ2V0IDwtIHNpemVfYnVkZ2V0O1xuICB1cGRhdGVfcHVzaGJhY2sgdFxuOztcblxubGV0IGZpbGxfYmxvY2tlZF9yZWFkcyB0ID1cbiAgd2hpbGUgKG5vdCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKSkgJiYgbm90IChpc19lbXB0eSB0KSBkb1xuICAgIGxldCBibG9ja2VkX3JlYWQgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmJsb2NrZWRfcmVhZHMgaW5cbiAgICBsZXQgY29uc3VtZXIgPSBibG9ja2VkX3JlYWQuY29uc3VtZXIgaW5cbiAgICBtYXRjaCBibG9ja2VkX3JlYWQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpdmFyIC0+IEl2YXIuZmlsbCBpdmFyIGBPa1xuICAgIHwgT25lIGl2YXIgLT4gSXZhci5maWxsIGl2YXIgKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpXG4gICAgfCBBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSAtPlxuICAgICAgSXZhci5maWxsIGl2YXIgKGBPayAoY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyKSlcbiAgZG9uZVxuOztcblxuKCogY2hlY2tzIGFsbCBpbnZhcmlhbnRzLCBjYWxscyBhIHBhc3NlZCBpbiBmIHRvIGhhbmRsZSBhIHdyaXRlLCB0aGVuIHVwZGF0ZXMgcmVhZHMgYW5kXG4gICBwdXNoYmFjayAqKVxubGV0IHN0YXJ0X3dyaXRlIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJ3cml0ZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgaXNfY2xvc2VkIHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIndyaXRlIHRvIGNsb3NlZCBwaXBlXCIgfnBpcGU6KHQgOiAoXywgXykgdCldXG47O1xuXG5sZXQgZmluaXNoX3dyaXRlIHQgPVxuICBmaWxsX2Jsb2NrZWRfcmVhZHMgdDtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb20gPVxuICBzdGFydF93cml0ZSB0O1xuICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6ZnJvbSB+ZHN0OnQuYnVmZmVyICgpO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHRyYW5zZmVyX2luIHQgfmZyb20gPVxuICB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb207XG4gIHB1c2hiYWNrIHRcbjs7XG5cbmxldCBjb3B5X2luX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZnJvbSA9XG4gIHN0YXJ0X3dyaXRlIHQ7XG4gIFF1ZXVlLml0ZXIgZnJvbSB+ZjooZnVuIHggLT4gUXVldWUuZW5xdWV1ZSB0LmJ1ZmZlciB4KTtcbiAgZmluaXNoX3dyaXRlIHRcbjs7XG5cbigqIFt3cml0ZSddIGlzIHVzZWQgaW50ZXJuYWxseSAqKVxubGV0IHdyaXRlJyB0IHEgPSB0cmFuc2Zlcl9pbiB0IH5mcm9tOnFcblxubGV0IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB2YWx1ZSA9XG4gIHN0YXJ0X3dyaXRlIHQ7XG4gIFF1ZXVlLmVucXVldWUgdC5idWZmZXIgdmFsdWU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGUgdCB2YWx1ZSA9XG4gIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB2YWx1ZTtcbiAgcHVzaGJhY2sgdFxuOztcblxubGV0IHdyaXRlX3doZW5fcmVhZHkgdCB+ZiA9XG4gIGxldCVtYXAgKCkgPSBwdXNoYmFjayB0IGluXG4gIGlmIGlzX2Nsb3NlZCB0IHRoZW4gYENsb3NlZCBlbHNlIGBPayAoZiAoZnVuIHggLT4gd3JpdGVfd2l0aG91dF9wdXNoYmFjayB0IHgpKVxuOztcblxubGV0IHdyaXRlX2lmX29wZW4gdCB4ID0gaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiB3cml0ZSB0IHggZWxzZSByZXR1cm4gKClcblxubGV0IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2tfaWZfb3BlbiB0IHggPVxuICBpZiBub3QgKGlzX2Nsb3NlZCB0KSB0aGVuIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB4XG47O1xuXG5sZXQgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgP2NvbnN1bWVyIHQgPVxuICBtYXRjaCBjb25zdW1lciB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgY29uc3VtZXIgLT5cbiAgICBpZiB0LmlkIDw+IENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXJcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQXR0ZW1wdCB0byB1c2UgY29uc3VtZXIgd2l0aCB3cm9uZyBwaXBlXCJcbiAgICAgICAgICAgIChjb25zdW1lciA6IENvbnN1bWVyLnQpXG4gICAgICAgICAgICB+cGlwZToodCA6IF8gUmVhZGVyLnQpXVxuOztcblxubGV0IHN0YXJ0X3JlYWQgP2NvbnN1bWVyIHQgbGFiZWwgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgbGFiZWwgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBlbnN1cmVfY29uc3VtZXJfbWF0Y2hlcyB0ID9jb25zdW1lclxuOztcblxubGV0IGdlbl9yZWFkX25vdyA/Y29uc3VtZXIgdCBjb25zdW1lID1cbiAgc3RhcnRfcmVhZCB0IFwicmVhZF9ub3dcIiA/Y29uc3VtZXI7XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBpZiBpc19jbG9zZWQgdCB0aGVuIGBFb2YgZWxzZSBgTm90aGluZ19hdmFpbGFibGVcbiAgZWxzZSAoXG4gICAgYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSB0LmJsb2NrZWRfcmVhZHMpO1xuICAgICgqIGZyb20gW2ludmFyaWFudF0gYW5kIFtub3QgKGlzX2VtcHR5IHQpXSAqKVxuICAgIGBPayAoY29uc3VtZSB0IGNvbnN1bWVyKSlcbjs7XG5cbmxldCBnZXRfbWF4X3F1ZXVlX2xlbmd0aCB+bWF4X3F1ZXVlX2xlbmd0aCA9XG4gIG1hdGNoIG1heF9xdWV1ZV9sZW5ndGggd2l0aFxuICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICB8IFNvbWUgbWF4X3F1ZXVlX2xlbmd0aCAtPlxuICAgIGlmIG1heF9xdWV1ZV9sZW5ndGggPD0gMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJtYXhfcXVldWVfbGVuZ3RoIDw9IDBcIiAobWF4X3F1ZXVlX2xlbmd0aCA6IGludCldO1xuICAgIG1heF9xdWV1ZV9sZW5ndGhcbjs7XG5cbmxldCByZWFkX25vdycgP2NvbnN1bWVyID9tYXhfcXVldWVfbGVuZ3RoIHQgPVxuICBsZXQgbWF4X3F1ZXVlX2xlbmd0aCA9IGdldF9tYXhfcXVldWVfbGVuZ3RoIH5tYXhfcXVldWVfbGVuZ3RoIGluXG4gIGdlbl9yZWFkX25vdyB0ID9jb25zdW1lciAoZnVuIHQgY29uc3VtZXIgLT4gY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyKVxuOztcblxubGV0IHJlYWRfbm93ID9jb25zdW1lciB0ID0gZ2VuX3JlYWRfbm93IHQgP2NvbnN1bWVyIGNvbnN1bWVfb25lXG5sZXQgcGVlayB0ID0gUXVldWUucGVlayB0LmJ1ZmZlclxuXG5sZXQgY2xlYXIgdCA9XG4gIG1hdGNoIHJlYWRfbm93JyB0IHdpdGhcbiAgfCBgRW9mIHwgYE5vdGhpbmdfYXZhaWxhYmxlIHwgYE9rIF8gLT4gKClcbjs7XG5cbmxldCByZWFkJyA/Y29uc3VtZXIgP21heF9xdWV1ZV9sZW5ndGggdCA9XG4gIGxldCBtYXhfcXVldWVfbGVuZ3RoID0gZ2V0X21heF9xdWV1ZV9sZW5ndGggfm1heF9xdWV1ZV9sZW5ndGggaW5cbiAgc3RhcnRfcmVhZCB0IFwicmVhZCdcIiA/Y29uc3VtZXI7XG4gIG1hdGNoIHJlYWRfbm93JyB0ID9jb25zdW1lciB+bWF4X3F1ZXVlX2xlbmd0aCB3aXRoXG4gIHwgKGBPayBfIHwgYEVvZikgYXMgciAtPiByZXR1cm4gclxuICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgdC5ibG9ja2VkX3JlYWRzXG4gICAgICAgIChCbG9ja2VkX3JlYWQuY3JlYXRlIChBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSkgY29uc3VtZXIpKVxuOztcblxubGV0IHJlYWQgP2NvbnN1bWVyIHQgPVxuICBzdGFydF9yZWFkIHQgXCJyZWFkXCIgP2NvbnN1bWVyO1xuICBpZiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBpZiBpc19jbG9zZWQgdFxuICAgIHRoZW4gcmV0dXJuIGBFb2ZcbiAgICBlbHNlXG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdC5ibG9ja2VkX3JlYWRzIChCbG9ja2VkX3JlYWQuKGNyZWF0ZSAoT25lIGl2YXIpKSBjb25zdW1lcikpXG4gIGVsc2UgKFxuICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICByZXR1cm4gKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpKVxuOztcblxubGV0IHJlYWRfZXhuID9jb25zdW1lciB0ID1cbiAgbWF0Y2glbWFwIHJlYWQgP2NvbnN1bWVyIHQgd2l0aFxuICB8IGBPayB2YWx1ZSAtPiB2YWx1ZVxuICB8IGBFb2YgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhuOiByZWNlaXZlZCBFT0ZcIl1cbjs7XG5cbmxldCB2YWx1ZXNfYXZhaWxhYmxlIHQgPVxuICBzdGFydF9yZWFkIHQgXCJ2YWx1ZXNfYXZhaWxhYmxlXCI7XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gYE9rXG4gIGVsc2UgaWYgaXNfY2xvc2VkIHRcbiAgdGhlbiByZXR1cm4gYEVvZlxuICBlbHNlIChcbiAgICBtYXRjaCBRdWV1ZS5sYXN0IHQuYmxvY2tlZF9yZWFkcyB3aXRoXG4gICAgfCBTb21lIHsgY29uc3VtZXIgPSBOb25lOyB3YW50cyA9IFplcm8gaXZhciB9IC0+XG4gICAgICAoKiBUaGlzIGNhc2UgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBtdWx0aXBsZSBjYWxscyB0byBbdmFsdWVzX2F2YWlsYWJsZV0gaW5cbiAgICAgICAgIHNlcXVlbmNlLiAgSXQgY2F1c2VzIHRoZW0gdG8gYWxsIHNoYXJlIHRoZSBzYW1lIGl2YXIsIHJhdGhlciB0aGFuIGFsbG9jYXRlXG4gICAgICAgICBhbiBpdmFyIHBlciBjYWxsLiAqKVxuICAgICAgSXZhci5yZWFkIGl2YXJcbiAgICB8IF8gLT5cbiAgICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgICAgUXVldWUuZW5xdWV1ZSB0LmJsb2NrZWRfcmVhZHMgKEJsb2NrZWRfcmVhZC4oY3JlYXRlIChaZXJvIGl2YXIpKSBOb25lKSkpXG47O1xuXG5sZXQgcmVhZF9jaG9pY2UgdCA9IGNob2ljZSAodmFsdWVzX2F2YWlsYWJsZSB0KSAoZnVuIChfIDogWyBgT2sgfCBgRW9mIF0pIC0+IHJlYWRfbm93IHQpXG5cbmxldCByZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXhuIHQgaGVyZSA9XG4gIERlZmVycmVkLkNob2ljZS5tYXAgKHJlYWRfY2hvaWNlIHQpIH5mOihmdW5jdGlvblxuICAgIHwgKGBPayBfIHwgYEVvZikgYXMgeCAtPiB4XG4gICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJQaXBlLnJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leG46IGNob2ljZSB3YXMgZW5hYmxlZCBidXQgcGlwZSBpcyBlbXB0eTsgXFxcbiAgICAgICAgICAgdGhpcyBpcyBsaWtlbHkgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gd2l0aCBvbmUgb3IgbW9yZSBvdGhlciBjb25zdW1lcnNcIlxuICAgICAgICAgICAgKGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV0pXG47O1xuXG4oKiBbcmVhZF9leGFjdGx5IHQgfm51bV92YWx1ZXNdIGxvb3BzLCBnZXR0aW5nIHlvdSBhbGwgW251bV92YWx1ZXNdIGl0ZW1zLCB1cFxuICAgdG8gRU9GLiAqKVxubGV0IHJlYWRfZXhhY3RseSA/Y29uc3VtZXIgdCB+bnVtX3ZhbHVlcyA9XG4gIHN0YXJ0X3JlYWQgdCBcInJlYWRfZXhhY3RseVwiID9jb25zdW1lcjtcbiAgaWYgbnVtX3ZhbHVlcyA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhhY3RseSBnb3QgbnVtX3ZhbHVlcyA8PSAwXCIgKG51bV92YWx1ZXMgOiBpbnQpXTtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoIC0+XG4gICAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBsZXQgYWxyZWFkeV9yZWFkID0gUXVldWUubGVuZ3RoIHJlc3VsdCBpblxuICAgICAgYXNzZXJ0IChhbHJlYWR5X3JlYWQgPD0gbnVtX3ZhbHVlcyk7XG4gICAgICBpZiBhbHJlYWR5X3JlYWQgPSBudW1fdmFsdWVzXG4gICAgICB0aGVuIEl2YXIuZmlsbCBmaW5pc2ggKGBFeGFjdGx5IHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgcmVhZCcgP2NvbnN1bWVyIHQgfm1heF9xdWV1ZV9sZW5ndGg6KG51bV92YWx1ZXMgLSBhbHJlYWR5X3JlYWQpXG4gICAgICAgID4+PiBmdW5jdGlvblxuICAgICAgICB8IGBFb2YgLT4gSXZhci5maWxsIGZpbmlzaCAoaWYgYWxyZWFkeV9yZWFkID0gMCB0aGVuIGBFb2YgZWxzZSBgRmV3ZXIgcmVzdWx0KVxuICAgICAgICB8IGBPayBxIC0+XG4gICAgICAgICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnEgfmRzdDpyZXN1bHQgKCk7XG4gICAgICAgICAgbG9vcCAoKVxuICAgIGluXG4gICAgbG9vcCAoKSlcbjs7XG5cbmxldCBkb3duc3RyZWFtX2ZsdXNoZWQgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlblxuICAgIGlmIExpc3QuaXNfZW1wdHkgdC5jb25zdW1lcnNcbiAgICB0aGVuIHJldHVybiBgT2tcbiAgICBlbHNlXG4gICAgICBGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXG4gICAgICAgIChMaXN0Lm1hcCB0LmNvbnN1bWVycyB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkKVxuICBlbHNlXG4gICAgKCogW3RdIG1pZ2h0IGJlIGNsb3NlZC4gIEJ1dCB0aGUgcmVhZCBlbmQgY2FuJ3QgYmUgY2xvc2VkLCBiZWNhdXNlIGlmIGl0IHdlcmUsIHRoZW5cbiAgICAgICBbdF0gd291bGQgYmUgZW1wdHkuICBJZiB0aGUgd3JpdGUgZW5kIGlzIGNsb3NlZCBidXQgbm90IHRoZSByZWFkIGVuZCwgdGhlbiB3ZSB3YW50XG4gICAgICAgdG8gZW5xdWV1ZSBhIGJsb2NrZWQgZmx1c2ggYmVjYXVzZSB0aGUgZW5xdWV1ZWQgdmFsdWVzIG1heSBnZXQgcmVhZC4gKilcbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZWFkeSAtPlxuICAgICAgUXVldWUuZW5xdWV1ZVxuICAgICAgICB0LmJsb2NrZWRfZmx1c2hlc1xuICAgICAgICB7IGZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPSB0Lm51bV92YWx1ZXNfcmVhZCArIGxlbmd0aCB0OyByZWFkeSB9KVxuOztcblxuKCogSW4gcHJhY3RpY2UsIGFsb25nIHdpdGggW0xpbmsuY3JlYXRlXSBhbmQgW2FkZF91cHN0cmVhbV9mbHVzaGVkXSwgW3Vwc3RyZWFtX2ZsdXNoZWRdXG4gICB0cmF2ZXJzZXMgdGhlIGdyYXBoIG9mIGxpbmtlZCBwaXBlcyB1cCB0byB0aGUgaGVhZHMgYW5kIHRoZW4gY2FsbHMgW2Rvd25zdHJlYW1fZmx1c2hlZF1cbiAgIG9uIHRoZW0uICopXG5sZXQgdXBzdHJlYW1fZmx1c2hlZCB0ID1cbiAgaWYgQmFnLmlzX2VtcHR5IHQudXBzdHJlYW1fZmx1c2hlZHNcbiAgdGhlbiBkb3duc3RyZWFtX2ZsdXNoZWQgdFxuICBlbHNlXG4gICAgQmFnLnRvX2xpc3QgdC51cHN0cmVhbV9mbHVzaGVkc1xuICAgIHw+IExpc3QubWFwIH5mOihmdW4gZiAtPiBmICgpKVxuICAgIHw+IEZsdXNoZWRfcmVzdWx0LmNvbWJpbmVcbjs7XG5cbmxldCBhZGRfdXBzdHJlYW1fZmx1c2hlZCB0IHVwc3RyZWFtX2ZsdXNoZWQgPSBCYWcuYWRkIHQudXBzdHJlYW1fZmx1c2hlZHMgdXBzdHJlYW1fZmx1c2hlZFxuXG5sZXQgYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZCA9XG4gIGxldCBjb25zdW1lciA9IENvbnN1bWVyLmNyZWF0ZSB+cGlwZV9pZDp0LmlkIH5kb3duc3RyZWFtX2ZsdXNoZWQgaW5cbiAgdC5jb25zdW1lcnMgPC0gY29uc3VtZXIgOjogdC5jb25zdW1lcnM7XG4gIGNvbnN1bWVyXG47O1xuXG4oKiBBIFtMaW5rLnRdIGxpbmtzIGZsdXNoaW5nIG9mIHR3byBwaXBlcyB0b2dldGhlci4gKilcbm1vZHVsZSBMaW5rIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiB1cHN0cmVhbTooXywgXykgcGlwZSAtPiBkb3duc3RyZWFtOihfLCBfKSBwaXBlIC0+IHRcbiAgdmFsIGNvbnN1bWVyIDogdCAtPiBDb25zdW1lci50XG5cbiAgKCogW3VubGlua191cHN0cmVhbV0gcmVtb3ZlcyBkb3duc3RyZWFtJ3MgcmVmZXJlbmNlIHRvIHVwc3RyZWFtLiAqKVxuXG4gIHZhbCB1bmxpbmtfdXBzdHJlYW0gOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHVucGFja2VkID1cbiAgICB7IGRvd25zdHJlYW0gOiAoJ2EsICdiKSB0XG4gICAgOyBjb25zdW1lciA6IENvbnN1bWVyLnRcbiAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgOiAodW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnQpIEJhZy5FbHQudFxuICAgIH1cblxuICB0eXBlIHQgPSBUIDogKF8sIF8pIHVucGFja2VkIC0+IHRcblxuICBsZXQgY29uc3VtZXIgKFQgdCkgPSB0LmNvbnN1bWVyXG5cbiAgbGV0IGNyZWF0ZSB+dXBzdHJlYW0gfmRvd25zdHJlYW0gPVxuICAgIFRcbiAgICAgIHsgZG93bnN0cmVhbVxuICAgICAgOyBjb25zdW1lciA9XG4gICAgICAgICAgYWRkX2NvbnN1bWVyIHVwc3RyZWFtIH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICAgZG93bnN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0pXG4gICAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgPVxuICAgICAgICAgIGFkZF91cHN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0gKGZ1biAoKSAtPiB1cHN0cmVhbV9mbHVzaGVkIHVwc3RyZWFtKVxuICAgICAgfVxuICA7O1xuXG4gIGxldCB1bmxpbmtfdXBzdHJlYW0gKFQgdCkgPVxuICAgIEJhZy5yZW1vdmUgdC5kb3duc3RyZWFtLnVwc3RyZWFtX2ZsdXNoZWRzIHQudXBzdHJlYW1fZmx1c2hlZHNfYmFnX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBGbHVzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb25zdW1lciBvZiBDb25zdW1lci50XG4gICAgfCBXaGVuX3ZhbHVlX3Byb2Nlc3NlZFxuICAgIHwgV2hlbl92YWx1ZV9yZWFkXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IGZvbGRfZ2VuXG4gICAgICAocmVhZF9ub3cgOiA/Y29uc3VtZXI6Q29uc3VtZXIudCAtPiBfIFJlYWRlci50IC0+IF8pXG4gICAgICA/KGZsdXNoZWQgPSBGbHVzaGVkLldoZW5fdmFsdWVfcmVhZClcbiAgICAgIHRcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA9XG4gIGxldCBjb25zdW1lciA9XG4gICAgbWF0Y2ggZmx1c2hlZCB3aXRoXG4gICAgfCBXaGVuX3ZhbHVlX3JlYWQgLT4gTm9uZVxuICAgIHwgQ29uc3VtZXIgY29uc3VtZXIgLT4gU29tZSBjb25zdW1lclxuICAgIHwgV2hlbl92YWx1ZV9wcm9jZXNzZWQgLT5cbiAgICAgICgqIFRoZSBmYWN0IHRoYXQgXCJubyBjb25zdW1lclwiIGJlaGF2ZXMgZGlmZmVyZW50IGZyb20gXCJ0cml2aWFsIGNvbnN1bWVyXCIgaXMgd2VpcmQsXG4gICAgICAgICBidXQgdGhhdCdzIGhvdyB0aGUgY29uc3VtZXIgbWFjaGluZXJ5IHdvcmtzLiAqKVxuICAgICAgU29tZSAoYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZDooZnVuICgpIC0+IHJldHVybiBgT2spKVxuICBpblxuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIHQgP2NvbnN1bWVyO1xuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICgqIFdlIGRvIFtyZXR1cm4gKCkgPj4+XSB0byBlbnN1cmUgdGhhdCBbZl0gaXMgb25seSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICopXG4gICAgcmV0dXJuICgpXG4gICAgPj4+IGZ1biAoKSAtPlxuICAgIGxldCByZWMgbG9vcCBiID1cbiAgICAgIG1hdGNoIHJlYWRfbm93IHQgP2NvbnN1bWVyIHdpdGhcbiAgICAgIHwgYEVvZiAtPiBJdmFyLmZpbGwgZmluaXNoZWQgYlxuICAgICAgfCBgT2sgdiAtPiBmIGIgdiBjb250aW51ZVxuICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gdmFsdWVzX2F2YWlsYWJsZSB0ID4+PiBmdW4gXyAtPiBsb29wIGJcbiAgICBhbmQgY29udGludWUgYiA9XG4gICAgICBPcHRpb24uaXRlciBjb25zdW1lciB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtO1xuICAgICAgbG9vcCBiXG4gICAgaW5cbiAgICBsb29wIGluaXQpXG47O1xuXG5sZXQgZm9sZCcgP2ZsdXNoZWQgP21heF9xdWV1ZV9sZW5ndGggdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIHEgbG9vcCAtPlxuICAgIGYgYiBxID4+PiBsb29wKVxuOztcblxubGV0IGZvbGQgP2ZsdXNoZWQgdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIGEgbG9vcCAtPiBmIGIgYSA+Pj4gbG9vcClcbjs7XG5cbmxldCBmb2xkX3dpdGhvdXRfcHVzaGJhY2sgP2NvbnN1bWVyIHQgfmluaXQgfmYgPVxuICBmb2xkX2dlblxuICAgIHJlYWRfbm93XG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBiIGEgbG9vcCAtPiBsb29wIChmIGIgYSkpXG4gICAgP2ZsdXNoZWQ6XG4gICAgICAobWF0Y2ggY29uc3VtZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIGMgLT4gU29tZSAoQ29uc3VtZXIgYykpXG47O1xuXG5sZXQgd2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKSBmIGEgPVxuICBpZiBub3QgY29udGludWVfb25fZXJyb3JcbiAgdGhlbiBmIGFcbiAgZWxzZSAoXG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgIH5ydW46XG4gICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgKGZ1biAoKSAtPiBmIGEpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIChNb25pdG9yLmV4dHJhY3RfZXhuIGV4bikpXG47O1xuXG5sZXQgaXRlcicgP2NvbnRpbnVlX29uX2Vycm9yID9mbHVzaGVkID9tYXhfcXVldWVfbGVuZ3RoIHQgfmYgPVxuICBmb2xkJyA/bWF4X3F1ZXVlX2xlbmd0aCA/Zmx1c2hlZCB0IH5pbml0OigpIH5mOihmdW4gKCkgcSAtPlxuICAgIHdpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yID9jb250aW51ZV9vbl9lcnJvciBmIHEpXG47O1xuXG5sZXQgaXRlciA/Y29udGludWVfb25fZXJyb3IgP2ZsdXNoZWQgdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIGxvb3AgLT5cbiAgICB3aXRoX2Vycm9yX3RvX2N1cnJlbnRfbW9uaXRvciA/Y29udGludWVfb25fZXJyb3IgZiBhID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbjs7XG5cbigqIFtpdGVyX3dpdGhvdXRfcHVzaGJhY2tdIGlzIGEgY29tbW9uIGNhc2UsIHNvIHdlIGltcGxlbWVudCBpdCBpbiBhbiBvcHRpbWl6ZWQgbWFubmVyLFxuICAgcmF0aGVyIHRoYW4gdmlhIFtpdGVyXS4gIFRoZSBpbXBsZW1lbnRhdGlvbiByZWFkcyBvbmx5IG9uZSBlbGVtZW50IGF0IGEgdGltZSwgc28gdGhhdFxuICAgaWYgW2ZdIGNsb3NlcyBbdF0gb3IgcmFpc2VzLCBubyBtb3JlIGVsZW1lbnRzIHdpbGwgYmUgcmVhZC4gKilcbmxldCBpdGVyX3dpdGhvdXRfcHVzaGJhY2tcbiAgICAgID9jb25zdW1lclxuICAgICAgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKVxuICAgICAgP21heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgICAgIHRcbiAgICAgIH5mXG4gID1cbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXI7XG4gIGxldCBtYXhfaXRlcmF0aW9uc19wZXJfam9iID1cbiAgICBtYXRjaCBtYXhfaXRlcmF0aW9uc19wZXJfam9iIHdpdGhcbiAgICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICAgIHwgU29tZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iIC0+XG4gICAgICBpZiBtYXhfaXRlcmF0aW9uc19wZXJfam9iIDw9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgXCJpdGVyX3dpdGhvdXRfcHVzaGJhY2sgZ290IG5vbi1wb3NpdGl2ZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iXCJcbiAgICAgICAgICAgICAgKG1heF9pdGVyYXRpb25zX3Blcl9qb2IgOiBpbnQpXTtcbiAgICAgIG1heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgaW5cbiAgbGV0IGYgPVxuICAgIGlmIG5vdCBjb250aW51ZV9vbl9lcnJvclxuICAgIHRoZW4gZlxuICAgIGVsc2VcbiAgICAgIGZ1biBhIC0+XG4gICAgICAgIHRyeSBmIGEgd2l0aFxuICAgICAgICB8IGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4blxuICBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICgqIFdlIGRvIFtyZXR1cm4gKCkgPj4+XSB0byBlbnN1cmUgdGhhdCBbZl0gaXMgb25seSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICopXG4gICAgcmV0dXJuICgpXG4gICAgPj4+IGZ1biAoKSAtPlxuICAgIGxldCByZWMgc3RhcnQgKCkgPSBsb29wIH5yZW1haW5pbmc6bWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlxuICAgIGFuZCBsb29wIH5yZW1haW5pbmcgPVxuICAgICAgaWYgcmVtYWluaW5nID0gMFxuICAgICAgdGhlbiByZXR1cm4gKCkgPj4+IGZ1biAoKSAtPiBzdGFydCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHJlYWRfbm93IHQgP2NvbnN1bWVyIHdpdGhcbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbCBmaW5pc2hlZCAoKVxuICAgICAgICB8IGBPayBhIC0+XG4gICAgICAgICAgZiBhO1xuICAgICAgICAgIGxvb3AgfnJlbWFpbmluZzoocmVtYWluaW5nIC0gMSlcbiAgICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gdmFsdWVzX2F2YWlsYWJsZSB0ID4+PiBmdW4gXyAtPiBzdGFydCAoKSlcbiAgICBpblxuICAgIHN0YXJ0ICgpKVxuOztcblxubGV0IGRyYWluIHQgPSBpdGVyJyB0IH5mOihmdW4gXyAtPiByZXR1cm4gKCkpXG5sZXQgZHJhaW5fYW5kX2NvdW50IHQgPSBmb2xkJyB0IH5pbml0OjAgfmY6KGZ1biBzdW0gcSAtPiByZXR1cm4gKHN1bSArIFF1ZXVlLmxlbmd0aCBxKSlcblxubGV0IHJlYWRfYWxsIGlucHV0ID1cbiAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQlbWFwICgpID1cbiAgICBpdGVyJyBpbnB1dCB+ZjooZnVuIHEgLT5cbiAgICAgIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzpxIH5kc3Q6cmVzdWx0ICgpO1xuICAgICAgcmV0dXJuICgpKVxuICBpblxuICByZXN1bHRcbjs7XG5cbmxldCB0b19saXN0IHIgPSByZWFkX2FsbCByID4+fCBRdWV1ZS50b19saXN0XG5cbmxldCB0b19zdHJlYW1fZGVwcmVjYXRlZCB0ID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBpdGVyX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KVxuICAgID4+PiBmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbClcbjs7XG5cbigqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBbb2Zfc3RyZWFtX2RlcHJlY2F0ZWRdIGRvZXMgYXMgbXVjaCBiYXRjaGluZyBhcyBwb3NzaWJsZS4gIEl0XG4gICBncmFicyBhcyBtYW55IGl0ZW1zIGFzIGFyZSBhdmFpbGFibGUgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gIE9uY2UgaXQgaGFzIGdyYWJiZWRcbiAgIGV2ZXJ5dGhpbmcsIGl0IHdyaXRlcyBpdCB0byB0aGUgcGlwZSBhbmQgdGhlbiBibG9ja3Mgd2FpdGluZyBmb3IgdGhlIG5leHQgZWxlbWVudCBmcm9tXG4gICB0aGUgc3RyZWFtLlxuXG4gICBUaGVyZSdzIG5vIHBvc3NpYmlsaXR5IHRoYXQgd2UnbGwgc3RhcnZlIHRoZSBwaXBlIHJlYWRpbmcgYW4gZW5kbGVzcyBzdHJlYW0sIGp1c3RcbiAgIGFjY3VtdWxhdGluZyB0aGUgZWxlbWVudHMgaW50byBvdXIgcHJpdmF0ZSBxdWV1ZSBmb3JldmVyIHdpdGhvdXQgZXZlciB3cml0aW5nIHRoZW1cbiAgIGRvd25zdHJlYW0gdG8gdGhlIHBpcGUuICBXaHk/IGJlY2F1c2Ugd2hpbGUgd2UncmUgcnVubmluZywgdGhlIHN0cmVhbS1wcm9kdWNlciAqaXNuJ3QqXG4gICBydW5uaW5nIC0tIHRoZXJlIGFyZSBubyBBc3luYyBibG9jayBwb2ludHMgaW4gdGhlIHF1ZXVlLWFjY3VtdWxhdG9yIGxvb3AuICBTbyB0aGVcbiAgIHF1ZXVlLWFjY3VtdWxhdG9yIGxvb3Agd2lsbCBldmVudHVhbGx5IGNhdGNoIHVwIHRvIHRoZSBjdXJyZW50IHN0cmVhbSB0YWlsLCBhdCB3aGljaFxuICAgcG9pbnQgd2UnbGwgZG8gdGhlIHBpcGUtd3JpdGUgYW5kIHRoZW4gYmxvY2sgb24gdGhlIHN0cmVhbS4uLiB0aHVzIGdpdmluZyB0aGVcbiAgIHN0cmVhbS1wcm9kdWNlciBhIGNoYW5jZSB0byBtYWtlIG1vcmUgZWxlbWVudHMuXG5cbiAgIE9uZSBjYW4ndCBpbXBsZW1lbnQgW29mX3N0cmVhbV0gdXNpbmcgW1N0cmVhbS5pdGVyXSBvciBbU3RyZWFtLml0ZXInXSBiZWNhdXNlIHlvdVxuICAgbmVlZCB0byBiZSBhYmxlIHRvIHN0b3AgZWFybHkgd2hlbiB0aGUgY29uc3VtZXIgY2xvc2VzIHRoZSBwaXBlLiAgQWxzbywgdXNpbmcgZWl0aGVyXG4gICBvZiB0aG9zZSB3b3VsZCBlbnRhaWwgc2lnbmlmaWNhbnRseSBtb3JlIGRlZmVycmVkIG92ZXJoZWFkLCB3aGVyZWFzIHRoZSBiZWxvd1xuICAgaW1wbGVtZW50YXRpb24gdXNlcyBhIGRlZmVycmVkIG9ubHkgd2hlbiBpdCBuZWVkcyB0byB3YWl0IGZvciBkYXRhIGZyb20gdGhlIHN0cmVhbS4gKilcbmxldCBvZl9zdHJlYW1fZGVwcmVjYXRlZCBzID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgKCkgaW5cbiAgbGV0IHEgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHRyYW5zZmVyICgpID1cbiAgICBpZiBub3QgKFF1ZXVlLmlzX2VtcHR5IHEpXG4gICAgdGhlblxuICAgICAgKCogQ2FuIG5vdCBwdXNoYmFjayBvbiB0aGUgc3RyZWFtLCBzbyBpZ25vcmUgdGhlIHB1c2hiYWNrIG9uIHRoZSBwaXBlLiAqKVxuICAgICAgZG9uJ3Rfd2FpdF9mb3IgKHdyaXRlJyB3IHEpXG4gIGluXG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBhc3NlcnQgKG5vdCAoaXNfY2xvc2VkIHcpKTtcbiAgICBsZXQgbmV4dF9kZWZlcnJlZCA9IFN0cmVhbS5uZXh0IHMgaW5cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIG5leHRfZGVmZXJyZWQgd2l0aFxuICAgIHwgU29tZSBuZXh0IC0+IGxvb3BfbmV4dCBuZXh0XG4gICAgfCBOb25lIC0+XG4gICAgICB0cmFuc2ZlciAoKTtcbiAgICAgIHVwb24gbmV4dF9kZWZlcnJlZCBjaGVja19jbG9zZWRfbG9vcF9uZXh0XG4gIGFuZCBjaGVja19jbG9zZWRfbG9vcF9uZXh0IG5leHQgPSBpZiBub3QgKGlzX2Nsb3NlZCB3KSB0aGVuIGxvb3BfbmV4dCBuZXh0XG4gIGFuZCBsb29wX25leHQgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICB0cmFuc2ZlciAoKTtcbiAgICAgIGNsb3NlIHdcbiAgICB8IENvbnMgKHgsIHMpIC0+XG4gICAgICBRdWV1ZS5lbnF1ZXVlIHEgeDtcbiAgICAgIGxvb3Agc1xuICBpblxuICBsb29wIHM7XG4gIHJcbjs7XG5cbmxldCB0cmFuc2Zlcl9nZW5cbiAgICAgIChyZWFkX25vdyA6ID9jb25zdW1lcjpDb25zdW1lci50IC0+IF8gUmVhZGVyLnQgLT4gXylcbiAgICAgIHdyaXRlXG4gICAgICBpbnB1dFxuICAgICAgb3V0cHV0XG4gICAgICB+ZlxuICA9XG4gIGlmICFjaGVja19pbnZhcmlhbnRcbiAgdGhlbiAoXG4gICAgaW52YXJpYW50IGlucHV0O1xuICAgIGludmFyaWFudCBvdXRwdXQpO1xuICBsZXQgbGluayA9IExpbmsuY3JlYXRlIH51cHN0cmVhbTppbnB1dCB+ZG93bnN0cmVhbTpvdXRwdXQgaW5cbiAgbGV0IGNvbnN1bWVyID0gTGluay5jb25zdW1lciBsaW5rIGluXG4gICgqIFdoZW4gd2UncmUgZG9uZSB3aXRoIFtpbnB1dF0sIHdlIHVubGluayB0byByZW1vdmUgcG9pbnRlcnMgZnJvbVxuICAgICBbb3V0cHV0XSB0byBbaW5wdXRdLCB3aGljaCB3b3VsZCBjYXVzZSBhIHNwYWNlIGxlYWsgaWYgd2UgaGFkIHNpbmdsZSBsb25nLWxpdmVkXG4gICAgIG91dHB1dCBpbnRvIHdoaWNoIHdlIHRyYW5zZmVyIGxvdHMgb2Ygc2hvcnQtbGl2ZWQgaW5wdXRzLiAqKVxuICBsZXQgdW5saW5rICgpID0gTGluay51bmxpbmtfdXBzdHJlYW0gbGluayBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAoKiBXZSBkbyBbcmV0dXJuICgpID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqKVxuICAgIHJldHVybiAoKVxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBsZXQgb3V0cHV0X2Nsb3NlZCAoKSA9XG4gICAgICBjbG9zZV9yZWFkIGlucHV0O1xuICAgICAgdW5saW5rICgpO1xuICAgICAgSXZhci5maWxsIHJlc3VsdCAoKVxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgIGlmIGlzX2Nsb3NlZCBvdXRwdXRcbiAgICAgIHRoZW4gb3V0cHV0X2Nsb3NlZCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHJlYWRfbm93IGlucHV0IH5jb25zdW1lciB3aXRoXG4gICAgICAgIHwgYEVvZiAtPlxuICAgICAgICAgIHVubGluayAoKTtcbiAgICAgICAgICBJdmFyLmZpbGwgcmVzdWx0ICgpXG4gICAgICAgIHwgYE9rIHggLT4gZiB4IGNvbnRpbnVlXG4gICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICAgICAgY2hvb3NlXG4gICAgICAgICAgICBbIGNob2ljZSAodmFsdWVzX2F2YWlsYWJsZSBpbnB1dCkgaWdub3JlOyBjaG9pY2UgKGNsb3NlZCBvdXRwdXQpIGlnbm9yZSBdXG4gICAgICAgICAgPj4+IGZ1biAoKSAtPiBsb29wICgpKVxuICAgIGFuZCBjb250aW51ZSB5ID1cbiAgICAgIGlmIGlzX2Nsb3NlZCBvdXRwdXRcbiAgICAgIHRoZW4gb3V0cHV0X2Nsb3NlZCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwdXNoYmFjayA9IHdyaXRlIG91dHB1dCB5IGluXG4gICAgICAgIENvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW0gY29uc3VtZXI7XG4gICAgICAgIHB1c2hiYWNrID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICBpblxuICAgIGxvb3AgKCkpXG47O1xuXG5sZXQgdHJhbnNmZXInID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IG91dHB1dCB+ZiA9XG4gIHRyYW5zZmVyX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgb3V0cHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCB0cmFuc2ZlciBpbnB1dCBvdXRwdXQgfmYgPVxuICB0cmFuc2Zlcl9nZW4gcmVhZF9ub3cgd3JpdGUgaW5wdXQgb3V0cHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG47O1xuXG5sZXQgdHJhbnNmZXJfaWQgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgb3V0cHV0ID1cbiAgdHJhbnNmZXJfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCBvdXRwdXQgfmY6KGZ1biBxIGsgLT4gayBxKVxuOztcblxubGV0IG1hcF9nZW4gcmVhZCB3cml0ZSBpbnB1dCB+ZiA9XG4gIGxldCBpbmZvID0gT3B0aW9uLm1hcCBpbnB1dC5pbmZvIH5mOihmdW4gaW5mbyAtPiBbJXNleHAgTWFwcGVkIChpbmZvIDogU2V4cC50KV0pIGluXG4gIGxldCByZXN1bHQsIG91dHB1dCA9IGNyZWF0ZSA/aW5mbyAoKSBpblxuICB1cG9uICh0cmFuc2Zlcl9nZW4gcmVhZCB3cml0ZSBpbnB1dCBvdXRwdXQgfmYpIChmdW4gKCkgLT4gY2xvc2Ugb3V0cHV0KTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZiA9XG4gIG1hcF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBfZ2VuIHJlYWRfbm93IHdyaXRlIGlucHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG5cbmxldCBjb25jYXRfbWFwX2xpc3QgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPlxuICAgIGsgKFF1ZXVlLmNvbmNhdF9tYXAgcSB+ZikpXG47O1xuXG5sZXQgZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4gcSAtPiBEZWZlcnJlZC5RdWV1ZS5maWx0ZXJfbWFwIHEgfmYpXG47O1xuXG5sZXQgZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZiA9XG4gIG1hcF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IH5mOihmdW4gcSBrIC0+XG4gICAgayAoUXVldWUuZmlsdGVyX21hcCBxIH5mOihmdW4geCAtPiBpZiBpc19yZWFkX2Nsb3NlZCBpbnB1dCB0aGVuIE5vbmUgZWxzZSBmIHgpKSlcbjs7XG5cbmxldCBmb2xkaW5nX2ZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjY3VtID0gcmVmIGluaXQgaW5cbiAgZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmY6KGZ1biB4IC0+XG4gICAgbGV0JW1hcCBhLCB4ID0gZiAhYWNjdW0geCBpblxuICAgIGFjY3VtIDo9IGE7XG4gICAgeClcbjs7XG5cbmxldCBmb2xkaW5nX2ZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmYgPVxuICBsZXQgYWNjdW0gPSByZWYgaW5pdCBpblxuICBmaWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4geCAtPlxuICAgIGxldCBhLCB4ID0gZiAhYWNjdW0geCBpblxuICAgIGFjY3VtIDo9IGE7XG4gICAgeClcbjs7XG5cbmxldCBmb2xkaW5nX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZiA9XG4gIGZvbGRpbmdfZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZjooZnVuIGFjY3VtIGEgLT5cbiAgICBsZXQgYWNjdW0sIGIgPSBmIGFjY3VtIGEgaW5cbiAgICBhY2N1bSwgU29tZSBiKVxuOztcblxubGV0IGZpbHRlciBpbnB1dCB+ZiA9IGZpbHRlcl9tYXAgaW5wdXQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgdCA9IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQ6MCB+aW5mbzpOb25lIH5pbml0aWFsX2J1ZmZlcjooUXVldWUub2ZfbGlzdCBsKSBpblxuICBJdmFyLmZpbGwgdC5jbG9zZWQgKCk7XG4gIHVwZGF0ZV9wdXNoYmFjayB0O1xuICB0XG47O1xuXG5sZXQgZW1wdHkgKCkgPSBvZl9saXN0IFtdXG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCByZWFkZXIsIHdyaXRlciA9IGNyZWF0ZSAoKSBpblxuICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHdyaXRlciB4O1xuICBjbG9zZSB3cml0ZXI7XG4gIHJlYWRlclxuOztcblxubGV0IHVuZm9sZCB+aW5pdDpzIH5mID1cbiAgKCogVG8gZ2V0IHNvbWUgYmF0Y2hpbmcsIHdlIHJ1biB0aGUgY29udGludWF0aW9uIGltbWVkaWF0ZWx5IGlmIHRoZSBkZWZlcnJlZCBpc1xuICAgICBkZXRlcm1pbmVkLiAgSG93ZXZlciwgd2UgYWx3YXlzIGNoZWNrIGZvciBwdXNoYmFjay4gIEJlY2F1c2Ugc2l6ZSBidWRnZXQgY2FuJ3QgYmVcbiAgICAgaW5maW5pdGUsIHRoZSBiZWxvdyBsb29wIGlzIGd1YXJhbnRlZWQgdG8gZXZlbnR1YWxseSB5aWVsZCB0byB0aGUgc2NoZWR1bGVyLiAqKVxuICBsZXQgKCA+Pj1+ICkgZCBmID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgIHwgTm9uZSAtPiBkID4+PSBmXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIGluXG4gIGNyZWF0ZV9yZWFkZXIgfmNsb3NlX29uX2V4Y2VwdGlvbjpmYWxzZSAoZnVuIHdyaXRlciAtPlxuICAgIGxldCByZWMgbG9vcCBzID1cbiAgICAgIGYgc1xuICAgICAgPj49fiBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IHJldHVybiAoKVxuICAgICAgfCBTb21lIChhLCBzKSAtPlxuICAgICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHRoZW4gcmV0dXJuICgpIGVsc2Ugd3JpdGUgd3JpdGVyIGEgPj49fiBmdW4gKCkgLT4gbG9vcCBzXG4gICAgaW5cbiAgICBsb29wIHMpXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICBjcmVhdGVfcmVhZGVyIH5jbG9zZV9vbl9leGNlcHRpb246ZmFsc2UgKGZ1biB3cml0ZXIgLT5cbiAgICBsZXQgcmVjIGVucXVldWVfbiBzZXF1ZW5jZSBpID1cbiAgICAgIGlmIGkgPD0gMFxuICAgICAgdGhlbiBzZXF1ZW5jZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgc2VxdWVuY2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc2VxdWVuY2VcbiAgICAgICAgfCBTb21lIChhLCBzZXF1ZW5jZSkgLT5cbiAgICAgICAgICBRdWV1ZS5lbnF1ZXVlIHdyaXRlci5idWZmZXIgYTtcbiAgICAgICAgICBlbnF1ZXVlX24gc2VxdWVuY2UgKGkgLSAxKSlcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBzZXF1ZW5jZSA9XG4gICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHx8IFNlcXVlbmNlLmlzX2VtcHR5IHNlcXVlbmNlXG4gICAgICB0aGVuIHJldHVybiAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHN0YXJ0X3dyaXRlIHdyaXRlcjtcbiAgICAgICAgbGV0IHNlcXVlbmNlID0gZW5xdWV1ZV9uIHNlcXVlbmNlICgxICsgd3JpdGVyLnNpemVfYnVkZ2V0IC0gbGVuZ3RoIHdyaXRlcikgaW5cbiAgICAgICAgZmluaXNoX3dyaXRlIHdyaXRlcjtcbiAgICAgICAgbGV0JWJpbmQgKCkgPSBwdXNoYmFjayB3cml0ZXIgaW5cbiAgICAgICAgbG9vcCBzZXF1ZW5jZSlcbiAgICBpblxuICAgIGxvb3Agc2VxdWVuY2UpXG47O1xuXG50eXBlICdhIHRvX3NlcXVlbmNlX2VsdCA9XG4gIHwgVmFsdWUgb2YgJ2FcbiAgfCBXYWl0X2ZvciA6IF8gRGVmZXJyZWQudCAtPiBfIHRvX3NlcXVlbmNlX2VsdFxuXG5sZXQgdG9fc2VxdWVuY2UgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDooKSB+ZjooZnVuICgpIC0+XG4gICAgbWF0Y2ggcmVhZF9ub3cgdCB3aXRoXG4gICAgfCBgRW9mIC0+IE5vbmVcbiAgICB8IGBPayBhIC0+IFNvbWUgKFZhbHVlIGEsICgpKVxuICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IFNvbWUgKFdhaXRfZm9yICh2YWx1ZXNfYXZhaWxhYmxlIHQpLCAoKSkpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZV9waXBlIGlucHV0cyA9XG4gIGxldCBvdXRwdXQsIG91dHB1dF93cml0ZXIgPSBjcmVhdGUgfmluZm86WyVzZXhwIFwiUGlwZS5pbnRlcmxlYXZlXCJdICgpIGluXG4gICgqIFdlIGtlZXAgYSByZWZlcmVuY2UgY291bnQgb2YgYWxsIHRoZSBwaXBlcyB0aGF0IFtpbnRlcmxlYXZlX3BpcGVdIGlzIG1hbmFnaW5nO1xuICAgICBbaW5wdXRzXSBjb3VudHMgYXMgb25lLiAgV2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IGRyb3BzIHRvIHplcm8sIHdlIGtub3cgdGhhdCBhbGxcbiAgICAgcGlwZXMgYXJlIGNsb3NlZCBhbmQgd2UgY2FuIGNsb3NlIFtvdXRwdXRfd3JpdGVyXS4gKilcbiAgbGV0IG51bV9waXBlc19yZW1haW5pbmcgPSByZWYgMSBpblxuICBsZXQgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpID1cbiAgICBkZWNyIG51bV9waXBlc19yZW1haW5pbmc7XG4gICAgaWYgIW51bV9waXBlc19yZW1haW5pbmcgPSAwIHRoZW4gY2xvc2Ugb3V0cHV0X3dyaXRlclxuICBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChsZXQlbWFwICgpID1cbiAgICAgICBpdGVyX3dpdGhvdXRfcHVzaGJhY2sgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT5cbiAgICAgICAgIGluY3IgbnVtX3BpcGVzX3JlbWFpbmluZztcbiAgICAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgICAgIChsZXQlbWFwICgpID0gdHJhbnNmZXJfaWQgaW5wdXQgb3V0cHV0X3dyaXRlciBpblxuICAgICAgICAgICAgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpKSlcbiAgICAgaW5cbiAgICAgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpKTtcbiAgKCogZm9yIFtpbnB1dHNdICopXG4gIG91dHB1dFxuOztcblxubGV0IGludGVybGVhdmUgaW5wdXRzID1cbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIExpc3QuaXRlciBpbnB1dHMgfmY6aW52YXJpYW50O1xuICBpbnRlcmxlYXZlX3BpcGUgKG9mX2xpc3QgaW5wdXRzKVxuOztcblxubGV0IG1lcmdlIGlucHV0cyB+Y29tcGFyZSA9XG4gIG1hdGNoIGlucHV0cyB3aXRoXG4gIHwgW10gLT4gZW1wdHkgKClcbiAgfCBbIGlucHV0IF0gLT4gaW5wdXRcbiAgfCBpbnB1dHMgLT5cbiAgICBsZXQgbW9kdWxlIEhlYXAgPSBQYWlyaW5nX2hlYXAgaW5cbiAgICBsZXQgciwgdyA9IGNyZWF0ZSAoKSBpblxuICAgIHVwb24gKGNsb3NlZCB3KSAoZnVuICgpIC0+IExpc3QuaXRlciBpbnB1dHMgfmY6Y2xvc2VfcmVhZCk7XG4gICAgbGV0IGhlYXAgPSBIZWFwLmNyZWF0ZSB+Y21wOihmdW4gKGExLCBfKSAoYTIsIF8pIC0+IGNvbXBhcmUgYTEgYTIpICgpIGluXG4gICAgbGV0IGhhbmRsZV9yZWFkIGlucHV0IGVvZl9vcl9vayA9XG4gICAgICBtYXRjaCBlb2Zfb3Jfb2sgd2l0aFxuICAgICAgfCBgRW9mIC0+ICgpXG4gICAgICB8IGBPayB2IC0+IEhlYXAuYWRkIGhlYXAgKHYsIGlucHV0KVxuICAgIGluXG4gICAgbGV0IHJlYyBwb3BfaGVhcF9hbmRfbG9vcCAoKSA9XG4gICAgICAoKiBBdCB0aGlzIHBvaW50LCBhbGwgaW5wdXRzIG5vdCBhdCBFb2Ygb2NjdXIgaW4gW2hlYXBdIGV4YWN0bHkgb25jZSwgc28gd2Uga25vd1xuICAgICAgICAgd2hhdCB0aGUgbmV4dCBvdXRwdXQgZWxlbWVudCBpcy4gIFtwb3BfaGVhcF9hbmRfbG9vcF0gcmVwZWF0ZWRseSB0YWtlcyBlbGVtZW50c1xuICAgICAgICAgZnJvbSB0aGUgaW5wdXRzIGFzIGxvbmcgYXMgaXQgaGFzIG9uZSBmcm9tIGVhY2ggaW5wdXQuICBUaGlzIGlzIGRvbmVcbiAgICAgICAgIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgYSBkZWZlcnJlZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBvdXRwdXQgLS1cbiAgICAgICAgIHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXNoYmFjayBzaW5jZSB0aGF0IGlzIG9ubHkgbW92aW5nIGVsZW1lbnRzIGZyb20gb25lIHBpcGUgdG9cbiAgICAgICAgIGFub3RoZXIuICBBcyBzb29uIGFzIFtwb3BfaGVhcF9hbmRfbG9vcF0gY2FuJ3QgZ2V0IGFuIGVsZW1lbnQgZnJvbSBzb21lIGlucHV0LCBpdFxuICAgICAgICAgd2FpdHMgb24gcHVzaGJhY2sgZnJvbSB0aGUgb3V0cHV0LCBzaW5jZSBpdCBoYXMgdG8gd2FpdCBvbiB0aGUgaW5wdXQgYW55d2F5LlxuICAgICAgICAgVGhpcyBhbHNvIHByZXZlbnRzIFttZXJnZV0gZnJvbSBjb25zdW1pbmcgaW5wdXRzIGF0IGEgcmF0ZSBmYXN0ZXIgdGhhbiBpdHMgb3V0cHV0XG4gICAgICAgICBpcyBjb25zdW1lZC4gKilcbiAgICAgIG1hdGNoIEhlYXAucG9wIGhlYXAgd2l0aFxuICAgICAgfCBOb25lIC0+IGNsb3NlIHdcbiAgICAgIHwgU29tZSAodiwgaW5wdXQpIC0+XG4gICAgICAgIGlmIG5vdCAoaXNfY2xvc2VkIHcpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdyB2O1xuICAgICAgICAgIGlmIEhlYXAubGVuZ3RoIGhlYXAgPSAwXG4gICAgICAgICAgdGhlbiB1cG9uICh0cmFuc2Zlcl9pZCBpbnB1dCB3KSAoZnVuICgpIC0+IGNsb3NlIHcpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBtYXRjaCByZWFkX25vdyBpbnB1dCB3aXRoXG4gICAgICAgICAgICB8IChgRW9mIHwgYE9rIF8pIGFzIHggLT5cbiAgICAgICAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeDtcbiAgICAgICAgICAgICAgcG9wX2hlYXBfYW5kX2xvb3AgKClcbiAgICAgICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICAgICAgICAgIHB1c2hiYWNrIHdcbiAgICAgICAgICAgICAgPj4+IGZ1biAoKSAtPlxuICAgICAgICAgICAgICByZWFkIGlucHV0XG4gICAgICAgICAgICAgID4+PiBmdW4geCAtPlxuICAgICAgICAgICAgICBoYW5kbGVfcmVhZCBpbnB1dCB4O1xuICAgICAgICAgICAgICBwb3BfaGVhcF9hbmRfbG9vcCAoKSkpXG4gICAgaW5cbiAgICBsZXQgaW5pdGlhbF9wdXNoID1cbiAgICAgIERlZmVycmVkLkxpc3QuaXRlciBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPlxuICAgICAgICBsZXQlbWFwIHggPSByZWFkIGlucHV0IGluXG4gICAgICAgIGhhbmRsZV9yZWFkIGlucHV0IHgpXG4gICAgaW5cbiAgICB1cG9uIGluaXRpYWxfcHVzaCBwb3BfaGVhcF9hbmRfbG9vcDtcbiAgICByXG47O1xuXG5sZXQgY29uY2F0X3BpcGUgaW5wdXRzID1cbiAgbGV0IHIgPVxuICAgIGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiAoZnVuIHcgLT5cbiAgICAgIGxldCBsaW5rID0gTGluay5jcmVhdGUgfnVwc3RyZWFtOmlucHV0cyB+ZG93bnN0cmVhbTp3IGluXG4gICAgICBsZXQgY29uc3VtZXIgPSBMaW5rLmNvbnN1bWVyIGxpbmsgaW5cbiAgICAgIGl0ZXIgfmZsdXNoZWQ6KENvbnN1bWVyIGNvbnN1bWVyKSBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPiB0cmFuc2Zlcl9pZCBpbnB1dCB3KSlcbiAgaW5cbiAgdXBvbiAoY2xvc2VkIHIpIChmdW4gKCkgLT4gY2xvc2UgaW5wdXRzKTtcbiAgclxuOztcblxubGV0IGNvbmNhdCBpbnB1dHMgPVxuICBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gKGZ1biB3IC0+XG4gICAgRGVmZXJyZWQuTGlzdC5pdGVyIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+IHRyYW5zZmVyX2lkIGlucHV0IHcpKVxuOztcblxubGV0IGZvcmsgdCB+cHVzaGJhY2tfdXNlcyA9XG4gIGxldCByZWFkZXIwLCB3cml0ZXIwID0gY3JlYXRlICgpIGluXG4gIGxldCByZWFkZXIxLCB3cml0ZXIxID0gY3JlYXRlICgpIGluXG4gIGxldCBzb21lX3JlYWRlcl93YXNfY2xvc2VkID0gcmVmIGZhbHNlIGluXG4gIGxldCBjb25zdW1lciA9XG4gICAgYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZDooZnVuICgpIC0+XG4gICAgICBsZXQgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCA9ICFzb21lX3JlYWRlcl93YXNfY2xvc2VkIGluXG4gICAgICBtYXRjaCVtYXBcbiAgICAgICAgRmx1c2hlZF9yZXN1bHQuY29tYmluZVxuICAgICAgICAgIFsgZG93bnN0cmVhbV9mbHVzaGVkIHdyaXRlcjA7IGRvd25zdHJlYW1fZmx1c2hlZCB3cml0ZXIxIF1cbiAgICAgIHdpdGhcbiAgICAgIHwgYFJlYWRlcl9jbG9zZWQgLT4gYFJlYWRlcl9jbG9zZWRcbiAgICAgIHwgYE9rIC0+XG4gICAgICAgICgqIEluIHRoaXMgY2FzZSwgdGhlcmUgY291bGQgaGF2ZSBiZWVuIG5vIHBlbmRpbmcgaXRlbXMgaW4gW3dyaXRlcjBdIG5vciBpblxuICAgICAgICAgICBbd3JpdGVyMV0sIGluIHdoaWNoIGNhc2Ugd2UgY291bGQgaGF2ZSBoYWQgYSBjbG9zZWQgcGlwZSB0aGF0IG1pc3NlZCBzb21lXG4gICAgICAgICAgIHdyaXRlcywgYnV0IFtGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXSB3b3VsZCBzdGlsbCBoYXZlIHJldHVybmVkIFtgT2tdICopXG4gICAgICAgIGlmIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgdGhlbiBgUmVhZGVyX2Nsb3NlZCBlbHNlIGBPaylcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0IHN0aWxsX29wZW4gPSBbIHdyaXRlcjA7IHdyaXRlcjEgXSBpblxuICAgICBsZXQgZmlsdGVyX29wZW4gc3RpbGxfb3BlbiA9XG4gICAgICAgKCogT25seSBjYWxsIFtmaWx0ZXJdIGFuZCByZWFsbG9jYXRlIGxpc3QgaWYgc29tZXRoaW5nIHdpbGwgZ2V0IGZpbHRlcmVkICopXG4gICAgICAgaWYgbm90IChMaXN0LmV4aXN0cyBzdGlsbF9vcGVuIH5mOmlzX2Nsb3NlZClcbiAgICAgICB0aGVuIHN0aWxsX29wZW5cbiAgICAgICBlbHNlIChcbiAgICAgICAgIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgOj0gdHJ1ZTtcbiAgICAgICAgIGxldCBzdGlsbF9vcGVuID0gTGlzdC5maWx0ZXIgc3RpbGxfb3BlbiB+ZjooZnVuIHcgLT4gbm90IChpc19jbG9zZWQgdykpIGluXG4gICAgICAgICBpZiBMaXN0LmlzX2VtcHR5IHN0aWxsX29wZW4gdGhlbiBjbG9zZSB0O1xuICAgICAgICAgc3RpbGxfb3BlbilcbiAgICAgaW5cbiAgICAgbGV0JWJpbmQgc3RpbGxfb3BlbiA9XG4gICAgICAgZm9sZCcgdCB+Zmx1c2hlZDooQ29uc3VtZXIgY29uc3VtZXIpIH5pbml0OnN0aWxsX29wZW4gfmY6KGZ1biBzdGlsbF9vcGVuIHF1ZXVlIC0+XG4gICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgIGlmIExpc3QuaXNfZW1wdHkgc3RpbGxfb3BlblxuICAgICAgICAgdGhlbiByZXR1cm4gW11cbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBsZXQlbWFwICgpID1cbiAgICAgICAgICAgICBtYXRjaCBwdXNoYmFja191c2VzIHdpdGhcbiAgICAgICAgICAgICB8IGBGYXN0X2NvbnN1bWVyX29ubHkgLT4gRGVmZXJyZWQuYW55IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICAgIHwgYEJvdGhfY29uc3VtZXJzIC0+IERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgICAgTGlzdC5pdGVyIHN0aWxsX29wZW4gfmY6KGZ1biB3IC0+IGNvcHlfaW5fd2l0aG91dF9wdXNoYmFjayB3IH5mcm9tOnF1ZXVlKTtcbiAgICAgICAgICAgc3RpbGxfb3BlbikpXG4gICAgIGluXG4gICAgIExpc3QuaXRlciBzdGlsbF9vcGVuIH5mOmNsb3NlO1xuICAgICByZXR1cm4gKCkpO1xuICByZWFkZXIwLCByZWFkZXIxXG47O1xuXG5sZXQgc2V0X2luZm8gdCBpbmZvID0gc2V0X2luZm8gdCAoU29tZSBpbmZvKVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyBjdXJyZW50X3ZhbHVlIDogJ2EgTW9wdGlvbi50XG4gIDsgdGFrZW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gIDsgbXV0YWJsZSB2YWx1ZV9hdmFpbGFibGUgOiB1bml0IEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCB2YWx1ZV9hdmFpbGFibGUgdCA9IEl2YXIucmVhZCB0LnZhbHVlX2F2YWlsYWJsZVxubGV0IGlzX2VtcHR5IHQgPSBNb3B0aW9uLmlzX25vbmUgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgXyAodCA6IF8gdCkgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jdXJyZW50X3ZhbHVlOihjaGVjayAoTW9wdGlvbi5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfnRha2VuOihjaGVjayAoQnZhci5pbnZhcmlhbnQgVW5pdC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgIH52YWx1ZV9hdmFpbGFibGU6XG4gICAgICAgIChjaGVjayAoZnVuIHZhbHVlX2F2YWlsYWJsZSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBib29sXVxuICAgICAgICAgICAgIChJdmFyLmlzX2Z1bGwgdmFsdWVfYXZhaWxhYmxlKVxuICAgICAgICAgICAgIH5leHBlY3Q6KE1vcHRpb24uaXNfc29tZSB0LmN1cnJlbnRfdmFsdWUpKSkpXG47O1xuXG5sZXQgcGVlayB0ID0gTW9wdGlvbi5nZXQgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBwZWVrX2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci5wZWVrX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBbJXNleHAgKHBlZWsgdCA6IGEgb3B0aW9uKV1cblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZF93cml0ZSkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbm1vZHVsZSBSZWFkX29ubHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbmxldCByZWFkX29ubHkgKHQgOiAoJ2EsIFs+IHJlYWQgXSkgdCkgPSAodCA6PiAoJ2EsIHJlYWQpIHQpXG5sZXQgd3JpdGVfb25seSAodCA6ICgnYSwgWz4gd3JpdGUgXSkgdCkgPSAodCA6PiAoJ2EsIHdyaXRlKSB0KVxuXG5sZXQgY3JlYXRlICgpID1cbiAgeyBjdXJyZW50X3ZhbHVlID0gTW9wdGlvbi5jcmVhdGUgKClcbiAgOyB0YWtlbiA9IEJ2YXIuY3JlYXRlICgpXG4gIDsgdmFsdWVfYXZhaWxhYmxlID0gSXZhci5jcmVhdGUgKClcbiAgfVxuOztcblxubGV0IHRha2Vfbm9uZW1wdHkgdCA9XG4gIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gIGxldCByID0gTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlIGluXG4gIE1vcHRpb24uc2V0X25vbmUgdC5jdXJyZW50X3ZhbHVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnRha2VuICgpO1xuICB0LnZhbHVlX2F2YWlsYWJsZSA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgclxuOztcblxubGV0IHRha2Vfbm93X2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci50YWtlX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgdGFrZV9ub25lbXB0eSB0XG47O1xuXG5sZXQgdGFrZV9ub3cgdCA9IGlmIG5vdCAoaXNfZW1wdHkgdCkgdGhlbiBTb21lICh0YWtlX25vbmVtcHR5IHQpIGVsc2UgTm9uZVxuXG5sZXQgcmVjIHRha2UgdCA9XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gKHRha2Vfbm9uZW1wdHkgdClcbiAgZWxzZSAoXG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIHRha2UgdClcbjs7XG5cbmxldCBzZXQgdCB2ID1cbiAgTW9wdGlvbi5zZXRfc29tZSB0LmN1cnJlbnRfdmFsdWUgdjtcbiAgSXZhci5maWxsX2lmX2VtcHR5IHQudmFsdWVfYXZhaWxhYmxlICgpXG47O1xuXG5sZXQgdXBkYXRlIHQgfmYgPSBzZXQgdCAoZiAocGVlayB0KSlcbmxldCB1cGRhdGVfZXhuIHQgfmYgPSBzZXQgdCAoZiAocGVla19leG4gdCkpXG5sZXQgdGFrZW4gdCA9IEJ2YXIud2FpdCB0LnRha2VuXG5cbmxldCByZWMgcHV0IHQgdiA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiAoXG4gICAgc2V0IHQgdjtcbiAgICByZXR1cm4gKCkpXG4gIGVsc2UgKFxuICAgIGxldCViaW5kICgpID0gdGFrZW4gdCBpblxuICAgIHB1dCB0IHYpXG47O1xuXG5sZXQgcGlwZV93aGVuX3JlYWR5IHQgPVxuICBsZXQgciwgdyA9IFBpcGUuY3JlYXRlICgpIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIGlmIG5vdCAoUGlwZS5pc19jbG9zZWQgdylcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHRha2Vfbm93IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKClcbiAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGxldCViaW5kICgpID0gUGlwZS53cml0ZSB3IHggaW5cbiAgICAgICAgbG9vcCAoKSlcbiAgICBlbHNlIHJldHVybiAoKVxuICBpblxuICBkb24ndF93YWl0X2ZvciAobG9vcCAoKSk7XG4gIHJcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBzdGFydCA6IHVuaXQgSXZhci50XG4gICAgOyByZXN1bHQgOiAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSBmID1cbiAgICBsZXQgc3RhcnQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIHsgc3RhcnRcbiAgICA7IHJlc3VsdCA9XG4gICAgICAgIChsZXQlYmluZCAoKSA9IEl2YXIucmVhZCBzdGFydCBpblxuICAgICAgICAgTW9uaXRvci50cnlfd2l0aF9vcl9lcnJvclxuICAgICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgICAgIGYpXG4gICAgfVxuICA7O1xuXG4gIGxldCBjcmVhdGVfb3JfZXJyb3IgZiA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICB7IHN0YXJ0XG4gICAgOyByZXN1bHQgPVxuICAgICAgICAobGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgc3RhcnQgaW5cbiAgICAgICAgIE1vbml0b3IudHJ5X3dpdGhfam9pbl9vcl9lcnJvclxuICAgICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgICAgIGYpXG4gICAgfVxuICA7O1xuXG4gIGxldCB3YWl0IHQgPSB0LnJlc3VsdFxuICBsZXQgd2FpdF9leG4gdCA9IHdhaXQgdCA+Pnwgb2tfZXhuXG4gIGxldCBzdGFydCB0ID0gSXZhci5maWxsX2lmX2VtcHR5IHQuc3RhcnQgKClcblxuICBsZXQgZm9yY2UgdCA9XG4gICAgc3RhcnQgdDtcbiAgICB3YWl0IHRcbiAgOztcblxuICBsZXQgZm9yY2VfZXhuIHQgPSBmb3JjZSB0ID4+fCBva19leG5cbiAgbGV0IHJldHVybiBhID0gY3JlYXRlIChmdW4gKCkgLT4gcmV0dXJuIGEpXG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgY3JlYXRlIChmdW4gKCkgLT5cbiAgICAgIGxldCViaW5kIGEgPSBmb3JjZV9leG4gdCBpblxuICAgICAgZm9yY2VfZXhuIChmIGEpKVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuICgpIC0+IGZvcmNlX2V4biB0ID4+fCBmKVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgTW9uYWQuTWFrZSAoVClcblxubGV0IGJpbmQnIHQgZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gY3JlYXRlIChmdW4gKCkgLT4gZiBhKSlcbmxldCBpc19mb3JjZWQgdCA9IEl2YXIuaXNfZnVsbCB0LnN0YXJ0XG5sZXQgaXNfZGV0ZXJtaW5lZCB0ID0gRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCB0LnJlc3VsdFxubGV0IHBlZWsgdCA9IERlZmVycmVkLnBlZWsgdC5yZXN1bHRcbmxldCBwZWVrX2V4biB0ID0gT3B0aW9uLm1hcCAocGVlayB0KSB+Zjpva19leG5cbiIsIm9wZW4gQ29yZVxuXG50eXBlICdhIHQgPSB7IHdhaXRzIDogJ2EgSXZhci50IFF1ZXVlLnQgfSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgY3JlYXRlICgpID0geyB3YWl0cyA9IFF1ZXVlLmNyZWF0ZSAoKSB9XG5sZXQgd2FpdCB0ID0gRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPiBRdWV1ZS5lbnF1ZXVlIHQud2FpdHMgaXZhcilcbmxldCBzaWduYWwgdCBhID0gT3B0aW9uLml0ZXIgKFF1ZXVlLmRlcXVldWUgdC53YWl0cykgfmY6KGZ1biBpdmFyIC0+IEl2YXIuZmlsbCBpdmFyIGEpXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgUXVldWUuaXRlciB0LndhaXRzIH5mOihmdW4gaXZhciAtPiBJdmFyLmZpbGwgaXZhciBhKTtcbiAgUXVldWUuY2xlYXIgdC53YWl0c1xuOztcbiIsIm9wZW4gQ29yZVxuaW5jbHVkZSBHY1xuXG4oKiogW2FkZF9maW5hbGl6ZXIgZiB4XSBpcyBsaWtlIFtHYy5maW5hbGlzZSBmIHhdLCBleGNlcHQgdGhhdCB0aGUgZmluYWxpemVyIGlzIGd1YXJhbnRlZWRcbiAgICB0byBydW4gYXMgYW4gQXN5bmMgam9iIChpLmUuIHdpdGhvdXQgaW50ZXJydXB0aW5nIG90aGVyIEFzeW5jIGpvYnMpLiAgVW5wcm90ZWN0ZWQgdXNlXG4gICAgb2YgW0NhbWwuR2MuZmluYWxpc2VdIG9yIFtDb3JlLkdjLmFkZF9maW5hbGl6ZXJdIGluIEFzeW5jIHByb2dyYW1zIGlzIHdyb25nLCBiZWNhdXNlXG4gICAgdGhlIGZpbmFsaXplcnMgd29uJ3QgaG9sZCB0aGUgYXN5bmMgbG9jaywgYW5kIHRodXMgY291bGQgaW50ZXJsZWF2ZSBhcmJpdHJhcmlseSB3aXRoXG4gICAgYXN5bmMgam9icy4gKilcbmxldCBhZGRfZmluYWxpemVyIGhlYXBfYmxvY2sgZiA9IFNjaGVkdWxlci4oYWRkX2ZpbmFsaXplciAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gaGVhcF9ibG9jayBmID0gU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2V4biAodCAoKSkpIGhlYXBfYmxvY2sgZlxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdCBoZWFwX2Jsb2NrIGYgPSBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdCAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9sYXN0X2V4biBoZWFwX2Jsb2NrIGYgPVxuICBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gKHQgKCkpKSBoZWFwX2Jsb2NrIGZcbjs7XG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBtb2R1bGUgQWxhcm0gPSBHYy5FeHBlcnQuQWxhcm1cblxuICB0eXBlIHQgPSBBbGFybS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSBmID0gU2NoZWR1bGVyLihjcmVhdGVfYWxhcm0gKHQgKCkpKSBmXG4gIGxldCBkZWxldGUgPSBBbGFybS5kZWxldGVcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGRlZmluZXMgc2lnbmF0dXJlcyB0aGF0IGV4dGVuZCBbQ29yZS5JbnZhcmlhbnRdIHdpdGggYW4gW0FzeW5jXVxuICAgIHN1Ym1vZHVsZSBmb3IgaW52YXJpYW50cyB0aGF0IHVzZSBhc3luYyBjb21wdXRhdGlvbiBhbmQgcmV0dXJuIFt1bml0IERlZmVycmVkLnRdLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIC0+IHVuaXQgRGVmZXJyZWQudFxuICB0eXBlICdhIGludiA9ICdhIHRcblxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2EgdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2IgaW52IC0+ICgnYSwgJ2IpIHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGludmFyaWFudCA6ICdhIGludiAtPiAnYiBpbnYgLT4gJ2MgaW52IC0+ICgnYSwgJ2IsICdjKSB0IGludlxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBc3luY19pbnZhcmlhbnQgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBDb3JlLkludmFyaWFudFxuXG4gIG1vZHVsZSBBc3luYyA6IHNpZ1xuICAgIG9wZW4gQXN5bmNcblxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBBc3luYy50XG5cbiAgICBtb2R1bGUgdHlwZSBTID0gU1xuICAgIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gICAgbW9kdWxlIHR5cGUgUzMgPSBTM1xuXG4gICAgdmFsIGludmFyaWFudFxuICAgICAgOiAgU291cmNlX2NvZGVfcG9zaXRpb24udFxuICAgICAgLT4gJ2FcbiAgICAgIC0+ICgnYSAtPiBTZXhwLnQpXG4gICAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgICAtPiB1bml0IERlZmVycmVkLnRcblxuICAgICgqKiBbY2hlY2tfZmllbGRdIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHJlY29yZCBmaWVsZHMgd2hlbiB1c2luZyBbW0BAZGVyaXZpbmcgZmllbGRzXV0uXG4gICAgICAgIElkaW9tYXRpYyB1c2FnZSBsb29rcyBsaWtlOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgdHlwZSB0ID0geyBmb28gOiBGb28udCA7IGJhciA6IEJhci50IH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICAgICAgICBsZXQgaW52YXJpYW50IHQgPVxuICAgICAgICAgICAgSW52YXJpYW50LkFzeW5jLmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBjaGVjayBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAoY2hlY2sgRm9vLmludmFyaWFudClcbiAgICAgICAgICAgICAgICB+YmFyOiAoY2hlY2sgQmFyLmludmFyaWFudCkgXX1cblxuICAgICAgICBXaGVuIHNvbWUgZmllbGRzIGhhdmUgc3luY2hyb25vdXMgaW52YXJpYW50cywgb3IgZG8gbm90IG5lZWQgdG8gYmUgY2hlY2tlZCwgaXRcbiAgICAgICAgbWF5IGJlIHVzZWZ1bCB0byBkZWZpbmUgYSBzZWNvbmQgd3JhcHBlciBhcm91bmQgW2NoZWNrX2ZpZWxkXTpcblxuICAgICAgICB7W1xuICAgICAgICAgIHR5cGUgdCA9IHsgZm9vIDogRm9vLnQgOyBiYXIgOiBCYXIudCA7IHF1dXggOiBRdXV4LnQgfVxuICAgICAgICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgICAgICAgIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgICAgICAgICBJbnZhcmlhbnQuQXN5bmMuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrJyBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrIGludiA9IGNoZWNrJyAoZnVuIHggLT4gaW52IHg7IHJldHVybiAoKSkgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAgKGNoZWNrJyBGb28uaW52YXJpYW50KVxuICAgICAgICAgICAgICAgIH5iYXI6ICAoY2hlY2sgIEJhci5pbnZhcmlhbnQpXG4gICAgICAgICAgICAgICAgfnF1dXg6IChjaGVjayAgaWdub3JlKSBdfSAqKVxuICAgIHZhbCBjaGVja19maWVsZCA6ICdhIC0+ICdiIHQgLT4gdW5pdCBEZWZlcnJlZC50IC0+ICgnYSwgJ2IpIEZpZWxkLnQgLT4gdW5pdCBEZWZlcnJlZC50XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBEZWZlcnJlZC5MZXRfc3ludGF4XG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29yZS5JbnZhcmlhbnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIGluY2x1ZGUgQXN5bmNfaW52YXJpYW50X2ludGYuQXN5bmNcblxuICBsZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgIH5ydW46XG4gICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgZlxuICAgICAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgIHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciBleG4gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCIgfl86KGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KSAoZXhuIDogZXhuKSB+XzoodCA6IHQpXVxuICA7O1xuXG4gIGxldCBjaGVja19maWVsZCB0IGYgd2FpdF9mb3JfcHJldmlvdXMgZmllbGQgPVxuICAgIGxldCViaW5kICgpID0gd2FpdF9mb3JfcHJldmlvdXMgaW5cbiAgICBtYXRjaCVtYXBcbiAgICAgIE1vbml0b3IudHJ5X3dpdGhcbiAgICAgICAgfnJ1bjpcbiAgICAgICAgICBgU2NoZWR1bGVcbiAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgICAgICAoZnVuICgpIC0+IGYgKEZpZWxkLmdldCBmaWVsZCB0KSlcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcInByb2JsZW0gd2l0aCBmaWVsZFwiIH5maWVsZDooRmllbGQubmFtZSBmaWVsZCA6IHN0cmluZykgKGV4biA6IGV4bildXG4gIDs7XG5lbmRcbiIsIigqKiBDb250YWlucyBBc3luYydzIGNvcmUgZGF0YSBzdHJ1Y3R1cmVzLCBsaWtlIHt7IUFzeW5jX2tlcm5lbC5EZWZlcnJlZH1bRGVmZXJyZWRdfSxcbiAgICB7eyFBc3luY19rZXJuZWwuSXZhcn1bSXZhcl19LCBhbmQge3shQXN5bmNfa2VybmVsLkNsb2NrX2ludGYuQ2xvY2t9W0Nsb2NrXX0uXG5cbiAgICBbQXN5bmNfa2VybmVsXSBpcyBkZXNpZ25lZCB0byBkZXBlbmQgb25seSBvbiB7eyFDb3JlfVtDb3JlXX0gYW5kIHNvIGlzIG1vcmVcbiAgICBwbGF0Zm9ybS1pbmRlcGVuZGVudC4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXN5bmNfa2VybmVsX2NvbmZpZyA9IEFzeW5jX2tlcm5lbF9jb25maWdcbm1vZHVsZSBBc3luY19rZXJuZWxfcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IFJlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2Vcbm1vZHVsZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlclxubW9kdWxlIEJ2YXIgPSBCdmFyXG5tb2R1bGUgQ2xvY2tfbnMgPSBDbG9ja19uc1xubW9kdWxlIENvbmRpdGlvbiA9IEFzeW5jX2NvbmRpdGlvblxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWRcbm1vZHVsZSBFeGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0XG5tb2R1bGUgR2MgPSBBc3luY19nY1xubW9kdWxlIEludmFyaWFudCA9IEFzeW5jX2ludmFyaWFudFxubW9kdWxlIEl2YXIgPSBJdmFyXG5tb2R1bGUgTGF6eV9kZWZlcnJlZCA9IExhenlfZGVmZXJyZWRcbm1vZHVsZSBNb25hZF9zZXF1ZW5jZSA9IE1vbmFkX3NlcXVlbmNlXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3Jcbm1vZHVsZSBNdmFyID0gTXZhclxubW9kdWxlIFBpcGUgPSBQaXBlXG5tb2R1bGUgUHJpb3JpdHkgPSBQcmlvcml0eVxubW9kdWxlIFNlcXVlbmNlciA9IFRocm90dGxlLlNlcXVlbmNlclxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxubW9kdWxlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2Vcbm1vZHVsZSBUYWlsID0gVGFpbFxubW9kdWxlIFRocm90dGxlID0gVGhyb3R0bGVcbm1vZHVsZSBUaW1lX3NvdXJjZSA9IFRpbWVfc291cmNlXG5cblxuKCoqIHsyIFRvcGxldmVsIGZ1bmN0aW9ucyB9XG5cbiAgICBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBicm9hZGx5IHVzZWZ1bCB3aGVuIHdyaXRpbmcgQXN5bmMgcHJvZ3JhbXMsIGFuZCBzbyBhcmUgbWFkZVxuICAgIGF2YWlsYWJsZSBhdCB0aGUgdG9wbGV2ZWwuICopXG5cblxubGV0IGFmdGVyID0gQ2xvY2tfbnMuYWZ0ZXJcbmxldCBhdCA9IENsb2NrX25zLmF0XG5sZXQgY2F0Y2ggPSBNb25pdG9yLmNhdGNoXG5sZXQgY2hvaWNlID0gRGVmZXJyZWQuY2hvaWNlXG5sZXQgY2hvb3NlID0gRGVmZXJyZWQuY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBEZWZlcnJlZC5kb24ndF93YWl0X2ZvclxubGV0IGV2ZXJ5ID0gQ2xvY2tfbnMuZXZlcnlcbmxldCBuZXZlciA9IERlZmVycmVkLm5ldmVyXG5sZXQgc2NoZWR1bGUgPSBTY2hlZHVsZXIuc2NoZWR1bGVcbmxldCBzY2hlZHVsZScgPSBTY2hlZHVsZXIuc2NoZWR1bGUnXG5sZXQgdHJ5X3dpdGggPSBNb25pdG9yLnRyeV93aXRoXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCB3aXRoX3RpbWVvdXQgPSBDbG9ja19ucy53aXRoX3RpbWVvdXRcbmxldCB3aXRoaW4gPSBTY2hlZHVsZXIud2l0aGluXG5sZXQgd2l0aGluJyA9IFNjaGVkdWxlci53aXRoaW4nXG5cbigqKiB7MiBJbmZpeCBvcGVyYXRvcnMgYW5kIFtMZXRfc3ludGF4XSBzdXBwb3J0fSAqKVxuXG5pbmNsdWRlIChEZWZlcnJlZCA6IE1vbmFkLkluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIERlZmVycmVkLnQpXG5cbigqKiBlcXVpdmFsZW50IHRvIHshRGVmZXJyZWQudXBvbn0uICopXG5sZXQgKCA+Pj4gKSA9IERlZmVycmVkLkluZml4LiggPj4+IClcblxuKCoqIGVxdWl2YWxlbnQgdG8geyFEZWZlcnJlZC5SZXN1bHQuYmluZH0uICopXG5sZXQgKCA+Pj0/ICkgPSBEZWZlcnJlZC5SZXN1bHQuKCA+Pj0gKVxuXG4oKiogZXF1aXZhbGVudCB0byB7IURlZmVycmVkLlJlc3VsdC5tYXB9LiAqKVxubGV0ICggPj58PyApID0gRGVmZXJyZWQuUmVzdWx0LiggPj58IClcblxuaW5jbHVkZSBEZWZlcnJlZC5MZXRfc3ludGF4XG5cbigqKi8qKilcblxuKCoqIFRoZSBtb2R1bGVzIGluIFtBc3luY19rZXJuZWxfcHJpdmF0ZV0gYXJlIHVzZWQgZm9yIGNvbnN0cnVjdGluZyBhbmQgdGVzdGluZyBBc3luYywgYW5kXG4gICAgc2hvdWxkIG5vdCBvdGhlcndpc2UgYmUgdXNlZC4gKilcbm1vZHVsZSBBc3luY19rZXJuZWxfcHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgRGVidWcgPSBEZWJ1Z1xuICBtb2R1bGUgSXZhcjAgPSBJdmFyMFxuICBtb2R1bGUgSXZhcl9maWxsZXIgPSBJdmFyX2ZpbGxlclxuICBtb2R1bGUgSm9iID0gSm9iXG4gIG1vZHVsZSBTdGFja19vcl9jb3VudGVyID0gU3RhY2tfb3JfY291bnRlclxuZW5kXG5cbigqKi8qKilcblxuKCogVGhpcyB0ZXN0IG11c3QgYmUgaW4gdGhpcyBsaWJyYXJ5LCBiZWNhdXNlIGl0IHJlcXVpcmVzIFtyZXR1cm5dIHRvIGJlIGlubGluZWQuICBNb3ZpbmdcbiAgIGl0IHRvIGFub3RoZXIgbGlicmFyeSB3aWxsIGNhdXNlIGl0IHRvIGJyZWFrIHdpdGggW1hfTElCUkFSWV9JTkxJTklORz1mYWxzZV0uICopXG5sZXQldGVzdF91bml0IFwiW3JldHVybiAoKV0gZG9lcyBub3QgYWxsb2NhdGVcIiA9XG4gIGxldCB3MSA9IEdjLm1pbm9yX3dvcmRzICgpIGluXG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAocmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQuTGV0X3N5bnRheC5yZXR1cm4gKCkpIDogXyBEZWZlcnJlZC50KTtcbiAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IChEZWZlcnJlZC5MZXRfc3ludGF4LkxldF9zeW50YXgucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGxldCB3MiA9IEdjLm1pbm9yX3dvcmRzICgpIGluXG4gIFsldGVzdF9yZXN1bHQ6IGludF0gdzIgfmV4cGVjdDp3MVxuOztcbiJdfQ==
