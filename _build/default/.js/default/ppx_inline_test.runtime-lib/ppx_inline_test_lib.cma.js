// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_inline_test_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_inline_test_lib = [0];
   runtime.caml_register_global(0, Ppx_inline_test_lib, "Ppx_inline_test_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_inline_test_lib__Runtime
//# unitInfo: Requires: Base, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib_Runtim$0 = "Ppx_inline_test_lib__Runtime",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    enable_everything = [0, 0, 0],
    cst = cst$13,
    am_running_inline_test_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    _E_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _F_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _z_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _A_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _B_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _C_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _D_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _G_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _H_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _J_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _K_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _I_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _x_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _y_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _r_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _t_ = [0, 1],
    _u_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _v_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _w_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _q_ = [0, [2, 0, [10, 0]], cst_s],
    _p_ = [0, [2, 0, [10, 0]], cst_s],
    _o_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib_Runtim = cst_Ppx_inline_test_lib_Runtim$0,
    cst_inline_tests_log = cst_inline_tests_log$0,
    _S_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _O_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    _h_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _g_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _f_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _e_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    _a_ = [0, [2, 0, 0], cst_s$0],
    _b_ = [0, [2, 0, 0], cst_s$0],
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error",
    cst_inline_test_runner = cst_inline_test_runner$0,
    _N_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Allow_output_patterns_in_t =
      " Allow output patterns in tests expectations",
    cst_allow_output_patterns = "-allow-output-patterns",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _n_ = [0, 187165616, 545942154],
    _L_ = [0, 187165616, -863538453];
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[25], combine, 0, ts);
   }
   var
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _aa_ = 1, force_drop = _aa_;
   }
   catch(_b4_){
    var _c_ = caml_wrap_exception(_b4_);
    if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _d_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _b2_ = caml_string_notequal(current[1], cst$13),
     _b3_ = _b2_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _d_, current[1]) : _b2_;
    return _b3_ ? caml_call3(Stdlib_Hashtbl[5], _d_, current[1], 0) : _b3_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return caml_string_equal(p, current[1]);
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var t = current$0[1];
    function _b0_(m){return m[2];}
    var _b1_ = caml_call2(Stdlib_List[19], _b0_, t);
    return caml_call1(Stdlib_List[13], _b1_);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    allow_output_patterns = [0, 0];
   function displayed_descr(param){
    var _bY_ = caml_obj_tag(param);
    a:
    if(250 === _bY_)
     var descr = param[1];
    else{
     if(246 !== _bY_ && 244 !== _bY_){var descr = param; break a;}
     var descr = caml_call1(CamlinternalLazy[2], param);
    }
    return function(filename, line, start_pos, end_pos){
     var
      _bZ_ =
        caml_string_equal(descr, cst$13)
         ? cst$0
         : caml_call2(Stdlib[28], cst$1, descr);
     return caml_call6
             (Stdlib_Printf[4], _e_, filename, line, start_pos, end_pos, _bZ_);};
   }
   var _i_ = caml_sys_argv(0), match = caml_call1(Stdlib_Array[9], _i_);
   a:
   if(match){
    var _j_ = match[2];
    if(_j_){
     var name = match[1];
     if(! caml_string_notequal(_j_[1], cst_inline_test_runner$0)){
      var match$0 = _j_[2];
      if(match$0){
       var rest = match$0[2], lib = match$0[1];
       if(Base[86][1]){
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, enable_everything],
         name_filter = [0, 0],
         msg$1 =
           caml_call4
            (Stdlib_Printf[4], _N_, name, cst_inline_test_runner, lib),
         f =
           function(anon){
            caml_call3(Stdlib_Printf[3], _O_, name, anon);
            return caml_call1(Stdlib[99], 1);
           },
         _P_ = 0,
         _Q_ =
           [0,
            [0,
             cst_allow_output_patterns,
             [2, allow_output_patterns],
             cst_Allow_output_patterns_in_t],
            [0,
             [0,
              cst_source_tree_root,
              [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
              cst_Path_to_the_root_of_the_so],
             _P_]],
         _R_ =
           [0,
            [0, cst_no_color, [3, use_color], cst_Summarize_tests_without_us],
            [0,
             [0, cst_in_place, [2, in_place], cst_Update_expect_tests_in_pla],
             [0,
              [0,
               cst_diff_cmd,
               [4, function(s){diff_command[1] = [0, s]; return 0;}],
               cst_Diff_command_for_tests_tha],
              _Q_]]],
         _T_ =
           [0,
            [0,
             cst_only_test,
             [4,
              function(str){
               try{
                var
                 _bQ_ =
                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                   },
                 _bR_ = [0, caml_call3(Stdlib_Scanf[5], str, _h_, _bQ_)],
                 match = _bR_;
               }
               catch(_bV_){
                try{
                 var
                  _bO_ = function(file, line){return [0, file, [0, line]];},
                  _bP_ = [0, caml_call3(Stdlib_Scanf[5], str, _g_, _bO_)],
                  match = _bP_;
                }
                catch(_bW_){
                 try{
                  var
                   _bM_ = function(file){return [0, file, 0];},
                   _bN_ = [0, caml_call3(Stdlib_Scanf[5], str, _f_, _bM_)],
                   match = _bN_;
                 }
                 catch(_bX_){var match = 0;}
                }
               }
               if(match)
                var
                 match$0 = match[1],
                 index = match$0[2],
                 file = match$0[1],
                 index$0 = index,
                 filename = file;
               else if(caml_call2(Stdlib_String[14], str, 58)){
                var
                 i = caml_call2(Stdlib_String[35], str, 58),
                 filename$0 = caml_call3(Stdlib_String[15], str, 0, i),
                 index_string =
                   caml_call3
                    (Stdlib_String[15],
                     str,
                     i + 1 | 0,
                     (caml_ml_string_length(str) - i | 0) - 1 | 0);
                try{
                 var
                  _bT_ = runtime.caml_int_of_string(index_string),
                  index$1 = _bT_;
                }
                catch(_bU_){
                 var _bS_ = caml_wrap_exception(_bU_);
                 if(_bS_[1] !== Stdlib[7])
                  throw caml_maybe_attach_backtrace(_bS_, 0);
                 caml_call2(Stdlib_Printf[3], _S_, str);
                 var index$1 = caml_call1(Stdlib[99], 1);
                }
                var index$0 = [0, index$1], filename = filename$0;
               }
               else
                var index$0 = 0, filename = str;
               tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
               return 0;
              }],
             cst_location_Run_only_the_test],
            _R_],
         _U_ =
           [0,
            [0,
             cst_matching,
             [4,
              function(s){name_filter[1] = [0, s, name_filter[1]]; return 0;}],
             cst_substring_Only_run_tests_w],
            _T_],
         _V_ =
           [0,
            [0,
             cst_require_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bI_ = t[2];
               function _bJ_(_bL_){return caml_string_notequal(tag, _bL_);}
               var _bK_ = caml_call2(Stdlib_List[41], _bJ_, _bI_);
               tag_predicate[1] = [0, [0, tag, t[1]], _bK_];
               return 0;
              }],
             cst_tag_Only_run_tests_tagged_],
            _U_],
         _W_ =
           [0,
            [0,
             cst_drop_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bE_ = [0, tag, t[2]], _bF_ = t[1];
               function _bG_(_bH_){return caml_string_notequal(tag, _bH_);}
               tag_predicate[1] =
                [0, caml_call2(Stdlib_List[41], _bG_, _bF_), _bE_];
               return 0;
              }],
             cst_tag_Only_run_tests_not_tag],
            _V_],
         _X_ =
           [0,
            [0, cst_verbose, [2, verbose], cst_Show_the_tests_as_they_run],
            [0,
             [0,
              cst_stop_on_error,
              [2, stop_on_error],
              cst_Run_tests_only_up_to_the_f],
             [0,
              [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
              [0,
               [0,
                cst_show_counts,
                [2, show_counts],
                cst_Show_the_number_of_tests_r],
               [0,
                [0,
                 cst_log,
                 [0,
                  function(param){
                   try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                   catch(_bD_){}
                   log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                   return 0;
                  }],
                 cst_Log_the_tests_run_in_inlin],
                _W_]]]]],
         _Y_ =
           [0,
            [0,
             cst_partition,
             [4, function(i){partition[1] = [0, i]; return 0;}],
             cst_Only_run_the_tests_in_the_],
            _X_],
         _Z_ =
           [0,
            [0,
             cst_list_partitions,
             [0, function(param){list_partitions[1] = 1; return 0;}],
             cst_Lists_all_the_partitions_t],
            _Y_],
         ___ =
           [0,
            [0,
             cst_list_test_names,
             [0,
              function(param){
               list_test_names[1] = 1;
               verbose[1] = 1;
               return 0;
              }],
             cst_Do_not_run_tests_but_show_],
            _Z_],
         l = caml_call2(Stdlib_Arg[11], 0, ___),
         argv = caml_call1(Stdlib_Array[10], [0, name, rest]);
        try{caml_call5(Stdlib_Arg[3], 0, argv, l, f, msg$1);}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] === Stdlib_Arg[8]){
          var msg = exn[2];
          caml_call2(Stdlib_Printf[3], _a_, msg);
          caml_call1(Stdlib[99], 1);
         }
         else{
          if(exn[1] !== Stdlib_Arg[7])
           throw caml_maybe_attach_backtrace(exn, 0);
          var msg$0 = exn[2];
          caml_call2(Stdlib_Printf[2], _b_, msg$0);
          caml_call1(Stdlib[99], 0);
         }
        }
        var
         _$_ = list_partitions[1] ? -260537174 : [0, 1025081494, partition[1]],
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _$_]];
        action[1] = v;
        break a;
       }
      }
     }
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_bB_){
     var _k_ = caml_wrap_exception(_bB_);
     if(_k_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_k_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_bC_){
       var _l_ = caml_wrap_exception(_bC_);
       if(_l_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_l_, 0);
       var _m_ = 0;
       break b;
      }
      var _M_ = caml_string_notequal(val, "inline-test") ? 0 : 1, _m_ = _M_;
     }
     var am_running_inline_test = _m_;
     break a;
    }
    var am_running_inline_test = 1;
   }
   var
    testing = am_test_runner ? _n_ : am_running_inline_test ? _L_ : 822171972;
   function wall_time_clock_ns(param){return caml_call1(Time_now[1], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _bz_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _bA_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib_Runtim, _bz_);
        return caml_call2(Base_String[70][2], 0, _bA_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = wall_time_clock_ns(0);
    try{var _by_ = [0, caml_call1(f, 0)], res = _by_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _bw_ = wall_time_clock_ns(0),
     _bx_ = caml_call2(Base_Int63[42], _bw_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _bx_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_bv_){
        return caml_call1(Stdlib_Random[15][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_bu_){
        return caml_call1(Base_Random[18][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var t = current$0[1];
    function _bn_(m){return m[1];}
    var _bo_ = caml_call2(Stdlib_List[19], _bn_, t);
    function _bp_(s){
     var
      _br_ = caml_call1(Stdlib_String[28], s),
      _bs_ = caml_call2(Stdlib[28], _br_, cst$3),
      _bt_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _bs_);
     return caml_call2(Stdlib[28], cst_in_TES, _bt_);
    }
    var _bq_ = caml_call2(Stdlib_List[19], _bp_, _bo_);
    return caml_call2(Stdlib_String[6], cst$4, _bq_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[9], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _bl_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _o_, _bl_);
    function _bm_(message){return caml_call2(Stdlib_Printf[3], _p_, message);}
    return caml_call2(Stdlib_List[17], _bm_, delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    function _bj_(s){
     if(verbose[1])
      delayed_errors[1] = [0, s, delayed_errors[1]];
     else
      caml_call2(Stdlib_Printf[3], _q_, s);
     var _bk_ = stop_on_error[1];
     return _bk_ ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2)) : _bk_;
    }
    return caml_call2(Stdlib_Printf[10], _bj_, fmt);
   }
   function add_hooks(C){
    return function(f, param){caml_call1(C[1], 0); return caml_call1(f, 0);};
   }
   function hum_backtrace(backtrace){
    var
     _bb_ = caml_call1(Base_String[88], backtrace),
     _bc_ = Base_List[133],
     _bd_ =
       caml_call2
        (_bc_,
         _bb_,
         function(str){
          var _bh_ = caml_obj_tag(where_to_cut_backtrace);
          a:
          if(250 === _bh_)
           var _bi_ = where_to_cut_backtrace[1];
          else{
           if(246 !== _bh_ && 244 !== _bh_){
            var _bi_ = where_to_cut_backtrace;
            break a;
           }
           var _bi_ = caml_call1(CamlinternalLazy[2], where_to_cut_backtrace);
          }
          return 1 - caml_call2(Base_String[70][5], _bi_, str);
         }),
     _be_ = Base_List[76],
     _bf_ =
       caml_call2
        (_be_,
         _bd_,
         function(str){
          var _bg_ = caml_call2(Base[198], str, cst$5);
          return caml_call2(Base[198], cst$6, _bg_);
         });
    return caml_call2(Base_String[54], 0, _bf_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _aQ_ = match[2],
     what_to_do = _aQ_[2],
     match$0 = _aQ_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1],
     _a4_ = add_hooks(config);
    function f$0(_a$_){var _ba_ = _a$_; return _a4_(f, _ba_);}
    var
     descr$0 =
       [246,
        function(_a__){
         return displayed_descr(descr)
                 (def_filename, def_line_number, start_pos, end_pos);
        }],
     _aR_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _aR_),
     _aS_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_aS_){
     if(only_test_location)
      var
       _aO_ =
         function(param){
          var
           used = param[3],
           line_number_opt = param[2],
           filename = param[1],
           position_start =
             caml_ml_string_length(def_filename)
             - caml_ml_string_length(filename)
             | 0,
           _a5_ = 0 <= position_start ? 1 : 0;
          if(_a5_){
           var
            end_of_def_filename =
              caml_call3
               (Stdlib_String[15],
                def_filename,
                position_start,
                caml_ml_string_length(filename)),
            _a6_ = caml_string_equal(end_of_def_filename, filename);
           if(_a6_){
            var
             _a7_ = 0 === position_start ? 1 : 0,
             _a8_ =
               _a7_
               ||
                (47
                  ===
                   runtime.caml_string_get
                    (def_filename, position_start - 1 | 0)
                  ? 1
                  : 0);
            if(_a8_)
             if(line_number_opt)
              var
               line_number = line_number_opt[1],
               _a9_ = caml_equal(def_line_number, line_number);
             else
              var _a9_ = 1;
            else
             var _a9_ = _a8_;
           }
           else
            var _a9_ = _a6_;
           var found = _a9_;
          }
          else
           var found = _a5_;
          if(found) used[1] = 1;
          return found;
         },
       _aT_ = caml_call2(Stdlib_List[33], _aO_, only_test_location);
     else
      var _aT_ = 1;
     if(_aT_){
      var
       _aF_ = which_tags[1],
       _aG_ =
         function(req){
          return 1 - caml_call2(Stdlib_List[36], req, complete_tags);
         },
       _aH_ = caml_call2(Stdlib_List[33], _aG_, _aF_);
      if(_aH_)
       var _aU_ = _aH_;
      else
       var
        _aI_ = which_tags[2],
        _aJ_ =
          function(dropped){
           return caml_call2(Stdlib_List[36], dropped, complete_tags);
          },
        _aU_ = caml_call2(Stdlib_List[33], _aJ_, _aI_);
      var _aV_ = 1 - _aU_;
      if(_aV_){
       var _aW_ = caml_obj_tag(descr$0);
       a:
       if(250 === _aW_)
        var descr$1 = descr$0[1];
       else{
        if(246 !== _aW_ && 244 !== _aW_){var descr$1 = descr$0; break a;}
        var descr$1 = caml_call1(CamlinternalLazy[2], descr$0);
       }
       if(name_filter)
        var
         _aP_ =
           function(substring){
            return caml_call2(Base_String[76], descr$1, substring);
           },
         _aX_ = caml_call2(Stdlib_List[33], _aP_, name_filter);
       else
        var _aX_ = 1;
       var should_run = _aX_;
      }
      else
       var should_run = _aV_;
     }
     else
      var should_run = _aT_;
    }
    else
     var should_run = _aS_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _aY_ = is_current(partition);
     if(_aY_){
      var _aZ_ = caml_obj_tag(descr$0);
      a:
      if(250 === _aZ_)
       var descr$2 = descr$0[1];
      else{
       if(246 !== _aZ_ && 244 !== _aZ_){var descr$2 = descr$0; break a;}
       var descr$2 = caml_call1(CamlinternalLazy[2], descr$0);
      }
      tests_ran[1]++;
      var match$1 = log[1];
      if(match$1){
       var ch = match$1[1], _a0_ = string_of_module_descr(0);
       caml_call4(Stdlib_Printf[1], ch, _r_, descr$2, _a0_);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _s_, descr$2);
      if(list_test_names[1])
       var result$0 = _t_;
      else{
       var
        caml_random_state = caml_call1(Stdlib_Random[16], 0),
        base_random_state = caml_call1(Base_Random[18][4], Base_Random[18][1]),
        _aK_ = caml_obj_tag(saved_caml_random_state);
       a:
       if(250 === _aK_)
        var _aL_ = saved_caml_random_state[1];
       else{
        if(246 !== _aK_ && 244 !== _aK_){
         var _aL_ = saved_caml_random_state;
         break a;
        }
        var _aL_ = caml_call1(CamlinternalLazy[2], saved_caml_random_state);
       }
       caml_call1(Stdlib_Random[17], _aL_);
       var _aM_ = caml_obj_tag(saved_base_random_state);
       a:
       if(250 === _aM_)
        var _aN_ = saved_base_random_state[1];
       else{
        if(246 !== _aM_ && 244 !== _aM_){
         var _aN_ = saved_base_random_state;
         break a;
        }
        var _aN_ = caml_call1(CamlinternalLazy[2], saved_base_random_state);
       }
       caml_call1(Base_Random[19], _aN_);
       var result = time_without_resetting_random_(f$0);
       caml_call1(Stdlib_Random[17], caml_random_state);
       caml_call1(Base_Random[19], base_random_state);
       var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, time_sec[1]);
      if(0 !== result$0[0]){
       var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
       tests_failed[1]++;
       var
        backtrace$0 = hum_backtrace(backtrace),
        exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
        sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$7 : cst$8,
        _a2_ = string_of_module_descr(0);
       return caml_call5
               (eprintf_or_delay(_w_),
                descr$2,
                sep,
                exn_str,
                backtrace$0,
                _a2_);
      }
      if(result$0[1]) return 0;
      tests_failed[1]++;
      var _a1_ = string_of_module_descr(0);
      return caml_call2(eprintf_or_delay(_v_), descr$2, _a1_);
     }
     var _a3_ = _aY_;
    }
    else
     var _a3_ = should_run;
    return _a3_;
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _aE_ = caml_string_equal(which_tests[1], static_lib);
    if(! _aE_) return _aE_;
    a:
    {
     if(typeof what_to_do !== "number" && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(caml_string_equal(partition, cst$13) && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _aC_ = caml_string_equal(lib, static_lib),
     _aD_ = _aC_ ? (dynamic_lib[1] = 0, 0) : _aC_;
    return _aD_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _as_ = match[2],
     what_to_do = _as_[2],
     match$0 = _as_[1],
     which_tags = match$0[4],
     libname = match$0[1],
     _az_ = add_hooks(config);
    function f$0(_aA_){var _aB_ = _aA_; return _az_(f, _aB_);}
    var
     _at_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _at_),
     _au_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_au_)
     var
      _aq_ = which_tags[2],
      _ar_ =
        function(dropped){
         return caml_call2(Stdlib_List[36], dropped, partial_tags);
        },
      should_run = 1 - caml_call2(Stdlib_List[33], _ar_, _aq_);
    else
     var should_run = _au_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _av_ = is_current(partition);
     if(_av_){
      test_modules_ran[1]++;
      var
       descr$0 =
         displayed_descr(descr)
          (def_filename, def_line_number, start_pos, end_pos),
       prev = current$0[1];
      current$0[1] = [0, [0, descr$0, tags], prev];
      try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       current$0[1] = prev;
       throw caml_maybe_attach_backtrace(e, 0);
      }
      if(0 === x[0]) return 0;
      var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
      test_modules_failed[1]++;
      var
       backtrace$0 = hum_backtrace(backtrace),
       exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
       sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$9 : cst$10,
       _aw_ = string_of_module_descr(0),
       _ax_ = caml_call1(Stdlib_String[28], descr$0);
      return caml_call5
              (eprintf_or_delay(caml_call2(Stdlib[98], _y_, _x_)),
               _ax_,
               sep,
               exn_str,
               backtrace$0,
               _aw_);
     }
     var _ay_ = _av_;
    }
    else
     var _ay_ = should_run;
    return _ay_;
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var _aj_ = match[2], which_tests = _aj_[1];
     if(typeof _aj_[2] === "number"){
      var
       _ae_ = 0,
       _af_ = function(k, param, acc){return [0, k, acc];},
       _ag_ = caml_call3(Stdlib_Hashtbl[14], _af_, _d_, _ae_),
       _ah_ = caml_call2(Stdlib_List[56], Stdlib_String[9], _ag_),
       _ak_ = caml_call1(Stdlib_Printf[2], _B_);
      caml_call2(Stdlib_List[17], _ak_, _ah_);
      return 0;
     }
     var match$0 = log[1];
     if(match$0){var ch = match$0[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _C_, tests_ran[1], test_modules_ran[1]);
      var
       _al_ = which_tests[2],
       _am_ = function(param){var used = param[3]; return 1 - used[1];},
       unused_tests = caml_call2(Stdlib_List[41], _am_, _al_),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _D_);
       var
        _an_ =
          function(param){
           var line_number_opt = param[2], filename = param[1];
           if(! line_number_opt)
            return caml_call2(Stdlib_Printf[3], _F_, filename);
           var line_number = line_number_opt[1];
           return caml_call3(Stdlib_Printf[3], _E_, filename, line_number);
          };
       caml_call2(Stdlib_List[17], _an_, tests);
       caml_call1(Stdlib_Printf[3], _G_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _ao_ = cst$11;
     else
      var
       _ap_ = caml_call2(Stdlib[98], _K_, _J_),
       _ao_ = caml_call2(Stdlib_Printf[4], _ap_, count_test_modules);
     caml_call4(Stdlib_Printf[3], _I_, count, tests_ran[1], _ao_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _ai_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if
       (caml_string_equal
         (caml_call1(Stdlib_Filename[13], _ai_), "inline_tests_runner.exe")){caml_call1(Stdlib_Printf[3], _z_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _A_);
    }
    return 2;
   }
   var
    use_color$0 = use_color[1],
    in_place$0 = in_place[1],
    diff_command$0 = diff_command[1],
    source_tree_root$0 = source_tree_root[1],
    allow_output_patterns$0 = allow_output_patterns[1],
    evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _ab_ = caml_call1(Stdlib_List[9], evaluators[1]);
    function _ac_(f){return caml_call1(f, 0);}
    switch(combine_all(caml_call2(Stdlib_List[19], _ac_, _ab_))){
      case 0:
       var _ad_ = 0; break;
      case 1:
       var _ad_ = 2; break;
      default: var _ad_ = 1;
    }
    return caml_call1(Stdlib[99], _ad_);
   }
   var
    Ppx_inline_test_lib_Runtime =
      [0,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       testing,
       use_color$0,
       in_place$0,
       diff_command$0,
       source_tree_root$0,
       allow_output_patterns$0,
       am_running_inline_test,
       am_running_inline_test_env_var,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (124, Ppx_inline_test_lib_Runtime, cst_Ppx_inline_test_lib_Runtim$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlbmFibGVfZXZlcnl0aGluZyIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciIsInRvX3N0cmluZyIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJhbGxvd19vdXRwdXRfcGF0dGVybnMiLCJkaXNwbGF5ZWRfZGVzY3IiLCJkZXNjciIsImZpbGVuYW1lIiwibGluZSIsInN0YXJ0X3BvcyIsImVuZF9wb3MiLCJuYW1lIiwicmVzdCIsImxpYiIsInRlc3RzIiwibGlzdF9wYXJ0aXRpb25zIiwicGFydGl0aW9uIiwidGFnX3ByZWRpY2F0ZSIsIm5hbWVfZmlsdGVyIiwibXNnJDEiLCJmIiwiYW5vbiIsInMiLCJzdHIiLCJmaWxlIiwiaW5kZXgiLCJpbmRleCQwIiwiaSIsImZpbGVuYW1lJDAiLCJpbmRleF9zdHJpbmciLCJpbmRleCQxIiwidGFnIiwibCIsImFyZ3YiLCJtc2ciLCJtc2ckMCIsInYiLCJhbV90ZXN0X3J1bm5lciIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3QiLCJ0ZXN0aW5nIiwid2FsbF90aW1lX2Nsb2NrX25zIiwid2hlcmVfdG9fY3V0X2JhY2t0cmFjZSIsInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tXyIsImJlZm9yZV9ucyIsInJlcyIsImV4biQwIiwiZXhuIiwic2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUiLCJzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSIsInN0cmluZ19vZl9tb2R1bGVfZGVzY3IiLCJwcmludF9kZWxheWVkX2Vycm9ycyIsImRlbGF5ZWRfZXJyb3JzJDAiLCJtZXNzYWdlIiwiZXByaW50Zl9vcl9kZWxheSIsImZtdCIsImFkZF9ob29rcyIsIkMiLCJodW1fYmFja3RyYWNlIiwiYmFja3RyYWNlIiwidGVzdF9pbm5lciIsImNvbmZpZyIsInRhZ3MiLCJkZWZfZmlsZW5hbWUiLCJkZWZfbGluZV9udW1iZXIiLCJib29sX29mX2YiLCJ3aGF0X3RvX2RvIiwid2hpY2hfdGFncyIsIm9ubHlfdGVzdF9sb2NhdGlvbiIsImxpYm5hbWUiLCJmJDAiLCJkZXNjciQwIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsImRlc2NyJDEiLCJzdWJzdHJpbmciLCJzaG91bGRfcnVuIiwiZGVzY3IkMiIsImNoIiwicmVzdWx0JDAiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwicmVzdWx0IiwiYmFja3RyYWNlJDAiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInBhcnRpYWxfdGFncyIsInByZXYiLCJ4IiwiZSQwIiwiZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJjb3VudCIsImNvdW50X3Rlc3RfbW9kdWxlcyIsInVudXNlZF90ZXN0cyIsImVycm9ycyIsInVzZV9jb2xvciQwIiwiaW5fcGxhY2UkMCIsImRpZmZfY29tbWFuZCQwIiwic291cmNlX3RyZWVfcm9vdCQwIiwiYWxsb3dfb3V0cHV0X3BhdHRlcm5zJDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3BweF9pbmxpbmVfdGVzdC9ydW50aW1lLWxpYi9ydW50aW1lLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0RE1BOztJQWtQRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFyU0VDO0lBQVk7O09BQ0Q7O09BQ0E7ZUFDQTs7R0FBTztZQUdsQkMsUUFBUUMsSUFBR0M7SUFDYjs7WUFEVUQ7O2FBQUdDLElBRWdCOzs7O2NBRmhCQSxJQUlnQjs7SUFEQTtHQUNPO1lBR2xDQyxZQUFZQztJQUFLLE9BQUEsNEJBUGpCSixZQU9ZSTtHQUFzQztHQVlqQztJQUFuQkM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFxRUVDOztJQUVVO0lBQStDLElBQUEsVUFEekRDOzs7OztRQUFBQTs7WUFHQUMsV0FNRixPQVRFRCwwQkFEQUQsVUFZVTtHQVdKLElBQUEsTUFBQSxzQ0FDTkc7WUFDQUM7SUFDRjtLQUFHLE9BQUEscUJBRkREO0tBRUMsa0JBQXNCLG1DQUZ2QkE7a0JBR0EsbUNBSEFBO0dBRzJCO1lBRTNCRTtJQUFhLFlBQ0w7UUFDSEM7SUFBSyxPQUFBLGtCQUFMQSxHQVBMSDtHQU9zQjtHQXFCRixJQUFwQkk7WUFjQUM7SUFBbUIsSUFqQlpDLElBR1BGO2tCQUhzQ0csR0FBSyxPQUFMQSxLQUFXO0lBQTFCLFdBQUEsa0NBQWhCRDtJQUFnQixPQUFBO0dBaUJZO0dBRzNCO0lBQVZFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBRUFDO0lBRUFDO0lBRUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDOzs7O1NBQXNCQzs7MENBQUFBO1NBQUFBOztvQkFBT0MsVUFBU0MsTUFBS0MsV0FBVUM7S0FHakQ7O1FBQUEsa0JBSGtCSjs7V0FHTSw4QkFITkE7S0FHTSxPQUFBO3FDQUhDQyxVQUFTQyxNQUFLQyxXQUFVQyxlQUdaOztHQVdyQyw0QkFBQSxRQUFBOzs7OztTQUNKQzs7OztXQUF1Q0MsbUJBQVBDOztRQUdsQjtTQUFSQztTQUNBQztTQUNBQztTQUNBQyxvQkExSkpqRDtTQTJKSWtEO1NBOUxjQztXQThQaEI7b0NBdkVKUiw4QkFBZ0NFO1NBdkxkTztvQkEyUFJDO1lBQ04sa0NBckVKVixNQW9FVVU7WUFDTixPQUFBO1dBQ007U0FGTDs7Ozs7aUJBckZMakI7Ozs7OzJCQW1GeUNrQixHQXBGekNuQiwwQkFvRnlDbUIsYUFBK0I7Ozs7O2tDQXZGeEV0Qjs7bUNBQ0FDOzs7OzRCQWtGaUNxQixHQWpGakNwQixzQkFpRmlDb0IsYUFBMkI7Ozs7Ozs7O3VCQTlCMUJDO2VBQzVCO2dCQTNDSjs7NEJBQ2FDLE1BQUtoQixNQUFLQyxXQUFXQyxTQUFZLFdBQWpDYyxVQUFLaEI7bUJBQTJDO2lCQUQ3RCxXQUFLLDRCQTBDMkJlOzs7O2dCQXZDcEM7aUJBQUk7a0NBQW9EQyxNQUFLaEIsTUFBUSxXQUFiZ0IsVUFBS2hCLE9BQXVCO2tCQUFoRixXQUFLLDRCQXVDMkJlOzs7O2lCQXJDcEM7a0JBQUk7bUNBQTBDQyxNQUFRLFdBQVJBLFNBQWtCO21CQUE1RCxXQUFLLDRCQXFDMkJEOzs7Ozs7Ozs7aUJBR1pFO2lCQUFORDtpQkFGSUUsVUFFRUQ7aUJBRlpsQixXQUVNaUI7dUJBRUgsOEJBTHFCRDtnQkFNZDtpQkFBSkksSUFBSSw4QkFOY0o7aUJBT2xCSyxhQUFXLDhCQVBPTCxRQU1sQkk7aUJBRUFFO21CQUFlOztxQkFSR047cUJBTWxCSTs0Q0FOa0JKLE9BTWxCSTtnQkFHSjtpQkFDTTtrQkFBQSxPQUFBLDJCQUZGRTtrQkFDQUM7Ozs7OztpQkFHQSxrQ0Faa0JQO3FCQVNsQk8sVUFLQTs7b0JBYklKLGNBUUpJLFVBUk52QixXQU1NcUI7OztvQkFOSUYsYUFBVm5CLFdBRHdCZ0I7ZUE3QjVCVCxtQkE4QklQLFVBQVVtQixrQkE5QmRaOztjQWlEK0M7Ozs7Ozs7O3VCQXRCcEJRLEdBdkIzQkoscUJBdUIyQkksR0F2QjNCSiwwQkF1QmdFOzs7Ozs7Ozt1QkFIbENhO2VBQzlCLElBektJekMsSUFtSkoyQix5QkFuSkkzQjtlQUNtQixvQiw0QkF1S095QztlQXZLbkIsV0FBQTtlQWtKWGQsMkJBcUI4QmMsS0F4SzFCekM7O2NBeUttRDs7Ozs7Ozs7dUJBSjVCeUM7ZUFDM0IsSUEzS0N6QyxJQXdKRDJCLGtCQXZKVyxXQXlLZ0JjLEtBMUsxQnpDLGNBQUFBO2VBRXVCLG9CLDRCQXdLR3lDO2VBbEIzQmQ7b0JBdEpZOztjQXlLd0M7Ozs7O2lDQXpEMUR6Qjs7OztrQkFLQUs7OztrQ0FKQUo7Ozs7b0JBQ0FDOzs7Ozs7O21CQW1ETSxJQUFLOzttQkE5Q1hJLGFBK0NrQjs7a0JBQTZCOzs7Ozs7OzBCQVRiNkIsR0FSNUJYLG1CQVE0QlcsYUFBd0I7Ozs7Ozs7aUNBVHBEWixpQ0FPNkQ7OztTQUhaOzs7Ozs7ZUFyQ3ZEcEI7ZUFIQUg7O2NBeUNvRjs7O1NBaE1wRXdDLElBK0w0QjtTQS9MakNDLE9BK0xFLGlDQVJidEIsTUFBdUNDO1FBdEx6QyxJQUNFLDZCQUZXcUIsTUFBS0QsR0FBRVosR0FBRUQ7Ozs7Y0FJWmU7VUFBTyxrQ0FBUEE7VUFBTzs7Ozs7Y0FDTkM7VUFBTyxrQ0FBUEE7VUFBTzs7O1FBMFBIO2VBcEVQcEIsa0RBQ0FDO1NBNUZBb0I7OztvQkF1RjBCdkIsS0FHMUJDLFVBSUFJLGdCQURBRDtRQTNHSnBDLFlBY0l1RDs7Ozs7OztPQWdMTkMsd0JBMUxFdEQ7OztRQXVNRTs7Ozs7O01BR0osSUFBTSxVQUFBOzs7Ozs7Ozs7U0FKTnVEOzs7UUFBQUE7OztJQVNBQyxVQXJCQUYsdUJBWUFDO1lBaUJBRSwwQkFDRixPQUFBLDJCQUF3QztHQUdSO0lBQTlCQzs7O1FBQzhDO1NBQUEsT0FBQTtTQUFkLE9BQUE7UUFBQSxPQUFBOztZQUVoQ0MsK0JBQW9DdEI7SUFDdEIsSUFBWnVCLFlBUkZIO0lBU0YsSUFXTSxJQUFBLFdBQUcsV0FiNkJwQixRQUVsQ3dCO1VBWUdDOztNQUFBQywwQkFBQUQ7TUFaSEQsY0FZR0UsS0FBbUI7O0lBRUY7S0FBQSxPQXZCdEJOO0tBdUJzQixPQUFBLGlDQWZwQkc7SUFySkY1QyxjQW9Lc0I7SUFDeEIsT0FmSTZDO0dBZUQ7R0FHOEI7SUFBL0JHOzs7UUFBeUQsT0FBQTs7SUFDekRDOzs7UUFBdUQsT0FBQTs7WUFZdkRDO0lBQ0YsSUFwTlkzRCxJQUlSRjtrQkFKMEJHLEdBQUssT0FBTEEsS0FBWTtJQUExQixXQUFBLGtDQUFKRDtrQkFxTklnQztLQUFLO01BQThCLE9BQUEsOEJBQW5DQTtNQUFtQyxPQUFBO01BQWpCLE9BQUE7S0FBQSxPQUFBO0lBQW1EO0lBRHBFLFdBQUE7SUFBQSxPQUFBO0dBR2hCO1lBNEJDNEI7SUFDSSxJQUVKQyxtQkFGSSwyQkEzTkp2RDtTQTZOQXVELGtCQURNO0lBRW9CLFdBQUE7SUFBMUI7a0JBQ2VDLFNBQ2IsT0FBQSxrQ0FEYUEsU0FDZ0I7SUFGL0IsT0FBQSxrQ0FEQUQ7R0FJZ0I7WUFFaEJFLGlCQUFpQkM7a0JBQ0VoQztLQUNuQixHQXpPQTlCO01BSUFJLHdCQW9PbUIwQixHQXBPbkIxQjs7TUFzT0ssa0NBRmMwQjtnQkFuT25CekI7b0JBeU5BcUQseUJBY0U7SUFFQztJQU5MLE9BQUEsb0NBRG1CSTtHQVFkO1lBRUhDLFVBQVdDO0ksZ0JBQXFCcEMsVUFDeEIsV0FER29DLFVBQ0gsT0FBQSxXQUR3QnBDLE1BQ0E7O1lBRWhDcUMsY0FBY0M7SUFDaEI7S0FDQSxPQUFBLDRCQUZnQkE7S0FFaEI7S0FFc0I7T0FBQTs7O2tCQUFLbkM7VUFDekIsd0JBL0ZBa0I7OztzQkFBQUE7Ozt1QkFBQUE7OztzREFBQUE7O1VBK0ZJLFdBQUEscUNBRHFCbEI7U0FDNkM7S0FIeEU7S0FJZTtPQUFBOzs7a0JBQUtBO1VBQWMsV0FBQSxzQkFBZEE7VUFBYyxPQUFBO1NBQVU7SUFKNUMsT0FBQTtHQUtnQjtZQUVDb0M7SUFBWUM7SUFBUXREO0lBQU91RDtJQUFlQztJQUEwQkM7SUFDakV0RDtJQUFXQztJQUFRVTtJQUFFNEM7SUFDbkMsWUFoVUZqRjtrQ0FpVVM7SUFFSDs7S0FENkVrRjs7S0FBM0JDO0tBQVloRDtLQUFoQ2lEO0tBQVRDO0tBQ3JCLE9BakJSYixVQVkyQks7SUFLbkIsU0E5RW9CUyx1Q0EwRVNqRDtJQUtwQjtLQUFia0Q7OztTQUFKLE9BbFBBakUsZ0JBNE9tQ0M7a0JBQXNCd0QsY0FBMEJDLGlCQUNqRXRELFdBQVdDOztLQU1GLE9BdlF6QnJCO0tBbEcwQmtGLGdCQXlXUix1QkFQc0JWO0tBU3hDLE9BQUEsZUFMMkJPLFVBM1k3QnhGO0lBZ1pFO1FBTG9DdUY7Ozs7VUE1RDVCO1dBQWlDSztXQUFqQkM7V0FBVmxFO1dBQ1ptRTttQ0F1RHFEWjtlQXZEekQsc0JBRGdCdkQ7O3VCQUNabUU7O1dBS0E7WUFERUM7Y0FDRjs7Z0JBa0RxRGI7Z0JBdkRyRFk7c0NBRFluRTtZQVNkLE9BQUEsa0JBSklvRSxxQkFMVXBFO1dBU2Q7OzBCQVJFbUU7Ozs7OzttQkFTd0I7cUJBOEM2QlosY0F2RHJEWTs7OztnQkFEc0JEOztlQWFmRyxjQWJlSDtzQkFhQSxXQTJDeURWLGlCQTNDeEVhOzs7Ozs7OztlQVZQQzs7O2VBQUFBO1VBWUosR0FaSUEsT0FIdUNMO1VBZ0IzQyxPQWJJSztTQWNMO2NBakJELGtDQTREd0NWOzs7O01Bcld0QztjQXFXMEREOztrQkFyV3pDWTtVQUFPLFdBQUksNEJBQVhBLEtBRFdQO1NBQ21CO09BQS9DLE9BQUE7TUFBQTs7OztlQXFXMERMOzttQkFwV3RDYTtXQUFXLG1DQUFYQSxTQUZRUjtVQUV3QjtlQUFyQztNQThXTjs7K0JBUkxEOzs7WUEzQzJCVSxVQTJDM0JWOzs2Q0EzQzJCVSxVQTJDM0JWO1lBM0MyQlUsMENBMkMzQlY7O1VBRmtFcEQ7OztvQkFyQ3JEK0Q7WUFBYSxPQUFBLDRCQUpDRCxTQUlkQztXQUFzRDtnQkFBdkUsa0NBcUNzRS9EOzs7V0FJbEVnRTs7O1dBQUFBOzs7VUFBQUE7OztTQUFBQTtJQVNKLEdBVElBO2VBSmlGakIseUJBZTdELE9BNVR0QmhGO0tBOFRLLElBRFkrQixZQWhCa0VpRCxlQWlCOUUsT0ExVEwvRSxXQXlUaUI4QjtLQUNaOzhCQWZIc0Q7OztXQWdCTWEsVUFoQk5iOzs0Q0FnQk1hLFVBaEJOYjtXQWdCTWEsMENBaEJOYjs7TUEvWUo1RjtvQkFtSkFvQjs7T0FnUm9ELElBQXZDc0YsaUJBQXVDLE9BekZwRG5DO09BeUZtQiw2QkFBTm1DLFNBSkhEOztTQW5SVjNGLFlBeVJ1QixrQ0FOYjJGO1NBaFJWeEY7V0F5UlUwRjs7T0F2R1k7UUFBcEJDLG9CQUFvQjtRQUNwQkMsb0JBQW9COzRCQUx0QnhDOzs7bUJBQUFBOzs7b0JBQUFBOzs7bURBQUFBOztPQU1GOytCQUxFQzs7O21CQUFBQTs7O29CQUFBQTs7O21EQUFBQTs7T0FNRjtPQUNhLElBQVR3QyxTQTVCRjlDLCtCQXVCNEIyQjtPQU05Qiw4QkFMSWlCO09BTUosNEJBTElDO1dBc0dRRixXQU1BLDZCQXBDNkJyQixXQXJFckN3Qjs7U0F6TEZoRyxZQXFTdUIsa0NBNVJ2Qk87ZUFtUlVzRjtxQkFBQUEsYUFnQlUzQix3QkFBTFo7T0F2YmZuRTtPQXlid0I7UUFBWjhHLGNBMURaaEMsY0F3RG9CQztRQUdSZ0MsVUFBVSxtQ0FIUDVDO1FBSUg2QyxNQUFTLDhCQURURDtRQUdRLE9BcEhwQnpDO09Bb0hvQixPQUFBO2dCQTNFcEJJO2dCQTRDVThCO2dCQTZCRVE7Z0JBREFEO2dCQURBRDs7O1NBbEJGSixhQVdTO01BbGJuQjFHO01Bc2JVLFdBN0dWc0U7TUE2R1UsT0FBQSxXQXBFVkksdUJBNENVOEI7Ozs7O2dCQWRORDtJQWFHOztZQW9DUFUsc0JBQXNCQyxZQUFXN0U7SUFDbkMsR0FqY0VwQyxnQkFxY0E7SUFyY0FBLHFCQWdjc0JpSDtJQVFoQixZQS9YSjlHO2tDQWdZVztJQUVSOztLQUR1QmtGO0tBQWI2QjtLQUNWLE9BQUEsa0JBRFVBLGdCQVZPRDtJQVdqQixXQUFBOzs7ZUFEdUI1Qiw2QkFBQUEsbUJBRXBCOEI7U0FBQUE7O09BS0Qsa0JBakIwQi9FLHNCQVl6QitFO0tBTUMsT0FBQTtJQXJYUC9HLGFBbVcrQmdDOztHQXFCNUI7WUFFTGdGLFVBQVVIO0lBQ1osWUF4ZEVqSDtnQkE2ZEE7SUFFRztLQURFaUM7S0FDRixPQUFBLGtCQURFQSxLQVBLZ0Y7S0FRUCxlQS9kSGpIOztHQStkNEM7WUFFNUNxSDtJQUFNckMsUUFBUXRELE9BQU91RCxNQUFNdEQsVUFBVXFFLGFBQWFuRSxXQUFXQyxTQUFRVTtJQUN2RSxPQTNGaUJ1QzthQTBGVEM7YUFBUXREO2FBQU91RDthQUFNdEQ7YUFBVXFFO2FBQWFuRTthQUFXQzthQUFRVTtzQkFFOUQ4RSxHQUFLLE9BQUxBLEVBQU07R0FBQztZQUVkQztJQUFXdkMsUUFBUXRELE9BQU91RCxNQUFNdEQsVUFBVXFFLGFBQWFuRSxXQUFXQyxTQUFRVTtJQUM1RSxPQS9GaUJ1QzthQThGSkM7YUFBUXREO2FBQU91RDthQUFNdEQ7YUFBVXFFO2FBQWFuRTthQUFXQzthQUFRVTs2QkFFN0QsU0FBSTtHQUFDO1lBRUhnRjtJQUFheEMsUUFBUXRELE9BQU91RCxNQUFlQyxjQUEwQkMsaUJBQ2xFdEQsV0FBV0MsU0FBUVU7SUFDakMsWUFsYUZyQztrQ0FtYVM7SUFFSDs7S0FEcUZrRjs7S0FBZEM7S0FBbERFO0tBQ3JCLE9BbkhSYixVQThHNEJLO0lBS3BCLFNBQUpTLHVDQUppQ2pEO0lBTVg7S0FBQSxPQXpXeEIvQjtLQXJHdUNnSCxlQThjdEIsdUJBUHdCeEM7S0FTekMsT0FBQSxlQUwyQk8sVUE3ZTdCeEY7SUFrZkU7O2FBTDZFc0Y7O2lCQTFjOURhO1NBQVcsbUNBQVhBLFNBRHdCc0I7UUFDUTtNQThjN0NuQixpQkE5Y1E7O1NBOGNSQTtJQVlKLEdBWklBO2VBSnlGakIseUJBa0JyRSxPQWphdEJoRjtLQW1hSyxJQURZK0IsWUFuQjBFaUQsZUFvQnRGLE9BL1pML0UsV0E4WmlCOEI7S0FDWjtNQXJnQlB4QztNQW1mQTtPQW9CVThGO1NBeFdWakUsZ0JBOFVvQ0M7V0FBc0J3RCxjQUEwQkMsaUJBQ2xFdEQsV0FBV0M7T0E5V3pCNEYsT0FIRmxIO01BQUFBLHVCQTBZUWtGLFNBMUJpQ1QsT0E3V3ZDeUM7TUFFSixJQXNZTSxJQXJZQUMsSUF3S043RCwrQkF1TUkyQixNQXJYRmpGLGVBR0VrSDtZQU1DRTtXQUFBQyx3QkFBQUQ7T0FUSHBILGVBR0VrSDtPQVFGLE1BQUEsNEJBRkdHOztlQUhDRixNQW1aVztvQkFuWlhBLE1Bb1pjN0Msd0JBQUxaO01BdGhCZnJFO01Bd2hCd0I7T0FBWmdILGNBdkpaaEMsY0FxSm9CQztPQUdSZ0MsVUFBVSxtQ0FIUDVDO09BSUg2QyxNQUFTLDhCQURURDtPQUdzRCxPQWpObEV6QztPQWlOVSxPQUFBLDhCQXRCQXFCO01Bc0J3RCxPQUFBO2VBeEtsRWpCLGlCQXVLeUI7O2VBRGJzQztlQURBRDtlQURBRDs7Ozs7O2dCQXBDUlA7SUFnQkc7O1lBNEJQd0I7SUFDSSxZQXJkRjNIOzswQkFrZTBDK0c7O01BcGM1QztPQUFBO3VCQUNxQmEsVUFBS0MsS0FBTyxXQUFaRCxHQUFLQyxLQUFlO09BQXZDLE9BQUE7T0FBQSxPQUFBO09BaWNRLE9BQUE7TUFBVjtNQUFBOzttQkF4WkE5RztxQkE2WlNzRixpQkFBTSx1QkFBTkE7S0F0TVRsQztTQXdPSTJELFFBamxCSmxJLGlCQWlsQldtSSxxQkFubEJYckk7Y0FtbEJJb0ksZUFBT0M7U0FwY1hwSDtPQXVhMkIsa0NBcmpCM0JoQixjQUZBRjtNQTRqQlU7Y0Fia0NzSDs4QkFhdEIsSUFBWXRCLDRCQUFBQSxRQUFtQjtPQUR6Q3VDLGVBQ0Y7T0FGQUMsU0FDRUQsbUJBQUFBO01BT04sR0FSSUM7V0FTR2xHLFFBVEhrRztPQVVGOzs7O1dBQ1UsSUFBZ0J2Qyw0QkFBVmxFO1dBQ2QsS0FEd0JrRTtZQUVkLE9BQUEsa0NBRklsRTtlQUdQcUUsY0FIaUJIO1dBR0YsT0FBQSxrQ0FIUmxFLFVBR1BxRTtVQUNSO09BSkQsa0NBRks5RDtPQU9MO09BQUE7O2VBeGtCUnBDLGdCQTZJQWU7T0ErYlU7T0FBQTs7TUFFTzs7Y0FJTnFIOzs7TUFFa0Q7T0FBQSxPQUFBO2NBQWYsbUNBRm5DQTtLQUNQLGtDQURBRCxPQWxsQkpuSTtLQW1sQkk7Ozs7S0FqREQsR0FBQTtNQUFzQztNQUFsQjtRQUFBO1VBQUEsbUVBQ3JCOztLQUdBOztJQUFBO0dBZ0RDO0dBUVU7SUFOYnVJLGNBamNBakg7SUFrY0FrSCxhQWpjQWpIO0lBa2NBa0gsaUJBamNBakg7SUFrY0FrSCxxQkFqY0FqSDtJQWtjQWtILDBCQWpjQWpIO0lBbWNBa0gscUJBL0RBWjtZQWdFQWEsY0FBZW5HLEdBRGZrRyxvQkFDZWxHLEdBRGZrRyx5QkFDaUQ7WUFDakRFO0lBQ3VCLFdBQUEsMkJBSHZCRjtrQkFHWWxHLEdBQUssT0FBQSxXQUFMQSxNQUFTO1dBL21CbkI5QyxZQSttQko7Ozs7Ozs7SUFBQSxPQUFBO0dBR087Ozs7V0F6bkJISCxTQU9BRyxhQWJBSjtPQTZkRjBIO09BdUJBSTtPQVVBQztPQUlBRTtPQUllQztPQWpOZjdEO09BOFRBMEU7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0EzVUEvRTtPQVBBckU7T0FxVkFzSjtPQUNBQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFRlc3RfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9IFN1Y2Nlc3MgfCBGYWlsdXJlIHwgRXJyb3JcblxuICBsZXQgdG9fZXhpdF9jb2RlID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gMFxuICAgIHwgRmFpbHVyZSAtPiAyXG4gICAgfCBFcnJvciAgIC0+IDFcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gXCJzdWNjZXNzXCJcbiAgICB8IEZhaWx1cmUgLT4gXCJmYWlsdXJlXCJcbiAgICB8IEVycm9yICAgLT4gXCJlcnJvclwiXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmUgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBTdWNjZXNzLCBTdWNjZXNzICAgICAgICAtPiBTdWNjZXNzXG4gICAgfCBFcnJvciAgLCBfIHwgXywgRXJyb3IgICAtPiBFcnJvclxuICAgIHwgRmFpbHVyZSwgXyB8IF8sIEZhaWx1cmUgLT4gRmFpbHVyZVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbCB0cyA9IExpc3QuZm9sZF9sZWZ0IGNvbWJpbmUgU3VjY2VzcyB0c1xuZW5kXG5cbmxldCBwYXJzZV9hcmd2IGFyZ3YgbCBmIG1zZyA9XG4gIHRyeVxuICAgIEFyZy5wYXJzZV9hcmd2IGFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQXJnLkJhZCBtc2cgLT4gUHJpbnRmLmVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAxXG4gIHwgQXJnLkhlbHAgbXNnIC0+IFByaW50Zi5wcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG47O1xuXG50eXBlIGRlc2NyID0gc3RyaW5nXG5sZXQgdGVzdF9tb2R1bGVzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdF9tb2R1bGVzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgdGVzdHNfcmFuID0gcmVmIDBcbmxldCB0ZXN0c19mYWlsZWQgPSByZWYgMFxubGV0IGR5bmFtaWNfbGliIDogc3RyaW5nIG9wdGlvbiByZWYgPSByZWYgTm9uZVxudHlwZSBmaWxlbmFtZSA9IHN0cmluZ1xudHlwZSBsaW5lX251bWJlciA9IGludFxudHlwZSBzdGFydF9wb3MgPSBpbnRcbnR5cGUgZW5kX3BvcyA9IGludFxudHlwZSBjb25maWcgPSAobW9kdWxlIElubGluZV90ZXN0X2NvbmZpZy5TKVxudHlwZSAnYSB0ZXN0X2Z1bmN0aW9uX2FyZ3NcbiAgPSBjb25maWc6Y29uZmlnXG4gIC0+IGRlc2NyOmRlc2NyIExhenkudFxuICAtPiB0YWdzOnN0cmluZyBsaXN0XG4gIC0+IGZpbGVuYW1lOmZpbGVuYW1lXG4gIC0+IGxpbmVfbnVtYmVyOmxpbmVfbnVtYmVyXG4gIC0+IHN0YXJ0X3BvczpzdGFydF9wb3NcbiAgLT4gZW5kX3BvczplbmRfcG9zXG4gIC0+ICdhXG5cbm1vZHVsZSBUYWdfcHJlZGljYXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyByZXF1aXJlZF90YWdzICA6IHN0cmluZyBsaXN0XG4gICAgOyBkcm9wcGVkX3RhZ3MgOiBzdHJpbmcgbGlzdFxuICAgIH1cblxuICBsZXQgZW5hYmxlX2V2ZXJ5dGhpbmcgPSB7IHJlcXVpcmVkX3RhZ3MgPSBbXTsgZHJvcHBlZF90YWdzID0gW10gfVxuXG4gIGxldCBkcm9wIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IHRhZyA6OiB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IExpc3QuZmlsdGVyICgoPD4pIHRhZykgdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuXG4gIGxldCByZXF1aXJlIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IExpc3QuZmlsdGVyICgoPD4pIHRhZykgdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSB0YWcgOjogdC5yZXF1aXJlZF90YWdzXG4gICAgfVxuXG4gIGxldCBlbnRpcmVfbW9kdWxlX2Rpc2FibGVkIHQgfnBhcnRpYWxfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuXG4gIGxldCBkaXNhYmxlZCB0IH5jb21wbGV0ZV90YWdzOnRhZ3MgPVxuICAgIExpc3QuZXhpc3RzIChmdW4gcmVxIC0+IG5vdCAoTGlzdC5tZW0gcmVxIHRhZ3MpKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB8fCBMaXN0LmV4aXN0cyAoZnVuIGRyb3BwZWQgLT4gTGlzdC5tZW0gZHJvcHBlZCB0YWdzKSB0LmRyb3BwZWRfdGFnc1xuZW5kXG5cblxudHlwZSB3aGljaF90ZXN0cyA9XG4gIHsgbGlibmFtZSA6IHN0cmluZ1xuICA7IG9ubHlfdGVzdF9sb2NhdGlvbiA6IChmaWxlbmFtZSAqIGxpbmVfbnVtYmVyIG9wdGlvbiAqIGJvb2wgcmVmKSBsaXN0XG4gIDsgbmFtZV9maWx0ZXIgOiBzdHJpbmcgbGlzdFxuICA7IHdoaWNoX3RhZ3MgOiBUYWdfcHJlZGljYXRlLnRcbiAgfVxudHlwZSB0ZXN0X21vZGUgPVxuICB7IHdoaWNoX3Rlc3RzIDogd2hpY2hfdGVzdHNcbiAgOyB3aGF0X3RvX2RvIDpcbiAgICAgIFsgYFJ1bl9wYXJ0aXRpb24gb2Ygc3RyaW5nIG9wdGlvblxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zXG4gICAgICBdXG4gIH1cblxubW9kdWxlIEFjdGlvbiA6IHNpZ1xuICB0eXBlIHQgPSBbXG4gICAgfCBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICBdXG4gIHZhbCBnZXQgOiB1bml0IC0+IHRcbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IFtcbiAgICB8IGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gIF1cbiAgbGV0IGFjdGlvbiA6IHQgcmVmID0gcmVmIGBJZ25vcmVcbiAgbGV0IGZvcmNlX2Ryb3AgPVxuICAgIHRyeSBpZ25vcmUgKFN5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCIgOiBzdHJpbmcpOyB0cnVlXG4gICAgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcbiAgbGV0IGdldCAoKSA9XG4gICAgKCogVGhpcyBpcyB1c2VmdWwgd2hlbiBjb21waWxpbmcgdG8gamF2YXNjcmlwdC5cbiAgICAgICBKc19vZl9vY2FtbCBjYW4gc3RhdGljYWxseSBldmFsdWF0ZSBbU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIl1cbiAgICAgICBhbmQgaW5saW5lIHRoZSByZXN1bHQgKFtgSWdub3JlXSkgd2hlbmV2ZXIgW2dldCAoKV0gaXMgY2FsbGVkLlxuICAgICAgIFVuaXQgdGVzdHMgY2FuIHRoZW4gYmUgdHJlYXRlZCBhcyBkZWFkY29kZSBzaW5jZSB0aGUgYXJndW1lbnQgW2ZdIG9mIHRoZSBbdGVzdF1cbiAgICAgICBmdW5jdGlvbiBiZWxvdyBpcyBuZXZlciB1c2VkLiAqKVxuICAgIGlmIGZvcmNlX2Ryb3BcbiAgICB0aGVuIGBJZ25vcmVcbiAgICBlbHNlICFhY3Rpb25cblxuICBsZXQgc2V0IHYgPSBhY3Rpb24gOj0gdlxuZW5kXG5cbm1vZHVsZSBQYXJ0aXRpb24gOiBzaWdcbiAgdmFsIGZvdW5kX3Rlc3QgOiB1bml0IC0+IHVuaXRcbiAgdmFsIHNldF9jdXJyZW50IDogc3RyaW5nIC0+IHVuaXRcbiAgdmFsIGlzX2N1cnJlbnQgOiBzdHJpbmcgb3B0aW9uIC0+IGJvb2xcbiAgdmFsIGFsbCA6IHVuaXQgLT4gc3RyaW5nIGxpc3RcbmVuZCA9IHN0cnVjdFxuICBsZXQgYWxsID0gSGFzaHRibC5jcmVhdGUgMjNcbiAgbGV0IGN1cnJlbnQgPSByZWYgXCJcIiAgbGV0IHNldF9jdXJyZW50IHggPSBjdXJyZW50IDo9IHhcbiAgbGV0IGZvdW5kX3Rlc3QgKCkgPVxuICAgIGlmICFjdXJyZW50IDw+IFwiXCIgJiYgbm90IChIYXNodGJsLm1lbSBhbGwgIWN1cnJlbnQpIHRoZW5cbiAgICAgIEhhc2h0YmwuYWRkIGFsbCAhY3VycmVudCAoKVxuICA7O1xuICBsZXQgaXNfY3VycmVudCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgcCAtPiBwID0gIWN1cnJlbnRcbiAgOztcbiAgbGV0IGFsbCAoKSA9XG4gICAgTGlzdC5zb3J0IFN0cmluZy5jb21wYXJlXG4gICAgICAoSGFzaHRibC5mb2xkIChmdW4gayAoKSBhY2MgLT4gayA6OiBhY2MpIGFsbCBbXSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTW9kdWxlX2NvbnRleHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIG9uZV9tb2R1bGUgPVxuICAgICAgeyBkZXNjciA6IHN0cmluZ1xuICAgICAgOyB0YWdzIDogc3RyaW5nIGxpc3RcbiAgICAgIH1cblxuICAgIHR5cGUgdCA9IG9uZV9tb2R1bGUgbGlzdFxuXG4gICAgbGV0IGRlc2NyIHQgPSBMaXN0Lm1hcCAoZnVuIG0gLT4gbS5kZXNjcikgdFxuICAgIGxldCB0YWdzIHQgPSBMaXN0LmNvbmNhdCAoTGlzdC5tYXAgKGZ1biBtIC0+IG0udGFncykgdClcbiAgZW5kXG5cbiAgbGV0IGN1cnJlbnQgOiBULnQgcmVmID0gcmVmIFtdXG5cbiAgbGV0IHdpdGhfIH5kZXNjciB+dGFncyBmID1cbiAgICBsZXQgcHJldiA9ICFjdXJyZW50IGluXG4gICAgY3VycmVudCA6PSB7IFQuIGRlc2NyOyB0YWdzIH0gOjogcHJldjtcbiAgICB0cnlcbiAgICAgIGxldCB4ID0gZiAoKSBpblxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgeFxuICAgIHdpdGggZSAtPlxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgcmFpc2UgZVxuXG4gIGxldCBjdXJyZW50X2Rlc2NyICgpID0gVC5kZXNjciAhY3VycmVudFxuICBsZXQgY3VycmVudF90YWdzICAoKSA9IFQudGFncyAgIWN1cnJlbnRcbmVuZFxuXG5sZXQgdmVyYm9zZSA9IHJlZiBmYWxzZVxubGV0IHN0cmljdCA9IHJlZiBmYWxzZVxubGV0IHNob3dfY291bnRzID0gcmVmIGZhbHNlXG5sZXQgbGlzdF90ZXN0X25hbWVzID0gcmVmIGZhbHNlXG5sZXQgZGVsYXllZF9lcnJvcnMgPSByZWYgW11cbmxldCBzdG9wX29uX2Vycm9yID0gcmVmIGZhbHNlXG5cbmxldCBsb2cgPSByZWYgTm9uZVxuXG5sZXQgdGltZV9zZWMgPSByZWYgMC5cblxubGV0IHVzZV9jb2xvciA9IHJlZiB0cnVlXG5sZXQgaW5fcGxhY2UgID0gcmVmIGZhbHNlXG5sZXQgZGlmZl9jb21tYW5kID0gcmVmIE5vbmVcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gcmVmIE5vbmVcbmxldCBhbGxvd19vdXRwdXRfcGF0dGVybnMgPSByZWYgZmFsc2VcblxubGV0IGRpc3BsYXllZF9kZXNjciAobGF6eSBkZXNjcikgZmlsZW5hbWUgbGluZSBzdGFydF9wb3MgZW5kX3BvcyA9XG4gIFByaW50Zi5zcHJpbnRmIFwiRmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZCVzXCJcbiAgICBmaWxlbmFtZSBsaW5lIHN0YXJ0X3BvcyBlbmRfcG9zXG4gICAgKGlmIGRlc2NyID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBcIjogXCIgXiBkZXNjcilcbmxldCBwYXJzZV9kZXNjciBzdHIgPVxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICwgbGluZSAlZCAsIGNoYXJhY3RlcnMgJWQgLSAlZCAlIVwiXG4gICAgICAgICAgICAgIChmdW4gZmlsZSBsaW5lIF9zdGFydF9wb3MgX2VuZF9wb3MgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgd2l0aCBfIC0+XG4gIHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgLCBsaW5lICVkICUhXCIgKGZ1biBmaWxlIGxpbmUgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgd2l0aCBfIC0+XG4gIHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgJSFcIiAoZnVuIGZpbGUgLT4gZmlsZSwgTm9uZSkpXG4gIHdpdGggXyAtPiBOb25lXG5cbmxldCAoKSA9XG4gIG1hdGNoIEFycmF5LnRvX2xpc3QgU3lzLmFyZ3Ygd2l0aFxuICB8IG5hbWUgOjogXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiA6OiBsaWIgOjogcmVzdFxuICAgIHdoZW4gQmFzZS5FeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcy5hbV90ZXN0aW5nIC0+IGJlZ2luXG4gICAgICAoKiB3aGVuIHdlIHNlZSB0aGlzIGFyZ3VtZW50LCB3ZSBzd2l0Y2ggdG8gdGVzdCBtb2RlICopXG4gICAgICBsZXQgdGVzdHMgPSByZWYgW10gaW5cbiAgICAgIGxldCBsaXN0X3BhcnRpdGlvbnMgPSByZWYgZmFsc2UgaW5cbiAgICAgIGxldCBwYXJ0aXRpb24gPSByZWYgTm9uZSBpblxuICAgICAgbGV0IHRhZ19wcmVkaWNhdGUgPSByZWYgVGFnX3ByZWRpY2F0ZS5lbmFibGVfZXZlcnl0aGluZyBpblxuICAgICAgbGV0IG5hbWVfZmlsdGVyID0gcmVmIFtdIGluXG4gICAgICBwYXJzZV9hcmd2IChBcnJheS5vZl9saXN0IChuYW1lIDo6IHJlc3QpKSAoQXJnLmFsaWduIFtcbiAgICAgICAgXCItbGlzdC10ZXN0LW5hbWVzXCIsIEFyZy5Vbml0IChmdW4gKCkgLT4gbGlzdF90ZXN0X25hbWVzIDo9IHRydWU7IHZlcmJvc2UgOj0gdHJ1ZSksXG4gICAgICAgIFwiIERvIG5vdCBydW4gdGVzdHMgYnV0IHNob3cgd2hhdCB3b3VsZCBoYXZlIGJlZW4gcnVuXCI7XG4gICAgICAgIFwiLWxpc3QtcGFydGl0aW9uc1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+IGxpc3RfcGFydGl0aW9ucyA6PSB0cnVlKSxcbiAgICAgICAgXCIgTGlzdHMgYWxsIHRoZSBwYXJ0aXRpb25zIHRoYXQgY29udGFpbiBhdCBsZWFzdCBvbmUgdGVzdCBvciB0ZXN0X21vZHVsZVwiO1xuICAgICAgICBcIi1wYXJ0aXRpb25cIiwgQXJnLlN0cmluZyAoZnVuIGkgLT4gcGFydGl0aW9uIDo9IFNvbWUgaSksXG4gICAgICAgIFwiIE9ubHkgcnVuIHRoZSB0ZXN0cyBpbiB0aGUgZ2l2ZW4gcGFydGl0aW9uXCI7XG4gICAgICAgIFwiLXZlcmJvc2VcIiwgQXJnLlNldCB2ZXJib3NlLCBcIiBTaG93IHRoZSB0ZXN0cyBhcyB0aGV5IHJ1blwiO1xuICAgICAgICBcIi1zdG9wLW9uLWVycm9yXCIsIEFyZy5TZXQgc3RvcF9vbl9lcnJvciwgXCIgUnVuIHRlc3RzIG9ubHkgdXAgdG8gdGhlIGZpcnN0IGVycm9yIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2Vzbid0IHdvcmsgZm9yIGV4cGVjdCB0ZXN0cylcIjtcbiAgICAgICAgXCItc3RyaWN0XCIsIEFyZy5TZXQgc3RyaWN0LCBcIiBFbmQgd2l0aCBhbiBlcnJvciBpZiBubyB0ZXN0cyB3ZXJlIHJ1blwiO1xuICAgICAgICBcIi1zaG93LWNvdW50c1wiLCBBcmcuU2V0IHNob3dfY291bnRzLCBcIiBTaG93IHRoZSBudW1iZXIgb2YgdGVzdHMgcmFuXCI7XG4gICAgICAgIFwiLWxvZ1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+XG4gICAgICAgICAgKHRyeSBTeXMucmVtb3ZlIFwiaW5saW5lX3Rlc3RzLmxvZ1wiIHdpdGggXyAtPiAoKSk7XG4gICAgICAgICAgbG9nIDo9IFNvbWUgKG9wZW5fb3V0IFwiaW5saW5lX3Rlc3RzLmxvZ1wiKVxuICAgICAgICApLCBcIiBMb2cgdGhlIHRlc3RzIHJ1biBpbiBpbmxpbmVfdGVzdHMubG9nXCI7XG4gICAgICAgIFwiLWRyb3AtdGFnXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLmRyb3AgIXRhZ19wcmVkaWNhdGUgc1xuICAgICAgICApLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyBub3QgdGFnZ2VkIHdpdGggW3RhZ10gKG92ZXJyaWRlcyBwcmV2aW91cyAtcmVxdWlyZS10YWcpXCI7XG4gICAgICAgIFwiLXJlcXVpcmUtdGFnXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLnJlcXVpcmUgIXRhZ19wcmVkaWNhdGUgc1xuICAgICAgICApLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1kcm9wLXRhZylcIjtcbiAgICAgICAgXCItbWF0Y2hpbmdcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gbmFtZV9maWx0ZXIgOj0gcyA6OiAhbmFtZV9maWx0ZXIpLFxuICAgICAgICBcInN1YnN0cmluZyBPbmx5IHJ1biB0ZXN0cyB3aG9zZSBuYW1lcyBjb250YWluIHRoZSBnaXZlbiBzdWJzdHJpbmdcIjtcbiAgICAgICAgXCItb25seS10ZXN0XCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+XG4gICAgICAgICAgbGV0IGZpbGVuYW1lLCBpbmRleCA9XG4gICAgICAgICAgICBtYXRjaCBwYXJzZV9kZXNjciBzIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSAoZmlsZSwgaW5kZXgpIC0+IGZpbGUsIGluZGV4XG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHMgJzonIHRoZW5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc6JyBpblxuICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IFN0cmluZy5zdWIgcyAwIGkgaW5cbiAgICAgICAgICAgICAgICBsZXQgaW5kZXhfc3RyaW5nID0gU3RyaW5nLnN1YiBzIChpICsgMSkgKFN0cmluZy5sZW5ndGggcyAtIGkgLSAxKSBpblxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9XG4gICAgICAgICAgICAgICAgICB0cnkgaW50X29mX3N0cmluZyBpbmRleF9zdHJpbmdcbiAgICAgICAgICAgICAgICAgIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgICAgXCJBcmd1bWVudCAlcyBkb2Vzbid0IGZpdCB0aGUgZm9ybWF0IGZpbGVuYW1lWzpsaW5lX251bWJlcl1cXG4lIVwiIHM7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgMVxuICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUsIFNvbWUgaW5kZXhcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHMsIE5vbmVcbiAgICAgICAgICBpblxuICAgICAgICAgIHRlc3RzIDo9IChmaWxlbmFtZSwgaW5kZXgsIHJlZiBmYWxzZSkgOjogIXRlc3RzXG4gICAgICAgICksIFwibG9jYXRpb24gUnVuIG9ubHkgdGhlIHRlc3RzIHNwZWNpZmllZCBieSBhbGwgdGhlIC1vbmx5LXRlc3Qgb3B0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICBMb2NhdGlvbnMgY2FuIGJlIG9uZSBvZiB0aGVzZSBmb3JtczpcbiAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWxcbiAgICAgICAgICAgICAgICAgICAgICAtIGZpbGUubWw6bGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyM1xuICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCIsIGxpbmUgMjMsIGNoYXJhY3RlcnMgMi0zXCI7XG4gICAgICAgIFwiLW5vLWNvbG9yXCIsIEFyZy5DbGVhciB1c2VfY29sb3IsIFwiIFN1bW1hcml6ZSB0ZXN0cyB3aXRob3V0IHVzaW5nIGNvbG9yXCI7XG4gICAgICAgIFwiLWluLXBsYWNlXCIsIEFyZy5TZXQgaW5fcGxhY2UsIFwiIFVwZGF0ZSBleHBlY3QgdGVzdHMgaW4gcGxhY2VcIjtcbiAgICAgICAgXCItZGlmZi1jbWRcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gZGlmZl9jb21tYW5kIDo9IFNvbWUgcyksXG4gICAgICAgIFwiIERpZmYgY29tbWFuZCBmb3IgdGVzdHMgdGhhdCByZXF1aXJlIGRpZmZpbmcgKHVzZSAtIHRvIGRpc2FibGUgZGlmZmluZylcIjtcbiAgICAgICAgXCItYWxsb3ctb3V0cHV0LXBhdHRlcm5zXCIsIEFyZy5TZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zLFxuICAgICAgICBcIiBBbGxvdyBvdXRwdXQgcGF0dGVybnMgaW4gdGVzdHMgZXhwZWN0YXRpb25zXCI7XG4gICAgICAgIFwiLXNvdXJjZS10cmVlLXJvb3RcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT4gc291cmNlX3RyZWVfcm9vdCA6PSBTb21lIHMpLFxuICAgICAgICBcIiBQYXRoIHRvIHRoZSByb290IG9mIHRoZSBzb3VyY2UgdHJlZVwiXG4gICAgICBdKSAoZnVuIGFub24gLT5cbiAgICAgICAgUHJpbnRmLmVwcmludGYgXCIlczogdW5leHBlY3RlZCBhbm9ueW1vdXMgYXJndW1lbnQgJXNcXG4lIVwiIG5hbWUgYW5vbjtcbiAgICAgICAgZXhpdCAxXG4gICAgICApIChQcmludGYuc3ByaW50ZiBcIiVzICVzICVzIFthcmdzXVwiIG5hbWUgXCJpbmxpbmUtdGVzdC1ydW5uZXJcIiBsaWIpO1xuICAgICAgQWN0aW9uLnNldCAoXG4gICAgICAgIGBUZXN0X21vZGVcbiAgICAgICAgICB7IHdoaWNoX3Rlc3RzID1cbiAgICAgICAgICAgICAgeyBsaWJuYW1lID0gbGliXG4gICAgICAgICAgICAgIDsgb25seV90ZXN0X2xvY2F0aW9uID0gIXRlc3RzO1xuICAgICAgICAgICAgICAgIHdoaWNoX3RhZ3MgPSAhdGFnX3ByZWRpY2F0ZTtcbiAgICAgICAgICAgICAgICBuYW1lX2ZpbHRlciA9ICFuYW1lX2ZpbHRlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgOyB3aGF0X3RvX2RvID1cbiAgICAgICAgICAgICAgaWYgIWxpc3RfcGFydGl0aW9uc1xuICAgICAgICAgICAgICB0aGVuIGBMaXN0X3BhcnRpdGlvbnNcbiAgICAgICAgICAgICAgZWxzZSBgUnVuX3BhcnRpdGlvbiAhcGFydGl0aW9uXG4gICAgICAgICAgfSlcbiAgICBlbmRcbiAgfCBfIC0+XG4gICAgKClcblxubGV0IGFtX3Rlc3RfcnVubmVyID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYFRlc3RfbW9kZSBfIC0+IHRydWVcbiAgfCBgSWdub3JlIC0+IGZhbHNlXG5cbmxldCBhbV9ydW5uaW5nX2lubGluZV90ZXN0X2Vudl92YXIgPVxuICAoKiBmb3IgYXBwcm94aW1hdGUgY29tcGF0aWJpbGl0eSwgZ2l2ZW4gdGhhdCB0aGUgdmFyaWFibGUgaXMgbm90IGV4YWN0bHkgZXF1aXZhbGVudFxuICAgICB0byB3aGF0IFBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVCB1c2VkIHRvIGJlICopXG4gIFwiVEVTVElOR19GUkFNRVdPUktcIlxuXG4oKiBUaGlzIHZhbHVlIGlzIGRlcHJlY2F0ZWQgaW4gcHJpbmNpcGxlLCBpbiBmYXZvciBvZiBDb3JlLmFtX3J1bm5pbmdfdGVzdCwgc29cbiAgIHdlJ3JlIGdvaW5nIHRvIGxpdmUgd2l0aCB0aGUgdWdseSBwYXR0ZXJuIG1hdGNoLiAqKVxubGV0IGFtX3J1bm5pbmdfaW5saW5lX3Rlc3QgPVxuICBtYXRjaCBTeXMuZ2V0ZW52IFwiUFBYX0lOTElORV9URVNUX0xJQl9BTV9SVU5OSU5HX0lOTElORV9URVNUXCIgd2l0aFxuICB8IChfIDogc3RyaW5nKSAtPiB0cnVlICgqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcGVvcGxlIHNldHRpbmcgdGhpcyB2YXJpYWJsZSBkaXJlY3RseSAqKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICBtYXRjaCBTeXMuZ2V0ZW52IGFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciB3aXRoXG4gICAgfCBcImlubGluZS10ZXN0XCIgLT4gdHJ1ZVxuICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBmYWxzZVxuICAgIHwgXyAtPiBmYWxzZVxuXG5sZXQgdGVzdGluZyA9XG4gIGlmIGFtX3Rlc3RfcnVubmVyXG4gIHRoZW4gYFRlc3RpbmcgYEFtX3Rlc3RfcnVubmVyXG4gIGVsc2VcbiAgICAoaWYgYW1fcnVubmluZ19pbmxpbmVfdGVzdFxuICAgICB0aGVuIGBUZXN0aW5nIGBBbV9jaGlsZF9vZl90ZXN0X3J1bm5lclxuICAgICBlbHNlIGBOb3RfdGVzdGluZylcblxubGV0IHdhbGxfdGltZV9jbG9ja19ucyAoKSA9XG4gIFRpbWVfbm93Lm5hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2ggKClcblxuXG5sZXQgd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSA9IGxhenkgKFxuICBCYXNlLlN0cmluZy5TZWFyY2hfcGF0dGVybi5jcmVhdGUgKF9fTU9EVUxFX18gXiBcIi5cIiBeIFwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNcIikpXG5cbmxldCB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmID1cbiAgbGV0IGJlZm9yZV9ucyA9IHdhbGxfdGltZV9jbG9ja19ucyAoKSBpblxuICBsZXQgcmVzID1cbiAgICAoKiBUbyBhdm9pZCBub2lzZSBpbiBiYWNrdHJhY2VzLCB3ZSBkbyB0d28gdGhpbmdzLlxuXG4gICAgICAgV2UgdXNlIFt3aGVyZV90b19jdXRfYmFja3RyYWNlXSBhYm92ZSB0byByZW1vdmUgdGhlIHN0YWNrIGZyYW1lcyBmb3IgdGhlIGN1cnJlbnRcbiAgICAgICBmdW5jdGlvbiBhbmQgYW55IGZ1bmN0aW9uIGl0IGdldHMgaW5saW5lZCBpbnRvLCBhcyBpdCdzIG5vdCBvZiBhbnkgaW50ZXJlc3QgdG8gdGhlXG4gICAgICAgdXNlciwgc2luY2UgaXQncyBub3QgdGFsa2luZyBhYm91dCB0aGVpciB0ZXN0IGJ1dCBpbnN0ZWFkIHRhbGtpbmcgYWJvdXQgdGhlXG4gICAgICAgcHB4X2lubGluZV90ZXN0IG1hY2hpbmVyeS5cblxuICAgICAgIFdlIGFsc28gYXZvaWQgaW5zZXJ0aW5nIGFueSBjb2RlIGJldHdlZW4gdGhlIFtmXSB0aGF0IGNvbWVzIGZyb20gdGhlIHVzZXIncyBmaWxlXG4gICAgICAgYW5kIGdyYWJiaW5nIHRoZSBiYWNrdHJhY2UgZnJvbSBpdHMgZXhjZXB0aW9ucyAobm8gd3JhcHBpbmcgb2YgW2ZdIHdpdGggaGlnaCBvcmRlclxuICAgICAgIGZ1bmN0aW9ucyBsaWtlIEV4bi5wcm90ZWN0LCBvciAoZnVuICgpIC0+IGYgKCk7IHRydWUpKS4gKilcbiAgICB0cnkgT2sgKGYgKCkpXG4gICAgd2l0aCBleG4gLT4gRXJyb3IgKGV4biwgUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgaW5cbiAgdGltZV9zZWMgOj0gQmFzZS5JbnQ2My4od2FsbF90aW1lX2Nsb2NrX25zICgpIC0gYmVmb3JlX25zIHw+IHRvX2Zsb2F0KSAgLy4gMWU5O1xuICByZXNcblxuXG5sZXQgc2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUgPSBsYXp5IChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2UgW3wgMTAwOyAyMDA7IDMwMCB8XSlcbmxldCBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSA9IGxhenkgKEJhc2UuUmFuZG9tLlN0YXRlLm1ha2UgW3wgMTExOyAyMjI7IDMzMyB8XSlcblxubGV0IHRpbWVfYW5kX3Jlc2V0X3JhbmRvbV9zZWVkcyBmID1cbiAgbGV0IGNhbWxfcmFuZG9tX3N0YXRlID0gU3RkbGliLlJhbmRvbS5nZXRfc3RhdGUgKCkgaW5cbiAgbGV0IGJhc2VfcmFuZG9tX3N0YXRlID0gQmFzZS5SYW5kb20uU3RhdGUuY29weSBCYXNlLlJhbmRvbS5TdGF0ZS5kZWZhdWx0IGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIChMYXp5LmZvcmNlIHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlKTtcbiAgQmFzZS5SYW5kb20uc2V0X3N0YXRlIChMYXp5LmZvcmNlIHNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlKTtcbiAgbGV0IHJlc3VsdCA9IHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYgaW5cbiAgU3RkbGliLlJhbmRvbS5zZXRfc3RhdGUgY2FtbF9yYW5kb21fc3RhdGU7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSBiYXNlX3JhbmRvbV9zdGF0ZTtcbiAgcmVzdWx0XG5cbmxldCBzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpID1cbiAgU3RyaW5nLmNvbmNhdCBcIlwiIChcbiAgICBMaXN0Lm1hcCAoZnVuIHMgLT4gXCIgIGluIFRFU1wiIF4gXCJUX01PRFVMRSBhdCBcIiBeIFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkgcyBeIFwiXFxuXCIpXG4gICAgICAoTW9kdWxlX2NvbnRleHQuY3VycmVudF9kZXNjciAoKSlcbiAgKVxuXG5sZXQgcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBsID1cbiAgTGlzdC5leGlzdHMgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgdXNlZCkgLT5cbiAgICBsZXQgcG9zaXRpb25fc3RhcnQgPVxuICAgICAgU3RyaW5nLmxlbmd0aCBkZWZfZmlsZW5hbWUgLSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgbGV0IGZvdW5kID1cbiAgICAgIHBvc2l0aW9uX3N0YXJ0ID49IDAgJiZcbiAgICAgIGxldCBlbmRfb2ZfZGVmX2ZpbGVuYW1lID1cbiAgICAgICAgU3RyaW5nLnN1YiBkZWZfZmlsZW5hbWVcbiAgICAgICAgICBwb3NpdGlvbl9zdGFydFxuICAgICAgICAgIChTdHJpbmcubGVuZ3RoIGZpbGVuYW1lKSBpblxuICAgICAgZW5kX29mX2RlZl9maWxlbmFtZSA9IGZpbGVuYW1lXG4gICAgICAmJiAocG9zaXRpb25fc3RhcnQgPSAwIHx8IGRlZl9maWxlbmFtZS5bcG9zaXRpb25fc3RhcnQgLSAxXSA9ICcvJylcbiAgICAgICYmIChtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgbGluZV9udW1iZXIgLT4gZGVmX2xpbmVfbnVtYmVyID0gbGluZV9udW1iZXIpXG4gICAgaW5cbiAgICBpZiBmb3VuZCB0aGVuIHVzZWQgOj0gdHJ1ZTtcbiAgICBmb3VuZFxuICApIGxcblxubGV0IG5hbWVfZmlsdGVyX21hdGNoIH5uYW1lX2ZpbHRlciBkZXNjciA9XG4gIG1hdGNoIG5hbWVfZmlsdGVyIHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyA6OiBfIC0+XG4gICAgTGlzdC5leGlzdHMgKGZ1biBzdWJzdHJpbmcgLT4gQmFzZS5TdHJpbmcuaXNfc3Vic3RyaW5nIH5zdWJzdHJpbmcgZGVzY3IpIG5hbWVfZmlsdGVyXG5cbmxldCBwcmludF9kZWxheWVkX2Vycm9ycyAoKSA9XG4gIG1hdGNoIExpc3QucmV2ICFkZWxheWVkX2Vycm9ycyB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBfIDo6IF8gYXMgZGVsYXllZF9lcnJvcnMgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIlxcbiVzXFxuJSFcIiAoU3RyaW5nLm1ha2UgNzAgJz0nKTtcbiAgICBMaXN0Lml0ZXIgKGZ1biBtZXNzYWdlIC0+XG4gICAgICBQcmludGYuZXByaW50ZiBcIiVzJSFcIiBtZXNzYWdlXG4gICAgKSBkZWxheWVkX2Vycm9yc1xuXG5sZXQgZXByaW50Zl9vcl9kZWxheSBmbXQgPVxuICBQcmludGYua3NwcmludGYgKGZ1biBzIC0+XG4gICAgaWYgIXZlcmJvc2UgdGhlbiBkZWxheWVkX2Vycm9ycyA6PSBzIDo6ICFkZWxheWVkX2Vycm9yc1xuICAgIGVsc2UgUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgcztcbiAgICBpZiAhc3RvcF9vbl9lcnJvciB0aGVuIGJlZ2luXG4gICAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAgIGV4aXQgMlxuICAgIGVuZFxuICApIGZtdFxuXG5sZXQgYWRkX2hvb2tzICgobW9kdWxlIEMpIDogY29uZmlnKSBmID1cbiAgZnVuICgpIC0+IEMucHJlX3Rlc3RfaG9vayAoKTsgZiAoKVxuXG5sZXQgaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgPVxuICBsZXQgb3BlbiBCYXNlIGluXG4gIGJhY2t0cmFjZVxuICB8PiBTdHJpbmcuc3BsaXRfbGluZXNcbiAgfD4gTGlzdC50YWtlX3doaWxlIH5mOihmdW4gc3RyIC0+XG4gICAgbm90IChTdHJpbmcuU2VhcmNoX3BhdHRlcm4ubWF0Y2hlcyAoZm9yY2Ugd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSkgc3RyKSlcbiAgfD4gTGlzdC5tYXAgfmY6KGZ1biBzdHIgLT4gXCIgIFwiIF4gc3RyIF4gXCJcXG5cIilcbiAgfD4gU3RyaW5nLmNvbmNhdFxuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgIH5zdGFydF9wb3MgfmVuZF9wb3MgZiBib29sX29mX2YgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0geyBsaWJuYW1lOyBvbmx5X3Rlc3RfbG9jYXRpb247IHdoaWNoX3RhZ3M7IG5hbWVfZmlsdGVyIH07IHdoYXRfdG9fZG8gfSAtPlxuICAgIGxldCBmID0gYWRkX2hvb2tzIGNvbmZpZyBmIGluXG4gICAgbGV0IGRlc2NyID0gbGF6eSAoZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MpIGluXG4gICAgbGV0IGNvbXBsZXRlX3RhZ3MgPSB0YWdzIEAgTW9kdWxlX2NvbnRleHQuY3VycmVudF90YWdzICgpIGluXG4gICAgbGV0IHNob3VsZF9ydW4gPVxuICAgICAgU29tZSBsaWJuYW1lID0gIWR5bmFtaWNfbGliXG4gICAgICAmJiBiZWdpbiBtYXRjaCBvbmx5X3Rlc3RfbG9jYXRpb24gd2l0aFxuICAgICAgICB8IFtdIC0+IHRydWVcbiAgICAgICAgfCBfIDo6IF8gLT4gcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBvbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgIGVuZFxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmRpc2FibGVkIHdoaWNoX3RhZ3MgfmNvbXBsZXRlX3RhZ3MpXG4gICAgICAmJiBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgKExhenkuZm9yY2UgZGVzY3IpXG4gICAgaW5cbiAgICBpZiBzaG91bGRfcnVuIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIC0+IFBhcnRpdGlvbi5mb3VuZF90ZXN0ICgpXG4gICAgICB8IGBSdW5fcGFydGl0aW9uIHBhcnRpdGlvbiAtPlxuICAgICAgICBpZiBQYXJ0aXRpb24uaXNfY3VycmVudCBwYXJ0aXRpb24gdGhlbiBiZWdpblxuICAgICAgICAgIGxldCBkZXNjciA9IExhenkuZm9yY2UgZGVzY3IgaW5cbiAgICAgICAgICBpbmNyIHRlc3RzX3JhbjtcbiAgICAgICAgICBiZWdpbiBtYXRjaCAhbG9nIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgY2ggLT4gUHJpbnRmLmZwcmludGYgY2ggXCIlc1xcbiVzXCIgZGVzY3IgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCIlcyUhXCIgZGVzY3JcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9XG4gICAgICAgICAgICBpZiAhbGlzdF90ZXN0X25hbWVzXG4gICAgICAgICAgICB0aGVuIE9rIHRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKCogU2VlIFt0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkc10gZm9yIHdoeSB3ZSB1c2UgW2Jvb2xfb2ZfZl1cbiAgICAgICAgICAgICAgICAgcmF0aGVyIGhhdmUgdGhlIGNhbGxlciB3cmFwIFtmXSB0byBhZGp1c3QgaXRzIHJldHVybiB2YWx1ZS4gKilcbiAgICAgICAgICAgICAgUmVzdWx0Lm1hcCBib29sX29mX2YgKHRpbWVfYW5kX3Jlc2V0X3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogSWYgIWxpc3RfdGVzdF9uYW1lcywgdGhpcyBpcyBpcyBhIGhhcm1sZXNzIHplcm8uICopXG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBQcmludGYucHJpbnRmIFwiICglLjNmIHNlYylcXG4lIVwiICF0aW1lX3NlYztcbiAgICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICAgIHwgT2sgdHJ1ZSAtPiAoKVxuICAgICAgICAgIHwgT2sgZmFsc2UgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdHNfZmFpbGVkO1xuICAgICAgICAgICAgZXByaW50Zl9vcl9kZWxheSBcIiVzIGlzIGZhbHNlLlxcbiVzXFxuJSFcIiBkZXNjclxuICAgICAgICAgICAgICAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSlcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdHNfZmFpbGVkO1xuICAgICAgICAgICAgbGV0IGJhY2t0cmFjZSA9IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlIGluXG4gICAgICAgICAgICBsZXQgZXhuX3N0ciA9IFNleHBsaWIwLlNleHBfY29udi5wcmludGV4Y19wcmVmZXJfc2V4cCBleG4gaW5cbiAgICAgICAgICAgIGxldCBzZXAgPSBpZiBTdHJpbmcuY29udGFpbnMgZXhuX3N0ciAnXFxuJyB0aGVuIFwiXFxuXCIgZWxzZSBcIiBcIiBpblxuICAgICAgICAgICAgZXByaW50Zl9vcl9kZWxheSBcIiVzIHRocmV3JXMlcy5cXG4lcyVzXFxuJSFcIiBkZXNjciBzZXAgZXhuX3N0clxuICAgICAgICAgICAgICBiYWNrdHJhY2UgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuXG5sZXQgc2V0X2xpYl9hbmRfcGFydGl0aW9uIHN0YXRpY19saWIgcGFydGl0aW9uID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBTb21lIF8gLT5cbiAgICAoKiBwb3NzaWJsZSBpZiB0aGUgaW50ZXJmYWNlIGlzIHVzZWQgZXhwbGljaXRseSBvciBpZiB3ZSBoYXBwZW4gdG8gZHlubGluayBzb21ldGhpbmdcbiAgICAgICB0aGF0IGNvbnRhaW4gdGVzdHMgKilcbiAgICAoKVxuICB8IE5vbmUgLT5cbiAgICBkeW5hbWljX2xpYiA6PSBTb21lIHN0YXRpY19saWI7XG4gICAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gICAgfCBgSWdub3JlIC0+ICgpXG4gICAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHM7IHdoYXRfdG9fZG8gfSAtPlxuICAgICAgaWYgd2hpY2hfdGVzdHMubGlibmFtZSA9IHN0YXRpY19saWIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcmVxdWlyZXNfcGFydGl0aW9uID1cbiAgICAgICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgfCBgUnVuX3BhcnRpdGlvbiAoU29tZSBfKSAtPiB0cnVlXG4gICAgICAgICAgfCBgUnVuX3BhcnRpdGlvbiBOb25lIC0+IGZhbHNlXG4gICAgICAgIGluXG4gICAgICAgIGlmIHBhcnRpdGlvbiA9IFwiXCIgJiYgcmVxdWlyZXNfcGFydGl0aW9uXG4gICAgICAgIHRoZW4gZmFpbHdpdGggXCJwcHhfaW5saW5lX3Rlc3Q6IGNhbm5vdCB1c2UgLWxpc3QtcGFydGl0aW9uIG9yIC1wYXJ0aXRpb24gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBzcGVjaWZ5aW5nIGEgcGFydGl0aW9uIGF0IHByZXByb2Nlc3NpbmcgdGltZVwiXG4gICAgICAgIGVsc2UgUGFydGl0aW9uLnNldF9jdXJyZW50IHBhcnRpdGlvblxuICAgICAgZW5kXG5cbmxldCB1bnNldF9saWIgc3RhdGljX2xpYiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIG5vdCBnaXZpbmcgYW4gZXJyb3IsIGJlY2F1c2Ugd2hlbiBzb21lIGFubm95aW5nIHBlb3BsZSBwdXQgcGFfb3VuaXQgaW4gdGhlaXIgbGlzdFxuICAgICAgIG9mIHByZXByb2Nlc3NvcnMsIHBhX291bml0IGlzIHNldCB1cCB0d2ljZSBhbmQgd2UgaGF2ZSB0d28gY2FsbHMgdG8gdW5zZXRfbGliIGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYW5kIHRoZSBzZWNvbmQgb25lIGNvbWVzIGluIHRoaXMgYnJhbmNoICopXG4gICAgKClcbiAgfCBTb21lIGxpYiAtPlxuICAgIGlmIGxpYiA9IHN0YXRpY19saWIgdGhlbiBkeW5hbWljX2xpYiA6PSBOb25lXG5cbmxldCB0ZXN0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3NcbiAgICBmIChmdW4gYiAtPiBiKVxuXG5sZXQgdGVzdF91bml0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3NcbiAgICBmIChmdW4gKCkgLT4gdHJ1ZSlcblxubGV0W0BpbmxpbmUgbmV2ZXJdIHRlc3RfbW9kdWxlIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZTpkZWZfZmlsZW5hbWUgfmxpbmVfbnVtYmVyOmRlZl9saW5lX251bWJlclxuICAgICAgICAgICAgICAgICAgICAgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0cyA9IHsgbGlibmFtZTsgb25seV90ZXN0X2xvY2F0aW9uID0gXzsgbmFtZV9maWx0ZXIgPSBfOyB3aGljaF90YWdzIH07IHdoYXRfdG9fZG8gfSAtPlxuICAgIGxldCBmID0gYWRkX2hvb2tzIGNvbmZpZyBmIGluXG4gICAgbGV0IGRlc2NyICgpID0gZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MgaW5cbiAgICBsZXQgcGFydGlhbF90YWdzID0gdGFncyBAIE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfdGFncyAoKSBpblxuICAgIGxldCBzaG91bGRfcnVuID1cbiAgICAgIFNvbWUgbGlibmFtZSA9ICFkeW5hbWljX2xpYlxuICAgICAgKCogSWYsIG5vIG1hdHRlciB3aGF0IHRhZ3MgYSB0ZXN0IGRlZmluZXMsIHdlIGNlcnRhaW5seSB3aWxsIGRyb3AgYWxsIHRlc3RzIHdpdGhpblxuICAgICAgICAgdGhpcyBtb2R1bGUsIHRoZW4gZG9uJ3QgcnVuIHRoZSBtb2R1bGUgYXQgYWxsLiBUaGlzIG1lYW5zIHBlb3BsZSBjYW4gd3JpdGVcbiAgICAgICAgIHRoaW5ncyBsaWtlIHRoZSBmb2xsb3dpbmcgd2l0aG91dCBicmVha2luZyB0aGUgMzItYml0IGJ1aWxkOlxuICAgICAgICAgbGV0JXRlc3RfbW9kdWxlIFtAdGFncyBcIjY0LWJpdHMtb25seVwiXSA9IChtb2R1bGUgc3RydWN0XG4gICAgICAgICBsZXQgaSA9IEludDY0LnRvX2ludF9leG4gLi4uLlxuICAgICAgICAgZW5kKVxuICAgICAgICAgV2UgZG9uJ3Qgc2hvcnRjdXQgYmFzZWQgb24gcG9zaXRpb24sIGFzIHdlIGNhbid0IHRlbGwgd2hhdCBwb3NpdGlvbnMgdGhlXG4gICAgICAgICBpbm5lciB0ZXN0cyB3aWxsIGhhdmUuICopXG4gICAgICAmJiBub3QgKFRhZ19wcmVkaWNhdGUuZW50aXJlX21vZHVsZV9kaXNhYmxlZCB3aGljaF90YWdzIH5wYXJ0aWFsX3RhZ3MpXG4gICAgaW5cbiAgICBpZiBzaG91bGRfcnVuIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIC0+IFBhcnRpdGlvbi5mb3VuZF90ZXN0ICgpXG4gICAgICB8IGBSdW5fcGFydGl0aW9uIHBhcnRpdGlvbiAtPlxuICAgICAgICBpZiBQYXJ0aXRpb24uaXNfY3VycmVudCBwYXJ0aXRpb24gdGhlbiBiZWdpblxuICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICAgICBsZXQgZGVzY3IgPSBkZXNjciAoKSBpblxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBNb2R1bGVfY29udGV4dC53aXRoXyB+ZGVzY3IgfnRhZ3MgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAoKiBXZSBkbyBub3QgcmVzZXQgcmFuZG9tIHN0YXRlcyB1cG9uIGVudGVyaW5nIFtsZXQldGVzdF9tb2R1bGVdLlxuXG4gICAgICAgICAgICAgICAgIENvbjogQ29kZSBpbiB0ZXN0IG1vZHVsZXMgY2FuIGFjY2lkZW50YWxseSBkZXBlbmQgb24gdG9wLWxldmVsIHJhbmRvbVxuICAgICAgICAgICAgICAgICBzdGF0ZSBlZmZlY3RzLlxuXG4gICAgICAgICAgICAgICAgIFByb3M6ICgxKSBXZSBkb24ndCByZXNldCB0byB0aGUgc2FtZSBzZWVkIG9uIGVudGVyaW5nIGEgW2xldCV0ZXN0X21vZHVsZV1cbiAgICAgICAgICAgICAgICAgYW5kIHRoZW4gYSBbbGV0JXRlc3RdIGluc2lkZSB0aGF0IG1vZHVsZSwgd2hpY2ggY291bGQgbGVhZCB0b1xuICAgICAgICAgICAgICAgICBhY2NpZGVudGFsbHkgcmFuZG9tbHkgZ2VuZXJhdGluZyB0aGUgc2FtZSB2YWx1ZXMgaW4gc29tZSB0ZXN0LiAoMikgTW92aW5nXG4gICAgICAgICAgICAgICAgIGNvZGUgaW50byBhbmQgb3V0IG9mIFtsZXQldGVzdF9tb2R1bGVdIGRvZXMgbm90IGNoYW5nZSBpdHMgcmFuZG9tIHNlZWQuXG4gICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgIHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgKFwiVEVTXCIgXl4gXCJUX01PRFVMRSBhdCAlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIpXG4gICAgICAgICAgICAgIChTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIGRlc2NyKSBzZXAgZXhuX3N0ciBiYWNrdHJhY2UgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuXG5sZXQgc3VtbWFyaXplICgpID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPlxuICAgIGlmIFN5cy5hcmd2IDw+IFt8fF0gJiYgRmlsZW5hbWUuYmFzZW5hbWUgU3lzLmFyZ3YuKDApID0gXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZVwiIHRoZW5cbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiaW5saW5lX3Rlc3RzX3J1bm5lci5leGUgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHJ1biBieSBoYW5kLCB5b3UgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgcnVuIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCBpbnN0ZWFkLlxcbiUhXCJcbiAgICBlbHNlXG4gICAgICBQcmludGYuZXByaW50ZiBcIllvdSBhcmUgZG9pbmcgc29tZXRoaW5nIHVuZXhwZWN0ZWQgd2l0aCB0aGUgdGVzdHMuIE5vIHRlc3RzIGhhdmUgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICBiZWVuIHJ1bi4gWW91IHNob3VsZCB1c2UgdGhlIGlubGluZV90ZXN0c19ydW5uZXIgc2NyaXB0IHRvIHJ1biBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgIHRlc3RzLlxcbiUhXCI7XG4gICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSBfOyB3aGF0X3RvX2RvID0gYExpc3RfcGFydGl0aW9ucyB9IC0+XG4gICAgTGlzdC5pdGVyIChQcmludGYucHJpbnRmIFwiJXNcXG5cIikgKFBhcnRpdGlvbi5hbGwgKCkpO1xuICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgfCBgVGVzdF9tb2RlIHsgd2hhdF90b19kbyA9IGBSdW5fcGFydGl0aW9uIF87IHdoaWNoX3Rlc3RzIH0gLT4gYmVnaW5cbiAgICAgIGJlZ2luIG1hdGNoICFsb2cgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgY2ggLT4gY2xvc2Vfb3V0IGNoXG4gICAgICBlbmQ7XG4gICAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAgIG1hdGNoICF0ZXN0c19mYWlsZWQsICF0ZXN0X21vZHVsZXNfZmFpbGVkIHdpdGhcbiAgICAgIHwgMCwgMCAtPiBiZWdpblxuICAgICAgICAgIGlmICFzaG93X2NvdW50cyB0aGVuIGJlZ2luXG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcIiVkIHRlc3RzIHJhbiwgJWQgdGVzdF9tb2R1bGVzIHJhblxcbiUhXCIgIXRlc3RzX3JhbiAhdGVzdF9tb2R1bGVzX3JhblxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBsZXQgZXJyb3JzID1cbiAgICAgICAgICAgIGxldCB1bnVzZWRfdGVzdHMgPVxuICAgICAgICAgICAgICBMaXN0LmZpbHRlciAoZnVuIChfLCBfLCB1c2VkKSAtPiBub3QgIXVzZWQpIHdoaWNoX3Rlc3RzLm9ubHlfdGVzdF9sb2NhdGlvblxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIG1hdGNoIHVudXNlZF90ZXN0cyB3aXRoXG4gICAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICAgIHwgXyA6OiBfIC0+IFNvbWUgdW51c2VkX3Rlc3RzXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCBlcnJvcnMgd2l0aFxuICAgICAgICAgIHwgU29tZSB0ZXN0cyAtPlxuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IHRoZSBmb2xsb3dpbmcgLW9ubHktdGVzdCBmbGFncyBtYXRjaGVkIG5vdGhpbmc6XCI7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgXykgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzXCIgZmlsZW5hbWVcbiAgICAgICAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzOiVkXCIgZmlsZW5hbWUgbGluZV9udW1iZXJcbiAgICAgICAgICAgICkgdGVzdHM7XG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcIi5cXG4lIVwiO1xuICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGlmICF0ZXN0c19yYW4gPSAwICYmICFzdHJpY3QgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBQcmludGYuZXByaW50ZiBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogbm8gdGVzdHMgaGF2ZSBiZWVuIHJ1bi5cXG4lIVwiO1xuICAgICAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgVGVzdF9yZXN1bHQuU3VjY2Vzc1xuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjb3VudCwgY291bnRfdGVzdF9tb2R1bGVzIC0+XG4gICAgICAgIFByaW50Zi5lcHJpbnRmIFwiRkFJTEVEICVkIC8gJWQgdGVzdHMlc1xcbiUhXCIgY291bnQgIXRlc3RzX3JhblxuICAgICAgICAgIChpZiBjb3VudF90ZXN0X21vZHVsZXMgPSAwIHRoZW4gXCJcIiBlbHNlIFByaW50Zi5zcHJpbnRmIChcIiwgJWQgVEVTXCIgXl4gXCJUX01PRFVMRVNcIikgY291bnRfdGVzdF9tb2R1bGVzKTtcbiAgICAgICAgVGVzdF9yZXN1bHQuRmFpbHVyZVxuICAgIGVuZFxuXG5sZXQgdXNlX2NvbG9yID0gIXVzZV9jb2xvclxubGV0IGluX3BsYWNlICA9ICFpbl9wbGFjZVxubGV0IGRpZmZfY29tbWFuZCA9ICFkaWZmX2NvbW1hbmRcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gIXNvdXJjZV90cmVlX3Jvb3RcbmxldCBhbGxvd19vdXRwdXRfcGF0dGVybnMgPSAhYWxsb3dfb3V0cHV0X3BhdHRlcm5zXG5cbmxldCBldmFsdWF0b3JzID0gcmVmIFtzdW1tYXJpemVdXG5sZXQgYWRkX2V2YWx1YXRvciB+ZiA9IGV2YWx1YXRvcnMgOj0gZiA6OiAhZXZhbHVhdG9yc1xubGV0IGV4aXQgKCkgPVxuICBMaXN0Lm1hcCAoZnVuIGYgLT4gZiAoKSkgKExpc3QucmV2ICFldmFsdWF0b3JzKVxuICB8PiBUZXN0X3Jlc3VsdC5jb21iaW5lX2FsbFxuICB8PiBUZXN0X3Jlc3VsdC50b19leGl0X2NvZGVcbiAgfD4gZXhpdFxuIl19
