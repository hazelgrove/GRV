// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Timing_wheel = [0];
   runtime.caml_register_global(0, Timing_wheel, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Expect_test_collector[5][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel$0 = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst$0 = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits$0 = "bits",
    cst_bits_per_slot$0 = "bits_per_slot",
    cst_capacity = "capacity",
    cst_config$0 = "config",
    cst_diff_max_min_allowed_key$0 = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound$0 = "elt_key_lower_bound",
    cst_index$0 = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot$0 = "keys_per_slot",
    cst_length$1 = "length",
    cst_level_bits$0 = "level_bits",
    cst_levels$0 = "levels",
    cst_max_allowed_alarm_time$0 = "max_allowed_alarm_time",
    cst_max_allowed_key$0 = "max_allowed_key",
    cst_max_interval_num$0 = "max_interval_num",
    cst_min_allowed_key$0 = "min_allowed_key",
    cst_min_elt$0 = "min_elt",
    cst_min_key_in_same_slot_mask$0 = "min_key_in_same_slot_mask",
    cst_now$0 = "now",
    cst_now_interval_num_start$0 = "now_interval_num_start",
    cst_pool$0 = "pool",
    cst_priority_queue$0 = "priority_queue",
    cst_slots$0 = "slots",
    cst_slots_mask$0 = "slots_mask",
    cst_start$0 = "start",
    cst_timing_wheel$0 = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1631:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1628:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1644:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1649:26",
    arg_108 = [0, cst$0],
    pos$5 = "timing_wheel/src/timing_wheel.ml:1006:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:1003:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:902:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:909:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:921:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:939:32",
    pos = "timing_wheel/src/timing_wheel.ml:944:30",
    cst = "",
    error_source_039 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List;
   global_data.Base__Field;
   var
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel$0);
   caml_call1(Expect_test_collector[5][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel$0, cst);
   var
    max_time = Core_Time_ns_alternate_sexp[45],
    min_time = Core_Time_ns_alternate_sexp[43],
    zero = Core_Int[55],
    to_int = Core_Int[61],
    t_of_sexp = Core_Int[79],
    sexp_of_t = Core_Int[80],
    symbol = Core_Int[84],
    symbol$0 = Core_Int[85],
    symbol$1 = Core_Int[87],
    equal = Core_Int[90],
    max_num_bits = Core_Int63[58] - 1 | 0,
    _b3_ = [0, cst$0],
    _b4_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1,
    _b1_ = [0, cst$0],
    _b2_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _bZ_ = [0, cst$0],
    _b0_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _bX_ = [0, cst_now_interval_num_start$0],
    _bY_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    _bV_ = [0, cst_max_allowed_alarm_time$0],
    _bW_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _bU_ = [0, cst_timing_wheel_src_timing_wh, 1707, 53],
    _bT_ = [0, cst_start$0],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _bR_ = [0, cst$0],
    _bQ_ = [0, cst_timing_wheel_src_timing_wh, 1654, 6],
    _bP_ = [0, cst_timing_wheel_src_timing_wh, 1658, 6],
    _bO_ = [0, cst_timing_wheel_src_timing_wh, 1662, 6],
    _bN_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _bM_ = [0, cst_timing_wheel_src_timing_wh, 1625, 11],
    _bL_ = [0, cst_timing_wheel_src_timing_wh, 1636, 11],
    _bK_ = [0, cst_timing_wheel_src_timing_wh, 1637, 11],
    _bJ_ = [0, cst_timing_wheel_src_timing_wh, 1638, 11],
    _bS_ = [0, cst_timing_wheel_src_timing_wh, 1618, 58357, 58379],
    _bH_ = [0, "t.max_interval_num"],
    _bI_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _bF_ = [0, "min_interval_num"],
    _bG_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _bE_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _bC_ = [0, cst$0],
    _bD_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _bA_ = [0, cst$0],
    _bB_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _bv_ = [0, "alarms"],
    _bw_ = [0, cst_now$0],
    _bx_ = [0, cst_max_interval_num$0],
    _by_ = [0, cst_start$0],
    _bz_ = [0, cst_config$0],
    _bt_ = [0, cst_value],
    _bu_ = [0, cst_at],
    _bb_ = [0, "max_allowed_alarm_interval_num"],
    _bc_ = [0, "min_allowed_alarm_interval_num"],
    _bd_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num",
    _a__ = [0, cst$0],
    _a$_ = [0, "level"],
    _ba_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _a6_ = [0, cst_priority_queue$0],
    _a7_ = [0, "max_allowed_key t"],
    _a8_ = [0, "min_allowed_key t"],
    _a9_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _a4_ = [0, cst$0],
    _a1_ = [0, cst_timing_wheel_src_timing_wh, 977, 38],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 983, 15],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 984, 15],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 987, 13],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 988, 13],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 991, 15],
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 997, 15],
    _aV_ = [0, cst_timing_wheel_src_timing_wh, 995, 13],
    _a3_ = [0, cst_timing_wheel_src_timing_wh, 974, 6],
    _a2_ = [0, cst_timing_wheel_src_timing_wh, 975, 6],
    _aS_ = [0, cst$0],
    _aR_ = [0, cst_timing_wheel_src_timing_wh, 898, 38],
    _aQ_ = [0, cst_timing_wheel_src_timing_wh, 899, 36],
    _aP_ = [0, cst_timing_wheel_src_timing_wh, 906, 15],
    _aO_ = [0, cst_timing_wheel_src_timing_wh, 914, 15],
    _aN_ = [0, cst_timing_wheel_src_timing_wh, 928, 15],
    _aM_ = [0, cst_timing_wheel_src_timing_wh, 936, 15],
    _aL_ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _aK_ = [0, cst_timing_wheel_src_timing_wh, 961, 21],
    _aJ_ = [0, cst_timing_wheel_src_timing_wh, 965, 21],
    _aI_ = [0, cst_timing_wheel_src_timing_wh, 969, 21],
    _aT_ = [0, cst_timing_wheel_src_timing_wh, 895, 31577, 31603],
    _a5_ = [0, cst_timing_wheel_src_timing_wh, 972, 34918, 34942],
    _aF_ = [0, "elts"],
    _aG_ = [0, cst_max_allowed_key$0],
    _aH_ = [0, cst_min_allowed_key$0],
    _aD_ = [0, cst_value],
    _aE_ = [0, cst_key],
    _ay_ = [0, cst_levels$0],
    _az_ = [0, cst_elt_key_lower_bound$0],
    _aA_ = [0, cst_min_elt$0],
    _aB_ = [0, cst_pool$0],
    _aC_ = [0, cst_length$1],
    _ad_ = [0, cst_slots$0],
    _ae_ = [0, cst_max_allowed_key$0],
    _af_ = [0, cst_min_allowed_key$0],
    _ag_ = [0, cst_length$1],
    _ah_ = [0, cst_diff_max_min_allowed_key$0],
    _ai_ = [0, cst_min_key_in_same_slot_mask$0],
    _aj_ = [0, cst_keys_per_slot$0],
    _ak_ = [0, cst_bits_per_slot$0],
    _al_ = [0, cst_slots_mask$0],
    _am_ = [0, cst_bits$0],
    _an_ = [0, cst_index$0],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm",
    _H_ = [0, cst$0],
    _G_ = [0, cst_timing_wheel_src_timing_wh, 648, 8],
    _F_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _E_ = [0, cst_timing_wheel_src_timing_wh, 653, 8],
    _I_ = [0, cst_timing_wheel_src_timing_wh, 647, 23049, 23075],
    _u_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]],
    _s_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _t_ = [0, cst_timing_wheel_src_timing_wh, 256, 8261, 8285],
    _p_ = [0, cst_capacity],
    _q_ = [0, cst_level_bits$0],
    _r_ = [0, cst_alarm_precision$0],
    _o_ = [0, cst_timing_wheel_src_timing_wh, 235, 2],
    cst_alarm_precision = cst_alarm_precision$0,
    _h_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span",
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds",
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits",
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _g_ = [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]],
    cst_level_bits = cst_level_bits$0,
    cst_slots = cst_slots$0,
    cst_max_allowed_key = cst_max_allowed_key$0,
    cst_min_allowed_key = cst_min_allowed_key$0,
    cst_length = cst_length$1,
    cst_diff_max_min_allowed_key = cst_diff_max_min_allowed_key$0,
    cst_min_key_in_same_slot_mask = cst_min_key_in_same_slot_mask$0,
    cst_keys_per_slot = cst_keys_per_slot$0,
    cst_bits_per_slot = cst_bits_per_slot$0,
    cst_slots_mask = cst_slots_mask$0,
    cst_bits = cst_bits$0,
    cst_index = cst_index$0,
    cst_levels = cst_levels$0,
    cst_elt_key_lower_bound = cst_elt_key_lower_bound$0,
    cst_min_elt = cst_min_elt$0,
    cst_pool = cst_pool$0,
    cst_length$0 = cst_length$1,
    cst_priority_queue = cst_priority_queue$0,
    cst_max_allowed_alarm_time = cst_max_allowed_alarm_time$0,
    cst_now_interval_num_start = cst_now_interval_num_start$0,
    cst_now = cst_now$0,
    cst_max_interval_num = cst_max_interval_num$0,
    cst_start = cst_start$0,
    cst_config = cst_config$0,
    cst_timing_wheel = cst_timing_wheel$0,
    cst_Timing_wheel = cst_Timing_wheel$0,
    min_value = 0;
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[47], Core_Int63[14], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[421], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[10], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[8], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    function _fr_(num_key_bits){
     invariant(num_key_bits);
     if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    caml_call2(Core_List[9], t, _fr_);
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[422], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    if(opt)
     var sth = opt[1], extend_to_max_num_bits = sth;
    else
     var extend_to_max_num_bits = 0;
    if(caml_call1(Core_List[8], x_008))
     caml_call1(Core[6], cst_Level_bits_create_exn_requ);
    function _ff_(bits){return caml_call2(Core[89], bits, 0);}
    if(caml_call2(Core_List[13], x_008, _ff_)){
     var
      _fg_ = [0, caml_call2(Core[421], Core[356], x_008), 0],
      _fh_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _fg_]];
     caml_call1(Core[253], _fh_);
    }
    function _fi_(_fq_, _fp_){return _fq_ + _fp_ | 0;}
    var num_bits = caml_call3(Core_List[10], x_008, 0, _fi_);
    if(caml_call2(Core[91], num_bits, max_num_bits)){
     var
      _fj_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[356], max_num_bits), 0]]], 0],
      _fk_ = [0, [1, [0, _f_, [0, caml_call1(Core[356], num_bits), 0]]], _fj_],
      _fl_ = [0, caml_call2(Core[421], Core[356], x_008), _fk_],
      _fm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _fl_]];
     caml_call1(Core[253], _fm_);
    }
    if(extend_to_max_num_bits)
     var
      _fn_ = caml_call1(Core[230], 1),
      _fo_ = caml_call2(Core_List[119], max_num_bits - num_bits | 0, _fn_),
      ints = caml_call2(Core[157], x_008, _fo_);
    else
     var ints = x_008;
    return caml_call2(Core_List[72], ints, of_int);
   }
   var level_bits_default = create_exn(0, _g_), compare = Core[352];
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function num_key_bits(t){return of_int(t);}
   function to_sexpable(t){
    if(caml_call2(Core[92], t, 0)){
     var
      _fc_ = [0, caml_call1(Core[356], t), 0],
      _fd_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _fc_]];
     caml_call1(Core[253], _fd_);
    }
    var _fe_ = caml_call1(caml_call1(Core_Int63[47], Core_Int63[14]), t);
    return caml_call1(Core_Time_ns[1][127], _fe_);
   }
   function sexp_of_t$1(t){
    var _fb_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _fb_);
   }
   var
    one_nanosecond = 0,
    about_one_microsecond = 10,
    about_one_millisecond = 20,
    about_one_second = 30,
    about_one_day = 46;
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _e__ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _e$_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _e__]];
     caml_call1(Core[253], _e$_);
    }
    var _fa_ = caml_call1(Core_Time_ns[1][126], span);
    return caml_call1(Core_Int63[86], _fa_);
   }
   var
    _i_ = Core_Time_ns[1],
    _j_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _i_[5], _i_[1], _i_[2], _i_[3], _i_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _j_[1],
    bin_write_t = _j_[2],
    bin_read_t = _j_[3],
    bin_read_t$0 = _j_[4],
    bin_shape_t = _j_[5],
    bin_writer_t = _j_[6],
    bin_reader_t = _j_[7],
    bin_t = _j_[8],
    _k_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _k_[9], _k_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _l_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   function _m_(r, v){return [0, r[1], v, r[3]];}
   var
    _n_ = 0,
    level_bits$0 =
      [0, function(param){return 0;}, cst_level_bits, _n_, level_bits, _m_];
   function t_of_sexp$2(sexp_019){
    if(0 === sexp_019[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_039, sexp_019);
    var
     field_sexps_020 = sexp_019[1],
     alarm_precision_021 = [0, 0],
     level_bits_023 = [0, 0],
     capacity_025 = [0, 0],
     duplicates_027 = [0, 0],
     extra_028 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_020;
       for(;;){
        if(! param) break;
        var sexp_019$0 = param[1];
        if(1 !== sexp_019$0[0]) break b;
        var _e7_ = sexp_019$0[1];
        if(! _e7_) break c;
        var _e8_ = _e7_[1];
        if(0 !== _e8_[0]) break e;
        var field_sexps_031 = _e7_[2], field_name_029 = _e8_[1];
        if(field_sexps_031 && field_sexps_031[2]) break d;
        var
         tail_041 = param[2],
         field_sexp_030$3 =
           function(field_sexps_031){
            function field_sexp_030(param){
             if(! field_sexps_031)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019);
             if(field_sexps_031[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
             var x_042 = field_sexps_031[1];
             return x_042;
            }
            return field_sexp_030;
           },
         field_sexp_030 = field_sexp_030$3(field_sexps_031);
        if(caml_string_notequal(field_name_029, cst_alarm_precision$0))
         if(caml_string_notequal(field_name_029, cst_capacity))
          if(caml_string_notequal(field_name_029, cst_level_bits$0)){
           if(Sexplib0_Sexp_conv[26][1])
            extra_028[1] = [0, field_name_029, extra_028[1]];
          }
          else if(level_bits_023[1])
           duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
          else{
           var
            field_sexp_030$0 = field_sexp_030(0),
            fvalue_034 = t_of_sexp$0(field_sexp_030$0);
           level_bits_023[1] = [0, fvalue_034];
          }
         else if(capacity_025[1])
          duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
         else{
          var
           field_sexp_030$1 = field_sexp_030(0),
           fvalue_032 = caml_call1(Core[357], field_sexp_030$1);
          capacity_025[1] = [0, fvalue_032];
         }
        else if(alarm_precision_021[1])
         duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
        else{
         var
          field_sexp_030$2 = field_sexp_030(0),
          fvalue_035 = caml_call1(_l_[10], field_sexp_030$2);
         alarm_precision_021[1] = [0, fvalue_035];
        }
        var param = tail_041;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019$0);
    }
    if(duplicates_027[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_039,
              duplicates_027[1],
              sexp_019);
    if(extra_028[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_039,
              extra_028[1],
              sexp_019);
    var
     _e9_ = alarm_precision_021[1],
     level_bits_024 = level_bits_023[1],
     match = capacity_025[1];
    if(! _e9_)
     return caml_call3
             (Sexplib0_Sexp_conv_error[15],
              error_source_039,
              sexp_019,
              [0,
               [0, 0 === alarm_precision_021[1] ? 1 : 0, cst_alarm_precision],
               0]);
    var alarm_precision_022 = _e9_[1];
    if(level_bits_024)
     var v_038 = level_bits_024[1], v_038$0 = v_038;
    else
     var v_038$0 = level_bits_default;
    return [0, alarm_precision_022, v_038$0, match];
   }
   function sexp_of_t$3(param){
    var
     capacity_048 = param[3],
     level_bits_046 = param[2],
     alarm_precision_044 = param[1],
     bnds_043 = 0;
    if(capacity_048)
     var
      v_049 = capacity_048[1],
      arg_051 = caml_call1(Core[356], v_049),
      bnd_050 = [1, [0, _p_, [0, arg_051, 0]]],
      bnds_043$0 = [0, bnd_050, bnds_043];
    else
     var bnds_043$0 = bnds_043;
    var
     arg_047 = sexp_of_t$0(level_bits_046),
     bnds_043$1 = [0, [1, [0, _q_, [0, arg_047, 0]]], bnds_043$0],
     arg_045 = caml_call1(_l_[11], alarm_precision_044),
     bnds_043$2 = [0, [1, [0, _r_, [0, arg_045, 0]]], bnds_043$1];
    return [1, bnds_043$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    return symbol$3(max_num_bits, num_key_bits(alarm_precision));
   }
   function invariant$1(t){
    function _e5_(param){
     var _e6_ = max_num_level_bits(t[1]);
     if(! caml_call2(symbol$0, num_bits_internal(t[2]), _e6_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
     var level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
     caml_call1(level_bits_fun, level_bits$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _t_, t, sexp_of_t$3, _e5_);
   }
   function create(capacity, opt, alarm_precision, param){
    if(opt)
     var sth = opt[1], level_bits = sth;
    else
     var level_bits = level_bits_default;
    var max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _u_)], about_one_microsecond, 0);
   }
   function durations(t){
    function _e2_(num_bits_accum, level_num_bits){
     var
      num_bits_accum$0 =
        num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
      _e4_ =
        caml_call2(Core[90], num_bits_accum$0, Core_Int63[58] - 1 | 0)
         ? Core_Int63[59]
         : caml_call2(Core_Int63[47], Core_Int63[14], num_bits_accum$0),
      duration = caml_call1(Core_Time_ns[1][127], _e4_);
     return [0, num_bits_accum$0, duration];
    }
    var _e3_ = caml_call1(to_int, num_key_bits(t[1]));
    return caml_call3(Core_List[73], t[2], _e3_, _e2_);
   }
   var compare$0 = Core_Int63[110], sexp_of_t$4 = Core_Int63[99];
   function create$0(level_bits){
    var _e0_ = Core_Int63[14], _e1_ = pow2(level_bits);
    return caml_call2(Core_Int63[17], _e1_, _e0_);
   }
   function num_keys(num_bits){return pow2(num_bits);}
   var
    one = Core_Int63[14],
    symbol$4 = Core_Int63[17],
    bit_not = Core_Int63[45],
    sexp_of_t$5 = Core_Int63[99],
    equal$1 = Core_Int63[109];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[13],
    one$0 = Core_Int63[14],
    symbol$5 = Core_Int63[16],
    symbol$6 = Core_Int63[18],
    succ = Core_Int63[39],
    pred = Core_Int63[40],
    max_value = Core_Int63[59],
    of_int$0 = Core_Int63[69],
    sexp_of_t$6 = Core_Int63[99],
    symbol$7 = Core_Int63[103],
    symbol$8 = Core_Int63[104],
    symbol$9 = Core_Int63[105],
    symbol$10 = Core_Int63[106],
    symbol$11 = Core_Int63[107],
    symbol$12 = Core_Int63[108],
    equal$2 = Core_Int63[109],
    compare$1 = Core_Int63[110],
    min = Core_Int63[111],
    max = Core_Int63[112],
    ascending = Core_Int63[113],
    descending = Core_Int63[114],
    between = Core_Int63[115],
    clamp_exn = Core_Int63[116],
    clamp = Core_Int63[117],
    Replace_polymorphic_compare = Core_Int63[118],
    comparator = Core_Int63[119],
    Map = Core_Int63[120],
    Set = Core_Int63[121],
    validate_lbound = Core_Int63[128],
    validate_ubound = Core_Int63[129],
    validate_bound = Core_Int63[130];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[13],
    one$1 = Core_Int63[14],
    symbol$13 = Core_Int63[16],
    symbol$14 = Core_Int63[17],
    rem = Core_Int63[25],
    succ$0 = Core_Int63[39],
    pred$0 = Core_Int63[40],
    bit_and = Core_Int63[42],
    shift_right = Core_Int63[48],
    max_value$0 = Core_Int63[59],
    min_value$0 = Core_Int63[60],
    of_int$1 = Core_Int63[69],
    sexp_of_t$7 = Core_Int63[99],
    symbol$15 = Core_Int63[103],
    symbol$16 = Core_Int63[104],
    symbol$17 = Core_Int63[105],
    symbol$18 = Core_Int63[106],
    symbol$19 = Core_Int63[107],
    symbol$20 = Core_Int63[108],
    equal$3 = Core_Int63[109],
    compare$2 = Core_Int63[110],
    min$0 = Core_Int63[111],
    max$0 = Core_Int63[112],
    ascending$0 = Core_Int63[113],
    descending$0 = Core_Int63[114],
    between$0 = Core_Int63[115],
    clamp_exn$0 = Core_Int63[116],
    clamp$0 = Core_Int63[117],
    Replace_polymorphic_compare$0 = Core_Int63[118],
    comparator$0 = Core_Int63[119],
    Map$0 = Core_Int63[120],
    Set$0 = Core_Int63[121],
    hash_fold_t = Core_Int63[122],
    hash = Core_Int63[123],
    hashable = Core_Int63[124],
    Table = Core_Int63[125],
    Hash_set = Core_Int63[126],
    Hash_queue = Core_Int63[127],
    validate_lbound$0 = Core_Int63[128],
    validate_ubound$0 = Core_Int63[129],
    validate_bound$0 = Core_Int63[130];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   function min_key_in_same_slot(t, min_key_in_same_slot_mask){return caml_call2(bit_and, t, min_key_in_same_slot_mask);
   }
   var
    _x_ = Set$0[1],
    _z_ = Map$0[1],
    _B_ = Set[1],
    _C_ = Map[1],
    _D_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _C_[9], _C_[10], _C_[11]],
        Map[2],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45],
        Map[46],
        Map[47],
        Map[48],
        Map[49],
        Map[50],
        Map[51],
        Map[52],
        Map[53],
        Map[54],
        Map[55],
        Map[56],
        Map[57],
        Map[58],
        Map[59],
        Map[60],
        Map[61],
        Map[62],
        Map[63],
        Map[64],
        Map[65],
        Map[66],
        Map[67],
        Map[68],
        Map[69],
        Map[70],
        Map[71],
        Map[72],
        Map[73],
        Map[74],
        Map[75],
        Map[76],
        Map[77],
        Map[78],
        Map[79],
        Map[80],
        Map[81],
        Map[82],
        Map[83],
        Map[84],
        Map[85],
        Map[86],
        Map[87],
        Map[88],
        Map[89],
        Map[90],
        Map[91],
        Map[92],
        Map[93],
        Map[94],
        Map[95],
        Map[96],
        Map[97],
        Map[98],
        Map[99],
        Map[100],
        Map[101],
        Map[102],
        Map[103],
        Map[104],
        Map[105],
        Map[106],
        Map[107]],
       [0,
        [0, _B_[1], _B_[2], _B_[11]],
        Set[2],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28],
        Set[29],
        Set[30],
        Set[31],
        Set[32],
        Set[33],
        Set[34],
        Set[35],
        Set[36],
        Set[37],
        Set[38],
        Set[39],
        Set[40],
        Set[41],
        Set[42],
        Set[43],
        Set[44],
        Set[45],
        Set[46],
        Set[47],
        Set[48],
        Set[49],
        Set[50],
        Set[51],
        Set[52],
        Set[53],
        Set[54],
        Set[55],
        Set[56],
        Set[57],
        Set[58],
        Set[59],
        Set[60],
        Set[61],
        Set[62],
        Set[63],
        Set[64],
        Set[65],
        Set[66],
        Set[67],
        Set[68],
        Set[69],
        Set[70],
        Set[71],
        Set[72],
        Set[73],
        Set[74],
        Set[75]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5],
    _v_ =
      [0,
       Hash_set[1],
       Hash_set[2],
       Hash_set[3],
       Hash_set[4],
       Hash_set[5],
       Hash_set[6],
       Hash_set[7]],
    _w_ =
      [0,
       Table[1],
       Table[2],
       Table[3],
       Table[4],
       Table[5],
       Table[6],
       Table[7],
       Table[8],
       Table[9],
       Table[10],
       Table[11],
       Table[12],
       Table[13],
       Table[14],
       Table[15],
       Table[16],
       Table[17],
       Table[18],
       Table[19],
       Table[20],
       Table[21],
       Table[22],
       Table[23],
       Table[24],
       Table[25],
       Table[26],
       Table[27],
       Table[28],
       Table[29],
       Table[30],
       Table[31],
       Table[32],
       Table[33],
       Table[34],
       Table[35],
       Table[36],
       Table[37],
       Table[38],
       Table[39],
       Table[40],
       Table[41],
       Table[42],
       Table[43],
       Table[44],
       Table[45],
       Table[46],
       Table[47],
       Table[48],
       Table[49],
       Table[50],
       Table[51],
       Table[52],
       Table[53],
       Table[54],
       Table[55],
       Table[56],
       Table[57],
       Table[58],
       Table[59],
       Table[60],
       Table[61],
       Table[62],
       Table[63],
       Table[64],
       Table[65],
       Table[66],
       Table[67],
       Table[68],
       Table[69],
       Table[70],
       Table[71],
       Table[72],
       Table[73],
       Table[74],
       Table[75],
       Table[76],
       Table[77],
       Table[78],
       Table[79],
       Table[80],
       Table[81],
       Table[82],
       Table[83],
       Table[84]],
    _y_ =
      [0,
       [0, _x_[1], _x_[2], _x_[11]],
       Set$0[2],
       Set$0[3],
       Set$0[4],
       Set$0[5],
       Set$0[6],
       Set$0[7],
       Set$0[8],
       Set$0[9],
       Set$0[10],
       Set$0[11],
       Set$0[12],
       Set$0[13],
       Set$0[14],
       Set$0[15],
       Set$0[16],
       Set$0[17],
       Set$0[18],
       Set$0[19],
       Set$0[20],
       Set$0[21],
       Set$0[22],
       Set$0[23],
       Set$0[24],
       Set$0[25],
       Set$0[26],
       Set$0[27],
       Set$0[28],
       Set$0[29],
       Set$0[30],
       Set$0[31],
       Set$0[32],
       Set$0[33],
       Set$0[34],
       Set$0[35],
       Set$0[36],
       Set$0[37],
       Set$0[38],
       Set$0[39],
       Set$0[40],
       Set$0[41],
       Set$0[42],
       Set$0[43],
       Set$0[44],
       Set$0[45],
       Set$0[46],
       Set$0[47],
       Set$0[48],
       Set$0[49],
       Set$0[50],
       Set$0[51],
       Set$0[52],
       Set$0[53],
       Set$0[54],
       Set$0[55],
       Set$0[56],
       Set$0[57],
       Set$0[58],
       Set$0[59],
       Set$0[60],
       Set$0[61],
       Set$0[62],
       Set$0[63],
       Set$0[64],
       Set$0[65],
       Set$0[66],
       Set$0[67],
       Set$0[68],
       Set$0[69],
       Set$0[70],
       Set$0[71],
       Set$0[72],
       Set$0[73],
       Set$0[74],
       Set$0[75]],
    _A_ =
      [0,
       [0, _z_[9], _z_[10], _z_[11]],
       Map$0[2],
       Map$0[3],
       Map$0[4],
       Map$0[5],
       Map$0[6],
       Map$0[7],
       Map$0[8],
       Map$0[9],
       Map$0[10],
       Map$0[11],
       Map$0[12],
       Map$0[13],
       Map$0[14],
       Map$0[15],
       Map$0[16],
       Map$0[17],
       Map$0[18],
       Map$0[19],
       Map$0[20],
       Map$0[21],
       Map$0[22],
       Map$0[23],
       Map$0[24],
       Map$0[25],
       Map$0[26],
       Map$0[27],
       Map$0[28],
       Map$0[29],
       Map$0[30],
       Map$0[31],
       Map$0[32],
       Map$0[33],
       Map$0[34],
       Map$0[35],
       Map$0[36],
       Map$0[37],
       Map$0[38],
       Map$0[39],
       Map$0[40],
       Map$0[41],
       Map$0[42],
       Map$0[43],
       Map$0[44],
       Map$0[45],
       Map$0[46],
       Map$0[47],
       Map$0[48],
       Map$0[49],
       Map$0[50],
       Map$0[51],
       Map$0[52],
       Map$0[53],
       Map$0[54],
       Map$0[55],
       Map$0[56],
       Map$0[57],
       Map$0[58],
       Map$0[59],
       Map$0[60],
       Map$0[61],
       Map$0[62],
       Map$0[63],
       Map$0[64],
       Map$0[65],
       Map$0[66],
       Map$0[67],
       Map$0[68],
       Map$0[69],
       Map$0[70],
       Map$0[71],
       Map$0[72],
       Map$0[73],
       Map$0[74],
       Map$0[75],
       Map$0[76],
       Map$0[77],
       Map$0[78],
       Map$0[79],
       Map$0[80],
       Map$0[81],
       Map$0[82],
       Map$0[83],
       Map$0[84],
       Map$0[85],
       Map$0[86],
       Map$0[87],
       Map$0[88],
       Map$0[89],
       Map$0[90],
       Map$0[91],
       Map$0[92],
       Map$0[93],
       Map$0[94],
       Map$0[95],
       Map$0[96],
       Map$0[97],
       Map$0[98],
       Map$0[99],
       Map$0[100],
       Map$0[101],
       Map$0[102],
       Map$0[103],
       Map$0[104],
       Map$0[105],
       Map$0[106],
       Map$0[107]];
   function sexp_of_pool_slots(of_a_054, x_055){
    function _eU_(_eZ_){return sexp_of_pool_slots(of_a_054, _eZ_);}
    var _eV_ = caml_call1(Tuple_pool[36][3][1], _eU_);
    function _eW_(_eY_){return sexp_of_pool_slots(of_a_054, _eY_);}
    var _eX_ = caml_call1(Tuple_pool[36][3][1], _eW_);
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[92],
             of_a_054,
             Core[356],
             _eX_,
             _eV_,
             x_055);
   }
   function sexp_of_t$8(of_a_056, x_057){
    function _eS_(_eT_){return sexp_of_pool_slots(of_a_056, _eT_);}
    return caml_call2(Tuple_pool[36][3][1], _eS_, x_057);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var grow = Tuple_pool[36][12], is_full = Tuple_pool[36][13];
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _eR_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[253], _eR_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   function _J_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], v];
   }
   var
    _K_ = 0,
    slots$0 = [0, function(param){return 0;}, cst_slots, _K_, slots, _J_];
   function _L_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v, r[11]];
   }
   var
    _M_ = [0, set_max_allowed_key],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       _M_,
       max_allowed_key,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11]];
   }
   var
    _O_ = [0, set_min_allowed_key],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       _O_,
       min_allowed_key,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11]];
   }
   var
    _Q_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _Q_, length, _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _S_ = 0,
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       _S_,
       diff_max_min_allowed_key,
       _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _U_ = 0,
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       _U_,
       min_key_in_same_slot_mask,
       _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _W_ = 0,
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       _W_,
       keys_per_slot,
       _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _Y_ = 0,
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       _Y_,
       bits_per_slot,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    ___ = 0,
    slots_mask$0 =
      [0, function(param){return 0;}, cst_slots_mask, ___, slots_mask, _Z_];
   function _$_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _aa_ = 0,
    bits$0 = [0, function(param){return 0;}, cst_bits, _aa_, bits, _$_];
   function _ab_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _ac_ = 0,
    index$0 = [0, function(param){return 0;}, cst_index, _ac_, index, _ab_];
   function sexp_of_t$9(of_a_065, param){
    var
     diff_max_min_allowed_key_079 = param[7],
     min_key_in_same_slot_mask_077 = param[6],
     keys_per_slot_075 = param[5],
     bits_per_slot_073 = param[4],
     slots_mask_071 = param[3],
     bits_069 = param[2],
     index_067 = param[1],
     length_081 = param[8],
     min_allowed_key_083 = param[9],
     max_allowed_key_085 = param[10],
     slots_087 = param[11],
     arg_088 = caml_call1(Sexplib0_Sexp_conv[23], slots_087),
     bnds_066 = [0, [1, [0, _ad_, [0, arg_088, 0]]], 0],
     arg_086 = caml_call1(sexp_of_t$7, max_allowed_key_085),
     bnds_066$0 = [0, [1, [0, _ae_, [0, arg_086, 0]]], bnds_066],
     arg_084 = caml_call1(sexp_of_t$7, min_allowed_key_083),
     bnds_066$1 = [0, [1, [0, _af_, [0, arg_084, 0]]], bnds_066$0],
     arg_082 = caml_call1(Core[356], length_081),
     bnds_066$2 = [0, [1, [0, _ag_, [0, arg_082, 0]]], bnds_066$1],
     arg_080 = caml_call1(_D_[1], diff_max_min_allowed_key_079),
     bnds_066$3 = [0, [1, [0, _ah_, [0, arg_080, 0]]], bnds_066$2],
     arg_078 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_077),
     bnds_066$4 = [0, [1, [0, _ai_, [0, arg_078, 0]]], bnds_066$3],
     arg_076 = caml_call1(_D_[1], keys_per_slot_075),
     bnds_066$5 = [0, [1, [0, _aj_, [0, arg_076, 0]]], bnds_066$4],
     arg_074 = caml_call1(sexp_of_t, bits_per_slot_073),
     bnds_066$6 = [0, [1, [0, _ak_, [0, arg_074, 0]]], bnds_066$5],
     arg_072 = caml_call1(sexp_of_t$4, slots_mask_071),
     bnds_066$7 = [0, [1, [0, _al_, [0, arg_072, 0]]], bnds_066$6],
     arg_070 = caml_call1(sexp_of_t, bits_069),
     bnds_066$8 = [0, [1, [0, _am_, [0, arg_070, 0]]], bnds_066$7],
     arg_068 = caml_call1(Core[356], index_067),
     bnds_066$9 = [0, [1, [0, _an_, [0, arg_068, 0]]], bnds_066$8];
    return [1, bnds_066$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot$0(t, key){
    return min_key_in_same_slot(key, t[6]);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot$0
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   function _ao_(r, v){return [0, r[1], r[2], r[3], r[4], v];}
   var
    _ap_ = 0,
    levels$0 = [0, function(param){return 0;}, cst_levels, _ap_, levels, _ao_];
   function _aq_(r, v){return [0, r[1], r[2], r[3], v, r[5]];}
   var
    _ar_ = [0, set_elt_key_lower_bound],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       _ar_,
       elt_key_lower_bound,
       _aq_];
   function _as_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _at_ = [0, set_min_elt],
    min_elt$0 =
      [0, function(param){return 0;}, cst_min_elt, _at_, min_elt, _as_];
   function _au_(r, v){return [0, r[1], v, r[3], r[4], r[5]];}
   var
    _av_ = [0, set_pool],
    pool$0 = [0, function(param){return 0;}, cst_pool, _av_, pool, _au_];
   function _aw_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _ax_ = [0, set_length$0],
    length$2 =
      [0, function(param){return 0;}, cst_length$0, _ax_, length$1, _aw_];
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){return caml_check_bound(t[5], 0)[1][9];}
   function max_allowed_key$1(t){
    var _eQ_ = num_levels(t) - 1 | 0;
    return caml_check_bound(t[5], _eQ_)[1 + _eQ_][10];
   }
   function internal_iter(t, f){
    var _eI_ = caml_call2(Core[91], t[1], 0);
    if(_eI_){
     var
      pool = t[2],
      levels = t[5],
      _eK_ = levels.length - 1 - 1 | 0,
      _eJ_ = 0;
     if(_eK_ >= 0){
      var level_index = _eJ_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        var slots = level[11], _eN_ = slots.length - 1 - 1 | 0, _eM_ = 0;
        if(_eN_ >= 0){
         var slot_index = _eM_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _eP_ = slot_index + 1 | 0;
          if(_eN_ === slot_index) break;
          var slot_index = _eP_;
         }
        }
       }
       var _eO_ = level_index + 1 | 0;
       if(_eK_ === level_index) break;
       var level_index = _eO_;
      }
     }
     var _eL_ = 0;
    }
    else
     var _eL_ = _eI_;
    return _eL_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, bits, max_num_bits)) return _D_[26];
    var _eH_ = num_keys(bits);
    return caml_call1(_D_[32], _eH_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[92], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _eE_ = level_index[1],
      level = caml_check_bound(t[5], _eE_)[1 + _eE_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[90], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot$0(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _eF_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _eF_)[1 + _eF_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       slot_min_key[1] = add(slot_min_key[1], level[5]);
      }
      var _eG_ = slot$0[1], first = caml_check_bound(slots, _eG_)[1 + _eG_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if
          (!
           caml_call2(Core[246], next$0, first)
           && ! caml_call2(Core[90], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_135, to_add){
    var
     pool$0 = x_135[2],
     key$0 = key(pool$0, to_add),
     _ex_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_135)),
     _ey_ =
       _ex_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_135)) : _ex_;
    if(1 - _ey_){
     var pool = x_135[2], r = [0, 0], _em_ = 0, _en_ = 0;
     internal_iter
      (x_135,
       function(elt){
        var _eC_ = r[1], _eD_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _eD_], _eC_];
        return 0;
       });
     var
      elts_115 = caml_call1(Core_List[34], r[1]),
      max_allowed_key_113 = max_allowed_key$1(x_135),
      min_allowed_key_111 = min_allowed_key$1(x_135),
      bnds_110 = 0,
      _el_ =
        function(param){
         var
          key_105 = param[1],
          bnds_104 = [0, [1, [0, _aD_, [0, arg_108, 0]]], 0],
          arg_106 = caml_call1(sexp_of_t$7, key_105),
          bnds_104$0 = [0, [1, [0, _aE_, [0, arg_106, 0]]], bnds_104];
         return [1, bnds_104$0];
        },
      arg_116 = caml_call2(Core[421], _el_, elts_115),
      bnds_110$0 = [0, [1, [0, _aF_, [0, arg_116, 0]]], bnds_110],
      arg_114 = caml_call1(sexp_of_t$7, max_allowed_key_113),
      bnds_110$1 = [0, [1, [0, _aG_, [0, arg_114, 0]]], bnds_110$0],
      arg_112 = caml_call1(sexp_of_t$7, min_allowed_key_111),
      bnds_110$2 = [0, [1, [0, _aH_, [0, arg_112, 0]]], bnds_110$1],
      _eo_ =
        [0,
         [1,
          [0, _a7_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_135)), 0]]],
         [0, [1, [0, _a6_, [0, [1, bnds_110$2], _en_]]], _em_]],
      _ep_ =
        [0,
         [1,
          [0, _a8_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_135)), 0]]],
         _eo_],
      _eq_ = [0, [1, [0, _a9_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _ep_],
      _er_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _eq_]];
     caml_call1(Core[253], _er_);
    }
    var level_index = [0, 0];
    for(;;){
     var _ez_ = level_index[1];
     if
      (!
       caml_call2
        (symbol$18, key$0, caml_check_bound(x_135[5], _ez_)[1 + _ez_][10]))
      break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_135[5], level_index$0)[1 + level_index$0],
     _eA_ = caml_call2(symbol$15, key$0, level[9]),
     _eB_ = _eA_ ? caml_call2(symbol$16, key$0, level[10]) : _eA_;
    if(1 - _eB_){
     var
      _es_ = 0,
      _et_ = 0,
      _eu_ =
        [0,
         [1,
          [0,
           _a$_,
           [0, sexp_of_t$9(function(param){return _a__;}, level), _et_]]],
         _es_],
      _ev_ = [0, [1, [0, _ba_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _eu_],
      _ew_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _ev_]];
     caml_call1(Core[253], _ew_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _ej_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _ek_ = _ej_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _ek_) return _ek_;
    var
     _ef_ =
       [0,
        [1, [0, _bb_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _eg_ =
       [0,
        [1, [0, _bc_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _ef_],
     _eh_ = [0, [1, [0, _bd_, [0, caml_call1(sexp_of_t$7, key), 0]]], _eg_],
     _ei_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _eh_]];
    return caml_call1(Core[253], _ei_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _ed_ = caml_call1(null$1, 0),
     _ee_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _ee_, _ed_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _d$_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _d$_)[1 + _d$_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0],
     _ea_ = next(pool, elt);
    if(caml_call2(Core[246], elt, _ea_)){
     var _eb_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _eb_;
     return;
    }
    if(caml_call2(Core[246], elt, first)){
     var _ec_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _ec_;
    }
    var _d9_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _d9_);
    var _d__ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _d__);
   }
   var
    _be_ =
      [0,
       _D_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       _A_,
       _y_,
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       _w_,
       _v_,
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _be_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   function _bf_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _bg_ = 0,
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       _bg_,
       priority_queue,
       _bf_];
   function _bh_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _bi_ = [0, set_max_allowed_alarm_time],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       _bi_,
       max_allowed_alarm_time,
       _bh_];
   function _bj_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _bk_ = [0, set_now_interval_num_start],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       _bk_,
       now_interval_num_start,
       _bj_];
   function _bl_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _bm_ = [0, set_now],
    now$0 = [0, function(param){return 0;}, cst_now, _bm_, now, _bl_];
   function _bn_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _bo_ = 0,
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       _bo_,
       max_interval_num,
       _bn_];
   function _bp_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _bq_ = 0,
    start$0 = [0, function(param){return 0;}, cst_start, _bq_, start, _bp_];
   function _br_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _bs_ = 0,
    config$0 = [0, function(param){return 0;}, cst_config, _bs_, config, _br_];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[92], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _d8_ = of_external_exn(p[2], t);
    return at(p[2], _d8_);
   }
   function value$0(tw, t){
    var p = tw[7], _d7_ = of_external_exn(p[2], t);
    return value(p[2], _d7_);
   }
   function interval_num(tw, t){
    var p = tw[7], _d6_ = of_external_exn(p[2], t);
    return key(p[2], _d6_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[101], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_167 = t[3],
     start_165 = t[2],
     config_163 = t[1],
     now_169 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _d5_ = r[1], _d4_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _d4_], _d5_];
       return 0;
      });
    var alarms_171 = caml_call2(Core_List[58], r[1], compare$3), bnds_162 = 0;
    function _d3_(param){
     var
      value_159 = param[2],
      at_157 = param[1],
      arg_160 = caml_call1(sexp_of_a, value_159),
      bnds_156 = [0, [1, [0, _bt_, [0, arg_160, 0]]], 0],
      arg_158 = caml_call1(Core_Time_ns_alternate_sexp[92], at_157),
      bnds_156$0 = [0, [1, [0, _bu_, [0, arg_158, 0]]], bnds_156];
     return [1, bnds_156$0];
    }
    var
     arg_172 = caml_call2(Core[421], _d3_, alarms_171),
     bnds_162$0 = [0, [1, [0, _bv_, [0, arg_172, 0]]], bnds_162],
     arg_170 = caml_call1(Core_Time_ns_alternate_sexp[92], now_169),
     bnds_162$1 = [0, [1, [0, _bw_, [0, arg_170, 0]]], bnds_162$0],
     arg_168 = caml_call1(_be_[2], max_interval_num_167),
     bnds_162$2 = [0, [1, [0, _bx_, [0, arg_168, 0]]], bnds_162$1],
     arg_166 = caml_call1(Core_Time_ns_alternate_sexp[92], start_165),
     bnds_162$3 = [0, [1, [0, _by_, [0, arg_166, 0]]], bnds_162$2],
     arg_164 = sexp_of_t$3(config_163),
     bnds_162$4 = [0, [1, [0, _bz_, [0, arg_164, 0]]], bnds_162$3];
    return [1, bnds_162$4];
   }
   function length$3(t){return t[7][1];}
   function is_empty$0(t){
    var _d2_ = length$3(t);
    return caml_call2(Core[90], _d2_, 0);
   }
   function pool$1(t){return t[7][2];}
   function interval_num_internal(time, alarm_precision){
    var
     _d0_ = caml_call1(Core_Time_ns_alternate_sexp[61], time),
     _d1_ = caml_call2(Core_Int63[48], _d0_, alarm_precision);
    return caml_call1(_be_[35], _d1_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[98], time, min_time)){
     var
      _dY_ =
        [0,
         [1,
          [0, _bE_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], time), 0]]],
         0],
      _dZ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _dY_]];
     caml_call1(Core[253], _dZ_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_be_[36], interval_num),
     t$0 = t[1][1],
     _dX_ = caml_call2(Core_Int63[47], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[62], _dX_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_be_[7], interval_num, min_interval_num)){
     var
      _dR_ =
        [0, [1, [0, _bF_, [0, caml_call1(_be_[2], min_interval_num), 0]]], 0],
      _dS_ =
        [0, [1, [0, _bG_, [0, caml_call1(_be_[2], interval_num), 0]]], _dR_],
      _dT_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _dS_]];
     caml_call1(Core[253], _dT_);
    }
    if(caml_call2(_be_[6], interval_num, t[3])){
     var
      _dU_ = [0, [1, [0, _bH_, [0, caml_call1(_be_[2], t[3]), 0]]], 0],
      _dV_ =
        [0, [1, [0, _bI_, [0, caml_call1(_be_[2], interval_num), 0]]], _dU_],
      _dW_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _dV_]];
     caml_call1(Core[253], _dW_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_be_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_be_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_174){
    var elt = min_elt$1(x_174[7]);
    if(caml_call1(is_null, elt)){
     var
      _dJ_ = 0,
      _dK_ = 0,
      _dL_ =
        [0,
         [1,
          [0,
           _bB_,
           [0, sexp_of_t$10(function(param){return _bA_;}, x_174), _dK_]]],
         _dJ_],
      _dM_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _dL_]];
     caml_call1(Core[253], _dM_);
    }
    var key$0 = key(pool$1(x_174), elt);
    if(caml_call2(_be_[9], key$0, x_174[3])){
     var
      _dN_ = 0,
      _dO_ = 0,
      _dP_ =
        [0,
         [1,
          [0,
           _bD_,
           [0, sexp_of_t$10(function(param){return _bC_;}, x_174), _dO_]]],
         _dN_],
      _dQ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _dP_]];
     caml_call1(Core[253], _dQ_);
    }
    return next_alarm_fires_at_internal(x_174, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_be_[3], max_allowed_key, t[3])) return max_time;
    var
     _dF_ = Core_Time_ns[1][67],
     _dG_ = alarm_precision$0(t),
     _dH_ = caml_call2(Core_Time_ns[1][98], _dG_, _dF_),
     _dI_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[51], _dI_, _dH_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    function _c0_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      priority_queue_fun =
        check
         (function(t){
           var pool = t[2];
           function _c$_(param){
            function check(f){return caml_call2(Base_Invariant[2], t, f);}
            if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a3_], 1);
            var _df_ = min_allowed_key$1(t);
            if(! caml_call2(symbol$15, max_allowed_key$1(t), _df_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
            var
             levels_fun =
               check
                (function(levels){
                  var _dl_ = num_levels(t);
                  if(! caml_call2(Core[91], _dl_, 0))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _aV_], 1);
                  function _dm_(level_index$0, level){
                   if(! caml_call2(Core[90], level_index$0, level[1]))
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aU_], 1);
                   function _dn_(param){
                    function check(f){
                     return caml_call2(Base_Invariant[2], level, f);
                    }
                    var
                     slots_fun =
                       check
                        (function(slots){
                          function _du_(elt){
                           var _dx_ = 1 - caml_call1(is_null, elt);
                           if(! _dx_) return _dx_;
                           function _dv_(param){
                            if(! is_valid(pool, elt))
                             throw caml_maybe_attach_backtrace
                                    ([0, Assert_failure, _G_], 1);
                            caml_call1(invariant_a, value(pool, elt));
                            var n = next(pool, elt);
                            if(! caml_call1(is_null, n)){
                             var _dE_ = prev(pool, n);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dE_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _F_], 1);
                            }
                            var p = prev(pool, elt);
                            if(! caml_call1(is_null, p)){
                             var _dD_ = next(pool, p);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dD_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _E_], 1);
                            }
                            return 0;
                           }
                           function _dw_(x_062){
                            return sexp_of_t$8(function(param){return _H_;}, x_062);
                           }
                           caml_call4(Base_Invariant[1], _I_, elt, _dw_, _dv_);
                           return iter
                                   (pool,
                                    elt,
                                    function(elt){
                                     var _dy_ = level[9];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dy_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aL_], 1);
                                     var _dz_ = level[10];
                                     if(! caml_call2(symbol$16, key(pool, elt), _dz_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aK_], 1);
                                     var _dA_ = t[4];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dA_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aJ_], 1);
                                     var _dB_ = level[1], _dC_ = level_index(pool, elt);
                                     if(caml_call2(Core[90], _dC_, _dB_))
                                      return caml_call1(invariant_a, value(pool, elt));
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _aI_], 1);
                                    });
                          }
                          return caml_call2(Core_Array[22], slots, _du_);
                         }),
                     max_allowed_key_fun =
                       check
                        (function(max_allowed_key){
                          var
                           expect = add_clamp_to_max(level[9], level[7]),
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_128, b_129){
                           return caml_call2(compare$2, a_128, b_129);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos,
                                   sexp_of_t$7,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   max_allowed_key);
                         }),
                     min_allowed_key_fun =
                       check
                        (function(min_allowed_key){
                          if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                           throw caml_maybe_attach_backtrace
                                  ([0, Assert_failure, _aM_], 1);
                          var
                           _dt_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                          if(! _dt_) return _dt_;
                          var
                           got = caml_call2(rem, min_allowed_key, level[5]),
                           expect = _D_[24],
                           sexpifier = _D_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_126, b_127){
                           return caml_call2(_D_[9], a_126, b_127);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$0,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   got);
                         }),
                     length_fun =
                       check
                        (function(length){
                          function _dr_(n, first){
                           if(caml_call1(is_null, first)) return n;
                           var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                           for(;;){
                            if(! continue$0[1]) return n + r[1] | 0;
                            r[1]++;
                            var next$0 = next(pool, current[1]);
                            if(caml_call2(Core[246], next$0, first))
                             continue$0[1] = 0;
                            else
                             current[1] = next$0;
                           }
                          }
                          var _ds_ = caml_call3(Core_Array[23], level[11], 0, _dr_);
                          if(caml_call2(Core[90], length, _ds_)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aN_], 1);
                         }),
                     expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                     diff_max_min_allowed_key_fun =
                       check
                        (function(eta){
                          var sexpifier = _D_[1], equal = 0, message = 0, here = 0;
                          function comparator(a_124, b_125){
                           return caml_call2(_D_[9], a_124, b_125);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$1,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   eta);
                         }),
                     min_key_in_same_slot_mask_fun =
                       check
                        (function(min_key_in_same_slot_mask){
                          if
                           (caml_call2
                             (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                           return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aO_], 1);
                         }),
                     keys_per_slot_fun =
                       check
                        (function(keys_per_slot){
                          var
                           expect = num_keys(level[4]),
                           sexpifier = _D_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_122, b_123){
                           return caml_call2(_D_[9], a_122, b_123);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$2,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   keys_per_slot);
                         }),
                     bits_per_slot_fun =
                       check
                        (function(bits_per_slot){
                          if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aP_], 1);
                         }),
                     expect$0 = create$0(level[2]),
                     slots_mask_fun =
                       check
                        (function(eta){
                          var equal = 0, message = 0, here = 0;
                          function comparator(a_120, b_121){
                           return caml_call2(compare$0, a_120, b_121);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$3,
                                   sexp_of_t$4,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect$0,
                                   eta);
                         }),
                     bits_fun =
                       check
                        (function(bits){
                          if(caml_call2(symbol$1, bits, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aQ_], 1);
                         }),
                     index_fun =
                       check
                        (function(index){
                          if(caml_call2(Core[88], index, 0)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aR_], 1);
                         });
                    caml_call1(index_fun, index$0);
                    caml_call1(bits_fun, bits$0);
                    caml_call1(slots_mask_fun, slots_mask$0);
                    caml_call1(bits_per_slot_fun, bits_per_slot$0);
                    caml_call1(keys_per_slot_fun, keys_per_slot$0);
                    caml_call1
                     (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                    caml_call1
                     (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                    caml_call1(length_fun, length$0);
                    caml_call1(min_allowed_key_fun, min_allowed_key$0);
                    caml_call1(max_allowed_key_fun, max_allowed_key$0);
                    return caml_call1(slots_fun, slots$0);
                   }
                   function _do_(x_119){
                    return sexp_of_t$9(function(param){return _aS_;}, x_119);
                   }
                   caml_call4(Base_Invariant[1], _aT_, level, _do_, _dn_);
                   var _dp_ = caml_call2(Core[91], level_index$0, 0);
                   if(! _dp_) return _dp_;
                   var
                    _dq_ = level_index$0 - 1 | 0,
                    prev_level = caml_check_bound(levels, _dq_)[1 + _dq_],
                    got = level[5],
                    expect = caml_call1(_D_[33], prev_level[7]),
                    sexpifier = _D_[1],
                    equal = 0,
                    message = 0,
                    here = 0;
                   function comparator(a_131, b_132){
                    return caml_call2(_D_[9], a_131, b_132);
                   }
                   caml_call8
                    (Ppx_assert_lib_Runtime[3],
                     pos$4,
                     sexpifier,
                     comparator,
                     here,
                     message,
                     equal,
                     expect,
                     got);
                   var
                    got$0 = level[9],
                    expect$0 = compute_min_allowed_key(level, prev_level[10]),
                    equal$0 = 0,
                    message$0 = 0,
                    here$0 = 0;
                   function comparator$0(a_133, b_134){
                    return caml_call2(compare$2, a_133, b_134);
                   }
                   return caml_call8
                           (Ppx_assert_lib_Runtime[3],
                            pos$5,
                            sexp_of_t$7,
                            comparator$0,
                            here$0,
                            message$0,
                            equal$0,
                            expect$0,
                            got$0);
                  }
                  return caml_call2(Core_Array[58], levels, _dm_);
                 }),
             elt_key_lower_bound_fun =
               check
                (function(elt_key_lower_bound){
                  if
                   (!
                    caml_call2
                     (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _aY_], 1);
                  if
                   (!
                    caml_call2
                     (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _aX_], 1);
                  var _dk_ = 1 - caml_call1(is_null, t[3]);
                  if(! _dk_) return _dk_;
                  if
                   (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                   return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _aW_], 1);
                 }),
             min_elt_fun =
               check
                (function(elt){
                  var _di_ = 1 - caml_call1(is_null, elt);
                  if(! _di_) return _di_;
                  if(! is_valid(t[2], elt))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a0_], 1);
                  var _dj_ = key(t[2], elt);
                  if(caml_call2(equal$3, t[4], _dj_)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _aZ_], 1);
                 }),
             pool_fun =
               check
                (function(t){
                  function _dg_(_dh_){return 0;}
                  return caml_call2(Tuple_pool[36][5], _dg_, t);
                 }),
             length_fun =
               check
                (function(length){
                  if(caml_call2(Core[88], length, 0)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _a1_], 1);
                 });
            caml_call1(length_fun, length$2);
            caml_call1(pool_fun, pool$0);
            caml_call1(min_elt_fun, min_elt$0);
            caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
            return caml_call1(levels_fun, levels$0);
           }
           function _da_(x_130){
            function of_a_089(param){return _a4_;}
            var
             length_091 = x_130[1],
             pool_093 = x_130[2],
             min_elt_095 = x_130[3],
             elt_key_lower_bound_097 = x_130[4],
             levels_099 = x_130[5],
             bnds_090 = 0;
            function _dc_(_de_){return sexp_of_t$9(of_a_089, _de_);}
            var
             arg_100 = caml_call2(Core[288], _dc_, levels_099),
             bnds_090$0 = [0, [1, [0, _ay_, [0, arg_100, 0]]], bnds_090],
             arg_098 = caml_call1(sexp_of_t$7, elt_key_lower_bound_097),
             bnds_090$1 = [0, [1, [0, _az_, [0, arg_098, 0]]], bnds_090$0],
             arg_096 = sexp_of_t$8(of_a_089, min_elt_095),
             bnds_090$2 = [0, [1, [0, _aA_, [0, arg_096, 0]]], bnds_090$1];
            function _db_(_dd_){return sexp_of_pool_slots(of_a_089, _dd_);}
            var
             arg_094 = caml_call2(Tuple_pool[36][4], _db_, pool_093),
             bnds_090$3 = [0, [1, [0, _aB_, [0, arg_094, 0]]], bnds_090$2],
             arg_092 = caml_call1(Core[356], length_091),
             bnds_090$4 = [0, [1, [0, _aC_, [0, arg_092, 0]]], bnds_090$3];
            return [1, bnds_090$4];
           }
           return caml_call4(Base_Invariant[1], _a5_, t, _da_, _c$_);
          }),
      max_allowed_alarm_time_fun =
        check
         (function(max_allowed_alarm_time){
           var
            expect = compute_max_allowed_alarm_time(t),
            sexpifier = Core_Time_ns_alternate_sexp[92],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_183, b_184){
            return caml_call2(Core_Time_ns_alternate_sexp[101], a_183, b_184);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$6,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    max_allowed_alarm_time);
          }),
      now_interval_num_start_fun =
        check
         (function(now_interval_num_start){
           var
            expect = interval_num_start(t, now_interval_num(t)),
            sexpifier = Core_Time_ns_alternate_sexp[92],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_181, b_182){
            return caml_call2(Core_Time_ns_alternate_sexp[101], a_181, b_182);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$7,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    now_interval_num_start);
          }),
      now_fun =
        check
         (function(now){
           if(! caml_call2(Core_Time_ns_alternate_sexp[94], now, t[2]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bL_], 1);
           if(! caml_call2(Core_Time_ns_alternate_sexp[95], now, max_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bK_], 1);
           var _c9_ = min_allowed_key$1(t[7]), _c__ = interval_num$0(t, t[4]);
           if(caml_call2(_be_[9], _c__, _c9_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bJ_], 1);
          }),
      max_interval_num_fun =
        check
         (function(max_interval_num){
           var
            got = interval_num$0(t, max_time),
            sexpifier = _be_[2],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_177, b_178){
            return caml_call2(_be_[22], a_177, b_178);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$8,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             max_interval_num,
             got);
           var
            got$0 = interval_num$0(t, interval_num_start(t, max_interval_num)),
            sexpifier$0 = _be_[2],
            equal$0 = 0,
            message$0 = 0,
            here$0 = 0;
           function comparator$0(a_179, b_180){
            return caml_call2(_be_[22], a_179, b_180);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$9,
                    sexpifier$0,
                    comparator$0,
                    here$0,
                    message$0,
                    equal$0,
                    max_interval_num,
                    got$0);
          }),
      start_fun =
        check
         (function(start){
           if(! caml_call2(Core_Time_ns_alternate_sexp[94], start, min_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bN_], 1);
           if(caml_call2(Core_Time_ns_alternate_sexp[95], start, max_time))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bM_], 1);
          }),
      config_fun = check(invariant$1);
     caml_call1(config_fun, config$0);
     caml_call1(start_fun, start$0);
     caml_call1(max_interval_num_fun, max_interval_num$0);
     caml_call1(now_fun, now$0);
     caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
     caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
     caml_call1(priority_queue_fun, priority_queue$0);
     return iter$0
             (t,
              function(alarm){
               var
                _c2_ = interval_num$0(t, at$0(t, alarm)),
                _c3_ = interval_num(t, alarm);
               if(! caml_call2(_be_[9], _c3_, _c2_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bQ_], 1);
               var
                _c4_ = interval_start(t, t[4]),
                _c5_ = interval_start(t, at$0(t, alarm));
               if(! caml_call2(Core_Time_ns_alternate_sexp[94], _c5_, _c4_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bP_], 1);
               var
                _c6_ = alarm_precision$0(t),
                _c7_ = caml_call2(Core_Time_ns_alternate_sexp[54], t[4], _c6_),
                _c8_ = at$0(t, alarm);
               if(caml_call2(Core_Time_ns_alternate_sexp[97], _c8_, _c7_))
                return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bO_], 1);
              });
    }
    function _c1_(x_176){
     return sexp_of_t$10(function(param){return _bR_;}, x_176);
    }
    return caml_call4(Base_Invariant[1], _bS_, t, _c1_, _c0_);
   }
   var debug = 0;
   function advance_clock(t, to, handle_removed){
    var _cY_ = caml_call2(Core_Time_ns_alternate_sexp[97], to, t[4]);
    if(_cY_){
     t[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t, to);
     t[5] = interval_num_start_unchecked(t, t_min_allowed_key);
     var t$0 = t[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$0)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$0[5],
       num_levels$0 = num_levels(t$0);
      for(;;){
       if(! caml_call2(Core[92], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$0[4])){
         t$0[3] = caml_call1(null$1, 0);
         t$0[4] = min_allowed_key$1(t$0);
        }
        var match = result[1];
        break;
       }
       var
        _cX_ = level_index[1],
        level = caml_check_bound(levels, _cX_)[1 + _cX_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot$0
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$0[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[90], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _cU_ = slot$0[1],
          first = caml_check_bound(slots, _cU_)[1 + _cU_];
         if(1 - caml_call1(is_null, first)){
          var _cV_ = caml_call1(null$1, 0), _cW_ = slot$0[1];
          caml_check_bound(slots, _cW_)[1 + _cW_] = _cV_;
          var pool = t$0[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$0, current[1]);
           else{
            t$0[1] = t$0[1] - 1 | 0;
            caml_call1(handle_removed, current[1]);
            caml_call2(free, pool, current[1]);
           }
           if(caml_call2(Core[246], next$0, first))
            continue$0[1] = 0;
           else
            current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t[6] = compute_max_allowed_alarm_time(t); return 0;}
     var _cZ_ = debug;
    }
    else
     var _cZ_ = _cY_;
    return _cZ_;
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[98],
        start,
        Core_Time_ns_alternate_sexp[43])){
     var
      _cK_ =
        [0,
         [1,
          [0,
           _bT_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[92], start), 0]]],
         0],
      _cL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _cK_]];
     caml_call1(Core[253], _cL_);
    }
    var level_bits = config[2], capacity$0 = config[3];
    function _cG_(index, param, level_bits){
     var
      levels = param[3],
      max_level_min_allowed_key = param[2],
      bits_per_slot = param[1],
      keys_per_slot = num_keys(bits_per_slot),
      diff_max_min_allowed_key =
        compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
      min_key_in_same_slot_mask = create$1(bits_per_slot),
      min_allowed_key =
        min_key_in_same_slot
         (max_level_min_allowed_key, min_key_in_same_slot_mask),
      max_allowed_key =
        add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
      _cO_ = caml_call1(null$1, 0),
      _cP_ = pow2(level_bits),
      _cQ_ = caml_call1(Core_Int63[5], _cP_),
      _cR_ = caml_call2(Core_Array[38], _cQ_, _cO_),
      level =
        [0,
         index,
         level_bits,
         create$0(level_bits),
         bits_per_slot,
         keys_per_slot,
         min_key_in_same_slot_mask,
         diff_max_min_allowed_key,
         0,
         min_allowed_key,
         max_allowed_key,
         _cR_],
      _cS_ = [0, level, levels],
      _cT_ =
        caml_call2(symbol$17, max_allowed_key, max_value$0)
         ? max_value$0
         : caml_call1(succ$0, max_allowed_key);
     return [0, symbol$2(level_bits, bits_per_slot), _cT_, _cS_];
    }
    var
     levels =
       caml_call3(Core_List[95], level_bits, [0, zero, zero$1, 0], _cG_)[3],
     _cH_ = caml_call1(Core_Array[90], levels),
     _cI_ = caml_call1(null$1, 0);
    if(capacity$0)
     var sth = capacity$0[1], capacity = sth;
    else
     var capacity = 1;
    var
     _cJ_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _cI_,
        zero$1,
        _cH_],
     _cM_ = Core_Time_ns_alternate_sexp[46],
     _cN_ = Core_Time_ns_alternate_sexp[46],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _cN_,
        _cM_,
        max_time,
        _cJ_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bU_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var _cF_ = interval_num_start(t, at);
    return internal_add(t[7], at, _cF_, value);
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[97], at, t[6])){
     var
      _cy_ =
        [0,
         [1,
          [0, _bV_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[6]), 0]]],
         0],
      _cz_ =
        [0,
         [1,
          [0, _bW_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
         _cy_],
      _cA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _cz_]];
     caml_call1(Core[253], _cA_);
    }
    var _cE_ = caml_call2(Core_Time_ns_alternate_sexp[98], at, t[5]);
    if(! _cE_) return _cE_;
    var
     _cB_ =
       [0,
        [1,
         [0, _bX_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[5]), 0]]],
        0],
     _cC_ =
       [0,
        [1,
         [0, _bY_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
        _cB_],
     _cD_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _cC_]];
    return caml_call1(Core[253], _cD_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var _cx_ = interval_num_unchecked(t, at);
    return internal_add(t[7], _cx_, at, value);
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _co_ = 1 - is_empty(t$0);
    if(_co_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _cq_ = levels.length - 1 - 1 | 0,
      _cp_ = 0;
     if(_cq_ >= 0){
      var level_index = _cp_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _ct_ = slots.length - 1 - 1 | 0, _cs_ = 0;
        if(_ct_ >= 0){
         var slot_index = _cs_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _cv_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _cv_;
          }
          var _cw_ = slot_index + 1 | 0;
          if(_ct_ === slot_index) break;
          var slot_index = _cw_;
         }
        }
       }
       var _cu_ = level_index + 1 | 0;
       if(_cq_ === level_index) break;
       var level_index = _cu_;
      }
     }
     var _cr_ = 0;
    }
    else
     var _cr_ = _co_;
    return _cr_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[6], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_185){
    var elt = min_elt$1(x_185[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_185), elt);
    var
     _ck_ = 0,
     _cl_ = 0,
     _cm_ =
       [0,
        [1,
         [0,
          _b0_,
          [0, sexp_of_t$10(function(param){return _bZ_;}, x_185), _cl_]]],
        _ck_],
     _cn_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _cm_]];
    return caml_call1(Core[253], _cn_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[43]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _ci_ = max_alarm_time[1], _cj_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[103], _cj_, _ci_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[45]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _cg_ = min_alarm_time[1], _ch_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[102], _ch_, _cg_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_186){
    var elt = min_elt$1(x_186[7]);
    if(caml_call1(is_null, elt)){
     var
      _cc_ = 0,
      _cd_ = 0,
      _ce_ =
        [0,
         [1,
          [0,
           _b2_,
           [0, sexp_of_t$10(function(param){return _b1_;}, x_186), _cd_]]],
         _cc_],
      _cf_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _ce_]];
     caml_call1(Core[253], _cf_);
    }
    return max_alarm_time_in_list(x_186, elt);
   }
   function min_alarm_time_in_min_interval$0(x_187){
    var elt = min_elt$1(x_187[7]);
    if(caml_call1(is_null, elt)){
     var
      _b__ = 0,
      _b$_ = 0,
      _ca_ =
        [0,
         [1,
          [0,
           _b4_,
           [0, sexp_of_t$10(function(param){return _b3_;}, x_187), _b$_]]],
         _b__],
      _cb_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _ca_]];
     caml_call1(Core[253], _cb_);
    }
    return min_alarm_time_in_list(x_187, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _b5_ = caml_call2(Core[91], level[8], 0);
    if(_b5_){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _b6_ = 1 - caml_call1(is_null, first[1]);
     if(_b6_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _b8_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(caml_call2(Core[246], next$0, first[1]))
        continue$0[1] = 0;
       else
        current[1] = next$0;
       var _b7_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[95], _b7_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _b8_ = _b6_;
     var _b9_ = _b8_;
    }
    else
     var _b9_ = _b5_;
    return _b9_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        one_nanosecond,
        about_one_day,
        about_one_microsecond,
        about_one_millisecond,
        about_one_second,
        mul,
        div,
        _l_],
       sexp_of_t$10,
       sexp_of_t_now,
       _be_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(219, Timing_wheel, cst_Timing_wheel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzEwOCIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMzkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImludmFyaWFudCQwIiwibnVtX2tleV9iaXRzIiwidF9vZl9zZXhwJDAiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJlcXVhbCQwIiwieF8wMTIiLCJ4XzAxMyIsInRvX3NleHBhYmxlIiwic2V4cF9vZl90JDEiLCJvbmVfbmFub3NlY29uZCIsImFib3V0X29uZV9taWNyb3NlY29uZCIsImFib3V0X29uZV9taWxsaXNlY29uZCIsImFib3V0X29uZV9zZWNvbmQiLCJhYm91dF9vbmVfZGF5IiwibXVsIiwiZGl2Iiwib2Zfc3Bhbl9mbG9vcl9wb3cyX25zIiwic3BhbiIsImxldmVsX2JpdHMiLCJyIiwidiIsImxldmVsX2JpdHMkMCIsInRfb2Zfc2V4cCQyIiwic2V4cF8wMTkiLCJmaWVsZF9zZXhwc18wMjAiLCJhbGFybV9wcmVjaXNpb25fMDIxIiwibGV2ZWxfYml0c18wMjMiLCJjYXBhY2l0eV8wMjUiLCJkdXBsaWNhdGVzXzAyNyIsImV4dHJhXzAyOCIsInNleHBfMDE5JDAiLCJmaWVsZF9zZXhwc18wMzEiLCJmaWVsZF9uYW1lXzAyOSIsInRhaWxfMDQxIiwiZmllbGRfc2V4cF8wMzAkMyIsImZpZWxkX3NleHBfMDMwIiwieF8wNDIiLCJmaWVsZF9zZXhwXzAzMCQwIiwiZnZhbHVlXzAzNCIsImZpZWxkX3NleHBfMDMwJDEiLCJmdmFsdWVfMDMyIiwiZmllbGRfc2V4cF8wMzAkMiIsImZ2YWx1ZV8wMzUiLCJsZXZlbF9iaXRzXzAyNCIsIm1hdGNoIiwiYWxhcm1fcHJlY2lzaW9uXzAyMiIsInZfMDM4Iiwidl8wMzgkMCIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDQ4IiwibGV2ZWxfYml0c18wNDYiLCJhbGFybV9wcmVjaXNpb25fMDQ0IiwiYm5kc18wNDMiLCJ2XzA0OSIsImFyZ18wNTEiLCJibmRfMDUwIiwiYm5kc18wNDMkMCIsImFyZ18wNDciLCJibmRzXzA0MyQxIiwiYXJnXzA0NSIsImJuZHNfMDQzJDIiLCJhbGFybV9wcmVjaXNpb24iLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMSIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJsb29wIiwicmVtYWluaW5nIiwidCQwIiwiYiIsIm1pY3Jvc2Vjb25kX3ByZWNpc2lvbiIsImR1cmF0aW9ucyIsIm51bV9iaXRzX2FjY3VtIiwibGV2ZWxfbnVtX2JpdHMiLCJudW1fYml0c19hY2N1bSQwIiwiZHVyYXRpb24iLCJjb21wYXJlJDAiLCJzZXhwX29mX3QkNCIsImNyZWF0ZSQwIiwibnVtX2tleXMiLCJjcmVhdGUkMSIsImJpdHNfcGVyX3Nsb3QiLCJ0b19pbnQ2MyIsIm9mX2ludDYzIiwic2NhbGVfaW50Iiwic2V4cF9vZl90JDciLCJvZl9pbnQ2MyQwIiwidG9faW50NjMkMCIsImFkZCIsImFkZF9jbGFtcF90b19tYXgiLCJzdWIiLCJkaWZmIiwibWluX2tleV9pbl9zYW1lX3Nsb3QiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIiwic2V4cF9vZl9wb29sX3Nsb3RzIiwib2ZfYV8wNTQiLCJ4XzA1NSIsInNleHBfb2ZfdCQ4Iiwib2ZfYV8wNTYiLCJ4XzA1NyIsIm51bGwkMCIsIm51bGwkMSIsImlzX251bGwiLCJmcmVlIiwia2V5IiwicCIsImF0IiwidmFsdWUiLCJsZXZlbF9pbmRleCIsInByZXYiLCJzZXRfcHJldiIsIngiLCJuZXh0Iiwic2V0X25leHQiLCJpc192YWxpZCIsImdyb3ciLCJpc19mdWxsIiwib2ZfZXh0ZXJuYWxfZXhuIiwicG9vbCIsImxpbmsiLCJpdGVyIiwiZmlyc3QiLCJmIiwiY3VycmVudCIsImNvbnRpbnVlJDAiLCJuZXh0JDAiLCJzbG90cyIsIm1heF9hbGxvd2VkX2tleSIsInNldF9tYXhfYWxsb3dlZF9rZXkiLCJtaW5fYWxsb3dlZF9rZXkiLCJzZXRfbWluX2FsbG93ZWRfa2V5IiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsImRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSIsImtleXNfcGVyX3Nsb3QiLCJzbG90c19tYXNrIiwiaW5kZXgiLCJzbG90cyQwIiwibWF4X2FsbG93ZWRfa2V5JDAiLCJtaW5fYWxsb3dlZF9rZXkkMCIsImxlbmd0aCQwIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5JDAiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrJDAiLCJrZXlzX3Blcl9zbG90JDAiLCJiaXRzX3Blcl9zbG90JDAiLCJzbG90c19tYXNrJDAiLCJiaXRzJDAiLCJpbmRleCQwIiwic2V4cF9vZl90JDkiLCJvZl9hXzA2NSIsImRpZmZfbWF4X21pbl9hbGxvd2VkX2tleV8wNzkiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXzA3NyIsImtleXNfcGVyX3Nsb3RfMDc1IiwiYml0c19wZXJfc2xvdF8wNzMiLCJzbG90c19tYXNrXzA3MSIsImJpdHNfMDY5IiwiaW5kZXhfMDY3IiwibGVuZ3RoXzA4MSIsIm1pbl9hbGxvd2VkX2tleV8wODMiLCJtYXhfYWxsb3dlZF9rZXlfMDg1Iiwic2xvdHNfMDg3IiwiYXJnXzA4OCIsImJuZHNfMDY2IiwiYXJnXzA4NiIsImJuZHNfMDY2JDAiLCJhcmdfMDg0IiwiYm5kc18wNjYkMSIsImFyZ18wODIiLCJibmRzXzA2NiQyIiwiYXJnXzA4MCIsImJuZHNfMDY2JDMiLCJhcmdfMDc4IiwiYm5kc18wNjYkNCIsImFyZ18wNzYiLCJibmRzXzA2NiQ1IiwiYXJnXzA3NCIsImJuZHNfMDY2JDYiLCJhcmdfMDcyIiwiYm5kc18wNjYkNyIsImFyZ18wNzAiLCJibmRzXzA2NiQ4IiwiYXJnXzA2OCIsImJuZHNfMDY2JDkiLCJzbG90IiwibmV4dF9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3QkMCIsImNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkiLCJsZXZlbHMiLCJlbHRfa2V5X2xvd2VyX2JvdW5kIiwic2V0X2VsdF9rZXlfbG93ZXJfYm91bmQiLCJtaW5fZWx0Iiwic2V0X21pbl9lbHQiLCJzZXRfcG9vbCIsImxlbmd0aCQxIiwic2V0X2xlbmd0aCQwIiwibGV2ZWxzJDAiLCJlbHRfa2V5X2xvd2VyX2JvdW5kJDAiLCJtaW5fZWx0JDAiLCJwb29sJDAiLCJsZW5ndGgkMiIsImlzX2VtcHR5IiwibnVtX2xldmVscyIsIm1pbl9hbGxvd2VkX2tleSQxIiwibWF4X2FsbG93ZWRfa2V5JDEiLCJpbnRlcm5hbF9pdGVyIiwibGV2ZWwiLCJzbG90X2luZGV4IiwiZWx0IiwiY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rIiwibWluX2VsdCQxIiwibWluX2VsdF9hbHJlYWR5X2ZvdW5kIiwibWluX2tleV9hbHJlYWR5X2ZvdW5kIiwibnVtX2xldmVscyQwIiwic2xvdF9taW5fa2V5Iiwic2xvdCQwIiwiY3VycmVudF9rZXkiLCJhZGRfZWx0IiwieF8xMzUiLCJ0b19hZGQiLCJrZXkkMCIsImVsdHNfMTE1IiwibWF4X2FsbG93ZWRfa2V5XzExMyIsIm1pbl9hbGxvd2VkX2tleV8xMTEiLCJibmRzXzExMCIsImtleV8xMDUiLCJibmRzXzEwNCIsImFyZ18xMDYiLCJibmRzXzEwNCQwIiwiYXJnXzExNiIsImJuZHNfMTEwJDAiLCJhcmdfMTE0IiwiYm5kc18xMTAkMSIsImFyZ18xMTIiLCJibmRzXzExMCQyIiwibGV2ZWxfaW5kZXgkMCIsInByZXYkMCIsImludGVybmFsX2FkZF9lbHQiLCJlbnN1cmVfdmFsaWRfa2V5IiwiaW50ZXJuYWxfYWRkIiwiaW50ZXJuYWxfcmVtb3ZlIiwibWluX2ludGVydmFsX251bSIsInByaW9yaXR5X3F1ZXVlIiwibWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsInNldF9tYXhfYWxsb3dlZF9hbGFybV90aW1lIiwibm93X2ludGVydmFsX251bV9zdGFydCIsInNldF9ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Iiwibm93Iiwic2V0X25vdyIsIm1heF9pbnRlcnZhbF9udW0iLCJzdGFydCIsImNvbmZpZyIsInByaW9yaXR5X3F1ZXVlJDAiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lJDAiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0JDAiLCJub3ckMCIsIm1heF9pbnRlcnZhbF9udW0kMCIsInN0YXJ0JDAiLCJjb25maWckMCIsInNleHBfb2ZfdF9ub3ciLCJhbGFybV9wcmVjaXNpb24kMCIsImF0JDAiLCJ0dyIsInZhbHVlJDAiLCJpbnRlcnZhbF9udW0iLCJpdGVyJDAiLCJjb21wYXJlJDMiLCJzZXhwX29mX3QkMTAiLCJzZXhwX29mX2EiLCJtYXhfaW50ZXJ2YWxfbnVtXzE2NyIsInN0YXJ0XzE2NSIsImNvbmZpZ18xNjMiLCJub3dfMTY5IiwiYWxhcm0iLCJhbGFybXNfMTcxIiwiYm5kc18xNjIiLCJ2YWx1ZV8xNTkiLCJhdF8xNTciLCJhcmdfMTYwIiwiYm5kc18xNTYiLCJhcmdfMTU4IiwiYm5kc18xNTYkMCIsImFyZ18xNzIiLCJibmRzXzE2MiQwIiwiYXJnXzE3MCIsImJuZHNfMTYyJDEiLCJhcmdfMTY4IiwiYm5kc18xNjIkMiIsImFyZ18xNjYiLCJibmRzXzE2MiQzIiwiYXJnXzE2NCIsImJuZHNfMTYyJDQiLCJsZW5ndGgkMyIsImlzX2VtcHR5JDAiLCJwb29sJDEiLCJpbnRlcnZhbF9udW1faW50ZXJuYWwiLCJ0aW1lIiwiaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCIsImludGVydmFsX251bSQwIiwiaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCIsImludGVydmFsX251bV9zdGFydCIsIm5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0IiwibmV4dF9hbGFybV9maXJlc19hdF9leG4iLCJ4XzE3NCIsImNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsIm5vd19pbnRlcnZhbF9udW0iLCJtYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0iLCJpbnRlcnZhbF9zdGFydCIsImludmFyaWFudCQyIiwiaW52YXJpYW50X2EiLCJjaGVjayIsInByaW9yaXR5X3F1ZXVlX2Z1biIsImxldmVsc19mdW4iLCJzbG90c19mdW4iLCJuIiwieF8wNjIiLCJtYXhfYWxsb3dlZF9rZXlfZnVuIiwiZXhwZWN0IiwiZXF1YWwiLCJtZXNzYWdlIiwiaGVyZSIsImNvbXBhcmF0b3IiLCJhXzEyOCIsImJfMTI5IiwibWluX2FsbG93ZWRfa2V5X2Z1biIsImdvdCIsInNleHBpZmllciIsImFfMTI2IiwiYl8xMjciLCJsZW5ndGhfZnVuIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5X2Z1biIsImV0YSIsImFfMTI0IiwiYl8xMjUiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrX2Z1biIsImtleXNfcGVyX3Nsb3RfZnVuIiwiYV8xMjIiLCJiXzEyMyIsImJpdHNfcGVyX3Nsb3RfZnVuIiwiZXhwZWN0JDAiLCJzbG90c19tYXNrX2Z1biIsImFfMTIwIiwiYl8xMjEiLCJiaXRzX2Z1biIsImluZGV4X2Z1biIsInhfMTE5IiwicHJldl9sZXZlbCIsImFfMTMxIiwiYl8xMzIiLCJnb3QkMCIsIm1lc3NhZ2UkMCIsImhlcmUkMCIsImNvbXBhcmF0b3IkMCIsImFfMTMzIiwiYl8xMzQiLCJlbHRfa2V5X2xvd2VyX2JvdW5kX2Z1biIsIm1pbl9lbHRfZnVuIiwicG9vbF9mdW4iLCJ4XzEzMCIsIm9mX2FfMDg5IiwibGVuZ3RoXzA5MSIsInBvb2xfMDkzIiwibWluX2VsdF8wOTUiLCJlbHRfa2V5X2xvd2VyX2JvdW5kXzA5NyIsImxldmVsc18wOTkiLCJibmRzXzA5MCIsImFyZ18xMDAiLCJibmRzXzA5MCQwIiwiYXJnXzA5OCIsImJuZHNfMDkwJDEiLCJhcmdfMDk2IiwiYm5kc18wOTAkMiIsImFyZ18wOTQiLCJibmRzXzA5MCQzIiwiYXJnXzA5MiIsImJuZHNfMDkwJDQiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lX2Z1biIsImFfMTgzIiwiYl8xODQiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0X2Z1biIsImFfMTgxIiwiYl8xODIiLCJub3dfZnVuIiwibWF4X2ludGVydmFsX251bV9mdW4iLCJhXzE3NyIsImJfMTc4Iiwic2V4cGlmaWVyJDAiLCJhXzE3OSIsImJfMTgwIiwic3RhcnRfZnVuIiwiY29uZmlnX2Z1biIsInhfMTc2IiwiZGVidWciLCJhZHZhbmNlX2Nsb2NrIiwidG8iLCJoYW5kbGVfcmVtb3ZlZCIsInRfbWluX2FsbG93ZWRfa2V5IiwicmVzdWx0IiwibWluX2FsbG93ZWRfa2V5X2JlZm9yZSIsInByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5JDAiLCJkZXNpcmVkX21pbl9hbGxvd2VkX2tleSIsImxldmVsX21pbl9hbGxvd2VkX2tleSIsImxldmVsX21pbl9hbGxvd2VkX2tleSQwIiwiY3JlYXRlJDIiLCJjYXBhY2l0eSQwIiwibWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSIsImFkZF9hdF9pbnRlcnZhbF9udW0iLCJlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIiwiYWRkJDAiLCJyZW1vdmUiLCJjbGVhciIsImZyZWVfZWx0IiwibWVtIiwicmVzY2hlZHVsZV9nZW4iLCJyZXNjaGVkdWxlIiwicmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIiwibWluX2FsYXJtX2ludGVydmFsX251bV9leG4iLCJ4XzE4NSIsIm1heF9hbGFybV90aW1lX2luX2xpc3QiLCJ3aXRoX2tleSIsIm1heF9hbGFybV90aW1lIiwibWluX2FsYXJtX3RpbWVfaW5fbGlzdCIsIm1pbl9hbGFybV90aW1lIiwibWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIiwibWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJ4XzE4NiIsIm1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCQwIiwieF8xODciLCJmaXJlX3Bhc3RfYWxhcm1zIiwiaGFuZGxlX2ZpcmVkIl0sInNvdXJjZXMiOlsiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9jb3JlX2tlcm5lbC90aW1pbmdfd2hlZWwvdGltaW5nX3doZWVsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUE4bEQwQkE7SUFIQUM7SUFnQkFDO0lBS0FDO0lBL3hCaEJDO0lBNEpzQkM7SUFIQUM7SUFyR0RDO0lBT0RDO0lBWUNDO0lBa0JDQztJQUtGQzs7SUFyc0I1QkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXpMa0Q7SUFJaERDO0lBQ0FDOzs7Ozs7Ozs7SUFzREVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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NkNBc0Q7UUFQQUQ7T0FxNENGOFU7T0E5T0FoSjtPQVhRYjtPQUhSRztPQXlFQTJDO09BREFEO09BOUNBM0I7T0F3RUFpQztPQThFQVE7T0EvQ0FOO09Ba0RBUTtPQXFEQXNGO09BK0pBcUM7T0FsWVE1TDtPQTJLUitEO09BRUFDO09BZ0lBc0c7T0EvQkFGO09BMkNBTTtPQUZBSDtPQVdBSztPQUVBQztPQVpBTDtPQWdCQU07T0FLQUM7T0FxQkFPO09BS0FDO09BS0FDO09BV0FFO09BMU9BL0g7T0FXQUM7V0FuZ0RBMVUsVUFnOENBa1UsMkJBcjZDRTlUOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIEJlIHN1cmUgYW5kIGZpcnN0IHJlYWQgdGhlIGltcGxlbWVudGF0aW9uIG92ZXJ2aWV3IGluIHRpbWluZ193aGVlbF9pbnRmLm1sLlxuXG4gICBBIHRpbWluZyB3aGVlbCBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBcImxldmVsc1wiLCB3aGVyZSBlYWNoIGxldmVsIGlzIGFuIGFycmF5IG9mXG4gICBcInNsb3RzXCIuICBFYWNoIHNsb3QgcmVwcmVzZW50cyBhIHJhbmdlIG9mIGtleXMsIGFuZCBob2xkcyBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGhcbiAgIHRob3NlIGtleXMuICBFYWNoIGxldmVsIGlzIGRldGVybWluZWQgYnkgdHdvIHBhcmFtZXRlcnM6IFtiaXRzXSwgdGhlIG51bWJlciBvZiBrZXkgYml0c1xuICAgdGhhdCB0aGF0IGxldmVsIGlzIHJlc3BvbnNpYmxlIGZvciBkaXN0aW5ndWlzaGluZywgYW5kIFtiaXRzX3Blcl9zbG90XSwgdGhlIHNpemUgb2YgdGhlXG4gICByYW5nZSBvZiBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBzbG90IGluIHRoZSBhcnJheS4gIENvbmNlcHR1YWxseSwgZWFjaCBsZXZlbFxuICAgYnJlYWtzIHVwIGFsbCBwb3NzaWJsZSBrZXlzIGludG8gcmFuZ2VzIG9mIHNpemUgWzJeYml0c19wZXJfc2xvdF0uICBUaGUgbGVuZ3RoIG9mIGFcbiAgIGxldmVsIGFycmF5IGlzIFsyXmJpdHNdLCBhbmQgdGhlIGFycmF5IGlzIHVzZWQgbGlrZSBhIGNpcmN1bGFyIGJ1ZmZlciB0byB0cmF2ZXJzZSB0aGVcbiAgIHJhbmdlcyBhcyB0aGUgdGltaW5nIHdoZWVsJ3MgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLiAgQSBrZXkgW2tdLCBpZiBzdG9yZWQgaW4gdGhlXG4gICBsZXZlbCwgaXMgc3RvcmVkIGF0IGluZGV4IFsoayAvIDJeYml0c19wZXJfc2xvdCkgbW9kIDJeYml0c10uXG5cbiAgIFRoZSBzZXR0aW5ncyBvZiB0aGUgW2JpdHNdIHZhbHVlcyBhcmUgY29uZmlndXJhYmxlIGJ5IHVzZXIgY29kZSB1c2luZyBbTGV2ZWxfYml0c10sXG4gICBhbHRob3VnaCB0aGVyZSBpcyBhIHJlYXNvbmFibGUgZGVmYXVsdCBzZXR0aW5nLiAgR2l2ZW4gdGhlIFtiaXRzXSB2YWx1ZXMsIHRoZVxuICAgW2JpdHNfcGVyX3Nsb3RdIGFyZSBjaG9zZW4gc28gdGhhdCBbYml0c19wZXJfc2xvdF0gYXQgbGV2ZWwgW2ldIGlzIHRoZSBzdW0gb2YgdGhlXG4gICBbYml0c10gYXQgYWxsIGxvd2VyIGxldmVscy4gIFRodXMsIGEgc2xvdCdzIHJhbmdlIGF0IGxldmVsIFtpXSBpcyBhcyBsYXJnZSBhcyB0aGVcbiAgIGVudGlyZSByYW5nZSBvZiB0aGUgYXJyYXkgYXQgbGV2ZWwgW2kgLSAxXS5cblxuICAgRWFjaCBsZXZlbCBoYXMgYSBbbWluX2FsbG93ZWRfa2V5XSBhbmQgYSBbbWF4X2FsbG93ZWRfa2V5XSB0aGF0IGRldGVybWluZSB0aGUgcmFuZ2Ugb2ZcbiAgIGtleXMgdGhhdCBpdCBjdXJyZW50bHkgcmVwcmVzZW50cy4gIFRoZSBjcnVjaWFsIGludmFyaWFudCBvZiB0aGUgdGltaW5nIHdoZWVsIGRhdGFcbiAgIHN0cnVjdHVyZSBpcyB0aGF0IHRoZSBbbWluX2FsbG93ZWRfa2V5XSBhdCBsZXZlbCBbaV0gaXMgbm8gbW9yZSB0aGFuIHRoZVxuICAgW21heF9hbGxvd2VkX2tleSArIDFdIG9mIGxldmVsIFtpIC0gMV0uICBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbGV2ZWxzIGNhbiByZXByZXNlbnQgYWxsXG4gICBrZXlzIGZyb20gdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIHRoZSBsb3dlc3QgbGV2ZWwgdG8gdGhlIFttYXhfYWxsb3dlZF9rZXldIG9mIHRoZVxuICAgaGlnaGVzdCBsZXZlbC4gIFRoZSBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcmVzdG9yaW5nXG4gICB0aGlzIGludmFyaWFudC5cblxuICAgQXQgbGV2ZWwgMCwgW2JpdHNfcGVyX3Nsb3QgPSAwXSwgYW5kIHNvIHRoZSBzaXplIG9mIGVhY2ggc2xvdCBpcyBbMV0uICBUaGF0IGlzLCBsZXZlbCAwXG4gICBwcmVjaXNlbHkgZGlzdGluZ3Vpc2hlcyBhbGwgdGhlIGtleXMgYmV0d2VlbiBpdHMgW21pbl9hbGxvd2VkX2tleV0gKHdoaWNoIGlzIHRoZSBzYW1lXG4gICBhcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGVudGlyZSB0aW1pbmcgd2hlZWwpIGFuZCBbbWF4X2FsbG93ZWRfa2V5XS4gIEFzIHRoZVxuICAgbGV2ZWxzIGluY3JlYXNlLCB0aGUgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCB0aGUgW2JpdHNfcGVyX3Nsb3RdIGluY3JlYXNlcywgYW5kXG4gICB0aGUgcmFuZ2Ugb2Yga2V5cyBzdG9yZWQgaW4gdGhlIGxldmVsIGluY3JlYXNlcyAoZHJhbWF0aWNhbGx5KS5cblxuICAgVGhlIGlkZWEgb2YgdGhlIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gdGhlIGhpZXJhcmNoaWNhbCBhcHByb2FjaCBkZXNjcmliZWQgaW46XG5cbiAgIHt2XG4gICAgIEhhc2hlZCBhbmQgSGllcmFyY2hpY2FsIFRpbWluZyBXaGVlbHM6XG4gICAgIEVmZmljaWVudCBEYXRhIFN0cnVjdHVyZXMgZm9yIEltcGxlbWVudGluZyBhIFRpbWVyIEZhY2lsaXR5XG5cbiAgICAgVmFyZ2hlc2UgJiBMYXVjaywgMTk5NlxuICAgdn1cblxuICAgSG93ZXZlciwgdGhlIGNvZGUgaXMgY29tcGxldGVseSBuZXcuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgVGltaW5nX3doZWVsX2ludGZcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxubW9kdWxlIFRpbWVfbnMgPSBDb3JlX3ByaXZhdGUuVGltZV9uc19hbHRlcm5hdGVfc2V4cFxuXG5sZXQgc2V4cF9vZl90X3N0eWxlIDogWyBgUHJldHR5IHwgYEludGVybmFsIF0gcmVmID0gcmVmIGBQcmV0dHlcblxuKCogW3ttYXgsbWlufV90aW1lXSBhcmUgYm91bmRzIG9uIHRoZSB0aW1lcyBzdXBwb3J0ZWQgYnkgYSB0aW1pbmcgd2hlZWwuICopXG5cbmxldCBtYXhfdGltZSA9IFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGVcbmxldCBtaW5fdGltZSA9IFRpbWVfbnMuZXBvY2hcblxubW9kdWxlIE51bV9rZXlfYml0cyA6IHNpZ1xuICB0eXBlIHQgPSBwcml2YXRlIGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGluY2x1ZGUgQ29tcGFyYWJsZSB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqIHZhbCBtaW5fdmFsdWUgOiB0ICopXG5cbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG93MiA6IHQgLT4gSW50NjMudFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgSW50XG5cbiAgbGV0IG1pbl92YWx1ZSA9IDBcblxuICAoKiogV2Ugc3VwcG9ydCBhbGwgbm9uLW5lZ2F0aXZlIFtUaW1lX25zLnRdIHZhbHVlcy4gKilcbiAgbGV0IG1heF92YWx1ZSA9IEludDYzLm51bV9iaXRzIC0gMVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0ICh0ID49IG1pbl92YWx1ZSk7XG4gICAgYXNzZXJ0ICh0IDw9IG1heF92YWx1ZSlcbiAgOztcblxuICBsZXQgb2ZfaW50IGkgPVxuICAgIGludmFyaWFudCBpO1xuICAgIGlcbiAgOztcblxuICBsZXQgKCArICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgKyB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgKCAtICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgLSB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgcG93MiB0ID0gSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgdFxuZW5kXG5cbm1vZHVsZSBMZXZlbF9iaXRzID0gc3RydWN0XG4gIHR5cGUgdCA9IE51bV9rZXlfYml0cy50IGxpc3QgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgbWF4X251bV9iaXRzID0gKE51bV9rZXlfYml0cy5tYXhfdmFsdWUgOj4gaW50KVxuICBsZXQgbnVtX2JpdHNfaW50ZXJuYWwgdCA9IExpc3QuZm9sZCB0IH5pbml0Ok51bV9rZXlfYml0cy56ZXJvIH5mOk51bV9rZXlfYml0cy4oICsgKVxuICBsZXQgbnVtX2JpdHMgdCA9IChudW1fYml0c19pbnRlcm5hbCB0IDo+IGludClcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIGFzc2VydCAobm90IChMaXN0LmlzX2VtcHR5IHQpKTtcbiAgICBMaXN0Lml0ZXIgdCB+ZjooZnVuIG51bV9rZXlfYml0cyAtPlxuICAgICAgTnVtX2tleV9iaXRzLmludmFyaWFudCBudW1fa2V5X2JpdHM7XG4gICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBudW1fa2V5X2JpdHMgTnVtX2tleV9iaXRzLnplcm8pKTtcbiAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IChudW1fYml0c19pbnRlcm5hbCB0KVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHQgPSBzZXhwIHw+IFslb2Zfc2V4cDogdF0gaW5cbiAgICBpbnZhcmlhbnQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9leG4gPyhleHRlbmRfdG9fbWF4X251bV9iaXRzID0gZmFsc2UpIGludHMgPVxuICAgIGlmIExpc3QuaXNfZW1wdHkgaW50cyB0aGVuIGZhaWx3aXRoIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIHJlcXVpcmVzIGEgbm9uZW1wdHkgbGlzdFwiO1xuICAgIGlmIExpc3QuZXhpc3RzIGludHMgfmY6KGZ1biBiaXRzIC0+IGJpdHMgPD0gMClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3Qgbm9ucG9zaXRpdmUgbnVtIGJpdHNcIiB+XzooaW50cyA6IGludCBsaXN0KV07XG4gICAgbGV0IG51bV9iaXRzID0gTGlzdC5mb2xkIGludHMgfmluaXQ6MCB+ZjooICsgKSBpblxuICAgIGlmIG51bV9iaXRzID4gbWF4X251bV9iaXRzXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3QgdG9vIG1hbnkgYml0c1wiXG4gICAgICAgICAgICB+XzooaW50cyA6IGludCBsaXN0KVxuICAgICAgICAgICAgfmdvdDoobnVtX2JpdHMgOiBpbnQpXG4gICAgICAgICAgICAobWF4X251bV9iaXRzIDogaW50KV07XG4gICAgbGV0IGludHMgPVxuICAgICAgaWYgZXh0ZW5kX3RvX21heF9udW1fYml0c1xuICAgICAgdGhlbiBpbnRzIEAgTGlzdC5pbml0IChtYXhfbnVtX2JpdHMgLSBudW1fYml0cykgfmY6KGNvbnN0IDEpXG4gICAgICBlbHNlIGludHNcbiAgICBpblxuICAgIExpc3QubWFwIGludHMgfmY6TnVtX2tleV9iaXRzLm9mX2ludFxuICA7O1xuXG4gIGxldCBkZWZhdWx0ID0gY3JlYXRlX2V4biBbIDExOyAxMDsgMTA7IDEwOyAxMDsgMTA7IDEgXVxuXG4gIGxldCB0cmltIHQgfm1heF9udW1fYml0cyA9XG4gICAgaWYgTnVtX2tleV9iaXRzLiggPD0gKSAobnVtX2JpdHNfaW50ZXJuYWwgdCkgbWF4X251bV9iaXRzXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgdCB+cmVtYWluaW5nID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gW11cbiAgICAgICAgfCBiIDo6IHQgLT5cbiAgICAgICAgICBpZiBOdW1fa2V5X2JpdHMuKCA+PSApIGIgcmVtYWluaW5nXG4gICAgICAgICAgdGhlbiBbIHJlbWFpbmluZyBdXG4gICAgICAgICAgZWxzZSBiIDo6IGxvb3AgdCB+cmVtYWluaW5nOihOdW1fa2V5X2JpdHMuKCAtICkgcmVtYWluaW5nIGIpXG4gICAgICBpblxuICAgICAgbG9vcCB0IH5yZW1haW5pbmc6bWF4X251bV9iaXRzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gOiBzaWdcbiAgaW5jbHVkZSBBbGFybV9wcmVjaXNpb25cblxuICB2YWwgbnVtX2tleV9iaXRzIDogdCAtPiBOdW1fa2V5X2JpdHMudFxuICB2YWwgaW50ZXJ2YWxfbnVtIDogdCAtPiBUaW1lX25zLnQgLT4gSW50NjMudFxuICB2YWwgaW50ZXJ2YWxfbnVtX3N0YXJ0IDogdCAtPiBJbnQ2My50IC0+IFRpbWVfbnMudFxuZW5kID0gc3RydWN0XG4gICgqKiBbdF0gaXMgcmVwcmVzZW50ZWQgYXMgdGhlIGxvZzIgb2YgYSBudW1iZXIgb2YgbmFub3NlY29uZHMuICopXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBoYXNoXVxuXG4gIGxldCBlcXVhbCA9IFslY29tcGFyZS5lcXVhbDogdF1cbiAgbGV0IG51bV9rZXlfYml0cyB0ID0gdCB8PiBOdW1fa2V5X2JpdHMub2ZfaW50XG5cbiAgbGV0IHRvX3NwYW4gdCA9XG4gICAgaWYgdCA8IDBcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiW0FsYXJtX3ByZWNpc2lvbi50b19zcGFuXSBvZiBuZWdhdGl2ZSBwb3dlciBvZiB0d28gbmFub3NlY29uZHNcIiB+XzoodCA6IGludCldO1xuICAgIEludDYzLihzaGlmdF9sZWZ0IG9uZSkgdCB8PiBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQgfD4gdG9fc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV1cbiAgbGV0IG9uZV9uYW5vc2Vjb25kID0gMFxuICBsZXQgYWJvdXRfb25lX21pY3Jvc2Vjb25kID0gMTBcbiAgbGV0IGFib3V0X29uZV9taWxsaXNlY29uZCA9IDIwXG4gIGxldCBhYm91dF9vbmVfc2Vjb25kID0gMzBcbiAgbGV0IGFib3V0X29uZV9kYXkgPSA0NlxuICBsZXQgbXVsIHQgfnBvdzIgPSB0ICsgcG93MlxuICBsZXQgZGl2IHQgfnBvdzIgPSB0IC0gcG93MlxuICBsZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9IEludDYzLnNoaWZ0X3JpZ2h0ICh0aW1lIHw+IFRpbWVfbnMudG9faW50NjNfbnNfc2luY2VfZXBvY2gpIHRcblxuICBsZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgaW50ZXJ2YWxfbnVtID1cbiAgICBJbnQ2My5zaGlmdF9sZWZ0IGludGVydmFsX251bSB0IHw+IFRpbWVfbnMub2ZfaW50NjNfbnNfc2luY2VfZXBvY2hcbiAgOztcblxuICBsZXQgb2Zfc3Bhbl9mbG9vcl9wb3cyX25zIHNwYW4gPVxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLm9mX3NwYW5fZmxvb3JfcG93Ml9uc10gZ290IG5vbi1wb3NpdGl2ZSBzcGFuXCJcbiAgICAgICAgICAgIChzcGFuIDogVGltZV9ucy5TcGFuLnQpXTtcbiAgICBzcGFuIHw+IFRpbWVfbnMuU3Bhbi50b19pbnQ2M19ucyB8PiBJbnQ2My5mbG9vcl9sb2cyXG4gIDs7XG5cbiAgbGV0IG9mX3NwYW4gPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcblxuICBtb2R1bGUgVW5zdGFibGUgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgY29tcGFyZV1cblxuICAgICAgbGV0IG9mX2JpbmFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19iaW5hYmxlID0gdG9fc3BhblxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19zcGFuXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIEJpbmFibGUuT2ZfYmluYWJsZV93aXRob3V0X3V1aWQgW0BhbGVydCBcIi1sZWdhY3lcIl0gKFRpbWVfbnMuU3BhbikgKFQpXG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZSAoVGltZV9ucy5TcGFuKSAoVClcbiAgZW5kXG5lbmRcblxubW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICBsZXQgbGV2ZWxfYml0c19kZWZhdWx0ID0gTGV2ZWxfYml0cy5kZWZhdWx0XG5cbiAgdHlwZSB0ID1cbiAgICB7IGFsYXJtX3ByZWNpc2lvbiA6IEFsYXJtX3ByZWNpc2lvbi5VbnN0YWJsZS50XG4gICAgOyBsZXZlbF9iaXRzIDogTGV2ZWxfYml0cy50IFtAZGVmYXVsdCBsZXZlbF9iaXRzX2RlZmF1bHRdXG4gICAgOyBjYXBhY2l0eSA6IGludCBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF1cblxuICBsZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBBbGFybV9wcmVjaXNpb24udG9fc3BhbiB0LmFsYXJtX3ByZWNpc2lvblxuXG4gICgqIFttYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbGV2ZWwgYml0cyBuZWVkZWQgZm9yIGFcbiAgICAgdGltaW5nIHdoZWVsIHdpdGggdGhlIHNwZWNpZmllZCBbYWxhcm1fcHJlY2lzaW9uXSB0byBiZSBhYmxlIHRvIHJlcHJlc2VudCBhbGxcbiAgICAgcG9zc2libGUgdGltZXMgZnJvbSBbVGltZV9ucy5lcG9jaF0gb253YXJkLiAgU2luY2Ugbm9uLW5lZ2F0aXZlIHRpbWVzIGhhdmUgNjIgYml0cyxcbiAgICAgd2UgcmVxdWlyZSBbTCA8PSA2MiAtIEFdLCB3aGVyZSBbQV0gaXMgdGhlIG51bWJlciBvZiBhbGFybSBiaXRzIGFuZCBbTF0gaXMgdGhlXG4gICAgIG51bWJlciBvZiBsZXZlbCBiaXRzLiAqKVxuICBsZXQgbWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbiA9XG4gICAgTnVtX2tleV9iaXRzLiggLSApXG4gICAgICBOdW1fa2V5X2JpdHMubWF4X3ZhbHVlXG4gICAgICAoQWxhcm1fcHJlY2lzaW9uLm51bV9rZXlfYml0cyBhbGFybV9wcmVjaXNpb24pXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIE51bV9rZXlfYml0cy4oIDw9IClcbiAgICAgICAgICAoTGV2ZWxfYml0cy5udW1fYml0c19pbnRlcm5hbCB0LmxldmVsX2JpdHMpXG4gICAgICAgICAgKG1heF9udW1fbGV2ZWxfYml0cyB0LmFsYXJtX3ByZWNpc2lvbikpO1xuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+YWxhcm1fcHJlY2lzaW9uOmlnbm9yZVxuICAgICAgICB+Y2FwYWNpdHk6aWdub3JlXG4gICAgICAgIH5sZXZlbF9iaXRzOihjaGVjayBMZXZlbF9iaXRzLmludmFyaWFudCkpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgPyhsZXZlbF9iaXRzID0gbGV2ZWxfYml0c19kZWZhdWx0KSB+YWxhcm1fcHJlY2lzaW9uICgpID1cbiAgICBsZXQgbGV2ZWxfYml0cyA9XG4gICAgICBMZXZlbF9iaXRzLnRyaW0gbGV2ZWxfYml0cyB+bWF4X251bV9iaXRzOihtYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uKVxuICAgIGluXG4gICAgeyBhbGFybV9wcmVjaXNpb247IGxldmVsX2JpdHM7IGNhcGFjaXR5IH1cbiAgOztcblxuICBsZXQgbWljcm9zZWNvbmRfcHJlY2lzaW9uICgpID1cbiAgICBjcmVhdGVcbiAgICAgICgpXG4gICAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi5hYm91dF9vbmVfbWljcm9zZWNvbmRcbiAgICAgIH5sZXZlbF9iaXRzOihMZXZlbF9iaXRzLmNyZWF0ZV9leG4gWyAxMDsgMTA7IDY7IDY7IDUgXSlcbiAgOztcblxuICBsZXQgZHVyYXRpb25zIHQgPVxuICAgIExpc3QuZm9sZGluZ19tYXBcbiAgICAgIHQubGV2ZWxfYml0c1xuICAgICAgfmluaXQ6KEFsYXJtX3ByZWNpc2lvbi5udW1fa2V5X2JpdHMgdC5hbGFybV9wcmVjaXNpb24gfD4gTnVtX2tleV9iaXRzLnRvX2ludClcbiAgICAgIH5mOihmdW4gbnVtX2JpdHNfYWNjdW0gbGV2ZWxfbnVtX2JpdHMgLT5cbiAgICAgICAgbGV0IG51bV9iaXRzX2FjY3VtID0gbnVtX2JpdHNfYWNjdW0gKyAobGV2ZWxfbnVtX2JpdHMgfD4gTnVtX2tleV9iaXRzLnRvX2ludCkgaW5cbiAgICAgICAgbGV0IGR1cmF0aW9uID1cbiAgICAgICAgICBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgICAgICAgICAgIChpZiBudW1fYml0c19hY2N1bSA9IEludDYzLm51bV9iaXRzIC0gMVxuICAgICAgICAgICAgIHRoZW4gSW50NjMubWF4X3ZhbHVlXG4gICAgICAgICAgICAgZWxzZSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSBudW1fYml0c19hY2N1bSlcbiAgICAgICAgaW5cbiAgICAgICAgbnVtX2JpdHNfYWNjdW0sIGR1cmF0aW9uKVxuICA7O1xuZW5kXG5cblxuKCoqIFRpbWluZyB3aGVlbCBpcyBpbXBsZW1lbnRlZCBhcyBhIHByaW9yaXR5IHF1ZXVlIGluIHdoaWNoIHRoZSBrZXlzIGFyZVxuICAgIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnRlcnZhbHMgb2YgdGltZS4gIFRoZSBwcmlvcml0eSBxdWV1ZSBpc1xuICAgIHVubGlrZSBhIHR5cGljYWwgcHJpb3JpdHkgcXVldWUgaW4gdGhhdCByYXRoZXIgdGhhbiBoYXZpbmcgYSBcImRlbGV0ZSBtaW5cIiBvcGVyYXRpb24sXG4gICAgaXQgaGFzIGEgbm9uZGVjcmVhc2luZyBtaW5pbXVtIGFsbG93ZWQga2V5LCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCB0aW1lLFxuICAgIGFuZCBhbiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBvcGVyYXRpb24sIHdoaWNoIGltcGxlbWVudHMgW2FkdmFuY2VfY2xvY2tdLlxuICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGFzIGEgc2lkZSBlZmZlY3QgcmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgdGltaW5nXG4gICAgd2hlZWwgd2hvc2Uga2V5IGlzIHNtYWxsZXIgdGhhbiB0aGUgbmV3IG1pbmltdW0sIHdoaWNoIGltcGxlbWVudHMgZmlyaW5nIHRoZSBhbGFybXNcbiAgICB3aG9zZSB0aW1lIGhhcyBleHBpcmVkLlxuXG4gICAgQWRkaW5nIGVsZW1lbnRzIHRvIGFuZCByZW1vdmluZyBlbGVtZW50cyBmcm9tIGEgdGltaW5nIHdoZWVsIHRha2VzIGNvbnN0YW50IHRpbWUsXG4gICAgdW5saWtlIGEgaGVhcC1iYXNlZCBwcmlvcml0eSBxdWV1ZSB3aGljaCB0YWtlcyBsb2coTiksIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZlxuICAgIGVsZW1lbnRzIGluIHRoZSBoZWFwLiAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlXG4gICAgYW1vdW50IG9mIGluY3JlYXNlIGluIHRoZSBtaW4tYWxsb3dlZCBrZXksIGFzIGNvbXBhcmVkIHRvIGxvZyhOKSBmb3IgYSBoZWFwLiAgSXQgaXNcbiAgICB0aGVzZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlcyB0aGF0IG1vdGl2YXRlIHRoZSBleGlzdGVuY2Ugb2YgdGltaW5nIHdoZWVscyBhbmQgbWFrZVxuICAgIHRoZW0gYSBnb29kIGNob2ljZSBmb3IgbWFpbnRhaW5nIGEgc2V0IG9mIGFsYXJtcy4gIFdpdGggYSB0aW1pbmcgd2hlZWwsIG9uZSBjYW5cbiAgICBzdXBwb3J0IGFueSBudW1iZXIgb2YgYWxhcm1zIHBheWluZyBjb25zdGFudCBvdmVyaGVhZCBwZXIgYWxhcm0sIHdoaWxlIHBheWluZyBhXG4gICAgc21hbGwgY29uc3RhbnQgb3ZlcmhlYWQgcGVyIHVuaXQgb2YgdGltZSBwYXNzZWQuXG5cbiAgICBBcyB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBpbmNyZWFzZXMsIHRoZSB0aW1pbmcgd2hlZWwgZG9lcyBhIGxhenkgcmFkaXggc29ydCBvZiB0aGVcbiAgICBlbGVtZW50IGtleXMsIHdpdGggbGV2ZWwgMCBoYW5kbGluZyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgW2JfMF0gYml0cyBpbiBhIGtleSwgYW5kXG4gICAgZWFjaCBzdWJzZXF1ZW50IGxldmVsIFtpXSBoYW5kbGluZyB0aGUgbmV4dCBtb3N0IHNpZ25pZmljYW50IFtiX2ldIGJpdHMuICBUaGUgbGV2ZWxzXG4gICAgaG9sZCBpbmNyZWFzaW5nbHkgbGFyZ2VyIHJhbmdlcyBvZiBrZXlzLCB3aGVyZSB0aGUgdW5pb24gb2YgYWxsIHRoZSBsZXZlbHMgY2FuIGhvbGRcbiAgICBhbnkga2V5IGZyb20gW21pbl9hbGxvd2VkX2tleSB0XSB0byBbbWF4X2FsbG93ZWRfa2V5IHRdLiAgV2hlbiBhIGtleSBpcyBhZGRlZCB0byB0aGVcbiAgICB0aW1pbmcgd2hlZWwsIGl0IGlzIGFkZGVkIGF0IHRoZSBsb3dlc3QgcG9zc2libGUgbGV2ZWwgdGhhdCBjYW4gc3RvcmUgdGhlIGtleS4gIEFzXG4gICAgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgaW5jcmVhc2VzLCB0aW1pbmctd2hlZWwgZWxlbWVudHMgbW92ZSBkb3duIGxldmVscyB1bnRpbCB0aGV5XG4gICAgcmVhY2ggbGV2ZWwgMCwgYW5kIHRoZW4gYXJlIGV2ZW50dWFsbHkgcmVtb3ZlZC4gICopXG5tb2R1bGUgUHJpb3JpdHlfcXVldWUgOiBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgJ2EgcHJpb3JpdHlfcXVldWUgPSAnYSB0XG5cbiAgbW9kdWxlIEtleSA6IEludGVydmFsX251bVxuXG4gIG1vZHVsZSBFbHQgOiBzaWdcbiAgICAoKiogQW4gW0VsdC50XSByZXByZXNlbnRzIGFuIGVsZW1lbnQgdGhhdCB3YXMgYWRkZWQgdG8gYSB0aW1pbmcgd2hlZWwuICopXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgYXQgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+IFRpbWVfbnMudFxuICAgIHZhbCBrZXkgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIHZhbHVlIDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBudWxsIDogdW5pdCAtPiAnYSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBJbnRlcm5hbF9lbHQgOiBzaWdcbiAgICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBrZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCBtYXhfYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICAgIHZhbCBtaW5fYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICAgIHZhbCBpc19udWxsIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgdG9fZXh0ZXJuYWwgOiAnYSB0IC0+ICdhIEVsdC50XG4gIGVuZFxuXG4gIHZhbCBwb29sIDogJ2EgdCAtPiAnYSBJbnRlcm5hbF9lbHQuUG9vbC50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICgqKiBbY3JlYXRlID9sZXZlbF9iaXRzICgpXSBjcmVhdGVzIGEgbmV3IGVtcHR5IHRpbWluZyB3aGVlbCwgW3RdLCB3aXRoIFtsZW5ndGggdCA9IDBdXG4gICAgICBhbmQgW21pbl9hbGxvd2VkX2tleSB0ID0gMF0uICopXG4gIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+ID9sZXZlbF9iaXRzOkxldmVsX2JpdHMudCAtPiB1bml0IC0+ICdhIHRcblxuICAoKiogW2xlbmd0aCB0XSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRpbWluZyB3aGVlbC4gKilcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcblxuICAoKiogW21pbl9hbGxvd2VkX2tleSB0XSBpcyB0aGUgbWluaW11bSBrZXkgdGhhdCBjYW4gYmUgc3RvcmVkIGluIFt0XS4gIFRoaXMgb25seVxuICAgICAgaW5kaWNhdGVzIHRoZSBwb3NzaWJpbGl0eTsgdGhlcmUgbmVlZCBub3QgYmUgYW4gZWxlbWVudCBbZWx0XSBpbiBbdF0gd2l0aCBbRWx0LmtleVxuICAgICAgZWx0ID0gbWluX2FsbG93ZWRfa2V5IHRdLiAgVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFwibWluX2tleVwiIG9wZXJhdGlvbiBpbiBhXG4gICAgICB0eXBpY2FsIHByaW9yaXR5IHF1ZXVlLlxuXG4gICAgICBbbWluX2FsbG93ZWRfa2V5IHRdIGNhbiBpbmNyZWFzZSBvdmVyIHRpbWUsIHZpYSBjYWxscyB0b1xuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0uICopXG4gIHZhbCBtaW5fYWxsb3dlZF9rZXkgOiBfIHQgLT4gS2V5LnRcblxuICAoKiogW21heF9hbGxvd2VkX2tleSB0XSBpcyB0aGUgbWF4aW11bSBhbGxvd2VkIGtleSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gW3RdLiAgQXNcbiAgICAgIFttaW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcywgc28gZG9lcyBbbWF4X2FsbG93ZWRfa2V5XTsgaG93ZXZlciBpdCBpcyBub3QgdGhlIGNhc2VcbiAgICAgIHRoYXQgW21heF9hbGxvd2VkX2tleSB0IC0gbWluX2FsbG93ZWRfa2V5IHRdIGlzIGEgY29uc3RhbnQuICBJdCBpcyBndWFyYW50ZWVkIHRoYXRcbiAgICAgIFttYXhfYWxsb3dlZF9rZXkgdCA+PSBtaW5fYWxsb3dlZF9rZXkgdCArIDJeQiAtIDFdLFxuICAgICAgd2hlcmUgW0JdIGlzIHRoZSBzdW0gb2YgdGhlIGJfaSBpbiBbbGV2ZWxfYml0c10uICopXG4gIHZhbCBtYXhfYWxsb3dlZF9rZXkgOiBfIHQgLT4gS2V5LnRcblxuICB2YWwgbWluX2VsdF8gOiAnYSB0IC0+ICdhIEludGVybmFsX2VsdC50XG4gIHZhbCBpbnRlcm5hbF9hZGQgOiAnYSB0IC0+IGtleTpLZXkudCAtPiBhdDpUaW1lX25zLnQgLT4gJ2EgLT4gJ2EgSW50ZXJuYWxfZWx0LnRcblxuICAoKiogW3JlbW92ZSB0IGVsdF0gcmVtb3ZlcyBbZWx0XSBmcm9tIFt0XS4gIEl0IGlzIGFuIGVycm9yIGlmIFtlbHRdIGlzIG5vdCBjdXJyZW50bHlcbiAgICAgIGluIFt0XSwgYW5kIHRoaXMgZXJyb3IgbWF5IG9yIG1heSBub3QgYmUgZGV0ZWN0ZWQuICopXG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+ICdhIEVsdC50IC0+IHVuaXRcblxuICB2YWwgY2hhbmdlIDogJ2EgdCAtPiAnYSBFbHQudCAtPiBrZXk6S2V5LnQgLT4gYXQ6VGltZV9ucy50IC0+IHVuaXRcblxuICAoKiogW2NsZWFyIHRdIHJlbW92ZXMgYWxsIGVsdHMgZnJvbSBbdF0uICopXG4gIHZhbCBjbGVhciA6IF8gdCAtPiB1bml0XG5cbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4gYm9vbFxuXG4gIG1vZHVsZSBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0IDogc2lnXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkXG4gIGVuZFxuXG4gICgqKiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5IHQgfmtleSB+aGFuZGxlX3JlbW92ZWRdIGluY3JlYXNlcyB0aGUgbWluaW11bSBhbGxvd2VkXG4gICAgICBrZXkgaW4gW3RdIHRvIFtrZXldLCBhbmQgcmVtb3ZlcyBhbGwgZWxlbWVudHMgd2l0aCBrZXlzIGxlc3MgdGhhbiBba2V5XSwgYXBwbHlpbmdcbiAgICAgIFtoYW5kbGVfcmVtb3ZlZF0gdG8gZWFjaCBlbGVtZW50IHRoYXQgaXMgcmVtb3ZlZC4gIElmIFtrZXkgPD0gbWluX2FsbG93ZWRfa2V5IHRdLFxuICAgICAgdGhlbiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBkb2VzIG5vdGhpbmcuICBPdGhlcndpc2UsIGlmXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSByZXR1cm5zIHN1Y2Nlc3NmdWxseSwgW21pbl9hbGxvd2VkX2tleSB0ID0ga2V5XS5cblxuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gW2tleSAtIG1pbl9hbGxvd2VkX2tleSB0XSxcbiAgICAgIGFsdGhvdWdoIHBvc3NpYmx5IGxlc3MgdGltZS5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW2hhbmRsZV9yZW1vdmVkXSBhY2Nlc3NlcyBbdF0gaW4gYW55IHdheSBvdGhlciB0aGFuXG4gICAgICBbRWx0XSBmdW5jdGlvbnMuICopXG4gIHZhbCBpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlcbiAgICA6ICAnYSB0XG4gICAgLT4ga2V5OktleS50XG4gICAgLT4gaGFuZGxlX3JlbW92ZWQ6KCdhIEVsdC50IC0+IHVuaXQpXG4gICAgLT4gSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC50XG5cbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIEVsdC50IC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgZmlyZV9wYXN0X2FsYXJtc1xuICAgIDogICdhIHRcbiAgICAtPiBoYW5kbGVfZmlyZWQ6KCdhIEVsdC50IC0+IHVuaXQpXG4gICAgLT4ga2V5OktleS50XG4gICAgLT4gbm93OlRpbWVfbnMudFxuICAgIC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICAoKiogRWFjaCBzbG90IGluIGEgbGV2ZWwgaXMgYSAocG9zc2libHkgbnVsbCkgcG9pbnRlciB0byBhIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgb2YgZWxlbWVudHMuICBXZSBwb29sIHRoZSBlbGVtZW50cyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGVtIGFmdGVyIHRoZXkgYXJlIHJlbW92ZWRcbiAgICAgIGZyb20gdGhlIHRpbWluZyB3aGVlbCAoZWl0aGVyIHZpYSBbcmVtb3ZlXSBvciBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSkuICBJblxuICAgICAgYWRkaXRpb24gdG8gc3RvcmluZyB0aGUgW2tleV0sIFthdF0sIGFuZCBbdmFsdWVdIGluIHRoZSBlbGVtZW50LCB3ZSBzdG9yZSB0aGVcbiAgICAgIFtsZXZlbF9pbmRleF0gc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgdG8gdGhlIGxldmVsIGhvbGRpbmcgYW4gZWxlbWVudCB3aGVuIHdlXG4gICAgICBbcmVtb3ZlXSBpdC5cblxuICAgICAgV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiBbRXh0ZXJuYWxfZWx0XSBhbmQgW0ludGVybmFsX2VsdF0sIHdoaWNoIGFyZSB0aGUgc2FtZVxuICAgICAgdW5kZXJuZWF0aC4gIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCBhbiBbSW50ZXJuYWxfZWx0XSBpcyBlaXRoZXIgW251bGxdIG9yIGFcbiAgICAgIHZhbGlkIHBvaW50ZXIuICBPbiB0aGUgb3RoZXIgaGFuZCwgW0V4dGVybmFsX2VsdF1zIGFyZSByZXR1cm5lZCB0byB1c2VyIGNvZGUsIHNvXG4gICAgICB0aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdmFsaWRpdHkgLS0gd2UgYWx3YXlzIHZhbGlkYXRlIGFuIFtFeHRlcm5hbF9lbHRdIGJlZm9yZVxuICAgICAgZG9pbmcgYW55dGhpbmcgd2l0aCBpdC5cblxuICAgICAgSXQgaXMgdGhlcmVmb3JlIE9LIHRvIHVzZSBbUG9vbC5VbnNhZmVdLCBiZWNhdXNlIHdlIHdpbGwgbmV2ZXIgYXR0ZW1wdCB0byBhY2Nlc3MgYVxuICAgICAgc2xvdCBvZiBhbiBpbnZhbGlkIHBvaW50ZXIuICopXG4gIG1vZHVsZSBQb29sID0gUG9vbC5VbnNhZmVcblxuICBtb2R1bGUgUG9pbnRlciA9IFBvb2wuUG9pbnRlclxuXG4gIG1vZHVsZSBLZXkgOiBzaWdcbiAgICAoKiogW0ludGVydmFsX251bV0gaXMgdGhlIHB1YmxpYyBBUEkuICBFdmVyeXRoaW5nIGZvbGxvd2luZyBpbiB0aGUgc2lnbmF0dXJlIGlzXG4gICAgICAgIGZvciBpbnRlcm5hbCB1c2UuICopXG4gICAgaW5jbHVkZSBUaW1pbmdfd2hlZWxfaW50Zi5JbnRlcnZhbF9udW1cblxuICAgICgqKiBbYWRkX2NsYW1wX3RvX21heF0gZG9lc24ndCB3b3JrIGF0IGFsbCB3aXRoIG5lZ2F0aXZlIHNwYW5zICopXG4gICAgdmFsIGFkZF9jbGFtcF90b19tYXggOiB0IC0+IFNwYW4udCAtPiB0XG5cbiAgICB2YWwgc3VjY19jbGFtcF90b19tYXggOiB0IC0+IHRcblxuICAgICgqKiBbU2xvdHNfbWFza10gaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSBhIGtleSdzIHNsb3QgaW4gYSBnaXZlbiBsZXZlbC4gKilcbiAgICBtb2R1bGUgU2xvdHNfbWFzayA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBjcmVhdGUgOiBsZXZlbF9iaXRzOk51bV9rZXlfYml0cy50IC0+IHRcbiAgICAgIHZhbCBuZXh0X3Nsb3QgOiB0IC0+IGludCAtPiBpbnRcbiAgICBlbmRcblxuICAgICgqKiBbTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza10gaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSB0aGUgbWluaW11bSBrZXkgaW4gdGhlXG4gICAgICAgIHNhbWUgc2xvdCBhcyBhIGdpdmVuIGtleS4gKilcbiAgICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIGluY2x1ZGUgRXF1YWwuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiBiaXRzX3Blcl9zbG90Ok51bV9rZXlfYml0cy50IC0+IHRcbiAgICBlbmRcblxuICAgIHZhbCBudW1fa2V5cyA6IE51bV9rZXlfYml0cy50IC0+IFNwYW4udFxuICAgIHZhbCBtaW5fa2V5X2luX3NhbWVfc2xvdCA6IHQgLT4gTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay50IC0+IHRcbiAgICB2YWwgc2xvdCA6IHQgLT4gYml0c19wZXJfc2xvdDpOdW1fa2V5X2JpdHMudCAtPiBzbG90c19tYXNrOlNsb3RzX21hc2sudCAtPiBpbnRcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIFNsb3RzX21hc2sgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgbGV0IGNyZWF0ZSB+bGV2ZWxfYml0cyA9IEludDYzLiggLSApIChOdW1fa2V5X2JpdHMucG93MiBsZXZlbF9iaXRzKSBJbnQ2My5vbmVcbiAgICAgIGxldCBuZXh0X3Nsb3QgdCBzbG90ID0gKHNsb3QgKyAxKSBsYW5kIEludDYzLnRvX2ludF9leG4gdFxuICAgIGVuZFxuXG4gICAgbGV0IG51bV9rZXlzIG51bV9iaXRzID0gTnVtX2tleV9iaXRzLnBvdzIgbnVtX2JpdHNcblxuICAgIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID0gc3RydWN0XG4gICAgICBpbmNsdWRlIEludDYzXG5cbiAgICAgIGxldCBjcmVhdGUgfmJpdHNfcGVyX3Nsb3QgPSBiaXRfbm90IChOdW1fa2V5X2JpdHMucG93MiBiaXRzX3Blcl9zbG90IC0gb25lKVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFNwYW4gPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgSW50NjNcblxuICAgICAgbGV0IHRvX2ludDYzIHQgPSB0XG4gICAgICBsZXQgb2ZfaW50NjMgaSA9IGlcbiAgICAgIGxldCBzY2FsZV9pbnQgdCBpID0gdCAqIG9mX2ludCBpXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIEludDYzXG5cbiAgICBsZXQgb2ZfaW50NjMgaSA9IGlcbiAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICBsZXQgYWRkIHQgaSA9IHQgKyBpXG4gICAgbGV0IGFkZF9jbGFtcF90b19tYXggdCBpID0gaWYgdCA+IG1heF92YWx1ZSAtIGkgdGhlbiBtYXhfdmFsdWUgZWxzZSB0ICsgaVxuICAgIGxldCBzdWNjX2NsYW1wX3RvX21heCB0ID0gaWYgdCA9IG1heF92YWx1ZSB0aGVuIG1heF92YWx1ZSBlbHNlIHN1Y2MgdFxuICAgIGxldCBzdWIgdCBpID0gdCAtIGlcbiAgICBsZXQgZGlmZiB0MSB0MiA9IHQxIC0gdDJcblxuICAgIGxldCBzbG90IHQgfihiaXRzX3Blcl9zbG90IDogTnVtX2tleV9iaXRzLnQpIH5zbG90c19tYXNrID1cbiAgICAgIHRvX2ludF9leG4gKGJpdF9hbmQgKHNoaWZ0X3JpZ2h0IHQgKGJpdHNfcGVyX3Nsb3QgOj4gaW50KSkgc2xvdHNfbWFzaylcbiAgICA7O1xuXG4gICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9XG4gICAgICBiaXRfYW5kIHQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID0gS2V5Lk1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgbW9kdWxlIFNsb3RzX21hc2sgPSBLZXkuU2xvdHNfbWFza1xuXG4gIG1vZHVsZSBFeHRlcm5hbF9lbHQgPSBzdHJ1Y3RcblxuICAgICgqKiBUaGUgW3Bvb2xfc2xvdHNdIGhlcmUgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGUgc2xvdHMgaW4gYSBsZXZlbCBhcnJheS4gIFRoaXMgaXNcbiAgICAgICAgZm9yIHRoZSBzbG90cyBpbiB0aGUgcG9vbCB0dXBsZSByZXByZXNlbnRpbmcgYSBsZXZlbCBlbGVtZW50LiAqKVxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9XG4gICAgICAoIEtleS50XG4gICAgICAsIFRpbWVfbnMudFxuICAgICAgLCAnYVxuICAgICAgLCBpbnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnQgKVxuICAgICAgICBQb29sLlNsb3RzLnQ2XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9pbnRlci50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxfZWx0IDogc2lnXG4gICAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+IHVuaXQgLT4gXyB0XG4gICAgICB2YWwgaXNfZnVsbCA6IF8gdCAtPiBib29sXG4gICAgICB2YWwgZ3JvdyA6ID9jYXBhY2l0eTppbnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPSBwcml2YXRlICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gXyB0XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCBpc192YWxpZCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGJvb2xcblxuICAgICgqKiBEZWFsaW5nIHdpdGggW0V4dGVybmFsX2VsdF1zLiAqKVxuXG4gICAgdmFsIGV4dGVybmFsX2lzX3ZhbGlkIDogJ2EgUG9vbC50IC0+ICdhIEV4dGVybmFsX2VsdC50IC0+IGJvb2xcbiAgICB2YWwgdG9fZXh0ZXJuYWwgOiAnYSB0IC0+ICdhIEV4dGVybmFsX2VsdC50XG4gICAgdmFsIG9mX2V4dGVybmFsX2V4biA6ICdhIFBvb2wudCAtPiAnYSBFeHRlcm5hbF9lbHQudCAtPiAnYSB0XG4gICAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaW52YXJpYW50IDogJ2EgUG9vbC50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbY3JlYXRlXSByZXR1cm5zIGFuIGVsZW1lbnQgd2hvc2UgW25leHRdIGFuZCBbcHJldl0gYXJlIFtudWxsXS4gKilcbiAgICB2YWwgY3JlYXRlXG4gICAgICA6ICAnYSBQb29sLnRcbiAgICAgIC0+IGtleTpLZXkudFxuICAgICAgKCoqIFthdF0gaXMgdXNlZCB3aGVuIHRoZSBwcmlvcml0eSBxdWV1ZSBpcyB1c2VkIHRvIGltcGxlbWVudCBhIHRpbWluZyB3aGVlbC4gIElmXG4gICAgICAgICAgdW51c2VkLCBpdCB3aWxsIGJlIFtUaW1lX25zLmVwb2NoXS4gKilcbiAgICAgIC0+IGF0OlRpbWVfbnMudFxuICAgICAgLT4gdmFsdWU6J2FcbiAgICAgIC0+IGxldmVsX2luZGV4OmludFxuICAgICAgLT4gJ2EgdFxuXG4gICAgdmFsIGZyZWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogYWNjZXNzb3JzICopXG5cbiAgICB2YWwga2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnRcbiAgICB2YWwgbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgbmV4dCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdmFsdWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiAnYVxuXG4gICAgKCoqIG11dGF0b3JzICopXG5cbiAgICB2YWwgc2V0X2tleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2F0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gVGltZV9ucy50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2xldmVsX2luZGV4IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50IC0+IHVuaXRcblxuICAgICgqKiBbaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZF0gdHJlYXRzIFt0XSBhcyB0aGUgaGVhZCBvZiB0aGUgbGlzdCBhbmQgYWRkcyBbdG9fYWRkXVxuICAgICAgICB0byB0aGUgZW5kIG9mIGl0LiAqKVxuICAgIHZhbCBpbnNlcnRfYXRfZW5kIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdG9fYWRkOidhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFtsaW5rX3RvX3NlbGYgcG9vbCB0XSBtYWtlcyBbdF0gYmUgYSBzaW5nbGV0b24gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0LiAqKVxuICAgIHZhbCBsaW5rX3RvX3NlbGYgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogW3VubGluayBwIHRdIHVubGlua3MgW3RdIGZyb20gdGhlIGNpcmN1bGFybHkgZG91Ymx5LWxpbmtlZCBsaXN0IHRoYXQgaXQgaXMgaW4uICBJdFxuICAgICAgICBjaGFuZ2VzIHRoZSBwb2ludGVycyBvZiBbdF0ncyBbcHJldl0gYW5kIFtuZXh0XSBlbHRzLCBidXQgbm90IFt0XSdzIFtwcmV2XSBhbmRcbiAgICAgICAgW25leHRdIHBvaW50ZXJzLiAgW3VubGlua10gaXMgbWVhbmluZ2xlc3MgaWYgW3RdIGlzIGEgc2luZ2xldG9uLiAqKVxuICAgIHZhbCB1bmxpbmsgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogSXRlcmF0b3JzLiAgW2l0ZXIgcCB0IH5pbml0IH5mXSB2aXNpdHMgZWFjaCBlbGVtZW50IGluIHRoZSBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgICAgY29udGFpbmluZyBbdF0sIHN0YXJ0aW5nIGF0IFt0XSwgYW5kIGZvbGxvd2luZyBbbmV4dF0gcG9pbnRlcnMuICBbbGVuZ3RoXSBjb3VudHNcbiAgICAgICAgYnkgdmlzaXRpbmcgZWFjaCBlbGVtZW50IGluIHRoZSBsaXN0LiAqKVxuICAgIHZhbCBpdGVyIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gZjooJ2EgdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgICB2YWwgbGVuZ3RoIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50XG5cbiAgICAoKiogW21heF9hbGFybV90aW1lIHQgZWx0IH53aXRoX2tleV0gZmluZHMgdGhlIG1heCBbYXRdIGluIFtlbHRdJ3MgbGlzdCBhbW9uZyB0aGUgZWx0c1xuICAgICAgICB3aG9zZSBrZXkgaXMgW3dpdGhfa2V5XSwgcmV0dXJuaW5nIFtUaW1lX25zLmVwb2NoXSBpZiB0aGUgbGlzdCBpcyBlbXB0eS4gKilcbiAgICB2YWwgbWF4X2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcblxuICAgIHZhbCBtaW5fYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHBvb2xfc2xvdHMgPSAnYSBFeHRlcm5hbF9lbHQucG9vbF9zbG90cyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgJ2EgdCA9ICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICAgIGxldCBpc19udWxsID0gUG9pbnRlci5pc19udWxsXG4gICAgbGV0IGVxdWFsIHQxIHQyID0gUG9pbnRlci5waHlzX2VxdWFsIHQxIHQyXG5cbiAgICBsZXQgY3JlYXRlIHBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleCA9XG4gICAgICBQb29sLm5ldzYgcG9vbCBrZXkgYXQgdmFsdWUgbGV2ZWxfaW5kZXggKG51bGwgKCkpIChudWxsICgpKVxuICAgIDs7XG5cbiAgICBsZXQgZnJlZSA9IFBvb2wuZnJlZVxuICAgIGxldCBrZXkgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MFxuICAgIGxldCBzZXRfa2V5IHAgdCBrID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MCBrXG4gICAgbGV0IGF0IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDFcbiAgICBsZXQgc2V0X2F0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MSB4XG4gICAgbGV0IHZhbHVlIHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDJcbiAgICBsZXQgbGV2ZWxfaW5kZXggcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50M1xuICAgIGxldCBzZXRfbGV2ZWxfaW5kZXggcCB0IGkgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQzIGlcbiAgICBsZXQgcHJldiBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ0XG4gICAgbGV0IHNldF9wcmV2IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NCB4XG4gICAgbGV0IG5leHQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50NVxuICAgIGxldCBzZXRfbmV4dCBwIHQgeCA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDUgeFxuICAgIGxldCBpc192YWxpZCBwIHQgPSBQb29sLnBvaW50ZXJfaXNfdmFsaWQgcCB0XG4gICAgbGV0IGV4dGVybmFsX2lzX3ZhbGlkID0gaXNfdmFsaWRcblxuICAgIGxldCBpbnZhcmlhbnQgcG9vbCBpbnZhcmlhbnRfYSB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICAgIGFzc2VydCAoaXNfdmFsaWQgcG9vbCB0KTtcbiAgICAgICAgaW52YXJpYW50X2EgKHZhbHVlIHBvb2wgdCk7XG4gICAgICAgIGxldCBuID0gbmV4dCBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIG4gfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKHByZXYgcG9vbCBuKSk7XG4gICAgICAgIGxldCBwID0gcHJldiBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIHAgfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKG5leHQgcG9vbCBwKSkpXG4gICAgOztcblxuICAgIG1vZHVsZSBQb29sID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBwb29sX3Nsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBsZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID0gUG9vbC5pbnZhcmlhbnQgaWdub3JlIHRcbiAgICAgIGxldCBjcmVhdGUgPyhjYXBhY2l0eSA9IDEpICgpID0gUG9vbC5jcmVhdGUgUG9vbC5TbG90cy50NiB+Y2FwYWNpdHlcbiAgICAgIGxldCBncm93ID0gUG9vbC5ncm93XG4gICAgICBsZXQgaXNfZnVsbCA9IFBvb2wuaXNfZnVsbFxuICAgIGVuZFxuXG4gICAgbGV0IHRvX2V4dGVybmFsIHQgPSB0XG5cbiAgICBsZXQgb2ZfZXh0ZXJuYWxfZXhuIHBvb2wgdCA9XG4gICAgICBpZiBpc192YWxpZCBwb29sIHQgdGhlbiB0IGVsc2UgcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaW1pbmdfd2hlZWwgZ290IGludmFsaWQgYWxhcm1cIl1cbiAgICA7O1xuXG4gICAgbGV0IHVubGluayBwb29sIHQgPVxuICAgICAgc2V0X25leHQgcG9vbCAocHJldiBwb29sIHQpIChuZXh0IHBvb2wgdCk7XG4gICAgICBzZXRfcHJldiBwb29sIChuZXh0IHBvb2wgdCkgKHByZXYgcG9vbCB0KVxuICAgIDs7XG5cbiAgICBsZXQgbGluayBwb29sIHByZXYgbmV4dCA9XG4gICAgICBzZXRfbmV4dCBwb29sIHByZXYgbmV4dDtcbiAgICAgIHNldF9wcmV2IHBvb2wgbmV4dCBwcmV2XG4gICAgOztcblxuICAgIGxldCBsaW5rX3RvX3NlbGYgcG9vbCB0ID0gbGluayBwb29sIHQgdFxuXG4gICAgbGV0IGluc2VydF9hdF9lbmQgcG9vbCB0IH50b19hZGQgPVxuICAgICAgbGV0IHByZXYgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgbGluayBwb29sIHByZXYgdG9fYWRkO1xuICAgICAgbGluayBwb29sIHRvX2FkZCB0XG4gICAgOztcblxuICAgIGxldCBpdGVyIHBvb2wgZmlyc3QgfmYgPVxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgKCogV2UgZ2V0IFtuZXh0XSBiZWZvcmUgY2FsbGluZyBbZl0gc28gdGhhdCBbZl0gY2FuIG1vZGlmeSBvciBbZnJlZV0gWyFjdXJyZW50XS4gKilcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgZiAhY3VycmVudDtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IGxlbmd0aCBwb29sIGZpcnN0ID1cbiAgICAgIGxldCByID0gcmVmIDAgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGluY3IgcjtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhclxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1heF9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMuZXBvY2ggaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgIGlmIEtleS5lcXVhbCAoa2V5IHBvb2wgIWN1cnJlbnQpIHdpdGhfa2V5XG4gICAgICAgIHRoZW4gbWF4X2FsYXJtX3RpbWUgOj0gVGltZV9ucy5tYXggKGF0IHBvb2wgIWN1cnJlbnQpICFtYXhfYWxhcm1fdGltZTtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhbWF4X2FsYXJtX3RpbWVcbiAgICA7O1xuXG4gICAgbGV0IG1pbl9hbGFybV90aW1lIHBvb2wgZmlyc3QgfndpdGhfa2V5ID1cbiAgICAgIGxldCBtaW5fYWxhcm1fdGltZSA9IHJlZiBUaW1lX25zLm1heF92YWx1ZV9yZXByZXNlbnRhYmxlIGluXG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAoKiBUaGUgW2tleV0gY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgZm9yIFttYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxdIGJlY2F1c2VcbiAgICAgICAgICAgbWF4IHRpbWUgcGVyIGludGVydmFsIGlzIG5vdCB0aGUgc2FtZSBhcyBtYXggdGltZSBnbG9iYWxseS5cblxuICAgICAgICAgICBUaGlzIGlzIG5vdCBzbyBmb3IgW21pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0sIHNvIHRoaXMgY2FuIHBvdGVudGlhbGx5XG4gICAgICAgICAgIGJlIHNpbXBsaWZpZWQuXG5cbiAgICAgICAgICAgUHJvYmFibHkgYSBiZXR0ZXIgY2hhbmdlIHdvdWxkIGJlIHRvIHNpbXBseSB0cmFuc2ZlciB0aGUgZXZlbnRzIHRvIHRoZVxuICAgICAgICAgICBcImZpcmVkXCIgY29sbGVjdGlvbiAoYW5kIHJlbmFtZSBpdCB0byBcImFib3V0IHRvIGZpcmVcIiksIHdoaWNoIGlzIHNvcnRlZCBieSB0aW1lLFxuICAgICAgICAgICBzbyBnZXR0aW5nIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhhdCBjb2xsZWN0aW9uIGlzIGVmZmljaWVudC5cbiAgICAgICAgKilcbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtaW5fYWxhcm1fdGltZSA6PSBUaW1lX25zLm1pbiAoYXQgcG9vbCAhY3VycmVudCkgIW1pbl9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtaW5fYWxhcm1fdGltZVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBMZXZlbCA9IHN0cnVjdFxuICAgICgqKiBGb3IgZ2l2ZW4gbGV2ZWwsIG9uZSBjYW4gYnJlYWsgdGhlIGJpdHMgaW50byBhIGtleSBpbnRvIHRocmVlIHJlZ2lvbnM6XG5cbiAgICAgICAge3ZcbiAgICAgICAgIHwgaGlnaGVyIGxldmVscyB8IHRoaXMgbGV2ZWwgfCBsb3dlciBsZXZlbHMgfFxuICAgICAgICB2fVxuXG4gICAgICAgIFwiTG93ZXIgbGV2ZWxzXCIgaXMgW2JpdHNfcGVyX3Nsb3RdIGJpdHMgd2lkZS4gIFwiVGhpcyBsZXZlbFwiIGlzIFtiaXRzXSB3aWRlLiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7ICgqIFRoZSBbaW5kZXhdIGluIHRoZSB0aW1pbmcgd2hlZWwncyBhcnJheSBvZiBsZXZlbHMgd2hlcmUgdGhpcyBsZXZlbCBpcy4gKilcbiAgICAgICAgaW5kZXggOiBpbnRcbiAgICAgIDsgKCogSG93IG1hbnkgW2JpdHNdIHRoaXMgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yLiAqKVxuICAgICAgICBiaXRzIDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsgKCogW3Nsb3RzX21hc2sgPSBTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czp0LmJpdHNdLiAqKVxuICAgICAgICBzbG90c19tYXNrIDogU2xvdHNfbWFzay50XG4gICAgICA7ICgqIFtiaXRzX3Blcl9zbG90XSBpcyBob3cgbWFueSBiaXRzIGVhY2ggc2xvdCBkaXN0aW5ndWlzaGVzLCBhbmQgaXMgdGhlIHN1bSBvZiBvZlxuICAgICAgICAgICB0aGUgW2JpdHNdIG9mIGFsbCB0aGUgbG93ZXIgbGV2ZWxzLiAqKVxuICAgICAgICBiaXRzX3Blcl9zbG90IDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsga2V5c19wZXJfc2xvdCA6IEtleS5TcGFuLnRcbiAgICAgIDsgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA6IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sudFxuICAgICAgOyAoKiBbZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5ID0ga2V5c19wZXJfc2xvdCAqIEFycmF5Lmxlbmd0aCBzbG90cyAtIDFdICopXG4gICAgICAgIGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA6IEtleS5TcGFuLnRcbiAgICAgIDsgKCogW2xlbmd0aF0gaXMgdGhlIG51bWJlciBvZiBlbHRzIGN1cnJlbnRseSBpbiB0aGlzIGxldmVsLiAqKVxuICAgICAgICBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgICAgOyAoKiBBbGwgZWxlbWVudHMgYXQgdGhpcyBsZXZlbCBoYXZlIHRoZWlyIFtrZXldIHNhdGlzZnkgW21pbl9hbGxvd2VkX2tleSA8PSBrZXkgPD1cbiAgICAgICAgICAgbWF4X2FsbG93ZWRfa2V5XS4gIEFsc28sIFttaW5fYWxsb3dlZF9rZXldIGlzIGEgbXVsdGlwbGUgb2YgW2tleXNfcGVyX3Nsb3RdLiAqKVxuICAgICAgICBtdXRhYmxlIG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG11dGFibGUgbWF4X2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgKCogW3Nsb3RzXSBob2xkcyB0aGUgKHBvc3NpYmx5IG51bGwpIHBvaW50ZXJzIHRvIHRoZSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RzXG4gICAgICAgICAgIG9mIGVsdHMuICBbQXJyYXkubGVuZ3RoIHNsb3RzID0gMSBsc2wgYml0c10uICopXG4gICAgICAgIHNsb3RzIDogKCdhIEludGVybmFsX2VsdC50IGFycmF5W0BzZXhwLm9wYXF1ZV0pXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IHNsb3QgdCB+a2V5ID0gS2V5LnNsb3Qga2V5IH5iaXRzX3Blcl9zbG90OnQuYml0c19wZXJfc2xvdCB+c2xvdHNfbWFzazp0LnNsb3RzX21hc2tcbiAgICBsZXQgbmV4dF9zbG90IHQgc2xvdCA9IFNsb3RzX21hc2submV4dF9zbG90IHQuc2xvdHNfbWFzayBzbG90XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5ID1cbiAgICAgIEtleS5taW5fa2V5X2luX3NhbWVfc2xvdCBrZXkgdC5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcblxuICAgIGxldCBjb21wdXRlX21pbl9hbGxvd2VkX2tleSB0IH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA9XG4gICAgICAoKiBUaGlzIGNvbXB1dGF0aW9uIGVuc3VyZXMgdGhhdCBbdF0ncyBbbWluX2FsbG93ZWRfa2V5XSBpcyBhcyBsYXJnZSBhcyBwb3NzaWJsZVxuICAgICAgICAgc3ViamVjdCB0byB0aGUgY29uc3RyYWludCB0aGF0IHRoZXJlIGlzIG5vIGludGVyLWxldmVsIGdhcC4gKilcbiAgICAgIGlmIEtleS5lcXVhbCBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSBLZXkubWF4X3ZhbHVlXG4gICAgICB0aGVuIEtleS5tYXhfdmFsdWVcbiAgICAgIGVsc2UgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5OihLZXkuc3VjYyBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSlcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICA7IG11dGFibGUgcG9vbCA6ICdhIEludGVybmFsX2VsdC5Qb29sLnRcbiAgICA7ICgqIFttaW5fZWx0XSBpcyBlaXRoZXIgbnVsbCBvciBhbiBlbGVtZW50IHdob3NlIGtleSBpcyBbZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIG1pbl9lbHQgOiAnYSBJbnRlcm5hbF9lbHQudFxuICAgIDsgKCogQWxsIGVsZW1lbnRzIGluIHRoZSBwcmlvcml0eSBxdWV1ZSBoYXZlIHRoZWlyIGtleSBbPj0gZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIGVsdF9rZXlfbG93ZXJfYm91bmQgOiBLZXkudFxuICAgIDsgbGV2ZWxzIDogJ2EgTGV2ZWwudCBhcnJheVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIHR5cGUgJ2EgcHJpb3JpdHlfcXVldWUgPSAnYSB0XG5cbiAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IEV4dGVybmFsX2VsdC5udWxsXG4gICAgbGV0IGF0IHAgdCA9IEludGVybmFsX2VsdC5hdCBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gICAgbGV0IGtleSBwIHQgPSBJbnRlcm5hbF9lbHQua2V5IHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgICBsZXQgdmFsdWUgcCB0ID0gSW50ZXJuYWxfZWx0LnZhbHVlIHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgZW5kXG5cbiAgbGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxuICBsZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuICBsZXQgbnVtX2xldmVscyB0ID0gQXJyYXkubGVuZ3RoIHQubGV2ZWxzXG4gIGxldCBtaW5fYWxsb3dlZF9rZXkgdCA9IExldmVsLm1pbl9hbGxvd2VkX2tleSB0LmxldmVscy4oMClcbiAgbGV0IG1heF9hbGxvd2VkX2tleSB0ID0gTGV2ZWwubWF4X2FsbG93ZWRfa2V5IHQubGV2ZWxzLihudW1fbGV2ZWxzIHQgLSAxKVxuXG4gIGxldCBpbnRlcm5hbF9pdGVyIHQgfmYgPVxuICAgIGlmIHQubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgZm9yIGxldmVsX2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggbGV2ZWxzIC0gMSBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgZm9yIHNsb3RfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBzbG90cyAtIDEgZG9cbiAgICAgICAgICAgIGxldCBlbHQgPSBzbG90cy4oc2xvdF9pbmRleCkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KSB0aGVuIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mXG4gICAgICAgICAgZG9uZSlcbiAgICAgIGRvbmUpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9IGludGVybmFsX2l0ZXIgdCB+ZjooZiA6IF8gRWx0LnQgLT4gdW5pdCA6PiBfIEludGVybmFsX2VsdC50IC0+IHVuaXQpXG5cbiAgbW9kdWxlIFByZXR0eSA9IHN0cnVjdFxuICAgIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIHsga2V5IDogS2V5LnRcbiAgICAgICAgOyB2YWx1ZSA6ICdhXG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtaW5fYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyBtYXhfYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyBlbHRzIDogJ2EgRWx0LnQgbGlzdFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBwcmV0dHkgdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICB7IFByZXR0eS5taW5fYWxsb3dlZF9rZXkgPSBtaW5fYWxsb3dlZF9rZXkgdFxuICAgIDsgbWF4X2FsbG93ZWRfa2V5ID0gbWF4X2FsbG93ZWRfa2V5IHRcbiAgICA7IGVsdHMgPVxuICAgICAgICAobGV0IHIgPSByZWYgW10gaW5cbiAgICAgICAgIGludGVybmFsX2l0ZXIgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICByXG4gICAgICAgICAgIDo9IHsgUHJldHR5LkVsdC5rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0XG4gICAgICAgICAgICAgIDsgdmFsdWUgPSBJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6OiAhcik7XG4gICAgICAgICBMaXN0LnJldiAhcilcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgbWF0Y2ggIXNleHBfb2ZfdF9zdHlsZSB3aXRoXG4gICAgfCBgSW50ZXJuYWwgLT4gWyVzZXhwICh0IDogYSB0X2ludGVybmFsKV1cbiAgICB8IGBQcmV0dHkgLT4gWyVzZXhwIChwcmV0dHkgdCA6IGEgUHJldHR5LnQpXVxuICA7O1xuXG4gIGxldCBjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSB+bGV2ZWxfYml0cyB+Yml0c19wZXJfc2xvdCA9XG4gICAgbGV0IGJpdHMgPSBOdW1fa2V5X2JpdHMuKCArICkgbGV2ZWxfYml0cyBiaXRzX3Blcl9zbG90IGluXG4gICAgaWYgTnVtX2tleV9iaXRzLmVxdWFsIGJpdHMgTnVtX2tleV9iaXRzLm1heF92YWx1ZVxuICAgIHRoZW4gS2V5LlNwYW4ubWF4X3ZhbHVlXG4gICAgZWxzZSBLZXkuU3Bhbi5wcmVkIChLZXkubnVtX2tleXMgYml0cylcbiAgOztcblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgOiB1bml0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBsZXZlbF9pbnZhcmlhbnQgbGV2ZWwgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIGxldmVsIFslc2V4cF9vZjogXyBMZXZlbC50XSAoZnVuICgpIC0+XG4gICAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIGxldmVsIGYgaW5cbiAgICAgICAgTGV2ZWwuRmllbGRzLml0ZXJcbiAgICAgICAgICB+aW5kZXg6KGNoZWNrIChmdW4gaW5kZXggLT4gYXNzZXJ0IChpbmRleCA+PSAwKSkpXG4gICAgICAgICAgfmJpdHM6KGNoZWNrIChmdW4gYml0cyAtPiBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBiaXRzIE51bV9rZXlfYml0cy56ZXJvKSkpXG4gICAgICAgICAgfnNsb3RzX21hc2s6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBTbG90c19tYXNrLnRdXG4gICAgICAgICAgICAgICAgICB+ZXhwZWN0OihTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czpsZXZlbC5iaXRzKSkpXG4gICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBiaXRzX3Blcl9zbG90IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID49ICkgYml0c19wZXJfc2xvdCBOdW1fa2V5X2JpdHMuemVybykpKVxuICAgICAgICAgIH5rZXlzX3Blcl9zbG90OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4ga2V5c19wZXJfc2xvdCAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAga2V5c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OihLZXkubnVtX2tleXMgbGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5lcXVhbFxuICAgICAgICAgICAgICAgICAgIG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICAgICAoTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICB+Yml0c19wZXJfc2xvdDpsZXZlbC5iaXRzX3Blcl9zbG90KSkpKVxuICAgICAgICAgIH5kaWZmX21heF9taW5fYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAgKGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgIH5sZXZlbF9iaXRzOmxldmVsLmJpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6bGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5sZW5ndGg6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICAgICAgICAgICA9IEFycmF5LmZvbGQgbGV2ZWwuc2xvdHMgfmluaXQ6MCB+ZjooZnVuIG4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gICAgICAgICAgICAgICAgICAgdGhlbiBuXG4gICAgICAgICAgICAgICAgICAgZWxzZSBuICsgSW50ZXJuYWxfZWx0Lmxlbmd0aCBwb29sIGVsdCkpKSlcbiAgICAgICAgICB+bWluX2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2FsbG93ZWRfa2V5IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgbWluX2FsbG93ZWRfa2V5IEtleS56ZXJvKTtcbiAgICAgICAgICAgICAgIGlmIEtleS4oIDwgKSBtaW5fYWxsb3dlZF9rZXkgS2V5Lm1heF92YWx1ZVxuICAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChLZXkucmVtIG1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90KVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6S2V5LlNwYW4uemVybykpXG4gICAgICAgICAgfm1heF9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1heF9hbGxvd2VkX2tleSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LnRdXG4gICAgICAgICAgICAgICAgIG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgIChLZXkuYWRkX2NsYW1wX3RvX21heFxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSkpKVxuICAgICAgICAgIH5zbG90czpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHNsb3RzIC0+XG4gICAgICAgICAgICAgICBBcnJheS5pdGVyIHNsb3RzIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaW52YXJpYW50IHBvb2wgaW52YXJpYW50X2EgZWx0O1xuICAgICAgICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICAgICAgICBLZXkuKCA+PSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgICAgICAgIEtleS4oIDw9IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5tYXhfYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgICAgICAgS2V5LiggPj0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEludGVybmFsX2VsdC5sZXZlbF9pbmRleCBwb29sIGVsdCA9IGxldmVsLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudF9hIChJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHQpKSkpKSkpXG4gICAgaW5cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF9pbnRlcm5hbF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1pbl9hbGxvd2VkX2tleSB0KSBLZXkuemVybyk7XG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1heF9hbGxvd2VkX2tleSB0KSAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5sZW5ndGg6KGNoZWNrIChmdW4gbGVuZ3RoIC0+IGFzc2VydCAobGVuZ3RoID49IDApKSlcbiAgICAgICAgfnBvb2w6KGNoZWNrIChJbnRlcm5hbF9lbHQuUG9vbC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgICAgfm1pbl9lbHQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZWx0XyAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XylcbiAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgIGFzc2VydCAoSW50ZXJuYWxfZWx0LmlzX3ZhbGlkIHQucG9vbCBlbHRfKTtcbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LmVxdWFsIHQuZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgZWx0XykpKSkpXG4gICAgICAgIH5lbHRfa2V5X2xvd2VyX2JvdW5kOlxuICAgICAgICAgIChjaGVjayAoZnVuIGVsdF9rZXlfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oIDw9ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWF4X2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBLZXkuZXF1YWwgZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgdC5taW5fZWx0KSkpKVxuICAgICAgICB+bGV2ZWxzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGxldmVscyAtPlxuICAgICAgICAgICAgIGFzc2VydCAobnVtX2xldmVscyB0ID4gMCk7XG4gICAgICAgICAgICAgQXJyYXkuaXRlcmkgbGV2ZWxzIH5mOihmdW4gbGV2ZWxfaW5kZXggbGV2ZWwgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAobGV2ZWxfaW5kZXggPSBMZXZlbC5pbmRleCBsZXZlbCk7XG4gICAgICAgICAgICAgICBsZXZlbF9pbnZhcmlhbnQgbGV2ZWw7XG4gICAgICAgICAgICAgICBpZiBsZXZlbF9pbmRleCA+IDBcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBsZXQgcHJldl9sZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXggLSAxKSBpblxuICAgICAgICAgICAgICAgICBsZXQgbW9kdWxlIEwgPSBMZXZlbCBpblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChMLmtleXNfcGVyX3Nsb3QgbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDooS2V5LlNwYW4uc3VjYyBwcmV2X2xldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS50XVxuICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgICAoTGV2ZWwuY29tcHV0ZV9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6cHJldl9sZXZlbC5tYXhfYWxsb3dlZF9rZXkpKSkpKSlcbiAgOztcblxuICAoKiogW21pbl9lbHRfXSByZXR1cm5zIFtudWxsXSBpZiBpdCBjYW4ndCBmaW5kIHRoZSBkZXNpcmVkIGVsZW1lbnQuICBXZSB3cmFwIGl0IHVwXG4gICAgICBhZnRlcndhcmRzIHRvIHJldHVybiBhbiBbb3B0aW9uXS4gKilcbiAgbGV0IG1pbl9lbHRfIHQgPVxuICAgIGlmIGlzX2VtcHR5IHRcbiAgICB0aGVuIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICB0aGVuIHQubWluX2VsdFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBtaW5fZWx0X2FscmVhZHlfZm91bmQgPSByZWYgKEludGVybmFsX2VsdC5udWxsICgpKSBpblxuICAgICAgbGV0IG1pbl9rZXlfYWxyZWFkeV9mb3VuZCA9IHJlZiBLZXkubWF4X3ZhbHVlIGluXG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgbGV0IG51bV9sZXZlbHMgPSBudW1fbGV2ZWxzIHQgaW5cbiAgICAgIHdoaWxlICFsZXZlbF9pbmRleCA8IG51bV9sZXZlbHMgZG9cbiAgICAgICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKCFsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgS2V5LiggPiApIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIFdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgYW55IG1vcmUgbGV2ZWxzLiAgUXVpdCB0aGUgbG9vcC4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSBudW1fbGV2ZWxzXG4gICAgICAgIGVsc2UgaWYgbGV2ZWwubGVuZ3RoID0gMFxuICAgICAgICB0aGVuIGluY3IgbGV2ZWxfaW5kZXhcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogTG9vayBpbiBbbGV2ZWxdLiAqKVxuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgbGV0IHNsb3RfbWluX2tleSA9XG4gICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKExldmVsLm1pbl9rZXlfaW5fc2FtZV9zbG90XG4gICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgIH5rZXk6KEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgc2xvdCA9IHJlZiAoTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OiFzbG90X21pbl9rZXkpIGluXG4gICAgICAgICAgKCogRmluZCB0aGUgZmlyc3Qgbm9uZW1wdHkgc2xvdCB3aXRoIGEgc21hbGwgZW5vdWdoIFtzbG90X21pbl9rZXldLiAqKVxuICAgICAgICAgIHdoaWxlXG4gICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXNfbnVsbCBzbG90cy4oIXNsb3QpXG4gICAgICAgICAgICAmJiBLZXkuKCA8ICkgIXNsb3RfbWluX2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgZG9cbiAgICAgICAgICAgIHNsb3QgOj0gTGV2ZWwubmV4dF9zbG90IGxldmVsICFzbG90O1xuICAgICAgICAgICAgc2xvdF9taW5fa2V5IDo9IEtleS5hZGQgIXNsb3RfbWluX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90XG4gICAgICAgICAgZG9uZTtcbiAgICAgICAgICBsZXQgZmlyc3QgPSBzbG90cy4oIXNsb3QpIGluXG4gICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIFZpc2l0IGFsbCBvZiB0aGUgZWx0cyBpbiB0aGlzIHNsb3QgYW5kIGZpbmQgb25lIHdpdGggbWluaW11bSBrZXkuICopXG4gICAgICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgICAgICBsZXQgY3VycmVudF9rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgaWYgS2V5LiggPD0gKSBjdXJyZW50X2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgIG1pbl9lbHRfYWxyZWFkeV9mb3VuZCA6PSAhY3VycmVudDtcbiAgICAgICAgICAgICAgICBtaW5fa2V5X2FscmVhZHlfZm91bmQgOj0gY3VycmVudF9rZXkpO1xuICAgICAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgKCogSWYgWyFsZXZlbF9pbmRleCA9IDBdIHRoZW4gYWxsIGVsdHMgaW4gdGhpcyBzbG90IGhhdmUgdGhlIHNhbWUgW2tleV0sXG4gICAgICAgICAgICAgICAgIGkuZS4gWyFzbG90X21pbl9rZXldLiAgU28sIHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgYW55IGVsZW1lbnRzIGFmdGVyXG4gICAgICAgICAgICAgICAgIFtmaXJzdF0uICBUaGlzIGlzIGEgdXNlZnVsIHNob3J0IGN1dCBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIHNhbWUgbWluIHNsb3QgaW4gbGV2ZWwgMC4gKilcbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHx8ICFsZXZlbF9pbmRleCA9IDBcbiAgICAgICAgICAgICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgICAgICAgICAgICBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgICAgICAgZG9uZSk7XG4gICAgICAgICAgKCogRmluaXNoZWQgbG9va2luZyBpbiBbbGV2ZWxdLiAgTW92ZSB1cCB0byB0aGUgbmV4dCBsZXZlbC4gKilcbiAgICAgICAgICBpbmNyIGxldmVsX2luZGV4KVxuICAgICAgZG9uZTtcbiAgICAgIHQubWluX2VsdCA8LSAhbWluX2VsdF9hbHJlYWR5X2ZvdW5kO1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtICFtaW5fa2V5X2FscmVhZHlfZm91bmQ7XG4gICAgICB0Lm1pbl9lbHQpXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5ID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgYm91bmRzXCJcbiAgICAgICAgICAoa2V5IDogS2V5LnQpXG4gICAgICAgICAgKG1pbl9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgKG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgfnByaW9yaXR5X3F1ZXVlOih0IDogXyB0KV1cbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgbGV2ZWwgYm91bmRzXCIgKGtleSA6IEtleS50KSAobGV2ZWwgOiBfIExldmVsLnQpXVxuICA7O1xuXG4gIGxldCBhZGRfZWx0IHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0IGluXG4gICAgaWYgbm90IChLZXkuKCA+PSApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpICYmIEtleS4oIDw9ICkga2V5IChtYXhfYWxsb3dlZF9rZXkgdCkpXG4gICAgdGhlbiByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5O1xuICAgICgqIEZpbmQgdGhlIGxvd2VzdCBsZXZlbCB0aGF0IHdpbGwgaG9sZCBbZWx0XS4gKilcbiAgICBsZXQgbGV2ZWxfaW5kZXggPVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIHdoaWxlIEtleS4oID4gKSBrZXkgKExldmVsLm1heF9hbGxvd2VkX2tleSB0LmxldmVscy4oIWxldmVsX2luZGV4KSkgZG9cbiAgICAgICAgaW5jciBsZXZlbF9pbmRleFxuICAgICAgZG9uZTtcbiAgICAgICFsZXZlbF9pbmRleFxuICAgIGluXG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgIGlmIG5vdCAoS2V5LiggPj0gKSBrZXkgbGV2ZWwubWluX2FsbG93ZWRfa2V5ICYmIEtleS4oIDw9ICkga2V5IGxldmVsLm1heF9hbGxvd2VkX2tleSlcbiAgICB0aGVuIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsO1xuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggKyAxO1xuICAgIEludGVybmFsX2VsdC5zZXRfbGV2ZWxfaW5kZXggcG9vbCBlbHQgbGV2ZWxfaW5kZXg7XG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIGxldCBmaXJzdCA9IHNsb3RzLihzbG90KSBpblxuICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgdGhlbiBJbnRlcm5hbF9lbHQuaW5zZXJ0X2F0X2VuZCBwb29sIGZpcnN0IH50b19hZGQ6ZWx0XG4gICAgZWxzZSAoXG4gICAgICBzbG90cy4oc2xvdCkgPC0gZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LmxpbmtfdG9fc2VsZiBwb29sIGVsdClcbiAgOztcblxuICBsZXQgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdCA9XG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgdC5wb29sIGVsdCBpblxuICAgIGlmIEtleS4oIDwgKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgdGhlbiAoXG4gICAgICB0Lm1pbl9lbHQgPC0gZWx0O1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIGtleSk7XG4gICAgYWRkX2VsdCB0IGVsdDtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2dvdF9pbnZhbGlkX2tleSB0IGtleSA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmFkZF9hdF9pbnRlcnZhbF9udW0gZ290IGludmFsaWQgaW50ZXJ2YWwgbnVtXCJcbiAgICAgICAgICB+aW50ZXJ2YWxfbnVtOihrZXkgOiBLZXkudClcbiAgICAgICAgICB+bWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtOihtaW5fYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW06KG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXVxuICA7O1xuXG4gIGxldCBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleSA9XG4gICAgaWYgS2V5LiggPCApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpIHx8IEtleS4oID4gKSBrZXkgKG1heF9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gcmFpc2VfZ290X2ludmFsaWRfa2V5IHQga2V5XG4gIDs7XG5cbiAgbGV0IGludGVybmFsX2FkZCB0IH5rZXkgfmF0IHZhbHVlID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBpZiBJbnRlcm5hbF9lbHQuUG9vbC5pc19mdWxsIHQucG9vbCB0aGVuIHQucG9vbCA8LSBJbnRlcm5hbF9lbHQuUG9vbC5ncm93IHQucG9vbDtcbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0LmNyZWF0ZSB0LnBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleDooLTEpIGluXG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdDtcbiAgICBlbHRcbiAgOztcblxuICAoKiogW3JlbW92ZV9vcl9yZV9hZGRfZWx0c10gdmlzaXRzIGVhY2ggZWxlbWVudCBpbiB0aGUgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBbZmlyc3RdLiAgSWYgdGhlIGVsZW1lbnQncyBrZXkgaXMgWz49IHRfbWluX2FsbG93ZWRfa2V5XSwgdGhlbiBpdCBhZGRzIHRoZSBlbGVtZW50XG4gICAgICBiYWNrIGF0IGEgbG93ZXIgbGV2ZWwuICBJZiBub3QsIHRoZW4gaXQgY2FsbHMgW2hhbmRsZV9yZW1vdmVkXSBhbmQgW2ZyZWVdcyB0aGVcbiAgICAgIGVsZW1lbnQuICopXG4gIGxldCByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCAobGV2ZWwgOiBfIExldmVsLnQpIGZpcnN0IH50X21pbl9hbGxvd2VkX2tleSB+aGFuZGxlX3JlbW92ZWRcbiAgICA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAoKiBXZSBleHRyYWN0IFtuZXh0XSBmcm9tIFtjdXJyZW50XSBmaXJzdCwgYmVjYXVzZSB3ZSB3aWxsIG1vZGlmeSBvciBbZnJlZV1cbiAgICAgICAgIFtjdXJyZW50XSBiZWZvcmUgY29udGludWluZyB0aGUgbG9vcC4gKilcbiAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgICBpZiBLZXkuKCA+PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQpIHRfbWluX2FsbG93ZWRfa2V5XG4gICAgICB0aGVuIGFkZF9lbHQgdCAhY3VycmVudFxuICAgICAgZWxzZSAoXG4gICAgICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICAgICAgaGFuZGxlX3JlbW92ZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCAhY3VycmVudCk7XG4gICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgIWN1cnJlbnQpO1xuICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICBkb25lXG4gIDs7XG5cbiAgKCoqIFtpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgW2xldmVsXSB0byBhc1xuICAgICAgbGFyZ2UgYSB2YWx1ZSBhcyBwb3NzaWJsZSwgYnV0IG5vIG1vcmUgdGhhbiBbbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleV0uXG4gICAgICBbdF9taW5fYWxsb3dlZF9rZXldIGlzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGZvciB0aGUgZW50aXJlIHRpbWluZyB3aGVlbC4gIEFzXG4gICAgICBlbGVtZW50cyBhcmUgZW5jb3VudGVyZWQsIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGUgdGltaW5nIHdoZWVsIGlmIHRoZWlyIGtleSBpc1xuICAgICAgc21hbGxlciB0aGFuIFt0X21pbl9hbGxvd2VkX2tleV0sIG9yIGFkZGVkIGF0IGEgbG93ZXIgbGV2ZWwgaWYgbm90LiAqKVxuICBsZXQgaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIHRcbiAgICAgICAgKGxldmVsIDogXyBMZXZlbC50KVxuICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgfnRfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIH5oYW5kbGVfcmVtb3ZlZFxuICAgID1cbiAgICBsZXQgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgTGV2ZWwuY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkgbGV2ZWwgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgaW5cbiAgICAoKiBXZSByZXF1aXJlIHRoYXQgW21vZCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdCA9IDBdLiAgU28sXG4gICAgICAgd2Ugc3RhcnQgW2xldmVsX21pbl9hbGxvd2VkX2tleV0gd2hlcmUgdGhhdCBpcyB0cnVlLCBhbmQgdGhlbiBpbmNyZWFzZSBpdCBieVxuICAgICAgIFtrZXlzX3Blcl9zbG90XSBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC4gKilcbiAgICBsZXQgbGV2ZWxfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgIExldmVsLm1pbl9rZXlfaW5fc2FtZV9zbG90XG4gICAgICAgIGxldmVsXG4gICAgICAgIH5rZXk6XG4gICAgICAgICAgKEtleS5taW5cbiAgICAgICAgICAgICBkZXNpcmVkX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgIChLZXkubWF4IGxldmVsLm1pbl9hbGxvd2VkX2tleSB0LmVsdF9rZXlfbG93ZXJfYm91bmQpKVxuICAgIGluXG4gICAgbGV0IGxldmVsX21pbl9hbGxvd2VkX2tleSA9IHJlZiBsZXZlbF9taW5fYWxsb3dlZF9rZXkgaW5cbiAgICBsZXQgc2xvdCA9IHJlZiAoTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OiFsZXZlbF9taW5fYWxsb3dlZF9rZXkpIGluXG4gICAgbGV0IGtleXNfcGVyX3Nsb3QgPSBsZXZlbC5rZXlzX3Blcl9zbG90IGluXG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICB3aGlsZSBLZXkuKCA8ICkgIWxldmVsX21pbl9hbGxvd2VkX2tleSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSBkb1xuICAgICAgaWYgbGV2ZWwubGVuZ3RoID0gMFxuICAgICAgdGhlblxuICAgICAgICAoKiBJZiBubyBlbGVtZW50cyByZW1haW4gYXQgdGhpcyBsZXZlbCwgd2UgY2FuIGp1c3Qgc2V0IFttaW5fYWxsb3dlZF9rZXldIHRvIHRoZVxuICAgICAgICAgICBkZXNpcmVkIHZhbHVlLiAqKVxuICAgICAgICBsZXZlbF9taW5fYWxsb3dlZF9rZXkgOj0gZGVzaXJlZF9taW5fYWxsb3dlZF9rZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgZmlyc3QgPSBzbG90cy4oIXNsb3QpIGluXG4gICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHNsb3RzLighc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCk7XG4gICAgICAgICAgcmVtb3ZlX29yX3JlX2FkZF9lbHRzIHQgbGV2ZWwgZmlyc3QgfnRfbWluX2FsbG93ZWRfa2V5IH5oYW5kbGVfcmVtb3ZlZCk7XG4gICAgICAgIHNsb3QgOj0gTGV2ZWwubmV4dF9zbG90IGxldmVsICFzbG90O1xuICAgICAgICBsZXZlbF9taW5fYWxsb3dlZF9rZXkgOj0gS2V5LmFkZF9jbGFtcF90b19tYXggIWxldmVsX21pbl9hbGxvd2VkX2tleSBrZXlzX3Blcl9zbG90KVxuICAgIGRvbmU7XG4gICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5IDwtIGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5O1xuICAgIGxldmVsLm1heF9hbGxvd2VkX2tleVxuICAgIDwtIEtleS5hZGRfY2xhbXBfdG9fbWF4IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICA7O1xuXG4gIG1vZHVsZSBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkXG4gIGVuZFxuXG4gIGxldCBpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZCA6IEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQudCA9XG4gICAgaWYgS2V5LiggPD0gKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgZWxzZSAoXG4gICAgICAoKiBXZSBpbmNyZWFzZSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgbGV2ZWxzIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlIGludmFyaWFudFxuICAgICAgICAgdGhhdCB0aGV5IGhhdmUgYXMgbGFyZ2UgYXMgcG9zc2libGUgYSBbbWluX2FsbG93ZWRfa2V5XSwgd2hpbGUgbGVhdmluZyBubyBnYXBzXG4gICAgICAgICBpbiBrZXlzLiAqKVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIGxldCByZXN1bHQgPSByZWYgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC5NYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZCBpblxuICAgICAgbGV0IHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5ID0gcmVmIChLZXkucHJlZCBrZXkpIGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGxldCBudW1fbGV2ZWxzID0gbnVtX2xldmVscyB0IGluXG4gICAgICB3aGlsZSAhbGV2ZWxfaW5kZXggPCBudW1fbGV2ZWxzIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4oIWxldmVsX2luZGV4KSBpblxuICAgICAgICBsZXQgbWluX2FsbG93ZWRfa2V5X2JlZm9yZSA9IGxldmVsLm1pbl9hbGxvd2VkX2tleSBpblxuICAgICAgICBpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICB0XG4gICAgICAgICAgbGV2ZWxcbiAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6IXByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgfnRfbWluX2FsbG93ZWRfa2V5OmtleVxuICAgICAgICAgIH5oYW5kbGVfcmVtb3ZlZDtcbiAgICAgICAgaWYgS2V5LmVxdWFsIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpIG1pbl9hbGxvd2VkX2tleV9iZWZvcmVcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogVGhpcyBsZXZlbCBkaWQgbm90IHNoaWZ0LiAgRG9uJ3Qgc2hpZnQgYW55IGhpZ2hlciBsZXZlbHMuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gbnVtX2xldmVscztcbiAgICAgICAgICByZXN1bHQgOj0gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBMZXZlbCBbbGV2ZWxfaW5kZXhdIHNoaWZ0ZWQuICBDb25zaWRlciBzaGlmdGluZyBoaWdoZXIgbGV2ZWxzLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9ICFsZXZlbF9pbmRleCArIDE7XG4gICAgICAgICAgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgOj0gTGV2ZWwubWF4X2FsbG93ZWRfa2V5IGxldmVsKVxuICAgICAgZG9uZTtcbiAgICAgIGlmIEtleS4oID4gKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogV2UgaGF2ZSByZW1vdmVkIFt0Lm1pbl9lbHRdIG9yIGl0IHdhcyBhbHJlYWR5IG51bGwsIHNvIGp1c3Qgc2V0IGl0IHRvXG4gICAgICAgICAgIG51bGwuICopXG4gICAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIG1pbl9hbGxvd2VkX2tleSB0KTtcbiAgICAgICFyZXN1bHQpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgP2xldmVsX2JpdHMgKCkgPVxuICAgIGxldCBsZXZlbF9iaXRzID1cbiAgICAgIG1hdGNoIGxldmVsX2JpdHMgd2l0aFxuICAgICAgfCBTb21lIGwgLT4gbFxuICAgICAgfCBOb25lIC0+IExldmVsX2JpdHMuZGVmYXVsdFxuICAgIGluXG4gICAgbGV0IF8sIF8sIGxldmVscyA9XG4gICAgICBMaXN0LmZvbGRpXG4gICAgICAgIGxldmVsX2JpdHNcbiAgICAgICAgfmluaXQ6KE51bV9rZXlfYml0cy56ZXJvLCBLZXkuemVybywgW10pXG4gICAgICAgIH5mOihmdW5cbiAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgIChiaXRzX3Blcl9zbG90LCBtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5LCBsZXZlbHMpXG4gICAgICAgICAgICAgKGxldmVsX2JpdHMgOiBOdW1fa2V5X2JpdHMudClcbiAgICAgICAgICAgICAtPlxuICAgICAgICAgICAgICAgbGV0IGtleXNfcGVyX3Nsb3QgPSBLZXkubnVtX2tleXMgYml0c19wZXJfc2xvdCBpblxuICAgICAgICAgICAgICAgbGV0IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgIGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IH5sZXZlbF9iaXRzIH5iaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPVxuICAgICAgICAgICAgICAgICBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmNyZWF0ZSB+Yml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBtaW5fYWxsb3dlZF9rZXkgPVxuICAgICAgICAgICAgICAgICBLZXkubWluX2tleV9pbl9zYW1lX3Nsb3QgbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1heF9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgIEtleS5hZGRfY2xhbXBfdG9fbWF4IG1pbl9hbGxvd2VkX2tleSBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBsZXQgbGV2ZWwgPVxuICAgICAgICAgICAgICAgICB7IExldmVsLmluZGV4XG4gICAgICAgICAgICAgICAgIDsgYml0cyA9IGxldmVsX2JpdHNcbiAgICAgICAgICAgICAgICAgOyBzbG90c19tYXNrID0gU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHNcbiAgICAgICAgICAgICAgICAgOyBiaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAgIDsga2V5c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICA7IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICAgOyBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgOyBsZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgIDsgbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIDsgbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIDsgc2xvdHMgPVxuICAgICAgICAgICAgICAgICAgICAgQXJyYXkuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgIH5sZW46KEludDYzLnRvX2ludF9leG4gKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoIE51bV9rZXlfYml0cy4oICsgKSBsZXZlbF9iaXRzIGJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICwgS2V5LnN1Y2NfY2xhbXBfdG9fbWF4IG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgLCBsZXZlbCA6OiBsZXZlbHMgKSlcbiAgICBpblxuICAgIHsgbGVuZ3RoID0gMFxuICAgIDsgcG9vbCA9IEludGVybmFsX2VsdC5Qb29sLmNyZWF0ZSA/Y2FwYWNpdHkgKClcbiAgICA7IG1pbl9lbHQgPSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIDsgZWx0X2tleV9sb3dlcl9ib3VuZCA9IEtleS56ZXJvXG4gICAgOyBsZXZlbHMgPSBBcnJheS5vZl9saXN0X3JldiBsZXZlbHNcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG1lbSB0IGVsdCA9IEludGVybmFsX2VsdC5leHRlcm5hbF9pc192YWxpZCB0LnBvb2wgZWx0XG5cbiAgbGV0IGludGVybmFsX3JlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBpZiBJbnRlcm5hbF9lbHQuZXF1YWwgZWx0IHQubWluX2VsdFxuICAgIHRoZW5cbiAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgICgqIFdlIGtlZXAgW3QuZWx0X2xvd2VyX2JvdW5kXSBzaW5jZSBpdCBpcyB2YWxpZCBldmVuIHRob3VnaCBbdC5taW5fZWx0XSBpcyBiZWluZ1xuICAgICAgIHJlbW92ZWQuICopO1xuICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oSW50ZXJuYWxfZWx0LmxldmVsX2luZGV4IHBvb2wgZWx0KSBpblxuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggLSAxO1xuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXk6KEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIGluXG4gICAgbGV0IGZpcnN0ID0gc2xvdHMuKHNsb3QpIGluXG4gICAgaWYgcGh5c19lcXVhbCBlbHQgKEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0KVxuICAgIHRoZW4gKCogW2VsdF0gaXMgdGhlIG9ubHkgZWxlbWVudCBpbiB0aGUgc2xvdCAqKVxuICAgICAgc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSAoXG4gICAgICBpZiBwaHlzX2VxdWFsIGVsdCBmaXJzdCB0aGVuIHNsb3RzLihzbG90KSA8LSBJbnRlcm5hbF9lbHQubmV4dCBwb29sIGVsdDtcbiAgICAgIEludGVybmFsX2VsdC51bmxpbmsgcG9vbCBlbHQpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwb29sIGVsdCBpblxuICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdFxuICA7O1xuXG4gIGxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfmhhbmRsZV9maXJlZCB+a2V5IH5ub3cgPVxuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLigwKSBpblxuICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5IGluXG4gICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmaXJzdCA9IHJlZiBzbG90cy4oc2xvdCkgaW5cbiAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgIWZpcnN0KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVmICFmaXJzdCBpblxuICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgICBsZXQgZWx0ID0gIWN1cnJlbnQgaW5cbiAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0IGluXG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0ICFmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0O1xuICAgICAgICAgIGlmIFRpbWVfbnMuKCA8PSApIChJbnRlcm5hbF9lbHQuYXQgcG9vbCBlbHQpIG5vd1xuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgaGFuZGxlX2ZpcmVkIChJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWwgZWx0KTtcbiAgICAgICAgICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICAgICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0O1xuICAgICAgICAgICAgKCogV2UgcmVjb21wdXRlIFtmaXJzdF0gYmVjYXVzZSBbaW50ZXJuYWxfcmVtb3ZlXSBtYXkgaGF2ZSBjaGFuZ2VkIGl0LiAqKVxuICAgICAgICAgICAgZmlyc3QgOj0gc2xvdHMuKHNsb3QpKVxuICAgICAgICBkb25lKSlcbiAgOztcblxuICBsZXQgY2hhbmdlIHQgZWx0IH5rZXkgfmF0ID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5zZXRfa2V5IHBvb2wgZWx0IGtleTtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2F0IHBvb2wgZWx0IGF0O1xuICAgIGludGVybmFsX2FkZF9lbHQgdCBlbHRcbiAgOztcblxuICBsZXQgY2xlYXIgdCA9XG4gICAgaWYgbm90IChpc19lbXB0eSB0KVxuICAgIHRoZW4gKFxuICAgICAgdC5sZW5ndGggPC0gMDtcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgZnJlZV9lbHQgZWx0ID0gSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgZm9yIGxldmVsX2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggbGV2ZWxzIC0gMSBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldmVsLmxlbmd0aCA8LSAwO1xuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgZm9yIHNsb3RfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBzbG90cyAtIDEgZG9cbiAgICAgICAgICAgIGxldCBlbHQgPSBzbG90cy4oc2xvdF9pbmRleCkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOmZyZWVfZWx0O1xuICAgICAgICAgICAgICBzbG90cy4oc2xvdF9pbmRleCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgZG9uZSlcbiAgICAgIGRvbmUpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsX2VsdCA9IFByaW9yaXR5X3F1ZXVlLkludGVybmFsX2VsdFxubW9kdWxlIEtleSA9IFByaW9yaXR5X3F1ZXVlLktleVxubW9kdWxlIEludGVydmFsX251bSA9IEtleVxuXG5sZXQgbWluX2ludGVydmFsX251bSA9IEludGVydmFsX251bS56ZXJvXG5cbigqIEFsbCB0aW1lIGZyb20gdGhlIGVwb2NoIG9ud2FyZHMgaXMgYnJva2VuIGludG8gaGFsZi1vcGVuIGludGVydmFscyBvZiBzaXplXG4gICBbQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiBjb25maWddLiAgVGhlIGludGVydmFscyBhcmUgbnVtYmVyZWQgc3RhcnRpbmcgYXQgemVybywgYW5kIGFcbiAgIHRpbWUncyBpbnRlcnZhbCBudW1iZXIgc2VydmVzIGFzIGl0cyBrZXkgaW4gW3ByaW9yaXR5X3F1ZXVlXS4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgOyBzdGFydCA6IFRpbWVfbnMudFxuICA7ICgqIFttYXhfaW50ZXJ2YWxfbnVtXSBpcyB0aGUgaW50ZXJ2YWwgbnVtYmVyIG9mIFttYXhfdGltZV0uICopXG4gICAgbWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50XG4gIDsgbXV0YWJsZSBub3cgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgOiBUaW1lX25zLnRcbiAgOyBwcmlvcml0eV9xdWV1ZSA6ICdhIFByaW9yaXR5X3F1ZXVlLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG50eXBlICdhIHRpbWluZ193aGVlbCA9ICdhIHRcbnR5cGUgJ2EgdF9ub3cgPSAnYSB0XG5cbmxldCBzZXhwX29mX3Rfbm93IF8gdCA9IFslc2V4cCAodC5ub3cgOiBUaW1lX25zLnQpXVxubGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiB0LmNvbmZpZ1xuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgUHJpb3JpdHlfcXVldWUuRWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgbnVsbCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5udWxsXG4gIGxldCBhdCB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LmF0IHR3LnByaW9yaXR5X3F1ZXVlIHRcbiAgbGV0IHZhbHVlIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQudmFsdWUgdHcucHJpb3JpdHlfcXVldWUgdFxuICBsZXQgaW50ZXJ2YWxfbnVtIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQua2V5IHR3LnByaW9yaXR5X3F1ZXVlIHRcbmVuZFxuXG5sZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG5sZXQgaXRlciB0IH5mID0gUHJpb3JpdHlfcXVldWUuaXRlciB0LnByaW9yaXR5X3F1ZXVlIH5mXG5cbm1vZHVsZSBQcmV0dHkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEFsYXJtID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgYXQgOiBUaW1lX25zLnRcbiAgICAgIDsgdmFsdWUgOiAnYVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICAgIGxldCBjcmVhdGUgdCBhbGFybSA9IHsgYXQgPSBBbGFybS5hdCB0IGFsYXJtOyB2YWx1ZSA9IEFsYXJtLnZhbHVlIHQgYWxhcm0gfVxuICAgIGxldCBjb21wYXJlIHQxIHQyID0gVGltZV9ucy5jb21wYXJlIChhdCB0MSkgKGF0IHQyKVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgICA7IHN0YXJ0IDogVGltZV9ucy50XG4gICAgOyBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgICA7IG5vdyA6IFRpbWVfbnMudFxuICAgIDsgYWxhcm1zIDogJ2EgQWxhcm0udCBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBwcmV0dHlcbiAgICAgICh7IGNvbmZpZ1xuICAgICAgIDsgc3RhcnRcbiAgICAgICA7IG1heF9pbnRlcnZhbF9udW1cbiAgICAgICA7IG5vd1xuICAgICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9IF9cbiAgICAgICA7IG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPSBfXG4gICAgICAgOyBwcmlvcml0eV9xdWV1ZSA9IF9cbiAgICAgICB9IGFzIHQpXG4gID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiByIDo9IFByZXR0eS5BbGFybS5jcmVhdGUgdCBhIDo6ICFyKTtcbiAgbGV0IGFsYXJtcyA9IExpc3Quc29ydCAhciB+Y29tcGFyZTpQcmV0dHkuQWxhcm0uY29tcGFyZSBpblxuICB7IFByZXR0eS5jb25maWc7IHN0YXJ0OyBtYXhfaW50ZXJ2YWxfbnVtOyBub3c7IGFsYXJtcyB9XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgbWF0Y2ggIXNleHBfb2ZfdF9zdHlsZSB3aXRoXG4gIHwgYEludGVybmFsIC0+IHNleHBfb2ZfdF9pbnRlcm5hbCBzZXhwX29mX2EgdFxuICB8IGBQcmV0dHkgLT4gWyVzZXhwIChwcmV0dHkgdCA6IGEgUHJldHR5LnQpXVxuOztcblxubGV0IGxlbmd0aCB0ID0gUHJpb3JpdHlfcXVldWUubGVuZ3RoIHQucHJpb3JpdHlfcXVldWVcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldFtAY29sZF0gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF9leG5fb2ZfZW1wdHlfdGltaW5nX3doZWVsIHQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIiB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF93aXRoX2FsbF9hbGFybXNfaW5fbWF4X2ludGVydmFsIHQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB3aXRoIGFsbCBhbGFybXMgaW4gbWF4IGludGVydmFsXCJcbiAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG47O1xuXG5sZXQgcG9vbCB0ID0gUHJpb3JpdHlfcXVldWUucG9vbCB0LnByaW9yaXR5X3F1ZXVlXG5cbmxldCBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWUgfmFsYXJtX3ByZWNpc2lvbiA9XG4gIEludGVydmFsX251bS5vZl9pbnQ2MyAoQWxhcm1fcHJlY2lzaW9uLmludGVydmFsX251bSBhbGFybV9wcmVjaXNpb24gdGltZSlcbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdGltZSA9XG4gIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZSB+YWxhcm1fcHJlY2lzaW9uOnQuY29uZmlnLmFsYXJtX3ByZWNpc2lvblxuOztcblxubGV0IGludGVydmFsX251bSB0IHRpbWUgPVxuICBpZiBUaW1lX25zLiggPCApIHRpbWUgbWluX3RpbWVcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW0gZ290IHRpbWUgdG9vIGZhciBpbiB0aGUgcGFzdFwiICh0aW1lIDogVGltZV9ucy50KV07XG4gIGludGVydmFsX251bV91bmNoZWNrZWQgdCB0aW1lXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGludGVydmFsX251bSA9XG4gIEFsYXJtX3ByZWNpc2lvbi5pbnRlcnZhbF9udW1fc3RhcnRcbiAgICB0LmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICAoaW50ZXJ2YWxfbnVtIHw+IEludGVydmFsX251bS50b19pbnQ2Mylcbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fc21hbGwgaW50ZXJ2YWxfbnVtID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtX3N0YXJ0IGdvdCB0b28gc21hbGwgaW50ZXJ2YWxfbnVtXCJcbiAgICAgICAgKGludGVydmFsX251bSA6IEludGVydmFsX251bS50KVxuICAgICAgICAobWluX2ludGVydmFsX251bSA6IEludGVydmFsX251bS50KV1cbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fbGFyZ2UgdCBpbnRlcnZhbF9udW0gPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW1fc3RhcnQgZ290IHRvbyBsYXJnZSBpbnRlcnZhbF9udW1cIlxuICAgICAgICAoaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXG4gICAgICAgICh0Lm1heF9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udCldXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgaW50ZXJ2YWxfbnVtID1cbiAgaWYgSW50ZXJ2YWxfbnVtLiggPCApIGludGVydmFsX251bSBtaW5faW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fc21hbGwgaW50ZXJ2YWxfbnVtO1xuICBpZiBJbnRlcnZhbF9udW0uKCA+ICkgaW50ZXJ2YWxfbnVtIHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX2xhcmdlIHQgaW50ZXJ2YWxfbnVtO1xuICBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgaW50ZXJ2YWxfbnVtXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleSA9XG4gICgqIFtpbnRlcnZhbF9udW1fc3RhcnQgdCBrZXldIGlzIHRoZSBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgc3RhcnQgb2YgdGhlIHRpbWUgaW50ZXJ2YWxcbiAgICAgaG9sZGluZyB0aGUgZmlyc3QgYWxhcm0gaW4gW3RdLiAgQWR2YW5jaW5nIHRvIHRoYXQgd291bGQgbm90IGJlIGVub3VnaCwgc2luY2UgdGhlXG4gICAgIGFsYXJtcyBpbiB0aGF0IGludGVydmFsIGRvbid0IGZpcmUgdW50aWwgdGhlIGNsb2NrIGlzIGFkdmFuY2VkIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgbmV4dCBpbnRlcnZhbC4gIFNvLCB3ZSB1c2UgW3N1Y2Mga2V5XSB0byBhZHZhbmNlIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICBpbnRlcnZhbC4gKilcbiAgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKEtleS5zdWNjIGtleSlcbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdCBpblxuICAgIGlmIEludGVydmFsX251bS5lcXVhbCBrZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5KSlcbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF9leG5fb2ZfZW1wdHlfdGltaW5nX3doZWVsIHQ7XG4gIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdCBpblxuICBpZiBJbnRlcnZhbF9udW0uZXF1YWwga2V5IHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfd2l0aF9hbGxfYWxhcm1zX2luX21heF9pbnRlcnZhbCB0O1xuICBuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5XG47O1xuXG5sZXQgY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgPVxuICBsZXQgbWF4X2FsbG93ZWRfa2V5ID0gUHJpb3JpdHlfcXVldWUubWF4X2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJ2YWxfbnVtLiggPj0gKSBtYXhfYWxsb3dlZF9rZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gbWF4X3RpbWVcbiAgZWxzZVxuICAgIFRpbWVfbnMuYWRkXG4gICAgICAoaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IG1heF9hbGxvd2VkX2tleSlcbiAgICAgIChUaW1lX25zLlNwYW4uKCAtICkgKGFsYXJtX3ByZWNpc2lvbiB0KSBUaW1lX25zLlNwYW4ubmFub3NlY29uZClcbjs7XG5cbmxldCBub3dfaW50ZXJ2YWxfbnVtIHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZVxubGV0IG1pbl9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSA9IG5vd19pbnRlcnZhbF9udW1cbmxldCBtYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gdCA9IGludGVydmFsX251bSB0IChtYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpXG5sZXQgaW50ZXJ2YWxfc3RhcnQgdCB0aW1lID0gaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IChpbnRlcnZhbF9udW0gdCB0aW1lKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y29uZmlnOihjaGVjayBDb25maWcuaW52YXJpYW50KVxuICAgICAgfnN0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1biBzdGFydCAtPlxuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+PSApIHN0YXJ0IG1pbl90aW1lKTtcbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBzdGFydCBtYXhfdGltZSkpKVxuICAgICAgfm1heF9pbnRlcnZhbF9udW06XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9pbnRlcnZhbF9udW0gLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogSW50ZXJ2YWxfbnVtLnRdXG4gICAgICAgICAgICAgfmV4cGVjdDptYXhfaW50ZXJ2YWxfbnVtXG4gICAgICAgICAgICAgKGludGVydmFsX251bSB0IG1heF90aW1lKTtcbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogSW50ZXJ2YWxfbnVtLnRdXG4gICAgICAgICAgICAgfmV4cGVjdDptYXhfaW50ZXJ2YWxfbnVtXG4gICAgICAgICAgICAgKGludGVydmFsX251bSB0IChpbnRlcnZhbF9udW1fc3RhcnQgdCBtYXhfaW50ZXJ2YWxfbnVtKSkpKVxuICAgICAgfm5vdzpcbiAgICAgICAgKGNoZWNrIChmdW4gbm93IC0+XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oID49ICkgbm93IHQuc3RhcnQpO1xuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIG5vdyBtYXhfdGltZSk7XG4gICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgSW50ZXJ2YWxfbnVtLmVxdWFsXG4gICAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgdC5ub3cpXG4gICAgICAgICAgICAgICAoUHJpb3JpdHlfcXVldWUubWluX2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWUpKSkpXG4gICAgICB+bm93X2ludGVydmFsX251bV9zdGFydDpcbiAgICAgICAgKGNoZWNrIChmdW4gbm93X2ludGVydmFsX251bV9zdGFydCAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdXG4gICAgICAgICAgICAgbm93X2ludGVydmFsX251bV9zdGFydFxuICAgICAgICAgICAgIH5leHBlY3Q6KGludGVydmFsX251bV9zdGFydCB0IChub3dfaW50ZXJ2YWxfbnVtIHQpKSkpXG4gICAgICB+bWF4X2FsbG93ZWRfYWxhcm1fdGltZTpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2FsbG93ZWRfYWxhcm1fdGltZSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdXG4gICAgICAgICAgICAgbWF4X2FsbG93ZWRfYWxhcm1fdGltZVxuICAgICAgICAgICAgIH5leHBlY3Q6KGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KSkpXG4gICAgICB+cHJpb3JpdHlfcXVldWU6KGNoZWNrIChQcmlvcml0eV9xdWV1ZS5pbnZhcmlhbnQgaW52YXJpYW50X2EpKTtcbiAgICBpdGVyIHQgfmY6KGZ1biBhbGFybSAtPlxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgSW50ZXJ2YWxfbnVtLmVxdWFsXG4gICAgICAgICAgKEFsYXJtLmludGVydmFsX251bSB0IGFsYXJtKVxuICAgICAgICAgIChpbnRlcnZhbF9udW0gdCAoQWxhcm0uYXQgdCBhbGFybSkpKTtcbiAgICAgIGFzc2VydCAoXG4gICAgICAgIFRpbWVfbnMuKCA+PSApXG4gICAgICAgICAgKGludGVydmFsX3N0YXJ0IHQgKEFsYXJtLmF0IHQgYWxhcm0pKVxuICAgICAgICAgIChpbnRlcnZhbF9zdGFydCB0IChub3cgdCkpKTtcbiAgICAgIGFzc2VydCAoXG4gICAgICAgIFRpbWVfbnMuKCA+ICkgKEFsYXJtLmF0IHQgYWxhcm0pIChUaW1lX25zLnN1YiAobm93IHQpIChhbGFybV9wcmVjaXNpb24gdCkpKSkpXG47O1xuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZCA9XG4gIGlmIFRpbWVfbnMuKCA+ICkgdG9fIChub3cgdClcbiAgdGhlbiAoXG4gICAgdC5ub3cgPC0gdG9fO1xuICAgIGxldCBrZXkgPSBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdG9fIGluXG4gICAgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDwtIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBrZXk7XG4gICAgbWF0Y2hcbiAgICAgIFByaW9yaXR5X3F1ZXVlLmluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgIH5rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkOmhhbmRsZV9maXJlZFxuICAgIHdpdGhcbiAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSAtPlxuICAgICAgaWYgZGVidWdcbiAgICAgIHRoZW5cbiAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPSApIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSAoY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKVxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgLT5cbiAgICAgIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbjs7XG5cbmxldCBjcmVhdGUgfmNvbmZpZyB+c3RhcnQgPVxuICBpZiBUaW1lX25zLiggPCApIHN0YXJ0IFRpbWVfbnMuZXBvY2hcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbC5jcmVhdGUgZ290IHN0YXJ0IGJlZm9yZSB0aGUgZXBvY2hcIiAoc3RhcnQgOiBUaW1lX25zLnQpXTtcbiAgbGV0IHQgPVxuICAgIHsgY29uZmlnXG4gICAgOyBzdGFydFxuICAgIDsgbWF4X2ludGVydmFsX251bSA9XG4gICAgICAgIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZTptYXhfdGltZSB+YWxhcm1fcHJlY2lzaW9uOmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICA7IG5vdyA9IFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9XG4gICAgICAgIFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IG1heF90aW1lICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IHByaW9yaXR5X3F1ZXVlID1cbiAgICAgICAgUHJpb3JpdHlfcXVldWUuY3JlYXRlID9jYXBhY2l0eTpjb25maWcuY2FwYWNpdHkgfmxldmVsX2JpdHM6Y29uZmlnLmxldmVsX2JpdHMgKClcbiAgICB9XG4gIGluXG4gIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdDtcbiAgYWR2YW5jZV9jbG9jayB0IH50b186c3RhcnQgfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgdFxuOztcblxubGV0IGFkZF9hdF9pbnRlcnZhbF9udW0gdCB+YXQgdmFsdWUgPVxuICBJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWxcbiAgICAoUHJpb3JpdHlfcXVldWUuaW50ZXJuYWxfYWRkXG4gICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgIH5rZXk6YXRcbiAgICAgICB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuICAgICAgIHZhbHVlKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gdGhhdCBmYXIgaW4gdGhlIGZ1dHVyZVwiXG4gICAgICAgIChhdCA6IFRpbWVfbnMudClcbiAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6KHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2JlZm9yZV9zdGFydF9vZl9jdXJyZW50X2ludGVydmFsIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gYmVmb3JlIHN0YXJ0IG9mIGN1cnJlbnQgaW50ZXJ2YWxcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Oih0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnQpXVxuOztcblxubGV0IGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQgPVxuICBpZiBUaW1lX25zLiggPiApIGF0IHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0aGVuIHJhaXNlX3RoYXRfZmFyX2luX3RoZV9mdXR1cmUgdCBhdDtcbiAgaWYgVGltZV9ucy4oIDwgKSBhdCB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgdGhlbiByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0XG47O1xuXG5sZXQgYWRkIHQgfmF0IHZhbHVlID1cbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpXG4gICAgICAgfmF0XG4gICAgICAgdmFsdWUpXG47O1xuXG5sZXQgcmVtb3ZlIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5yZW1vdmUgdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxubGV0IGNsZWFyIHQgPSBQcmlvcml0eV9xdWV1ZS5jbGVhciB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWVtIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5tZW0gdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxuXG5sZXQgcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5IH5hdCA9XG4gIGlmIG5vdCAobWVtIHQgYWxhcm0pXG4gIHRoZW4gZmFpbHdpdGggXCJUaW1pbmdfd2hlZWwgY2Fubm90IHJlc2NoZWR1bGUgYWxhcm0gbm90IGluIHRpbWluZyB3aGVlbFwiO1xuICBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0O1xuICBQcmlvcml0eV9xdWV1ZS5jaGFuZ2UgdC5wcmlvcml0eV9xdWV1ZSBhbGFybSB+a2V5IH5hdFxuOztcblxubGV0IHJlc2NoZWR1bGUgdCBhbGFybSB+YXQgPSByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6KGludGVydmFsX251bV91bmNoZWNrZWQgdCBhdCkgfmF0XG5cbmxldCByZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSB0IGFsYXJtIH5hdCA9XG4gIHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleTphdCB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuOztcblxubGV0IG1pbl9hbGFybV9pbnRlcnZhbF9udW0gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWluX2FsYXJtX2ludGVydmFsX251bV9leG4gb2YgZW1wdHkgdGltaW5nX3doZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbiAgZWxzZSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdFxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWF4X2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWluX2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAobWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldO1xuICBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0XG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkID1cbiAgUHJpb3JpdHlfcXVldWUuZmlyZV9wYXN0X2FsYXJtc1xuICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICB+aGFuZGxlX2ZpcmVkXG4gICAgfmtleToobm93X2ludGVydmFsX251bSB0KVxuICAgIH5ub3c6dC5ub3dcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBOdW1fa2V5X2JpdHMgPSBOdW1fa2V5X2JpdHNcblxuICBsZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsID0gaW50ZXJ2YWxfbnVtX2ludGVybmFsXG4gIGxldCBtYXhfdGltZSA9IG1heF90aW1lXG5lbmRcbiJdfQ==
