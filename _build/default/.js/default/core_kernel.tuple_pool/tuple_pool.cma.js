// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Tuple_pool__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Tuple_pool = [0];
   runtime.caml_register_global(0, Tuple_pool, "Tuple_pool__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Import = "Tuple_pool__Import",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][1], "tuple_pool/src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Import);
   var Tuple_pool_Import = [0];
   runtime.caml_register_global(11, Tuple_pool_Import, cst_Tuple_pool_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_type_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_type_intf = "Tuple_pool__Tuple_type_intf",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_type_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1
    (Expect_test_collector[5][1], "tuple_pool/src/tuple_type_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_type_intf);
   var Tuple_pool_Tuple_type_intf = [0];
   runtime.caml_register_global
    (11, Tuple_pool_Tuple_type_intf, cst_Tuple_pool_Tuple_type_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_type
//# unitInfo: Requires: Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool__Tuple_type_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_type$0 = "Tuple_pool__Tuple_type",
    cst_tuple_pool$0 = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    t1 = [0, 301584533, [0, 1]],
    t2 = [0, 301584533, [0, 2]],
    t3 = [0, 301584533, [0, 3]],
    t4 = [0, 301584533, [0, 4]],
    t5 = [0, 301584533, [0, 5]],
    t6 = [0, 301584533, [0, 6]],
    t7 = [0, 301584533, [0, 7]],
    t8 = [0, 301584533, [0, 8]],
    t9 = [0, 301584533, [0, 9]],
    t10 = [0, 301584533, [0, 10]],
    t11 = [0, 301584533, [0, 11]],
    t12 = [0, 301584533, [0, 12]],
    t13 = [0, 301584533, [0, 13]],
    t14 = [0, 301584533, [0, 14]],
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_type$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool$0);
   caml_call1(Expect_test_collector[5][1], "tuple_pool/src/tuple_type.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool$0, cst);
   var
    _b_ = [0, "Slots"],
    _a_ = [0, "slots_per_tuple"],
    cst_tuple_pool = cst_tuple_pool$0,
    cst_Tuple_pool_Tuple_type = cst_Tuple_pool_Tuple_type$0;
   function sexp_of_t(param){
    var
     v_006 = param[2],
     slots_per_tuple_002 = v_006[1],
     arg_003 = caml_call1(Core[356], slots_per_tuple_002),
     bnds_001 = [0, [1, [0, _a_, [0, arg_003, 0]]], 0];
    return [1, [0, _b_, [0, [1, bnds_001], 0]]];
   }
   function sexp_of_t$0(of_tuple_007, of_variant_008){return sexp_of_t;}
   function slots_per_tuple(param){var n = param[2][1]; return n;}
   function sexp_of_t1(of_a0_009){return sexp_of_t;}
   function sexp_of_t2(of_a0_010, of_a1_011){return sexp_of_t;}
   function sexp_of_t3(of_a0_012, of_a1_013, of_a2_014){return sexp_of_t;}
   function sexp_of_t4(of_a0_015, of_a1_016, of_a2_017, of_a3_018){return sexp_of_t;
   }
   function sexp_of_t5(of_a0_019, of_a1_020, of_a2_021, of_a3_022, of_a4_023){return sexp_of_t;
   }
   function sexp_of_t6
   (of_a0_024, of_a1_025, of_a2_026, of_a3_027, of_a4_028, of_a5_029){return sexp_of_t;
   }
   function sexp_of_t7
   (of_a0_030,
    of_a1_031,
    of_a2_032,
    of_a3_033,
    of_a4_034,
    of_a5_035,
    of_a6_036){
    return sexp_of_t;
   }
   function sexp_of_t8
   (of_a0_037,
    of_a1_038,
    of_a2_039,
    of_a3_040,
    of_a4_041,
    of_a5_042,
    of_a6_043,
    of_a7_044){
    return sexp_of_t;
   }
   function sexp_of_t9
   (of_a0_045,
    of_a1_046,
    of_a2_047,
    of_a3_048,
    of_a4_049,
    of_a5_050,
    of_a6_051,
    of_a7_052,
    of_a8_053){
    return sexp_of_t;
   }
   function sexp_of_t10
   (of_a0_054,
    of_a1_055,
    of_a2_056,
    of_a3_057,
    of_a4_058,
    of_a5_059,
    of_a6_060,
    of_a7_061,
    of_a8_062,
    of_a9_063){
    return sexp_of_t;
   }
   function sexp_of_t11
   (of_a0_064,
    of_a1_065,
    of_a2_066,
    of_a3_067,
    of_a4_068,
    of_a5_069,
    of_a6_070,
    of_a7_071,
    of_a8_072,
    of_a9_073,
    of_a10_074){
    return sexp_of_t;
   }
   function sexp_of_t12
   (of_a0_075,
    of_a1_076,
    of_a2_077,
    of_a3_078,
    of_a4_079,
    of_a5_080,
    of_a6_081,
    of_a7_082,
    of_a8_083,
    of_a9_084,
    of_a10_085,
    of_a11_086){
    return sexp_of_t;
   }
   function sexp_of_t13
   (of_a0_087,
    of_a1_088,
    of_a2_089,
    of_a3_090,
    of_a4_091,
    of_a5_092,
    of_a6_093,
    of_a7_094,
    of_a8_095,
    of_a9_096,
    of_a10_097,
    of_a11_098,
    of_a12_099){
    return sexp_of_t;
   }
   function sexp_of_t14
   (of_a0_100,
    of_a1_101,
    of_a2_102,
    of_a3_103,
    of_a4_104,
    of_a5_105,
    of_a6_106,
    of_a7_107,
    of_a8_108,
    of_a9_109,
    of_a10_110,
    of_a11_111,
    of_a12_112,
    of_a13_113){
    return sexp_of_t;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_type);
   var
    Tuple_pool_Tuple_type =
      [0,
       [0,
        sexp_of_t$0,
        slots_per_tuple,
        sexp_of_t1,
        sexp_of_t2,
        sexp_of_t3,
        sexp_of_t4,
        sexp_of_t5,
        sexp_of_t6,
        sexp_of_t7,
        sexp_of_t8,
        sexp_of_t9,
        sexp_of_t10,
        sexp_of_t11,
        sexp_of_t12,
        sexp_of_t13,
        sexp_of_t14,
        t1,
        t2,
        t3,
        t4,
        t5,
        t6,
        t7,
        t8,
        t9,
        t10,
        t11,
        t12,
        t13,
        t14]];
   runtime.caml_register_global
    (28, Tuple_pool_Tuple_type, cst_Tuple_pool_Tuple_type$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool__Tuple_pool_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Tuple_pool_Tuple_pool_intf = "Tuple_pool__Tuple_pool_intf",
    cst_tuple_pool = "tuple_pool";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool_Tuple_pool_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool);
   caml_call1
    (Expect_test_collector[5][1], "tuple_pool/src/tuple_pool_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool_Tuple_pool_intf);
   var Tuple_pool_Tuple_pool_intf = [0];
   runtime.caml_register_global
    (11, Tuple_pool_Tuple_pool_intf, cst_Tuple_pool_Tuple_pool_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Tuple_pool
//# unitInfo: Requires: Assert_failure, Base__Field, Base__String, Bin_prot__Shape, Core, Core__Array, Core__Core_sys, Core__Debug, Core__Error, Core__Int, Core__Int63, Core__List, Core__Printf, Core__Result, Core__Uniform_array, Expect_test_collector, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool__Tuple_type, Typerep_lib__Make_typename, Typerep_lib__Std, Typerep_lib__Typename, Typerep_lib__Typerep_obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Tuple_pool$0 = "Tuple_pool",
    cst$0 = "_",
    cst_capacity$1 = "capacity",
    cst_dummy$0 = "dummy",
    cst_first_free$0 = "first_free",
    cst_is_valid$0 = "is_valid",
    cst_length$0 = "length",
    cst_next_id$0 = "next_id",
    cst_pointer$0 = "pointer",
    cst_slots_per_tuple$0 = "slots_per_tuple",
    cst_t$1 = "t",
    cst_tuple_pool$0 = "tuple_pool",
    cst_tuple_pool_src_tuple_pool_$9 = "tuple_pool/src/tuple_pool.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   function caml_call13
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    return (f.l >= 0 ? f.l : f.l = f.length) == 13
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   function caml_call15
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14){
    return (f.l >= 0 ? f.l : f.l = f.length) == 15
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    name$1 = "tuple_pool/src/tuple_pool.ml.Error_check.Pointer.t",
    prefix = "Pool.",
    name$0 = "tuple_pool/src/tuple_pool.ml.Debug.Pointer.t",
    cst = cst$1,
    name = "tuple_pool/src/tuple_pool.ml.Pool.Pointer.t",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Core = global_data.Core,
    Typerep_lib_Std = global_data.Typerep_lib__Std,
    Typerep_lib_Typerep_obj = global_data.Typerep_lib__Typerep_obj,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename,
    Core_Int63 = global_data.Core__Int63,
    Core_Result = global_data.Core__Result,
    Core_List = global_data.Core__List,
    Core_Debug = global_data.Core__Debug,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Core_Uniform_array = global_data.Core__Uniform_array,
    Tuple_pool_Tuple_type = global_data.Tuple_pool__Tuple_type,
    Assert_failure = global_data.Assert_failure,
    Core_Array = global_data.Core__Array,
    Base_Field = global_data.Base__Field,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_String = global_data.Base__String,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Error = global_data.Core__Error,
    Core_Core_sys = global_data.Core__Core_sys,
    Core_Int = global_data.Core__Int,
    Core_Printf = global_data.Core__Printf,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Tuple_pool$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_tuple_pool$0);
   caml_call1(Expect_test_collector[5][1], cst_tuple_pool_src_tuple_pool_$9);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_tuple_pool$0, cst);
   var
    failwiths = Core_Error[41],
    arch_sixtyfour = caml_call2(Core[90], Core_Core_sys[9], 64),
    num_bits = Core_Int[40],
    max_value = Core[1][19],
    to_string = Core[22],
    sprintf = Core_Printf[2],
    _aN_ = [0, cst$0],
    cst_attempt_to_use_invalid_poi = "attempt to use invalid pointer",
    _aO_ = [0, cst_tuple_pool_src_tuple_pool_$9, 1150, 38369, 38396],
    cst_is_valid = cst_is_valid$0,
    cst_pointer = cst_pointer$0,
    _aL_ = [0, cst_pointer$0],
    _aM_ = [0, cst_is_valid$0],
    cst_unsafe_set = "unsafe_set",
    cst_set = "set",
    _aK_ = [0, cst$0],
    cst_unsafe_get = "unsafe_get",
    cst_get = "get",
    _aJ_ = [0, cst$0],
    _aI_ = [0, cst$0],
    _aH_ = [0, cst$0],
    _aG_ = [0, cst$0],
    cst_get_tuple = "get_tuple",
    _aF_ = [0, cst$0],
    cst_new = "new",
    _aE_ = [0, cst$0],
    cst_free = "free",
    _aD_ = [0, cst$0],
    cst_unsafe_free = "unsafe_free",
    _aC_ = [0, cst$0],
    cst_is_full = "is_full",
    _aB_ = [0, cst_capacity$1],
    _aA_ = [0, cst$0],
    cst_grow = "grow",
    _az_ = [0, cst$0],
    cst_capacity$0 = cst_capacity$1,
    cst_max_capacity = "max_capacity",
    _ay_ = [0, cst$0],
    cst_create = "create",
    _ax_ = [0, cst$0],
    cst_pointer_is_valid = "pointer_is_valid",
    _aw_ = [0, cst$0],
    cst_pointer_of_id_exn = "pointer_of_id_exn",
    _av_ = [0, cst$0],
    cst_id_of_pointer = "id_of_pointer",
    cst_Pointer_Id_to_int63 = "Pointer.Id.to_int63",
    cst_Pointer_Id_of_int63 = "Pointer.Id.of_int63",
    _au_ = [0, cst$0],
    cst_Pointer_is_null = "Pointer.is_null",
    _at_ = [0, cst$0],
    _as_ = [0, cst$0],
    cst_Pointer_phys_equal = "Pointer.phys_equal",
    _ar_ = [0, cst$0],
    _aq_ = [0, cst$0],
    cst_Pointer_phys_compare = "Pointer.phys_compare",
    _ap_ = [0, " result", 0],
    cst_t = cst_t$1,
    cst_tuple_pool_src_tuple_pool_$8 = "tuple_pool/src/tuple_pool.ml:986:6",
    cst_t$0 = cst_t$1,
    _an_ = [0, cst$0],
    _am_ = [0, cst$0],
    cst_Pool_free_of_invalid_point = "Pool.free of invalid pointer",
    _ao_ = [0, cst_tuple_pool_src_tuple_pool_$9, 700, 23089, 23103],
    _ak_ = [0, cst$0],
    cst_Pool_malloc_of_full_pool = "Pool.malloc of full pool",
    _al_ = [0, cst_tuple_pool_src_tuple_pool_$9, 657, 21456, 21476],
    cst_Pool_grow_cannot_grow_pool =
      "Pool.grow cannot grow pool; capacity already at maximum",
    _aj_ = [0, cst_tuple_pool_src_tuple_pool_$9, 625, 20520, 20534],
    _ah_ = [0, "max"],
    cst_Pool_create_got_invalid_ca = "Pool.create got invalid capacity",
    _ag_ = [0, cst_tuple_pool_src_tuple_pool_$9, 540, 17887, 17909],
    cst_Pool_create_got_too_large_ = "Pool.create got too large capacity",
    _ai_ = [0, cst_tuple_pool_src_tuple_pool_$9, 546, 18147, 18161],
    _W_ = [0, cst$0],
    _af_ = [0, cst_tuple_pool_src_tuple_pool_$9, 450, 56],
    _ae_ = [0, cst_tuple_pool_src_tuple_pool_$9, 453, 13],
    _ad_ = [0, cst_tuple_pool_src_tuple_pool_$9, 454, 13],
    _ac_ = [0, cst_tuple_pool_src_tuple_pool_$9, 457, 13],
    _ab_ = [0, cst_tuple_pool_src_tuple_pool_$9, 458, 13],
    _aa_ = [0, cst_tuple_pool_src_tuple_pool_$9, 466, 15],
    _$_ = [0, cst_tuple_pool_src_tuple_pool_$9, 468, 15],
    cst_cycle_in_free_list = "cycle in free list",
    ___ = [0, cst_tuple_pool_src_tuple_pool_$9, 472, 15394, 15427],
    _Y_ = [0, cst_tuple_pool_src_tuple_pool_$9, 479, 15],
    _Z_ = [0, cst_tuple_pool_src_tuple_pool_$9, 488, 21],
    cst_Pool_invariant_failed = "Pool.invariant failed",
    _X_ = [0, cst_tuple_pool_src_tuple_pool_$9, 493, 16348, 16370],
    _T_ = [0, cst$0],
    cst_invalid_header_index = "invalid header index",
    _V_ = [0, cst_tuple_pool_src_tuple_pool_$9, 433, 13853, 13882],
    cst_pointer_not_live = "pointer not live",
    cst_Pool_pointer_of_id_exn_got = "Pool.pointer_of_id_exn got invalid id",
    _U_ = [0, cst_tuple_pool_src_tuple_pool_$9, 439, 14080, 14094],
    _N_ = [0, cst_dummy$0],
    _O_ = [0, cst_first_free$0],
    _P_ = [0, cst_next_id$0],
    _Q_ = [0, cst_length$0],
    _R_ = [0, cst_capacity$1],
    _S_ = [0, cst_slots_per_tuple$0],
    _A_ = [0, cst_tuple_pool_src_tuple_pool_$9, 329, 6],
    _w_ = [0, "null"],
    _x_ = [0, "Free"],
    _y_ = [0, "Used"],
    _v_ = [0, cst_tuple_pool_src_tuple_pool_$9, 307, 8],
    _u_ = [0, cst_tuple_pool_src_tuple_pool_$9, 308, 8],
    _q_ = [0, cst$0],
    cst_should_equal = "should equal",
    _r_ = [0, cst_tuple_pool_src_tuple_pool_$9, 251, 7700, 7731],
    cst_Pointer_of_id_exn_got_stra = "Pointer.of_id_exn got strange id",
    _p_ = [0, cst_tuple_pool_src_tuple_pool_$9, 255, 7828, 7844],
    _m_ = [0, cst_tuple_pool_src_tuple_pool_$9, 219, 48],
    _k_ =
      [0,
       [11, "<Pool.Pointer.t: 0x", [4, 6, [0, 2, 8], 0, [12, 62, 0]]],
       "<Pool.Pointer.t: 0x%08x>"],
    cst_Tuple_id_of_int_got_negati = "Tuple_id.of_int got negative int",
    _j_ = [0, cst_tuple_pool_src_tuple_pool_$9, 145, 4421, 4448],
    _i_ = [0, cst_tuple_pool_src_tuple_pool_$9, 136, 22],
    _b_ = [0, cst_capacity$1],
    _c_ = [0, "old_capacity"],
    cst_Pool_grow_got_too_small_ca = "Pool.grow got too small capacity",
    _d_ = [0, cst_tuple_pool_src_tuple_pool_$9, 29, 638, 654],
    _a_ = [0, cst$1],
    cst_tuple_pool_src_tuple_pool_ = cst_tuple_pool_src_tuple_pool_$9,
    cst_t13_max_slot = "<<t13 = max_slot>>",
    _aR_ = [0, cst_tuple_pool_src_tuple_pool_$9, 104, 6],
    _aS_ = [0, cst_tuple_pool_src_tuple_pool_$9, 107, 6],
    cst_tuple_pool_src_tuple_pool_$0 = cst_tuple_pool_src_tuple_pool_$9,
    cst_array_index_num_bits_0 = "<<array_index_num_bits > 0>>",
    cst_tuple_pool_src_tuple_pool_$1 = cst_tuple_pool_src_tuple_pool_$9,
    cst_masked_tuple_id_num_bits_0 = "<<masked_tuple_id_num_bits > 0>>",
    cst_tuple_pool_src_tuple_pool_$2 = cst_tuple_pool_src_tuple_pool_$9,
    cst_array_index_num_bits_maske =
      "<<(array_index_num_bits + masked_tuple_id_num_b[...]>>",
    cst_tuple_pool_src_tuple_pool_$3 = cst_tuple_pool_src_tuple_pool_$9,
    cst_null_max_slot_0 = "<<((null ()) + max_slot) < 0>>",
    cst_tuple_pool_src_tuple_pool_$4 = cst_tuple_pool_src_tuple_pool_$9,
    cst_invariant_ignore_null = "<<invariant ignore (null ())>>",
    cst_tuple_pool_src_tuple_pool_$5 = cst_tuple_pool_src_tuple_pool_$9,
    cst_List_iter_Tuple_id_example =
      "<<List.iter Tuple_id.examples   ~f:(fun tuple_i[...]>>",
    cst_tuple_pool_src_tuple_pool_$6 = cst_tuple_pool_src_tuple_pool_$9,
    cst_List_iter_Tuple_id_example$0 =
      "<<List.iter Tuple_id.examples   ~f:(fun id ->  [...]>>",
    cst_tuple_pool_src_tuple_pool_$7 = cst_tuple_pool_src_tuple_pool_$9,
    cst_for_slots_per_tuple_1_to_m =
      "<<for slots_per_tuple = 1 to max_slot do   asse[...]>>",
    cst_dummy = cst_dummy$0,
    cst_first_free = cst_first_free$0,
    cst_next_id = cst_next_id$0,
    cst_length = cst_length$0,
    cst_capacity = cst_capacity$1,
    cst_slots_per_tuple = cst_slots_per_tuple$0,
    cst_tuple_pool = cst_tuple_pool$0,
    cst_Tuple_pool = cst_Tuple_pool$0;
   function concat(l){return caml_call2(Base_String[54], _a_, l);}
   var max_slot = 14;
   function sexp_of_t(of_slots_007, of_a_008){return Core[356];}
   function equal(t1, t2){return caml_call2(Core[90], t1, t2);}
   var
    t0 = 1,
    t1 = 2,
    t2 = 3,
    t3 = 4,
    t4 = 5,
    t5 = 6,
    t6 = 7,
    t7 = 8,
    t8 = 9,
    t9 = 10,
    t10 = 11,
    t11 = 12,
    t12 = 13,
    t13 = 14;
   function _e_(param){return caml_call2(Core[90], t13, max_slot);}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_t13_max_slot,
     0,
     cst_tuple_pool_src_tuple_pool_,
     87,
     4,
     31,
     _e_);
   var
    Slot =
      [0,
       sexp_of_t,
       equal,
       t0,
       t1,
       t2,
       t3,
       t4,
       t5,
       t6,
       t7,
       t8,
       t9,
       t10,
       t11,
       t12,
       t13];
   if(arch_sixtyfour){
    if(! caml_call2(Core[90], num_bits, 63))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
    var array_index_num_bits = 30;
   }
   else{
    if
     (!
      caml_call2(Core[90], num_bits, 31)
      && ! caml_call2(Core[90], num_bits, 32))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
    var array_index_num_bits = 22;
   }
   var masked_tuple_id_num_bits = num_bits - array_index_num_bits | 0;
   function _f_(param){return caml_call2(Core[91], array_index_num_bits, 0);}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_array_index_num_bits_0,
     0,
     cst_tuple_pool_src_tuple_pool_$0,
     113,
     2,
     39,
     _f_);
   function _g_(param){
    return caml_call2(Core[91], masked_tuple_id_num_bits, 0);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_masked_tuple_id_num_bits_0,
     0,
     cst_tuple_pool_src_tuple_pool_$1,
     114,
     2,
     43,
     _g_);
   function _h_(param){
    return caml_call2
            (Core[89],
             array_index_num_bits + masked_tuple_id_num_bits | 0,
             num_bits);
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_array_index_num_bits_maske,
     0,
     cst_tuple_pool_src_tuple_pool_$2,
     115,
     2,
     78,
     _h_);
   var max_array_length = 1 << array_index_num_bits, sexp_of_t$0 = Core[356];
   function invariant(t){
    if(caml_call2(Core[88], t, 0)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   var init = 0;
   function of_int(i){
    if(caml_call2(Core[92], i, 0))
     caml_call5
      (failwiths, 0, _j_, cst_Tuple_id_of_int_got_negati, i, Core[356]);
    return i;
   }
   var
    examples = [0, 0, [0, 1, [0, 536870911, [0, max_value, 0]]]],
    tuple_id_mask = (1 << masked_tuple_id_num_bits) - 1 | 0,
    Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name]),
    typename_of_t = Typename_of_t[2];
   function typerep_of_t(of_slots){
    var name_of_t = caml_call1(Typename_of_t[1], of_slots);
    return [9, [0, name_of_t, [0, Core[359]]]];
   }
   function sexp_of_t$1(param, t){return [0, caml_call2(sprintf, _k_, t)];}
   function phys_equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var phys_compare = Core[95];
   function null$0(param){return -15;}
   function is_null(t){return t === -15 ? 1 : 0;}
   function _l_(param){return caml_call2(Core[92], -1, 0);}
   caml_call8
    (Ppx_inline_test_lib_Runtime[4],
     Inline_test_config,
     cst_null_max_slot_0,
     0,
     cst_tuple_pool_src_tuple_pool_$3,
     209,
     4,
     39,
     _l_);
   function create(header_index, tuple_id){
    return header_index | (tuple_id & tuple_id_mask) << array_index_num_bits;
   }
   var header_index_mask = (1 << array_index_num_bits) - 1 | 0;
   function masked_tuple_id(t){return t >>> array_index_num_bits | 0;}
   function header_index(t){return t & header_index_mask;}
   function invariant$0(param, t){
    var _cK_ = 1 - (t === -15 ? 1 : 0);
    if(! _cK_) return _cK_;
    var _cL_ = header_index(t);
    if(caml_call2(Core[91], _cL_, 0)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   function _n_(param){
    var _cI_ = -15;
    invariant$0(function(_cJ_){return 0;}, _cI_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_invariant_ignore_null,
     0,
     cst_tuple_pool_src_tuple_pool_$4,
     221,
     4,
     48,
     _n_);
   function _o_(param){
    function _cF_(tuple_id){
     var _cG_ = create(1, tuple_id);
     return invariant$0(function(_cH_){return 0;}, _cG_);
    }
    caml_call2(Core_List[9], examples, _cF_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_List_iter_Tuple_id_example,
     0,
     cst_tuple_pool_src_tuple_pool_$5,
     223,
     4,
     135,
     _o_);
   function slot_index(t, slot){return header_index(t) + slot | 0;}
   function first_slot_index(t){return slot_index(t, Slot[3]);}
   var
    to_int_exn = Core_Int63[5],
    of_int$0 = Core_Int63[69],
    bin_size_t = Core_Int63[90],
    bin_write_t = Core_Int63[91],
    bin_read_t = Core_Int63[92],
    bin_read_t$0 = Core_Int63[93],
    bin_shape_t = Core_Int63[94],
    bin_writer_t = Core_Int63[95],
    bin_reader_t = Core_Int63[96],
    bin_t = Core_Int63[97],
    t_of_sexp = Core_Int63[98],
    sexp_of_t$2 = Core_Int63[99];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   var
    _s_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t$2,
       to_int63,
       of_int63],
    null$1 = 0;
   function is_null$0(t){return caml_call2(Core[90], t, 0);}
   function is_free(t){return caml_call2(Core[91], t, 0);}
   function is_used(t){return caml_call2(Core[92], t, 0);}
   function tuple_id(t){return of_int(- (t + 1 | 0) | 0);}
   function _t_(param){
    function _cE_(id){
     var t = -1 - id | 0;
     if(! is_used(t))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     var t1 = tuple_id(t);
     if(caml_call2(Core[90], t1, id)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
    }
    caml_call2(Core_List[9], examples, _cE_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_List_iter_Tuple_id_example$0,
     0,
     cst_tuple_pool_src_tuple_pool_$6,
     304,
     4,
     173,
     _t_);
   var metadata_index = 0, start_of_tuples_index = 1;
   function max_capacity(slots_per_tuple){
    return caml_div(max_array_length - 1 | 0, 1 + slots_per_tuple | 0);
   }
   function _z_(param){
    var slots_per_tuple = 1;
    for(;;){
     var
      _cC_ =
        1 + caml_mul(1 + slots_per_tuple | 0, max_capacity(slots_per_tuple))
        | 0;
     if(! caml_call2(Core[89], _cC_, max_array_length))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     var _cD_ = slots_per_tuple + 1 | 0;
     if(14 === slots_per_tuple) return 0;
     var slots_per_tuple = _cD_;
    }
   }
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     cst_for_slots_per_tuple_1_to_m,
     0,
     cst_tuple_pool_src_tuple_pool_$7,
     327,
     2,
     203,
     _z_);
   function dummy(r){return r[6];}
   function first_free(r){return r[5];}
   function set_first_free(r, v){r[5] = v; return 0;}
   function next_id(r){return r[4];}
   function set_next_id(r, v){r[4] = v; return 0;}
   function length(r){return r[3];}
   function set_length(r, v){r[3] = v; return 0;}
   function capacity(r){return r[2];}
   function slots_per_tuple(r){return r[1];}
   function _B_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v];}
   var
    _C_ = 0,
    dummy$0 = [0, function(param){return 0;}, cst_dummy, _C_, dummy, _B_];
   function _D_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}
   var
    _E_ = [0, set_first_free],
    first_free$0 =
      [0, function(param){return 0;}, cst_first_free, _E_, first_free, _D_];
   function _F_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _G_ = [0, set_next_id],
    next_id$0 =
      [0, function(param){return 0;}, cst_next_id, _G_, next_id, _F_];
   function _H_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _I_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _I_, length, _H_];
   function _J_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6]];}
   var
    _K_ = 0,
    capacity$0 =
      [0, function(param){return 0;}, cst_capacity, _K_, capacity, _J_];
   function _L_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _M_ = 0,
    slots_per_tuple$0 =
      [0,
       function(param){return 0;},
       cst_slots_per_tuple,
       _M_,
       slots_per_tuple,
       _L_];
   function array_indices_per_tuple(t){return 1 + t[1] | 0;}
   function array_length(t){
    var _cB_ = array_indices_per_tuple(t);
    return 1 + caml_mul(t[2], _cB_) | 0;
   }
   function tuple_num_to_header_index(t, tuple_num){
    return 1 + caml_mul(tuple_num, array_indices_per_tuple(t)) | 0;
   }
   function tuple_num_to_first_slot_index(t, tuple_num){
    return tuple_num_to_header_index(t, tuple_num) + 1 | 0;
   }
   function metadata(t){
    return caml_call2(Core_Uniform_array[20], t, metadata_index);
   }
   function length$1(t){return metadata(t)[3];}
   function sexp_of_t$3(sexp_of_ty, t){
    var
     param = metadata(t),
     capacity_018 = param[2],
     slots_per_tuple_016 = param[1],
     length_020 = param[3],
     next_id_022 = param[4],
     first_free_024 = param[5],
     dummy_026 = param[6],
     arg_027 = caml_call2(Core[454], Sexplib0_Sexp_conv[23], dummy_026),
     bnds_015 = [0, [1, [0, _N_, [0, arg_027, 0]]], 0],
     arg_025 =
       is_null$0(first_free_024)
        ? _w_
        : is_free
           (first_free_024)
          ? [1, [0, _x_, [0, [0, caml_call1(to_string, first_free_024)], 0]]]
          : [1,
            [0,
             _y_,
             [0, [0, caml_call1(to_string, tuple_id(first_free_024))], 0]]],
     bnds_015$0 = [0, [1, [0, _O_, [0, arg_025, 0]]], bnds_015],
     arg_023 = caml_call1(sexp_of_t$0, next_id_022),
     bnds_015$1 = [0, [1, [0, _P_, [0, arg_023, 0]]], bnds_015$0],
     arg_021 = caml_call1(Core[356], length_020),
     bnds_015$2 = [0, [1, [0, _Q_, [0, arg_021, 0]]], bnds_015$1],
     arg_019 = caml_call1(Core[356], capacity_018),
     bnds_015$3 = [0, [1, [0, _R_, [0, arg_019, 0]]], bnds_015$2],
     arg_017 = caml_call1(Core[356], slots_per_tuple_016),
     bnds_015$4 = [0, [1, [0, _S_, [0, arg_017, 0]]], bnds_015$3];
    return [1, bnds_015$4];
   }
   function unsafe_header(t, header_index){
    return caml_call2(Core_Uniform_array[20], t, header_index);
   }
   function unsafe_set_header(t, header_index, header){
    return caml_call3(Core_Uniform_array[45], t, header_index, header);
   }
   function header_index_is_in_bounds(t, header_index){
    var _cz_ = caml_call2(Core[88], header_index, start_of_tuples_index);
    if(! _cz_) return _cz_;
    var _cA_ = caml_call1(Core_Uniform_array[18], t);
    return caml_call2(Core[92], header_index, _cA_);
   }
   function unsafe_pointer_is_live(t, pointer){
    var
     header_index$0 = header_index(pointer),
     header = unsafe_header(t, header_index$0),
     _cw_ = is_used(header);
    if(! _cw_) return _cw_;
    var
     _cx_ = masked_tuple_id(pointer),
     _cy_ = tuple_id(header) & tuple_id_mask;
    return caml_call2(Core[90], _cy_, _cx_);
   }
   function pointer_is_valid(t, pointer){
    var _cv_ = header_index_is_in_bounds(t, header_index(pointer));
    return _cv_ ? unsafe_pointer_is_live(t, pointer) : _cv_;
   }
   function id_of_pointer(t, pointer){return caml_call1(of_int$0, pointer);}
   function is_valid_header_index(t, header_index){
    var
     metadata$0 = metadata(t),
     _ct_ = header_index_is_in_bounds(t, header_index);
    if(! _ct_) return _ct_;
    var
     _cu_ =
       runtime.caml_mod
        (header_index - 1 | 0, array_indices_per_tuple(metadata$0));
    return caml_call2(Core[90], 0, _cu_);
   }
   function pointer_of_id_exn(t$2, id){
    try{
     try{
      var t = caml_call1(to_int_exn, id);
      if(t === -15)
       var t$0 = t;
      else
       var
        _cs_ = of_int(masked_tuple_id(t)),
        should_equal = create(header_index(t), _cs_),
        t$1 =
          t === should_equal
           ? t
           : caml_call5
             (failwiths,
              0,
              _r_,
              cst_should_equal,
              should_equal,
              function(x_009){
               return sexp_of_t$1(function(param){return _q_;}, x_009);
              }),
        t$0 = t$1;
      var pointer = t$0;
     }
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       pointer =
         caml_call5
          (failwiths,
           0,
           _p_,
           cst_Pointer_of_id_exn_got_stra,
           [0, id, exn],
           function(param){
            var
             arg1_011 = param[2],
             arg0_010 = param[1],
             res0_012 = caml_call1(sexp_of_t$2, arg0_010),
             res1_013 = caml_call1(Core[537], arg1_011);
            return [1, [0, res0_012, [0, res1_013, 0]]];
           });
     }
     if(1 - (pointer === -15 ? 1 : 0)){
      var header_index$0 = header_index(pointer);
      if(1 - is_valid_header_index(t$2, header_index$0))
       caml_call5
        (failwiths,
         0,
         _V_,
         cst_invalid_header_index,
         header_index$0,
         Core[356]);
      if(1 - unsafe_pointer_is_live(t$2, pointer))
       caml_call1(Core[6], cst_pointer_not_live);
     }
     return pointer;
    }
    catch(exn){
     var exn$0 = caml_wrap_exception(exn);
     return caml_call5
             (failwiths,
              0,
              _U_,
              cst_Pool_pointer_of_id_exn_got,
              [0, id, t$2, exn$0],
              function(param){
               var
                arg2_030 = param[3],
                arg1_029 = param[2],
                arg0_028 = param[1],
                res0_031 = caml_call1(_s_[10], arg0_028),
                res1_032 = sexp_of_t$3(function(param){return _T_;}, arg1_029),
                res2_033 = caml_call1(Core[537], arg2_030);
               return [1, [0, res0_031, [0, res1_032, [0, res2_033, 0]]]];
              });
    }
   }
   function invariant$1(invariant_a, t){
    try{
     var
      metadata$0 = metadata(t),
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, metadata$0));
        },
      _cd_ =
        function(param){
         if(param){
          var
           dummy = param[1],
           _ck_ = metadata$0[1],
           _cl_ = caml_call1(Core_Uniform_array[18], dummy);
          if(caml_call2(Core[90], _cl_, _ck_)) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
         }
         var _cn_ = metadata$0[2] - 1 | 0, _cm_ = 0;
         if(_cn_ >= 0){
          var tuple_num = _cm_;
          for(;;){
           var
            header_index = tuple_num_to_header_index(metadata$0, tuple_num),
            header = unsafe_header(t, header_index);
           if(is_free(header)){
            var
             first_slot = tuple_num_to_first_slot_index(metadata$0, tuple_num),
             _cp_ = metadata$0[1] - 1 | 0,
             _co_ = 0;
            if(_cp_ >= 0){
             var slot = _co_;
             for(;;){
              if
               (typeof
                caml_call2(Core_Uniform_array[19], t, first_slot + slot | 0)
                !== "number")
               throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
              var _cr_ = slot + 1 | 0;
              if(_cp_ === slot) break;
              var slot = _cr_;
             }
            }
           }
           var _cq_ = tuple_num + 1 | 0;
           if(_cn_ === tuple_num) break;
           var tuple_num = _cq_;
          }
         }
         return 0;
        },
      _ce_ =
        function(first_free){
         var
          free = caml_call2(Core_Array[38], metadata$0[2], 0),
          r = [0, first_free];
         for(;;){
          if(is_null$0(r[1])) return 0;
          var header_index = r[1];
          if(! is_free(header_index))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
          if(! is_valid_header_index(t, header_index))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
          var
           tuple_num =
             caml_div
              (header_index - 1 | 0, array_indices_per_tuple(metadata$0));
          if(caml_check_bound(free, tuple_num)[1 + tuple_num])
           caml_call5
            (failwiths, 0, ___, cst_cycle_in_free_list, tuple_num, Core[356]);
          caml_check_bound(free, tuple_num)[1 + tuple_num] = 1;
          r[1] = unsafe_header(t, header_index);
         }
        },
      _cf_ =
        function(length){
         if(! caml_call2(Core[88], length, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
         if(caml_call2(Core[89], length, metadata$0[2])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
        },
      _cg_ =
        function(capacity){
         if(! caml_call2(Core[88], capacity, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
         var
          _ci_ = array_length(metadata$0),
          _cj_ = caml_call1(Core_Uniform_array[18], t);
         if(caml_call2(Core[90], _cj_, _ci_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ad_], 1);
        };
     check
      (function(slots_per_tuple){
        if(caml_call2(Core[91], slots_per_tuple, 0)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _af_], 1);
       },
       slots_per_tuple$0);
     check(_cg_, capacity$0);
     check(_cf_, length$0);
     check(invariant, next_id$0);
     check(_ce_, first_free$0);
     var _ch_ = check(_cd_, dummy$0);
     return _ch_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return caml_call5
             (failwiths,
              0,
              _X_,
              cst_Pool_invariant_failed,
              [0, exn, t],
              function(param){
               var
                arg1_035 = param[2],
                arg0_034 = param[1],
                res0_036 = caml_call1(Core[537], arg0_034),
                res1_037 = sexp_of_t$3(function(param){return _W_;}, arg1_035);
               return [1, [0, res0_036, [0, res1_037, 0]]];
              });
    }
   }
   function capacity$1(t){return metadata(t)[2];}
   function is_full(t){
    var t$0 = metadata(t);
    return caml_call2(Core[90], t$0[3], t$0[2]);
   }
   function unsafe_add_to_free_list(t, metadata, header_index){
    unsafe_set_header(t, header_index, metadata[5]);
    metadata[5] = header_index;
    return;
   }
   function set_metadata(t, metadata){
    return caml_call3(Core_Uniform_array[21], t, metadata_index, metadata);
   }
   function create_array(metadata){
    var
     _cc_ = array_length(metadata),
     t = caml_call1(Core_Uniform_array[43], _cc_);
    set_metadata(t, metadata);
    return t;
   }
   function unsafe_init_range(t, metadata, lo, hi){
    var match = metadata[6];
    if(match){
     var dummy = match[1], _b8_ = hi - 1 | 0;
     if(_b8_ >= lo){
      var tuple_num$0 = lo;
      for(;;){
       var
        _b$_ = metadata[1],
        _ca_ = tuple_num_to_first_slot_index(metadata, tuple_num$0);
       caml_call5(Core_Uniform_array[36], dummy, 0, t, _ca_, _b$_);
       var _cb_ = tuple_num$0 + 1 | 0;
       if(_b8_ === tuple_num$0) break;
       var tuple_num$0 = _cb_;
      }
     }
    }
    var _b9_ = hi - 1 | 0;
    if(_b9_ >= lo){
     var tuple_num = _b9_;
     for(;;){
      unsafe_add_to_free_list
       (t, metadata, tuple_num_to_header_index(metadata, tuple_num));
      var _b__ = tuple_num - 1 | 0;
      if(lo === tuple_num) break;
      var tuple_num = _b__;
     }
    }
    return;
   }
   function create_with_dummy(slots, capacity, dummy){
    if(caml_call2(Core[92], capacity, 0))
     caml_call5
      (failwiths,
       0,
       _ag_,
       cst_Pool_create_got_invalid_ca,
       capacity,
       Core[356]);
    var
     slots_per_tuple = caml_call1(Tuple_pool_Tuple_type[1][2], slots),
     max_capacity$0 = max_capacity(slots_per_tuple);
    if(caml_call2(Core[91], capacity, max_capacity$0))
     caml_call5
      (failwiths,
       0,
       _ai_,
       cst_Pool_create_got_too_large_,
       [0, capacity, [0, 5442212, max_capacity$0]],
       function(param){
        var
         arg1_040 = param[2],
         arg0_039 = param[1],
         res0_041 = caml_call1(Core[356], arg0_039),
         v_038 = arg1_040[2],
         res1_042 = [1, [0, _ah_, [0, caml_call1(Core[356], v_038), 0]]];
        return [1, [0, res0_041, [0, res1_042, 0]]];
       });
    var
     metadata = [0, slots_per_tuple, capacity, 0, init, null$1, dummy],
     t = create_array(metadata);
    unsafe_init_range(t, metadata, 0, capacity);
    return t;
   }
   function create$0(slots, capacity, dummy){
    var
     _b7_ = caml_call1(Tuple_pool_Tuple_type[1][2], slots),
     dummy$0 =
       caml_call2(Core[90], _b7_, 1)
        ? caml_call1(Core_Uniform_array[16], dummy)
        : dummy;
    return create_with_dummy(slots, capacity, [0, dummy$0]);
   }
   function grow(capacity$0, t){
    var
     match$0 = metadata(t),
     old_capacity = match$0[2],
     slots_per_tuple = match$0[1],
     length = match$0[3],
     next_id = match$0[4],
     dummy$0 = match$0[6];
    if(capacity$0){
     var capacity = capacity$0[1];
     if(caml_call2(Core[89], capacity, old_capacity))
      caml_call5
       (failwiths,
        0,
        _d_,
        cst_Pool_grow_got_too_small_ca,
        [0, [0, -1011154630, capacity], [0, 138253074, old_capacity]],
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          v_001 = arg0_003[2],
          res0_005 = [1, [0, _b_, [0, caml_call1(Core[356], v_001), 0]]],
          v_002 = arg1_004[2],
          res1_006 = [1, [0, _c_, [0, caml_call1(Core[356], v_002), 0]]];
         return [1, [0, res0_005, [0, res1_006, 0]]];
        });
     var _b2_ = capacity;
    }
    else
     var
      _b2_ = caml_call2(Core[90], old_capacity, 0) ? 1 : old_capacity * 2 | 0;
    var
     _b3_ = max_capacity(slots_per_tuple),
     capacity$1 = caml_call2(Core[96], _b3_, _b2_);
    if(caml_call2(Core[90], capacity$1, old_capacity))
     caml_call5
      (failwiths,
       0,
       _aj_,
       cst_Pool_grow_cannot_grow_pool,
       capacity$1,
       Core[356]);
    var
     metadata$2 =
       [0, slots_per_tuple, capacity$1, length, next_id, null$1, dummy$0],
     t$0 = create_array(metadata$2),
     _b4_ = caml_mul(old_capacity, array_indices_per_tuple(metadata$2));
    caml_call5
     (Core_Uniform_array[36],
      t,
      start_of_tuples_index,
      t$0,
      start_of_tuples_index,
      _b4_);
    var metadata$0 = metadata(t), match = metadata$0[6];
    if(match){
     var dummy = match[1], _bY_ = metadata$0[2] - 1 | 0, _bX_ = 0;
     if(_bY_ >= 0){
      var tuple_num = _bX_;
      for(;;){
       var header_index = tuple_num_to_header_index(metadata$0, tuple_num);
       unsafe_set_header(t, header_index, null$1);
       caml_call5
        (Core_Uniform_array[36],
         dummy,
         0,
         t,
         header_index + 1 | 0,
         metadata$0[1]);
       var _bZ_ = tuple_num + 1 | 0;
       if(_bY_ === tuple_num) break;
       var tuple_num = _bZ_;
      }
     }
    }
    else{
     var _b0_ = caml_call1(Core_Uniform_array[18], t) - 1 | 0;
     if(_b0_ >= 1){
      var i = start_of_tuples_index;
      for(;;){
       caml_call3(Core_Uniform_array[22], t, i, 0);
       var _b1_ = i + 1 | 0;
       if(_b0_ === i) break;
       var i = _b1_;
      }
     }
    }
    var
     metadata$1 =
       [0, metadata$0[1], 0, 0, metadata$0[4], null$1, metadata$0[6]];
    set_metadata(t, metadata$1);
    unsafe_init_range(t$0, metadata$2, old_capacity, capacity$1);
    var _b5_ = old_capacity - 1 | 0;
    if(_b5_ >= 0){
     var tuple_num$0 = _b5_;
     for(;;){
      var
       header_index$0 = tuple_num_to_header_index(metadata$2, tuple_num$0),
       header = unsafe_header(t$0, header_index$0);
      if(1 - is_used(header))
       unsafe_add_to_free_list(t$0, metadata$2, header_index$0);
      var _b6_ = tuple_num$0 - 1 | 0;
      if(0 === tuple_num$0) break;
      var tuple_num$0 = _b6_;
     }
    }
    return t$0;
   }
   function malloc(t){
    var metadata$0 = metadata(t), header_index = metadata$0[5];
    if(is_null$0(header_index))
     caml_call5
      (failwiths,
       0,
       _al_,
       cst_Pool_malloc_of_full_pool,
       t,
       function(x_043){
        return sexp_of_t$3(function(param){return _ak_;}, x_043);
       });
    metadata$0[5] = unsafe_header(t, header_index);
    metadata$0[3] = metadata$0[3] + 1 | 0;
    var tuple_id = metadata$0[4];
    unsafe_set_header(t, header_index, -1 - tuple_id | 0);
    var
     _bW_ =
       arch_sixtyfour
        ? tuple_id + 1 | 0
        : caml_call2(Core[90], tuple_id, max_value) ? 0 : tuple_id + 1 | 0;
    metadata$0[4] = _bW_;
    return create(header_index, tuple_id);
   }
   function unsafe_free(t, pointer){
    var metadata$0 = metadata(t);
    metadata$0[3] = metadata$0[3] - 1 | 0;
    unsafe_add_to_free_list(t, metadata$0, header_index(pointer));
    var match = metadata$0[6];
    if(match){
     var
      dummy = match[1],
      _bR_ = metadata$0[1],
      _bS_ = first_slot_index(pointer);
     return caml_call5(Core_Uniform_array[38], dummy, 0, t, _bS_, _bR_);
    }
    var
     pos = first_slot_index(pointer),
     _bU_ = metadata$0[1] - 1 | 0,
     _bT_ = 0;
    if(_bU_ >= 0){
     var i = _bT_;
     for(;;){
      caml_call2(Core_Uniform_array[47], t, pos + i | 0);
      var _bV_ = i + 1 | 0;
      if(_bU_ === i) break;
      var i = _bV_;
     }
    }
    return 0;
   }
   function free(t, pointer){
    if(1 - pointer_is_valid(t, pointer))
     caml_call5
      (failwiths,
       0,
       _ao_,
       cst_Pool_free_of_invalid_point,
       [0, pointer, t],
       function(param){
        var
         arg1_045 = param[2],
         arg0_044 = param[1],
         res0_046 = sexp_of_t$1(function(param){return _am_;}, arg0_044),
         res1_047 = sexp_of_t$3(function(param){return _an_;}, arg1_045);
        return [1, [0, res0_046, [0, res1_047, 0]]];
       });
    return unsafe_free(t, pointer);
   }
   function new1(t, a0){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    return pointer;
   }
   function new2(t, a0, a1){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    return pointer;
   }
   function new3(t, a0, a1, a2){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    return pointer;
   }
   function new4(t, a0, a1, a2, a3){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    return pointer;
   }
   function new5(t, a0, a1, a2, a3, a4){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    return pointer;
   }
   function new6(t, a0, a1, a2, a3, a4, a5){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    return pointer;
   }
   function new7(t, a0, a1, a2, a3, a4, a5, a6){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    return pointer;
   }
   function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    return pointer;
   }
   function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    return pointer;
   }
   function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    return pointer;
   }
   function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    return pointer;
   }
   function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    return pointer;
   }
   function new13(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    caml_call3(Core_Uniform_array[22], t, offset + 13 | 0, a12);
    return pointer;
   }
   function new14
   (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    var pointer = malloc(t), offset = header_index(pointer);
    caml_call3(Core_Uniform_array[22], t, offset + 1 | 0, a0);
    caml_call3(Core_Uniform_array[22], t, offset + 2 | 0, a1);
    caml_call3(Core_Uniform_array[22], t, offset + 3 | 0, a2);
    caml_call3(Core_Uniform_array[22], t, offset + 4 | 0, a3);
    caml_call3(Core_Uniform_array[22], t, offset + 5 | 0, a4);
    caml_call3(Core_Uniform_array[22], t, offset + 6 | 0, a5);
    caml_call3(Core_Uniform_array[22], t, offset + 7 | 0, a6);
    caml_call3(Core_Uniform_array[22], t, offset + 8 | 0, a7);
    caml_call3(Core_Uniform_array[22], t, offset + 9 | 0, a8);
    caml_call3(Core_Uniform_array[22], t, offset + 10 | 0, a9);
    caml_call3(Core_Uniform_array[22], t, offset + 11 | 0, a10);
    caml_call3(Core_Uniform_array[22], t, offset + 12 | 0, a11);
    caml_call3(Core_Uniform_array[22], t, offset + 13 | 0, a12);
    caml_call3(Core_Uniform_array[22], t, offset + 14 | 0, a13);
    return pointer;
   }
   function get(t, p, slot){
    var _bQ_ = slot_index(p, slot);
    return caml_call2(Core_Uniform_array[19], t, _bQ_);
   }
   function unsafe_get(t, p, slot){
    var _bP_ = slot_index(p, slot);
    return caml_call2(Core_Uniform_array[20], t, _bP_);
   }
   function set(t, p, slot, x){
    var _bO_ = slot_index(p, slot);
    return caml_call3(Core_Uniform_array[21], t, _bO_, x);
   }
   function unsafe_set(t, p, slot, x){
    var _bN_ = slot_index(p, slot);
    return caml_call3(Core_Uniform_array[22], t, _bN_, x);
   }
   function get_tuple(t, pointer){
    var metadata$0 = metadata(t), len = metadata$0[1];
    if(caml_call2(Core[90], len, 1)) return get(t, pointer, Slot[3]);
    var _bM_ = first_slot_index(pointer);
    return caml_call3(Core_Uniform_array[39], t, _bM_, len);
   }
   function create$1(slots, capacity){
    return create_with_dummy(slots, capacity, 0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_tuple_pool);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Tuple_pool);
   function _aP_(Pool){
    var Slots = Pool[1], Slot = Pool[2];
    function sexp_of_t(of_slots_077, param){
     var
      is_valid_079 = param[1],
      pointer_081 = param[2],
      arg_082 = caml_call2(Pool[3][1], of_slots_077, pointer_081),
      bnds_078 = [0, [1, [0, _aL_, [0, arg_082, 0]]], 0],
      arg_080 = caml_call1(Core[305], is_valid_079),
      bnds_078$0 = [0, [1, [0, _aM_, [0, arg_080, 0]]], bnds_078];
     return [1, bnds_078$0];
    }
    var
     Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name$1]),
     typename_of_t = Typename_of_t[2];
    function typerep_of_t(of_slots){
     var name_of_t = caml_call1(Typename_of_t[1], of_slots);
     return [9,
             [0,
              name_of_t,
              [0,
               [246,
                function(param){
                 var _bF_ = 1;
                 function _bG_(t){return t[1];}
                 var
                  _bH_ = caml_call2(Typerep_lib_Typename[1], 0, 0),
                  field0 =
                    caml_call1
                     (Typerep_lib_Std[1][8][7],
                      [0, cst_is_valid, Core[308], 0, _bH_, _bG_, _bF_]),
                  _bI_ = 0;
                 function _bJ_(t){return t[2];}
                 var
                  _bK_ = caml_call2(Typerep_lib_Typename[1], 0, 0),
                  _bL_ =
                    [0,
                     cst_pointer,
                     caml_call1(Pool[3][2], of_slots),
                     1,
                     _bK_,
                     _bJ_,
                     _bI_],
                  field1 = caml_call1(Typerep_lib_Std[1][8][7], _bL_),
                  typename = caml_call1(Typerep_lib_Std[1][1][2], name_of_t),
                  has_double_array_tag =
                    caml_call1
                     (Typerep_lib_Typerep_obj[4],
                      [0, Typerep_lib_Typerep_obj[3], Typerep_lib_Typerep_obj[3]]),
                  fields = [0, [0, field0], [0, field1]];
                 function create(param){
                  var
                   get = param[1],
                   is_valid = caml_call1(get, field0),
                   pointer = caml_call1(get, field1);
                  return [0, is_valid, pointer];
                 }
                 return [7,
                         caml_call1
                          (Typerep_lib_Std[1][10][7],
                           [0, typename, fields, has_double_array_tag, create])];
                }]]]];
    }
    function create(pointer){return [0, 1, pointer];}
    function null$0(param){return [0, 0, caml_call1(Pool[3][4], 0)];}
    function phys_compare(t1, t2){
     return caml_call2(Pool[3][6], t1[2], t2[2]);
    }
    function phys_equal(t1, t2){return caml_call2(Pool[3][7], t1[2], t2[2]);}
    function is_null(t){return caml_call1(Pool[3][5], t[2]);}
    function follow(t){
     if(1 - t[1])
      caml_call5
       (failwiths,
        0,
        _aO_,
        cst_attempt_to_use_invalid_poi,
        t,
        function(x_083){
         return sexp_of_t(function(param){return _aN_;}, x_083);
        });
     return t[2];
    }
    function invalidate(t){t[1] = 0; return 0;}
    var
     Id = Pool[3][8],
     sexp_of_t$0 = Pool[4],
     invariant = Pool[5],
     length = Pool[12];
    function pointer_is_valid(t, param){
     var is_valid = param[1], pointer = param[2];
     return is_valid ? caml_call2(Pool[6], t, pointer) : is_valid;
    }
    function id_of_pointer(t, pointer){
     return caml_call2(Pool[7], t, pointer[2]);
    }
    function pointer_of_id_exn(t, id){
     var
      pointer = caml_call2(Pool[8], t, id),
      is_valid = caml_call2(Pool[6], t, pointer);
     return [0, is_valid, pointer];
    }
    var
     create$0 = Pool[9],
     capacity = Pool[11],
     max_capacity = Pool[10],
     grow = Pool[13],
     is_full = Pool[14];
    function get_tuple(t, p){
     var _bE_ = follow(p);
     return caml_call2(Pool[31], t, _bE_);
    }
    function get(t, p){
     var _bD_ = follow(p);
     return caml_call2(Pool[32], t, _bD_);
    }
    function unsafe_get(t, p){
     var _bC_ = follow(p);
     return caml_call2(Pool[33], t, _bC_);
    }
    function set(t, p, slot, v){
     var _bB_ = follow(p);
     return caml_call4(Pool[34], t, _bB_, slot, v);
    }
    function unsafe_set(t, p, slot, v){
     var _bA_ = follow(p);
     return caml_call4(Pool[35], t, _bA_, slot, v);
    }
    function unsafe_free(t, p){
     var _bz_ = follow(p);
     caml_call2(Pool[16], t, _bz_);
     return invalidate(p);
    }
    function free(t, p){
     var _by_ = follow(p);
     caml_call2(Pool[15], t, _by_);
     return invalidate(p);
    }
    function new1(t, a0){return create(caml_call2(Pool[17], t, a0));}
    function new2(t, a0, a1){return create(caml_call3(Pool[18], t, a0, a1));}
    function new3(t, a0, a1, a2){
     return create(caml_call4(Pool[19], t, a0, a1, a2));
    }
    function new4(t, a0, a1, a2, a3){
     return create(caml_call5(Pool[20], t, a0, a1, a2, a3));
    }
    function new5(t, a0, a1, a2, a3, a4){
     return create(caml_call6(Pool[21], t, a0, a1, a2, a3, a4));
    }
    function new6(t, a0, a1, a2, a3, a4, a5){
     return create(caml_call7(Pool[22], t, a0, a1, a2, a3, a4, a5));
    }
    function new7(t, a0, a1, a2, a3, a4, a5, a6){
     return create(caml_call8(Pool[23], t, a0, a1, a2, a3, a4, a5, a6));
    }
    function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
     return create(caml_call9(Pool[24], t, a0, a1, a2, a3, a4, a5, a6, a7));
    }
    function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
     return create
             (caml_call10(Pool[25], t, a0, a1, a2, a3, a4, a5, a6, a7, a8));
    }
    function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
     return create
             (caml_call11(Pool[26], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
    }
    function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
     return create
             (caml_call12
               (Pool[27], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
    }
    function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
     return create
             (caml_call13
               (Pool[28], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
    }
    function new13(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
     return create
             (caml_call14
               (Pool[29],
                t,
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12));
    }
    function new14
    (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
     return create
             (caml_call15
               (Pool[30],
                t,
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13));
    }
    return [0,
            Slots,
            Slot,
            [0,
             sexp_of_t,
             typerep_of_t,
             typename_of_t,
             null$0,
             is_null,
             phys_compare,
             phys_equal,
             Id],
            sexp_of_t$0,
            invariant,
            pointer_is_valid,
            id_of_pointer,
            pointer_of_id_exn,
            create$0,
            max_capacity,
            capacity,
            length,
            grow,
            is_full,
            free,
            unsafe_free,
            new1,
            new2,
            new3,
            new4,
            new5,
            new6,
            new7,
            new8,
            new9,
            new10,
            new11,
            new12,
            new13,
            new14,
            get_tuple,
            get,
            unsafe_get,
            set,
            unsafe_set];
   }
   function _aQ_(Pool){
    var check_invariant = [0, 1], show_messages = [0, 1];
    function debug(name, ts, arg, sexp_of_arg, sexp_of_result, f){
     if(check_invariant[1]){
      var _bs_ = function(_bx_){return 0;}, _bt_ = caml_call1(Pool[5], _bs_);
      caml_call2(Core_List[9], ts, _bt_);
     }
     if(show_messages[1]){
      var _bu_ = concat([0, prefix, [0, name, 0]]);
      caml_call3(Core_Debug[2], _bu_, arg, sexp_of_arg);
     }
     var result_or_exn = caml_call1(Core_Result[47], f);
     if(show_messages[1]){
      var
       _bv_ =
         function(x_048){
          return caml_call3(Core_Result[10], sexp_of_result, Core[537], x_048);
         },
       _bw_ = concat([0, prefix, [0, name, _ap_]]);
      caml_call3(Core_Debug[2], _bw_, result_or_exn, _bv_);
     }
     return caml_call1(Core_Result[32], result_or_exn);
    }
    var
     Slots = Pool[1],
     Slot = Pool[2],
     sexp_of_t = Pool[3][1],
     Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name$0]),
     typename_of_t = Typename_of_t[2];
    function typerep_of_t(of_slots){
     var name_of_t = caml_call1(Typename_of_t[1], of_slots);
     return [9,
             [0,
              name_of_t,
              [0,
               [246, function(_br_){return caml_call1(Pool[3][2], of_slots);}]]]];
    }
    function phys_compare(t1, t2){
     function _bp_(param){return caml_call2(Pool[3][6], t1, t2);}
     var _bq_ = Core[356];
     return debug
             (cst_Pointer_phys_compare,
              0,
              [0, t1, t2],
              function(param){
               var
                arg1_052 = param[2],
                arg0_051 = param[1],
                res0_053 =
                  caml_call2
                   (sexp_of_t, function(param){return _aq_;}, arg0_051),
                res1_054 =
                  caml_call2
                   (sexp_of_t, function(param){return _ar_;}, arg1_052);
               return [1, [0, res0_053, [0, res1_054, 0]]];
              },
              _bq_,
              _bp_);
    }
    function phys_equal(t1, t2){
     function _bn_(param){return caml_call2(Pool[3][7], t1, t2);}
     var _bo_ = Core[305];
     return debug
             (cst_Pointer_phys_equal,
              0,
              [0, t1, t2],
              function(param){
               var
                arg1_056 = param[2],
                arg0_055 = param[1],
                res0_057 =
                  caml_call2
                   (sexp_of_t, function(param){return _as_;}, arg0_055),
                res1_058 =
                  caml_call2
                   (sexp_of_t, function(param){return _at_;}, arg1_056);
               return [1, [0, res0_057, [0, res1_058, 0]]];
              },
              _bo_,
              _bn_);
    }
    function is_null(t){
     function _bl_(param){return caml_call1(Pool[3][5], t);}
     var _bm_ = Core[305];
     return debug
             (cst_Pointer_is_null,
              0,
              t,
              function(x_059){
               return caml_call2
                       (sexp_of_t, function(param){return _au_;}, x_059);
              },
              _bm_,
              _bl_);
    }
    var
     null$0 = Pool[3][4],
     _aT_ = Pool[3][8][5],
     _aU_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _aT_], 0],
     _aV_ = caml_call1(Bin_prot_Shape[4][1], cst_tuple_pool_src_tuple_pool_$8),
     group = caml_call2(Bin_prot_Shape[6], _aV_, _aU_),
     _aW_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0),
     bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[14], group, _aW_), 0),
     bin_size_t = Pool[3][8][1],
     bin_write_t = Pool[3][8][2],
     bin_writer_t = [0, bin_size_t, bin_write_t],
     bin_read_t = Pool[3][8][4],
     bin_read_t$0 = Pool[3][8][3],
     bin_reader_t = [0, bin_read_t$0, bin_read_t],
     bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
     t_of_sexp = Pool[3][8][9],
     sexp_of_t$0 = Pool[3][8][10];
    function of_int63(i){
     function _bk_(param){return caml_call1(Pool[3][8][12], i);}
     return debug
             (cst_Pointer_Id_of_int63,
              0,
              i,
              Core_Int63[99],
              sexp_of_t$0,
              _bk_);
    }
    function to_int63(t){
     function _bj_(param){return caml_call1(Pool[3][8][11], t);}
     return debug
             (cst_Pointer_Id_to_int63,
              0,
              t,
              sexp_of_t$0,
              Core_Int63[99],
              _bj_);
    }
    var sexp_of_t$1 = Pool[4], invariant = Pool[5], length = Pool[12];
    function id_of_pointer(t, pointer){
     function _bi_(param){return caml_call2(Pool[7], t, pointer);}
     return debug
             (cst_id_of_pointer,
              [0, t, 0],
              pointer,
              function(x_063){
               return caml_call2
                       (sexp_of_t, function(param){return _av_;}, x_063);
              },
              sexp_of_t$0,
              _bi_);
    }
    function pointer_of_id_exn(t, id){
     function _bh_(param){return caml_call2(Pool[8], t, id);}
     return debug
             (cst_pointer_of_id_exn,
              [0, t, 0],
              id,
              sexp_of_t$0,
              function(x_064){
               return caml_call2
                       (sexp_of_t, function(param){return _aw_;}, x_064);
              },
              _bh_);
    }
    function pointer_is_valid(t, pointer){
     function _bf_(param){return caml_call2(Pool[6], t, pointer);}
     var _bg_ = Core[305];
     return debug
             (cst_pointer_is_valid,
              [0, t, 0],
              pointer,
              function(x_065){
               return caml_call2
                       (sexp_of_t, function(param){return _ax_;}, x_065);
              },
              _bg_,
              _bf_);
    }
    function create(slots, capacity, dummy){
     function _bd_(param){return caml_call3(Pool[9], slots, capacity, dummy);}
     function _be_(x_066){
      return caml_call2(sexp_of_t$1, function(param){return _ay_;}, x_066);
     }
     return debug(cst_create, 0, capacity, Core[356], _be_, _bd_);
    }
    function max_capacity(slots_per_tuple){
     function _bc_(param){return caml_call1(Pool[10], slots_per_tuple);}
     return debug
             (cst_max_capacity,
              0,
              slots_per_tuple,
              Core[356],
              Core[356],
              _bc_);
    }
    function capacity(t){
     function _ba_(param){return caml_call1(Pool[11], t);}
     var _bb_ = Core[356];
     return debug
             (cst_capacity$0,
              [0, t, 0],
              t,
              function(x_067){
               return caml_call2
                       (sexp_of_t$1, function(param){return _az_;}, x_067);
              },
              _bb_,
              _ba_);
    }
    function grow(capacity, t){
     function _a__(param){return caml_call2(Pool[13], capacity, t);}
     function _a$_(x_069){
      return caml_call2(sexp_of_t$1, function(param){return _aA_;}, x_069);
     }
     return debug
             (cst_grow,
              [0, t, 0],
              [0, -1011154630, capacity],
              function(param){
               var v_068 = param[2];
               return [1,
                       [0, _aB_, [0, caml_call2(Core[454], Core[356], v_068), 0]]];
              },
              _a$_,
              _a__);
    }
    function is_full(t){
     function _a8_(param){return caml_call1(Pool[14], t);}
     var _a9_ = Core[305];
     return debug
             (cst_is_full,
              [0, t, 0],
              t,
              function(x_070){
               return caml_call2
                       (sexp_of_t$1, function(param){return _aC_;}, x_070);
              },
              _a9_,
              _a8_);
    }
    function unsafe_free(t, p){
     function _a6_(param){return caml_call2(Pool[16], t, p);}
     var _a7_ = Core[518];
     return debug
             (cst_unsafe_free,
              [0, t, 0],
              p,
              function(x_071){
               return caml_call2
                       (sexp_of_t, function(param){return _aD_;}, x_071);
              },
              _a7_,
              _a6_);
    }
    function free(t, p){
     function _a4_(param){return caml_call2(Pool[15], t, p);}
     var _a5_ = Core[518];
     return debug
             (cst_free,
              [0, t, 0],
              p,
              function(x_072){
               return caml_call2
                       (sexp_of_t, function(param){return _aE_;}, x_072);
              },
              _a5_,
              _a4_);
    }
    function debug_new(t, f){
     function _a3_(x_073){
      return caml_call2(sexp_of_t, function(param){return _aF_;}, x_073);
     }
     return debug(cst_new, [0, t, 0], 0, Core[518], _a3_, f);
    }
    function new1(t, a0){
     return debug_new(t, function(param){return caml_call2(Pool[17], t, a0);});
    }
    function new2(t, a0, a1){
     return debug_new
             (t, function(param){return caml_call3(Pool[18], t, a0, a1);});
    }
    function new3(t, a0, a1, a2){
     return debug_new
             (t, function(param){return caml_call4(Pool[19], t, a0, a1, a2);});
    }
    function new4(t, a0, a1, a2, a3){
     return debug_new
             (t,
              function(param){return caml_call5(Pool[20], t, a0, a1, a2, a3);});
    }
    function new5(t, a0, a1, a2, a3, a4){
     return debug_new
             (t,
              function(param){
               return caml_call6(Pool[21], t, a0, a1, a2, a3, a4);
              });
    }
    function new6(t, a0, a1, a2, a3, a4, a5){
     return debug_new
             (t,
              function(param){
               return caml_call7(Pool[22], t, a0, a1, a2, a3, a4, a5);
              });
    }
    function new7(t, a0, a1, a2, a3, a4, a5, a6){
     return debug_new
             (t,
              function(param){
               return caml_call8(Pool[23], t, a0, a1, a2, a3, a4, a5, a6);
              });
    }
    function new8(t, a0, a1, a2, a3, a4, a5, a6, a7){
     return debug_new
             (t,
              function(param){
               return caml_call9(Pool[24], t, a0, a1, a2, a3, a4, a5, a6, a7);
              });
    }
    function new9(t, a0, a1, a2, a3, a4, a5, a6, a7, a8){
     return debug_new
             (t,
              function(param){
               return caml_call10
                       (Pool[25], t, a0, a1, a2, a3, a4, a5, a6, a7, a8);
              });
    }
    function new10(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
     return debug_new
             (t,
              function(param){
               return caml_call11
                       (Pool[26], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
              });
    }
    function new11(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
     return debug_new
             (t,
              function(param){
               return caml_call12
                       (Pool[27], t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
              });
    }
    function new12(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
     return debug_new
             (t,
              function(param){
               return caml_call13
                       (Pool[28],
                        t,
                        a0,
                        a1,
                        a2,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8,
                        a9,
                        a10,
                        a11);
              });
    }
    function new13(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
     return debug_new
             (t,
              function(param){
               return caml_call14
                       (Pool[29],
                        t,
                        a0,
                        a1,
                        a2,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12);
              });
    }
    function new14
    (t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
     return debug_new
             (t,
              function(param){
               return caml_call15
                       (Pool[30],
                        t,
                        a0,
                        a1,
                        a2,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13);
              });
    }
    function get_tuple(t, pointer){
     function _a1_(param){return caml_call2(Pool[31], t, pointer);}
     function _a2_(param){return _aG_;}
     return debug
             (cst_get_tuple,
              [0, t, 0],
              pointer,
              function(x_074){
               return caml_call2
                       (sexp_of_t, function(param){return _aH_;}, x_074);
              },
              _a2_,
              _a1_);
    }
    function debug_get(name, f, t, pointer){
     function _aZ_(param){return caml_call2(f, t, pointer);}
     function _a0_(param){return _aI_;}
     return debug
             (name,
              [0, t, 0],
              pointer,
              function(x_075){
               return caml_call2
                       (sexp_of_t, function(param){return _aJ_;}, x_075);
              },
              _a0_,
              _aZ_);
    }
    function get(t, pointer, slot){
     return caml_call1(debug_get(cst_get, Pool[32], t, pointer), slot);
    }
    function unsafe_get(t, pointer, slot){
     return caml_call1(debug_get(cst_unsafe_get, Pool[33], t, pointer), slot);
    }
    function debug_set(name, f, t, pointer, slot, a){
     function _aX_(param){return caml_call4(f, t, pointer, slot, a);}
     var _aY_ = Core[518];
     return debug
             (name,
              [0, t, 0],
              pointer,
              function(x_076){
               return caml_call2
                       (sexp_of_t, function(param){return _aK_;}, x_076);
              },
              _aY_,
              _aX_);
    }
    function set(t, pointer, slot, a){
     return debug_set(cst_set, Pool[34], t, pointer, slot, a);
    }
    function unsafe_set(t, pointer, slot, a){
     return debug_set(cst_unsafe_set, Pool[35], t, pointer, slot, a);
    }
    return [0,
            Slots,
            Slot,
            [0,
             sexp_of_t,
             typerep_of_t,
             typename_of_t,
             null$0,
             is_null,
             phys_compare,
             phys_equal,
             [0,
              bin_size_t,
              bin_write_t,
              bin_read_t$0,
              bin_read_t,
              bin_shape_t,
              bin_writer_t,
              bin_reader_t,
              bin_t,
              t_of_sexp,
              sexp_of_t$0,
              to_int63,
              of_int63]],
            sexp_of_t$1,
            invariant,
            pointer_is_valid,
            id_of_pointer,
            pointer_of_id_exn,
            create,
            max_capacity,
            capacity,
            length,
            grow,
            is_full,
            free,
            unsafe_free,
            new1,
            new2,
            new3,
            new4,
            new5,
            new6,
            new7,
            new8,
            new9,
            new10,
            new11,
            new12,
            new13,
            new14,
            get_tuple,
            get,
            unsafe_get,
            set,
            unsafe_set,
            check_invariant,
            show_messages];
   }
   var
    Tuple_pool =
      [0,
       Tuple_pool_Tuple_type[1],
       Slot,
       [0,
        sexp_of_t$1,
        typerep_of_t,
        typename_of_t,
        null$0,
        is_null,
        phys_compare,
        phys_equal,
        _s_],
       sexp_of_t$3,
       invariant$1,
       pointer_is_valid,
       id_of_pointer,
       pointer_of_id_exn,
       create$0,
       max_capacity,
       capacity$1,
       length$1,
       grow,
       is_full,
       free,
       unsafe_free,
       new1,
       new2,
       new3,
       new4,
       new5,
       new6,
       new7,
       new8,
       new9,
       new10,
       new11,
       new12,
       new13,
       new14,
       get_tuple,
       get,
       unsafe_get,
       set,
       unsafe_set,
       [0,
        Tuple_pool_Tuple_type[1],
        Slot,
        [0,
         sexp_of_t$1,
         typerep_of_t,
         typename_of_t,
         null$0,
         is_null,
         phys_compare,
         phys_equal,
         _s_],
        sexp_of_t$3,
        invariant$1,
        pointer_is_valid,
        id_of_pointer,
        pointer_of_id_exn,
        max_capacity,
        capacity$1,
        length$1,
        grow,
        is_full,
        free,
        unsafe_free,
        new1,
        new2,
        new3,
        new4,
        new5,
        new6,
        new7,
        new8,
        new9,
        new10,
        new11,
        new12,
        new13,
        new14,
        get_tuple,
        get,
        unsafe_get,
        set,
        unsafe_set,
        create$1],
       _aQ_,
       _aP_];
   runtime.caml_register_global(178, Tuple_pool, cst_Tuple_pool$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0dXBsZV9wb29sLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJ0MSIsInQyIiwidDMiLCJ0NCIsInQ1IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJ0MTAiLCJ0MTEiLCJ0MTIiLCJ0MTMiLCJ0MTQiLCJzZXhwX29mX3QiLCJ2XzAwNiIsInNsb3RzX3Blcl90dXBsZV8wMDIiLCJhcmdfMDAzIiwiYm5kc18wMDEiLCJzZXhwX29mX3QkMCIsIm9mX3R1cGxlXzAwNyIsIm9mX3ZhcmlhbnRfMDA4Iiwic2xvdHNfcGVyX3R1cGxlIiwibiIsInNleHBfb2ZfdDEiLCJvZl9hMF8wMDkiLCJzZXhwX29mX3QyIiwib2ZfYTBfMDEwIiwib2ZfYTFfMDExIiwic2V4cF9vZl90MyIsIm9mX2EwXzAxMiIsIm9mX2ExXzAxMyIsIm9mX2EyXzAxNCIsInNleHBfb2ZfdDQiLCJvZl9hMF8wMTUiLCJvZl9hMV8wMTYiLCJvZl9hMl8wMTciLCJvZl9hM18wMTgiLCJzZXhwX29mX3Q1Iiwib2ZfYTBfMDE5Iiwib2ZfYTFfMDIwIiwib2ZfYTJfMDIxIiwib2ZfYTNfMDIyIiwib2ZfYTRfMDIzIiwic2V4cF9vZl90NiIsIm9mX2EwXzAyNCIsIm9mX2ExXzAyNSIsIm9mX2EyXzAyNiIsIm9mX2EzXzAyNyIsIm9mX2E0XzAyOCIsIm9mX2E1XzAyOSIsInNleHBfb2ZfdDciLCJvZl9hMF8wMzAiLCJvZl9hMV8wMzEiLCJvZl9hMl8wMzIiLCJvZl9hM18wMzMiLCJvZl9hNF8wMzQiLCJvZl9hNV8wMzUiLCJvZl9hNl8wMzYiLCJzZXhwX29mX3Q4Iiwib2ZfYTBfMDM3Iiwib2ZfYTFfMDM4Iiwib2ZfYTJfMDM5Iiwib2ZfYTNfMDQwIiwib2ZfYTRfMDQxIiwib2ZfYTVfMDQyIiwib2ZfYTZfMDQzIiwib2ZfYTdfMDQ0Iiwic2V4cF9vZl90OSIsIm9mX2EwXzA0NSIsIm9mX2ExXzA0NiIsIm9mX2EyXzA0NyIsIm9mX2EzXzA0OCIsIm9mX2E0XzA0OSIsIm9mX2E1XzA1MCIsIm9mX2E2XzA1MSIsIm9mX2E3XzA1MiIsIm9mX2E4XzA1MyIsInNleHBfb2ZfdDEwIiwib2ZfYTBfMDU0Iiwib2ZfYTFfMDU1Iiwib2ZfYTJfMDU2Iiwib2ZfYTNfMDU3Iiwib2ZfYTRfMDU4Iiwib2ZfYTVfMDU5Iiwib2ZfYTZfMDYwIiwib2ZfYTdfMDYxIiwib2ZfYThfMDYyIiwib2ZfYTlfMDYzIiwic2V4cF9vZl90MTEiLCJvZl9hMF8wNjQiLCJvZl9hMV8wNjUiLCJvZl9hMl8wNjYiLCJvZl9hM18wNjciLCJvZl9hNF8wNjgiLCJvZl9hNV8wNjkiLCJvZl9hNl8wNzAiLCJvZl9hN18wNzEiLCJvZl9hOF8wNzIiLCJvZl9hOV8wNzMiLCJvZl9hMTBfMDc0Iiwic2V4cF9vZl90MTIiLCJvZl9hMF8wNzUiLCJvZl9hMV8wNzYiLCJvZl9hMl8wNzciLCJvZl9hM18wNzgiLCJvZl9hNF8wNzkiLCJvZl9hNV8wODAiLCJvZl9hNl8wODEiLCJvZl9hN18wODIiLCJvZl9hOF8wODMiLCJvZl9hOV8wODQiLCJvZl9hMTBfMDg1Iiwib2ZfYTExXzA4NiIsInNleHBfb2ZfdDEzIiwib2ZfYTBfMDg3Iiwib2ZfYTFfMDg4Iiwib2ZfYTJfMDg5Iiwib2ZfYTNfMDkwIiwib2ZfYTRfMDkxIiwib2ZfYTVfMDkyIiwib2ZfYTZfMDkzIiwib2ZfYTdfMDk0Iiwib2ZfYThfMDk1Iiwib2ZfYTlfMDk2Iiwib2ZfYTEwXzA5NyIsIm9mX2ExMV8wOTgiLCJvZl9hMTJfMDk5Iiwic2V4cF9vZl90MTQiLCJvZl9hMF8xMDAiLCJvZl9hMV8xMDEiLCJvZl9hMl8xMDIiLCJvZl9hM18xMDMiLCJvZl9hNF8xMDQiLCJvZl9hNV8xMDUiLCJvZl9hNl8xMDYiLCJvZl9hN18xMDciLCJvZl9hOF8xMDgiLCJvZl9hOV8xMDkiLCJvZl9hMTBfMTEwIiwib2ZfYTExXzExMSIsIm9mX2ExMl8xMTIiLCJvZl9hMTNfMTEzIiwibmFtZSQxIiwicHJlZml4IiwibmFtZSQwIiwibmFtZSIsImZhaWx3aXRocyIsImFyY2hfc2l4dHlmb3VyIiwibnVtX2JpdHMiLCJtYXhfdmFsdWUiLCJ0b19zdHJpbmciLCJzcHJpbnRmIiwiY29uY2F0IiwibCIsIm1heF9zbG90Iiwib2Zfc2xvdHNfMDA3Iiwib2ZfYV8wMDgiLCJlcXVhbCIsInQwIiwiYXJyYXlfaW5kZXhfbnVtX2JpdHMiLCJtYXNrZWRfdHVwbGVfaWRfbnVtX2JpdHMiLCJtYXhfYXJyYXlfbGVuZ3RoIiwiaW52YXJpYW50IiwidCIsImluaXQiLCJvZl9pbnQiLCJpIiwiZXhhbXBsZXMiLCJ0dXBsZV9pZF9tYXNrIiwidHlwZW5hbWVfb2ZfdCIsInR5cGVyZXBfb2ZfdCIsIm9mX3Nsb3RzIiwibmFtZV9vZl90Iiwic2V4cF9vZl90JDEiLCJwaHlzX2VxdWFsIiwicGh5c19jb21wYXJlIiwibnVsbCQwIiwiaXNfbnVsbCIsImNyZWF0ZSIsImhlYWRlcl9pbmRleCIsInR1cGxlX2lkIiwiaGVhZGVyX2luZGV4X21hc2siLCJtYXNrZWRfdHVwbGVfaWQiLCJpbnZhcmlhbnQkMCIsInNsb3RfaW5kZXgiLCJzbG90IiwiZmlyc3Rfc2xvdF9pbmRleCIsInRvX2ludDYzIiwib2ZfaW50NjMiLCJudWxsJDEiLCJpc19udWxsJDAiLCJpc19mcmVlIiwiaXNfdXNlZCIsImlkIiwibWV0YWRhdGFfaW5kZXgiLCJzdGFydF9vZl90dXBsZXNfaW5kZXgiLCJtYXhfY2FwYWNpdHkiLCJkdW1teSIsInIiLCJmaXJzdF9mcmVlIiwic2V0X2ZpcnN0X2ZyZWUiLCJ2IiwibmV4dF9pZCIsInNldF9uZXh0X2lkIiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsImNhcGFjaXR5IiwiZHVtbXkkMCIsImZpcnN0X2ZyZWUkMCIsIm5leHRfaWQkMCIsImxlbmd0aCQwIiwiY2FwYWNpdHkkMCIsInNsb3RzX3Blcl90dXBsZSQwIiwiYXJyYXlfaW5kaWNlc19wZXJfdHVwbGUiLCJhcnJheV9sZW5ndGgiLCJ0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IiwidHVwbGVfbnVtIiwidHVwbGVfbnVtX3RvX2ZpcnN0X3Nsb3RfaW5kZXgiLCJtZXRhZGF0YSIsImxlbmd0aCQxIiwic2V4cF9vZl90JDMiLCJzZXhwX29mX3R5IiwiY2FwYWNpdHlfMDE4Iiwic2xvdHNfcGVyX3R1cGxlXzAxNiIsImxlbmd0aF8wMjAiLCJuZXh0X2lkXzAyMiIsImZpcnN0X2ZyZWVfMDI0IiwiZHVtbXlfMDI2IiwiYXJnXzAyNyIsImJuZHNfMDE1IiwiYXJnXzAyNSIsImJuZHNfMDE1JDAiLCJhcmdfMDIzIiwiYm5kc18wMTUkMSIsImFyZ18wMjEiLCJibmRzXzAxNSQyIiwiYXJnXzAxOSIsImJuZHNfMDE1JDMiLCJhcmdfMDE3IiwiYm5kc18wMTUkNCIsInVuc2FmZV9oZWFkZXIiLCJ1bnNhZmVfc2V0X2hlYWRlciIsImhlYWRlciIsImhlYWRlcl9pbmRleF9pc19pbl9ib3VuZHMiLCJ1bnNhZmVfcG9pbnRlcl9pc19saXZlIiwicG9pbnRlciIsImhlYWRlcl9pbmRleCQwIiwicG9pbnRlcl9pc192YWxpZCIsImlkX29mX3BvaW50ZXIiLCJpc192YWxpZF9oZWFkZXJfaW5kZXgiLCJtZXRhZGF0YSQwIiwicG9pbnRlcl9vZl9pZF9leG4iLCJ0JDIiLCJ0JDAiLCJzaG91bGRfZXF1YWwiLCJ0JDEiLCJ4XzAwOSIsImV4biQwIiwiZXhuIiwiYXJnMV8wMTEiLCJhcmcwXzAxMCIsInJlczBfMDEyIiwicmVzMV8wMTMiLCJhcmcyXzAzMCIsImFyZzFfMDI5IiwiYXJnMF8wMjgiLCJyZXMwXzAzMSIsInJlczFfMDMyIiwicmVzMl8wMzMiLCJpbnZhcmlhbnQkMSIsImludmFyaWFudF9hIiwiY2hlY2siLCJmIiwiZmllbGQiLCJmaXJzdF9zbG90IiwiZnJlZSIsImFyZzFfMDM1IiwiYXJnMF8wMzQiLCJyZXMwXzAzNiIsInJlczFfMDM3IiwiY2FwYWNpdHkkMSIsImlzX2Z1bGwiLCJ1bnNhZmVfYWRkX3RvX2ZyZWVfbGlzdCIsInNldF9tZXRhZGF0YSIsImNyZWF0ZV9hcnJheSIsInVuc2FmZV9pbml0X3JhbmdlIiwibG8iLCJoaSIsInR1cGxlX251bSQwIiwiY3JlYXRlX3dpdGhfZHVtbXkiLCJzbG90cyIsIm1heF9jYXBhY2l0eSQwIiwiYXJnMV8wNDAiLCJhcmcwXzAzOSIsInJlczBfMDQxIiwidl8wMzgiLCJyZXMxXzA0MiIsImNyZWF0ZSQwIiwiZ3JvdyIsIm9sZF9jYXBhY2l0eSIsImFyZzFfMDA0IiwiYXJnMF8wMDMiLCJ2XzAwMSIsInJlczBfMDA1Iiwidl8wMDIiLCJyZXMxXzAwNiIsIm1ldGFkYXRhJDIiLCJtZXRhZGF0YSQxIiwibWFsbG9jIiwieF8wNDMiLCJ1bnNhZmVfZnJlZSIsInBvcyIsImFyZzFfMDQ1IiwiYXJnMF8wNDQiLCJyZXMwXzA0NiIsInJlczFfMDQ3IiwibmV3MSIsImEwIiwib2Zmc2V0IiwibmV3MiIsImExIiwibmV3MyIsImEyIiwibmV3NCIsImEzIiwibmV3NSIsImE0IiwibmV3NiIsImE1IiwibmV3NyIsImE2IiwibmV3OCIsImE3IiwibmV3OSIsImE4IiwibmV3MTAiLCJhOSIsIm5ldzExIiwiYTEwIiwibmV3MTIiLCJhMTEiLCJuZXcxMyIsImExMiIsIm5ldzE0IiwiYTEzIiwiZ2V0IiwicCIsInVuc2FmZV9nZXQiLCJzZXQiLCJ4IiwidW5zYWZlX3NldCIsImdldF90dXBsZSIsImxlbiIsImNyZWF0ZSQxIiwib2Zfc2xvdHNfMDc3IiwiaXNfdmFsaWRfMDc5IiwicG9pbnRlcl8wODEiLCJhcmdfMDgyIiwiYm5kc18wNzgiLCJhcmdfMDgwIiwiYm5kc18wNzgkMCIsImZpZWxkMCIsImZpZWxkMSIsInR5cGVuYW1lIiwiaGFzX2RvdWJsZV9hcnJheV90YWciLCJmaWVsZHMiLCJpc192YWxpZCIsImZvbGxvdyIsInhfMDgzIiwiaW52YWxpZGF0ZSIsImNoZWNrX2ludmFyaWFudCIsInNob3dfbWVzc2FnZXMiLCJkZWJ1ZyIsInRzIiwiYXJnIiwic2V4cF9vZl9hcmciLCJzZXhwX29mX3Jlc3VsdCIsInJlc3VsdF9vcl9leG4iLCJ4XzA0OCIsImFyZzFfMDUyIiwiYXJnMF8wNTEiLCJyZXMwXzA1MyIsInJlczFfMDU0IiwiYXJnMV8wNTYiLCJhcmcwXzA1NSIsInJlczBfMDU3IiwicmVzMV8wNTgiLCJ4XzA1OSIsImdyb3VwIiwiYmluX3NoYXBlX3QiLCJiaW5fc2l6ZV90IiwiYmluX3dyaXRlX3QiLCJiaW5fd3JpdGVyX3QiLCJiaW5fcmVhZF90IiwiYmluX3JlYWRfdCQwIiwiYmluX3JlYWRlcl90IiwiYmluX3QiLCJ0X29mX3NleHAiLCJ4XzA2MyIsInhfMDY0IiwieF8wNjUiLCJ4XzA2NiIsInhfMDY3IiwieF8wNjkiLCJ2XzA2OCIsInhfMDcwIiwieF8wNzEiLCJ4XzA3MiIsImRlYnVnX25ldyIsInhfMDczIiwieF8wNzQiLCJkZWJ1Z19nZXQiLCJ4XzA3NSIsImRlYnVnX3NldCIsImEiLCJ4XzA3NiJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvY29yZV9rZXJuZWwvdHVwbGVfcG9vbC90dXBsZV90eXBlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9jb3JlX2tlcm5lbC90dXBsZV9wb29sL3R1cGxlX3Bvb2wubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lBbUNNQTtJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQzs7Ozs7Ozs7Ozs7Ozs7OztZQXpDSkM7SUFBQTtLQUFVQztLQUZFQyxzQkFFRkQ7S0FGRUUsVUFBQSxzQkFBQUQ7S0FBWkUsZ0NBQVlEO2dDQUFaQztHQUUrQztZQUMvQ0MsWUFBTUMsY0FBUUMsZ0JBQWQsT0FEQVAsVUFDbUQ7WUFFL0NRLDJCQUE0Q0MsaUJBQU8sT0FBUEE7WUFFaERDLFdBQUtDLFdBQUwsT0FMQVgsVUFLcUM7WUFDckNZLFdB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ekU7WUFLQWtCO1lBS0FVO1lBMUNBRjtZQThDQThGO1lBVUFqQjtZQVNBTjtZQUxBbUM7WUFVQU07WUFDQUc7WUFDQUU7WUFDQUU7WUFDQUU7WUFDQUU7WUFDQUU7WUFFQUU7WUFJQUU7WUFJQUU7WUFJQUU7WUFJQUU7WUFJQUU7WUFJQUU7WUFJQVE7WUFTQU47WUFDQUU7WUFPQUM7WUFDQUU7WUFuTUFvQjtZQUNBQzs7Ozs7Ozs7UUE1dEJFdE07UUFGSkg7UUFBQUQ7UUFLSU87UUFDQUM7UUFGQUY7UUFEQUQ7O09Bc0xGOEM7T0E2REFpRDtPQXJDQXRCO09BUUFDO09BVUFHO09BMElBOEM7T0FqUEFyRztPQTZLQW9GO09BakhBN0Q7T0FpT08rRTtPQS9HUGpCO09BbU1BTjtPQW5CQW1DO09Ba0NBTTtPQU9BRztPQVFBRTtPQVNBRTtPQVVBRTtPQVdBRTtPQVlBRTtPQWFBRTtPQWNBRTtPQWVBRTtPQWdCQUU7T0FpQkFFO09Ba0JBRTtPQW1CQUU7T0FnQ0FRO09BWkFOO09BRUFFO09BSUFDO09BRUFFOzs7OztTQS9yQkVqTDtTQUZKSDtTQUFBRDtTQUtJTztTQUNBQztTQUZBRjtTQURBRDs7UUFzTEY4QztRQTZEQWlEO1FBckNBdEI7UUFRQUM7UUFVQUc7UUF2R0F2RDtRQTZLQW9GO1FBakhBN0Q7UUFpT08rRTtRQS9HUGpCO1FBbU1BTjtRQW5CQW1DO1FBa0NBTTtRQU9BRztRQVFBRTtRQVNBRTtRQVVBRTtRQVdBRTtRQVlBRTtRQWFBRTtRQWNBRTtRQWVBRTtRQWdCQUU7UUFpQkFFO1FBa0JBRTtRQW1CQUU7UUFnQ0FRO1FBWkFOO1FBRUFFO1FBSUFDO1FBRUFFO1FBc0JBRzs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUdXBsZV90eXBlX2ludGZcblxubW9kdWxlIFNsb3RzID0gc3RydWN0XG4gIHR5cGUgdV8gPSB7IHNsb3RzX3Blcl90dXBsZSA6IGludCB9IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgKCd0dXBsZSwgJ3ZhcmlhbnQpIHUgPSB1XyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlIHRfID0gWyBgU2xvdHMgb2YgdV8gXSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICgndHVwbGUsICd2YXJpYW50KSB0ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgc2xvdHNfcGVyX3R1cGxlIChgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSBuIH0pID0gblxuXG4gIHR5cGUgJ2EwIHQxID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEpIHQyID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMikgdDMgPSB0XyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICgnYTAsICdhMSwgJ2EyLCAnYTMpIHQ0ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQpIHQ1ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSkgdDYgPSB0XyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICgnYTAsICdhMSwgJ2EyLCAnYTMsICdhNCwgJ2E1LCAnYTYpIHQ3ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcpIHQ4ID0gdF8gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcsICdhOCkgdDkgPSB0XyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICgnYTAsICdhMSwgJ2EyLCAnYTMsICdhNCwgJ2E1LCAnYTYsICdhNywgJ2E4LCAnYTkpIHQxMCA9IHRfIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcsICdhOCwgJ2E5LCAnYTEwKSB0MTEgPSB0X1xuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgKCdhMCwgJ2ExLCAnYTIsICdhMywgJ2E0LCAnYTUsICdhNiwgJ2E3LCAnYTgsICdhOSwgJ2ExMCwgJ2ExMSkgdDEyID0gdF9cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICgnYTAsICdhMSwgJ2EyLCAnYTMsICdhNCwgJ2E1LCAnYTYsICdhNywgJ2E4LCAnYTksICdhMTAsICdhMTEsICdhMTIpIHQxMyA9IHRfXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSAoJ2EwLCAnYTEsICdhMiwgJ2EzLCAnYTQsICdhNSwgJ2E2LCAnYTcsICdhOCwgJ2E5LCAnYTEwLCAnYTExLCAnYTEyLCAnYTEzKSB0MTQgPSB0X1xuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCB0MSA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDEgfVxuICBsZXQgdDIgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAyIH1cbiAgbGV0IHQzID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gMyB9XG4gIGxldCB0NCA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDQgfVxuICBsZXQgdDUgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSA1IH1cbiAgbGV0IHQ2ID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gNiB9XG4gIGxldCB0NyA9IGBTbG90cyB7IHNsb3RzX3Blcl90dXBsZSA9IDcgfVxuICBsZXQgdDggPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSA4IH1cbiAgbGV0IHQ5ID0gYFNsb3RzIHsgc2xvdHNfcGVyX3R1cGxlID0gOSB9XG4gIGxldCB0MTAgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxMCB9XG4gIGxldCB0MTEgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxMSB9XG4gIGxldCB0MTIgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxMiB9XG4gIGxldCB0MTMgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxMyB9XG4gIGxldCB0MTQgPSBgU2xvdHMgeyBzbG90c19wZXJfdHVwbGUgPSAxNCB9XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiBUdXBsZV9wb29sX2ludGZcbm1vZHVsZSBUdXBsZV90eXBlID0gVHVwbGVfdHlwZVxuXG5sZXQgZmFpbHdpdGhzID0gRXJyb3IuZmFpbHdpdGhzXG5sZXQgcGh5c19lcXVhbCA9IENhbWwuKCA9PSApXG5sZXQgYXJjaF9zaXh0eWZvdXIgPSBTeXMud29yZF9zaXplX2luX2JpdHMgPSA2NFxuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIGxldCBudW1fYml0cyA9IEludC5udW1fYml0c1xuICBsZXQgbWF4X3ZhbHVlID0gQ2FtbC5tYXhfaW50XG4gIGxldCB0b19zdHJpbmcgPSBzdHJpbmdfb2ZfaW50XG5lbmRcblxubGV0IHNwcmludGYgPSBQcmludGYuc3ByaW50ZlxubGV0IGNvbmNhdCBsID0gQmFzZS5TdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBsXG5cbm1vZHVsZSB0eXBlIFMgPSBTXG5cbm1vZHVsZSBQb29sID0gc3RydWN0XG4gIGxldCBncm93X2NhcGFjaXR5IH5jYXBhY2l0eSB+b2xkX2NhcGFjaXR5ID1cbiAgICBtYXRjaCBjYXBhY2l0eSB3aXRoXG4gICAgfCBOb25lIC0+IGlmIG9sZF9jYXBhY2l0eSA9IDAgdGhlbiAxIGVsc2Ugb2xkX2NhcGFjaXR5ICogMlxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPD0gb2xkX2NhcGFjaXR5XG4gICAgICB0aGVuXG4gICAgICAgIGZhaWx3aXRoc1xuICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICBcIlBvb2wuZ3JvdyBnb3QgdG9vIHNtYWxsIGNhcGFjaXR5XCJcbiAgICAgICAgICAoYGNhcGFjaXR5IGNhcGFjaXR5LCBgb2xkX2NhcGFjaXR5IG9sZF9jYXBhY2l0eSlcbiAgICAgICAgICBbJXNleHBfb2Y6IFsgYGNhcGFjaXR5IG9mIGludCBdICogWyBgb2xkX2NhcGFjaXR5IG9mIGludCBdXTtcbiAgICAgIGNhcGFjaXR5XG4gIDs7XG5cbiAgbW9kdWxlIFNsb3RzID0gVHVwbGVfdHlwZS5TbG90c1xuXG4gIGxldCBtYXhfc2xvdCA9IDE0XG5cbiAgKCogVGhlIHBvb2wgaXMgcmVwcmVzZW50ZWQgYXMgYSBzaW5nbGUgW1VuaWZvcm1fYXJyYXkudF0sIHdoZXJlIGluZGV4IHplcm8gaGFzIHRoZVxuICAgICBtZXRhZGF0YSBhYm91dCB0aGUgcG9vbCBhbmQgdGhlIHJlbWFpbmluZyBpbmRpY2VzIGFyZSB0aGUgdHVwbGVzIGxheWVkIG91dCBvbmUgYWZ0ZXJcbiAgICAgdGhlIG90aGVyLiAgRWFjaCB0dXBsZSB0YWtlcyBbMSArIHNsb3RzX3Blcl90dXBsZV0gaW5kaWNlcyBpbiB0aGUgcG9vbCwgd2hlcmUgdGhlXG4gICAgIGZpcnN0IGluZGV4IGhvbGRzIGEgaGVhZGVyIGFuZCB0aGUgcmVtYWluaW5nIGluZGljZXMgaG9sZCB0aGUgdHVwbGUncyBzbG90czpcblxuICAgICB7dlxuICAgICB8IGhlYWRlciB8IHMwIHwgczEgfCAuLi4gfCBzPE4tMT4gfFxuICAgICB2fVxuXG4gICAgIEEgW1BvaW50ZXIudF0gdG8gYSB0dXBsZSBjb250YWlucyB0aGUgaW50ZWdlciBpbmRleCB3aGVyZSBpdHMgaGVhZGVyIGlzLCBhcyB3ZWxsIGFzXG4gICAgIChhIG1hc2sgb2YpIHRoZSB0dXBsZSdzIHVuaXF1ZSBpZC5cblxuICAgICBUaGUgZnJlZSB0dXBsZXMgYXJlIHNpbmdseSBsaW5rZWQgdmlhIHRoZSBoZWFkZXJzLlxuXG4gICAgIFdoZW4gYSB0dXBsZSBpcyBpbiB1c2UsIGl0cyBoZWFkZXIgaXMgbWFya2VkIHRvIGluZGljYXRlIHNvLCBhbmQgYWxzbyB0byBpbmNsdWRlIHRoZVxuICAgICB0dXBsZSdzIHVuaXF1ZSBpZC4gIFRoaXMgYWxsb3dzIHVzIHRvIGNoZWNrIGluIGNvbnN0YW50IHRpbWUgd2hldGhlciBhIHBvaW50ZXIgaXNcbiAgICAgdmFsaWQsIGJ5IGNvbXBhcmluZyB0aGUgaWQgaW4gdGhlIHBvaW50ZXIgd2l0aCB0aGUgaWQgaW4gdGhlIGhlYWRlci5cblxuICAgICBXaGVuIGEgdHVwbGUgaXMgbm90IGluIHVzZSwgaXRzIGhlYWRlciBpcyBwYXJ0IG9mIHRoZSBmcmVlIGxpc3QsIGFuZCBpdHMgdHVwbGUgc2xvdHNcbiAgICAgaGF2ZSBkdW1teSB2YWx1ZXMgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzLCBmcm9tIHRoZSBbZHVtbXldIHR1cGxlIHN1cHBsaWVkIHRvXG4gICAgIFtjcmVhdGVdLiAgV2UgbXVzdCBoYXZlIGR1bW15IHZhbHVlcyBvZiB0aGUgY29ycmVjdCB0eXBlIHRvIHByZXZlbnQgYSBzZWdmYXVsdCBpblxuICAgICBjb2RlIHRoYXQgKG1pc3Rha2VubHkpIHVzZXMgYSBwb2ludGVyIHRvIGEgZnJlZSB0dXBsZS5cblxuICAgICBGb3IgW1Bvb2wuVW5zYWZlXSwgYSBzbG90IGluIGEgZnJlZSBvYmplY3QgaXMgZ3VhcmFudGVlZCB0byBiZSBhbiBpbnQ7IGl0IG11c3Qgbm90IGJlXG4gICAgIHBvaW50ZXIgdG8gcHJldmVudCBhIHNwYWNlIGxlYWsuICBIb3dldmVyLCB0aGUgaW50IGluIHRoZSBzbG90IG1heSBub3QgcmVwcmVzZW50IGFcbiAgICAgdmFsaWQgdmFsdWUgb2YgdGhlIHR5cGUuXG4gICopXG5cbiAgbW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgICB0eXBlICgnc2xvdHMsICdhKSB0ID0gaW50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWwgKHQxIDogKF8sIF8pIHQpIHQyID0gdDEgPSB0MlxuICAgIGxldCB0MCA9IDFcbiAgICBsZXQgdDEgPSAyXG4gICAgbGV0IHQyID0gM1xuICAgIGxldCB0MyA9IDRcbiAgICBsZXQgdDQgPSA1XG4gICAgbGV0IHQ1ID0gNlxuICAgIGxldCB0NiA9IDdcbiAgICBsZXQgdDcgPSA4XG4gICAgbGV0IHQ4ID0gOVxuICAgIGxldCB0OSA9IDEwXG4gICAgbGV0IHQxMCA9IDExXG4gICAgbGV0IHQxMSA9IDEyXG4gICAgbGV0IHQxMiA9IDEzXG4gICAgbGV0IHQxMyA9IDE0XG5cbiAgICBsZXQldGVzdCBfID0gdDEzID0gbWF4X3Nsb3RcbiAgZW5kXG5cbiAgKCogV2Ugb25seSBoYXZlIFtJbnQubnVtX2JpdHNdIGJpdHMgYXZhaWxhYmxlIGZvciBwb29sIHBvaW50ZXJzLiAgVGhlIGJpdHMgb2YgYSBwb29sXG4gICAgIHBvaW50ZXIgZW5jb2RlIHR3byB0aGluZ3M6XG5cbiAgICAgLSB0aGUgdHVwbGUncyBhcnJheSBpbmRleCBpbiB0aGUgcG9vbFxuICAgICAtIHRoZSB0dXBsZSdzIGlkZW50aWZpZXIgKG5vdCBuZWNlc3NhcmlseSB1bmlxdWUpXG5cbiAgICAgV2UgY2hvb3NlIFthcnJheV9pbmRleF9udW1fYml0c10gYXMgbGFyZ2UgYXMgbmVlZGVkIGZvciB0aGUgbWF4aW11bSBwb29sIGNhcGFjaXR5XG4gICAgIHRoYXQgd2Ugd2FudCB0byBzdXBwb3J0LCBhbmQgdXNlIHRoZSByZW1haW5pbmcgW21hc2tlZF90dXBsZV9pZF9udW1fYml0c10gYml0cyBmb3JcbiAgICAgdGhlIGlkZW50aWZpZXIuICA2NC1iaXQgYW5kIDMyLWJpdCBhcmNoaXRlY3R1cmVzIHR5cGljYWxseSBoYXZlIHZlcnkgZGlmZmVyZW50XG4gICAgIGFkZHJlc3Mtc3BhY2Ugc2l6ZXMsIHNvIHdlIGNob29zZSBbYXJyYXlfaW5kZXhfbnVtX2JpdHNdIGRpZmZlcmVudGx5LiAqKVxuXG4gIGxldCBhcnJheV9pbmRleF9udW1fYml0cyA9XG4gICAgaWYgYXJjaF9zaXh0eWZvdXJcbiAgICB0aGVuIChcbiAgICAgIGFzc2VydCAoSW50Lm51bV9iaXRzID0gNjMpO1xuICAgICAgMzApXG4gICAgZWxzZSAoXG4gICAgICBhc3NlcnQgKEludC5udW1fYml0cyA9IDMxIHx8IEludC5udW1fYml0cyA9IDMyKTtcbiAgICAgIDIyKVxuICA7O1xuXG4gIGxldCBtYXNrZWRfdHVwbGVfaWRfbnVtX2JpdHMgPSBJbnQubnVtX2JpdHMgLSBhcnJheV9pbmRleF9udW1fYml0c1xuXG4gIGxldCV0ZXN0IF8gPSBhcnJheV9pbmRleF9udW1fYml0cyA+IDBcbiAgbGV0JXRlc3QgXyA9IG1hc2tlZF90dXBsZV9pZF9udW1fYml0cyA+IDBcbiAgbGV0JXRlc3QgXyA9IGFycmF5X2luZGV4X251bV9iaXRzICsgbWFza2VkX3R1cGxlX2lkX251bV9iaXRzIDw9IEludC5udW1fYml0c1xuXG4gIGxldCBtYXhfYXJyYXlfbGVuZ3RoID0gMSBsc2wgYXJyYXlfaW5kZXhfbnVtX2JpdHNcblxuICBtb2R1bGUgVHVwbGVfaWQgOiBzaWdcbiAgICB0eXBlIHQgPSBwcml2YXRlIGludCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpbml0IDogdFxuICAgIHZhbCBuZXh0IDogdCAtPiB0XG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gICAgdmFsIGV4YW1wbGVzIDogdCBsaXN0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgKCogV2UgZ3VhcmFudGVlIHRoYXQgdHVwbGUgaWRzIGFyZSBub25uZWdhdGl2ZSBzbyB0aGF0IHRoZXkgY2FuIGJlIGVuY29kZWQgaW5cbiAgICAgICBoZWFkZXJzLiAqKVxuICAgIGxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAodCA+PSAwKVxuICAgIGxldCB0b19zdHJpbmcgPSBJbnQudG9fc3RyaW5nXG4gICAgbGV0IGVxdWFsICh0MSA6IHQpIHQyID0gdDEgPSB0MlxuICAgIGxldCBpbml0ID0gMFxuICAgIGxldCBuZXh0IHQgPSBpZiBhcmNoX3NpeHR5Zm91ciB0aGVuIHQgKyAxIGVsc2UgaWYgdCA9IEludC5tYXhfdmFsdWUgdGhlbiAwIGVsc2UgdCArIDFcbiAgICBsZXQgdG9faW50IHQgPSB0XG5cbiAgICBsZXQgb2ZfaW50IGkgPVxuICAgICAgaWYgaSA8IDBcbiAgICAgIHRoZW4gZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJUdXBsZV9pZC5vZl9pbnQgZ290IG5lZ2F0aXZlIGludFwiIGkgWyVzZXhwX29mOiBpbnRdO1xuICAgICAgaVxuICAgIDs7XG5cbiAgICBsZXQgZXhhbXBsZXMgPSBbIDA7IDE7IDB4MUZGRl9GRkZGOyBJbnQubWF4X3ZhbHVlIF1cbiAgZW5kXG5cbiAgbGV0IHR1cGxlX2lkX21hc2sgPSAoMSBsc2wgbWFza2VkX3R1cGxlX2lkX251bV9iaXRzKSAtIDFcblxuICBtb2R1bGUgUG9pbnRlciA6IHNpZ1xuICAgICgqIFtQb2ludGVyLnRdIGlzIGFuIGVuY29kaW5nIGFzIGFuIFtpbnRdIG9mIHRoZSBmb2xsb3dpbmcgc3VtIHR5cGU6XG5cbiAgICAgICB7W1xuICAgICAgICAgfCBOdWxsXG4gICAgICAgICB8IE5vcm1hbCBvZiB7IGhlYWRlcl9pbmRleCA6IGludDsgbWFza2VkX3R1cGxlX2lkIDogaW50IH1cbiAgICAgICBdfVxuXG4gICAgICAgVGhlIGVuY29kaW5nIGlzIGNob3NlbiB0byBvcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gb3BlcmF0aW9uLCBuYW1lbHkgdHVwbGUtc2xvdFxuICAgICAgIGFjY2VzcywgdGhlIFtzbG90X2luZGV4XSBmdW5jdGlvbi4gIFRoZSBlbmNvZGluZyBpcyBkZXNpZ25lZCBzbyB0aGF0IFtzbG90X2luZGV4XVxuICAgICAgIHByb2R1Y2VzIGEgbmVnYXRpdmUgbnVtYmVyIGZvciBbTnVsbF0sIHdoaWNoIHdpbGwgY2F1c2UgdGhlIHN1YnNlcXVlbnQgYXJyYXkgYm91bmRzXG4gICAgICAgY2hlY2sgdG8gZmFpbC4gKilcblxuICAgIHR5cGUgJ3Nsb3RzIHQgPSBwcml2YXRlIGludCBbQEBkZXJpdmluZyBzZXhwX29mLCB0eXBlcmVwXVxuXG4gICAgaW5jbHVkZSBJbnZhcmlhbnQuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIHBoeXNfY29tcGFyZSA6ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgcGh5c19lcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgICAoKiBUaGUgbnVsbCBwb2ludGVyLiAgW251bGxdIGlzIGEgZnVuY3Rpb24gZHVlIHRvIGlzc3VlcyB3aXRoIHRoZSB2YWx1ZSByZXN0cmljdGlvbi4gKilcblxuICAgIHZhbCBudWxsIDogdW5pdCAtPiBfIHRcbiAgICB2YWwgaXNfbnVsbCA6IF8gdCAtPiBib29sXG5cbiAgICAoKiBOb3JtYWwgcG9pbnRlcnMuICopXG5cbiAgICB2YWwgY3JlYXRlIDogaGVhZGVyX2luZGV4OmludCAtPiBUdXBsZV9pZC50IC0+IF8gdFxuICAgIHZhbCBoZWFkZXJfaW5kZXggOiBfIHQgLT4gaW50XG4gICAgdmFsIG1hc2tlZF90dXBsZV9pZCA6IF8gdCAtPiBpbnRcbiAgICB2YWwgc2xvdF9pbmRleCA6IF8gdCAtPiAoXywgXykgU2xvdC50IC0+IGludFxuICAgIHZhbCBmaXJzdF9zbG90X2luZGV4IDogXyB0IC0+IGludFxuXG4gICAgbW9kdWxlIElkIDogc2lnXG4gICAgICB0eXBlIHQgW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG4gICAgICB2YWwgdG9faW50NjMgOiB0IC0+IEludDYzLnRcbiAgICAgIHZhbCBvZl9pbnQ2MyA6IEludDYzLnQgLT4gdFxuICAgIGVuZFxuXG4gICAgdmFsIHRvX2lkIDogXyB0IC0+IElkLnRcbiAgICB2YWwgb2ZfaWRfZXhuIDogSWQudCAtPiBfIHRcbiAgZW5kID0gc3RydWN0XG4gICAgKCogQSBwb2ludGVyIGlzIGVpdGhlciBbbnVsbF0gb3IgdGhlIChwb3NpdGl2ZSkgaW5kZXggaW4gdGhlIHBvb2wgb2YgdGhlIG5leHQtZnJlZVxuICAgICAgIGZpZWxkIHByZWNlZWRpbmcgdGhlIHR1cGxlJ3Mgc2xvdHMuICopXG4gICAgdHlwZSAnc2xvdHMgdCA9IGludCBbQEBkZXJpdmluZyB0eXBlcmVwXVxuXG4gICAgbGV0IHNleHBfb2ZfdCBfIHQgPSBTZXhwLkF0b20gKHNwcmludGYgXCI8UG9vbC5Qb2ludGVyLnQ6IDB4JTA4eD5cIiB0KVxuICAgIGxldCBwaHlzX2VxdWFsICh0MSA6IF8gdCkgdDIgPSBwaHlzX2VxdWFsIHQxIHQyXG4gICAgbGV0IHBoeXNfY29tcGFyZSA9IGNvbXBhcmVcbiAgICBsZXQgbnVsbCAoKSA9IC1tYXhfc2xvdCAtIDFcbiAgICBsZXQgaXNfbnVsbCB0ID0gcGh5c19lcXVhbCB0IChudWxsICgpKVxuXG4gICAgKCogW251bGxdIG11c3QgYmUgc3VjaCB0aGF0IFtudWxsICsgc2xvdF0gaXMgYW4gaW52YWxpZCBhcnJheSBpbmRleCBmb3IgYWxsIHNsb3RzLlxuICAgICAgIE90aGVyd2lzZSBnZXQvc2V0IG9uIHRoZSBudWxsIHBvaW50ZXIgbWF5IGxlYWQgdG8gYSBzZWdmYXVsdC4gKilcbiAgICBsZXQldGVzdCBfID0gbnVsbCAoKSArIG1heF9zbG90IDwgMFxuXG4gICAgbGV0IGNyZWF0ZSB+aGVhZGVyX2luZGV4ICh0dXBsZV9pZCA6IFR1cGxlX2lkLnQpID1cbiAgICAgIGhlYWRlcl9pbmRleFxuICAgICAgbG9yICgoVHVwbGVfaWQudG9faW50IHR1cGxlX2lkIGxhbmQgdHVwbGVfaWRfbWFzaykgbHNsIGFycmF5X2luZGV4X251bV9iaXRzKVxuICAgIDs7XG5cbiAgICBsZXQgaGVhZGVyX2luZGV4X21hc2sgPSAoMSBsc2wgYXJyYXlfaW5kZXhfbnVtX2JpdHMpIC0gMVxuICAgIGxldCBtYXNrZWRfdHVwbGVfaWQgdCA9IHQgbHNyIGFycmF5X2luZGV4X251bV9iaXRzXG4gICAgbGV0IGhlYWRlcl9pbmRleCB0ID0gdCBsYW5kIGhlYWRlcl9pbmRleF9tYXNrXG4gICAgbGV0IGludmFyaWFudCBfIHQgPSBpZiBub3QgKGlzX251bGwgdCkgdGhlbiBhc3NlcnQgKGhlYWRlcl9pbmRleCB0ID4gMClcblxuICAgIGxldCV0ZXN0X3VuaXQgXyA9IGludmFyaWFudCBpZ25vcmUgKG51bGwgKCkpXG5cbiAgICBsZXQldGVzdF91bml0IF8gPVxuICAgICAgTGlzdC5pdGVyIFR1cGxlX2lkLmV4YW1wbGVzIH5mOihmdW4gdHVwbGVfaWQgLT5cbiAgICAgICAgaW52YXJpYW50IGlnbm9yZSAoY3JlYXRlIH5oZWFkZXJfaW5kZXg6MSB0dXBsZV9pZCkpXG4gICAgOztcblxuICAgIGxldCBzbG90X2luZGV4IHQgc2xvdCA9IGhlYWRlcl9pbmRleCB0ICsgc2xvdFxuICAgIGxldCBmaXJzdF9zbG90X2luZGV4IHQgPSBzbG90X2luZGV4IHQgU2xvdC50MFxuXG4gICAgbW9kdWxlIElkID0gc3RydWN0XG4gICAgICBpbmNsdWRlIEludDYzXG5cbiAgICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgICAgbGV0IG9mX2ludDYzIGkgPSBpXG4gICAgZW5kXG5cbiAgICBsZXQgdG9faWQgdCA9IElkLm9mX2ludCB0XG5cbiAgICBsZXQgb2ZfaWRfZXhuIGlkID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgdCA9IElkLnRvX2ludF9leG4gaWQgaW5cbiAgICAgICAgaWYgaXNfbnVsbCB0XG4gICAgICAgIHRoZW4gdFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgc2hvdWxkX2VxdWFsID1cbiAgICAgICAgICAgIGNyZWF0ZSB+aGVhZGVyX2luZGV4OihoZWFkZXJfaW5kZXggdCkgKFR1cGxlX2lkLm9mX2ludCAobWFza2VkX3R1cGxlX2lkIHQpKVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgcGh5c19lcXVhbCB0IHNob3VsZF9lcXVhbFxuICAgICAgICAgIHRoZW4gdFxuICAgICAgICAgIGVsc2UgZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJzaG91bGQgZXF1YWxcIiBzaG91bGRfZXF1YWwgWyVzZXhwX29mOiBfIHRdKVxuICAgICAgd2l0aFxuICAgICAgfCBleG4gLT5cbiAgICAgICAgZmFpbHdpdGhzXG4gICAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICAgIFwiUG9pbnRlci5vZl9pZF9leG4gZ290IHN0cmFuZ2UgaWRcIlxuICAgICAgICAgIChpZCwgZXhuKVxuICAgICAgICAgIFslc2V4cF9vZjogSWQudCAqIGV4bl1cbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgSGVhZGVyIDogc2lnXG4gICAgKCogQSBbSGVhZGVyLnRdIGlzIGFuIGVuY29kaW5nIGFzIGFuIFtpbnRdIG9mIHRoZSBmb2xsb3dpbmcgdHlwZTpcblxuICAgICAgIHtbXG4gICAgICAgICB8IE51bGxcbiAgICAgICAgIHwgRnJlZSBvZiB7IG5leHRfZnJlZV9oZWFkZXJfaW5kZXggOiBpbnQgfVxuICAgICAgICAgfCBVc2VkIG9mIHsgdHVwbGVfaWQgOiBpbnQgfVxuICAgICAgIF19XG5cbiAgICAgICBJZiBhIHR1cGxlIGlzIGZyZWUsIGl0cyBoZWFkZXIgaXMgc2V0IHRvIGVpdGhlciBbTnVsbF0gb3IgW0ZyZWVdIHdpdGhcbiAgICAgICBbbmV4dF9mcmVlX2hlYWRlcl9pbmRleF0gaW5kaWNhdGluZyB0aGUgaGVhZGVyIG9mIHRoZSBuZXh0IHR1cGxlIG9uIHRoZSBmcmVlIGxpc3QuXG4gICAgICAgSWYgYSB0dXBsZSBpcyBpbiB1c2UsIGl0IGhlYWRlciBpcyBzZXQgdG8gW1VzZWRdLiAqKVxuXG4gICAgdHlwZSB0ID0gcHJpdmF0ZSBpbnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBudWxsIDogdFxuICAgIHZhbCBpc19udWxsIDogdCAtPiBib29sXG4gICAgdmFsIGZyZWUgOiBuZXh0X2ZyZWVfaGVhZGVyX2luZGV4OmludCAtPiB0XG4gICAgdmFsIGlzX2ZyZWUgOiB0IC0+IGJvb2xcbiAgICB2YWwgbmV4dF9mcmVlX2hlYWRlcl9pbmRleCA6IHQgLT4gaW50XG5cbiAgICAoKiBvbmx5IHZhbGlkIGlmIFtpc19mcmVlIHRdICopXG5cbiAgICB2YWwgdXNlZCA6IFR1cGxlX2lkLnQgLT4gdFxuICAgIHZhbCBpc191c2VkIDogdCAtPiBib29sXG4gICAgdmFsIHR1cGxlX2lkIDogdCAtPiBUdXBsZV9pZC50XG5cbiAgICAoKiBvbmx5IHZhbGlkIGlmIFtpc191c2VkIHRdICopXG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludFxuXG4gICAgbGV0IG51bGwgPSAwXG4gICAgbGV0IGlzX251bGwgdCA9IHQgPSAwXG5cbiAgICAoKiBXZSBrbm93IHRoYXQgaGVhZGVyIGluZGljZXMgYXJlIFs+IDBdLCBiZWNhdXNlIGluZGV4IFswXSBob2xkcyB0aGUgbWV0YWRhdGEuICopXG4gICAgbGV0IGZyZWUgfm5leHRfZnJlZV9oZWFkZXJfaW5kZXggPSBuZXh0X2ZyZWVfaGVhZGVyX2luZGV4XG4gICAgbGV0IGlzX2ZyZWUgdCA9IHQgPiAwXG4gICAgbGV0IG5leHRfZnJlZV9oZWFkZXJfaW5kZXggdCA9IHRcbiAgICBsZXQgdXNlZCAodHVwbGVfaWQgOiBUdXBsZV9pZC50KSA9IC0xIC0gKHR1cGxlX2lkIDo+IGludClcbiAgICBsZXQgaXNfdXNlZCB0ID0gdCA8IDBcbiAgICBsZXQgdHVwbGVfaWQgdCA9IFR1cGxlX2lkLm9mX2ludCAoLSh0ICsgMSkpXG5cbiAgICBsZXQldGVzdF91bml0IF8gPVxuICAgICAgTGlzdC5pdGVyIFR1cGxlX2lkLmV4YW1wbGVzIH5mOihmdW4gaWQgLT5cbiAgICAgICAgbGV0IHQgPSB1c2VkIGlkIGluXG4gICAgICAgIGFzc2VydCAoaXNfdXNlZCB0KTtcbiAgICAgICAgYXNzZXJ0IChUdXBsZV9pZC5lcXVhbCAodHVwbGVfaWQgdCkgaWQpKVxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90IHQgPVxuICAgICAgaWYgaXNfbnVsbCB0XG4gICAgICB0aGVuIFNleHAuQXRvbSBcIm51bGxcIlxuICAgICAgZWxzZSBpZiBpc19mcmVlIHRcbiAgICAgIHRoZW4gU2V4cC4oTGlzdCBbIEF0b20gXCJGcmVlXCI7IEF0b20gKEludC50b19zdHJpbmcgKG5leHRfZnJlZV9oZWFkZXJfaW5kZXggdCkpIF0pXG4gICAgICBlbHNlIFNleHAuKExpc3QgWyBBdG9tIFwiVXNlZFwiOyBBdG9tIChUdXBsZV9pZC50b19zdHJpbmcgKHR1cGxlX2lkIHQpKSBdKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBtZXRhZGF0YV9pbmRleCA9IDBcbiAgbGV0IHN0YXJ0X29mX3R1cGxlc19pbmRleCA9IDFcblxuICBsZXQgbWF4X2NhcGFjaXR5IH5zbG90c19wZXJfdHVwbGUgPVxuICAgIChtYXhfYXJyYXlfbGVuZ3RoIC0gc3RhcnRfb2ZfdHVwbGVzX2luZGV4KSAvICgxICsgc2xvdHNfcGVyX3R1cGxlKVxuICA7O1xuXG4gIGxldCV0ZXN0X3VuaXQgXyA9XG4gICAgZm9yIHNsb3RzX3Blcl90dXBsZSA9IDEgdG8gbWF4X3Nsb3QgZG9cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIHN0YXJ0X29mX3R1cGxlc19pbmRleCArICgoMSArIHNsb3RzX3Blcl90dXBsZSkgKiBtYXhfY2FwYWNpdHkgfnNsb3RzX3Blcl90dXBsZSlcbiAgICAgICAgPD0gbWF4X2FycmF5X2xlbmd0aClcbiAgICBkb25lXG4gIDs7XG5cbiAgbW9kdWxlIE1ldGFkYXRhID0gc3RydWN0XG4gICAgdHlwZSAnc2xvdHMgdCA9XG4gICAgICB7ICgqIFtzbG90c19wZXJfdHVwbGVdIGlzIG51bWJlciBvZiBzbG90cyBpbiBhIHR1cGxlIGFzIHNlZW4gYnkgdGhlIHVzZXI7IGkuZS4gbm90XG4gICAgICAgICAgIGNvdW50aW5nIHRoZSBuZXh0LWZyZWUgcG9pbnRlci4gKilcbiAgICAgICAgc2xvdHNfcGVyX3R1cGxlIDogaW50XG4gICAgICA7IGNhcGFjaXR5IDogaW50XG4gICAgICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICA7IG11dGFibGUgbmV4dF9pZCA6IFR1cGxlX2lkLnRcbiAgICAgIDsgbXV0YWJsZSBmaXJzdF9mcmVlIDogSGVhZGVyLnRcbiAgICAgICgqIFtkdW1teV0gaXMgW05vbmVdIGluIGFuIHVuc2FmZSBwb29sLiAgSW4gYSBzYWZlIHBvb2wsIFtkdW1teV0gaXMgW1NvbWUgYV0sIHdpdGhcbiAgICAgICAgIFtVbmlmb3JtX2FycmF5Lmxlbmd0aCBhID0gc2xvdHNfcGVyX3R1cGxlXS4gIFtkdW1teV0gaXMgYWN0dWFsbHkgYSB0dXBsZSB2YWx1ZVxuICAgICAgICAgd2l0aCB0aGUgY29ycmVjdCB0eXBlIChjb3JyZXNwb25kaW5nIHRvIFsnc2xvdHNdKSwgYnV0IHdlIG1ha2UgdGhlIHR5cGUgb2ZcbiAgICAgICAgIFtkdW1teV0gYmUgW09iai50IFVuaWZvcm1fYXJyYXkudF0gYmVjYXVzZSB3ZSBjYW4ndCB3cml0ZSB0aGF0IHR5cGUgaGVyZS4gIEFsc28sXG4gICAgICAgICB0aGUgcHVycG9zZSBvZiBbZHVtbXldIGlzIHRvIGluaXRpYWxpemUgYSBwb29sIGVsZW1lbnQsIG1ha2luZyBbZHVtbXldIGFuIFtPYmoudFxuICAgICAgICAgVW5pZm9ybV9hcnJheS50XSBsZXRzIHVzIGluaXRpYWxpemUgYSBwb29sIGVsZW1lbnQgdXNpbmcgW1VuaWZvcm1fYXJyYXkuYmxpdF1cbiAgICAgICAgIGZyb20gW2R1bW15XSB0byB0aGUgcG9vbCwgd2hpY2ggaXMgYW4gW09iai50IFVuaWZvcm1fYXJyYXkudF0uICopXG4gICAgICA7IGR1bW15IDogKE9iai50IFVuaWZvcm1fYXJyYXkudFtAc2V4cC5vcGFxdWVdKSBvcHRpb25cbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgYXJyYXlfaW5kaWNlc19wZXJfdHVwbGUgdCA9IDEgKyB0LnNsb3RzX3Blcl90dXBsZVxuICAgIGxldCBhcnJheV9sZW5ndGggdCA9IHN0YXJ0X29mX3R1cGxlc19pbmRleCArICh0LmNhcGFjaXR5ICogYXJyYXlfaW5kaWNlc19wZXJfdHVwbGUgdClcblxuICAgIGxldCBoZWFkZXJfaW5kZXhfdG9fdHVwbGVfbnVtIHQgfmhlYWRlcl9pbmRleCA9XG4gICAgICAoaGVhZGVyX2luZGV4IC0gc3RhcnRfb2ZfdHVwbGVzX2luZGV4KSAvIGFycmF5X2luZGljZXNfcGVyX3R1cGxlIHRcbiAgICA7O1xuXG4gICAgbGV0IHR1cGxlX251bV90b19oZWFkZXJfaW5kZXggdCB0dXBsZV9udW0gPVxuICAgICAgc3RhcnRfb2ZfdHVwbGVzX2luZGV4ICsgKHR1cGxlX251bSAqIGFycmF5X2luZGljZXNfcGVyX3R1cGxlIHQpXG4gICAgOztcblxuICAgIGxldCB0dXBsZV9udW1fdG9fZmlyc3Rfc2xvdF9pbmRleCB0IHR1cGxlX251bSA9XG4gICAgICB0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IHQgdHVwbGVfbnVtICsgMVxuICAgIDs7XG5cbiAgICBsZXQgaXNfZnVsbCB0ID0gdC5sZW5ndGggPSB0LmNhcGFjaXR5XG4gIGVuZFxuXG4gIG9wZW4gTWV0YWRhdGFcblxuICAoKiBXZSB1c2UgdHlwZSBbT2JqLnRdIGJlY2F1c2UgdGhlIGFycmF5IGhvbGRzIGEgbWl4IG9mIGludGVnZXJzIGFzIHdlbGwgYXMgT0NhbWwgdmFsdWVzXG4gICAgIG9mIGFyYml0cmFyeSB0eXBlLiAqKVxuICB0eXBlICdzbG90cyB0ID0gT2JqLnQgVW5pZm9ybV9hcnJheS50XG5cbiAgbGV0IG1ldGFkYXRhICh0eXBlIHNsb3RzKSAodCA6IHNsb3RzIHQpID1cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBtZXRhZGF0YV9pbmRleCB8PiAoT2JqLm9iaiA6IF8gLT4gc2xvdHMgTWV0YWRhdGEudClcbiAgOztcblxuICBsZXQgbGVuZ3RoIHQgPSAobWV0YWRhdGEgdCkubGVuZ3RoXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl90eSB0ID0gTWV0YWRhdGEuc2V4cF9vZl90IHNleHBfb2ZfdHkgKG1ldGFkYXRhIHQpXG5cbiAgKCogQmVjYXVzZSBbdW5zYWZlX2hlYWRlcl0gYW5kIFt1bnNhZmVfc2V0X2hlYWRlcl0gZG8gbm90IGRvIGEgYm91bmRzIGNoZWNrLCBvbmUgbXVzdCBiZVxuICAgICBzdXJlIHRoYXQgb25lIGhhcyBhIHZhbGlkIFtoZWFkZXJfaW5kZXhdIGJlZm9yZSBjYWxsaW5nIHRoZW0uICopXG4gIGxldCB1bnNhZmVfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCA9XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaGVhZGVyX2luZGV4IHw+IChPYmoub2JqIDogXyAtPiBIZWFkZXIudClcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF9oZWFkZXIgdCB+aGVhZGVyX2luZGV4IChoZWFkZXIgOiBIZWFkZXIudCkgPVxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGhlYWRlcl9pbmRleCAoaGVhZGVyIDo+IGludClcbiAgOztcblxuICBsZXQgaGVhZGVyX2luZGV4X2lzX2luX2JvdW5kcyB0IH5oZWFkZXJfaW5kZXggPVxuICAgIGhlYWRlcl9pbmRleCA+PSBzdGFydF9vZl90dXBsZXNfaW5kZXggJiYgaGVhZGVyX2luZGV4IDwgVW5pZm9ybV9hcnJheS5sZW5ndGggdFxuICA7O1xuXG4gIGxldCB1bnNhZmVfcG9pbnRlcl9pc19saXZlIHQgcG9pbnRlciA9XG4gICAgbGV0IGhlYWRlcl9pbmRleCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBsZXQgaGVhZGVyID0gdW5zYWZlX2hlYWRlciB0IH5oZWFkZXJfaW5kZXggaW5cbiAgICBIZWFkZXIuaXNfdXNlZCBoZWFkZXJcbiAgICAmJiBUdXBsZV9pZC50b19pbnQgKEhlYWRlci50dXBsZV9pZCBoZWFkZXIpIGxhbmQgdHVwbGVfaWRfbWFza1xuICAgICAgID0gUG9pbnRlci5tYXNrZWRfdHVwbGVfaWQgcG9pbnRlclxuICA7O1xuXG4gIGxldCBwb2ludGVyX2lzX3ZhbGlkIHQgcG9pbnRlciA9XG4gICAgaGVhZGVyX2luZGV4X2lzX2luX2JvdW5kcyB0IH5oZWFkZXJfaW5kZXg6KFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIpXG4gICAgKCogQXQgdGhpcyBwb2ludCwgd2Uga25vdyB0aGUgcG9pbnRlciBpc24ndCBbbnVsbF0gYW5kIGlzIGluIGJvdW5kcywgc28gd2Uga25vdyBpdCBpc1xuICAgICAgIHRoZSBpbmRleCBvZiBhIGhlYWRlciwgc2luY2Ugd2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IGFsbCBwb2ludGVycyBvdGhlciB0aGFuXG4gICAgICAgW251bGxdIGFyZS4gKilcbiAgICAmJiB1bnNhZmVfcG9pbnRlcl9pc19saXZlIHQgcG9pbnRlclxuICA7O1xuXG4gIGxldCBpZF9vZl9wb2ludGVyIF90IHBvaW50ZXIgPSBQb2ludGVyLnRvX2lkIHBvaW50ZXJcblxuICBsZXQgaXNfdmFsaWRfaGVhZGVyX2luZGV4IHQgfmhlYWRlcl9pbmRleCA9XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgIGhlYWRlcl9pbmRleF9pc19pbl9ib3VuZHMgdCB+aGVhZGVyX2luZGV4XG4gICAgJiYgMFxuICAgICAgID0gKGhlYWRlcl9pbmRleCAtIHN0YXJ0X29mX3R1cGxlc19pbmRleClcbiAgICAgICAgIG1vZCBNZXRhZGF0YS5hcnJheV9pbmRpY2VzX3Blcl90dXBsZSBtZXRhZGF0YVxuICA7O1xuXG4gIGxldCBwb2ludGVyX29mX2lkX2V4biB0IGlkID1cbiAgICB0cnlcbiAgICAgIGxldCBwb2ludGVyID0gUG9pbnRlci5vZl9pZF9leG4gaWQgaW5cbiAgICAgIGlmIG5vdCAoUG9pbnRlci5pc19udWxsIHBvaW50ZXIpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGhlYWRlcl9pbmRleCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICAgICAgaWYgbm90IChpc192YWxpZF9oZWFkZXJfaW5kZXggdCB+aGVhZGVyX2luZGV4KVxuICAgICAgICB0aGVuIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiaW52YWxpZCBoZWFkZXIgaW5kZXhcIiBoZWFkZXJfaW5kZXggWyVzZXhwX29mOiBpbnRdO1xuICAgICAgICBpZiBub3QgKHVuc2FmZV9wb2ludGVyX2lzX2xpdmUgdCBwb2ludGVyKSB0aGVuIGZhaWx3aXRoIFwicG9pbnRlciBub3QgbGl2ZVwiKTtcbiAgICAgIHBvaW50ZXJcbiAgICB3aXRoXG4gICAgfCBleG4gLT5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUG9vbC5wb2ludGVyX29mX2lkX2V4biBnb3QgaW52YWxpZCBpZFwiXG4gICAgICAgIChpZCwgdCwgZXhuKVxuICAgICAgICBbJXNleHBfb2Y6IFBvaW50ZXIuSWQudCAqIF8gdCAqIGV4bl1cbiAgOztcblxuICBsZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0IDogdW5pdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgbWV0YWRhdGEgPSBtZXRhZGF0YSB0IGluXG4gICAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCBtZXRhZGF0YSkgaW5cbiAgICAgIE1ldGFkYXRhLkZpZWxkcy5pdGVyXG4gICAgICAgIH5zbG90c19wZXJfdHVwbGU6KGNoZWNrIChmdW4gc2xvdHNfcGVyX3R1cGxlIC0+IGFzc2VydCAoc2xvdHNfcGVyX3R1cGxlID4gMCkpKVxuICAgICAgICB+Y2FwYWNpdHk6XG4gICAgICAgICAgKGNoZWNrIChmdW4gY2FwYWNpdHkgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKGNhcGFjaXR5ID49IDApO1xuICAgICAgICAgICAgIGFzc2VydCAoVW5pZm9ybV9hcnJheS5sZW5ndGggdCA9IE1ldGFkYXRhLmFycmF5X2xlbmd0aCBtZXRhZGF0YSkpKVxuICAgICAgICB+bGVuZ3RoOlxuICAgICAgICAgIChjaGVjayAoZnVuIGxlbmd0aCAtPlxuICAgICAgICAgICAgIGFzc2VydCAobGVuZ3RoID49IDApO1xuICAgICAgICAgICAgIGFzc2VydCAobGVuZ3RoIDw9IG1ldGFkYXRhLmNhcGFjaXR5KSkpXG4gICAgICAgIH5uZXh0X2lkOihjaGVjayBUdXBsZV9pZC5pbnZhcmlhbnQpXG4gICAgICAgIH5maXJzdF9mcmVlOlxuICAgICAgICAgIChjaGVjayAoZnVuIGZpcnN0X2ZyZWUgLT5cbiAgICAgICAgICAgICBsZXQgZnJlZSA9IEFycmF5LmNyZWF0ZSB+bGVuOm1ldGFkYXRhLmNhcGFjaXR5IGZhbHNlIGluXG4gICAgICAgICAgICAgbGV0IHIgPSByZWYgZmlyc3RfZnJlZSBpblxuICAgICAgICAgICAgIHdoaWxlIG5vdCAoSGVhZGVyLmlzX251bGwgIXIpIGRvXG4gICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gIXIgaW5cbiAgICAgICAgICAgICAgIGFzc2VydCAoSGVhZGVyLmlzX2ZyZWUgaGVhZGVyKTtcbiAgICAgICAgICAgICAgIGxldCBoZWFkZXJfaW5kZXggPSBIZWFkZXIubmV4dF9mcmVlX2hlYWRlcl9pbmRleCBoZWFkZXIgaW5cbiAgICAgICAgICAgICAgIGFzc2VydCAoaXNfdmFsaWRfaGVhZGVyX2luZGV4IHQgfmhlYWRlcl9pbmRleCk7XG4gICAgICAgICAgICAgICBsZXQgdHVwbGVfbnVtID0gaGVhZGVyX2luZGV4X3RvX3R1cGxlX251bSBtZXRhZGF0YSB+aGVhZGVyX2luZGV4IGluXG4gICAgICAgICAgICAgICBpZiBmcmVlLih0dXBsZV9udW0pXG4gICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiY3ljbGUgaW4gZnJlZSBsaXN0XCIgdHVwbGVfbnVtIFslc2V4cF9vZjogaW50XTtcbiAgICAgICAgICAgICAgIGZyZWUuKHR1cGxlX251bSkgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgIHIgOj0gdW5zYWZlX2hlYWRlciB0IH5oZWFkZXJfaW5kZXhcbiAgICAgICAgICAgICBkb25lKSlcbiAgICAgICAgfmR1bW15OlxuICAgICAgICAgIChjaGVjayAoZnVuY3Rpb25cbiAgICAgICAgICAgICB8IFNvbWUgZHVtbXkgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoVW5pZm9ybV9hcnJheS5sZW5ndGggZHVtbXkgPSBtZXRhZGF0YS5zbG90c19wZXJfdHVwbGUpXG4gICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICBmb3IgdHVwbGVfbnVtID0gMCB0byBtZXRhZGF0YS5jYXBhY2l0eSAtIDEgZG9cbiAgICAgICAgICAgICAgICAgbGV0IGhlYWRlcl9pbmRleCA9IHR1cGxlX251bV90b19oZWFkZXJfaW5kZXggbWV0YWRhdGEgdHVwbGVfbnVtIGluXG4gICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bnNhZmVfaGVhZGVyIHQgfmhlYWRlcl9pbmRleCBpblxuICAgICAgICAgICAgICAgICBpZiBIZWFkZXIuaXNfZnJlZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0X3Nsb3QgPSB0dXBsZV9udW1fdG9fZmlyc3Rfc2xvdF9pbmRleCBtZXRhZGF0YSB0dXBsZV9udW0gaW5cbiAgICAgICAgICAgICAgICAgICBmb3Igc2xvdCA9IDAgdG8gbWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlIC0gMSBkb1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChPYmouaXNfaW50IChVbmlmb3JtX2FycmF5LmdldCB0IChmaXJzdF9zbG90ICsgc2xvdCkpKVxuICAgICAgICAgICAgICAgICAgIGRvbmUpXG4gICAgICAgICAgICAgICBkb25lKSlcbiAgICB3aXRoXG4gICAgfCBleG4gLT5cbiAgICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiUG9vbC5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biwgdCkgWyVzZXhwX29mOiBleG4gKiBfIHRdXG4gIDs7XG5cbiAgbGV0IGNhcGFjaXR5IHQgPSAobWV0YWRhdGEgdCkuY2FwYWNpdHlcbiAgbGV0IGlzX2Z1bGwgdCA9IE1ldGFkYXRhLmlzX2Z1bGwgKG1ldGFkYXRhIHQpXG5cbiAgbGV0IHVuc2FmZV9hZGRfdG9fZnJlZV9saXN0IHQgbWV0YWRhdGEgfmhlYWRlcl9pbmRleCA9XG4gICAgdW5zYWZlX3NldF9oZWFkZXIgdCB+aGVhZGVyX2luZGV4IG1ldGFkYXRhLmZpcnN0X2ZyZWU7XG4gICAgbWV0YWRhdGEuZmlyc3RfZnJlZSA8LSBIZWFkZXIuZnJlZSB+bmV4dF9mcmVlX2hlYWRlcl9pbmRleDpoZWFkZXJfaW5kZXhcbiAgOztcblxuICBsZXQgc2V0X21ldGFkYXRhICh0eXBlIHNsb3RzKSAodCA6IHNsb3RzIHQpIG1ldGFkYXRhID1cbiAgICBVbmlmb3JtX2FycmF5LnNldCB0IG1ldGFkYXRhX2luZGV4IChPYmoucmVwciAobWV0YWRhdGEgOiBzbG90cyBNZXRhZGF0YS50KSlcbiAgOztcblxuICBsZXQgY3JlYXRlX2FycmF5ICh0eXBlIHNsb3RzKSAobWV0YWRhdGEgOiBzbG90cyBNZXRhZGF0YS50KSA6IHNsb3RzIHQgPVxuICAgIGxldCB0ID0gVW5pZm9ybV9hcnJheS5jcmVhdGVfb2JqX2FycmF5IH5sZW46KE1ldGFkYXRhLmFycmF5X2xlbmd0aCBtZXRhZGF0YSkgaW5cbiAgICBzZXRfbWV0YWRhdGEgdCBtZXRhZGF0YTtcbiAgICB0XG4gIDs7XG5cbiAgKCogSW5pdGlhbGl6ZSB0dXBsZXMgbnVtYmVyZWQgZnJvbSBbbG9dIChpbmNsdXNpdmUpIHVwIHRvIFtoaV0gKGV4Y2x1c2l2ZSkuICBGb3IgZWFjaFxuICAgICB0dXBsZSwgdGhpcyBwdXRzIGR1bW15IHZhbHVlcyBpbiB0aGUgdHVwbGUncyBzbG90cyBhbmQgYWRkcyB0aGUgdHVwbGUgdG8gdGhlIGZyZWVcbiAgICAgbGlzdC4gKilcbiAgbGV0IHVuc2FmZV9pbml0X3JhbmdlIHQgbWV0YWRhdGEgfmxvIH5oaSA9XG4gICAgKG1hdGNoIG1ldGFkYXRhLmR1bW15IHdpdGhcbiAgICAgfCBOb25lIC0+ICgpXG4gICAgIHwgU29tZSBkdW1teSAtPlxuICAgICAgIGZvciB0dXBsZV9udW0gPSBsbyB0byBoaSAtIDEgZG9cbiAgICAgICAgIFVuaWZvcm1fYXJyYXkuYmxpdFxuICAgICAgICAgICB+c3JjOmR1bW15XG4gICAgICAgICAgIH5zcmNfcG9zOjBcbiAgICAgICAgICAgfmRzdDp0XG4gICAgICAgICAgIH5kc3RfcG9zOih0dXBsZV9udW1fdG9fZmlyc3Rfc2xvdF9pbmRleCBtZXRhZGF0YSB0dXBsZV9udW0pXG4gICAgICAgICAgIH5sZW46bWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICAgZG9uZSk7XG4gICAgZm9yIHR1cGxlX251bSA9IGhpIC0gMSBkb3dudG8gbG8gZG9cbiAgICAgIHVuc2FmZV9hZGRfdG9fZnJlZV9saXN0XG4gICAgICAgIHRcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfmhlYWRlcl9pbmRleDoodHVwbGVfbnVtX3RvX2hlYWRlcl9pbmRleCBtZXRhZGF0YSB0dXBsZV9udW0pXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9kdW1teSBzbG90cyB+Y2FwYWNpdHkgfmR1bW15ID1cbiAgICBpZiBjYXBhY2l0eSA8IDBcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIlBvb2wuY3JlYXRlIGdvdCBpbnZhbGlkIGNhcGFjaXR5XCIgY2FwYWNpdHkgWyVzZXhwX29mOiBpbnRdO1xuICAgIGxldCBzbG90c19wZXJfdHVwbGUgPSBTbG90cy5zbG90c19wZXJfdHVwbGUgc2xvdHMgaW5cbiAgICBsZXQgbWF4X2NhcGFjaXR5ID0gbWF4X2NhcGFjaXR5IH5zbG90c19wZXJfdHVwbGUgaW5cbiAgICBpZiBjYXBhY2l0eSA+IG1heF9jYXBhY2l0eVxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUG9vbC5jcmVhdGUgZ290IHRvbyBsYXJnZSBjYXBhY2l0eVwiXG4gICAgICAgIChjYXBhY2l0eSwgYG1heCBtYXhfY2FwYWNpdHkpXG4gICAgICAgIFslc2V4cF9vZjogaW50ICogWyBgbWF4IG9mIGludCBdXTtcbiAgICBsZXQgbWV0YWRhdGEgPVxuICAgICAgeyBNZXRhZGF0YS5zbG90c19wZXJfdHVwbGVcbiAgICAgIDsgY2FwYWNpdHlcbiAgICAgIDsgbGVuZ3RoID0gMFxuICAgICAgOyBuZXh0X2lkID0gVHVwbGVfaWQuaW5pdFxuICAgICAgOyBmaXJzdF9mcmVlID0gSGVhZGVyLm51bGxcbiAgICAgIDsgZHVtbXlcbiAgICAgIH1cbiAgICBpblxuICAgIGxldCB0ID0gY3JlYXRlX2FycmF5IG1ldGFkYXRhIGluXG4gICAgdW5zYWZlX2luaXRfcmFuZ2UgdCBtZXRhZGF0YSB+bG86MCB+aGk6Y2FwYWNpdHk7XG4gICAgdFxuICA7O1xuXG4gIGxldCBjcmVhdGUgKHR5cGUgdHVwbGUpIChzbG90cyA6ICh0dXBsZSwgXykgU2xvdHMudCkgfmNhcGFjaXR5IH5kdW1teSA9XG4gICAgbGV0IGR1bW15ID1cbiAgICAgIGlmIFNsb3RzLnNsb3RzX3Blcl90dXBsZSBzbG90cyA9IDFcbiAgICAgIHRoZW4gVW5pZm9ybV9hcnJheS5zaW5nbGV0b24gKE9iai5yZXByIChkdW1teSA6IHR1cGxlKSlcbiAgICAgIGVsc2UgKE9iai5tYWdpYyAoZHVtbXkgOiB0dXBsZSkgOiBPYmoudCBVbmlmb3JtX2FycmF5LnQpXG4gICAgaW5cbiAgICBjcmVhdGVfd2l0aF9kdW1teSBzbG90cyB+Y2FwYWNpdHkgfmR1bW15OihTb21lIGR1bW15KVxuICA7O1xuXG4gICgqIFB1cmdlIGEgcG9vbCBhbmQgbWFrZSBpdCB1bnVzYWJsZS4gKilcbiAgbGV0IGRlc3Ryb3kgdCA9XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgICgqIFdlIGNsZWFyIG91dCBhbGwgdGhlIHBvb2wncyBlbnRyaWVzLCB3aGljaCBjYXVzZXMgYWxsIHBvaW50ZXJzIHRvIGJlIGludmFsaWQuICBUaGlzXG4gICAgICAgYWxzbyBwcmV2ZW50cyB0aGUgZGVzdHJveWVkIHBvb2wgZnJvbSB1bm5lY2Vzc2FyaWx5IGtlZXBpbmcgaGVhcCBibG9ja3MgYWxpdmUuXG4gICAgICAgVGhpcyBpcyBzaW1pbGFyIHRvIFtmcmVlXWluZyBhbGwgdGhlIGVudHJpZXMgd2l0aCB0aGUgZGlmZmVyZW5jZSB0aGF0IHdlIG1ha2UgdGhlXG4gICAgICAgZnJlZSBsaXN0IGVtcHR5IGFzIHdlbGwuICopXG4gICAgKG1hdGNoIG1ldGFkYXRhLmR1bW15IHdpdGhcbiAgICAgfCBOb25lIC0+XG4gICAgICAgZm9yIGkgPSBzdGFydF9vZl90dXBsZXNfaW5kZXggdG8gVW5pZm9ybV9hcnJheS5sZW5ndGggdCAtIDEgZG9cbiAgICAgICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKE9iai5yZXByIDApXG4gICAgICAgZG9uZVxuICAgICB8IFNvbWUgZHVtbXkgLT5cbiAgICAgICBmb3IgdHVwbGVfbnVtID0gMCB0byBtZXRhZGF0YS5jYXBhY2l0eSAtIDEgZG9cbiAgICAgICAgIGxldCBoZWFkZXJfaW5kZXggPSB0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IG1ldGFkYXRhIHR1cGxlX251bSBpblxuICAgICAgICAgdW5zYWZlX3NldF9oZWFkZXIgdCB+aGVhZGVyX2luZGV4IEhlYWRlci5udWxsO1xuICAgICAgICAgVW5pZm9ybV9hcnJheS5ibGl0XG4gICAgICAgICAgIH5zcmM6ZHVtbXlcbiAgICAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICAgICB+ZHN0OnRcbiAgICAgICAgICAgfmRzdF9wb3M6KGhlYWRlcl9pbmRleCArIDEpXG4gICAgICAgICAgIH5sZW46bWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICAgZG9uZSk7XG4gICAgbGV0IG1ldGFkYXRhID1cbiAgICAgIHsgTWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlID0gbWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICA7IGNhcGFjaXR5ID0gMFxuICAgICAgOyBsZW5ndGggPSAwXG4gICAgICA7IG5leHRfaWQgPSBtZXRhZGF0YS5uZXh0X2lkXG4gICAgICA7IGZpcnN0X2ZyZWUgPSBIZWFkZXIubnVsbFxuICAgICAgOyBkdW1teSA9IG1ldGFkYXRhLmR1bW15XG4gICAgICB9XG4gICAgaW5cbiAgICBzZXRfbWV0YWRhdGEgdCBtZXRhZGF0YVxuICA7O1xuXG4gIGxldFtAY29sZF0gZ3JvdyA/Y2FwYWNpdHkgdCA9XG4gICAgbGV0IHsgTWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICAgIDsgY2FwYWNpdHkgPSBvbGRfY2FwYWNpdHlcbiAgICAgICAgOyBsZW5ndGhcbiAgICAgICAgOyBuZXh0X2lkXG4gICAgICAgIDsgZmlyc3RfZnJlZSA9IF9cbiAgICAgICAgOyBkdW1teVxuICAgICAgICB9XG4gICAgICA9XG4gICAgICBtZXRhZGF0YSB0XG4gICAgaW5cbiAgICBsZXQgY2FwYWNpdHkgPVxuICAgICAgbWluIChtYXhfY2FwYWNpdHkgfnNsb3RzX3Blcl90dXBsZSkgKGdyb3dfY2FwYWNpdHkgfmNhcGFjaXR5IH5vbGRfY2FwYWNpdHkpXG4gICAgaW5cbiAgICBpZiBjYXBhY2l0eSA9IG9sZF9jYXBhY2l0eVxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUG9vbC5ncm93IGNhbm5vdCBncm93IHBvb2w7IGNhcGFjaXR5IGFscmVhZHkgYXQgbWF4aW11bVwiXG4gICAgICAgIGNhcGFjaXR5XG4gICAgICAgIFslc2V4cF9vZjogaW50XTtcbiAgICBsZXQgbWV0YWRhdGEgPVxuICAgICAgeyBNZXRhZGF0YS5zbG90c19wZXJfdHVwbGVcbiAgICAgIDsgY2FwYWNpdHlcbiAgICAgIDsgbGVuZ3RoXG4gICAgICA7IG5leHRfaWRcbiAgICAgIDsgZmlyc3RfZnJlZSA9IEhlYWRlci5udWxsXG4gICAgICA7IGR1bW15XG4gICAgICB9XG4gICAgaW5cbiAgICBsZXQgdCcgPSBjcmVhdGVfYXJyYXkgbWV0YWRhdGEgaW5cbiAgICBVbmlmb3JtX2FycmF5LmJsaXRcbiAgICAgIH5zcmM6dFxuICAgICAgfnNyY19wb3M6c3RhcnRfb2ZfdHVwbGVzX2luZGV4XG4gICAgICB+ZHN0OnQnXG4gICAgICB+ZHN0X3BvczpzdGFydF9vZl90dXBsZXNfaW5kZXhcbiAgICAgIH5sZW46KG9sZF9jYXBhY2l0eSAqIE1ldGFkYXRhLmFycmF5X2luZGljZXNfcGVyX3R1cGxlIG1ldGFkYXRhKTtcbiAgICBkZXN0cm95IHQ7XG4gICAgdW5zYWZlX2luaXRfcmFuZ2UgdCcgbWV0YWRhdGEgfmxvOm9sZF9jYXBhY2l0eSB+aGk6Y2FwYWNpdHk7XG4gICAgZm9yIHR1cGxlX251bSA9IG9sZF9jYXBhY2l0eSAtIDEgZG93bnRvIDAgZG9cbiAgICAgIGxldCBoZWFkZXJfaW5kZXggPSB0dXBsZV9udW1fdG9faGVhZGVyX2luZGV4IG1ldGFkYXRhIHR1cGxlX251bSBpblxuICAgICAgbGV0IGhlYWRlciA9IHVuc2FmZV9oZWFkZXIgdCcgfmhlYWRlcl9pbmRleCBpblxuICAgICAgaWYgbm90IChIZWFkZXIuaXNfdXNlZCBoZWFkZXIpXG4gICAgICB0aGVuIHVuc2FmZV9hZGRfdG9fZnJlZV9saXN0IHQnIG1ldGFkYXRhIH5oZWFkZXJfaW5kZXhcbiAgICBkb25lO1xuICAgIHQnXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9tYWxsb2NfZnVsbCB0ID1cbiAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIlBvb2wubWFsbG9jIG9mIGZ1bGwgcG9vbFwiIHQgWyVzZXhwX29mOiBfIHRdXG4gIDs7XG5cbiAgbGV0IG1hbGxvYyAodHlwZSBzbG90cykgKHQgOiBzbG90cyB0KSA6IHNsb3RzIFBvaW50ZXIudCA9XG4gICAgbGV0IG1ldGFkYXRhID0gbWV0YWRhdGEgdCBpblxuICAgIGxldCBmaXJzdF9mcmVlID0gbWV0YWRhdGEuZmlyc3RfZnJlZSBpblxuICAgIGlmIEhlYWRlci5pc19udWxsIGZpcnN0X2ZyZWUgdGhlbiByYWlzZV9tYWxsb2NfZnVsbCB0O1xuICAgIGxldCBoZWFkZXJfaW5kZXggPSBIZWFkZXIubmV4dF9mcmVlX2hlYWRlcl9pbmRleCBmaXJzdF9mcmVlIGluXG4gICAgbWV0YWRhdGEuZmlyc3RfZnJlZSA8LSB1bnNhZmVfaGVhZGVyIHQgfmhlYWRlcl9pbmRleDtcbiAgICBtZXRhZGF0YS5sZW5ndGggPC0gbWV0YWRhdGEubGVuZ3RoICsgMTtcbiAgICBsZXQgdHVwbGVfaWQgPSBtZXRhZGF0YS5uZXh0X2lkIGluXG4gICAgdW5zYWZlX3NldF9oZWFkZXIgdCB+aGVhZGVyX2luZGV4IChIZWFkZXIudXNlZCB0dXBsZV9pZCk7XG4gICAgbWV0YWRhdGEubmV4dF9pZCA8LSBUdXBsZV9pZC5uZXh0IHR1cGxlX2lkO1xuICAgIFBvaW50ZXIuY3JlYXRlIH5oZWFkZXJfaW5kZXggdHVwbGVfaWRcbiAgOztcblxuICBsZXQgdW5zYWZlX2ZyZWUgKHR5cGUgc2xvdHMpICh0IDogc2xvdHMgdCkgKHBvaW50ZXIgOiBzbG90cyBQb2ludGVyLnQpID1cbiAgICBsZXQgbWV0YWRhdGEgPSBtZXRhZGF0YSB0IGluXG4gICAgbWV0YWRhdGEubGVuZ3RoIDwtIG1ldGFkYXRhLmxlbmd0aCAtIDE7XG4gICAgdW5zYWZlX2FkZF90b19mcmVlX2xpc3QgdCBtZXRhZGF0YSB+aGVhZGVyX2luZGV4OihQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyKTtcbiAgICBtYXRjaCBtZXRhZGF0YS5kdW1teSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgcG9zID0gUG9pbnRlci5maXJzdF9zbG90X2luZGV4IHBvaW50ZXIgaW5cbiAgICAgIGZvciBpID0gMCB0byBtZXRhZGF0YS5zbG90c19wZXJfdHVwbGUgLSAxIGRvXG4gICAgICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgdCAocG9zICsgaSlcbiAgICAgIGRvbmVcbiAgICB8IFNvbWUgZHVtbXkgLT5cbiAgICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX2JsaXRcbiAgICAgICAgfnNyYzpkdW1teVxuICAgICAgICB+c3JjX3BvczowXG4gICAgICAgIH5sZW46bWV0YWRhdGEuc2xvdHNfcGVyX3R1cGxlXG4gICAgICAgIH5kc3Q6dFxuICAgICAgICB+ZHN0X3BvczooUG9pbnRlci5maXJzdF9zbG90X2luZGV4IHBvaW50ZXIpXG4gIDs7XG5cbiAgbGV0IGZyZWUgKHR5cGUgc2xvdHMpICh0IDogc2xvdHMgdCkgKHBvaW50ZXIgOiBzbG90cyBQb2ludGVyLnQpID1cbiAgICAoKiBDaGVjayBbcG9pbnRlcl9pc192YWxpZF0gdG86XG4gICAgICAgLSBhdm9pZCBmcmVlaW5nIGEgbnVsbCBwb2ludGVyXG4gICAgICAgLSBhdm9pZCBmcmVlaW5nIGEgZnJlZSBwb2ludGVyICh0aGlzIHdvdWxkIGxlYWQgdG8gYSBwb29sIGluY29uc2lzdGVuY3kpXG4gICAgICAgLSBiZSBhYmxlIHRvIHVzZSB1bnNhZmUgZnVuY3Rpb25zIGFmdGVyLiAqKVxuICAgIGlmIG5vdCAocG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXIpXG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJQb29sLmZyZWUgb2YgaW52YWxpZCBwb2ludGVyXCJcbiAgICAgICAgKHBvaW50ZXIsIHQpXG4gICAgICAgIFslc2V4cF9vZjogXyBQb2ludGVyLnQgKiBfIHRdO1xuICAgIHVuc2FmZV9mcmVlIHQgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxIHQgYTAgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3MiB0IGEwIGExID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzMgdCBhMCBhMSBhMiA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXc0IHQgYTAgYTEgYTIgYTMgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3NSB0IGEwIGExIGEyIGEzIGE0ID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzYgdCBhMCBhMSBhMiBhMyBhNCBhNSA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXc3IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA3KSAoT2JqLnJlcHIgYTYpO1xuICAgIHBvaW50ZXJcbiAgOztcblxuICBsZXQgbmV3OCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3ID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNikgKE9iai5yZXByIGE1KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNykgKE9iai5yZXByIGE2KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOCkgKE9iai5yZXByIGE3KTtcbiAgICBwb2ludGVyXG4gIDs7XG5cbiAgbGV0IG5ldzkgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDkpIChPYmoucmVwciBhOCk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxMCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5ID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNikgKE9iai5yZXByIGE1KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNykgKE9iai5yZXByIGE2KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOCkgKE9iai5yZXByIGE3KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOSkgKE9iai5yZXByIGE4KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTApIChPYmoucmVwciBhOSk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxMSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDkpIChPYmoucmVwciBhOCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEwKSAoT2JqLnJlcHIgYTkpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMSkgKE9iai5yZXByIGExMCk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxMiB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgPVxuICAgIGxldCBwb2ludGVyID0gbWFsbG9jIHQgaW5cbiAgICBsZXQgb2Zmc2V0ID0gUG9pbnRlci5oZWFkZXJfaW5kZXggcG9pbnRlciBpblxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxKSAoT2JqLnJlcHIgYTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgYTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAzKSAoT2JqLnJlcHIgYTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA0KSAoT2JqLnJlcHIgYTMpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA1KSAoT2JqLnJlcHIgYTQpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA2KSAoT2JqLnJlcHIgYTUpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA3KSAoT2JqLnJlcHIgYTYpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA4KSAoT2JqLnJlcHIgYTcpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyA5KSAoT2JqLnJlcHIgYTgpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMCkgKE9iai5yZXByIGE5KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTEpIChPYmoucmVwciBhMTApO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMikgKE9iai5yZXByIGExMSk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxMyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyID1cbiAgICBsZXQgcG9pbnRlciA9IG1hbGxvYyB0IGluXG4gICAgbGV0IG9mZnNldCA9IFBvaW50ZXIuaGVhZGVyX2luZGV4IHBvaW50ZXIgaW5cbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMSkgKE9iai5yZXByIGEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMikgKE9iai5yZXByIGExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMykgKE9iai5yZXByIGEyKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNCkgKE9iai5yZXByIGEzKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNSkgKE9iai5yZXByIGE0KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNikgKE9iai5yZXByIGE1KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgNykgKE9iai5yZXByIGE2KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOCkgKE9iai5yZXByIGE3KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgOSkgKE9iai5yZXByIGE4KTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTApIChPYmoucmVwciBhOSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDExKSAoT2JqLnJlcHIgYTEwKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTIpIChPYmoucmVwciBhMTEpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMykgKE9iai5yZXByIGExMik7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBuZXcxNCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyIGExMyA9XG4gICAgbGV0IHBvaW50ZXIgPSBtYWxsb2MgdCBpblxuICAgIGxldCBvZmZzZXQgPSBQb2ludGVyLmhlYWRlcl9pbmRleCBwb2ludGVyIGluXG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEpIChPYmoucmVwciBhMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDIpIChPYmoucmVwciBhMSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDMpIChPYmoucmVwciBhMik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDQpIChPYmoucmVwciBhMyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDUpIChPYmoucmVwciBhNCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDYpIChPYmoucmVwciBhNSk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDcpIChPYmoucmVwciBhNik7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDgpIChPYmoucmVwciBhNyk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDkpIChPYmoucmVwciBhOCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEwKSAoT2JqLnJlcHIgYTkpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxMSkgKE9iai5yZXByIGExMCk7XG4gICAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgKG9mZnNldCArIDEyKSAoT2JqLnJlcHIgYTExKTtcbiAgICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCAob2Zmc2V0ICsgMTMpIChPYmoucmVwciBhMTIpO1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChvZmZzZXQgKyAxNCkgKE9iai5yZXByIGExMyk7XG4gICAgcG9pbnRlclxuICA7O1xuXG4gIGxldCBnZXQgdCBwIHNsb3QgPSBPYmoub2JqIChVbmlmb3JtX2FycmF5LmdldCB0IChQb2ludGVyLnNsb3RfaW5kZXggcCBzbG90KSlcblxuICBsZXQgdW5zYWZlX2dldCB0IHAgc2xvdCA9XG4gICAgT2JqLm9iaiAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgKFBvaW50ZXIuc2xvdF9pbmRleCBwIHNsb3QpKVxuICA7O1xuXG4gIGxldCBzZXQgdCBwIHNsb3QgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgKFBvaW50ZXIuc2xvdF9pbmRleCBwIHNsb3QpIChPYmoucmVwciB4KVxuXG4gIGxldCB1bnNhZmVfc2V0IHQgcCBzbG90IHggPVxuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IChQb2ludGVyLnNsb3RfaW5kZXggcCBzbG90KSAoT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgZ2V0X3R1cGxlICh0eXBlIHR1cGxlKSAodCA6ICh0dXBsZSwgXykgU2xvdHMudCB0KSBwb2ludGVyID1cbiAgICBsZXQgbWV0YWRhdGEgPSBtZXRhZGF0YSB0IGluXG4gICAgbGV0IGxlbiA9IG1ldGFkYXRhLnNsb3RzX3Blcl90dXBsZSBpblxuICAgIGlmIGxlbiA9IDFcbiAgICB0aGVuIGdldCB0IHBvaW50ZXIgU2xvdC50MFxuICAgIGVsc2VcbiAgICAgIChPYmoubWFnaWNcbiAgICAgICAgIChVbmlmb3JtX2FycmF5LnN1YiB0IH5wb3M6KFBvaW50ZXIuZmlyc3Rfc2xvdF9pbmRleCBwb2ludGVyKSB+bGVuXG4gICAgICAgICAgOiBPYmoudCBVbmlmb3JtX2FycmF5LnQpXG4gICAgICAgOiB0dXBsZSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvb2xcblxubW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICBpbmNsdWRlIFBvb2xcblxuICBsZXQgY3JlYXRlIHNsb3RzIH5jYXBhY2l0eSA9IGNyZWF0ZV93aXRoX2R1bW15IHNsb3RzIH5jYXBhY2l0eSB+ZHVtbXk6Tm9uZVxuZW5kXG5cbm1vZHVsZSBEZWJ1ZyAoUG9vbCA6IFMpID0gc3RydWN0XG4gIG9wZW4gUG9vbFxuXG4gIGxldCBjaGVja19pbnZhcmlhbnQgPSByZWYgdHJ1ZVxuICBsZXQgc2hvd19tZXNzYWdlcyA9IHJlZiB0cnVlXG5cbiAgbGV0IGRlYnVnIG5hbWUgdHMgYXJnIHNleHBfb2ZfYXJnIHNleHBfb2ZfcmVzdWx0IGYgPVxuICAgIGxldCBwcmVmaXggPSBcIlBvb2wuXCIgaW5cbiAgICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gTGlzdC5pdGVyIHRzIH5mOihpbnZhcmlhbnQgaWdub3JlKTtcbiAgICBpZiAhc2hvd19tZXNzYWdlcyB0aGVuIERlYnVnLmVwcmludHMgKGNvbmNhdCBbIHByZWZpeDsgbmFtZSBdKSBhcmcgc2V4cF9vZl9hcmc7XG4gICAgbGV0IHJlc3VsdF9vcl9leG4gPSBSZXN1bHQudHJ5X3dpdGggZiBpblxuICAgIGlmICFzaG93X21lc3NhZ2VzXG4gICAgdGhlblxuICAgICAgRGVidWcuZXByaW50c1xuICAgICAgICAoY29uY2F0IFsgcHJlZml4OyBuYW1lOyBcIiByZXN1bHRcIiBdKVxuICAgICAgICByZXN1bHRfb3JfZXhuXG4gICAgICAgIFslc2V4cF9vZjogKHJlc3VsdCwgZXhuKSBSZXN1bHQudF07XG4gICAgUmVzdWx0Lm9rX2V4biByZXN1bHRfb3JfZXhuXG4gIDs7XG5cbiAgbW9kdWxlIFNsb3RzID0gU2xvdHNcbiAgbW9kdWxlIFNsb3QgPSBTbG90XG5cbiAgbW9kdWxlIFBvaW50ZXIgPSBzdHJ1Y3RcbiAgICBvcGVuIFBvaW50ZXJcblxuICAgIHR5cGUgbm9ucmVjICdzbG90cyB0ID0gJ3Nsb3RzIHQgW0BAZGVyaXZpbmcgc2V4cF9vZiwgdHlwZXJlcF1cblxuICAgIGxldCBwaHlzX2NvbXBhcmUgdDEgdDIgPVxuICAgICAgZGVidWdcbiAgICAgICAgXCJQb2ludGVyLnBoeXNfY29tcGFyZVwiXG4gICAgICAgIFtdXG4gICAgICAgICh0MSwgdDIpXG4gICAgICAgIFslc2V4cF9vZjogXyB0ICogXyB0XVxuICAgICAgICBbJXNleHBfb2Y6IGludF1cbiAgICAgICAgKGZ1biAoKSAtPiBwaHlzX2NvbXBhcmUgdDEgdDIpXG4gICAgOztcblxuICAgIGxldCBwaHlzX2VxdWFsIHQxIHQyID1cbiAgICAgIGRlYnVnXG4gICAgICAgIFwiUG9pbnRlci5waHlzX2VxdWFsXCJcbiAgICAgICAgW11cbiAgICAgICAgKHQxLCB0MilcbiAgICAgICAgWyVzZXhwX29mOiBfIHQgKiBfIHRdXG4gICAgICAgIFslc2V4cF9vZjogYm9vbF1cbiAgICAgICAgKGZ1biAoKSAtPiBwaHlzX2VxdWFsIHQxIHQyKVxuICAgIDs7XG5cbiAgICBsZXQgaXNfbnVsbCB0ID1cbiAgICAgIGRlYnVnIFwiUG9pbnRlci5pc19udWxsXCIgW10gdCBbJXNleHBfb2Y6IF8gdF0gWyVzZXhwX29mOiBib29sXSAoZnVuICgpIC0+IGlzX251bGwgdClcbiAgICA7O1xuXG4gICAgbGV0IG51bGwgPSBudWxsXG5cbiAgICBtb2R1bGUgSWQgPSBzdHJ1Y3RcbiAgICAgIG9wZW4gSWRcblxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG4gICAgICBsZXQgb2ZfaW50NjMgaSA9XG4gICAgICAgIGRlYnVnIFwiUG9pbnRlci5JZC5vZl9pbnQ2M1wiIFtdIGkgWyVzZXhwX29mOiBJbnQ2My50XSBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgICBvZl9pbnQ2MyBpKVxuICAgICAgOztcblxuICAgICAgbGV0IHRvX2ludDYzIHQgPVxuICAgICAgICBkZWJ1ZyBcIlBvaW50ZXIuSWQudG9faW50NjNcIiBbXSB0IFslc2V4cF9vZjogdF0gWyVzZXhwX29mOiBJbnQ2My50XSAoZnVuICgpIC0+XG4gICAgICAgICAgdG9faW50NjMgdClcbiAgICAgIDs7XG4gICAgZW5kXG4gIGVuZFxuXG4gIHR5cGUgbm9ucmVjICdzbG90cyB0ID0gJ3Nsb3RzIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICBsZXQgaWRfb2ZfcG9pbnRlciB0IHBvaW50ZXIgPVxuICAgIGRlYnVnXG4gICAgICBcImlkX29mX3BvaW50ZXJcIlxuICAgICAgWyB0IF1cbiAgICAgIHBvaW50ZXJcbiAgICAgIFslc2V4cF9vZjogXyBQb2ludGVyLnRdXG4gICAgICBbJXNleHBfb2Y6IFBvaW50ZXIuSWQudF1cbiAgICAgIChmdW4gKCkgLT4gaWRfb2ZfcG9pbnRlciB0IHBvaW50ZXIpXG4gIDs7XG5cbiAgbGV0IHBvaW50ZXJfb2ZfaWRfZXhuIHQgaWQgPVxuICAgIGRlYnVnXG4gICAgICBcInBvaW50ZXJfb2ZfaWRfZXhuXCJcbiAgICAgIFsgdCBdXG4gICAgICBpZFxuICAgICAgWyVzZXhwX29mOiBQb2ludGVyLklkLnRdXG4gICAgICBbJXNleHBfb2Y6IF8gUG9pbnRlci50XVxuICAgICAgKGZ1biAoKSAtPiBwb2ludGVyX29mX2lkX2V4biB0IGlkKVxuICA7O1xuXG4gIGxldCBwb2ludGVyX2lzX3ZhbGlkIHQgcG9pbnRlciA9XG4gICAgZGVidWdcbiAgICAgIFwicG9pbnRlcl9pc192YWxpZFwiXG4gICAgICBbIHQgXVxuICAgICAgcG9pbnRlclxuICAgICAgWyVzZXhwX29mOiBfIFBvaW50ZXIudF1cbiAgICAgIFslc2V4cF9vZjogYm9vbF1cbiAgICAgIChmdW4gKCkgLT4gcG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXIpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBzbG90cyB+Y2FwYWNpdHkgfmR1bW15ID1cbiAgICBkZWJ1ZyBcImNyZWF0ZVwiIFtdIGNhcGFjaXR5IFslc2V4cF9vZjogaW50XSBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgICAgY3JlYXRlIHNsb3RzIH5jYXBhY2l0eSB+ZHVtbXkpXG4gIDs7XG5cbiAgbGV0IG1heF9jYXBhY2l0eSB+c2xvdHNfcGVyX3R1cGxlID1cbiAgICBkZWJ1ZyBcIm1heF9jYXBhY2l0eVwiIFtdIHNsb3RzX3Blcl90dXBsZSBbJXNleHBfb2Y6IGludF0gWyVzZXhwX29mOiBpbnRdIChmdW4gKCkgLT5cbiAgICAgIG1heF9jYXBhY2l0eSB+c2xvdHNfcGVyX3R1cGxlKVxuICA7O1xuXG4gIGxldCBjYXBhY2l0eSB0ID1cbiAgICBkZWJ1ZyBcImNhcGFjaXR5XCIgWyB0IF0gdCBbJXNleHBfb2Y6IF8gdF0gWyVzZXhwX29mOiBpbnRdIChmdW4gKCkgLT4gY2FwYWNpdHkgdClcbiAgOztcblxuICBsZXQgZ3JvdyA/Y2FwYWNpdHkgdCA9XG4gICAgZGVidWdcbiAgICAgIFwiZ3Jvd1wiXG4gICAgICBbIHQgXVxuICAgICAgKGBjYXBhY2l0eSBjYXBhY2l0eSlcbiAgICAgIFslc2V4cF9vZjogWyBgY2FwYWNpdHkgb2YgaW50IG9wdGlvbiBdXVxuICAgICAgWyVzZXhwX29mOiBfIHRdXG4gICAgICAoZnVuICgpIC0+IGdyb3cgP2NhcGFjaXR5IHQpXG4gIDs7XG5cbiAgbGV0IGlzX2Z1bGwgdCA9XG4gICAgZGVidWcgXCJpc19mdWxsXCIgWyB0IF0gdCBbJXNleHBfb2Y6IF8gdF0gWyVzZXhwX29mOiBib29sXSAoZnVuICgpIC0+IGlzX2Z1bGwgdClcbiAgOztcblxuICBsZXQgdW5zYWZlX2ZyZWUgdCBwID1cbiAgICBkZWJ1ZyBcInVuc2FmZV9mcmVlXCIgWyB0IF0gcCBbJXNleHBfb2Y6IF8gUG9pbnRlci50XSBbJXNleHBfb2Y6IHVuaXRdIChmdW4gKCkgLT5cbiAgICAgIHVuc2FmZV9mcmVlIHQgcClcbiAgOztcblxuICBsZXQgZnJlZSB0IHAgPVxuICAgIGRlYnVnIFwiZnJlZVwiIFsgdCBdIHAgWyVzZXhwX29mOiBfIFBvaW50ZXIudF0gWyVzZXhwX29mOiB1bml0XSAoZnVuICgpIC0+IGZyZWUgdCBwKVxuICA7O1xuXG4gIGxldCBkZWJ1Z19uZXcgdCBmID0gZGVidWcgXCJuZXdcIiBbIHQgXSAoKSBbJXNleHBfb2Y6IHVuaXRdIFslc2V4cF9vZjogXyBQb2ludGVyLnRdIGZcbiAgbGV0IG5ldzEgdCBhMCA9IGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3MSB0IGEwKVxuICBsZXQgbmV3MiB0IGEwIGExID0gZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXcyIHQgYTAgYTEpXG4gIGxldCBuZXczIHQgYTAgYTEgYTIgPSBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzMgdCBhMCBhMSBhMilcbiAgbGV0IG5ldzQgdCBhMCBhMSBhMiBhMyA9IGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3NCB0IGEwIGExIGEyIGEzKVxuICBsZXQgbmV3NSB0IGEwIGExIGEyIGEzIGE0ID0gZGVidWdfbmV3IHQgKGZ1biAoKSAtPiBuZXc1IHQgYTAgYTEgYTIgYTMgYTQpXG4gIGxldCBuZXc2IHQgYTAgYTEgYTIgYTMgYTQgYTUgPSBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzYgdCBhMCBhMSBhMiBhMyBhNCBhNSlcbiAgbGV0IG5ldzcgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiA9IGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3NyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2KVxuXG4gIGxldCBuZXc4IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgPVxuICAgIGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3OCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3KVxuICA7O1xuXG4gIGxldCBuZXc5IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggPVxuICAgIGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3OSB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4KVxuICA7O1xuXG4gIGxldCBuZXcxMCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5ID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzEwIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkpXG4gIDs7XG5cbiAgbGV0IG5ldzExIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzExIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwKVxuICA7O1xuXG4gIGxldCBuZXcxMiB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgPVxuICAgIGRlYnVnX25ldyB0IChmdW4gKCkgLT4gbmV3MTIgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExKVxuICA7O1xuXG4gIGxldCBuZXcxMyB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgYTEyID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzEzIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIpXG4gIDs7XG5cbiAgbGV0IG5ldzE0IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIgYTEzID1cbiAgICBkZWJ1Z19uZXcgdCAoZnVuICgpIC0+IG5ldzE0IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIgYTEzKVxuICA7O1xuXG4gIGxldCBnZXRfdHVwbGUgdCBwb2ludGVyID1cbiAgICBkZWJ1ZyBcImdldF90dXBsZVwiIFsgdCBdIHBvaW50ZXIgWyVzZXhwX29mOiBfIFBvaW50ZXIudF0gWyVzZXhwX29mOiBfXSAoZnVuICgpIC0+XG4gICAgICBnZXRfdHVwbGUgdCBwb2ludGVyKVxuICA7O1xuXG4gIGxldCBkZWJ1Z19nZXQgbmFtZSBmIHQgcG9pbnRlciA9XG4gICAgZGVidWcgbmFtZSBbIHQgXSBwb2ludGVyIFslc2V4cF9vZjogXyBQb2ludGVyLnRdIFslc2V4cF9vZjogX10gKGZ1biAoKSAtPiBmIHQgcG9pbnRlcilcbiAgOztcblxuICBsZXQgZ2V0IHQgcG9pbnRlciBzbG90ID0gZGVidWdfZ2V0IFwiZ2V0XCIgZ2V0IHQgcG9pbnRlciBzbG90XG4gIGxldCB1bnNhZmVfZ2V0IHQgcG9pbnRlciBzbG90ID0gZGVidWdfZ2V0IFwidW5zYWZlX2dldFwiIHVuc2FmZV9nZXQgdCBwb2ludGVyIHNsb3RcblxuICBsZXQgZGVidWdfc2V0IG5hbWUgZiB0IHBvaW50ZXIgc2xvdCBhID1cbiAgICBkZWJ1ZyBuYW1lIFsgdCBdIHBvaW50ZXIgWyVzZXhwX29mOiBfIFBvaW50ZXIudF0gWyVzZXhwX29mOiB1bml0XSAoZnVuICgpIC0+XG4gICAgICBmIHQgcG9pbnRlciBzbG90IGEpXG4gIDs7XG5cbiAgbGV0IHNldCB0IHBvaW50ZXIgc2xvdCBhID0gZGVidWdfc2V0IFwic2V0XCIgc2V0IHQgcG9pbnRlciBzbG90IGFcbiAgbGV0IHVuc2FmZV9zZXQgdCBwb2ludGVyIHNsb3QgYSA9IGRlYnVnX3NldCBcInVuc2FmZV9zZXRcIiB1bnNhZmVfc2V0IHQgcG9pbnRlciBzbG90IGFcbmVuZFxuXG5tb2R1bGUgRXJyb3JfY2hlY2sgKFBvb2wgOiBTKSA9IHN0cnVjdFxuICBvcGVuIFBvb2xcbiAgbW9kdWxlIFNsb3RzID0gU2xvdHNcbiAgbW9kdWxlIFNsb3QgPSBTbG90XG5cbiAgbW9kdWxlIFBvaW50ZXIgPSBzdHJ1Y3RcbiAgICB0eXBlICdzbG90cyB0ID1cbiAgICAgIHsgbXV0YWJsZSBpc192YWxpZCA6IGJvb2xcbiAgICAgIDsgcG9pbnRlciA6ICdzbG90cyBQb2ludGVyLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBzZXhwX29mLCB0eXBlcmVwXVxuXG4gICAgbGV0IGNyZWF0ZSBwb2ludGVyID0geyBpc192YWxpZCA9IHRydWU7IHBvaW50ZXIgfVxuICAgIGxldCBudWxsICgpID0geyBpc192YWxpZCA9IGZhbHNlOyBwb2ludGVyID0gUG9pbnRlci5udWxsICgpIH1cbiAgICBsZXQgcGh5c19jb21wYXJlIHQxIHQyID0gUG9pbnRlci5waHlzX2NvbXBhcmUgdDEucG9pbnRlciB0Mi5wb2ludGVyXG4gICAgbGV0IHBoeXNfZXF1YWwgdDEgdDIgPSBQb2ludGVyLnBoeXNfZXF1YWwgdDEucG9pbnRlciB0Mi5wb2ludGVyXG4gICAgbGV0IGlzX251bGwgdCA9IFBvaW50ZXIuaXNfbnVsbCB0LnBvaW50ZXJcblxuICAgIGxldCBmb2xsb3cgdCA9XG4gICAgICBpZiBub3QgdC5pc192YWxpZFxuICAgICAgdGhlbiBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImF0dGVtcHQgdG8gdXNlIGludmFsaWQgcG9pbnRlclwiIHQgWyVzZXhwX29mOiBfIHRdO1xuICAgICAgdC5wb2ludGVyXG4gICAgOztcblxuICAgIGxldCBpbnZhbGlkYXRlIHQgPSB0LmlzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgICBtb2R1bGUgSWQgPSBQb2ludGVyLklkXG4gIGVuZFxuXG4gIHR5cGUgJ3Nsb3RzIHQgPSAnc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgbGV0IHBvaW50ZXJfaXNfdmFsaWQgdCB7IFBvaW50ZXIuaXNfdmFsaWQ7IHBvaW50ZXIgfSA9XG4gICAgaXNfdmFsaWQgJiYgcG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXJcbiAgOztcblxuICAoKiBXZSBkb24ndCBkbyBbUG9pbnRlci5mb2xsb3cgcG9pbnRlcl0sIGJlY2F1c2UgdGhhdCB3b3VsZCBkaXNhbGxvdyBbaWRfb2ZfcG9pbnRlciB0XG4gICAgIChQb2ludGVyLm51bGwgKCkpXS4gKilcbiAgbGV0IGlkX29mX3BvaW50ZXIgdCBwb2ludGVyID0gaWRfb2ZfcG9pbnRlciB0IHBvaW50ZXIuUG9pbnRlci5wb2ludGVyXG5cbiAgbGV0IHBvaW50ZXJfb2ZfaWRfZXhuIHQgaWQgPVxuICAgIGxldCBwb2ludGVyID0gcG9pbnRlcl9vZl9pZF9leG4gdCBpZCBpblxuICAgIGxldCBpc192YWxpZCA9IFBvb2wucG9pbnRlcl9pc192YWxpZCB0IHBvaW50ZXIgaW5cbiAgICB7IFBvaW50ZXIuaXNfdmFsaWQ7IHBvaW50ZXIgfVxuICA7O1xuXG4gIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHlcbiAgbGV0IG1heF9jYXBhY2l0eSA9IG1heF9jYXBhY2l0eVxuICBsZXQgZ3JvdyA9IGdyb3dcbiAgbGV0IGlzX2Z1bGwgPSBpc19mdWxsXG4gIGxldCBnZXRfdHVwbGUgdCBwID0gZ2V0X3R1cGxlIHQgKFBvaW50ZXIuZm9sbG93IHApXG4gIGxldCBnZXQgdCBwID0gZ2V0IHQgKFBvaW50ZXIuZm9sbG93IHApXG4gIGxldCB1bnNhZmVfZ2V0IHQgcCA9IHVuc2FmZV9nZXQgdCAoUG9pbnRlci5mb2xsb3cgcClcbiAgbGV0IHNldCB0IHAgc2xvdCB2ID0gc2V0IHQgKFBvaW50ZXIuZm9sbG93IHApIHNsb3QgdlxuICBsZXQgdW5zYWZlX3NldCB0IHAgc2xvdCB2ID0gdW5zYWZlX3NldCB0IChQb2ludGVyLmZvbGxvdyBwKSBzbG90IHZcblxuICBsZXQgdW5zYWZlX2ZyZWUgdCBwID1cbiAgICB1bnNhZmVfZnJlZSB0IChQb2ludGVyLmZvbGxvdyBwKTtcbiAgICBQb2ludGVyLmludmFsaWRhdGUgcFxuICA7O1xuXG4gIGxldCBmcmVlIHQgcCA9XG4gICAgZnJlZSB0IChQb2ludGVyLmZvbGxvdyBwKTtcbiAgICBQb2ludGVyLmludmFsaWRhdGUgcFxuICA7O1xuXG4gIGxldCBuZXcxIHQgYTAgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXcxIHQgYTApXG4gIGxldCBuZXcyIHQgYTAgYTEgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXcyIHQgYTAgYTEpXG4gIGxldCBuZXczIHQgYTAgYTEgYTIgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXczIHQgYTAgYTEgYTIpXG4gIGxldCBuZXc0IHQgYTAgYTEgYTIgYTMgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXc0IHQgYTAgYTEgYTIgYTMpXG4gIGxldCBuZXc1IHQgYTAgYTEgYTIgYTMgYTQgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXc1IHQgYTAgYTEgYTIgYTMgYTQpXG4gIGxldCBuZXc2IHQgYTAgYTEgYTIgYTMgYTQgYTUgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXc2IHQgYTAgYTEgYTIgYTMgYTQgYTUpXG4gIGxldCBuZXc3IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgPSBQb2ludGVyLmNyZWF0ZSAoUG9vbC5uZXc3IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYpXG5cbiAgbGV0IG5ldzggdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyA9XG4gICAgUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3OCB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3KVxuICA7O1xuXG4gIGxldCBuZXc5IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzkgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOClcbiAgOztcblxuICBsZXQgbmV3MTAgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSA9XG4gICAgUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3MTAgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSlcbiAgOztcblxuICBsZXQgbmV3MTEgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzExIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwKVxuICA7O1xuXG4gIGxldCBuZXcxMiB0IGEwIGExIGEyIGEzIGE0IGE1IGE2IGE3IGE4IGE5IGExMCBhMTEgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzEyIHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSlcbiAgOztcblxuICBsZXQgbmV3MTMgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMiA9XG4gICAgUG9pbnRlci5jcmVhdGUgKFBvb2wubmV3MTMgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMilcbiAgOztcblxuICBsZXQgbmV3MTQgdCBhMCBhMSBhMiBhMyBhNCBhNSBhNiBhNyBhOCBhOSBhMTAgYTExIGExMiBhMTMgPVxuICAgIFBvaW50ZXIuY3JlYXRlIChQb29sLm5ldzE0IHQgYTAgYTEgYTIgYTMgYTQgYTUgYTYgYTcgYTggYTkgYTEwIGExMSBhMTIgYTEzKVxuICA7O1xuZW5kXG4iXX0=
