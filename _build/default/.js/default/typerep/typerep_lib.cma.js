// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Typerep_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, refl = 0;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, refl, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Caml, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Caml = global_data.Caml,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   var
    _a_ =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"],
    cst_Typename_same_witness_exn = "Typename.same_witness_exn",
    cst_Typename_create = "Typename.create",
    cst_static = "static";
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return caml_call1(Stdlib_Hashtbl[28], a[1]);}
   function name(a){return a[2];}
   var static$0 = next(cst_static);
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     var a = xs, b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var hash$0 = Stdlib_Hashtbl[28], static$1 = [0, static$0, 0];
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){return t[1][2];}
   function create(opt, param){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : caml_call1(Stdlib[2], cst_Typename_same_witness_exn);
   }
   var Key_table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$0]);
   function Table(X){
    function create(int$0){return caml_call1(Key_table[1], int$0);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var _h_ = [0, caml_call2(Key_table[7], table, name)], data = _h_;}
     catch(_i_){
      var _g_ = caml_wrap_exception(_i_);
      if(_g_[1] !== Base[206] && _g_ !== Caml[8])
       throw caml_maybe_attach_backtrace(_g_, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var msg = caml_call3(Stdlib_Printf[4], _a_, uid_a[2], uid_b[2]);
    return caml_call1(Stdlib[2], msg);
   }
   function Same_witness_exn_1(A, B){
    var
     uid_a = caml_call1(A[1], static$1)[1],
     uid_b = caml_call1(B[1], static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     uid_a = caml_call2(A[1], static$1, static$1)[1],
     uid_b = caml_call2(B[1], static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     uid_a = caml_call3(A[1], static$1, static$1, static$1)[1],
     uid_b = caml_call3(B[1], static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     uid_a = caml_call4(A[1], static$1, static$1, static$1, static$1)[1],
     uid_b = caml_call4(B[1], static$1, static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     uid_a =
       caml_call5(A[1], static$1, static$1, static$1, static$1, static$1)[1],
     uid_b =
       caml_call5(B[1], static$1, static$1, static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function _b_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d, e){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
    }
    return [0, typename_of_t];
   }
   function _c_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
    }
    return [0, typename_of_t];
   }
   function _d_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c){
     return [0, uid, [0, a, [0, b, [0, c, 0]]]];
    }
    return [0, typename_of_t];
   }
   function _e_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
    return [0, typename_of_t];
   }
   function _f_(X){
    var uid = next(X[1]);
    function typename_of_t(a){return [0, uid, [0, a, 0]];}
    return [0, typename_of_t];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$1,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (11, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return caml_call3(Stdlib_Array[15], f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return caml_call3(Stdlib_Array[15], f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Assert_failure, Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = caml_call1(Typerep_lib_Typename[11], [0, name])[1],
    typename_of_int32 = caml_call1(Typerep_lib_Typename[11], [0, name$0])[1],
    typename_of_int64 = caml_call1(Typerep_lib_Typename[11], [0, name$1])[1],
    typename_of_nativeint =
      caml_call1(Typerep_lib_Typename[11], [0, name$2])[1],
    typename_of_char = caml_call1(Typerep_lib_Typename[11], [0, name$3])[1],
    typename_of_float = caml_call1(Typerep_lib_Typename[11], [0, name$4])[1],
    typename_of_string = caml_call1(Typerep_lib_Typename[11], [0, name$5])[1],
    typename_of_bytes = caml_call1(Typerep_lib_Typename[11], [0, name$6])[1],
    typename_of_bool = caml_call1(Typerep_lib_Typename[11], [0, name$7])[1],
    typename_of_unit = caml_call1(Typerep_lib_Typename[11], [0, name$8])[1],
    M_option = caml_call1(Typerep_lib_Typename[12], [0, name$9]),
    typename_of_option = M_option[1],
    M_list = caml_call1(Typerep_lib_Typename[12], [0, name$10]),
    typename_of_list = M_list[1],
    M_array = caml_call1(Typerep_lib_Typename[12], [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = caml_call1(Typerep_lib_Typename[12], [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = caml_call1(Typerep_lib_Typename[12], [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = caml_call1(Typerep_lib_Typename[13], [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = caml_call1(Typerep_lib_Typename[11], [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = caml_call1(Typerep_lib_Typename[13], [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = caml_call1(Typerep_lib_Typename[14], [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = caml_call1(Typerep_lib_Typename[15], [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = caml_call1(Typerep_lib_Typename[16], [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]),
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, cst_lib_std_internal_ml, 802, 14],
    _q_ =
      [0,
       [0,
        [0, [0, 0, 0, 0]],
        [0, [0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        0,
        0,
        0,
        0,
        0]];
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var
     ___ = typename_of_t(rep),
     _$_ = caml_call1(Typerep_lib_Typename[9], ___);
    return caml_call1(Typerep_lib_Typename[8][4], _$_);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        _Q_ = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), _Q_);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        _R_ = caml_call1(Typerep[14], c),
        _S_ = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), _S_, _R_);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        _T_ = caml_call1(Typerep[14], d),
        _U_ = caml_call1(Typerep[14], c$0),
        _V_ = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4,
                caml_call1(Typerep[14], a$1),
                _V_,
                _U_,
                _T_);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        _W_ = caml_call1(Typerep[14], e),
        _X_ = caml_call1(Typerep[14], d$0),
        _Y_ = caml_call1(Typerep[14], c$1),
        _Z_ = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5,
                caml_call1(Typerep[14], a$2),
                _Z_,
                _Y_,
                _X_,
                _W_);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = caml_call1(Typerep_lib_Variant_and_record[1], [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        _P_ = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), _P_);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return caml_call1(Named[2], name);
    }
   }
   function same_witness(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      if(typeof t1$0 === "number")
       switch(t1$0){
         case 0:
          if(typeof t2$0 === "number"){if(0 === t2$0) return _a_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 1:
          if(typeof t2$0 === "number"){if(1 === t2$0) return _b_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 2:
          if(typeof t2$0 === "number"){if(2 === t2$0) return _c_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 3:
          if(typeof t2$0 === "number"){if(3 === t2$0) return _d_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 4:
          if(typeof t2$0 === "number"){if(4 === t2$0) return _e_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 5:
          if(typeof t2$0 === "number"){if(5 === t2$0) return _f_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 6:
          if(typeof t2$0 === "number"){if(6 === t2$0) return _g_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 7:
          if(typeof t2$0 === "number"){if(7 === t2$0) return _h_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 8:
          if(typeof t2$0 === "number"){if(8 === t2$0) return _i_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         default:
          if(typeof t2$0 === "number"){if(9 === t2$0) return _j_; break a;}
          if(9 !== t2$0[0]) break a;
       }
      else
       b:
       switch(t1$0[0]){
         case 0:
          var r1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 0:
              var r2$0 = t2$0[1], x = same_witness(r1, r2$0);
              return x ? x : x;
             case 9:
              break b;
           }
          break a;
         case 1:
          var r1$0 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 1:
              var r2$1 = t2$0[1], x$0 = same_witness(r1$0, r2$1);
              return x$0 ? x$0 : x$0;
             case 9:
              break b;
           }
          break a;
         case 2:
          var r1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 2:
              var r2$2 = t2$0[1], x$1 = same_witness(r1$1, r2$2);
              return x$1 ? x$1 : x$1;
             case 9:
              break b;
           }
          break a;
         case 3:
          var r1$2 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 3:
              var r2$3 = t2$0[1], x$2 = same_witness(r1$2, r2$3);
              return x$2 ? x$2 : x$2;
             case 9:
              break b;
           }
          break a;
         case 4:
          var r1$3 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 4:
              var r2$4 = t2$0[1], x$3 = same_witness(r1$3, r2$4);
              return x$3 ? x$3 : x$3;
             case 9:
              break b;
           }
          break a;
         case 5:
          var _w_ = t1$0[1], rng1 = _w_[2], dom1 = _w_[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 5:
              var
               match = t2$0[1],
               rng2 = match[2],
               dom2 = match[1],
               match$0 = same_witness(dom1, dom2),
               match$1 = same_witness(rng1, rng2);
              if(match$0 && match$1) return _k_;
              return 0;
             case 9:
              break b;
           }
          break a;
         case 6:
          var t1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 6:
              var t2$2 = t2$0[1];
              switch(t1$1[0]){
                case 0:
                 var _x_ = t1$1[1];
                 if(0 !== t2$2[0]) return 0;
                 var
                  match$2 = t2$2[1],
                  b2 = match$2[2],
                  a2 = match$2[1],
                  b1 = _x_[2],
                  a1 = _x_[1],
                  match$3 = same_witness(a1, a2),
                  match$4 = same_witness(b1, b2);
                 if(match$3 && match$4) return _l_;
                 return 0;
                case 1:
                 var _y_ = t1$1[1];
                 if(1 !== t2$2[0]) return 0;
                 var
                  match$5 = t2$2[1],
                  c2 = match$5[3],
                  b2$0 = match$5[2],
                  a2$0 = match$5[1],
                  c1 = _y_[3],
                  b1$0 = _y_[2],
                  a1$0 = _y_[1],
                  match$6 = same_witness(a1$0, a2$0),
                  match$7 = same_witness(b1$0, b2$0),
                  match$8 = same_witness(c1, c2);
                 if(match$6 && match$7 && match$8) return _m_;
                 return 0;
                case 2:
                 var _z_ = t1$1[1];
                 if(2 !== t2$2[0]) return 0;
                 var
                  match$9 = t2$2[1],
                  d2 = match$9[4],
                  c2$0 = match$9[3],
                  b2$1 = match$9[2],
                  a2$1 = match$9[1],
                  d1 = _z_[4],
                  c1$0 = _z_[3],
                  b1$1 = _z_[2],
                  a1$1 = _z_[1],
                  match$10 = same_witness(a1$1, a2$1),
                  match$11 = same_witness(b1$1, b2$1),
                  match$12 = same_witness(c1$0, c2$0),
                  match$13 = same_witness(d1, d2);
                 if(match$10 && match$11 && match$12 && match$13) return _n_;
                 return 0;
                default:
                 var _A_ = t1$1[1];
                 if(3 !== t2$2[0]) return 0;
                 var
                  match$14 = t2$2[1],
                  e2 = match$14[5],
                  d2$0 = match$14[4],
                  c2$1 = match$14[3],
                  b2$2 = match$14[2],
                  a2$2 = match$14[1],
                  e1 = _A_[5],
                  d1$0 = _A_[4],
                  c1$1 = _A_[3],
                  b1$2 = _A_[2],
                  a1$2 = _A_[1],
                  match$15 = same_witness(a1$2, a2$2),
                  match$16 = same_witness(b1$2, b2$2),
                  match$17 = same_witness(c1$1, c2$1),
                  match$18 = same_witness(d1$0, d2$0),
                  match$19 = same_witness(e1, e2);
                 if(match$15 && match$16 && match$17 && match$18 && match$19)
                  return _o_;
                 return 0;
              }
             case 9:
              break b;
           }
          break a;
         case 7:
          var r1$4 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 7:
              var
               r2$5 = t2$0[1],
               _B_ = caml_call1(Typerep[10][1], r2$5),
               _C_ = caml_call1(Typerep[10][1], r1$4);
              return caml_call2(Typerep_lib_Typename[4], _C_, _B_);
             case 9:
              break b;
           }
          break a;
         case 8:
          var r1$5 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 8:
              var
               r2$6 = t2$0[1],
               _D_ = caml_call1(Typerep[6][1], r2$6),
               _E_ = caml_call1(Typerep[6][1], r1$5);
              return caml_call2(Typerep_lib_Typename[4], _E_, _D_);
             case 9:
              break b;
           }
          break a;
         default:
          var match$20 = t1$0[1], name1 = match$20[1];
          if(typeof t2$0 !== "number" && 9 === t2$0[0]){
           var
            match$21 = t2$0[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            _H_ = caml_call1(Named[2], name2),
            _I_ = caml_call1(Named[2], name1),
            x$4 = caml_call2(Typerep_lib_Typename[4], _I_, _H_);
           if(x$4) return x$4;
           if(r1$7){
            var _J_ = r1$7[1], _K_ = caml_obj_tag(_J_);
            c:
            if(250 === _K_)
             var t1$3 = _J_[1];
            else{
             if(246 !== _K_ && 244 !== _K_){var t1$3 = _J_; break c;}
             var t1$3 = caml_call1(CamlinternalLazy[2], _J_);
            }
            if(! r2$7){var t1$0 = t1$3; continue;}
            var _L_ = r2$7[1], _M_ = caml_obj_tag(_L_);
            c:
            if(250 === _M_)
             var t2$3 = _L_[1];
            else{
             if(246 !== _M_ && 244 !== _M_){var t2$3 = _L_; break c;}
             var t2$3 = caml_call1(CamlinternalLazy[2], _L_);
            }
            var t1$0 = t1$3, t2$0 = t2$3;
            continue;
           }
           if(! r2$7) return 0;
           var _N_ = r2$7[1], _O_ = caml_obj_tag(_N_);
           c:
           if(250 === _O_)
            var t2$4 = _N_[1];
           else{
            if(246 !== _O_ && 244 !== _O_){var t2$4 = _N_; break c;}
            var t2$4 = caml_call1(CamlinternalLazy[2], _N_);
           }
           var t2$0 = t2$4;
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var _F_ = r1$6[1], _G_ = caml_obj_tag(_F_);
          c:
          if(250 === _G_)
           var t1$2 = _F_[1];
          else{
           if(246 !== _G_ && 244 !== _G_){var t1$2 = _F_; break c;}
           var t1$2 = caml_call1(CamlinternalLazy[2], _F_);
          }
          var t1$0 = t1$2;
          continue;
       }
      var r2 = t2$0[1][2];
      if(! r2) return 0;
      var _u_ = r2[1], _v_ = caml_obj_tag(_u_);
      b:
      if(250 === _v_)
       var t2$1 = _u_[1];
      else{
       if(246 !== _v_ && 244 !== _v_){var t2$1 = _u_; break b;}
       var t2$1 = caml_call1(CamlinternalLazy[2], _u_);
      }
      var t2$0 = t2$1;
      continue;
     }
     if(typeof t1$0 === "number")
      switch(t1$0){
        case 0: break;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        case 8:
         return 0;
        default: return 0;
      }
     else
      switch(t1$0[0]){
        case 9: break;
        case 0:
         return 0;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        default: return 0;
      }
     return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var proof = match[1];
    return proof;
   }
   function head(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 !== "number" && 9 === t$0[0]){
      var _r_ = t$0[1][2];
      if(_r_){
       var _s_ = _r_[1], _t_ = caml_obj_tag(_s_);
       a:
       if(250 === _t_)
        var t$1 = _s_[1];
       else{
        if(246 !== _t_ && 244 !== _t_){var t$1 = _s_; break a;}
        var t$1 = caml_call1(CamlinternalLazy[2], _s_);
       }
       var t$0 = t$1;
       continue;
      }
     }
     return t$0;
    }
   }
   caml_call3
    (CamlinternalMod[2],
     _q_,
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var
    typerep_of_int = 0,
    typerep_of_int32 = 1,
    typerep_of_int64 = 2,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   var typerep_of_tuple0 = 9;
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    value_tuple0 = 0,
    match =
      Base_Int63[114][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Assert_failure, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, cst_lib_typerep_obj_ml, 9, 4],
    _a_ = [0, cst_lib_typerep_obj_ml, 11, 4],
    cst_Latency_stats = "Latency_stats",
    _h_ = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    _g_ = [0, cst_lib_typerep_obj_ml, 29, 9],
    _f_ = [0, cst_lib_typerep_obj_ml, 49, 2],
    _e_ = [0, cst_lib_typerep_obj_ml, 50, 2];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function hash_variant(s){
    var
     accu = [0, 0],
     _k_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _l_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _l_ | 0;
      var _m_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _m_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var _c_ = hash_variant(cst_Latency_stats);
   if(repr_of_poly_variant(-894644482) !== _c_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var _d_ = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== _d_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   var double_array_value = 0.;
   function has_double_array_tag(a){
    var _i_ = runtime.caml_obj_tag(a);
    return Stdlib_Obj[17] === _i_ ? 1 : 0;
   }
   var
    double$0 = [254, double_array_value, double_array_value],
    simple = [0, double_array_value, double_array_value];
   if(! has_double_array_tag(double$0))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Assert_failure, Base, Caml, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Caml = global_data.Caml,
    Typerep_lib_Type_generic_intf = global_data.Typerep_lib__Type_generic_intf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    _c_ =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    _a_ = [0, cst_lib_type_generic_ml, 185, 16],
    _b_ = [0, cst_lib_type_generic_ml, 187, 69],
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    cst_Typerep_lib_Type_generic_I =
      "Typerep_lib.Type_generic.Ident.Broken_dependency";
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant);
     function _az_(index$0){
      var
       tag$0 = caml_call2(A[4][3], variant, index$0),
       tag = tag$0[1],
       label = caml_call1(A[2][1], tag),
       rep = caml_call1(map, caml_call1(A[2][8], tag)),
       arity = caml_call1(A[2][2], tag),
       args_labels = caml_call1(A[2][3], tag),
       index = caml_call1(A[2][4], tag),
       ocaml_repr = caml_call1(A[2][5], tag),
       tyid = caml_call1(A[2][7], tag),
       param = caml_call1(A[2][6], tag);
      if(0 === param[0])
       var fct = param[1], create = [0, fct];
      else
       var k = param[1], create = [1, k];
      return [0,
              caml_call1
               (B[2][9],
                [0,
                 label,
                 rep,
                 arity,
                 args_labels,
                 index,
                 ocaml_repr,
                 tyid,
                 create])];
     }
     var
      _aA_ = caml_call1(A[4][2], variant),
      tags = caml_call2(Stdlib_Array[1], _aA_, _az_);
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       _aB_ = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, _aB_)[1 + _aB_][1],
       _aC_ = caml_call1(B[2][7], btag),
       _aD_ = caml_call1(A[2][7], atag);
      caml_call2(Typerep_lib_Typename[5], _aD_, _aC_);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record);
     function _au_(index$0){
      var
       field$0 = caml_call2(A[8][3], record, index$0),
       field = field$0[1],
       label = caml_call1(A[6][1], field),
       rep = caml_call1(map, caml_call1(A[6][6], field)),
       index = caml_call1(A[6][2], field),
       is_mutable = caml_call1(A[6][4], field),
       tyid = caml_call1(A[6][5], field),
       get = caml_call1(A[6][3], field);
      return [0,
              caml_call1
               (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
     }
     var
      _av_ = caml_call1(A[8][2], record),
      fields = caml_call2(Stdlib_Array[1], _av_, _au_);
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        _aw_ = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, _aw_)[1 + _aw_][1],
        _ax_ = caml_call1(B[6][5], bfield),
        _ay_ = caml_call1(A[6][5], afield);
       caml_call2(Typerep_lib_Typename[5], _ay_, _ax_);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248, cst_Typerep_lib_Type_generic_I, caml_fresh_oo_id(0)],
    _d_ = Typerep_lib_Typename[6];
   caml_call1(Stdlib_Hashtbl[26], [0, _d_[2], _d_[3]]);
   function _e_(X){
    var required = X[2], name = X[1];
    caml_call1(Typerep_lib_Type_generic_intf[1], [0]);
    var
     _k_ = Typerep_lib_Typename[8],
     include = caml_call1(Stdlib_Hashtbl[26], [0, _k_[2], _k_[3]]),
     create = include[1],
     replace = include[10],
     mem = include[11],
     _l_ = include[7];
    function find(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _aq_ = caml_obj_tag(table);
     a:
     if(250 === _aq_)
      var table$0 = table[1];
     else{
      if(246 !== _aq_ && 244 !== _aq_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     try{var _as_ = [0, caml_call2(_l_, table$0, key)]; return _as_;}
     catch(_at_){
      var _ar_ = caml_wrap_exception(_at_);
      if(_ar_[1] !== Base[206] && _ar_ !== Caml[8])
       throw caml_maybe_attach_backtrace(_ar_, 0);
      return 0;
     }
    }
    var
     check_dependencies =
       required
        ? function
         (uid){
          function _an_(param){
           var
            implements$0 = param[2],
            name$0 = param[1],
            _ao_ = 1 - caml_call1(implements$0, uid);
           if(! _ao_) return _ao_;
           var
            _ap_ = caml_call1(Typerep_lib_Typename[8][4], uid),
            message = caml_call4(Stdlib_Printf[4], _c_, name, name$0, _ap_);
           caml_call1(Stdlib[53], message);
           throw caml_maybe_attach_backtrace
                  ([0, Broken_dependency, message], 1);
          }
          return caml_call2(Stdlib_List[17], _an_, required);
         }
        : function(param){return;};
    function replace$0(table, key, value){
     check_dependencies(key);
     var _al_ = caml_obj_tag(table);
     a:
     if(250 === _al_)
      var _am_ = table[1];
     else{
      if(246 !== _al_ && 244 !== _al_){var _am_ = table; break a;}
      var _am_ = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call3(replace, _am_, key, value);
    }
    function mem$0(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _ak_ = caml_obj_tag(table);
     a:
     if(250 === _ak_)
      var table$0 = table[1];
     else{
      if(246 !== _ak_ && 244 !== _ak_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call2(mem, table$0, key);
    }
    var
     size = 256,
     table0 = [246, function(_aj_){return caml_call1(create, size);}],
     table1 = [246, function(_ai_){return caml_call1(create, size);}],
     table2 = [246, function(_ah_){return caml_call1(create, size);}],
     table3 = [246, function(_ag_){return caml_call1(create, size);}],
     table4 = [246, function(_af_){return caml_call1(create, size);}],
     table5 = [246, function(_ae_){return caml_call1(create, size);}];
    function is_registered(uid){
     var ___ = mem$0(table0, uid);
     if(___)
      var _$_ = ___;
     else{
      var _aa_ = mem$0(table1, uid);
      if(_aa_)
       var _$_ = _aa_;
      else{
       var _ab_ = mem$0(table2, uid);
       if(_ab_)
        var _$_ = _ab_;
       else{
        var _ac_ = mem$0(table3, uid);
        if(_ac_)
         var _$_ = _ac_;
        else{
         var _ad_ = mem$0(table4, uid);
         if(! _ad_) return mem$0(table5, uid);
         var _$_ = _ad_;
        }
       }
      }
     }
     return _$_;
    }
    var ident = [0, name, is_registered], unit = Typerep_lib_Typename[2];
    function register0(compute){
     var uid = caml_call1(Typerep_lib_Typename[9], compute[2]);
     return replace$0(table0, uid, compute);
    }
    function register1(compute){
     var
      _Z_ = caml_call1(compute[2], unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Z_);
     return replace$0(table1, uid, compute);
    }
    function register2(compute){
     var
      _Y_ = caml_call2(compute[2], unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Y_);
     return replace$0(table2, uid, compute);
    }
    function register3(compute){
     var
      _X_ = caml_call3(compute[2], unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _X_);
     return replace$0(table3, uid, compute);
    }
    function register4(compute){
     var
      _W_ = caml_call4(compute[2], unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _W_);
     return replace$0(table4, uid, compute);
    }
    function register5(compute){
     var
      _V_ = caml_call5(compute[2], unit, unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _V_);
     return replace$0(table5, uid, compute);
    }
    function register(typerep_of_a, compute){
     var
      typename_of_t =
        caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
     return register0([0, typerep_of_a, typename_of_t, compute]);
    }
    var
     Not_implemented =
       [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
     Memo = caml_call1(Typerep_lib_Typename[17], [0]),
     _m_ = Typerep_lib_Std_internal[1],
     Helper$0 =
       Helper
        ([0, _m_[3], _m_[4], _m_[5], _m_[6], _m_[7], _m_[8], _m_[9], _m_[10]],
         [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
    function of_typerep(rep){
     var
      context = caml_call1(X[33][1][1], 0),
      memo_table = caml_call1(Memo[1], 32);
     function of_typerep(param){
      var param$0 = param;
      for(;;){
       if(typeof param$0 === "number")
        switch(param$0){
          case 0:
           return X[11];
          case 1:
           return X[12];
          case 2:
           return X[13];
          case 3:
           return X[14];
          case 4:
           return X[15];
          case 5:
           return X[16];
          case 6:
           return X[17];
          case 7:
           return X[18];
          case 8:
           return X[19];
          default: return X[20];
        }
       switch(param$0[0]){
         case 0:
          var rep$11 = param$0[1], _J_ = of_typerep(rep$11);
          return caml_call1(X[21], _J_);
         case 1:
          var rep$12 = param$0[1], _K_ = of_typerep(rep$12);
          return caml_call1(X[22], _K_);
         case 2:
          var rep$13 = param$0[1], _L_ = of_typerep(rep$13);
          return caml_call1(X[23], _L_);
         case 3:
          var rep$14 = param$0[1], _M_ = of_typerep(rep$14);
          return caml_call1(X[24], _M_);
         case 4:
          var rep$15 = param$0[1], _N_ = of_typerep(rep$15);
          return caml_call1(X[25], _N_);
         case 5:
          var
           match$11 = param$0[1],
           rng = match$11[2],
           dom = match$11[1],
           _O_ = of_typerep(rng),
           _P_ = of_typerep(dom);
          return caml_call2(X[26], _P_, _O_);
         case 6:
          var tuple = param$0[1];
          switch(tuple[0]){
            case 0:
             var
              match$12 = tuple[1],
              b = match$12[2],
              a = match$12[1],
              ra = of_typerep(a),
              rb = of_typerep(b);
             return caml_call2(X[27], ra, rb);
            case 1:
             var
              match$13 = tuple[1],
              c = match$13[3],
              b$0 = match$13[2],
              a$0 = match$13[1],
              ra$0 = of_typerep(a$0),
              rb$0 = of_typerep(b$0),
              rc = of_typerep(c);
             return caml_call3(X[28], ra$0, rb$0, rc);
            case 2:
             var
              match$14 = tuple[1],
              d = match$14[4],
              c$0 = match$14[3],
              b$1 = match$14[2],
              a$1 = match$14[1],
              ra$1 = of_typerep(a$1),
              rb$1 = of_typerep(b$1),
              rc$0 = of_typerep(c$0),
              rd = of_typerep(d);
             return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
            default:
             var
              match$15 = tuple[1],
              e = match$15[5],
              d$0 = match$15[4],
              c$1 = match$15[3],
              b$2 = match$15[2],
              a$2 = match$15[1],
              ra$2 = of_typerep(a$2),
              rb$2 = of_typerep(b$2),
              rc$1 = of_typerep(c$1),
              rd$0 = of_typerep(d$0),
              re = of_typerep(e);
             return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
          }
         case 7:
          var
           record = param$0[1],
           _Q_ = caml_call2(Helper$0[2], [0, of_typerep], record);
          return caml_call1(X[31], _Q_);
         case 8:
          var
           variant = param$0[1],
           _R_ = caml_call2(Helper$0[1], [0, of_typerep], variant);
          return caml_call1(X[32], _R_);
         default:
          var
           match$16 = param$0[1],
           content = match$16[2],
           named = match$16[1],
           typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
           match$17 = caml_call2(Memo[4], memo_table, typename);
          if(match$17){
           var shared = match$17[1];
           return caml_call1(X[33][3], shared);
          }
          switch(named[0]){
            case 0:
             var
              rep$5 = named[1],
              match =
                find(table0, caml_call1(Typerep_lib_Typename[9], rep$5[2]));
             if(match)
              var
               rep = match[1],
               witness = caml_call2(Typerep_lib_Typename[5], rep[2], rep$5[1]),
               L = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _n_ = rep[3],
               _o_ = caml_call1(L[1], witness),
               match$5 = [0, caml_call2(Typerep_lib_Type_equal[1], _o_, _n_)];
             else
              var match$5 = 0;
             if(match$5)
              var custom = match$5[1], match$18 = [0, custom];
             else
              var match$18 = 0;
             break;
            case 1:
             var
              rep$6 = named[1],
              match$0 =
                find(table1, caml_call1(Typerep_lib_Typename[9], rep$6[3]));
             if(match$0)
              var
               rep$0 = match$0[1],
               typename_of_t = rep$6[2],
               Conv =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[18], [0, rep$0[2]]),
                   [0, typename_of_t]),
               L$0 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _p_ = rep$0[3],
               _q_ = caml_call1(L$0[1], Conv[1][1]),
               match$6 = [0, caml_call2(Typerep_lib_Type_equal[1], _q_, _p_)];
             else
              var match$6 = 0;
             if(match$6)
              var
               custom$0 = match$6[1],
               custom$1 = caml_call1(custom$0, of_typerep(rep$6[1])),
               match$18 = [0, custom$1];
             else
              var match$18 = 0;
             break;
            case 2:
             var
              rep$7 = named[1],
              match$1 =
                find(table2, caml_call1(Typerep_lib_Typename[9], rep$7[4]));
             if(match$1)
              var
               rep$1 = match$1[1],
               typename_of_t$0 = rep$7[3],
               Conv$0 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[19], [0, rep$1[2]]),
                   [0, typename_of_t$0]),
               L$1 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _r_ = rep$1[3],
               _s_ = caml_call1(L$1[1], Conv$0[1][1]),
               match$7 = [0, caml_call2(Typerep_lib_Type_equal[1], _s_, _r_)];
             else
              var match$7 = 0;
             if(match$7)
              var
               custom$2 = match$7[1],
               _z_ = of_typerep(rep$7[2]),
               custom$3 = caml_call2(custom$2, of_typerep(rep$7[1]), _z_),
               match$18 = [0, custom$3];
             else
              var match$18 = 0;
             break;
            case 3:
             var
              rep$8 = named[1],
              match$2 =
                find(table3, caml_call1(Typerep_lib_Typename[9], rep$8[5]));
             if(match$2)
              var
               rep$2 = match$2[1],
               typename_of_t$1 = rep$8[4],
               Conv$1 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[20], [0, rep$2[2]]),
                   [0, typename_of_t$1]),
               L$2 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _t_ = rep$2[3],
               _u_ = caml_call1(L$2[1], Conv$1[1][1]),
               match$8 = [0, caml_call2(Typerep_lib_Type_equal[1], _u_, _t_)];
             else
              var match$8 = 0;
             if(match$8)
              var
               custom$4 = match$8[1],
               _A_ = of_typerep(rep$8[3]),
               _B_ = of_typerep(rep$8[2]),
               custom$5 = caml_call3(custom$4, of_typerep(rep$8[1]), _B_, _A_),
               match$18 = [0, custom$5];
             else
              var match$18 = 0;
             break;
            case 4:
             var
              rep$9 = named[1],
              match$3 =
                find(table4, caml_call1(Typerep_lib_Typename[9], rep$9[6]));
             if(match$3)
              var
               rep$3 = match$3[1],
               typename_of_t$2 = rep$9[5],
               Conv$2 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[21], [0, rep$3[2]]),
                   [0, typename_of_t$2]),
               L$3 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _v_ = rep$3[3],
               _w_ = caml_call1(L$3[1], Conv$2[1][1]),
               match$9 = [0, caml_call2(Typerep_lib_Type_equal[1], _w_, _v_)];
             else
              var match$9 = 0;
             if(match$9)
              var
               custom$6 = match$9[1],
               _C_ = of_typerep(rep$9[4]),
               _D_ = of_typerep(rep$9[3]),
               _E_ = of_typerep(rep$9[2]),
               custom$7 =
                 caml_call4(custom$6, of_typerep(rep$9[1]), _E_, _D_, _C_),
               match$18 = [0, custom$7];
             else
              var match$18 = 0;
             break;
            default:
             var
              rep$10 = named[1],
              match$4 =
                find(table5, caml_call1(Typerep_lib_Typename[9], rep$10[7]));
             if(match$4)
              var
               rep$4 = match$4[1],
               typename_of_t$3 = rep$10[6],
               Conv$3 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[22], [0, rep$4[2]]),
                   [0, typename_of_t$3]),
               L$4 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _x_ = rep$4[3],
               _y_ = caml_call1(L$4[1], Conv$3[1][1]),
               match$10 = [0, caml_call2(Typerep_lib_Type_equal[1], _y_, _x_)];
             else
              var match$10 = 0;
             if(match$10)
              var
               custom$8 = match$10[1],
               _F_ = of_typerep(rep$10[5]),
               _G_ = of_typerep(rep$10[4]),
               _H_ = of_typerep(rep$10[3]),
               _I_ = of_typerep(rep$10[2]),
               custom$9 =
                 caml_call5
                  (custom$8, of_typerep(rep$10[1]), _I_, _H_, _G_, _F_),
               match$18 = [0, custom$9];
             else
              var match$18 = 0;
          }
          if(match$18){var computation = match$18[1]; return computation;}
          if(! content){
           var
            _U_ = caml_call1(Typerep_lib_Typename[9], typename),
            string = caml_call1(Typerep_lib_Typename[8][4], _U_);
           throw caml_maybe_attach_backtrace
                  ([0, Not_implemented, name, string], 1);
          }
          var _S_ = content[1], _T_ = caml_obj_tag(_S_);
          a:
          if(250 === _T_)
           var content$0 = _S_[1];
          else{
           if(246 !== _T_ && 244 !== _T_){var content$0 = _S_; break a;}
           var content$0 = caml_call1(CamlinternalLazy[2], _S_);
          }
          if(caml_call1(X[33][5], content$0)){
           var shared$0 = caml_call2(X[33][2], context, typename);
           caml_call3(Memo[3], memo_table, typename, shared$0);
           var computation$0 = of_typerep(content$0);
           return caml_call2(X[33][4], shared$0, computation$0);
          }
          var param$0 = content$0;
       }
      }
     }
     var computation = of_typerep(rep);
     return [0, 911962647, computation];
    }
    return [0,
            ident,
            Not_implemented,
            register0,
            register1,
            register2,
            register3,
            register4,
            register5,
            register,
            of_typerep,
            [0,
             X[3],
             X[4],
             X[5],
             X[6],
             X[7],
             X[8],
             X[9],
             X[10],
             X[11],
             X[12],
             X[13],
             X[14],
             X[15],
             X[16],
             X[17],
             X[18],
             X[19],
             X[20],
             X[21],
             X[22],
             X[23],
             X[24],
             X[25],
             X[26],
             X[27],
             X[28],
             X[29],
             X[30],
             X[31],
             X[32],
             X[33]]];
   }
   var
    _f_ = [0],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_g_){
        function create(_j_){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          _h_ = caml_call1(Typerep_lib_Typename[9], name),
          path = caml_call1(Typerep_lib_Typename[8][4], _h_),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }],
          _i_ = [0, 0];
         return [0, function(input){return caml_call1(r[1], input);}, r, _i_];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         if(caml_call2(Base[204], shared[1], computation))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       _f_,
       _e_];
   runtime.caml_register_global
    (21, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename;
   function _a_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[16], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4, of_p5){
     var
      _p_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
      _q_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _r_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _s_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _t_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call5(Name_of_x[1], _t_, _s_, _r_, _q_, _p_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [5,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              of_p5,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _b_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[15], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4){
     var
      _l_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _m_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _n_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _o_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call4(Name_of_x[1], _o_, _n_, _m_, _l_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [4,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _c_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[14], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3){
     var
      _i_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _j_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _k_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call3(Name_of_x[1], _k_, _j_, _i_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [3,
             [0,
              of_p1,
              of_p2,
              of_p3,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _d_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[13], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2){
     var
      _g_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _h_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call2(Name_of_x[1], _h_, _g_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [2, [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   function _e_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[12], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1){
     var
      _f_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call1(Name_of_x[1], _f_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   var
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[11], X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       _e_,
       _d_,
       _c_,
       _b_,
       _a_];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = caml_call1(Typerep_lib_Make_typename[1], X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = caml_call1(Typerep_lib_Make_typename[2], X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = caml_call1(Typerep_lib_Make_typename[3], X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = caml_call1(Typerep_lib_Make_typename[4], X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = caml_call1(Typerep_lib_Make_typename[5], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = caml_call1(Typerep_lib_Make_typename[6], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicmVmbCIsImNvbnYiLCJ4IiwibGlmdCIsImNvbXBhcmUiLCJhIiwiYiIsImVxdWFsIiwidWlkIiwibmV4dCIsIm5hbWUiLCJjb2RlIiwiaGFzaCIsInN0YXRpYyQwIiwiY29tcGFyZSQwIiwiazEiLCJrMiIsImNtcCIsImIkMCIsImEkMCIsInlzIiwieSIsInhzIiwibiIsImVxdWFsJDAiLCJoYXNoJDAiLCJzdGF0aWMkMSIsImtleSIsInQiLCJ1aWQkMCIsIm5hbWUkMCIsImNyZWF0ZSIsIm9wdCIsInN0aCIsInNhbWUiLCJubTEiLCJubTIiLCJzYW1lX3dpdG5lc3MiLCJzYW1lX3dpdG5lc3NfZXhuIiwiaW50JDAiLCJtZW0iLCJ0YWJsZSIsInNldCIsImRhdGEiLCJmaW5kIiwiZGF0YSQwIiwiZmFpbCIsInVpZF9hIiwidWlkX2IiLCJtc2ciLCJ3aXRuZXNzIiwidHlwZW5hbWVfb2ZfdCIsImMiLCJkIiwiZSIsImxhYmVsIiwiYXJpdHkiLCJhcmdzX2xhYmVscyIsImluZGV4Iiwib2NhbWxfcmVwciIsInR5aWQiLCJ0cmF2ZXJzZSIsImludGVybmFsX3VzZV9vbmx5IiwibGVuZ3RoIiwidGFnIiwiaXNfcG9seW1vcnBoaWMiLCJ2YWx1ZSIsImZvbGQiLCJpbml0IiwiZiIsImludGVybmFsX3VzZV9vbmx5JDAiLCJsYWJlbCQwIiwiaW5kZXgkMCIsImdldCIsImlzX211dGFibGUiLCJ0eWlkJDAiLCJ0cmF2ZXJzZSQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMSIsInR5cGVuYW1lX29mX3QkMCIsImxlbmd0aCQwIiwiZmllbGQiLCJoYXNfZG91YmxlX2FycmF5X3RhZyIsImNyZWF0ZSQwIiwiZm9sZCQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMiIsIm5hbWUkMSIsIm5hbWUkMiIsIm5hbWUkMyIsIm5hbWUkNCIsIm5hbWUkNSIsIm5hbWUkNiIsIm5hbWUkNyIsIm5hbWUkOCIsIm5hbWUkOSIsIm5hbWUkMTAiLCJuYW1lJDExIiwibmFtZSQxMiIsIm5hbWUkMTMiLCJuYW1lJDE0IiwibmFtZSQxNSIsIm5hbWUkMTYiLCJuYW1lJDE3IiwibmFtZSQxOCIsIm5hbWUkMTkiLCJ0eXBlbmFtZV9vZl9pbnQiLCJ0eXBlbmFtZV9vZl9pbnQzMiIsInR5cGVuYW1lX29mX2ludDY0IiwidHlwZW5hbWVfb2ZfbmF0aXZlaW50IiwidHlwZW5hbWVfb2ZfY2hhciIsInR5cGVuYW1lX29mX2Zsb2F0IiwidHlwZW5hbWVfb2Zfc3RyaW5nIiwidHlwZW5hbWVfb2ZfYnl0ZXMiLCJ0eXBlbmFtZV9vZl9ib29sIiwidHlwZW5hbWVfb2ZfdW5pdCIsInR5cGVuYW1lX29mX29wdGlvbiIsInR5cGVuYW1lX29mX2xpc3QiLCJ0eXBlbmFtZV9vZl9hcnJheSIsInR5cGVuYW1lX29mX2xhenlfdCIsInR5cGVuYW1lX29mX3JlZiIsInR5cGVuYW1lX29mX2Z1bmN0aW9uIiwidHlwZW5hbWVfb2ZfdHVwbGUwIiwidHlwZW5hbWVfb2ZfdHVwbGUyIiwidHlwZW5hbWVfb2ZfdHVwbGUzIiwidHlwZW5hbWVfb2ZfdHVwbGU0IiwidHlwZW5hbWVfb2ZfdHVwbGU1IiwicmVwIiwicmVwJDAiLCJyZXAkMSIsInJlcCQyIiwicmVwJDMiLCJyZXAkNCIsIm5hbWUkMjAiLCJhcml0eSQwIiwiYyQwIiwiYiQxIiwiYSQxIiwiZCQwIiwiYyQxIiwiYiQyIiwiYSQyIiwidHlwZW5hbWVfb2ZfdCQxIiwicm5nIiwiZG9tIiwicmVwJDUiLCJyZXAkNiIsInQxIiwidDIiLCJ0MSQwIiwidDIkMCIsInIxIiwicjIkMCIsInIxJDAiLCJyMiQxIiwieCQwIiwicjEkMSIsInIyJDIiLCJ4JDEiLCJyMSQyIiwicjIkMyIsIngkMiIsInIxJDMiLCJyMiQ0IiwieCQzIiwicm5nMSIsImRvbTEiLCJybmcyIiwiZG9tMiIsInQxJDEiLCJ0MiQyIiwiYjIiLCJhMiIsImIxIiwiYTEiLCJjMiIsImIyJDAiLCJhMiQwIiwiYzEiLCJiMSQwIiwiYTEkMCIsImQyIiwiYzIkMCIsImIyJDEiLCJhMiQxIiwiZDEiLCJjMSQwIiwiYjEkMSIsImExJDEiLCJlMiIsImQyJDAiLCJjMiQxIiwiYjIkMiIsImEyJDIiLCJlMSIsImQxJDAiLCJjMSQxIiwiYjEkMiIsImExJDIiLCJyMSQ0IiwicjIkNSIsInIxJDUiLCJyMiQ2IiwibmFtZTEiLCJyMiQ3IiwibmFtZTIiLCJyMSQ3IiwieCQ0IiwidDEkMyIsInQyJDMiLCJ0MiQ0IiwicjEkNiIsInQxJDIiLCJyMiIsInQyJDEiLCJwcm9vZiIsImhlYWQiLCJ0JDAiLCJ0JDEiLCJ0eXBlcmVwX29mX2ludCIsInR5cGVyZXBfb2ZfaW50MzIiLCJ0eXBlcmVwX29mX2ludDY0IiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2NoYXIiLCJ0eXBlcmVwX29mX2Zsb2F0IiwidHlwZXJlcF9vZl9zdHJpbmciLCJ0eXBlcmVwX29mX2J5dGVzIiwidHlwZXJlcF9vZl9ib29sIiwidHlwZXJlcF9vZl91bml0IiwidHlwZXJlcF9vZl9vcHRpb24iLCJ0eXBlcmVwX29mX2xpc3QiLCJ0eXBlcmVwX29mX2FycmF5IiwidHlwZXJlcF9vZl9sYXp5X3QiLCJ0eXBlcmVwX29mX3JlZiIsInR5cGVyZXBfb2ZfZnVuY3Rpb24iLCJ0eXBlcmVwX29mX3R1cGxlMCIsInR5cGVyZXBfb2ZfdHVwbGUyIiwidHlwZXJlcF9vZl90dXBsZTMiLCJ0eXBlcmVwX29mX3R1cGxlNCIsInR5cGVyZXBfb2ZfdHVwbGU1IiwidmFsdWVfdHVwbGUwIiwidHlwZW5hbWVfb2ZfaW50NjMiLCJ0eXBlcmVwX29mX2ludDYzIiwicmVwcl9vZl9wb2x5X3ZhcmlhbnQiLCJ2YXJpYW50Iiwic2l6ZSIsInJlcHIiLCJoYXNoX3ZhcmlhbnQiLCJzIiwiYWNjdSIsImkiLCJkb3VibGVfYXJyYXlfdmFsdWUiLCJkb3VibGUkMCIsInNpbXBsZSIsIm1hcF92YXJpYW50IiwibWFwIiwidHlwZW5hbWUiLCJwb2x5bW9ycGhpYyIsInRhZyQwIiwiZmN0IiwiayIsInRhZ3MiLCJhdGFnIiwiYnRhZyIsIm1hcF9yZWNvcmQiLCJyZWNvcmQiLCJmaWVsZCQwIiwiZmllbGRzIiwiZ2V0JDAiLCJhZmllbGQiLCJiZmllbGQiLCJyZXF1aXJlZCIsInRhYmxlJDAiLCJjaGVja19kZXBlbmRlbmNpZXMiLCJpbXBsZW1lbnRzJDAiLCJtZXNzYWdlIiwicmVwbGFjZSQwIiwibWVtJDAiLCJ0YWJsZTAiLCJ0YWJsZTEiLCJ0YWJsZTIiLCJ0YWJsZTMiLCJ0YWJsZTQiLCJ0YWJsZTUiLCJpc19yZWdpc3RlcmVkIiwiaWRlbnQiLCJ1bml0IiwicmVnaXN0ZXIwIiwiY29tcHV0ZSIsInJlZ2lzdGVyMSIsInJlZ2lzdGVyMiIsInJlZ2lzdGVyMyIsInJlZ2lzdGVyNCIsInJlZ2lzdGVyNSIsInJlZ2lzdGVyIiwidHlwZXJlcF9vZl9hIiwib2ZfdHlwZXJlcCIsImNvbnRleHQiLCJtZW1vX3RhYmxlIiwicmVwJDExIiwicmVwJDEyIiwicmVwJDEzIiwicmVwJDE0IiwicmVwJDE1IiwidHVwbGUiLCJyYSIsInJiIiwicmEkMCIsInJiJDAiLCJyYyIsInJhJDEiLCJyYiQxIiwicmMkMCIsInJkIiwicmEkMiIsInJiJDIiLCJyYyQxIiwicmQkMCIsInJlIiwiY29udGVudCIsIm5hbWVkIiwic2hhcmVkIiwiY3VzdG9tIiwiY3VzdG9tJDAiLCJjdXN0b20kMSIsInJlcCQ3IiwiY3VzdG9tJDIiLCJjdXN0b20kMyIsInJlcCQ4IiwiY3VzdG9tJDQiLCJjdXN0b20kNSIsInJlcCQ5IiwidHlwZW5hbWVfb2ZfdCQyIiwiY3VzdG9tJDYiLCJjdXN0b20kNyIsInJlcCQxMCIsInR5cGVuYW1lX29mX3QkMyIsImN1c3RvbSQ4IiwiY3VzdG9tJDkiLCJjb21wdXRhdGlvbiIsInN0cmluZyIsImNvbnRlbnQkMCIsInNoYXJlZCQwIiwiY29tcHV0YXRpb24kMCIsInBhdGgiLCJyIiwiaW5wdXQiLCJnZXRfd2lwX2NvbXB1dGF0aW9uIiwiY2xvcyIsInNldF9maW5hbF9jb21wdXRhdGlvbiIsImNvbXBpbGV0aW1lX2RlcmVmZXJlbmNlIiwic2hhcmUiLCJvZl9wMSIsIm9mX3AyIiwib2ZfcDMiLCJvZl9wNCIsIm9mX3A1IiwidHlwZW5hbWVfb2ZfbmFtZWQiLCJ0eXBlcmVwX29mX3QiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3R5cGVyZXAvdHlwZV9lcXVhbC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvdHlwZXJlcC90eXBlbmFtZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvdHlwZXJlcC92YXJpYW50X2FuZF9yZWNvcmRfaW50Zi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvdHlwZXJlcC9zdGRfaW50ZXJuYWwubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3R5cGVyZXAvdHlwZXJlcF9vYmoubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3R5cGVyZXAvdHlwZV9nZW5lcmljX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3R5cGVyZXAvdHlwZV9nZW5lcmljLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi90eXBlcmVwL21ha2VfdHlwZW5hbWUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3R5cGVyZXAvdHlwZV9hYnN0cmFjdC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7O0U7Ozs7OzswQ0FHSUE7WUFDQUMsWUFBNENDLEdBQUssT0FBTEEsRUFBTTs2QkFNaERDLFlBQW9ELFNBQUMsRUFEM0QsV0FDTUE7b0NBTkZGLE1BREFEOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDOEJFSSxRQUFRQyxHQUFFQyxHQUFJLGdDQUFORCxNQUFFQyxNQUFp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QkY7O1NBSEVBO1NBUU1nVDtTQUVBalQ7U0FSTjRRLGdCQU1NcUMsbUJBUk5oVCxlQVVNRDttQkFSTjRRLE9BRkEzUTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDQWU7O0tBQWZpVDtLQUNBalQ7SUFKZ0UsV0FHaEVpVCxjQUNBalQ7Ozs7YUFNQWlULGFBQWFOLE9BQVEsZUFBZSxpQkFBdkJBLFlBQTJDO1FBQ3hEM1M7SUFKdUUsV0FHdkVpVCxjQUNBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DO0tBQVEsZUFBZSxpQkFBN0JELE9BQU1DO0lBQWlEO1FBQ3BFNVM7SUFKTixXQUdNaVQsY0FDQWpUOzs7O2FBT0FpVCxhQUFhTixPQUFNQyxPQUFNQztLQUFRLGVBQWUsaUJBQW5DRixPQUFNQyxPQUFNQztJQUF1RDtRQUNoRjdTO0lBSjBELFdBRzFEaVQsY0FDQWpUOzs7O2FBT0FpVCxhQUFhTixPQUFNQyxPQUFNQyxPQUFNQztLQUNqQyxlQUFlLGlCQURBSCxPQUFNQyxPQUFNQyxPQUFNQztJQUNvQjtRQUduRDlTO0lBUGtFLFdBR2xFaVQsY0FJQWpUOzs7O2FBT0FpVCxhQUFhTixPQUFNQyxPQUFNQyxPQUFNQyxPQUFNQztLQUN2QyxlQUFlLGlCQURBSixPQUFNQyxPQUFNQyxPQUFNQyxPQUFNQztJQUNvQjtRQUd6RC9TO0lBUDBFLFdBRzFFaVQsY0FJQWpUOzs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgQmFzZS5UeXBlX2VxdWFsLnQgPSBUIDogKCdhLCAnYSkgdFxudHlwZSAoJ2EsICdiKSBlcXVhbCA9ICgnYSwgJ2IpIHRcblxubGV0IHJlZmwgPSBUXG5sZXQgY29udiA6IHR5cGUgYSBiLiAoYSwgYikgdCAtPiBhIC0+IGIgPSBmdW4gVCB4IC0+IHhcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChhIFgudCwgYiBYLnQpIHQgPSBUXG5lbmRcbiIsIigqIHRoaXMgbGliIHNob3VsZCBub3QgZGVwZW5kIG9uIGNvcmUgKilcbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGluY2x1ZGUgTGlzdFxuXG4gIGxldCBjb21wYXJlIGNtcCBhIGIgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgPVxuICAgICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgICB8IFtdLCBbXSAtPiAwXG4gICAgICB8IFtdLCBfIC0+IC0xXG4gICAgICB8IF8sIFtdIC0+IDFcbiAgICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgICBsZXQgbiA9IGNtcCB4IHkgaW5cbiAgICAgICAgaWYgbiA9IDAgdGhlbiBsb29wIHhzIHlzIGVsc2UgblxuICAgIGluXG4gICAgbG9vcCBhIGJcbiAgOztcbmVuZFxuXG5tb2R1bGUgVWlkIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgbmV4dCA6IHN0cmluZyAtPiB0XG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbiAgdmFsIG5hbWUgOiB0IC0+IHN0cmluZ1xuICB2YWwgc3RhdGljIDogdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBjb2RlIDogaW50XG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgfVxuXG4gIGxldCBjb21wYXJlIGEgYiA9IGNvbXBhcmUgKGEuY29kZSA6IGludCkgYi5jb2RlXG4gIGxldCBlcXVhbCBhIGIgPSAoYS5jb2RlIDogaW50KSA9IGIuY29kZVxuICBsZXQgdWlkID0gcmVmIDBcblxuICBsZXQgbmV4dCBuYW1lID1cbiAgICBsZXQgY29kZSA9ICF1aWQgaW5cbiAgICBpbmNyIHVpZDtcbiAgICB7IGNvZGU7IG5hbWUgfVxuICA7O1xuXG4gIGxldCBoYXNoIGEgPSBIYXNodGJsLmhhc2ggYS5jb2RlXG4gIGxldCBuYW1lIGEgPSBhLm5hbWVcbiAgbGV0IHN0YXRpYyA9IG5leHQgXCJzdGF0aWNcIlxuZW5kXG5cbm1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHVpZCA6IFVpZC50XG4gICAgOyBwYXJhbXMgOiB0IGxpc3RcbiAgICB9XG5cbiAgbGV0IHJlYyBjb21wYXJlIGsxIGsyID1cbiAgICBpZiBrMSA9PSBrMlxuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNtcCA9IFVpZC5jb21wYXJlIGsxLnVpZCBrMi51aWQgaW5cbiAgICAgIGlmIGNtcCA8PiAwIHRoZW4gY21wIGVsc2UgTGlzdC5jb21wYXJlIGNvbXBhcmUgazEucGFyYW1zIGsyLnBhcmFtcylcbiAgOztcblxuICBsZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG4gIGxldCBoYXNoID0gKEhhc2h0YmwuaGFzaCA6IHQgLT4gaW50KVxuICBsZXQgc3RhdGljID0geyB1aWQgPSBVaWQuc3RhdGljOyBwYXJhbXMgPSBbXSB9XG5lbmRcblxudHlwZSAnYSB0ID0gS2V5LnRcbnR5cGUgJ2EgdHlwZW5hbWUgPSAnYSB0XG5cbmxldCBrZXkgdCA9IHRcbmxldCB1aWQgdCA9IHQuS2V5LnVpZFxubGV0IG5hbWUgdCA9IFVpZC5uYW1lIHQuS2V5LnVpZFxubGV0IHN0YXRpYyA9IEtleS5zdGF0aWNcbmxldCBjcmVhdGUgPyhuYW1lID0gXCJUeXBlbmFtZS5jcmVhdGVcIikgKCkgPSB7IEtleS51aWQgPSBVaWQubmV4dCBuYW1lOyBwYXJhbXMgPSBbXSB9XG5cbmluY2x1ZGUgc3RydWN0XG4gICgqIFRoZSBhcmd1bWVudCBmb3IgT2JqLm1hZ2ljIGhlcmUgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSBpbiBjb3JlL3R5cGVfZXF1YWwgKilcblxuICBsZXQgc2FtZSAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID0gS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcblxuICBsZXQgc2FtZV93aXRuZXNzICh0eXBlIGEgYikgKG5tMSA6IGEgdCkgKG5tMiA6IGIgdCkgPVxuICAgIGlmIEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG4gICAgdGhlbiBTb21lIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gKE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgOiAoYSwgYikgVHlwZV9lcXVhbC50KVxuICAgIGVsc2UgZmFpbHdpdGggXCJUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuXCJcbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHR5cGVuYW1lIC0+ICdhIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHR5cGVuYW1lIC0+ICdiIHR5cGVuYW1lIC0+ICgnYSwgJ2IpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAnYyB0eXBlbmFtZSAtPiAoJ2EsICdiLCAnYykgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFM0ID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3RcbiAgICA6ICAnYSB0eXBlbmFtZVxuICAgIC0+ICdiIHR5cGVuYW1lXG4gICAgLT4gJ2MgdHlwZW5hbWVcbiAgICAtPiAnZCB0eXBlbmFtZVxuICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFM1ID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAnZSB0eXBlbmFtZVxuICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90ID0geyBLZXkudWlkOyBwYXJhbXMgPSBbXSB9XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGEgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYiBdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBOYW1lZF9pbnRmLlMzKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgYiBjID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGMgXSB9XG5lbmRcblxubW9kdWxlIE1ha2U0IChYIDogTmFtZWRfaW50Zi5TNCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyBkID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQgXSB9XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyBkIGUgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYjsgYzsgZDsgZSBdIH1cbmVuZFxuXG5tb2R1bGUgS2V5X3RhYmxlID0gSGFzaHRibC5NYWtlIChLZXkpXG5cbm1vZHVsZSBUYWJsZSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIGRhdGEgPSBEYXRhIDogJ2EgdCAqICdhIFgudCAtPiBkYXRhXG4gIHR5cGUgdCA9IGRhdGEgS2V5X3RhYmxlLnRcblxuICBsZXQgY3JlYXRlIGludCA9IEtleV90YWJsZS5jcmVhdGUgaW50XG4gIGxldCBtZW0gdGFibGUgbmFtZSA9IEtleV90YWJsZS5tZW0gdGFibGUgKGtleSBuYW1lKVxuICBsZXQgc2V0IHRhYmxlIG5hbWUgZGF0YSA9IEtleV90YWJsZS5yZXBsYWNlIHRhYmxlIChrZXkgbmFtZSkgKERhdGEgKG5hbWUsIGRhdGEpKVxuXG4gIGxldCBmaW5kICh0eXBlIGEpIHRhYmxlIChuYW1lIDogYSB0eXBlbmFtZSkgPVxuICAgIGxldCBkYXRhID1cbiAgICAgIHRyeSBTb21lIChLZXlfdGFibGUuZmluZCB0YWJsZSAoa2V5IG5hbWUpKSB3aXRoXG4gICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbiAgICBpblxuICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChEYXRhIChuYW1lJywgZGF0YSkpIC0+XG4gICAgICAoZnVuICh0eXBlIGIpIChuYW1lJyA6IGIgdHlwZW5hbWUpIChkYXRhIDogYiBYLnQpIC0+XG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gKHNhbWVfd2l0bmVzc19leG4gbmFtZScgbmFtZSA6IChiLCBhKSBUeXBlX2VxdWFsLnQpIGluXG4gICAgICAgICBTb21lIChkYXRhIDogYSBYLnQpKVxuICAgICAgICBuYW1lJ1xuICAgICAgICBkYXRhXG4gIDs7XG5lbmRcblxubGV0IGZhaWwgdWlkX2EgdWlkX2IgPVxuICBsZXQgbXNnID1cbiAgICBQcmludGYuc3ByaW50ZiBcIlR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG4gJVMgJVNcIiAoVWlkLm5hbWUgdWlkX2EpIChVaWQubmFtZSB1aWRfYilcbiAgaW5cbiAgZmFpbHdpdGggbXNnXG47O1xuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8xIChBIDogUzEpIChCIDogUzEpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYS4gKCdhIEEudCwgJ2EgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMiAoQSA6IFMyKSAoQiA6IFMyKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IuICgoJ2EsICdiKSBBLnQsICgnYSwgJ2IpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMyAoQSA6IFMzKSAoQiA6IFMzKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IgJ2MuICgoJ2EsICdiLCAnYykgQS50LCAoJ2EsICdiLCAnYykgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzQgKEEgOiBTNCkgKEIgOiBTNCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiICdjICdkLiAoKCdhLCAnYiwgJ2MsICdkKSBBLnQsICgnYSwgJ2IsICdjLCAnZCkgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fNSAoQSA6IFM1KSAoQiA6IFM1KSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZXEgOlxuICAgICAgICAnYSAnYiAnYyAnZCAnZS4gKCgnYSwgJ2IsICdjLCAnZCwgJ2UpIEEudCwgKCdhLCAnYiwgJ2MsICdkLCAnZSkgQi50KSBUeXBlX2VxdWFsLnRcbiAgICB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG4iLCIoKipcbiAgIFBsYWNlIGhvbGRlciBmb3IgY29tbW9uIFZhcmlhbnRzIGFuZCBGaWVsZHMgaW50ZXJmYWNlXG4qKVxuXG5tb2R1bGUgTSAoWCA6IHNpZ1xuICAgICgqKlxuICAgICAgIFRoaXMgZnVuY3RvciBpcyBlc3NlbnRpYWxseSB0aGVyZSBiZWNhdXNlIHdlIHVzZSB0aGlzIHNhbWUgaW50ZXJmYWNlIGluIGRpZmZlcmVudFxuICAgICAgIGNvbnRleHRzLCB3aXRoIGRpZmZlcmVudCB0eXBlcyBmb3IgWydhIHRdLlxuXG4gICAgICAgMSkgT25lIHVzZSBjYXNlIGZvciBpdCBpcyB3aGVyZSBbJ2EgWC50ID0gJ2EgVHlwZXJlcC50XS4gIFRoZXNlIGludGVyZmFjZXMgYXJlIHRoZW5cbiAgICAgICBwYXJ0IG9mIHRoZSB0eXBlIHdpdG5lc3MgYnVpbHQgZm9yIGEgdHlwZSBjb250YWluaW5nIGEgcmVjb3JkIG9yIGEgdmFyaWFudCBpbiBpdHNcbiAgICAgICBzdHJ1Y3R1cmUuIFt0cmF2ZXJzZV0gd2lsbCBnaXZlIGEgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlXG4gICAgICAgYXJndW1lbnRzIG9mIGEgdmFyaWFudCBvciByZWNvcmQgdHlwZS5cblxuICAgICAgIDIpIEFub3RoZXIgdXNlIGNhc2UgaXMgZm9yIGJ1aWxkaW5nIFwic3RhZ2VkIGdlbmVyaWMgY29tcHV0YXRpb25zXCIuIEluIHRoYXQgY2FzZSwgdGhlXG4gICAgICAgdHlwZSBbJ2EgWC50XSBpcyB0aGUgdHlwZSBvZiB0aGUgY29tcHV0YXRpb24gdGhhdCBpcyBiZWluZyBidWlsdC4gIFt0cmF2ZXJzZV1cbiAgICAgICByZXR1cm5zIHRoZSBjb21wdXRhdGlvbiBidWlsdCBmb3IgdGhlIGFyZ3VtZW50LiBUaGUgaW50ZXJmYWNlIG5vIGxvbmdlciBleHBvcnRzXG4gICAgICAgdGhlIHR5cGVyZXAgb2YgdGhlIGFyZ3VtZW50cyBpbiBob3BlcyBvZiBlbmZvcmNpbmcgdGhhdCBubyB0eXBlcmVwIHRyYXZlcnNhbFxuICAgICAgIGhhcHBlbnMgYXQgcnVudGltZSBpZiB0aGUgY29tcHV0YXRpb24gaGFwcGVuIHRvIGJlIGEgZnVuY3Rpb24uXG4gICAgKilcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgKCogVGhlIGZ1bmN0aW9ucyBwcmVmaXhlZCBieSBbaW50ZXJuYWxdIGFzIHdlbGwgYXMgdGhlIG1vZHVsZSBzdWZmaXhlZCBieSBbX2ludGVybmFsXVxuICAgICBhcmUgdXNlZCBieSB0aGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gW3dpdGggdHlwZXJlcF0gYXMgd2VsbCBhcyBzb21lXG4gICAgIGludGVybmFscyBvZiB0aGUgdHlwZXJlcCBsaWJyYXJ5LiBEbyBub3QgY29uc2lkZXIgdXNpbmcgdGhlc2Ugc29tZXdoZXJlIGVsc2UuICBUaGV5XG4gICAgIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBleHBvcnRlZCBvdXRzaWRlIHRoZSB0eXBlcmVwIGxpYnJhcnksIGJ1dCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgbmVlZHMgc29tZWhvdyB0byBhY2Nlc3MgdGhpcywgZXZlbiBvdXRzaWRlLiAqKVxuXG4gIG1vZHVsZSBUYWdfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0ID1cbiAgICAgIHsgbGFiZWwgOiBzdHJpbmdcbiAgICAgIDsgcmVwIDogJ2FyZ3MgWC50XG4gICAgICA7IGFyaXR5IDogaW50XG4gICAgICA7IGFyZ3NfbGFiZWxzIDogc3RyaW5nIGxpc3RcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgb2NhbWxfcmVwciA6IGludFxuICAgICAgOyB0eWlkIDogJ2FyZ3MgVHlwZW5hbWUudFxuICAgICAgOyBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGVcbiAgICAgIH1cbiAgZW5kXG5cbiAgKCoqXG4gICAgIFdpdG5lc3Mgb2YgYSB0YWcsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHZhcmlhbnQgdHlwZSwgYWxzbyBjYWxsZWQgYW4gXCJhcHBsaWVkXG4gICAgIHZhcmlhbnQgQ29uc3RydWN0b3JcIlxuXG4gICAgIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgdGFnXG4gICAgIHBhcmFtZXRlcnMuICBFeGFtcGxlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID1cbiAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgfCBCIG9mIHN0cmluZ1xuICAgICAgICAgfCBDIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG5cbiAgICAgdGhpcyB0eXBlIGhhcyB0aHJlZSBjb25zdHJ1Y3RvcnMuIEZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmdcbiAgICAgW1RhZy50XTpcblxuICAgICB7W1xuICAgICAgIHZhbCB0YWdfQSA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgICB2YWwgdGFnX0IgOiAodCwgc3RyaW5nICAgICAgICApIFRhZy50XG4gICAgICAgdmFsIHRhZ19DIDogKHQsIChpbnQgKiBzdHJpbmcpKSBUYWcudFxuICAgICBdfVxuXG4gICAgIE5vdGUsIGlubGluZSByZWNvcmQgaW4gdmFyaWFudCBhcmUgdHlwZWQgYXMgaWYgdGhlaXIgZGVmaW5pdGlvbiB3YXMgdXNpbmcgdHVwbGVzLFxuICAgICB3aXRob3V0IHRoZSBwYXJlbnRoZXNpcy4gIFRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZWlyIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24uICBCdXRcbiAgICAgdGhlIGRpc3RpbmN0aW9uIGlzIGNhcnJpZWQgYW5kIGF2YWlsYWJsZSBmb3IgaW50cm9zcGVjdGlvbiBhcyBwYXJ0IG9mIHRoZSBbVGFnLnRdLlxuICAgICBTZWUgW2FyZ3NfbGFiZWxzXS4gKilcbiAgbW9kdWxlIFRhZyA6IHNpZ1xuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgY3JlYXRlID1cbiAgICAgIHwgQXJncyBvZiAoJ2FyZ3MgLT4gJ3ZhcmlhbnQpXG4gICAgICB8IENvbnN0IG9mICd2YXJpYW50XG5cbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIHRcblxuICAgICgqKlxuICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBhcyBpdCBpcyBnaXZlbiBpbiB0aGUgY29uY3JldGUgc3ludGF4XG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7dlxuICAgICAgICAgQ29uc3RydWN0b3IgICAgICAgIHwgbGFiZWxcbiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIHwgQSBvZiBpbnQgICAgICAgICB8ICBcIkFcIlxuICAgICAgICAgfCBgYSBvZiBpbnQgICAgICAgIHwgIFwiYVwiXG4gICAgICAgICB8IGBBIG9mIGludCAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSB8ICBcIkFcIlxuICAgICAgIHZ9XG5cbiAgICAgICBmb3Igc3RhbmRhcmQgdmFyaWFudCwgdGhlIG9jYW1sIHN5bnRheCBpbXBsaWVzIHRoYXQgdGhpcyBsYWJlbCB3aWxsIGFsd2F5cyBzdGFydHNcbiAgICAgICB3aXRoIGEgY2FwaXRhbCBsZXR0ZXIuIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50cywgdGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSBjaGFyLlxuICAgICAgIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50LCB0aGlzIGxhYmVsIGRvZXMgbm90IGluY2x1ZGUgdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSBzaXplIG9mIHRoZSBvY2FtbCBoZWFwIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50c1xuXG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge3ZcbiAgICAgICAgICAwOiB8IEEgfCAnQVxuICAgICAgICAgIDE6IHwgQSBvZiBpbnQgfCBgQSBvZiBpbnQgfCBBIG9mIChpbnQgKiBpbnQpIHwgYEEgb2YgKGludCAqIGludClcbiAgICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnR9XG4gICAgICAgICAgMjogfCBBIG9mIGludCAqIGZsb2F0XG4gICAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgICAgZXRjLlxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJpdHkgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKiBUaGUgbGFiZWwgb2YgdGhlIGZpZWxkcyBmb3IgaW5saW5lIHJlY29yZHMuICBGb3Igb3RoZXIgZm9ybXMgb2YgdGFncywgdGhpcyBpcyB0aGVcbiAgICAgICAgZW1wdHkgbGlzdC4gIFdoZW4gdGhpcyByZXR1cm5zIGEgbm9uIGVtcHR5IGxpc3QsIHRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGxpc3RcbiAgICAgICAgaXMgZXF1YWwgdG8gdGhlIGFyaXR5LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAge3ZcbiAgICAgICAgICgxKSBFbXB0eTpcblxuICAgICAgICAgICB8IEEgfCAnQVxuICAgICAgICAgICB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgIHwgYEEgb2YgaW50ICogaW50XG4gICAgICAgICAgIHwgQSBvZiBpbnQgKiBmbG9hdFxuXG4gICAgICAgICAoMikgTm9uIGVtcHR5OlxuXG4gICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSAgICAgICAgICAgICAgIC0+IFsgXCJ4XCIgXVxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH0gICAtPiBbIFwieFwiIDsgXCJ5XCIgXVxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJnc19sYWJlbHMgOiAoXywgXykgdCAtPiBzdHJpbmcgbGlzdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb25zdHJ1Y3RvciBpbiB0aGUgbGlzdCBvZiBhbGwgdGhlIHZhcmlhbnQgdHlwZSdzIGNvbnN0cnVjdG9yc1xuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgQyBvZiBpbnQgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEQgb2YgY2hhciAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBFIG9mIHsgeCA6IGludCB9ICAoKiA0ICopXG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgb2NhbWxfcmVwciBpcyByZWxhdGVkIHRvIHRoZSBydW50aW1lIG9mIG9iamVjdHMuIHRoaXMgaXMgZXNzZW50aWFsbHkgYSB3YXkgb2ZcbiAgICAgICBnaXZpbmcgb25lIHRoZSBhYmlsaXR5IHRvIHJlYnVpbGQgZHluYW1pY2FsbHkgYW4gW09iai50XSByZXByZXNlbnRpbmcgYSB0YWcuXG5cbiAgICAgICBQb2x5bW9ycGhpYyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgaGFzaCBvZiB0aGUgbGFiZWwsIGFzIGRvbmUgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgYGJhcikgICgqIDQ4OTUxODcgKilcbiAgICAgICBwcmludF9pbnQgKE9iai5tYWdpYyAnZm9vKSAgKCogNTA5NzIyMiAqKVxuXG4gICAgICAgU3RhbmRhcmRzIHZhcmlhbnRzOlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgdGFnIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZS5cbiAgICAgICB0aGUgd2F5IGl0IHdvcmtzIGluIHRoZSBvY2FtbCBydW50aW1lIGlzIGJ5IHBhcnRpdGlvbmluZyB0aGUgY29uc3RydWN0b3JzIHJlZ2FyZGluZ1xuICAgICAgIGlmIHRoZXkgaGF2ZSBzb21lIGFyZ3VtZW50cyBvciBub3QsIHByZXNlcnZpbmcgdGhlIG9yZGVyLCB0aGVuIGFzc2lnbiBpbmNyZWFzaW5nXG4gICAgICAgaW5kZXggd2l0aGluZyBlYWNoIHBhcnRpdGlvbi5cbiAgICAgICBFeGFtcGxlOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9ICAgICAgICAgICAgICAgICAgKCogbm8gYXJnICopICAoKiBhcmdzICopXG4gICAgICAgICAgIHwgQSAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEIgb2YgaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEMgICAgICAgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBEIG9mIChmbG9hdCAqIHN0cmluZykgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBFICAgICAgICAgICAgICAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgRiAgICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgICAgICB8IEcgb2Ygc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEggb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgb2NhbWxfcmVwciA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2l2ZSBiYWNrIGEgd2F5IG9mIGNvbnN0cnVjdGluZyBhIHZhbHVlIG9mIHRoYXQgY29uc3RydWN0b3IgZnJvbSBpdHMgYXJndW1lbnRzLlxuXG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIChpbnQgKiBzdHJpbmcpXG4gICAgICAgICAgIHwgQiBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICB8IENcbiAgICAgICAgICAgfCBEIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgXX1cblxuICAgICAgIFtjcmVhdGVdIHdpbGwgcmV0dXJuIHNvbWV0aGluZyBlcXVpdmFsZW50IHRvOlxuICAgICAgIHRhZ19BIDogW0FyZ3MgKGZ1biAoZCA6IChpbnQgKiBzdHJpbmcpIC0+IEEgZCldXG4gICAgICAgdGFnX0IgOiBbQXJncyAoZnVuIChpLCBmKSAtPiBCIChpLCBmKSldXG4gICAgICAgdGFnX0MgOiBbQ29uc3QgQ11cbiAgICAgICB0YWdfRCA6IFtBcmdzIChmdW4gKHgsIHkpIC0+IEQgeyB4OyB5IH0pXVxuICAgICopXG4gICAgdmFsIGNyZWF0ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIHQgLT4gKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gbWlnaHQgYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgbG9va3VwIGJhc2VkXG4gICAgICAgIG9uIGl0IHdoaWxlIGJ1aWxkaW5nIGEgY29tcHV0YXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnYXJncykgdCAtPiAnYXJncyBUeXBlbmFtZS50XG5cbiAgICAoKiogZ2V0IHRoZSByZXByZXNlbnRhdGlvbi9jb21wdXRhdGlvbiBvZiB0aGUgYXJndW1lbnRzICopXG4gICAgdmFsIHRyYXZlcnNlIDogKF8sICdhcmdzKSB0IC0+ICdhcmdzIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgVGFnX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRhZ19pbnRlcm5hbFxuXG4gICAgbGV0IGxhYmVsIHQgPSB0LmxhYmVsXG4gICAgbGV0IGFyaXR5IHQgPSB0LmFyaXR5XG4gICAgbGV0IGFyZ3NfbGFiZWxzIHQgPSB0LmFyZ3NfbGFiZWxzXG4gICAgbGV0IGluZGV4IHQgPSB0LmluZGV4XG4gICAgbGV0IG9jYW1sX3JlcHIgdCA9IHQub2NhbWxfcmVwclxuICAgIGxldCBjcmVhdGUgdCA9IHQuY3JlYXRlXG4gICAgbGV0IHR5aWQgdCA9IHQudHlpZFxuICAgIGxldCB0cmF2ZXJzZSB0ID0gdC5yZXBcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhKSBUYWcudCAqICdhIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgdGFncyA6ICdhIHRhZyBhcnJheVxuICAgICAgOyBwb2x5bW9ycGhpYyA6IGJvb2xcbiAgICAgIDsgdmFsdWUgOiAnYSAtPiAnYSB2YWx1ZVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgVmFyaWFudCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSB0YWdzIGNvbnN0aXR1aW5nIGEgdmFyaWFudFxuICAgICAgIHR5cGUuIHRoZSBbJ3ZhcmlhbnRdIHBhcmFtZXRlciBpcyB0aGUgdmFyaWFudCB0eXBlLCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHRoZVxuICAgICAgIGNvbnN0cnVjdG9ycyBvZiB0aGF0IHZhcmlhbnQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgbWlnaHQgYmUgZGlmZmVyZW50XG4gICAgICAgZm9yIGVhY2ggY29uc3RydWN0b3IgYW5kIGlzIHRodXMgZXhpc3RlbnRpYWxcbiAgICAqKVxuICAgIHR5cGUgXyB0YWcgPSBUYWcgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAtPiAndmFyaWFudCB0YWdcblxuICAgICgqKlxuICAgICAgIEEgc2ltaWxhciBleGlzdGVudGlhbCBjb25zdHJ1Y3RvciB0byBbXyB0YWddIGJ1dCB0aGlzIG9uZSBob2xkcyBhIHZhbHVlIHdob3NlIHR5cGVcbiAgICAgICBpcyB0aGUgYXJndW1lbnRzIG9mIHRoZSB0YWcgY29uc3RydWN0b3IuICBBIHZhbHVlIG9mIHR5cGUgWydhIHZhbHVlXSBpcyBhIHBhaXIgb2ZcbiAgICAgICAoMSkgYSB2YWx1ZSBvZiB2YXJpYW50IHR5cGUgWydhXSBhbG9uZyB3aXRoICgyKSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZSBbJ2FdXG4gICAgKilcbiAgICB0eXBlIF8gdmFsdWUgPSBWYWx1ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIFRhZy50ICogJ2FyZ3MgLT4gJ3ZhcmlhbnQgdmFsdWVcblxuICAgICgqKlxuICAgICAgIFdpdG5lc3Mgb2YgYSB2YXJpYW50IHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHZhcmlhbnQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFncyBvZiB0aGlzIHZhcmlhbnQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCB0YWcgb2YgdGhpcyB2YXJpYW50IHR5cGUsIGluZGV4ZWQgZnJvbSAwLlxuICAgICopXG4gICAgdmFsIHRhZyA6ICdhIHQgLT4gaW50IC0+ICdhIHRhZ1xuXG4gICAgKCoqXG4gICAgICAgRGlzdGluZ3Vpc2ggcG9seW1vcnBoaWMgdmFyaWFudHMgYW5kIHN0YW5kYXJkIHZhcmlhbnRzLiBUeXBpY2FsbHksIHBvbHltb3JwaGljXG4gICAgICAgdmFyaWFudHMgdGFncyBzdGFydHMgd2l0aCB0aGUgW2BdIGNoYXJhY3Rlci5cbiAgICAgICBFeGFtcGxlXG4gICAgICAgcG9seW1vcnBoaWMgdmFyaWFudDogdHlwZSB0ID0gWyBgQSB8IGBCIF1cbiAgICAgICBzdGFuZGFyZCB2YXJpYW50OiAgICB0eXBlIHQgPSBBIHwgQlxuICAgICopXG4gICAgdmFsIGlzX3BvbHltb3JwaGljIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gYSB2YWx1ZSBvZiB0aGlzIHZhcmlhbnQgdHlwZS5cbiAgICAqKVxuICAgIHZhbCB2YWx1ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdmFsdWVcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIHRhZyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAnYSBWYXJpYW50X2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFZhcmlhbnRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQudGFnc1xuICAgIGxldCB0YWcgdCBpbmRleCA9IHQudGFncy4oaW5kZXgpXG4gICAgbGV0IGlzX3BvbHltb3JwaGljIHQgPSB0LnBvbHltb3JwaGljXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEFycmF5LmZvbGRfbGVmdCBmIGluaXQgdC50YWdzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBGaWVsZF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdmaWVsZCBYLnRcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdmaWVsZCBUeXBlbmFtZS50XG4gICAgICA7IGdldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgICA7ICgqIHNldCA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb247IChcXCogbXV0YWJsZSBmaWVsZCAqXFwpICopXG4gICAgICAgIGlzX211dGFibGUgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgZmllbGQsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHJlY29yZCB0eXBlLlxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgZmllbGQuXG4gICAgIEV4YW1wbGU6XG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50IDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG4gICAgIFRoaXMgdHlwZSBoYXMgdHdvIGZpZWxkcy4gZm9yIGVhY2ggb2YgdGhlbSB3ZSdsbCBoYXZlIGEgY29ycmVzcG9uZGluZyBbRmllbGQudF1cblxuICAgICB2YWwgZmllbGRfeCA6ICh0LCBpbnQpIEZpZWxkLnRcbiAgICAgdmFsIGZpZWxkX3kgOiAodCwgc3RyaW5nKSBGaWVsZC50XG4gICopXG4gIG1vZHVsZSBGaWVsZCA6IHNpZ1xuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdFxuXG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgZmllbGQgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB7IHggICA6IGludDsgICAgICgqIFwieFwiICopXG4gICAgICAgICAgIGZvbyA6IHN0cmluZzsgICgqIFwiZm9vXCIgKilcbiAgICAgICAgICAgYmFyIDogZmxvYXQ7ICAgKCogXCJiYXJcIiAqKVxuICAgICAgICAgfVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBmaWVsZCBpbiB0aGUgbGlzdCBvZiBhbGwgZmllbGRzIGZvciB0aGlzIHJlY29yZCB0eXBlLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgICAgeCAgIDogaW50OyAgICAgKCogMCAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiAxICopXG4gICAgICAgICAgIGJhciA6IHN0cmluZzsgICgqIDIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGluZGV4IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBGaWVsZCBhY2Nlc3NvcnMuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGRvdCBvcGVyYXRpb24uXG4gICAgICAgW0ZpZWxkLmdldCBiYXJfZmllbGQgdF0gcmV0dXJucyB0aGUgZmllbGQgW2Jhcl0gb2YgdGhlIHJlY29yZCB2YWx1ZSBbdF0sIGp1c3QgdGhlXG4gICAgICAgc2FtZSBhcyBbdC5iYXJdXG4gICAgKilcbiAgICB2YWwgZ2V0IDogKCdyZWNvcmQsICdmaWVsZCkgdCAtPiAncmVjb3JkIC0+ICdmaWVsZFxuXG4gICAgKCoqIHJldHVybiB3aGV0aGVyIHRoZSBmaWVsZCBpcyBtdXRhYmxlLCBpLmUuIHdoZXRoZXIgaXRzIGRlY2xhcmF0aW9uIGlzIHByZWZpeGVkIHdpdGhcbiAgICAgICAgdGhlIGtleXdvcmQgW211dGFibGVdICopXG4gICAgdmFsIGlzX211dGFibGUgOiAoXywgXykgdCAtPiBib29sXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gIE1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCAqKVxuICAgIHZhbCB0eWlkIDogKF8sICdmaWVsZCkgdCAtPiAnZmllbGQgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgRmllbGRfaW50ZXJuYWwudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRmllbGRfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBnZXQgdCA9IHQuZ2V0XG4gICAgbGV0IGlzX211dGFibGUgdCA9IHQuaXNfbXV0YWJsZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBSZWNvcmRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gZmllbGQgPSBGaWVsZCA6ICgncmVjb3JkLCAnYSkgRmllbGQudCAtPiAncmVjb3JkIGZpZWxkXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgZmllbGRzIDogJ2EgZmllbGQgYXJyYXlcbiAgICAgIDsgaGFzX2RvdWJsZV9hcnJheV90YWcgOiBib29sXG4gICAgICA7IGNyZWF0ZSA6ICdhIGZpZWxkcyAtPiAnYVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkIDogc2lnXG4gICAgKCoqXG4gICAgICAgQW4gZXhpc3RlbnRpYWwgdHlwZSB1c2VkIHRvIGdhdGhlciBhbGwgdGhlIGZpZWxkcyBjb25zdGl0dWluZyBhIHJlY29yZCB0eXBlLiB0aGVcbiAgICAgICBbJ3JlY29yZF0gcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGUgZmllbGQgb2YgdGhhdFxuICAgICAgIHJlY29yZCB0eXBlLiBUaGUgdHlwZSBvZiB0aGUgZmllbGRzIG1pZ2h0IGJlIGRpZmZlcmVudCBmb3IgZWFjaCBmaWVsZCBhbmQgaXMgdGh1c1xuICAgICAgIGV4aXN0ZW50aWFsLlxuICAgICopXG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgWydyZWNvcmQgZmllbGRzXSBpcyBhIHR5cGUgaXNvbW9ycGhpYyB0byBbJ3JlY29yZF0uICBUaGlzIGdpdmVzIGEgd2F5IHRvIGdldCB0aGVcbiAgICAgICBmaWVsZCB2YWx1ZSBmb3IgZWFjaCBmaWVsZCBvZiB0aGUgcmVjb3JkLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIHJlcHJlc2VudGF0aW9uIGlzXG4gICAgICAgdGhhdCBpdCBpcyBjb252ZW5pZW50IGZvciB3cml0aW5nIGdlbmVyaWMgY29tcHV0YXRpb25zLlxuICAgICopXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgcmVjb3JkIHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHJlY29yZCB0eXBlIHdpdG5lc3NlZC5cbiAgICAqKVxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcblxuICAgICgqKlxuICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBmaWVsZHMgb2YgdGhpcyByZWNvcmQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCBmaWVsZCBvZiB0aGlzIHJlY29yZCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCBmaWVsZCA6ICdhIHQgLT4gaW50IC0+ICdhIGZpZWxkXG5cbiAgICAoKipcbiAgICAgICBUaGlzIGlzIGEgbG93IGxldmVsIG1ldGFkYXRhIHJlZ2FyZGluZyB0aGUgd2F5IHRoZSBvY2FtbCBjb21waWxlciByZXByZXNlbnQgdGhlXG4gICAgICAgYXJyYXkgdW5kZXJuZWF0aCB0aGF0IGlzIHRoZSBydW50aW1lIHZhbHVlIG9mIGEgcmVjb3JkIG9mIHR5cGUgWydhXSBnaXZlbiBhIHdpdG5lc3NcbiAgICAgICBvZiB0eXBlIFsnYSB0XS4gW2hhc19kb3VibGVfYXJyYXlfdGFnIHddIHJldHVybnMgW3RydWVdIGlmIHRoZSBhcnJheSB0aGF0XG4gICAgICAgcmVwcmVzZW50cyBydW50aW1lIHZhbHVlcyBvZiB0aGlzIHR5cGUgaXMgYW4gb3B0aW1pemVkIG9jYW1sIGZsb2F0IGFycmF5LlxuICAgICAgIFR5cGljYWxseSwgdGhpcyB3aWxsIGJlIHRydWUgZm9yIHJlY29yZCB3aGVyZSBhbGwgZmllbGRzIGFyZSBzdGF0aWNhbGx5IGtub3duIGFzIHRvXG4gICAgICAgYmUgW2Zsb2F0c10uXG5cbiAgICAgICBOb3RlIHRoYXQgeW91IGNhbid0IGdldCB0aGlzIGluZm9ybWF0aW9uIGR5bmFtaWNhbGx5IGJ5IGluc3BlY3RpbmcgdGhlIHR5cGVyZXAgb25jZVxuICAgICAgIGl0IGlzIGFwcGxpZWQsIGJlY2F1c2UgdGhlcmUgaXMgYXQgdGhpcyBwb2ludCBubyB3YXkgdG8gdGVsbCB3aGV0aGVyIG9uZSBvZiB0aGVcbiAgICAgICBmaWVsZCBpcyBwb2x5bW9ycGhpYyBpbiB0aGUgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGhhc19kb3VibGVfYXJyYXlfdGFnIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIEV4cG9zZSBvbmUgZGlyZWN0aW9uIG9mIHRoZSBpc29tb3JwaGlzbSBiZXR3ZWVuIGEgdmFsdWUgb2YgdHlwZSBbJ2FdIGFuZCBhIHZhbHVlIG9mXG4gICAgICAgdHlwZSBbJ2EgZmllbGRzXS4gQmFzaWNhbGx5LCBnaXZlbiBhbiBlbmNvZGluZyB3YXkgb2YgYWNjZXNzaW5nIHRoZSB2YWx1ZSBvZiBhbGxcbiAgICAgICB0aGUgZmllbGRzIG9mIGEgcmVjb3JkLCBjcmVhdGUgdGhhdCByZWNvcmQgYW5kIHJldHVybiBpdC5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAnYSB0IC0+ICdhIGZpZWxkcyAtPiAnYVxuXG4gICAgKCoqXG4gICAgICAgZm9sZGluZyBhbG9uZyB0aGUgdGFncyBvZiB0aGUgdmFyaWFudCB0eXBlXG4gICAgKilcbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgZmllbGQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgUmVjb3JkX2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlY29yZF9pbnRlcm5hbFxuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgdCA9IHQudHlwZW5hbWVcbiAgICBsZXQgbGVuZ3RoIHQgPSBBcnJheS5sZW5ndGggdC5maWVsZHNcbiAgICBsZXQgZmllbGQgdCBpbmRleCA9IHQuZmllbGRzLihpbmRleClcbiAgICBsZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgdCA9IHQuaGFzX2RvdWJsZV9hcnJheV90YWdcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQuZmllbGRzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVwXG4gICAgZW5kKVxuZW5kXG4iLCJtb2R1bGUgTmFtZV9vZiA9IHN0cnVjdFxuICBsZXQgdHlwZW5hbWVfb2ZfaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQzMiA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50MzJcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50MzJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2ludDY0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnQ2NFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJpbnQ2NFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfbmF0aXZlaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBuYXRpdmVpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwibmF0aXZlaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9jaGFyID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBjaGFyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImNoYXJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Zsb2F0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBmbG9hdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJmbG9hdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2Zfc3RyaW5nID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICBsZXQgbmFtZSA9IFwic3RyaW5nXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ieXRlcyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYnl0ZXNcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Jvb2wgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJvb2xcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYm9vbFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdW5pdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJ1bml0XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIG1vZHVsZSBNX29wdGlvbiA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gICAgICBsZXQgbmFtZSA9IFwib3B0aW9uXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX29wdGlvbiA9IE1fb3B0aW9uLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9saXN0ID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGlzdFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9saXN0ID0gTV9saXN0LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9hcnJheSA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbiAgICAgIGxldCBuYW1lID0gXCJhcnJheVwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9hcnJheSA9IE1fYXJyYXkudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2xhenlfdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGF6eV90XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2xhenlfdCA9IE1fbGF6eV90LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9yZWYgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZWZcblxuICAgICAgbGV0IG5hbWUgPSBcInJlZlwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9yZWYgPSBNX3JlZi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fZnVuY3Rpb24gPSBUeXBlbmFtZS5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSAtPiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwiZnVuY3Rpb25cIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfZnVuY3Rpb24gPSBNX2Z1bmN0aW9uLnR5cGVuYW1lX29mX3RcblxuICB0eXBlIHR1cGxlMCA9IHVuaXRcblxuICBtb2R1bGUgTV90dXBsZTAgPSBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICB0eXBlIHQgPSB0dXBsZTBcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlMFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTAgPSBNX3R1cGxlMC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUyID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgKiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGUyXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMiA9IE1fdHVwbGUyLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTMgPSBUeXBlbmFtZS5NYWtlMyAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2EgKiAnYiAqICdjXG5cbiAgICAgIGxldCBuYW1lID0gXCJ0dXBsZTNcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUzID0gTV90dXBsZTMudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNCA9IFR5cGVuYW1lLk1ha2U0IChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0ID0gJ2EgKiAnYiAqICdjICogJ2RcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlNFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTQgPSBNX3R1cGxlNC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGU1ID0gVHlwZW5hbWUuTWFrZTUgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gJ2EgKiAnYiAqICdjICogJ2QgKiAnZVxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGU1XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlNSA9IE1fdHVwbGU1LnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgcmVjIFR5cGVyZXAgOiBzaWdcbiAgdHlwZSBfIHQgPVxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEludDMyIDogaW50MzIgdFxuICAgIHwgSW50NjQgOiBpbnQ2NCB0XG4gICAgfCBOYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICAgIHwgQ2hhciA6IGNoYXIgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgQnl0ZXMgOiBieXRlcyB0XG4gICAgfCBCb29sIDogYm9vbCB0XG4gICAgfCBVbml0IDogdW5pdCB0XG4gICAgfCBPcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgfCBMaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB8IEFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gICAgfCBMYXp5IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICAgIHwgUmVmIDogJ2EgdCAtPiAnYSByZWYgdFxuICAgIHwgRnVuY3Rpb24gOiAoJ2RvbSB0ICogJ3JuZyB0KSAtPiAoJ2RvbSAtPiAncm5nKSB0XG4gICAgfCBUdXBsZSA6ICdhIFR5cGVyZXAuVHVwbGUudCAtPiAnYSB0XG4gICAgfCBSZWNvcmQgOiAnYSBUeXBlcmVwLlJlY29yZC50IC0+ICdhIHRcbiAgICB8IFZhcmlhbnQgOiAnYSBUeXBlcmVwLlZhcmlhbnQudCAtPiAnYSB0XG4gICAgfCBOYW1lZCA6ICgnYSBUeXBlcmVwLk5hbWVkLnQgKiAnYSB0IGxhenlfdCBvcHRpb24pIC0+ICdhIHRcblxuICB0eXBlIHBhY2tlZCA9IFQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFQwID0gc2lnXG4gICAgICB0eXBlIG5hbWVkXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQxID0gc2lnXG4gICAgICB0eXBlICdhIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgYSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMiA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2IgVHlwZW5hbWUudCAtPiAoJ2EsICdiKSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQzID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYykgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ0ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNSA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBlXG5cbiAgICAgIHZhbCBlIDogZSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdlIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQsIGUpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgICgqIHRoZXJlIHRoZSBtb2R1bGUgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggYSB0eXBlIFt0XSB3aXRoXG4gICAgICAgcGFyYW1ldGVycyB3aG9zZSBraW5kIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgdHlwZSB2YXJpYWJsZTogWydhICd0XSwgZXZlbiB3aXRoXG4gICAgICAgYSBnYWR0LiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFQwIG9mIChtb2R1bGUgVDAgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDEgb2YgKG1vZHVsZSBUMSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMiBvZiAobW9kdWxlIFQyIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQzIG9mIChtb2R1bGUgVDMgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDQgb2YgKG1vZHVsZSBUNCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNSBvZiAobW9kdWxlIFQ1IHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIFR1cGxlIDogc2lnXG4gICAgKCogdGhlc2UgY29uc3RydWN0b3JzIGNvdWxkIGJlIHBsdW5nZWQgYXQgdG9wbGV2ZWwgb2YgVHlwZXJlcC50LCBob3dldmVyIGl0IGlzIGxlc3NcbiAgICAgICB2ZXJib3NlIHRoYXQgd2F5ICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBUMiA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQpIC0+ICgnYSAqICdiKSB0XG4gICAgICB8IFQzIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCkgLT4gKCdhICogJ2IgKiAnYykgdFxuICAgICAgfCBUNCA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgICAgIHwgVDUgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQgKiAnZSBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkICogJ2UpIHRcblxuICAgIHZhbCBhcml0eSA6IF8gdCAtPiBpbnRcbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVHlwZXJlcC50XG5cbiAgdmFsIHNhbWUgOiBfIHQgLT4gXyB0IC0+IGJvb2xcbiAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG4gIHZhbCBzYW1lX3dpdG5lc3NfZXhuIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSwgJ2IpIFR5cGVfZXF1YWwudFxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICB2YWwgaGVhZCA6ICdhIHQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IGFyaXR5ID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgXyAtPiAwXG4gICAgICB8IFQxIF8gLT4gMVxuICAgICAgfCBUMiBfIC0+IDJcbiAgICAgIHwgVDMgXyAtPiAzXG4gICAgICB8IFQ0IF8gLT4gNFxuICAgICAgfCBUNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgKHR5cGUgYSkgPSBmdW5jdGlvblxuICAgICAgfCBUMCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMiByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMiB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMyByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgbmFtZSByZXAgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkICh0eXBlbmFtZV9vZl90IHJlcCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA9IHN0cnVjdFxuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGlzIHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICBsZXQgYXJpdHkgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIF8gLT4gMlxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIF8gLT4gM1xuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IF8gLT4gNFxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IF8gLT4gNVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgICB8IFQyIChhLCBiKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlMiAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgIHwgVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGUzXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICB8IFQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNFxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgIHwgVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGU1XG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBkKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLk0gKHN0cnVjdFxuICAgICAgdHlwZSAnYSByZXAgPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZXBcbiAgICBlbmQpXG5cbiAgbGV0IHJlYyB0eXBlbmFtZV9vZl90IDogdHlwZSBhLiBhIHQgLT4gYSBUeXBlbmFtZS50ID0gZnVuY3Rpb25cbiAgICB8IEludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2ludFxuICAgIHwgSW50MzIgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQzMlxuICAgIHwgSW50NjQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQ2NFxuICAgIHwgTmF0aXZlaW50IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbmF0aXZlaW50XG4gICAgfCBDaGFyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfY2hhclxuICAgIHwgRmxvYXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9mbG9hdFxuICAgIHwgU3RyaW5nIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfc3RyaW5nXG4gICAgfCBCeXRlcyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2J5dGVzXG4gICAgfCBCb29sIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfYm9vbFxuICAgIHwgVW5pdCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3VuaXRcbiAgICB8IE9wdGlvbiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9vcHRpb24gKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgTGlzdCByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9saXN0ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEFycmF5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2FycmF5ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExhenkgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGF6eV90ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IFJlZiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9yZWYgKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgRnVuY3Rpb24gKGRvbSwgcm5nKSAtPlxuICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl9mdW5jdGlvbiAodHlwZW5hbWVfb2ZfdCBkb20pICh0eXBlbmFtZV9vZl90IHJuZylcbiAgICB8IFR1cGxlIHJlcCAtPiBUeXBlcmVwLlR1cGxlLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBSZWNvcmQgcmVwIC0+IFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBWYXJpYW50IHJlcCAtPiBUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByZXBcbiAgICB8IE5hbWVkIChuYW1lLCBfKSAtPiBOYW1lZC50eXBlbmFtZV9vZl90IG5hbWVcbiAgOztcblxuICBsZXQgcmVjIHNhbWVfd2l0bmVzcyA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBUeXBlX2VxdWFsLnQgb3B0aW9uID1cbiAgICBmdW4gdDEgdDIgLT5cbiAgICAgIGxldCBtb2R1bGUgRSA9IFR5cGVfZXF1YWwgaW5cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IE5hbWVkIChuYW1lMSwgcjEpLCBOYW1lZCAobmFtZTIsIHIyKSAtPlxuICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUxKSAoTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lMilcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4XG4gICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHIxLCByMiB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgKGxhenkgdDEpLCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICAgIHwgU29tZSAobGF6eSB0MSksIE5vbmUgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgICB8IE5vbmUsIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgICAgfCBOb25lLCBOb25lIC0+IE5vbmUpKVxuICAgICAgfCBOYW1lZCAoXywgcjEpLCB0MiAtPlxuICAgICAgICAobWF0Y2ggcjEgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQxKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCB0MSwgTmFtZWQgKF8sIHIyKSAtPlxuICAgICAgICAobWF0Y2ggcjIgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBJbnQsIEludCAtPiBTb21lIEUuVFxuICAgICAgfCBJbnQzMiwgSW50MzIgLT4gU29tZSBFLlRcbiAgICAgIHwgSW50NjQsIEludDY0IC0+IFNvbWUgRS5UXG4gICAgICB8IE5hdGl2ZWludCwgTmF0aXZlaW50IC0+IFNvbWUgRS5UXG4gICAgICB8IENoYXIsIENoYXIgLT4gU29tZSBFLlRcbiAgICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRS5UXG4gICAgICB8IFN0cmluZywgU3RyaW5nIC0+IFNvbWUgRS5UXG4gICAgICB8IEJ5dGVzLCBCeXRlcyAtPiBTb21lIEUuVFxuICAgICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRS5UXG4gICAgICB8IFVuaXQsIFVuaXQgLT4gU29tZSBFLlRcbiAgICAgIHwgT3B0aW9uIHIxLCBPcHRpb24gcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGlzdCByMSwgTGlzdCByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBBcnJheSByMSwgQXJyYXkgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGF6eSByMSwgTGF6eSByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBSZWYgcjEsIFJlZiByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBGdW5jdGlvbiAoZG9tMSwgcm5nMSksIEZ1bmN0aW9uIChkb20yLCBybmcyKSAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGRvbTEgZG9tMiwgc2FtZV93aXRuZXNzIHJuZzEgcm5nMiB3aXRoXG4gICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgfCBUdXBsZSB0MSwgVHVwbGUgdDIgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gVHlwZXJlcC5UdXBsZSBpblxuICAgICAgICAobWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgIHwgVC5UMiAoYTEsIGIxKSwgVC5UMiAoYTIsIGIyKSAtPlxuICAgICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UMyAoYTEsIGIxLCBjMSksIFQuVDMgKGEyLCBiMiwgYzIpIC0+XG4gICAgICAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgYTEgYTIsIHNhbWVfd2l0bmVzcyBiMSBiMiwgc2FtZV93aXRuZXNzIGMxIGMyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UNCAoYTEsIGIxLCBjMSwgZDEpLCBULlQ0IChhMiwgYjIsIGMyLCBkMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfLCBfIHwgXywgTm9uZSwgXywgXyB8IF8sIF8sIE5vbmUsIF8gfCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICB8IFQuVDUgKGExLCBiMSwgYzEsIGQxLCBlMSksIFQuVDUgKGEyLCBiMiwgYzIsIGQyLCBlMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICggc2FtZV93aXRuZXNzIGExIGEyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGIxIGIyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGMxIGMyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGQxIGQyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGUxIGUyIClcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgICB8IE5vbmUsIF8sIF8sIF8sIF9cbiAgICAgICAgICAgIHwgXywgTm9uZSwgXywgXywgX1xuICAgICAgICAgICAgfCBfLCBfLCBOb25lLCBfLCBfXG4gICAgICAgICAgICB8IF8sIF8sIF8sIE5vbmUsIF9cbiAgICAgICAgICAgIHwgXywgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgfCBULlQyIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQzIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ0IF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ1IF8sIF8gLT4gTm9uZSlcbiAgICAgIHwgUmVjb3JkIHIxLCBSZWNvcmQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjIpXG4gICAgICB8IFZhcmlhbnQgcjEsIFZhcmlhbnQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuVmFyaWFudC50eXBlbmFtZV9vZl90IHIxKVxuICAgICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMilcbiAgICAgIHwgSW50LCBfIC0+IE5vbmVcbiAgICAgIHwgSW50MzIsIF8gLT4gTm9uZVxuICAgICAgfCBJbnQ2NCwgXyAtPiBOb25lXG4gICAgICB8IE5hdGl2ZWludCwgXyAtPiBOb25lXG4gICAgICB8IENoYXIsIF8gLT4gTm9uZVxuICAgICAgfCBGbG9hdCwgXyAtPiBOb25lXG4gICAgICB8IFN0cmluZywgXyAtPiBOb25lXG4gICAgICB8IEJ5dGVzLCBfIC0+IE5vbmVcbiAgICAgIHwgQm9vbCwgXyAtPiBOb25lXG4gICAgICB8IFVuaXQsIF8gLT4gTm9uZVxuICAgICAgfCBPcHRpb24gXywgXyAtPiBOb25lXG4gICAgICB8IExpc3QgXywgXyAtPiBOb25lXG4gICAgICB8IEFycmF5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBMYXp5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBSZWYgXywgXyAtPiBOb25lXG4gICAgICB8IEZ1bmN0aW9uIF8sIF8gLT4gTm9uZVxuICAgICAgfCBUdXBsZSBfLCBfIC0+IE5vbmVcbiAgICAgIHwgUmVjb3JkIF8sIF8gLT4gTm9uZVxuICAgICAgfCBWYXJpYW50IF8sIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lIGEgYiA9IHNhbWVfd2l0bmVzcyBhIGIgPD4gTm9uZVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIGEgYiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIGEgYiB3aXRoXG4gICAgfCBTb21lIHByb29mIC0+IHByb29mXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgaGVhZCA9IGZ1bmN0aW9uXG4gICAgfCBUeXBlcmVwLk5hbWVkIChfLCBTb21lIChsYXp5IHQpKSAtPiBoZWFkIHRcbiAgICB8IHQgLT4gdFxuICA7O1xuZW5kXG5cbmxldCB0eXBlcmVwX29mX2ludCA9IFR5cGVyZXAuSW50XG5sZXQgdHlwZXJlcF9vZl9pbnQzMiA9IFR5cGVyZXAuSW50MzJcbmxldCB0eXBlcmVwX29mX2ludDY0ID0gVHlwZXJlcC5JbnQ2NFxubGV0IHR5cGVyZXBfb2ZfbmF0aXZlaW50ID0gVHlwZXJlcC5OYXRpdmVpbnRcbmxldCB0eXBlcmVwX29mX2NoYXIgPSBUeXBlcmVwLkNoYXJcbmxldCB0eXBlcmVwX29mX2Zsb2F0ID0gVHlwZXJlcC5GbG9hdFxubGV0IHR5cGVyZXBfb2Zfc3RyaW5nID0gVHlwZXJlcC5TdHJpbmdcbmxldCB0eXBlcmVwX29mX2J5dGVzID0gVHlwZXJlcC5CeXRlc1xubGV0IHR5cGVyZXBfb2ZfYm9vbCA9IFR5cGVyZXAuQm9vbFxubGV0IHR5cGVyZXBfb2ZfdW5pdCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2Zfb3B0aW9uIHJlcCA9IFR5cGVyZXAuT3B0aW9uIHJlcFxubGV0IHR5cGVyZXBfb2ZfbGlzdCByZXAgPSBUeXBlcmVwLkxpc3QgcmVwXG5sZXQgdHlwZXJlcF9vZl9hcnJheSByZXAgPSBUeXBlcmVwLkFycmF5IHJlcFxubGV0IHR5cGVyZXBfb2ZfbGF6eV90IHJlcCA9IFR5cGVyZXAuTGF6eSByZXBcbmxldCB0eXBlcmVwX29mX3JlZiByZXAgPSBUeXBlcmVwLlJlZiByZXBcbmxldCB0eXBlcmVwX29mX2Z1bmN0aW9uIGRvbSBybmcgPSBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZylcbmxldCB0eXBlcmVwX29mX3R1cGxlMCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2ZfdHVwbGUyIGEgYiA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGUzIGEgYiBjID0gVHlwZXJlcC5UdXBsZSAoVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTQgYSBiIGMgZCA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU1IGEgYiBjIGQgZSA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpKVxuXG5pbmNsdWRlIE5hbWVfb2ZcblxubGV0IHZhbHVlX3R1cGxlMCA9ICgpXG5cbmxldCB0eXBlcmVwX29mX2ludDYzLCB0eXBlbmFtZV9vZl9pbnQ2MyA9XG4gIGxldCB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByXG4gICAgOiB0eXBlIGEgYi4gKGEsIGIpIEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLnQgLT4gYSBUeXBlcmVwLnQgKiBhIFR5cGVuYW1lLnRcbiAgICA9IGZ1bmN0aW9uXG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludCAtPiB0eXBlcmVwX29mX2ludCwgdHlwZW5hbWVfb2ZfaW50XG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludDY0IC0+IHR5cGVyZXBfb2ZfaW50NjQsIHR5cGVuYW1lX29mX2ludDY0XG4gIGluXG4gIHR5cGVyZXBfYW5kX3R5cGVuYW1lX29mX2ludDYzX3JlcHIgQmFzZS5JbnQ2My5Qcml2YXRlLnJlcHJcbjs7XG4iLCIoKiB1c2luZyB0aGUgaGFzaF92YXJpYW50IG9mIHBhX3R5cGVfY29udiBhdCBjb21waWxlIHRpbWUgKilcbmxldCByZXByX29mX3BvbHlfdmFyaWFudCA6IFs+IF0gLT4gaW50ID1cbiAgZnVuIHZhcmlhbnQgLT5cbiAgbGV0IG9iaiA9IE9iai5yZXByIHZhcmlhbnQgaW5cbiAgaWYgT2JqLmlzX2ludCBvYmpcbiAgdGhlbiBPYmoub2JqIG9ialxuICBlbHNlIChcbiAgICBsZXQgc2l6ZSA9IE9iai5zaXplIG9iaiBpblxuICAgIGFzc2VydCAoc2l6ZSA9IDIpO1xuICAgIGxldCByZXByID0gT2JqLmZpZWxkIG9iaiAwIGluXG4gICAgYXNzZXJ0IChPYmouaXNfaW50IHJlcHIpO1xuICAgIE9iai5vYmogcmVwcilcbjs7XG5cbmxldCBoYXNoX3ZhcmlhbnQgcyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9ICgyMjMgKiAhYWNjdSkgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgoMSBsc2wgMzEpIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3Vcbjs7XG5cbigqIGEgZmV3IHVuaXQgdGVzdHMgb2YgY2FzZXMgdGhhdCBoYXZlIHRyaWdnZXJlZCBkaWZmcyBpbiB0aGUgcGFzdCBvZiB0aGlzXG4gICBsaWIgKilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYExhdGVuY3lfc3RhdHMgPSBoYXNoX3ZhcmlhbnQgXCJMYXRlbmN5X3N0YXRzXCIpXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGB6ZXJvID0gaGFzaF92YXJpYW50IFwiemVyb1wiKVxubGV0IGRvdWJsZV9hcnJheV92YWx1ZSA9IE9iai5tYWdpYyAwLlxubGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIGEgPSBPYmouZG91YmxlX2FycmF5X3RhZyA9IE9iai50YWcgKE9iai5yZXByIGEpXG5cbmxldCAoKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgZG91YmxlID1cbiAgICAgIHsgYSA6IGZsb2F0XG4gICAgICA7IGIgOiBmbG9hdFxuICAgICAgfVxuXG4gICAgdHlwZSBzaW1wbGUgPVxuICAgICAgeyBjIDogZmxvYXRcbiAgICAgIDsgZCA6IGludFxuICAgICAgfVxuXG4gICAgbGV0IGRvdWJsZSA9IHsgYSA9IGRvdWJsZV9hcnJheV92YWx1ZTsgYiA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gICAgbGV0IHNpbXBsZSA9IHsgYyA9IGRvdWJsZV9hcnJheV92YWx1ZTsgZCA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gIGVuZFxuICBpblxuICBhc3NlcnQgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uZG91YmxlKTtcbiAgYXNzZXJ0IChub3QgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uc2ltcGxlKSlcbjs7XG4iLCJtb2R1bGUgTSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIGNvbXB1dGUgOiB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gKCdhLCAnYikgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAoJ2EsICdiLCAnYykgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAnZCBYLnQgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgWC50XG4gICAgICAtPiAnYiBYLnRcbiAgICAgIC0+ICdjIFgudFxuICAgICAgLT4gJ2QgWC50XG4gICAgICAtPiAnZSBYLnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgWC50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcbm1vZHVsZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50ZiA9IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmXG5cbm1vZHVsZSBIZWxwZXIgKEEgOiBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TKSAoQiA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpID0gc3RydWN0XG4gIHR5cGUgbWFwID0geyBtYXAgOiAnYS4gJ2EgQS50IC0+ICdhIEIudCB9XG5cbiAgbGV0IG1hcF92YXJpYW50ICh0eXBlIHZhcmlhbnQpIHsgbWFwIH0gKHZhcmlhbnQgOiB2YXJpYW50IEEuVmFyaWFudC50KSA9XG4gICAgbGV0IG1hcF9jcmVhdGUgPSBmdW5jdGlvblxuICAgICAgfCBBLlRhZy5BcmdzIGZjdCAtPiBCLlRhZ19pbnRlcm5hbC5BcmdzIGZjdFxuICAgICAgfCBBLlRhZy5Db25zdCBrIC0+IEIuVGFnX2ludGVybmFsLkNvbnN0IGtcbiAgICBpblxuICAgIGxldCBtYXBfdGFnIHRhZyA9XG4gICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVGFnIHRhZyAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLlRhZy5sYWJlbCB0YWcgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5UYWcudHJhdmVyc2UgdGFnKSBpblxuICAgICAgICBsZXQgYXJpdHkgPSBBLlRhZy5hcml0eSB0YWcgaW5cbiAgICAgICAgbGV0IGFyZ3NfbGFiZWxzID0gQS5UYWcuYXJnc19sYWJlbHMgdGFnIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuVGFnLmluZGV4IHRhZyBpblxuICAgICAgICBsZXQgb2NhbWxfcmVwciA9IEEuVGFnLm9jYW1sX3JlcHIgdGFnIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5UYWcudHlpZCB0YWcgaW5cbiAgICAgICAgbGV0IGNyZWF0ZSA9IG1hcF9jcmVhdGUgKEEuVGFnLmNyZWF0ZSB0YWcpIGluXG4gICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5UYWdcbiAgICAgICAgICAoQi5UYWcuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuVGFnX2ludGVybmFsLmxhYmVsXG4gICAgICAgICAgICAgOyByZXBcbiAgICAgICAgICAgICA7IGFyaXR5XG4gICAgICAgICAgICAgOyBhcmdzX2xhYmVsc1xuICAgICAgICAgICAgIDsgaW5kZXhcbiAgICAgICAgICAgICA7IG9jYW1sX3JlcHJcbiAgICAgICAgICAgICA7IHR5aWRcbiAgICAgICAgICAgICA7IGNyZWF0ZVxuICAgICAgICAgICAgIH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCB2YXJpYW50IGluXG4gICAgbGV0IHBvbHltb3JwaGljID0gQS5WYXJpYW50LmlzX3BvbHltb3JwaGljIHZhcmlhbnQgaW5cbiAgICBsZXQgdGFncyA9XG4gICAgICBBcnJheS5pbml0IChBLlZhcmlhbnQubGVuZ3RoIHZhcmlhbnQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX3RhZyAoQS5WYXJpYW50LnRhZyB2YXJpYW50IGluZGV4KSlcbiAgICBpblxuICAgIGxldCB2YWx1ZSAoYSA6IHZhcmlhbnQpID1cbiAgICAgIG1hdGNoIEEuVmFyaWFudC52YWx1ZSB2YXJpYW50IGEgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVmFsdWUgKGF0YWcsIGEpIC0+XG4gICAgICAgIChmdW4gKHR5cGUgYXJncykgKGF0YWcgOiAodmFyaWFudCwgYXJncykgQS5UYWcudCkgKGEgOiBhcmdzKSAtPlxuICAgICAgICAgICBsZXQgKEIuVmFyaWFudF9pbnRlcm5hbC5UYWcgYnRhZykgPSB0YWdzLihBLlRhZy5pbmRleCBhdGFnKSBpblxuICAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5UYWcudHlpZCBhdGFnKSAoQi5UYWcudHlpZCBidGFnKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYnRhZyA9IChidGFnIDogKHZhcmlhbnQsIGFyZ3MpIEIuVGFnLnQpIGluXG4gICAgICAgICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5WYWx1ZSAoYnRhZywgYSkpXG4gICAgICAgICAgICAgYnRhZylcbiAgICAgICAgICBhdGFnXG4gICAgICAgICAgYVxuICAgIGluXG4gICAgQi5WYXJpYW50LmludGVybmFsX3VzZV9vbmx5IHsgQi5WYXJpYW50X2ludGVybmFsLnR5cGVuYW1lOyB0YWdzOyBwb2x5bW9ycGhpYzsgdmFsdWUgfVxuICA7O1xuXG4gIGxldCBtYXBfcmVjb3JkICh0eXBlIHJlY29yZCkgeyBtYXAgfSAocmVjb3JkIDogcmVjb3JkIEEuUmVjb3JkLnQpID1cbiAgICBsZXQgbWFwX2ZpZWxkIGZpZWxkID1cbiAgICAgIG1hdGNoIGZpZWxkIHdpdGhcbiAgICAgIHwgQS5SZWNvcmQuRmllbGQgZmllbGQgLT5cbiAgICAgICAgbGV0IGxhYmVsID0gQS5GaWVsZC5sYWJlbCBmaWVsZCBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLkZpZWxkLnRyYXZlcnNlIGZpZWxkKSBpblxuICAgICAgICBsZXQgaW5kZXggPSBBLkZpZWxkLmluZGV4IGZpZWxkIGluXG4gICAgICAgIGxldCBpc19tdXRhYmxlID0gQS5GaWVsZC5pc19tdXRhYmxlIGZpZWxkIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5GaWVsZC50eWlkIGZpZWxkIGluXG4gICAgICAgIGxldCBnZXQgPSBBLkZpZWxkLmdldCBmaWVsZCBpblxuICAgICAgICBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZFxuICAgICAgICAgIChCLkZpZWxkLmludGVybmFsX3VzZV9vbmx5XG4gICAgICAgICAgICAgeyBCLkZpZWxkX2ludGVybmFsLmxhYmVsOyByZXA7IGluZGV4OyBpc19tdXRhYmxlOyB0eWlkOyBnZXQgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVjb3JkIGluXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnID0gQS5SZWNvcmQuaGFzX2RvdWJsZV9hcnJheV90YWcgcmVjb3JkIGluXG4gICAgbGV0IGZpZWxkcyA9XG4gICAgICBBcnJheS5pbml0IChBLlJlY29yZC5sZW5ndGggcmVjb3JkKSAoZnVuIGluZGV4IC0+XG4gICAgICAgIG1hcF9maWVsZCAoQS5SZWNvcmQuZmllbGQgcmVjb3JkIGluZGV4KSlcbiAgICBpblxuICAgIGxldCBjcmVhdGUgeyBCLlJlY29yZF9pbnRlcm5hbC5nZXQgfSA9XG4gICAgICBsZXQgZ2V0ICh0eXBlIGEpIChhZmllbGQgOiAoXywgYSkgQS5GaWVsZC50KSA9XG4gICAgICAgIG1hdGNoIGZpZWxkcy4oQS5GaWVsZC5pbmRleCBhZmllbGQpIHdpdGhcbiAgICAgICAgfCBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZCBiZmllbGQgLT5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYmZpZWxkIDogKHJlY29yZCwgZXgpIEIuRmllbGQudCkgLT5cbiAgICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG4gKEEuRmllbGQudHlpZCBhZmllbGQpIChCLkZpZWxkLnR5aWQgYmZpZWxkKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICAgZ2V0IGJmaWVsZClcbiAgICAgICAgICAgIGJmaWVsZFxuICAgICAgaW5cbiAgICAgIEEuUmVjb3JkLmNyZWF0ZSByZWNvcmQgeyBBLlJlY29yZC5nZXQgfVxuICAgIGluXG4gICAgQi5SZWNvcmQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgIHsgQi5SZWNvcmRfaW50ZXJuYWwudHlwZW5hbWU7IGZpZWxkczsgaGFzX2RvdWJsZV9hcnJheV90YWc7IGNyZWF0ZSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgTmFtZWQgPSBzaWdcbiAgdHlwZSAnYSBjb21wdXRhdGlvblxuXG4gIG1vZHVsZSBDb250ZXh0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBpbml0IDogQ29udGV4dC50IC0+ICdhIFR5cGVuYW1lLnQgLT4gJ2EgdFxuICB2YWwgZ2V0X3dpcF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNldF9maW5hbF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNoYXJlIDogXyBUeXBlcmVwLnQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXB1dGF0aW9uID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGludCA6IGludCB0XG4gIHZhbCBpbnQzMiA6IGludDMyIHRcbiAgdmFsIGludDY0IDogaW50NjQgdFxuICB2YWwgbmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgdmFsIGZsb2F0IDogZmxvYXQgdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgdmFsIGJ5dGVzIDogYnl0ZXMgdFxuICB2YWwgYm9vbCA6IGJvb2wgdFxuICB2YWwgdW5pdCA6IHVuaXQgdFxuICB2YWwgb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICB2YWwgbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBhcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICB2YWwgbGF6eV90IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICB2YWwgcmVmXyA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgdmFsIGZ1bmN0aW9uXyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgLT4gJ2IpIHRcbiAgdmFsIHR1cGxlMiA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgdHVwbGUzIDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gKCdhICogJ2IgKiAnYykgdFxuICB2YWwgdHVwbGU0IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgdmFsIHR1cGxlNSA6ICdhIHQgLT4gJ2IgdCAtPiAnYyB0IC0+ICdkIHQgLT4gJ2UgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuICB2YWwgcmVjb3JkIDogJ2EgUmVjb3JkLnQgLT4gJ2EgdFxuICB2YWwgdmFyaWFudCA6ICdhIFZhcmlhbnQudCAtPiAnYSB0XG5cbiAgbW9kdWxlIE5hbWVkIDogTmFtZWQgd2l0aCB0eXBlICdhIGNvbXB1dGF0aW9uIDo9ICdhIHRcbmVuZFxuXG4oKiBzcGVjaWFsIGZ1bmN0b3IgYXBwbGljYXRpb24gZm9yIGNvbXB1dGF0aW9uIGFzIGNsb3N1cmUgb2YgdGhlIGZvcm0gW2EgLT4gYl0gKilcbm1vZHVsZSBNYWtlX25hbWVkX2Zvcl9jbG9zdXJlIChYIDogc2lnXG4gICAgdHlwZSAnYSBpbnB1dFxuICAgIHR5cGUgJ2Egb3V0cHV0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaW5wdXQgLT4gJ2Egb3V0cHV0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoaW1wbGVtZW50cyB1aWQpXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICBuYW1lJ1xuICAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgcHJlcnJfZW5kbGluZSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG4gIGVuZCkgOiBTX2ltcGxlbWVudGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFgudFxuICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuXG4gIGluY2x1ZGUgVHlwZV9nZW5lcmljX2ludGYuTSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIDs7XG5cbiAgICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzID0gSWRlbnQuY2hlY2tfZGVwZW5kZW5jaWVzIFgubmFtZSBYLnJlcXVpcmVkXG5cbiAgICBsZXQgcmVwbGFjZSB0YWJsZSBrZXkgdmFsdWUgPVxuICAgICAgY2hlY2tfZGVwZW5kZW5jaWVzIGtleTtcbiAgICAgIHJlcGxhY2UgKExhenkuZm9yY2UgdGFibGUpIGtleSB2YWx1ZVxuICAgIDs7XG5cbiAgICBsZXQgbWVtIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgbWVtIHRhYmxlIGtleSlcbiAgICAgIGVsc2UgZmFsc2VcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2l6ZSA9IDI1NlxuICBsZXQgdGFibGUwID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUxID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUyID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUzID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU0ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU1ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuXG4gIGxldCBpc19yZWdpc3RlcmVkIHVpZCA9XG4gICAgVWlkX3RhYmxlLm1lbSB0YWJsZTAgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTEgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTIgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTMgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTQgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTUgdWlkXG4gIDs7XG5cbiAgbGV0IGlkZW50ID0geyBJZGVudC5uYW1lID0gWC5uYW1lOyBpbXBsZW1lbnRzID0gaXNfcmVnaXN0ZXJlZCB9XG5cbiAgbW9kdWxlIEZpbmQwIChUIDogVHlwZXJlcC5OYW1lZC5UMCkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gVC5uYW1lZCBjb21wdXRhdGlvbiBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUwIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMgPSAodmFsIHJlcCA6IFMpIGluXG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biBTLnR5cGVuYW1lX29mX3QgVC50eXBlbmFtZV9vZl9uYW1lZCBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgd2l0bmVzcykgUy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMSAoVCA6IFR5cGVyZXAuTmFtZWQuVDEpIDogc2lnXG4gICAgdmFsIGNvbXB1dGUgOiB1bml0IC0+IChULmEgY29tcHV0YXRpb24gLT4gVC5hIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTEgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzEgPSAodmFsIHJlcCA6IFMxKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMVxuICAgICAgICAgICAgKFMxKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFMxLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQyIChUIDogVHlwZXJlcC5OYW1lZC5UMikgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKSBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUyIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMyID0gKHZhbCByZXAgOiBTMikgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzJcbiAgICAgICAgICAgIChTMilcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSBULmEgY29tcHV0YXRpb24gLT4gVC5iIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzIuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDMgKFQgOiBUeXBlcmVwLk5hbWVkLlQzKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTMgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIHJlcCA6IFMzKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fM1xuICAgICAgICAgICAgKFMzKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiBULmMgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNCAoVCA6IFR5cGVyZXAuTmFtZWQuVDQpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU0IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCByZXAgOiBTNCkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzRcbiAgICAgICAgICAgIChTNClcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgPSAoJ2EsICdiLCAnYywgJ2QpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzQuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDUgKFQgOiBUeXBlcmVwLk5hbWVkLlQ1KSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU1IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM1ID0gKHZhbCByZXAgOiBTNSkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzVcbiAgICAgICAgICAgIChTNSlcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzUuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdW5pdCA9IFR5cGVuYW1lLnN0YXRpY1xuXG4gIGxldCByZWdpc3RlcjAgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gKHZhbCBjb21wdXRlIDogUykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIFMudHlwZW5hbWVfb2ZfdCBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjEgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgY29tcHV0ZSA6IFMxKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMxLnR5cGVuYW1lX29mX3QgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTEgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIyIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIGNvbXB1dGUgOiBTMikgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMi50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTIgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIzIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIGNvbXB1dGUgOiBTMykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMy50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMyB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjQgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgY29tcHV0ZSA6IFM0KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM0LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTQgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXI1IGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIGNvbXB1dGUgOiBTNSkgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTNS50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTUgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIgKHR5cGUgYSkgdHlwZXJlcF9vZl9hIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFR5cGVyZXAudHlwZW5hbWVfb2ZfdCB0eXBlcmVwX29mX2FcbiAgICAgIGxldCB0eXBlcmVwX29mX3QgPSB0eXBlcmVwX29mX2FcbiAgICAgIGxldCBjb21wdXRlID0gY29tcHV0ZVxuICAgIGVuZFxuICAgIGluXG4gICAgcmVnaXN0ZXIwIChtb2R1bGUgUyA6IFMpXG4gIDs7XG5cbiAgKCogSU1QTEVNRU5UQVRJT04gKilcblxuICB0eXBlIGltcGxlbWVudGF0aW9uID0geyBnZW5lcmljIDogJ2EuICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiB9XG5cbiAgbGV0IGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gKHR5cGUgYSkgYXV4ID0gZnVuY3Rpb25cbiAgICB8IFR5cGVyZXAuTmFtZWQuVDAgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMCAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDEgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9IChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgOiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQyIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQyIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDIgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIDogKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQzIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQzIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDMgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ0IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ0IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDQgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jLCBULmQpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDUgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDUgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kNSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b21cbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYSlcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYilcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZClcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZSlcbiAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE5vdF9pbXBsZW1lbnRlZCBvZiBzdHJpbmcgKiBzdHJpbmdcblxuICBsZXQgcmFpc2Vfbm90X2ltcGxlbWVudGVkIHN0cmluZyA9IHJhaXNlIChOb3RfaW1wbGVtZW50ZWQgKFgubmFtZSwgc3RyaW5nKSlcblxuICBsZXQgX3VzaW5nX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgY29udGVudCA9XG4gICAgbWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiBhdXggcmVwIHdpdGhcbiAgICB8IFNvbWUgY29tcHV0YXRpb24gLT4gY29tcHV0YXRpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIChtYXRjaCBjb250ZW50IHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgY29udGVudCkgLT4gYXV4LmdlbmVyaWMgY29udGVudFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IHJlcCBpblxuICAgICAgICAgbGV0IG5hbWUgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIHR5cGVuYW1lKSBpblxuICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWUpXG4gIDs7XG5lbmRcblxubW9kdWxlIF8gPSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLktleSlcblxubW9kdWxlIE1ha2UgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5cbiAgICBpbmNsdWRlIENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIENvbXB1dGF0aW9uID0gWFxuICBpbmNsdWRlIE1ha2VfU19pbXBsZW1lbnRhdGlvbiAoWClcblxuICBtb2R1bGUgTWVtbyA9IFR5cGVuYW1lLlRhYmxlIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFguTmFtZWQudFxuICAgIGVuZClcblxuICBtb2R1bGUgSGVscGVyID0gSGVscGVyIChUeXBlcmVwKSAoQ29tcHV0YXRpb24pXG5cbiAgbGV0IG9mX3R5cGVyZXAgcmVwID1cbiAgICBsZXQgY29udGV4dCA9IFguTmFtZWQuQ29udGV4dC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgbWVtb190YWJsZSA9IE1lbW8uY3JlYXRlIDMyIGluXG4gICAgbGV0IHJlYyBvZl90eXBlcmVwIDogdHlwZSBhLiBhIFR5cGVyZXAudCAtPiBhIHQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLkludCAtPiBYLmludFxuICAgICAgfCBUeXBlcmVwLkludDMyIC0+IFguaW50MzJcbiAgICAgIHwgVHlwZXJlcC5JbnQ2NCAtPiBYLmludDY0XG4gICAgICB8IFR5cGVyZXAuTmF0aXZlaW50IC0+IFgubmF0aXZlaW50XG4gICAgICB8IFR5cGVyZXAuQ2hhciAtPiBYLmNoYXJcbiAgICAgIHwgVHlwZXJlcC5GbG9hdCAtPiBYLmZsb2F0XG4gICAgICB8IFR5cGVyZXAuU3RyaW5nIC0+IFguc3RyaW5nXG4gICAgICB8IFR5cGVyZXAuQnl0ZXMgLT4gWC5ieXRlc1xuICAgICAgfCBUeXBlcmVwLkJvb2wgLT4gWC5ib29sXG4gICAgICB8IFR5cGVyZXAuVW5pdCAtPiBYLnVuaXRcbiAgICAgIHwgVHlwZXJlcC5PcHRpb24gcmVwIC0+IFgub3B0aW9uIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MaXN0IHJlcCAtPiBYLmxpc3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkFycmF5IHJlcCAtPiBYLmFycmF5IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MYXp5IHJlcCAtPiBYLmxhenlfdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuUmVmIHJlcCAtPiBYLnJlZl8gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZykgLT4gWC5mdW5jdGlvbl8gKG9mX3R5cGVyZXAgZG9tKSAob2ZfdHlwZXJlcCBybmcpXG4gICAgICB8IFR5cGVyZXAuVHVwbGUgdHVwbGUgLT5cbiAgICAgICAgKCogZG8gTk9UIHdyaXRlIFtYLnR1cGxlMiAob2ZfdHlwZXJlcCBhKSAob2ZfdHlwZXJlcCBiKV1cbiAgICAgICAgICAgYmVjYXVzZSBvZl90eXBlcmVwIGNhbiBjb250YWluIGEgc2lkZSBlZmZlY3QgYW5kIFthXSBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgYmVmb3JlIFtiXSAqKVxuICAgICAgICAobWF0Y2ggdHVwbGUgd2l0aFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIFgudHVwbGUyIHJhIHJiXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIFgudHVwbGUzIHJhIHJiIHJjXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBYLnR1cGxlNCByYSByYiByYyByZFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgbGV0IHJlID0gb2ZfdHlwZXJlcCBlIGluXG4gICAgICAgICAgIFgudHVwbGU1IHJhIHJiIHJjIHJkIHJlKVxuICAgICAgfCBUeXBlcmVwLlJlY29yZCByZWNvcmQgLT5cbiAgICAgICAgWC5yZWNvcmQgKEhlbHBlci5tYXBfcmVjb3JkIHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSByZWNvcmQpXG4gICAgICB8IFR5cGVyZXAuVmFyaWFudCB2YXJpYW50IC0+XG4gICAgICAgIFgudmFyaWFudCAoSGVscGVyLm1hcF92YXJpYW50IHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSB2YXJpYW50KVxuICAgICAgfCBUeXBlcmVwLk5hbWVkIChuYW1lZCwgY29udGVudCkgLT5cbiAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IG5hbWVkIGluXG4gICAgICAgIChtYXRjaCBNZW1vLmZpbmQgbWVtb190YWJsZSB0eXBlbmFtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgc2hhcmVkIC0+IFguTmFtZWQuZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWRcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiB7IGdlbmVyaWMgPSBvZl90eXBlcmVwIH0gbmFtZWQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGNvbXB1dGF0aW9uIC0+IGNvbXB1dGF0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCB0eXBlbmFtZSkgaW5cbiAgICAgICAgICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPlxuICAgICAgICAgICAgICAgICBpZiBYLk5hbWVkLnNoYXJlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IHNoYXJlZCA9IFguTmFtZWQuaW5pdCBjb250ZXh0IHR5cGVuYW1lIGluXG4gICAgICAgICAgICAgICAgICAgTWVtby5zZXQgbWVtb190YWJsZSB0eXBlbmFtZSBzaGFyZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCBjb250ZW50IGluXG4gICAgICAgICAgICAgICAgICAgWC5OYW1lZC5zZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICAgICAgICBlbHNlIG9mX3R5cGVyZXAgY29udGVudCkpKVxuICAgIGluXG4gICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCByZXAgaW5cbiAgICBgZ2VuZXJpYyBjb21wdXRhdGlvblxuICA7O1xuZW5kXG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCA9XG4gICAgVHlwZXJlcC5OYW1lZC5UMFxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBuYW1lZCA9IFgudFxuICAgICAgICB0eXBlIHQgPSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEpIG9mX3AxID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90IChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSBuYW1lZCA9ICdhIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIHQgPSBwMSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBwMSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIpIG9mX3AxIG9mX3AyID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMlxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZCA9ICgnYSwgJ2IpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyKSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMpIG9mX3AxIG9mX3AyIG9mX3AzID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UM1xuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWQgPSAoJ2EsICdiLCAnYykgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDRcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCkgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgZCA9IHA0XG5cbiAgICAgICAgbGV0IGQgPSBvZl9wNFxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0KSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMgcDQgcDUpIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A0KVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A1KVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UNVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIGUgPSBwNVxuXG4gICAgICAgIGxldCBlID0gb2ZfcDVcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnQpXG4gIDs7XG5lbmRcbiIsIm9wZW4gU3RkX2ludGVybmFsXG5cbm1vZHVsZSBNYWtlMCAoWCA6IE5hbWVkX2ludGYuUzApIDogVHlwZXJlcGFibGUuUyB3aXRoIHR5cGUgdCA6PSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UwIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3QgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpIDogVHlwZXJlcGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBOYW1lZF9pbnRmLlMyKSA6IFR5cGVyZXBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFgudCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpIDpcbiAgVHlwZXJlcGFibGUuUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpIDpcbiAgVHlwZXJlcGFibGUuUzQgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA6PSAoJ2EsICdiLCAnYywgJ2QpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTQgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCwgTm9uZSlcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpIDpcbiAgVHlwZXJlcGFibGUuUzUgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlNSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1LCBOb25lKVxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcbiJdfQ==
