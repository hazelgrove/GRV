// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Incremental__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incremental = [0];
   runtime.caml_register_global(0, Incremental, "Incremental__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Before_or_after
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Before_or_afte$0 = "Incremental__Before_or_after",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Before_or_afte$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/before_or_after.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _a_ = [0, "After"],
    _b_ = [0, "Before"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Before_or_afte = cst_Incremental_Before_or_afte$0;
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Before_or_afte);
   var Incremental_Before_or_after = [0, sexp_of_t];
   runtime.caml_register_global
    (13, Incremental_Before_or_after, cst_Incremental_Before_or_afte$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Import
//# unitInfo: Requires: Core, Core__Array, Core__Int, Core__String, Core__Time_ns, Core__Uniform_array, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Uopt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Import$0 = "Incremental__Import",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Array = global_data.Core__Array,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Time_ns = global_data.Core__Time_ns,
    include = global_data.Uopt,
    Core_Uniform_array = global_data.Core__Uniform_array;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _a_ = Core_Int[99],
    symbol = _a_[1],
    symbol$0 = _a_[2],
    symbol$1 = _a_[3],
    symbol$2 = _a_[4],
    symbol$3 = _a_[5],
    symbol$4 = _a_[6],
    equal = _a_[7],
    compare = _a_[8],
    min = _a_[9],
    max = _a_[10],
    concat = Core_String[32],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Import = cst_Incremental_Import$0,
    debug = 0;
   function tag(arg0_001, arg1_002, sexp_of_a){
    var
     res0_003 = caml_call1(Core[471], arg0_001),
     res1_004 = caml_call1(sexp_of_a, arg1_002);
    return [1, [0, res0_003, [0, res1_004, 0]]];
   }
   var
    Span = Core_Time_ns[1],
    Ofday = Core_Time_ns[2],
    hash_fold_t = Core_Time_ns[3],
    hash = Core_Time_ns[4],
    typerep_of_t = Core_Time_ns[5],
    typename_of_t = Core_Time_ns[6],
    bin_size_t = Core_Time_ns[7],
    bin_write_t = Core_Time_ns[8],
    bin_read_t = Core_Time_ns[9],
    bin_read_t$0 = Core_Time_ns[10],
    bin_shape_t = Core_Time_ns[11],
    bin_writer_t = Core_Time_ns[12],
    bin_reader_t = Core_Time_ns[13],
    bin_t = Core_Time_ns[14],
    symbol$5 = Core_Time_ns[15],
    symbol$6 = Core_Time_ns[16],
    symbol$7 = Core_Time_ns[17],
    symbol$8 = Core_Time_ns[18],
    symbol$9 = Core_Time_ns[19],
    symbol$10 = Core_Time_ns[20],
    equal$0 = Core_Time_ns[21],
    compare$0 = Core_Time_ns[22],
    min$0 = Core_Time_ns[23],
    max$0 = Core_Time_ns[24],
    Alternate_sexp = Core_Time_ns[25],
    quickcheck_generator = Core_Time_ns[26],
    quickcheck_observer = Core_Time_ns[27],
    quickcheck_shrinker = Core_Time_ns[28],
    gen_incl = Core_Time_ns[29],
    gen_uniform_incl = Core_Time_ns[30],
    is_earlier = Core_Time_ns[31],
    is_later = Core_Time_ns[32],
    of_date_ofday = Core_Time_ns[33],
    of_date_ofday_precise = Core_Time_ns[34],
    to_date_ofday = Core_Time_ns[35],
    to_date_ofday_precise = Core_Time_ns[36],
    to_date = Core_Time_ns[37],
    to_ofday = Core_Time_ns[38],
    reset_date_cache = Core_Time_ns[39],
    convert = Core_Time_ns[40],
    utc_offset = Core_Time_ns[41],
    to_filename_string = Core_Time_ns[42],
    of_filename_string = Core_Time_ns[43],
    to_string_abs = Core_Time_ns[44],
    to_string_abs_trimmed = Core_Time_ns[45],
    to_string_abs_parts = Core_Time_ns[46],
    to_string_trimmed = Core_Time_ns[47],
    to_sec_string = Core_Time_ns[48],
    to_sec_string_with_zone = Core_Time_ns[49],
    of_localized_string = Core_Time_ns[50],
    of_string_gen = Core_Time_ns[51],
    to_string_iso8601_basic = Core_Time_ns[52],
    occurrence = Core_Time_ns[53],
    of_string = Core_Time_ns[54],
    of_string_with_utc_offset = Core_Time_ns[55],
    to_string = Core_Time_ns[56],
    to_string_utc = Core_Time_ns[57],
    epoch = Core_Time_ns[58],
    min_value_representable = Core_Time_ns[59],
    max_value_representable = Core_Time_ns[60],
    min_value_for_1us_rounding = Core_Time_ns[61],
    max_value_for_1us_rounding = Core_Time_ns[62],
    min_value = Core_Time_ns[63],
    max_value = Core_Time_ns[64],
    now = Core_Time_ns[65],
    add = Core_Time_ns[66],
    add_saturating = Core_Time_ns[67],
    sub_saturating = Core_Time_ns[68],
    sub = Core_Time_ns[69],
    next = Core_Time_ns[70],
    prev = Core_Time_ns[71],
    diff = Core_Time_ns[72],
    abs_diff = Core_Time_ns[73],
    to_span_since_epoch = Core_Time_ns[74],
    of_span_since_epoch = Core_Time_ns[75],
    to_int63_ns_since_epoch = Core_Time_ns[76],
    of_int63_ns_since_epoch = Core_Time_ns[77],
    to_int_ns_since_epoch = Core_Time_ns[78],
    of_int_ns_since_epoch = Core_Time_ns[79],
    next_multiple = Core_Time_ns[80],
    prev_multiple = Core_Time_ns[81],
    random = Core_Time_ns[82],
    of_time = Core_Time_ns[83],
    to_time = Core_Time_ns[84],
    to_time_float_round_nearest = Core_Time_ns[85],
    to_time_float_round_nearest_mi = Core_Time_ns[86],
    of_time_float_round_nearest = Core_Time_ns[87],
    of_time_float_round_nearest_mi = Core_Time_ns[88],
    Utc = Core_Time_ns[89],
    Stable = Core_Time_ns[90],
    Hash_queue = Core_Time_ns[91],
    Hash_set = Core_Time_ns[92],
    Map = Core_Time_ns[93],
    Option = Core_Time_ns[94],
    Replace_polymorphic_compare = Core_Time_ns[95],
    Set = Core_Time_ns[96],
    Table = Core_Time_ns[97],
    Zone = Core_Time_ns[98],
    arg_type = Core_Time_ns[99],
    comparator = Core_Time_ns[100],
    get_sexp_zone = Core_Time_ns[101],
    interruptible_pause = Core_Time_ns[102],
    of_date_ofday_zoned = Core_Time_ns[103],
    of_string_abs = Core_Time_ns[104],
    of_string_fix_proto = Core_Time_ns[105],
    pause = Core_Time_ns[106],
    pause_forever = Core_Time_ns[107],
    pp = Core_Time_ns[108],
    set_sexp_zone = Core_Time_ns[109],
    sexp_of_t_abs = Core_Time_ns[111],
    t_of_sexp = Core_Time_ns[112],
    t_of_sexp_abs = Core_Time_ns[113],
    to_date_ofday_zoned = Core_Time_ns[114],
    to_ofday_zoned = Core_Time_ns[115],
    to_string_fix_proto = Core_Time_ns[116],
    validate_bound = Core_Time_ns[117],
    validate_lbound = Core_Time_ns[118],
    validate_ubound = Core_Time_ns[119],
    sexp_of_t = Core_Time_ns[25][4],
    Time_ns =
      [0,
       Span,
       Ofday,
       hash_fold_t,
       hash,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       equal$0,
       compare$0,
       min$0,
       max$0,
       Alternate_sexp,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       Utc,
       Stable,
       Hash_queue,
       Hash_set,
       Map,
       Option,
       Replace_polymorphic_compare,
       Set,
       Table,
       Zone,
       arg_type,
       comparator,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       validate_bound,
       validate_lbound,
       validate_ubound,
       sexp_of_t],
    bin_shape_t$0 = Core_Array[1],
    bin_size_t$0 = Core_Array[2],
    bin_write_t$0 = Core_Array[3],
    bin_read_t$1 = Core_Array[4],
    bin_read_t$2 = Core_Array[5],
    bin_writer_t$0 = Core_Array[6],
    bin_reader_t$0 = Core_Array[7],
    bin_t$0 = Core_Array[8],
    quickcheck_generator$0 = Core_Array[9],
    quickcheck_observer$0 = Core_Array[10],
    quickcheck_shrinker$0 = Core_Array[11],
    typerep_of_t$0 = Core_Array[12],
    typename_of_t$0 = Core_Array[13],
    compare$1 = Core_Array[14],
    t_of_sexp$0 = Core_Array[15],
    sexp_of_t$0 = Core_Array[16],
    t_sexp_grammar = Core_Array[17],
    binary_search = Core_Array[18],
    binary_search_segmented = Core_Array[19],
    mem = Core_Array[20],
    is_empty = Core_Array[21],
    iter = Core_Array[22],
    fold = Core_Array[23],
    fold_result = Core_Array[24],
    fold_until = Core_Array[25],
    exists = Core_Array[26],
    for_all = Core_Array[27],
    count = Core_Array[28],
    sum = Core_Array[29],
    find = Core_Array[30],
    find_map = Core_Array[31],
    to_list = Core_Array[32],
    to_array = Core_Array[33],
    min_elt = Core_Array[34],
    max_elt = Core_Array[35],
    invariant = Core_Array[36],
    max_length = Core_Array[37],
    create = Core_Array[38],
    create_float_uninitialized = Core_Array[39],
    init = Core_Array[40],
    make_matrix = Core_Array[41],
    copy_matrix = Core_Array[42],
    append = Core_Array[43],
    concat$0 = Core_Array[44],
    copy = Core_Array[45],
    fill = Core_Array[46],
    blit = Core_Array[47],
    blito = Core_Array[48],
    unsafe_blit = Core_Array[49],
    sub$0 = Core_Array[50],
    subo = Core_Array[51],
    of_list = Core_Array[52],
    map = Core_Array[53],
    folding_map = Core_Array[54],
    folding_mapi = Core_Array[55],
    fold_map = Core_Array[56],
    fold_mapi = Core_Array[57],
    iteri = Core_Array[58],
    mapi = Core_Array[59],
    foldi = Core_Array[60],
    fold_right = Core_Array[61],
    sort = Core_Array[62],
    stable_sort = Core_Array[63],
    is_sorted = Core_Array[64],
    is_sorted_strictly = Core_Array[65],
    merge = Core_Array[66],
    concat_map = Core_Array[67],
    concat_mapi = Core_Array[68],
    partition_tf = Core_Array[69],
    partitioni_tf = Core_Array[70],
    cartesian_product = Core_Array[71],
    transpose = Core_Array[72],
    transpose_exn = Core_Array[73],
    filter_opt = Core_Array[74],
    filter_map = Core_Array[75],
    filter_mapi = Core_Array[76],
    for_alli = Core_Array[77],
    existsi = Core_Array[78],
    counti = Core_Array[79],
    iter2_exn = Core_Array[80],
    map2_exn = Core_Array[81],
    fold2_exn = Core_Array[82],
    for_all2_exn = Core_Array[83],
    exists2_exn = Core_Array[84],
    filter = Core_Array[85],
    filteri = Core_Array[86],
    swap = Core_Array[87],
    rev_inplace = Core_Array[88],
    rev = Core_Array[89],
    of_list_rev = Core_Array[90],
    of_list_map = Core_Array[91],
    of_list_mapi = Core_Array[92],
    of_list_rev_map = Core_Array[93],
    of_list_rev_mapi = Core_Array[94],
    map_inplace = Core_Array[95],
    find_exn = Core_Array[96],
    find_map_exn = Core_Array[97],
    findi = Core_Array[98],
    findi_exn = Core_Array[99],
    find_mapi = Core_Array[100],
    find_mapi_exn = Core_Array[101],
    find_consecutive_duplicate = Core_Array[102],
    reduce = Core_Array[103],
    reduce_exn = Core_Array[104],
    permute = Core_Array[105],
    random_element = Core_Array[106],
    random_element_exn = Core_Array[107],
    zip = Core_Array[108],
    zip_exn = Core_Array[109],
    unzip = Core_Array[110],
    sorted_copy = Core_Array[111],
    last = Core_Array[112],
    equal$1 = Core_Array[113],
    to_sequence = Core_Array[114],
    to_sequence_mutable = Core_Array[115],
    Int = Core_Array[116],
    Float = Core_Array[117],
    normalize = Core_Array[118],
    slice = Core_Array[119],
    nget = Core_Array[120],
    nset = Core_Array[121],
    Permissioned = Core_Array[122];
   function realloc(t, len, a){
    var new_t = caml_call2(create, len, a);
    caml_call5(Core_Array[47], t, 0, new_t, 0, t.length - 1);
    return new_t;
   }
   var
    Array =
      [0,
       bin_shape_t$0,
       bin_size_t$0,
       bin_write_t$0,
       bin_read_t$1,
       bin_read_t$2,
       bin_writer_t$0,
       bin_reader_t$0,
       bin_t$0,
       quickcheck_generator$0,
       quickcheck_observer$0,
       quickcheck_shrinker$0,
       typerep_of_t$0,
       typename_of_t$0,
       compare$1,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       max_length,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat$0,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit,
       sub$0,
       subo,
       of_list,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       iteri,
       mapi,
       foldi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       concat_map,
       concat_mapi,
       partition_tf,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       filter_map,
       filter_mapi,
       for_alli,
       existsi,
       counti,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       filter,
       filteri,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi,
       findi_exn,
       find_mapi,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal$1,
       to_sequence,
       to_sequence_mutable,
       Int,
       Float,
       normalize,
       slice,
       nget,
       nset,
       Permissioned,
       realloc],
    sexp_of_t$1 = include[1],
    invariant$0 = include[2],
    none = include[3],
    some = include[4],
    is_none = include[5],
    is_some = include[6],
    value_exn = include[7],
    unsafe_value = include[8],
    to_option = include[9],
    of_option = include[10],
    Optional_syntax = include[11],
    Uopt =
      [0,
       sexp_of_t$1,
       invariant$0,
       none,
       some,
       is_none,
       is_some,
       value_exn,
       to_option,
       of_option,
       Optional_syntax,
       unsafe_value],
    bin_shape_t$1 = Core_Uniform_array[1],
    bin_size_t$1 = Core_Uniform_array[2],
    bin_write_t$1 = Core_Uniform_array[3],
    bin_read_t$3 = Core_Uniform_array[4],
    bin_read_t$4 = Core_Uniform_array[5],
    bin_writer_t$1 = Core_Uniform_array[6],
    bin_reader_t$1 = Core_Uniform_array[7],
    bin_t$1 = Core_Uniform_array[8],
    t_of_sexp$1 = Core_Uniform_array[9],
    sexp_of_t$2 = Core_Uniform_array[10],
    t_sexp_grammar$0 = Core_Uniform_array[11],
    compare$2 = Core_Uniform_array[12],
    invariant$1 = Core_Uniform_array[13],
    empty = Core_Uniform_array[14],
    create$0 = Core_Uniform_array[15],
    singleton = Core_Uniform_array[16],
    init$0 = Core_Uniform_array[17],
    length = Core_Uniform_array[18],
    get = Core_Uniform_array[19],
    unsafe_get = Core_Uniform_array[20],
    swap$0 = Core_Uniform_array[23],
    unsafe_set_omit_phys_equal_che = Core_Uniform_array[24],
    unsafe_set_with_caml_modify = Core_Uniform_array[25],
    set_with_caml_modify = Core_Uniform_array[26],
    map$0 = Core_Uniform_array[27],
    mapi$0 = Core_Uniform_array[28],
    iter$0 = Core_Uniform_array[29],
    iteri$0 = Core_Uniform_array[30],
    foldi$0 = Core_Uniform_array[31],
    of_array = Core_Uniform_array[32],
    to_array$0 = Core_Uniform_array[33],
    of_list$0 = Core_Uniform_array[34],
    to_list$0 = Core_Uniform_array[35],
    blit$0 = Core_Uniform_array[36],
    blito$0 = Core_Uniform_array[37],
    unsafe_blit$0 = Core_Uniform_array[38],
    sub$1 = Core_Uniform_array[39],
    subo$0 = Core_Uniform_array[40],
    copy$0 = Core_Uniform_array[41],
    unsafe_create_uninitialized = Core_Uniform_array[42],
    create_obj_array = Core_Uniform_array[43],
    unsafe_set_assuming_currently_ = Core_Uniform_array[44],
    unsafe_set_int_assuming_curren = Core_Uniform_array[45],
    unsafe_set_int = Core_Uniform_array[46],
    unsafe_clear_if_pointer = Core_Uniform_array[47],
    exists$0 = Core_Uniform_array[48],
    for_all$0 = Core_Uniform_array[49],
    map2_exn$0 = Core_Uniform_array[50],
    min_elt$0 = Core_Uniform_array[51],
    max_elt$0 = Core_Uniform_array[52];
   function realloc$0(t, len){
    var new_t = caml_call2(create$0, len, Uopt[3]);
    caml_call5(blit$0, t, 0, new_t, 0, caml_call1(length, t));
    return new_t;
   }
   var
    Uniform_array =
      [0,
       bin_shape_t$1,
       bin_size_t$1,
       bin_write_t$1,
       bin_read_t$3,
       bin_read_t$4,
       bin_writer_t$1,
       bin_reader_t$1,
       bin_t$1,
       t_of_sexp$1,
       sexp_of_t$2,
       t_sexp_grammar$0,
       compare$2,
       invariant$1,
       empty,
       create$0,
       singleton,
       init$0,
       length,
       get,
       unsafe_get,
       swap$0,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map$0,
       mapi$0,
       iter$0,
       iteri$0,
       foldi$0,
       of_array,
       to_array$0,
       of_list$0,
       to_list$0,
       blit$0,
       blito$0,
       unsafe_blit$0,
       sub$1,
       subo$0,
       copy$0,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists$0,
       for_all$0,
       map2_exn$0,
       min_elt$0,
       max_elt$0,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       realloc$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Import);
   var
    Incremental_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       debug,
       concat,
       tag,
       Time_ns,
       Array,
       Uopt,
       Uniform_array];
   runtime.caml_register_global
    (18, Incremental_Import, cst_Incremental_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Cutoff
//# unitInfo: Requires: Base__Invariant, Core, Expect_test_collector, Incremental__Import, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Cutoff$0 = "Incremental__Cutoff",
    cst_incremental$0 = "incremental",
    cst_src_cutoff_ml = "src/cutoff.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Cutoff$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_cutoff_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _g_ = [0, "_"],
    _h_ = [0, cst_src_cutoff_ml, 17, 409, 431],
    _a_ = [0, "Always"],
    _b_ = [0, "Never"],
    _c_ = [0, "Phys_equal"],
    _d_ = [0, "Compare"],
    _e_ = [0, "Equal"],
    _f_ = [0, "F"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Cutoff = cst_Incremental_Cutoff$0;
   function sexp_of_t(of_a_001, param){
    if(typeof param === "number")
     switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;}
    switch(param[0]){
      case 0:
       var
        _l_ = function(_q_){return 0;},
        res0_003 = caml_call1(Sexplib0_Sexp_conv[24], _l_);
       return [1, [0, _d_, [0, res0_003, 0]]];
      case 1:
       var
        _m_ = function(_p_){return 0;},
        res0_005 = caml_call1(Sexplib0_Sexp_conv[24], _m_);
       return [1, [0, _e_, [0, res0_005, 0]]];
      default:
       var
        _n_ = function(_o_){return 0;},
        res0_007 = caml_call1(Sexplib0_Sexp_conv[24], _n_);
       return [1, [0, _f_, [0, res0_007, 0]]];
    }
   }
   function invariant(param, t){
    function _j_(param){return 0;}
    function _k_(x_009){
     return sexp_of_t(function(param){return _g_;}, x_009);
    }
    return caml_call4(Base_Invariant[1], _h_, t, _k_, _j_);
   }
   function create(f){return [2, f];}
   function of_compare(f){return [0, f];}
   function of_equal(f){return [1, f];}
   var poly_equal = [1, runtime.caml_equal], never = 1, always = 0;
   function should_cutoff(t, old_value, new_value){
    if(typeof t === "number")
     switch(t){
       case 0:
        return 1;
       case 1:
        return 0;
       default: return caml_call2(Core[246], old_value, new_value);
     }
    switch(t[0]){
      case 0:
       var f = t[1], _i_ = caml_call2(f, old_value, new_value);
       return caml_call2(Incremental_Import[3], _i_, 0);
      case 1:
       var f$0 = t[1]; return caml_call2(f$0, old_value, new_value);
      default: var f$1 = t[1]; return caml_call2(f$1, old_value, new_value);
    }
   }
   function equal(t1, t2){
    if(typeof t1 === "number")
     switch(t1){
       case 0:
        if(typeof t2 === "number" && ! t2) return 1; return 0;
       case 1:
        if(typeof t2 === "number" && 1 === t2) return 1; return 0;
       default: if(typeof t2 === "number" && 2 <= t2) return 1; return 0;
     }
    switch(t1[0]){
      case 0:
       var f1 = t1[1];
       if(typeof t2 !== "number" && 0 === t2[0]){
        var f2 = t2[1];
        return caml_call2(Core[246], f1, f2);
       }
       return 0;
      case 1:
       var f1$0 = t1[1];
       if(typeof t2 !== "number" && 1 === t2[0]){
        var f2$0 = t2[1];
        return caml_call2(Core[246], f1$0, f2$0);
       }
       return 0;
      default:
       var f1$1 = t1[1];
       if(typeof t2 !== "number" && 2 === t2[0]){
        var f2$1 = t2[1];
        return caml_call2(Core[246], f1$1, f2$1);
       }
       return 0;
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Cutoff);
   var
    Incremental_Cutoff =
      [0,
       sexp_of_t,
       invariant,
       create,
       of_compare,
       of_equal,
       always,
       never,
       2,
       poly_equal,
       equal,
       should_cutoff];
   runtime.caml_register_global
    (23, Incremental_Cutoff, cst_Incremental_Cutoff$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Dot_user_info
//# unitInfo: Requires: Core, Core__Comparator, Core__Info, Core__List, Core__Map, Core__Set, Core__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$12 = '"',
    cst_Incremental_Dot_user_info$0 = "Incremental__Dot_user_info",
    cst_incremental$0 = "incremental",
    cst$10 = "{",
    cst$11 = "|",
    cst$9 = "}";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$7 = cst$9,
    cst$8 = cst$10,
    cst$5 = cst$9,
    cst$6 = cst$10,
    cst$4 = "\\",
    cst$0 = cst$12,
    cst$1 = '\\"',
    cst$2 = cst$12,
    cst$3 = cst$12,
    cst = "",
    Core_String = global_data.Core__String,
    Core_Info = global_data.Core__Info,
    Core_Set = global_data.Core__Set,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Comparator = global_data.Core__Comparator;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Dot_user_info$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/dot_user_info.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _j_ = [0, [12, 32, [2, 0, [12, 61, [2, 0, 0]]]], " %s=%s"],
    _h_ = [0, cst$11],
    _i_ = [0, cst$11],
    _k_ = [0, " "],
    _l_ =
      [0,
       [11,
        "  ",
        [2,
         0,
         [11, " [shape=Mrecord label=", [2, 0, [12, 32, [2, 0, [12, 93, 0]]]]]]],
       "  %s [shape=Mrecord label=%s %s]"],
    _c_ = [0, "Dot"],
    _d_ = [0, "Info"],
    _e_ = [0, "new_"],
    _f_ = [0, "prior"],
    _g_ = [0, "Append"],
    _a_ = [0, "attributes"],
    _b_ = [0, "label"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Dot_user_info = cst_Incremental_Dot_user_info$0;
   function compare(a_001, b_002){
    function _H_(a_003, b_004){return caml_call2(Core[467], a_003, b_004);}
    return caml_call3(Core[418], _H_, a_001, b_002);
   }
   function sexp_of_t(x_005){return caml_call2(Core[421], Core[471], x_005);}
   var
    include = caml_call2(Core_Comparator[1], compare, sexp_of_t),
    comparator = include[1];
   function sexp_of_dot(param){
    var
     attributes_009 = param[2],
     label_007 = param[1],
     arg_010 = caml_call2(Core_String[140][107], Core[471], attributes_009),
     bnds_006 = [0, [1, [0, _a_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call2(Core_Set[82], [0, sexp_of_t], label_007),
     bnds_006$0 = [0, [1, [0, _b_, [0, arg_008, 0]]], bnds_006];
    return [1, bnds_006$0];
   }
   function sexp_of_t$0(param){
    switch(param[0]){
      case 0:
       var arg0_011 = param[1], res0_012 = sexp_of_dot(arg0_011);
       return [1, [0, _c_, [0, res0_012, 0]]];
      case 1:
       var arg0_013 = param[1], res0_014 = caml_call1(Core_Info[6], arg0_013);
       return [1, [0, _d_, [0, res0_014, 0]]];
      default:
       var
        new_018 = param[2],
        prior_016 = param[1],
        arg_019 = sexp_of_t$0(new_018),
        bnds_015 = [0, [1, [0, _e_, [0, arg_019, 0]]], 0],
        arg_017 = sexp_of_t$0(prior_016),
        bnds_015$0 = [0, [1, [0, _f_, [0, arg_017, 0]]], bnds_015];
       return [1, [0, _g_, bnds_015$0]];
    }
   }
   function info(info){return [1, info];}
   function append(prior, new$0){return [2, prior, new$0];}
   function dot(label, attributes){
    var label$0 = caml_call2(Core_Set[7], [0, comparator], label);
    return [0, [0, label$0, attributes]];
   }
   function to_dot(param){
    switch(param[0]){
      case 0:
       var dot = param[1]; return dot;
      case 1:
       var
        i = param[1],
        _E_ = Core_String[140][3],
        _F_ = [0, caml_call1(Core_Info[9], i), 0];
       return [0, caml_call2(Core_Set[7], [0, comparator], _F_), _E_];
      default:
       var
        new$0 = param[2],
        prior = param[1],
        prior$0 = to_dot(prior),
        new$1 = to_dot(new$0),
        label = caml_call2(Core_Set[13], prior$0[1], new$1[1]),
        _G_ = function(param, left, right){return right;},
        attributes = caml_call3(Core_Map[78], prior$0[2], new$1[2], _G_);
       return [0, label, attributes];
    }
   }
   function escape_dot_string(s){
    var
     _C_ = caml_call3(Core_String[51], s, cst$2, cst$1),
     _D_ = caml_call2(Core[18], _C_, cst$0);
    return caml_call2(Core[18], cst$3, _D_);
   }
   function escape_record_label(s){
    function _z_(c){
     a:
     {
      if(62 <= c){
       var _A_ = c - 63 | 0;
       if(59 < _A_ >>> 0){if(63 <= _A_) break a;} else if(29 !== _A_) break a;
      }
      else if(32 !== c && 60 !== c) break a;
      var _B_ = caml_call1(Core_String[97], c);
      return caml_call2(Core[18], cst$4, _B_);
     }
     return caml_call1(Core_String[97], c);
    }
    return caml_call3(Core_String[73], 0, s, _z_);
   }
   function to_string(name, param){
    var attributes = param[2], label = param[1];
    function _m_(cols){
     var
      _w_ = caml_call2(Core_List[72], cols, escape_record_label),
      _x_ = caml_call2(Core_String[32], _h_, _w_),
      _y_ = caml_call2(Core[18], _x_, cst$5);
     return caml_call2(Core[18], cst$6, _y_);
    }
    var
     _n_ = caml_call1(Core_Set[38], label),
     _o_ = caml_call2(Core_List[72], _n_, _m_),
     s = caml_call2(Core_String[32], _i_, _o_),
     _p_ = caml_call2(Core[18], s, cst$7),
     label$0 = caml_call2(Core[18], cst$8, _p_);
    function _q_(param){
     var
      v = param[2],
      k = param[1],
      _u_ = escape_dot_string(v),
      _v_ = escape_dot_string(k);
     return caml_call3(Core[257], _j_, _v_, _u_);
    }
    var
     _r_ = caml_call2(Core_Map[74], 0, attributes),
     _s_ = caml_call2(Core_List[72], _r_, _q_),
     attributes$0 = caml_call2(Core_String[32], _k_, _s_),
     _t_ = escape_dot_string(label$0);
    return caml_call4(Core[257], _l_, name, _t_, attributes$0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Dot_user_info);
   var
    Incremental_Dot_user_info =
      [0,
       [0, comparator],
       sexp_of_dot,
       sexp_of_t$0,
       info,
       dot,
       to_dot,
       append,
       to_string];
   runtime.caml_register_global
    (39, Incremental_Dot_user_info, cst_Incremental_Dot_user_info$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Node_id
//# unitInfo: Requires: Assert_failure, Core__Int, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Node_id$0 = "Incremental__Node_id",
    cst_incremental$0 = "incremental",
    cst_src_node_id_ml = "src/node_id.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Node_id$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_node_id_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    incr = Core_Int[32],
    sexp_of_t = Core_Int[80],
    to_string = Core_Int[82],
    symbol = Core_Int[84],
    compare = Core_Int[91],
    hash_fold_t = Core_Int[103],
    hash = Core_Int[104],
    hashable = Core_Int[105],
    Table = Core_Int[106],
    Hash_set = Core_Int[107],
    Hash_queue = Core_Int[108],
    _a_ = [0, cst_src_node_id_ml, 5, 18],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Node_id = cst_Incremental_Node_id$0;
   function invariant(t){
    if(caml_call2(symbol, t, 1)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   var r = [0, 0];
   function next(param){caml_call1(incr, r); return r[1];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Node_id);
   var
    Incremental_Node_id =
      [0,
       sexp_of_t,
       compare,
       hash_fold_t,
       hash,
       hashable,
       [0,
        Table[1],
        Table[2],
        Table[3],
        Table[4],
        Table[5],
        Table[6],
        Table[7],
        Table[8],
        Table[9],
        Table[10],
        Table[11],
        Table[12],
        Table[13],
        Table[14],
        Table[15],
        Table[16],
        Table[17],
        Table[18],
        Table[19],
        Table[20],
        Table[21],
        Table[22],
        Table[23],
        Table[24],
        Table[25],
        Table[26],
        Table[27],
        Table[28],
        Table[29],
        Table[30],
        Table[31],
        Table[32],
        Table[33],
        Table[34],
        Table[35],
        Table[36],
        Table[37],
        Table[38],
        Table[39],
        Table[40],
        Table[41],
        Table[42],
        Table[43],
        Table[44],
        Table[45],
        Table[46],
        Table[47],
        Table[48],
        Table[49],
        Table[50],
        Table[51],
        Table[52],
        Table[53],
        Table[54],
        Table[55],
        Table[56],
        Table[57],
        Table[58],
        Table[59],
        Table[60],
        Table[61],
        Table[62],
        Table[63],
        Table[64],
        Table[65],
        Table[66],
        Table[67],
        Table[68],
        Table[69],
        Table[70],
        Table[71],
        Table[72],
        Table[73],
        Table[74],
        Table[75],
        Table[76],
        Table[77],
        Table[78],
        Table[79],
        Table[80],
        Table[81],
        Table[82],
        Table[83],
        Table[84]],
       [0,
        Hash_set[1],
        Hash_set[2],
        Hash_set[3],
        Hash_set[4],
        Hash_set[5],
        Hash_set[6],
        Hash_set[7]],
       Hash_queue,
       invariant,
       next,
       to_string];
   runtime.caml_register_global
    (14, Incremental_Node_id, cst_Incremental_Node_id$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Stabilization_num
//# unitInfo: Requires: Assert_failure, Core__Int, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Stabilization_$0 = "Incremental__Stabilization_num",
    cst_incremental$0 = "incremental",
    cst_src_stabilization_num_ml = "src/stabilization_num.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Stabilization_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_stabilization_num_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    zero = Core_Int[55],
    to_int = Core_Int[61],
    sexp_of_t = Core_Int[80],
    symbol = Core_Int[84],
    symbol$0 = Core_Int[86],
    equal = Core_Int[90],
    compare = Core_Int[91],
    _a_ = [0, cst_src_stabilization_num_ml, 5, 18],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Stabilization_ = cst_Incremental_Stabilization_$0;
   function invariant(t){
    if(caml_call2(symbol, t, -1)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   var none = -1;
   function is_none(t){return caml_call2(symbol$0, t, none);}
   function is_some(t){return caml_call2(symbol, t, 0);}
   function add1(t){return t + 1 | 0;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Stabilization_);
   var
    Incremental_Stabilization_num =
      [0,
       compare,
       sexp_of_t,
       equal,
       invariant,
       none,
       zero,
       is_none,
       is_some,
       add1,
       to_int];
   runtime.caml_register_global
    (14, Incremental_Stabilization_num, cst_Incremental_Stabilization_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__On_update_handler
//# unitInfo: Requires: Expect_test_collector, Incremental__Import, Incremental__Stabilization_num, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Changed = "Changed",
    cst_Incremental_On_update_hand$0 = "Incremental__On_update_handler",
    cst_Invalidated = "Invalidated",
    cst_Necessary = "Necessary",
    cst_Unnecessary = "Unnecessary",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_Import = global_data.Incremental__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_On_update_hand$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/on_update_handler.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _j_ = [0, "created_at"],
    _k_ = [0, "previous_update_kind"],
    _l_ = [0, "f"],
    _f_ = [0, cst_Invalidated],
    _g_ = [0, cst_Unnecessary],
    _h_ = [0, cst_Necessary],
    _i_ = [0, cst_Changed],
    _a_ = [0, "Never_been_updated"],
    _b_ = [0, cst_Necessary],
    _c_ = [0, cst_Changed],
    _d_ = [0, cst_Invalidated],
    _e_ = [0, cst_Unnecessary],
    cst_incremental = cst_incremental$0,
    cst_Incremental_On_update_hand = cst_Incremental_On_update_hand$0;
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    a:
    {
     if(typeof a_001 === "number"){
      if(0 === a_001){
       if(typeof b_002 === "number") return 0 === b_002 ? 0 : -1;
       if(0 === b_002[0]) break a;
      }
      else{
       if(typeof b_002 === "number") return 0 === b_002 ? 1 : 0;
       if(0 === b_002[0]) break a;
      }
      return 1;
     }
     if(0 === a_001[0]){
      var a_003 = a_001[1];
      if(typeof b_002 !== "number" && 0 === b_002[0]){
       var b_004 = b_002[1];
       return caml_call2(cmp_a, a_003, b_004);
      }
      return -1;
     }
     var a_007 = a_001[2], a_005 = a_001[1];
     if(typeof b_002 === "number") return -1;
     if(0 !== b_002[0]){
      var
       b_008 = b_002[2],
       b_006 = b_002[1],
       n = caml_call2(cmp_a, a_005, b_006);
      return 0 === n ? caml_call2(cmp_a, a_007, b_008) : n;
     }
    }
    return 1;
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return 0 === param ? _f_ : _g_;
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_009, arg0_010);
     return [1, [0, _h_, [0, res0_011, 0]]];
    }
    var
     arg1_013 = param[2],
     arg0_012 = param[1],
     res0_014 = caml_call1(of_a_009, arg0_012),
     res1_015 = caml_call1(of_a_009, arg1_013);
    return [1, [0, _i_, [0, res0_014, [0, res1_015, 0]]]];
   }
   var Node_update = [0, compare, sexp_of_t];
   function sexp_of_t$0(of_a_017, param){
    var
     previous_update_kind_021 = param[2],
     created_at_023 = param[3],
     arg_024 = caml_call1(Incremental_Stabilization_num[2], created_at_023),
     bnds_018 = [0, [1, [0, _j_, [0, arg_024, 0]]], 0];
    switch(previous_update_kind_021){
      case 0:
       var arg_022 = _a_; break;
      case 1:
       var arg_022 = _b_; break;
      case 2:
       var arg_022 = _c_; break;
      case 3:
       var arg_022 = _d_; break;
      default: var arg_022 = _e_;
    }
    var bnds_018$0 = [0, [1, [0, _k_, [0, arg_022, 0]]], bnds_018];
    function _p_(_q_){return 0;}
    var
     arg_020 = caml_call1(Sexplib0_Sexp_conv[24], _p_),
     bnds_018$1 = [0, [1, [0, _l_, [0, arg_020, 0]]], bnds_018$0];
    return [1, bnds_018$1];
   }
   function create(f, created_at){return [0, f, 0, created_at];}
   function really_run(t, node_update){
    var
     _o_ =
       typeof node_update === "number"
        ? 0 === node_update ? 3 : 4
        : 0 === node_update[0] ? 1 : 2;
    t[2] = _o_;
    return caml_call1(t[1], node_update);
   }
   function run(t, node_update, now){
    var
     _m_ = caml_call2(Incremental_Stabilization_num[1], t[3], now),
     _n_ = caml_call2(Incremental_Import[5], _m_, 0);
    if(! _n_) return _n_;
    a:
    {
     b:
     {
      switch(t[2]){
        case 0:
         if(typeof node_update === "number") break a;
         if(1 === node_update[0]) break b;
         break a;
        case 1:
         if(typeof node_update === "number" || 0 !== node_update[0]) break a;
         break;
        case 2:
         if(typeof node_update === "number" || 0 !== node_update[0]) break a;
         break;
        case 3:
         return 0;
        default:
         if(typeof node_update !== "number"){
          if(1 === node_update[0]) break b;
          break a;
         }
         if(1 !== node_update) break a;
      }
      return 0;
     }
     var a = node_update[2];
     return really_run(t, [0, a]);
    }
    return really_run(t, node_update);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_On_update_hand);
   var
    Incremental_On_update_handler = [0, Node_update, sexp_of_t$0, create, run];
   runtime.caml_register_global
    (27, Incremental_On_update_handler, cst_Incremental_On_update_hand$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Raised_exn
//# unitInfo: Requires: Base__Backtrace, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Raised_exn$0 = "Incremental__Raised_exn",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Backtrace = global_data.Base__Backtrace,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Raised_exn$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/raised_exn.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _a_ = [0, "backtrace"],
    _b_ = [0, "exn"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Raised_exn = cst_Incremental_Raised_exn$0;
   function sexp_of_t(param){
    var
     backtrace_004 = param[2],
     exn_002 = param[1],
     arg_005 = caml_call1(Base_Backtrace[1], backtrace_004),
     bnds_001 = [0, [1, [0, _a_, [0, arg_005, 0]]], 0],
     arg_003 = caml_call1(Core[537], exn_002),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_003, 0]]], bnds_001];
    return [1, bnds_001$0];
   }
   function create(exn){return [0, exn, caml_call1(Base_Backtrace[6][4], 0)];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Raised_exn);
   var Incremental_Raised_exn = [0, sexp_of_t, create];
   runtime.caml_register_global
    (15, Incremental_Raised_exn, cst_Incremental_Raised_exn$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Types
//# unitInfo: Requires: CamlinternalMod, Core, Expect_test_collector, Incremental__Import, Incremental__Node_id, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Types$0 = "Incremental__Types",
    cst$0 = "_",
    cst_incremental$0 = "incremental",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Node_id = global_data.Incremental__Node_id,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    CamlinternalMod = global_data.CamlinternalMod;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    Adjust_heights_heap =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 22, 2], [0, [0]]),
    Alarm =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 27, 2], [0, [0]]),
    Alarm_value =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 43, 2], [0, [0, [0, [0]]]]),
    Array_fold =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 52, 2], [0, [0]]),
    At =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 62, 2], [0, [0]]),
    At_intervals =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 73, 2], [0, [0]]),
    Bind =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 86, 2], [0, [0]]),
    Clock =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 96, 2], [0, [0]]),
    Expert =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 117, 2], [0, [0]]),
    Freeze =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 126, 2], [0, [0]]),
    If_then_else =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 138, 2], [0, [0]]),
    Internal_observer =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 165, 2],
        [0, [0, [0, [0]], [0, [0]]]]),
    Join =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 175, 2], [0, [0]]),
    Kind =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 416, 2], [0, [0]]),
    Node =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 460, 6],
        [0, [0, 0, [0, [0, 0]], 0, 0, 0]]),
    Observer =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 519, 2], [0, [0]]),
    Only_in_debug =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 527, 2], [0, [0]]),
    Packed_weak_hashtbl =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 532, 2], [0, [0]]),
    Recompute_heap =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 541, 2], [0, [0]]),
    Run_on_update_handlers =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 546, 2], [0, [0]]),
    Scope =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 553, 6], [0, [0, 0]]),
    Snapshot =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 573, 2], [0, [0]]),
    State =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 606, 2], [0, [0]]),
    Status =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 615, 2], [0, [0]]),
    Step_function_node =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 629, 2], [0, [0]]),
    Unordered_array_fold =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 643, 2], [0, [0]]),
    Var =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 659, 2], [0, [0, [0, [0]]]]);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Adjust_heights_heap, Adjust_heights_heap);
   caml_call3(CamlinternalMod[2], [0, [0]], Alarm, Alarm);
   caml_call3
    (CamlinternalMod[2], [0, [0, [0, [0]]]], Alarm_value, Alarm_value);
   caml_call3(CamlinternalMod[2], [0, [0]], Array_fold, Array_fold);
   caml_call3(CamlinternalMod[2], [0, [0]], At, At);
   caml_call3(CamlinternalMod[2], [0, [0]], At_intervals, At_intervals);
   caml_call3(CamlinternalMod[2], [0, [0]], Bind, Bind);
   caml_call3(CamlinternalMod[2], [0, [0]], Clock, Clock);
   caml_call3(CamlinternalMod[2], [0, [0]], Expert, Expert);
   caml_call3(CamlinternalMod[2], [0, [0]], Freeze, Freeze);
   caml_call3(CamlinternalMod[2], [0, [0]], If_then_else, If_then_else);
   caml_call3
    (CamlinternalMod[2],
     [0, [0, [0, [0]], [0, [0]]]],
     Internal_observer,
     Internal_observer);
   caml_call3(CamlinternalMod[2], [0, [0]], Join, Join);
   caml_call3(CamlinternalMod[2], [0, [0]], Kind, Kind);
   var
    _h_ = [0, cst$0],
    cst_Top = "Top",
    _a_ = [0, cst$0],
    cst_n = "n",
    _b_ = [0, [0, 0, [0, [0, 0]], 0, 0, 0]],
    _c_ = [0, [0]],
    _d_ = [0, [0]],
    _e_ = [0, [0]],
    _f_ = [0, [0]],
    _g_ = [0, [0]],
    _i_ = [0, [0, 0]],
    _j_ = [0, [0]],
    _k_ = [0, [0]],
    _l_ = [0, [0]],
    _m_ = [0, [0]],
    _n_ = [0, [0]],
    _o_ = [0, [0, [0, [0]]]],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Types = cst_Incremental_Types$0;
   function sexp_of_node(param, t){
    var
     _w_ = [0, cst_n, [0, caml_call1(Incremental_Node_id[11], t[1]), 0]],
     _x_ = caml_call2(Incremental_Import[12], 0, _w_);
    return caml_call1(Core[471], _x_);
   }
   function sexp_of_t(x_003){
    return sexp_of_node(function(param){return _a_;}, x_003);
   }
   function is_valid(t){
    var _v_ = t[5];
    if(typeof _v_ === "number" && ! _v_) return 0;
    return 1;
   }
   function is_necessary(t){
    var _q_ = caml_call2(Incremental_Import[4], t[9], 0);
    if(_q_)
     var _r_ = _q_;
    else{
     var _s_ = caml_call1(Incremental_Import[16][6], t[21]);
     if(_s_)
      var _r_ = _s_;
     else{
      var _t_ = t[5];
      a:
      {
       if(typeof _t_ !== "number" && 7 === _t_[0]){var _u_ = 1; break a;}
       var _u_ = 0;
      }
      var _r_ = _u_ || t[26];
     }
    }
    return _r_;
   }
   function type_equal_if_phys_same(t1, t2){
    return caml_call2(Core[247], t1, t2) ? [0, 0] : 0;
   }
   caml_call3
    (CamlinternalMod[2],
     _b_,
     Node,
     [0,
      sexp_of_node,
      [0, sexp_of_t],
      is_valid,
      is_necessary,
      type_equal_if_phys_same]);
   caml_call3(CamlinternalMod[2], _c_, Observer, Observer);
   caml_call3(CamlinternalMod[2], _d_, Only_in_debug, Only_in_debug);
   caml_call3
    (CamlinternalMod[2], _e_, Packed_weak_hashtbl, Packed_weak_hashtbl);
   caml_call3(CamlinternalMod[2], _f_, Recompute_heap, Recompute_heap);
   caml_call3
    (CamlinternalMod[2], _g_, Run_on_update_handlers, Run_on_update_handlers);
   function sexp_of_t$0(param){
    if(! param) return caml_call1(Core[471], cst_Top);
    var bind = param[1], x_004 = bind[1];
    function _p_(param){return _h_;}
    return caml_call2(Node[1], _p_, x_004);
   }
   caml_call3(CamlinternalMod[2], _i_, Scope, [0, sexp_of_t$0]);
   caml_call3(CamlinternalMod[2], _j_, Snapshot, Snapshot);
   caml_call3(CamlinternalMod[2], _k_, State, State);
   caml_call3(CamlinternalMod[2], _l_, Status, Status);
   caml_call3(CamlinternalMod[2], _m_, Step_function_node, Step_function_node);
   caml_call3
    (CamlinternalMod[2], _n_, Unordered_array_fold, Unordered_array_fold);
   caml_call3(CamlinternalMod[2], _o_, Var, Var);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Types);
   var
    Incremental_Types =
      [0,
       Adjust_heights_heap,
       Alarm,
       Alarm_value,
       Array_fold,
       At,
       At_intervals,
       Bind,
       Clock,
       Expert,
       Freeze,
       If_then_else,
       Internal_observer,
       Join,
       Kind,
       Node,
       Observer,
       Only_in_debug,
       Packed_weak_hashtbl,
       Recompute_heap,
       Run_on_update_handlers,
       Scope,
       Snapshot,
       State,
       Status,
       Step_function_node,
       Unordered_array_fold,
       Var];
   runtime.caml_register_global
    (100, Incremental_Types, cst_Incremental_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Var
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Stabilization_num, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Var$0 = "Incremental__Var",
    cst$0 = "_",
    cst_incremental$0 = "incremental",
    cst_set_at$0 = "set_at",
    cst_src_var_ml = "src/var.ml",
    cst_value$0 = "value",
    cst_value_set_during_stabiliza$0 = "value_set_during_stabilization",
    cst_watch$0 = "watch",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Var$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_var_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _q_ = [0, cst$0],
    _r_ = [0, "T"],
    _o_ = [0, cst$0],
    _n_ = [0, cst_src_var_ml, 32, 23],
    _m_ = [0, cst_src_var_ml, 33, 18],
    _p_ = [0, cst_src_var_ml, 22, 913, 935],
    _i_ = [0, cst_watch$0],
    _j_ = [0, cst_set_at$0],
    _k_ = [0, cst_value_set_during_stabiliza$0],
    _l_ = [0, cst_value$0],
    cst_watch = cst_watch$0,
    cst_set_at = cst_set_at$0,
    cst_value_set_during_stabiliza = cst_value_set_during_stabiliza$0,
    cst_value = cst_value$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Var = cst_Incremental_Var$0;
   function watch(r){return r[4];}
   function set_at(r){return r[3];}
   function set_set_at(r, v){r[3] = v; return 0;}
   function value_set_during_stabilization(r){return r[2];}
   function set_value_set_during_stabiliza(r, v){r[2] = v; return 0;}
   function value(r){return r[1];}
   function set_value(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _b_ = 0,
    watch$0 = [0, function(param){return 0;}, cst_watch, _b_, watch, _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _d_ = [0, set_set_at],
    set_at$0 = [0, function(param){return 0;}, cst_set_at, _d_, set_at, _c_];
   function _e_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _f_ = [0, set_value_set_during_stabiliza],
    value_set_during_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_value_set_during_stabiliza,
       _f_,
       value_set_during_stabilization,
       _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _h_ = [0, set_value],
    value$0 = [0, function(param){return 0;}, cst_value, _h_, value, _g_];
   function sexp_of_var(of_a_001, param){
    var
     value_003 = param[1],
     value_set_during_stabilization = param[2],
     set_at_007 = param[3],
     watch_009 = param[4],
     arg_010 = caml_call2(Incremental_Types[15][1], of_a_001, watch_009),
     bnds_002 = [0, [1, [0, _i_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(Incremental_Stabilization_num[2], set_at_007),
     bnds_002$0 = [0, [1, [0, _j_, [0, arg_008, 0]]], bnds_002],
     arg_006 =
       caml_call2
        (Incremental_Import[16][1], of_a_001, value_set_during_stabilization),
     bnds_002$1 = [0, [1, [0, _k_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(of_a_001, value_003),
     bnds_002$2 = [0, [1, [0, _l_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function invariant(invariant_a, t){
    function _s_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      watch_fun =
        check
         (function(watch){
           var match = watch[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(16 === match[0]){
            var t$0 = match[1];
            if(caml_call2(Core[246], t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          }),
      set_at_fun = check(Incremental_Stabilization_num[4]),
      value_set_during_stabilization =
        check(caml_call1(Incremental_Import[16][2], invariant_a)),
      value_fun = check(invariant_a);
     caml_call1(value_fun, value$0);
     caml_call1
      (value_set_during_stabilization, value_set_during_stabilization$0);
     caml_call1(set_at_fun, set_at$0);
     return caml_call1(watch_fun, watch$0);
    }
    function _t_(x_011){
     return sexp_of_var(function(param){return _o_;}, x_011);
    }
    return caml_call4(Base_Invariant[1], _p_, t, _t_, _s_);
   }
   function incr_state(t){return t[4][2];}
   function sexp_of_t(param){
    var res0_015 = sexp_of_var(function(param){return _q_;}, param);
    return [1, [0, _r_, [0, res0_015, 0]]];
   }
   function latest_value(t){
    return caml_call1(Incremental_Import[16][6], t[2])
            ? caml_call1(Incremental_Import[16][11], t[2])
            : t[1];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Var);
   var
    Incremental_Var =
      [0, invariant, sexp_of_var, [0, sexp_of_t], latest_value, incr_state];
   runtime.caml_register_global(33, Incremental_Var, cst_Incremental_Var$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Unordered_array_fold
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Unordered_arra$0 = "Incremental__Unordered_array_fold",
    cst$0 = "_",
    cst_children$0 = "children",
    cst_fold_value$0 = "fold_value",
    cst_full_compute_every_n_chang$0 = "full_compute_every_n_changes",
    cst_incremental$0 = "incremental",
    cst_init$0 = "init",
    cst_main$0 = "main",
    cst_num_changes_since_last_ful$0 = "num_changes_since_last_full_compute",
    cst_src_unordered_array_fold_m = "src/unordered_array_fold.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/unordered_array_fold.ml:57:26",
    cst = "",
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Unordered_arra$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_unordered_array_fold_m);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _J_ = [0, cst$0],
    _I_ = [0, cst$0],
    _F_ = [0, cst$0],
    _G_ = [0, "child"],
    _H_ = [0, "child_index"],
    _K_ = [0, "unordered_array_fold"],
    cst_Unordered_array_fold_child =
      "[Unordered_array_fold.child_changed] mismatch",
    _D_ = [0, cst$0],
    _C_ = [0, cst$0],
    _B_ = [0, cst_src_unordered_array_fold_m, 42, 40],
    _A_ = [0, cst_src_unordered_array_fold_m, 43, 18],
    _z_ = [0, cst_src_unordered_array_fold_m, 68, 11],
    _y_ = [0, cst_src_unordered_array_fold_m, 53, 18],
    _x_ = [0, cst_src_unordered_array_fold_m, 63, 11],
    _w_ = [0, cst_src_unordered_array_fold_m, 64, 11],
    _E_ = [0, cst_src_unordered_array_fold_m, 35, 908, 930],
    _o_ = [0, cst_num_changes_since_last_ful$0],
    _p_ = [0, cst_fold_value$0],
    _q_ = [0, cst_children$0],
    _r_ = [0, cst_full_compute_every_n_chang$0],
    _s_ = [0, "update"],
    _t_ = [0, "f"],
    _u_ = [0, cst_init$0],
    _v_ = [0, cst_main$0],
    _a_ = [0, "F_inverse"],
    _b_ = [0, "Update"],
    cst_num_changes_since_last_ful = cst_num_changes_since_last_ful$0,
    cst_fold_value = cst_fold_value$0,
    cst_children = cst_children$0,
    cst_full_compute_every_n_chang = cst_full_compute_every_n_chang$0,
    cst_init = cst_init$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Unordered_arra = cst_Incremental_Unordered_arra$0;
   function sexp_of_t(of_a_001, of_b_002, param){
    if(0 === param[0]){
     var
      _am_ = function(_ap_){return 0;},
      res0_004 = caml_call1(Sexplib0_Sexp_conv[24], _am_);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    function _an_(_ao_){return 0;}
    var res0_006 = caml_call1(Sexplib0_Sexp_conv[24], _an_);
    return [1, [0, _b_, [0, res0_006, 0]]];
   }
   function num_changes_since_last_full_co(r){return r[8];}
   function set_num_changes_since_last_ful(r, v){r[8] = v; return 0;}
   function fold_value(r){return r[7];}
   function set_fold_value(r, v){r[7] = v; return 0;}
   function children(r){return r[6];}
   function full_compute_every_n_changes(r){return r[5];}
   function init(r){return r[2];}
   function main(r){return r[1];}
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _d_ = [0, set_num_changes_since_last_ful],
    num_changes_since_last_full_co$0 =
      [0,
       function(param){return 0;},
       cst_num_changes_since_last_ful,
       _d_,
       num_changes_since_last_full_co,
       _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _f_ = [0, set_fold_value],
    fold_value$0 =
      [0, function(param){return 0;}, cst_fold_value, _f_, fold_value, _e_];
   function _g_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _h_ = 0,
    children$0 =
      [0, function(param){return 0;}, cst_children, _h_, children, _g_];
   function _i_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _j_ = 0,
    full_compute_every_n_changes$0 =
      [0,
       function(param){return 0;},
       cst_full_compute_every_n_chang,
       _j_,
       full_compute_every_n_changes,
       _i_];
   function _k_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _l_ = 0,
    init$0 = [0, function(param){return 0;}, cst_init, _l_, init, _k_];
   function _m_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _n_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _n_, main, _m_];
   function sexp_of_t$0(of_a_009, of_acc_010, param){
    var
     children_022 = param[6],
     full_compute_every_n_changes_0 = param[5],
     init_014 = param[2],
     main_012 = param[1],
     fold_value_024 = param[7],
     num_changes_since_last_full_co = param[8],
     arg_027 = caml_call1(Core[356], num_changes_since_last_full_co),
     bnds_011 = [0, [1, [0, _o_, [0, arg_027, 0]]], 0],
     arg_025 =
       caml_call2(Incremental_Import[16][1], of_acc_010, fold_value_024),
     bnds_011$0 = [0, [1, [0, _p_, [0, arg_025, 0]]], bnds_011],
     _ah_ = caml_call1(Incremental_Types[15][1], of_a_009),
     arg_023 = caml_call2(Core[288], _ah_, children_022),
     bnds_011$1 = [0, [1, [0, _q_, [0, arg_023, 0]]], bnds_011$0],
     arg_021 = caml_call1(Core[356], full_compute_every_n_changes_0),
     bnds_011$2 = [0, [1, [0, _r_, [0, arg_021, 0]]], bnds_011$1];
    function _ai_(_al_){return 0;}
    var
     arg_019 = caml_call1(Sexplib0_Sexp_conv[24], _ai_),
     bnds_011$3 = [0, [1, [0, _s_, [0, arg_019, 0]]], bnds_011$2];
    function _aj_(_ak_){return 0;}
    var
     arg_017 = caml_call1(Sexplib0_Sexp_conv[24], _aj_),
     bnds_011$4 = [0, [1, [0, _t_, [0, arg_017, 0]]], bnds_011$3],
     arg_015 = caml_call1(of_acc_010, init_014),
     bnds_011$5 = [0, [1, [0, _u_, [0, arg_015, 0]]], bnds_011$4],
     arg_013 = caml_call2(Incremental_Types[15][1], of_acc_010, main_012),
     bnds_011$6 = [0, [1, [0, _v_, [0, arg_013, 0]]], bnds_011$5];
    return [1, bnds_011$6];
   }
   function invariant(invariant_a, invariant_acc, t1){
    function _ac_(param){
     function check(f){return caml_call2(Base_Invariant[2], t1, f);}
     var
      num_changes_since_last_full_co =
        check
         (function(num_changes_since_last_full_co){
           if
            (!
             caml_call2
              (Incremental_Import[1], num_changes_since_last_full_co, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
           if
            (caml_call2
              (Incremental_Import[2], num_changes_since_last_full_co, t1[5]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          }),
      fold_value_fun =
        check
         (function(fold_value){
           caml_call2(Incremental_Import[16][2], invariant_acc, fold_value);
           var
            got = caml_call1(Incremental_Import[16][6], fold_value),
            expect = caml_call2(Incremental_Import[5], t1[8], t1[5]),
            sexpifier = Core[305],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_029, b_030){
            return caml_call2(Core[301], a_029, b_030);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          }),
      children_fun =
        check
         (function(children){
           function _af_(child){
            caml_call2(Incremental_Import[16][2], invariant_a, child[4]);
            var _ag_ = caml_call2(Incremental_Import[5], t1[8], t1[5]);
            if(! _ag_) return _ag_;
            if(caml_call1(Incremental_Import[16][6], child[4])) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
           }
           return caml_call2(Incremental_Import[15][22], children, _af_);
          }),
      full_compute_every_n_changes_f =
        check
         (function(full_compute_every_n_changes){
           if
            (caml_call2
              (Incremental_Import[4], full_compute_every_n_changes, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
          }),
      init_fun = check(invariant_acc),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(15 === match[0]){
            var t2 = match[1];
            if(caml_call2(Core[247], t1, t2)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(init_fun, init$0);
     caml_call1
      (full_compute_every_n_changes_f, full_compute_every_n_changes$0);
     caml_call1(children_fun, children$0);
     caml_call1(fold_value_fun, fold_value$0);
     return caml_call1
             (num_changes_since_last_full_co,
              num_changes_since_last_full_co$0);
    }
    function _ad_(x_028){
     function _ae_(param){return _C_;}
     return sexp_of_t$0(function(param){return _D_;}, _ae_, x_028);
    }
    return caml_call4(Base_Invariant[1], _E_, t1, _ad_, _ac_);
   }
   function create
   (init, f, update$0, full_compute_every_n_changes, children, main){
    var _aa_ = Incremental_Import[16][3];
    if(0 === update$0[0])
     var
      f_inverse = update$0[1],
      _ab_ =
        function(fold_value, old_value, new_value){
         return caml_call2
                 (f, caml_call2(f_inverse, fold_value, old_value), new_value);
        };
    else
     var update = update$0[1], _ab_ = update;
    return [0,
            main,
            init,
            f,
            _ab_,
            full_compute_every_n_changes,
            children,
            _aa_,
            full_compute_every_n_changes];
   }
   function compute(t){
    if(caml_call2(Incremental_Import[3], t[8], t[5])){
     t[8] = 0;
     var
      children = t[6],
      f = t[3],
      init = t[2],
      result = [0, init],
      _Z_ = children.length - 1 - 1 | 0,
      _Y_ = 0;
     if(_Z_ >= 0){
      var i = _Y_;
      for(;;){
       var ___ = caml_call1(Incremental_Import[16][7], children[1 + i][4]);
       result[1] = caml_call2(f, result[1], ___);
       var _$_ = i + 1 | 0;
       if(_Z_ === i) break;
       var i = _$_;
      }
     }
     t[7] = caml_call1(Incremental_Import[16][4], result[1]);
    }
    return caml_call1(Incremental_Import[16][7], t[7]);
   }
   function force_full_compute(t){
    t[7] = Incremental_Import[16][3];
    t[8] = t[5];
    return 0;
   }
   function child_changed(x_031, child, child_index, old_value_opt, new_value){
    var
     child_at_index =
       runtime.caml_check_bound(x_031[6], child_index)[1 + child_index];
    if(! caml_call2(Incremental_Types[15][5], child, child_at_index)){
     var
      _P_ = 0,
      _Q_ = 0,
      _R_ = function(param){return _F_;},
      _S_ =
        [0,
         [1,
          [0, _G_, [0, caml_call2(Incremental_Types[15][1], _R_, child), _Q_]]],
         _P_],
      _T_ =
        [0, [1, [0, _H_, [0, caml_call1(Core[356], child_index), 0]]], _S_],
      _U_ = 0,
      _V_ = function(param){return _I_;},
      _W_ =
        [0,
         [1,
          [0,
           _K_,
           [0, sexp_of_t$0(function(param){return _J_;}, _V_, x_031), _U_]]],
         _T_],
      _X_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Unordered_array_fold_child),
          _W_]];
     return caml_call1(Core[253], _X_);
    }
    if(caml_call2(Incremental_Import[5], x_031[8], x_031[5] - 1 | 0)){
     x_031[8] = x_031[8] + 1 | 0;
     var
      _L_ = caml_call1(Incremental_Import[16][7], old_value_opt),
      _M_ = caml_call1(Incremental_Import[16][7], x_031[7]),
      _N_ = caml_call3(x_031[4], _M_, _L_, new_value);
     x_031[7] = caml_call1(Incremental_Import[16][4], _N_);
     return 0;
    }
    var _O_ = caml_call2(Incremental_Import[5], x_031[8], x_031[5]);
    return _O_ ? force_full_compute(x_031) : _O_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Unordered_arra);
   var
    Incremental_Unordered_array_fo =
      [0,
       invariant,
       sexp_of_t$0,
       [0, sexp_of_t],
       create,
       compute,
       child_changed,
       force_full_compute];
   runtime.caml_register_global
    (55, Incremental_Unordered_array_fo, cst_Incremental_Unordered_arra$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Alarm
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Alarm$0 = "Incremental__Alarm",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Alarm$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/alarm.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Alarm = cst_Incremental_Alarm$0;
   function sexp_of_t(x_001){
    return caml_call2(Timing_wheel[5][1], Sexplib0_Sexp_conv[23], x_001);
   }
   function invariant(param){return 0;}
   var null$0 = caml_call1(Timing_wheel[5][2], 0);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Alarm);
   var Incremental_Alarm = [0, sexp_of_t, invariant, null$0];
   runtime.caml_register_global
    (13, Incremental_Alarm, cst_Incremental_Alarm$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Step_function_node
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Core__Sequence, Expect_test_collector, Incremental__Alarm, Incremental__Import, Incremental__Stabilization_num, Incremental__Types, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Step_function_$0 = "Incremental__Step_function_node",
    cst_alarm$0 = "alarm",
    cst_alarm_value$0 = "alarm_value",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_step_function_node_ml = "src/step_function_node.ml",
    cst_value$0 = "value",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sequence = global_data.Core__Sequence,
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_step_function = global_data.Incremental_step_function,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Step_function_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_step_function_node_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _u_ = [0, "_"],
    _t_ = [0, cst_src_step_function_node_ml, 30, 33],
    _s_ = [0, cst_src_step_function_node_ml, 31, 18],
    _q_ = [0, cst_src_step_function_node_ml, 41, 18],
    _r_ = [0, cst_src_step_function_node_ml, 40, 33],
    _v_ = [0, cst_src_step_function_node_ml, 22, 626, 648],
    _i_ = [0, "clock"],
    _j_ = [0, cst_alarm_value$0],
    _k_ = [0, cst_alarm$0],
    _l_ = [0, "upcoming_steps"],
    _m_ = [0, cst_value$0],
    _n_ = [0, "extracted_step_function_from_child_at"],
    _o_ = [0, "child"],
    _p_ = [0, cst_main$0],
    cst_alarm_value = cst_alarm_value$0,
    cst_alarm = cst_alarm$0,
    cst_value = cst_value$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Step_function_ = cst_Incremental_Step_function_$0;
   function alarm_value(r){return r[7];}
   function set_alarm_value(r, v){r[7] = v; return 0;}
   function alarm(r){return r[6];}
   function set_alarm(r, v){r[6] = v; return 0;}
   function value(r){return r[4];}
   function set_value(r, v){r[4] = v; return 0;}
   function main(r){return r[1];}
   function _a_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _b_ = [0, set_alarm_value],
    alarm_value$0 =
      [0, function(param){return 0;}, cst_alarm_value, _b_, alarm_value, _a_];
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _d_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _d_, alarm, _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _f_ = [0, set_value],
    value$0 = [0, function(param){return 0;}, cst_value, _f_, value, _e_];
   function _g_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _h_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _h_, main, _g_];
   function sexp_of_t(of_a_001, param){
    var
     main_003 = param[1],
     child_005 = param[2],
     extracted_step_function_from_c = param[3],
     value_009 = param[4],
     upcoming_steps_011 = param[5],
     alarm_017 = param[6],
     alarm_value_019 = param[7],
     clock_021 = param[8],
     arg_022 = caml_call1(Sexplib0_Sexp_conv[23], clock_021),
     bnds_002 = [0, [1, [0, _i_, [0, arg_022, 0]]], 0],
     arg_020 = caml_call1(Sexplib0_Sexp_conv[23], alarm_value_019),
     bnds_002$0 = [0, [1, [0, _j_, [0, arg_020, 0]]], bnds_002],
     arg_018 = caml_call1(Incremental_Alarm[1], alarm_017),
     bnds_002$1 = [0, [1, [0, _k_, [0, arg_018, 0]]], bnds_002$0];
    function _z_(param){
     var
      arg1_014 = param[2],
      arg0_013 = param[1],
      res0_015 = caml_call1(Incremental_Import[14][119], arg0_013),
      res1_016 = caml_call1(of_a_001, arg1_014);
     return [1, [0, res0_015, [0, res1_016, 0]]];
    }
    var
     arg_012 = caml_call2(Core_Sequence[11], _z_, upcoming_steps_011),
     bnds_002$2 = [0, [1, [0, _l_, [0, arg_012, 0]]], bnds_002$1],
     arg_010 = caml_call2(Incremental_Import[16][1], of_a_001, value_009),
     bnds_002$3 = [0, [1, [0, _m_, [0, arg_010, 0]]], bnds_002$2],
     arg_008 =
       caml_call1
        (Incremental_Stabilization_num[2], extracted_step_function_from_c),
     bnds_002$4 = [0, [1, [0, _n_, [0, arg_008, 0]]], bnds_002$3],
     _A_ = caml_call1(Incremental_step_function[1], of_a_001),
     _B_ = caml_call1(Incremental_Types[15][1], _A_),
     arg_006 = caml_call2(Incremental_Import[16][1], _B_, child_005),
     bnds_002$5 = [0, [1, [0, _o_, [0, arg_006, 0]]], bnds_002$4],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$6 = [0, [1, [0, _p_, [0, arg_004, 0]]], bnds_002$5];
    return [1, bnds_002$6];
   }
   function invariant(invariant_a, t1){
    function _x_(param){
     function check(f){return caml_call2(Base_Invariant[2], t1, f);}
     var
      alarm_value_fun =
        check
         (function(alarm_value){
           var match = alarm_value[1];
           if(3 !== match[0])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
           var t2 = match[1];
           if(caml_call2(Core[247], t1, t2)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
          }),
      alarm_fun = check(Incremental_Alarm[2]),
      value_fun = check(caml_call1(Incremental_Import[16][2], invariant_a)),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 5:
               return 0;
              case 14:
               var t = match[1];
               if(caml_call2(Core[246], t1, t)) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(value_fun, value$0);
     caml_call1(alarm_fun, alarm$0);
     caml_call1(alarm_value_fun, alarm_value$0);
     return 0;
    }
    function _y_(x_023){
     return sexp_of_t(function(param){return _u_;}, x_023);
    }
    return caml_call4(Base_Invariant[1], _v_, t1, _y_, _x_);
   }
   function advance(t, to){
    var
     steps$0 = t[5],
     a1$0 = caml_call1(Incremental_Import[16][7], t[4]),
     a1 = a1$0,
     steps = steps$0;
    for(;;){
     var match = caml_call1(Core_Sequence[47], steps);
     if(match){
      var
       _w_ = match[1],
       steps2 = _w_[2],
       match$0 = _w_[1],
       a2 = match$0[2],
       step_at = match$0[1];
      if(caml_call2(Incremental_Import[14][15], to, step_at)){var a1 = a2, steps = steps2; continue;}
     }
     t[4] = caml_call1(Incremental_Import[16][4], a1);
     t[5] = steps;
     return 0;
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Step_function_);
   var Incremental_Step_function_node = [0, invariant, sexp_of_t, advance];
   runtime.caml_register_global
    (45, Incremental_Step_function_node, cst_Incremental_Step_function_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Array_fold
//# unitInfo: Requires: Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Array_fold$0 = "Incremental__Array_fold",
    cst$0 = "_",
    cst_children$0 = "children",
    cst_incremental$0 = "incremental",
    cst_init$0 = "init",
    cst_src_array_fold_ml = "src/array_fold.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Array_fold$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_array_fold_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _i_ = [0, cst$0],
    _h_ = [0, cst$0],
    _j_ = [0, cst_src_array_fold_ml, 13, 253, 275],
    _e_ = [0, cst_children$0],
    _f_ = [0, "f"],
    _g_ = [0, cst_init$0],
    cst_children = cst_children$0,
    cst_init = cst_init$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Array_fold = cst_Incremental_Array_fold$0;
   function children(r){return r[3];}
   function init(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = 0,
    children$0 =
      [0, function(param){return 0;}, cst_children, _b_, children, _a_];
   function _c_(r, v){return [0, v, r[2], r[3]];}
   var
    _d_ = 0,
    init$0 = [0, function(param){return 0;}, cst_init, _d_, init, _c_];
   function sexp_of_t(of_a_001, of_acc_002, param){
    var
     children_008 = param[3],
     init_004 = param[1],
     _s_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_009 = caml_call2(Core[288], _s_, children_008),
     bnds_003 = [0, [1, [0, _e_, [0, arg_009, 0]]], 0];
    function _t_(_u_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _t_),
     bnds_003$0 = [0, [1, [0, _f_, [0, arg_007, 0]]], bnds_003],
     arg_005 = caml_call1(of_acc_002, init_004),
     bnds_003$1 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_003$0];
    return [1, bnds_003$1];
   }
   function invariant(invariant_a, invariant_acc, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      children_fun =
        check
         (function(children){
           function _r_(child){
            return caml_call2
                    (Incremental_Import[16][2], invariant_a, child[4]);
           }
           return caml_call2(Incremental_Import[15][22], children, _r_);
          }),
      init_fun = check(invariant_acc);
     caml_call1(init_fun, init$0);
     return caml_call1(children_fun, children$0);
    }
    function _p_(x_010){
     function _q_(param){return _h_;}
     return sexp_of_t(function(param){return _i_;}, _q_, x_010);
    }
    return caml_call4(Base_Invariant[1], _j_, t, _p_, _o_);
   }
   function compute(param){
    var
     children = param[3],
     f = param[2],
     init = param[1],
     result = [0, init],
     _l_ = children.length - 1 - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var _m_ = caml_call1(Incremental_Import[16][7], children[1 + i][4]);
      result[1] = caml_call2(f, result[1], _m_);
      var _n_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _n_;
     }
    }
    return result[1];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Array_fold);
   var Incremental_Array_fold = [0, sexp_of_t, invariant, compute];
   runtime.caml_register_global
    (27, Incremental_Array_fold, cst_Incremental_Array_fold$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__At
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Alarm, Incremental__Before_or_after, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_At$0 = "Incremental__At",
    cst_alarm$0 = "alarm",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_at_ml = "src/at.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Before_or_after = global_data.Incremental__Before_or_after,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_At$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_at_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _j_ = [0, cst_src_at_ml, 23, 22],
    _i_ = [0, cst_src_at_ml, 24, 18],
    _k_ = [0, cst_src_at_ml, 15, 264, 286],
    _e_ = [0, "clock"],
    _f_ = [0, cst_alarm$0],
    _g_ = [0, "at"],
    _h_ = [0, cst_main$0],
    cst_alarm = cst_alarm$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_At = cst_Incremental_At$0;
   function alarm(r){return r[3];}
   function set_alarm(r, v){r[3] = v; return 0;}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _b_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _b_, alarm, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(param){
    var
     at_004 = param[2],
     main_002 = param[1],
     alarm_006 = param[3],
     clock_008 = param[4],
     arg_009 = caml_call1(Sexplib0_Sexp_conv[23], clock_008),
     bnds_001 = [0, [1, [0, _e_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Incremental_Alarm[1], alarm_006),
     bnds_001$0 = [0, [1, [0, _f_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Incremental_Import[14][119], at_004),
     bnds_001$1 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 =
       caml_call2
        (Incremental_Types[15][1], Incremental_Before_or_after[1], main_002),
     bnds_001$2 = [0, [1, [0, _h_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(t){
    function _l_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      alarm_fun = check(Incremental_Alarm[2]),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 1:
               var t$0 = match[1];
               if(caml_call2(Core[246], t, t$0)) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
              case 5:
               if(match[1]) return 0; break;
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(alarm_fun, alarm$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _k_, t, sexp_of_t, _l_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_At);
   var Incremental_At = [0, invariant, sexp_of_t];
   runtime.caml_register_global(32, Incremental_At, cst_Incremental_At$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__At_intervals
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Alarm, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_At_intervals$0 = "Incremental__At_intervals",
    cst_alarm$0 = "alarm",
    cst_incremental$0 = "incremental",
    cst_interval$0 = "interval",
    cst_main$0 = "main",
    cst_src_at_intervals_ml = "src/at_intervals.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_At_intervals$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_at_intervals_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _n_ = [0, cst_src_at_intervals_ml, 23, 32],
    _m_ = [0, cst_src_at_intervals_ml, 24, 18],
    _l_ = [0, cst_src_at_intervals_ml, 26, 40],
    _o_ = [0, cst_src_at_intervals_ml, 16, 293, 315],
    _g_ = [0, "clock"],
    _h_ = [0, cst_alarm$0],
    _i_ = [0, cst_interval$0],
    _j_ = [0, "base"],
    _k_ = [0, cst_main$0],
    cst_alarm = cst_alarm$0,
    cst_interval = cst_interval$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_At_intervals = cst_Incremental_At_intervals$0;
   function alarm(r){return r[4];}
   function set_alarm(r, v){r[4] = v; return 0;}
   function interval(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], v, r[5]];}
   var
    _b_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _b_, alarm, _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _d_ = 0,
    interval$0 =
      [0, function(param){return 0;}, cst_interval, _d_, interval, _c_];
   function _e_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _f_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _f_, main, _e_];
   function sexp_of_t(param){
    var
     interval_006 = param[3],
     base_004 = param[2],
     main_002 = param[1],
     alarm_008 = param[4],
     clock_010 = param[5],
     arg_011 = caml_call1(Sexplib0_Sexp_conv[23], clock_010),
     bnds_001 = [0, [1, [0, _g_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Incremental_Alarm[1], alarm_008),
     bnds_001$0 = [0, [1, [0, _h_, [0, arg_009, 0]]], bnds_001],
     arg_007 = caml_call1(Incremental_Import[14][1][10], interval_006),
     bnds_001$1 = [0, [1, [0, _i_, [0, arg_007, 0]]], bnds_001$0],
     arg_005 = caml_call1(Incremental_Import[14][119], base_004),
     bnds_001$2 = [0, [1, [0, _j_, [0, arg_005, 0]]], bnds_001$1],
     arg_003 = caml_call2(Incremental_Types[15][1], Core[518], main_002),
     bnds_001$3 = [0, [1, [0, _k_, [0, arg_003, 0]]], bnds_001$2];
    return [1, bnds_001$3];
   }
   function invariant(t){
    function _p_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      alarm_fun = check(Incremental_Alarm[2]),
      interval_fun =
        check
         (function(interval){
           if(caml_call1(Incremental_Import[14][1][34], interval)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(2 === match[0]){
            var t$0 = match[1];
            if(caml_call2(Core[246], t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(interval_fun, interval$0);
     caml_call1(alarm_fun, alarm$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t, _p_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_At_intervals);
   var Incremental_At_intervals = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (34, Incremental_At_intervals, cst_Incremental_At_intervals$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Bind
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Bind$0 = "Incremental__Bind",
    cst$0 = "_",
    cst_all_nodes_created_on_rhs$0 = "all_nodes_created_on_rhs",
    cst_incremental$0 = "incremental",
    cst_lhs_change$0 = "lhs_change",
    cst_main$0 = "main",
    cst_rhs_scope$0 = "rhs_scope",
    cst_src_bind_ml = "src/bind.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Bind$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_bind_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _z_ = [0, cst$0],
    _y_ = [0, cst$0],
    _x_ = [0, cst_src_bind_ml, 52, 29],
    _w_ = [0, cst_src_bind_ml, 53, 18],
    _v_ = [0, cst_src_bind_ml, 58, 11],
    _u_ = [0, cst_src_bind_ml, 61, 35],
    _t_ = [0, cst_src_bind_ml, 62, 18],
    _r_ = [0, cst_src_bind_ml, 67, 24],
    _s_ = [0, cst_src_bind_ml, 66, 26],
    _q_ = [0, cst_src_bind_ml, 71, 13],
    _p_ = [0, cst_src_bind_ml, 73, 18],
    _A_ = [0, cst_src_bind_ml, 45, 1438, 1460],
    _i_ = [0, cst_all_nodes_created_on_rhs$0],
    _j_ = [0, cst_rhs_scope$0],
    _k_ = [0, "rhs"],
    _l_ = [0, cst_lhs_change$0],
    _m_ = [0, "lhs"],
    _n_ = [0, "f"],
    _o_ = [0, cst_main$0],
    cst_all_nodes_created_on_rhs = cst_all_nodes_created_on_rhs$0,
    cst_rhs_scope = cst_rhs_scope$0,
    cst_lhs_change = cst_lhs_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Bind = cst_Incremental_Bind$0;
   function all_nodes_created_on_rhs(r){return r[7];}
   function set_all_nodes_created_on_rhs(r, v){r[7] = v; return 0;}
   function rhs_scope(r){return r[6];}
   function set_rhs_scope(r, v){r[6] = v; return 0;}
   function lhs_change(r){return r[4];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _b_ = [0, set_all_nodes_created_on_rhs],
    all_nodes_created_on_rhs$0 =
      [0,
       function(param){return 0;},
       cst_all_nodes_created_on_rhs,
       _b_,
       all_nodes_created_on_rhs,
       _a_];
   function _c_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _d_ = [0, set_rhs_scope],
    rhs_scope$0 =
      [0, function(param){return 0;}, cst_rhs_scope, _d_, rhs_scope, _c_];
   function _e_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _f_ = 0,
    lhs_change$0 =
      [0, function(param){return 0;}, cst_lhs_change, _f_, lhs_change, _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _h_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _h_, main, _g_];
   function sexp_of_t(of_a_001, of_b_002, param){
    var
     main_004 = param[1],
     lhs_change_010 = param[4],
     lhs_008 = param[3],
     rhs_012 = param[5],
     rhs_scope_014 = param[6],
     all_nodes_created_on_rhs_016 = param[7],
     arg_017 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Types[15][2][1],
         all_nodes_created_on_rhs_016),
     bnds_003 = [0, [1, [0, _i_, [0, arg_017, 0]]], 0],
     arg_015 = caml_call1(Incremental_Types[21][1], rhs_scope_014),
     bnds_003$0 = [0, [1, [0, _j_, [0, arg_015, 0]]], bnds_003],
     _G_ = caml_call1(Incremental_Types[15][1], of_b_002),
     arg_013 = caml_call2(Incremental_Import[16][1], _G_, rhs_012),
     bnds_003$1 = [0, [1, [0, _k_, [0, arg_013, 0]]], bnds_003$0],
     arg_011 = caml_call2(Incremental_Types[15][1], Core[518], lhs_change_010),
     bnds_003$2 = [0, [1, [0, _l_, [0, arg_011, 0]]], bnds_003$1],
     arg_009 = caml_call2(Incremental_Types[15][1], of_a_001, lhs_008),
     bnds_003$3 = [0, [1, [0, _m_, [0, arg_009, 0]]], bnds_003$2];
    function _H_(_I_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _H_),
     bnds_003$4 = [0, [1, [0, _n_, [0, arg_007, 0]]], bnds_003$3],
     arg_005 = caml_call2(Incremental_Types[15][1], of_b_002, main_004),
     bnds_003$5 = [0, [1, [0, _o_, [0, arg_005, 0]]], bnds_003$4];
    return [1, bnds_003$5];
   }
   function same(t1, t2){return caml_call2(Core[247], t1, t2);}
   function is_valid(t){
    var _F_ = t[1][5];
    if(typeof _F_ === "number" && ! _F_) return 0;
    return 1;
   }
   function iter_nodes_created_on_rhs(t, f){
    var r = [0, t[7]];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r[1])) return 0;
     var match = caml_call1(Incremental_Import[16][11], r[1]);
     r[1] = match[13];
     caml_call1(f, match);
    }
   }
   function invariant(invariant_a, invariant_b, t){
    function _B_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      all_nodes_created_on_rhs_fun =
        check
         (function(param){
           return iter_nodes_created_on_rhs
                   (t,
                    function(node){
                     if(! caml_call2(Core[246], node[12], t[6]))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _q_], 1);
                     var _E_ = caml_call1(Incremental_Types[15][4], node);
                     if(! _E_) return _E_;
                     if(caml_call2(Incremental_Import[5], t[4][14], node[14]))
                      return 0;
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _p_], 1);
                    });
          }),
      rhs_scope_fun =
        check
         (function(param){
           if(! param)
            throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
           var t$0 = param[1];
           if(same(t, t$0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
          }),
      lhs_change_fun =
        check
         (function(lhs_change){
           if(! caml_call2(Core[246], lhs_change[12], t[1][12]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
           var match = lhs_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(3 === match[0]){
            var t$0 = match[1];
            if(same(t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(4 === match[0]){
            var t$0 = match[1];
            if(same(t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(lhs_change_fun, lhs_change$0);
     caml_call1(rhs_scope_fun, rhs_scope$0);
     return caml_call1
             (all_nodes_created_on_rhs_fun, all_nodes_created_on_rhs$0);
    }
    function _C_(x_018){
     function _D_(param){return _y_;}
     return sexp_of_t(function(param){return _z_;}, _D_, x_018);
    }
    return caml_call4(Base_Invariant[1], _A_, t, _C_, _B_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Bind);
   var
    Incremental_Bind =
      [0, invariant, sexp_of_t, is_valid, iter_nodes_created_on_rhs];
   runtime.caml_register_global(45, Incremental_Bind, cst_Incremental_Bind$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Expert
//# unitInfo: Requires: Assert_failure, Core, Core__Int, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Expert$0 = "Incremental__Expert",
    cst_incremental$0 = "incremental",
    cst_src_expert_ml = "src/expert.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$0 = "src/expert.ml:76:19",
    pos$1 = "src/expert.ml:69:22",
    pos = "src/expert.ml:60:21",
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Incremental_Types = global_data.Incremental__Types,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Expert$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_expert_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _q_ = [0, cst_src_expert_ml, 142, 2],
    _p_ = [0, cst_src_expert_ml, 111, 2],
    _o_ = [0, cst_src_expert_ml, 104, 18],
    _m_ = [0, cst_src_expert_ml, 61, 15],
    _n_ = [0, cst_src_expert_ml, 53, 2],
    _f_ = [0, "will_fire_all_callbacks"],
    _g_ = [0, "num_invalid_children"],
    _h_ = [0, "force_stale"],
    _i_ = [0, "num_children"],
    _j_ = [0, "children"],
    _k_ = [0, "on_observability_change"],
    _l_ = [0, "f"],
    _d_ = [0, "_"],
    _e_ = [0, "E"],
    _a_ = [0, "index"],
    _b_ = [0, "on_change"],
    _c_ = [0, "child"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Expert = cst_Incremental_Expert$0;
   function sexp_of_edge(of_a_001, param){
    var
     child_003 = param[1],
     index_007 = param[3],
     arg_008 = caml_call2(Incremental_Import[16][1], Core[356], index_007),
     bnds_002 = [0, [1, [0, _a_, [0, arg_008, 0]]], 0];
    function _W_(_X_){return 0;}
    var
     arg_006 = caml_call1(Sexplib0_Sexp_conv[24], _W_),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_006, 0]]], bnds_002],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, child_003),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_004, 0]]], bnds_002$0];
    return [1, bnds_002$1];
   }
   function sexp_of_packed_edge(param){
    var res0_010 = sexp_of_edge(function(param){return _d_;}, param);
    return [1, [0, _e_, [0, res0_010, 0]]];
   }
   function sexp_of_t(of_a_011, param){
    var
     children_017 = param[3],
     num_children_019 = param[4],
     force_stale_021 = param[5],
     num_invalid_children_023 = param[6],
     will_fire_all_callbacks_025 = param[7],
     arg_026 = caml_call1(Core[305], will_fire_all_callbacks_025),
     bnds_012 = [0, [1, [0, _f_, [0, arg_026, 0]]], 0],
     arg_024 = caml_call1(Core[356], num_invalid_children_023),
     bnds_012$0 = [0, [1, [0, _g_, [0, arg_024, 0]]], bnds_012],
     arg_022 = caml_call1(Core[305], force_stale_021),
     bnds_012$1 = [0, [1, [0, _h_, [0, arg_022, 0]]], bnds_012$0],
     arg_020 = caml_call1(Core[356], num_children_019),
     bnds_012$2 = [0, [1, [0, _i_, [0, arg_020, 0]]], bnds_012$1],
     _R_ = caml_call1(Incremental_Import[16][1], sexp_of_packed_edge),
     arg_018 = caml_call2(Incremental_Import[17][10], _R_, children_017),
     bnds_012$3 = [0, [1, [0, _j_, [0, arg_018, 0]]], bnds_012$2];
    function _S_(_V_){return 0;}
    var
     arg_016 = caml_call1(Sexplib0_Sexp_conv[24], _S_),
     bnds_012$4 = [0, [1, [0, _k_, [0, arg_016, 0]]], bnds_012$3];
    function _T_(_U_){return 0;}
    var
     arg_014 = caml_call1(Sexplib0_Sexp_conv[24], _T_),
     bnds_012$5 = [0, [1, [0, _l_, [0, arg_014, 0]]], bnds_012$4];
    return [1, bnds_012$5];
   }
   function invariant(invariant_a, param){
    var
     children = param[3],
     num_children = param[4],
     _O_ = caml_call1(Incremental_Import[17][18], children);
    if(! caml_call2(Incremental_Import[2], num_children, _O_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    function _P_(expect, uopt){
     if(caml_call2(Incremental_Import[5], expect, num_children)){
      var
       _Q_ = caml_call1(Incremental_Import[16][7], uopt)[3],
       got = caml_call1(Incremental_Import[16][7], _Q_),
       sexpifier = Core[356],
       equal = 0,
       message = 0,
       here = 0,
       comparator =
         function(a_027, b_028){return caml_call2(Core[352], a_027, b_028);};
      return caml_call8
              (Ppx_assert_lib_Runtime[3],
               pos,
               sexpifier,
               comparator,
               here,
               message,
               equal,
               expect,
               got);
     }
     if(caml_call1(Incremental_Import[16][5], uopt)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    }
    return caml_call2(Incremental_Import[17][28], children, _P_);
   }
   function invariant_about_num_invalid_ch(param){
    var
     children = param[3],
     num_children = param[4],
     num_invalid_children = param[6];
    return function(is_necessary){
     if(! is_necessary){
      var
       sexpifier$0 = Core[356],
       expect$0 = 0,
       equal$0 = 0,
       message$0 = 0,
       here$0 = 0,
       comparator$0 =
         function(a_029, b_030){return caml_call2(Core[352], a_029, b_030);};
      return caml_call8
              (Ppx_assert_lib_Runtime[3],
               pos$1,
               sexpifier$0,
               comparator$0,
               here$0,
               message$0,
               equal$0,
               expect$0,
               num_invalid_children);
     }
     var count_invalid_children = [0, 0], _L_ = num_children - 1 | 0, _K_ = 0;
     if(_L_ >= 0){
      var i = _K_;
      for(;;){
       var
        _M_ = caml_call2(Incremental_Import[17][19], children, i),
        r = caml_call1(Incremental_Import[16][7], _M_);
       if(1 - caml_call1(Incremental_Types[15][3], r[1]))
        count_invalid_children[1]++;
       var _N_ = i + 1 | 0;
       if(_L_ === i) break;
       var i = _N_;
      }
     }
     var
      expect = count_invalid_children[1],
      sexpifier = Core[356],
      equal = 0,
      message = 0,
      here = 0;
     function comparator(a_031, b_032){
      return caml_call2(Core[352], a_031, b_032);
     }
     return caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$0,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              num_invalid_children);};
   }
   function create(f, on_observability_change){
    return [0,
            f,
            on_observability_change,
            Incremental_Import[17][14],
            0,
            0,
            0,
            1];
   }
   function make_stale(t){return t[5] ? 534011858 : (t[5] = 1, 17724);}
   function incr_invalid_children(t){t[6] = t[6] + 1 | 0; return 0;}
   function decr_invalid_children(t){t[6] = t[6] - 1 | 0; return 0;}
   function add_child_edge(t, packed_edge){
    if(! caml_call1(Incremental_Import[16][5], packed_edge[3]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _G_ = caml_call1(Incremental_Import[17][18], t[3]);
    if(caml_call2(Incremental_Import[1], t[4], _G_)){
     if(Incremental_Import[11]){
      var _H_ = caml_call1(Incremental_Import[17][18], t[3]);
      if(! caml_call2(Incremental_Import[3], t[4], _H_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
     }
     var
      _I_ = 2 * caml_call1(Incremental_Import[17][18], t[3]) | 0,
      new_max = caml_call2(Core_Int[93], 2, _I_);
     t[3] = caml_call2(Incremental_Import[17][53], t[3], new_max);
    }
    var new_child_index = t[4];
    packed_edge[3] = caml_call1(Incremental_Import[16][4], new_child_index);
    var _J_ = caml_call1(Incremental_Import[16][4], packed_edge);
    caml_call3(Incremental_Import[17][52], t[3], new_child_index, _J_);
    t[4] = t[4] + 1 | 0;
    t[5] = 1;
    return new_child_index;
   }
   function swap_children(t, child_index1, child_index2){
    var
     _E_ = caml_call2(Incremental_Import[17][19], t[3], child_index1),
     edge1 = caml_call1(Incremental_Import[16][7], _E_),
     _F_ = caml_call2(Incremental_Import[17][19], t[3], child_index2),
     match = caml_call1(Incremental_Import[16][7], _F_);
    edge1[3] = caml_call1(Incremental_Import[16][4], child_index2);
    match[3] = caml_call1(Incremental_Import[16][4], child_index1);
    return caml_call3
            (Incremental_Import[17][21], t[3], child_index1, child_index2);
   }
   function last_child_edge_exn(t){
    var
     last_index = t[4] - 1 | 0,
     _D_ = caml_call2(Incremental_Import[17][19], t[3], last_index);
    return caml_call1(Incremental_Import[16][7], _D_);
   }
   function remove_last_child_edge_exn(t){
    var
     last_index = t[4] - 1 | 0,
     packed_edge_opt =
       caml_call2(Incremental_Import[17][19], t[3], last_index);
    caml_call3
     (Incremental_Import[17][52], t[3], last_index, Incremental_Import[16][3]);
    t[4] = last_index;
    t[5] = 1;
    if(! caml_call1(Incremental_Import[16][6], packed_edge_opt))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
    var match = caml_call1(Incremental_Import[16][11], packed_edge_opt);
    match[3] = Incremental_Import[16][3];
    return 0;
   }
   function before_main_computation(t){
    if(caml_call2(Incremental_Import[4], t[6], 0)) return 144245463;
    t[5] = 0;
    var will_fire_all_callbacks = t[7];
    t[7] = 0;
    if(will_fire_all_callbacks){
     var _z_ = t[4] - 1 | 0, _y_ = 0;
     if(_z_ >= 0){
      var i = _y_;
      for(;;){
       var
        _A_ = caml_call2(Incremental_Import[17][19], t[3], i),
        match = caml_call1(Incremental_Import[16][7], _A_),
        _B_ = caml_call1(Incremental_Import[16][7], match[1][4]);
       caml_call1(match[2], _B_);
       var _C_ = i + 1 | 0;
       if(_z_ === i) break;
       var i = _C_;
      }
     }
    }
    return 17724;
   }
   function observability_change(t, is_now_observable){
    caml_call1(t[2], is_now_observable);
    var
     _w_ = 1 - is_now_observable,
     _x_ = _w_ ? (t[7] = 1, t[6] = 0, 0) : _w_;
    return _x_;
   }
   function run_edge_callback(t, child_index){
    var _r_ = 1 - t[7];
    if(_r_){
     var
      _s_ = caml_call2(Incremental_Import[17][19], t[3], child_index),
      r = caml_call1(Incremental_Import[16][7], _s_),
      _t_ = caml_call1(Incremental_Import[16][6], r[1][4]);
     if(_t_){
      var _u_ = caml_call1(Incremental_Import[16][11], r[1][4]);
      return caml_call1(r[2], _u_);
     }
     var _v_ = _t_;
    }
    else
     var _v_ = _r_;
    return _v_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Expert);
   var
    Incremental_Expert =
      [0,
       invariant,
       sexp_of_t,
       sexp_of_edge,
       invariant_about_num_invalid_ch,
       create,
       make_stale,
       incr_invalid_children,
       decr_invalid_children,
       add_child_edge,
       swap_children,
       last_child_edge_exn,
       remove_last_child_edge_exn,
       before_main_computation,
       observability_change,
       run_edge_callback];
   runtime.caml_register_global
    (38, Incremental_Expert, cst_Incremental_Expert$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Sexp_of
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Sexp_of = "Incremental__Sexp_of",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Sexp_of);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Expect_test_collector[5][1], "src/sexp_of.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Sexp_of);
   var Incremental_Sexp_of = [0];
   runtime.caml_register_global
    (11, Incremental_Sexp_of, cst_Incremental_Sexp_of);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Scope
//# unitInfo: Requires: Assert_failure, Core, Expect_test_collector, Incremental__Bind, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Scope$0 = "Incremental__Scope",
    cst_incremental$0 = "incremental",
    cst_src_scope_ml = "src/scope.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Bind = global_data.Incremental__Bind,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Scope$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_scope_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    include = Incremental_Types[21],
    sexp_of_t = include[1],
    _a_ = [0, cst_src_scope_ml, 37, 2],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Scope = cst_Incremental_Scope$0,
    top = 0;
   function is_top(param){return param ? 0 : 1;}
   function invariant(param){
    if(! param) return 0;
    var bind = param[1];
    function _b_(_e_){return 0;}
    function _c_(_d_){return 0;}
    return caml_call3(Incremental_Bind[1], _c_, _b_, bind);
   }
   function height(param){
    if(! param) return -1;
    var bind = param[1];
    return bind[4][14];
   }
   function is_valid(param){
    if(! param) return 1;
    var bind = param[1];
    return caml_call1(Incremental_Bind[3], bind);
   }
   function is_necessary(param){
    if(! param) return 1;
    var bind = param[1];
    return caml_call1(Incremental_Types[15][4], bind[1]);
   }
   function add_node(t, node){
    if(! caml_call2(Core[246], node[12], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    if(! t) return 0;
    var bind = t[1];
    node[13] = bind[7];
    bind[7] = caml_call1(Incremental_Import[16][4], node);
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Scope);
   var
    Incremental_Scope =
      [0,
       sexp_of_t,
       invariant,
       top,
       is_top,
       height,
       is_valid,
       is_necessary,
       add_node];
   runtime.caml_register_global
    (17, Incremental_Scope, cst_Incremental_Scope$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Freeze
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Scope, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Freeze$0 = "Incremental__Freeze",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_freeze_ml = "src/freeze.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Scope = global_data.Incremental__Scope,
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Freeze$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_freeze_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _i_ = [0, "_"],
    _h_ = [0, cst_src_freeze_ml, 19, 11],
    _g_ = [0, cst_src_freeze_ml, 23, 26],
    _f_ = [0, cst_src_freeze_ml, 24, 18],
    _j_ = [0, cst_src_freeze_ml, 14, 239, 261],
    _c_ = [0, "only_freeze_when"],
    _d_ = [0, "child"],
    _e_ = [0, cst_main$0],
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Freeze = cst_Incremental_Freeze$0;
   function main(r){return r[1];}
   function _a_(r, v){return [0, v, r[2], r[3]];}
   var
    _b_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _b_, main, _a_];
   function sexp_of_t(of_a_001, param){
    var child_005 = param[2], main_003 = param[1], bnds_002 = 0;
    function _m_(_n_){return 0;}
    var
     arg_008 = caml_call1(Sexplib0_Sexp_conv[24], _m_),
     bnds_002$0 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call2(Incremental_Types[15][1], of_a_001, child_005),
     bnds_002$1 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$2 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function invariant(invariant_a, t){
    function _k_(param){
     function f(main){
      if(! caml_call1(Incremental_Scope[4], main[12]))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      var match = main[5];
      if(typeof match === "number"){if(0 === match) return 0;}
      else
       switch(match[0]){
         case 5:
          return 0;
         case 7:
          var t$0 = match[1];
          if(caml_call2(Core[246], t, t$0)) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
       }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     var main_fun = caml_call2(Base_Invariant[2], t, f);
     caml_call1(main_fun, main$0);
     return 0;
    }
    function _l_(x_009){
     return sexp_of_t(function(param){return _i_;}, x_009);
    }
    return caml_call4(Base_Invariant[1], _j_, t, _l_, _k_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Freeze);
   var Incremental_Freeze = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (30, Incremental_Freeze, cst_Incremental_Freeze$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__If_then_else
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_If_then_else$0 = "Incremental__If_then_else",
    cst_current_branch$0 = "current_branch",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_if_then_else_ml = "src/if_then_else.ml",
    cst_test_change$0 = "test_change",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Types = global_data.Incremental__Types;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_If_then_else$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_if_then_else_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _q_ = [0, "_"],
    _p_ = [0, cst_src_if_then_else_ml, 26, 32],
    _o_ = [0, cst_src_if_then_else_ml, 33, 34],
    _n_ = [0, cst_src_if_then_else_ml, 34, 18],
    _m_ = [0, cst_src_if_then_else_ml, 40, 13],
    _r_ = [0, cst_src_if_then_else_ml, 19, 382, 404],
    _g_ = [0, "else_"],
    _h_ = [0, "then_"],
    _i_ = [0, cst_current_branch$0],
    _j_ = [0, cst_test_change$0],
    _k_ = [0, "test"],
    _l_ = [0, cst_main$0],
    cst_current_branch = cst_current_branch$0,
    cst_test_change = cst_test_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_If_then_else = cst_Incremental_If_then_else$0;
   function current_branch(r){return r[4];}
   function set_current_branch(r, v){r[4] = v; return 0;}
   function test_change(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _b_ = [0, set_current_branch],
    current_branch$0 =
      [0,
       function(param){return 0;},
       cst_current_branch,
       _b_,
       current_branch,
       _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _d_ = 0,
    test_change$0 =
      [0, function(param){return 0;}, cst_test_change, _d_, test_change, _c_];
   function _e_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _f_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _f_, main, _e_];
   function sexp_of_t(of_a_001, param){
    var
     test_change_007 = param[3],
     test_005 = param[2],
     main_003 = param[1],
     current_branch_009 = param[4],
     else_013 = param[6],
     then_011 = param[5],
     arg_014 = caml_call2(Incremental_Types[15][1], of_a_001, else_013),
     bnds_002 = [0, [1, [0, _g_, [0, arg_014, 0]]], 0],
     arg_012 = caml_call2(Incremental_Types[15][1], of_a_001, then_011),
     bnds_002$0 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_002],
     _v_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_010 = caml_call2(Incremental_Import[16][1], _v_, current_branch_009),
     bnds_002$1 = [0, [1, [0, _i_, [0, arg_010, 0]]], bnds_002$0],
     arg_008 =
       caml_call2(Incremental_Types[15][1], Core[518], test_change_007),
     bnds_002$2 = [0, [1, [0, _j_, [0, arg_008, 0]]], bnds_002$1],
     arg_006 = caml_call2(Incremental_Types[15][1], Core[305], test_005),
     bnds_002$3 = [0, [1, [0, _k_, [0, arg_006, 0]]], bnds_002$2],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$4 = [0, [1, [0, _l_, [0, arg_004, 0]]], bnds_002$3];
    return [1, bnds_002$4];
   }
   function invariant(invariant_a, t1){
    function _s_(param){
     function check(f){return caml_call2(Base_Invariant[2], t1, f);}
     var
      current_branch_fun =
        check
         (function(current_branch){
           var _u_ = caml_call1(Incremental_Import[16][6], current_branch);
           if(! _u_) return _u_;
           var
            current_branch$0 =
              caml_call1(Incremental_Import[16][7], current_branch);
           if
            (!
             caml_call2(Core[246], current_branch$0, t1[5])
             && ! caml_call2(Core[246], current_branch$0, t1[6]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
           return 0;
          }),
      test_change_fun =
        check
         (function(test_change){
           var match = test_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(8 === match[0]){
            var t2 = match[1];
            if(caml_call2(Core[247], t1, t2)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(9 === match[0]){
            var t = match[1];
            if(caml_call2(Core[246], t1, t)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
           }
           return 0;
          });
     caml_call1(main_fun, main$0);
     caml_call1(test_change_fun, test_change$0);
     caml_call1(current_branch_fun, current_branch$0);
     return 0;
    }
    function _t_(x_015){
     return sexp_of_t(function(param){return _q_;}, x_015);
    }
    return caml_call4(Base_Invariant[1], _r_, t1, _t_, _s_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_If_then_else);
   var Incremental_If_then_else = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (36, Incremental_If_then_else, cst_Incremental_If_then_else$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Join
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Join$0 = "Incremental__Join",
    cst_incremental$0 = "incremental",
    cst_lhs_change$0 = "lhs_change",
    cst_main$0 = "main",
    cst_src_join_ml = "src/join.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Core = global_data.Core,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Join$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_join_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _m_ = [0, "_"],
    _l_ = [0, cst_src_join_ml, 24, 29],
    _k_ = [0, cst_src_join_ml, 25, 18],
    _j_ = [0, cst_src_join_ml, 31, 35],
    _i_ = [0, cst_src_join_ml, 32, 18],
    _n_ = [0, cst_src_join_ml, 17, 322, 344],
    _e_ = [0, "rhs"],
    _f_ = [0, cst_lhs_change$0],
    _g_ = [0, "lhs"],
    _h_ = [0, cst_main$0],
    cst_lhs_change = cst_lhs_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Join = cst_Incremental_Join$0;
   function lhs_change(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _b_ = 0,
    lhs_change$0 =
      [0, function(param){return 0;}, cst_lhs_change, _b_, lhs_change, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(of_a_001, param){
    var
     lhs_change_007 = param[3],
     lhs_005 = param[2],
     main_003 = param[1],
     rhs_009 = param[4],
     _q_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_010 = caml_call2(Incremental_Import[16][1], _q_, rhs_009),
     bnds_002 = [0, [1, [0, _e_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call2(Incremental_Types[15][1], Core[518], lhs_change_007),
     bnds_002$0 = [0, [1, [0, _f_, [0, arg_008, 0]]], bnds_002],
     _r_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_006 = caml_call2(Incremental_Types[15][1], _r_, lhs_005),
     bnds_002$1 = [0, [1, [0, _g_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$2 = [0, [1, [0, _h_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function same(t1, t2){return caml_call2(Core[247], t1, t2);}
   function invariant(invariant_a, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      lhs_change_fun =
        check
         (function(lhs_change){
           var match = lhs_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(10 === match[0]){
            var t$0 = match[1];
            if(same(t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(11 === match[0]){
            var t$0 = match[1];
            if(same(t, t$0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(lhs_change_fun, lhs_change$0);
     return 0;
    }
    function _p_(x_011){
     return sexp_of_t(function(param){return _m_;}, x_011);
    }
    return caml_call4(Base_Invariant[1], _n_, t, _p_, _o_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Join);
   var Incremental_Join = [0, invariant, sexp_of_t];
   runtime.caml_register_global(32, Incremental_Join, cst_Incremental_Join$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Snapshot
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Scope, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Snapshot$0 = "Incremental__Snapshot",
    cst_before$0 = "before",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_snapshot_ml = "src/snapshot.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Scope = global_data.Incremental__Scope,
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Snapshot$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_snapshot_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _m_ = [0, "_"],
    _l_ = [0, cst_src_snapshot_ml, 21, 11],
    _k_ = [0, cst_src_snapshot_ml, 25, 28],
    _j_ = [0, cst_src_snapshot_ml, 26, 18],
    _n_ = [0, cst_src_snapshot_ml, 16, 286, 308],
    _e_ = [0, "clock"],
    _f_ = [0, "value_at"],
    _g_ = [0, cst_before$0],
    _h_ = [0, "at"],
    _i_ = [0, cst_main$0],
    cst_before = cst_before$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Snapshot = cst_Incremental_Snapshot$0;
   function before(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _b_ = 0,
    before$0 = [0, function(param){return 0;}, cst_before, _b_, before, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(of_a_001, param){
    var
     clock_011 = param[5],
     value_at_009 = param[4],
     before_007 = param[3],
     at_005 = param[2],
     main_003 = param[1],
     arg_012 = caml_call1(Sexplib0_Sexp_conv[23], clock_011),
     bnds_002 = [0, [1, [0, _e_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call2(Incremental_Types[15][1], of_a_001, value_at_009),
     bnds_002$0 = [0, [1, [0, _f_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(of_a_001, before_007),
     bnds_002$1 = [0, [1, [0, _g_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Incremental_Import[14][119], at_005),
     bnds_002$2 = [0, [1, [0, _h_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$3 = [0, [1, [0, _i_, [0, arg_004, 0]]], bnds_002$2];
    return [1, bnds_002$3];
   }
   function invariant(invariant_a, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      before_fun = check(invariant_a),
      main_fun =
        check
         (function(main){
           if(! caml_call1(Incremental_Scope[4], main[12]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 5:
               return 0;
              case 13:
               var t$0 = match[1];
               if(caml_call2(Core[246], t, t$0)) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(before_fun, before$0);
     return 0;
    }
    function _p_(x_013){
     return sexp_of_t(function(param){return _m_;}, x_013);
    }
    return caml_call4(Base_Invariant[1], _n_, t, _p_, _o_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Snapshot);
   var Incremental_Snapshot = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (35, Incremental_Snapshot, cst_Incremental_Snapshot$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Kind
//# unitInfo: Requires: Core, Expect_test_collector, Incremental__Array_fold, Incremental__At, Incremental__At_intervals, Incremental__Bind, Incremental__Expert, Incremental__Freeze, Incremental__If_then_else, Incremental__Import, Incremental__Join, Incremental__Snapshot, Incremental__Step_function_node, Incremental__Types, Incremental__Unordered_array_fold, Incremental__Var, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Array_fold$0 = "Array_fold",
    cst_At$0 = "At",
    cst_At_intervals$0 = "At_intervals",
    cst_Bind_lhs_change$0 = "Bind_lhs_change",
    cst_Bind_main$0 = "Bind_main",
    cst_Const$0 = "Const",
    cst_Expert$0 = "Expert",
    cst_Freeze$0 = "Freeze",
    cst_If_test_change$0 = "If_test_change",
    cst_If_then_else$0 = "If_then_else",
    cst_Incremental_Kind$0 = "Incremental__Kind",
    cst_Invalid$0 = "Invalid",
    cst_Join_lhs_change$0 = "Join_lhs_change",
    cst_Join_main$0 = "Join_main",
    cst_Map$0 = "Map",
    cst_Map10$0 = "Map10",
    cst_Map11$0 = "Map11",
    cst_Map12$0 = "Map12",
    cst_Map13$0 = "Map13",
    cst_Map14$0 = "Map14",
    cst_Map15$0 = "Map15",
    cst_Map2$0 = "Map2",
    cst_Map3$0 = "Map3",
    cst_Map4$0 = "Map4",
    cst_Map5$0 = "Map5",
    cst_Map6$0 = "Map6",
    cst_Map7$0 = "Map7",
    cst_Map8$0 = "Map8",
    cst_Map9$0 = "Map9",
    cst_Snapshot$0 = "Snapshot",
    cst_Step_function$0 = "Step_function",
    cst_Uninitialized$0 = "Uninitialized",
    cst_Unordered_array_fold$0 = "Unordered_array_fold",
    cst_Var$0 = "Var",
    cst$0 = "_",
    cst_incremental$0 = "incremental",
    cst_src_kind_ml = "src/kind.ml",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Array_fold = global_data.Incremental__Array_fold,
    Incremental_At = global_data.Incremental__At,
    Incremental_At_intervals = global_data.Incremental__At_intervals,
    Incremental_Bind = global_data.Incremental__Bind,
    Incremental_Expert = global_data.Incremental__Expert,
    Incremental_Freeze = global_data.Incremental__Freeze,
    Incremental_If_then_else = global_data.Incremental__If_then_else,
    Incremental_Join = global_data.Incremental__Join,
    Incremental_Snapshot = global_data.Incremental__Snapshot,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Incremental_Unordered_array_fo =
      global_data.Incremental__Unordered_array_fold,
    Incremental_Var = global_data.Incremental__Var,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Kind$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_kind_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _bQ_ = [0, cst$0],
    cst_Kind_slow_get_child_got_in = "Kind.slow_get_child got invalid index",
    _bR_ = [0, cst_src_kind_ml, 602, 14347, 14361],
    cst_Invalid = cst_Invalid$0,
    cst_Uninitialized = cst_Uninitialized$0,
    cst_Array_fold = cst_Array_fold$0,
    cst_At = cst_At$0,
    cst_At_intervals = cst_At_intervals$0,
    cst_Bind_lhs_change = cst_Bind_lhs_change$0,
    cst_Bind_main = cst_Bind_main$0,
    cst_Const = cst_Const$0,
    cst_Expert = cst_Expert$0,
    cst_Freeze = cst_Freeze$0,
    cst_If_test_change = cst_If_test_change$0,
    cst_If_then_else = cst_If_then_else$0,
    cst_Join_lhs_change = cst_Join_lhs_change$0,
    cst_Join_main = cst_Join_main$0,
    cst_Map = cst_Map$0,
    cst_Snapshot = cst_Snapshot$0,
    cst_Step_function = cst_Step_function$0,
    cst_Unordered_array_fold = cst_Unordered_array_fold$0,
    cst_Var = cst_Var$0,
    cst_Map2 = cst_Map2$0,
    cst_Map3 = cst_Map3$0,
    cst_Map4 = cst_Map4$0,
    cst_Map5 = cst_Map5$0,
    cst_Map6 = cst_Map6$0,
    cst_Map7 = cst_Map7$0,
    cst_Map8 = cst_Map8$0,
    cst_Map9 = cst_Map9$0,
    cst_Map10 = cst_Map10$0,
    cst_Map11 = cst_Map11$0,
    cst_Map12 = cst_Map12$0,
    cst_Map13 = cst_Map13$0,
    cst_Map14 = cst_Map14$0,
    cst_Map15 = cst_Map15$0,
    _bO_ = [0, cst$0],
    _bN_ = [0, cst$0],
    _bM_ = [0, cst$0],
    _bL_ = [0, cst$0],
    _bK_ = [0, cst$0],
    _bJ_ = [0, cst$0],
    _bI_ = [0, cst$0],
    _bH_ = [0, cst$0],
    _bG_ = [0, cst$0],
    _bF_ = [0, cst$0],
    _bE_ = [0, cst$0],
    _bD_ = [0, cst$0],
    _bC_ = [0, cst$0],
    _bB_ = [0, cst$0],
    _bA_ = [0, cst$0],
    _by_ = [0, cst$0],
    _bx_ = [0, cst$0],
    _bw_ = [0, cst$0],
    _bv_ = [0, cst$0],
    _bu_ = [0, cst$0],
    _bt_ = [0, cst$0],
    _bs_ = [0, cst$0],
    _br_ = [0, cst$0],
    _bq_ = [0, cst$0],
    _bp_ = [0, cst$0],
    _bo_ = [0, cst$0],
    _bn_ = [0, cst$0],
    _bm_ = [0, cst$0],
    _bl_ = [0, cst$0],
    _bj_ = [0, cst$0],
    _bi_ = [0, cst$0],
    _bh_ = [0, cst$0],
    _bg_ = [0, cst$0],
    _bf_ = [0, cst$0],
    _be_ = [0, cst$0],
    _bd_ = [0, cst$0],
    _bc_ = [0, cst$0],
    _bb_ = [0, cst$0],
    _ba_ = [0, cst$0],
    _a$_ = [0, cst$0],
    _a__ = [0, cst$0],
    _a9_ = [0, cst$0],
    _a7_ = [0, cst$0],
    _a6_ = [0, cst$0],
    _a5_ = [0, cst$0],
    _a4_ = [0, cst$0],
    _a3_ = [0, cst$0],
    _a2_ = [0, cst$0],
    _a1_ = [0, cst$0],
    _a0_ = [0, cst$0],
    _aZ_ = [0, cst$0],
    _aY_ = [0, cst$0],
    _aX_ = [0, cst$0],
    _aW_ = [0, cst$0],
    _aU_ = [0, cst$0],
    _aT_ = [0, cst$0],
    _aS_ = [0, cst$0],
    _aR_ = [0, cst$0],
    _aQ_ = [0, cst$0],
    _aP_ = [0, cst$0],
    _aO_ = [0, cst$0],
    _aN_ = [0, cst$0],
    _aM_ = [0, cst$0],
    _aL_ = [0, cst$0],
    _aK_ = [0, cst$0],
    _aI_ = [0, cst$0],
    _aH_ = [0, cst$0],
    _aG_ = [0, cst$0],
    _aF_ = [0, cst$0],
    _aE_ = [0, cst$0],
    _aD_ = [0, cst$0],
    _aC_ = [0, cst$0],
    _aB_ = [0, cst$0],
    _aA_ = [0, cst$0],
    _az_ = [0, cst$0],
    _ax_ = [0, cst$0],
    _aw_ = [0, cst$0],
    _av_ = [0, cst$0],
    _au_ = [0, cst$0],
    _at_ = [0, cst$0],
    _as_ = [0, cst$0],
    _ar_ = [0, cst$0],
    _aq_ = [0, cst$0],
    _ap_ = [0, cst$0],
    _an_ = [0, cst$0],
    _am_ = [0, cst$0],
    _al_ = [0, cst$0],
    _ak_ = [0, cst$0],
    _aj_ = [0, cst$0],
    _ai_ = [0, cst$0],
    _ah_ = [0, cst$0],
    _ag_ = [0, cst$0],
    _ae_ = [0, cst$0],
    _ad_ = [0, cst$0],
    _ac_ = [0, cst$0],
    _ab_ = [0, cst$0],
    _aa_ = [0, cst$0],
    _$_ = [0, cst$0],
    ___ = [0, cst$0],
    _Y_ = [0, cst$0],
    _X_ = [0, cst$0],
    _W_ = [0, cst$0],
    _V_ = [0, cst$0],
    _U_ = [0, cst$0],
    _T_ = [0, cst$0],
    _R_ = [0, cst$0],
    _Q_ = [0, cst$0],
    _P_ = [0, cst$0],
    _O_ = [0, cst$0],
    _N_ = [0, cst$0],
    _L_ = [0, cst$0],
    _K_ = [0, cst$0],
    _J_ = [0, cst$0],
    _I_ = [0, cst$0],
    _G_ = [0, cst$0],
    _F_ = [0, cst$0],
    _E_ = [0, cst$0],
    _C_ = [0, cst$0],
    _B_ = [0, cst$0],
    _y_ = [0, cst$0],
    _u_ = [0, cst$0],
    _r_ = [0, cst$0],
    _o_ = [0, cst$0],
    _j_ = [0, cst$0],
    _h_ = [0, cst$0],
    _g_ = [0, cst$0],
    _c_ = [0, cst$0],
    _a_ = [0, cst_Invalid$0],
    _b_ = [0, cst_Uninitialized$0],
    _d_ = [0, cst_Array_fold$0],
    _e_ = [0, cst_At$0],
    _f_ = [0, cst_At_intervals$0],
    _i_ = [0, cst_Bind_lhs_change$0],
    _k_ = [0, cst_Bind_main$0],
    _l_ = [0, cst_Const$0],
    _m_ = [0, cst_Expert$0],
    _n_ = [0, cst_Freeze$0],
    _p_ = [0, cst_If_test_change$0],
    _q_ = [0, cst_If_then_else$0],
    _s_ = [0, cst_Join_lhs_change$0],
    _t_ = [0, cst_Join_main$0],
    _v_ = [0, cst_Map$0],
    _w_ = [0, cst_Snapshot$0],
    _x_ = [0, cst_Step_function$0],
    _z_ = [0, cst_Unordered_array_fold$0],
    _A_ = [0, cst_Var$0],
    _D_ = [0, cst_Map2$0],
    _H_ = [0, cst_Map3$0],
    _M_ = [0, cst_Map4$0],
    _S_ = [0, cst_Map5$0],
    _Z_ = [0, cst_Map6$0],
    _af_ = [0, cst_Map7$0],
    _ao_ = [0, cst_Map8$0],
    _ay_ = [0, cst_Map9$0],
    _aJ_ = [0, cst_Map10$0],
    _aV_ = [0, cst_Map11$0],
    _a8_ = [0, cst_Map12$0],
    _bk_ = [0, cst_Map13$0],
    _bz_ = [0, cst_Map14$0],
    _bP_ = [0, cst_Map15$0],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Kind = cst_Incremental_Kind$0;
   function sexp_of_t(of_a_001, param){
    if(typeof param === "number") return 0 === param ? _a_ : _b_;
    switch(param[0]){
      case 0:
       var
        arg0_002 = param[1],
        _co_ = function(param){return _c_;},
        res0_003 =
          caml_call3(Incremental_Array_fold[1], _co_, of_a_001, arg0_002);
       return [1, [0, _d_, [0, res0_003, 0]]];
      case 1:
       var
        arg0_004 = param[1],
        res0_005 = caml_call1(Incremental_At[2], arg0_004);
       return [1, [0, _e_, [0, res0_005, 0]]];
      case 2:
       var
        arg0_006 = param[1],
        res0_007 = caml_call1(Incremental_At_intervals[2], arg0_006);
       return [1, [0, _f_, [0, res0_007, 0]]];
      case 3:
       var
        arg0_008 = param[1],
        _cp_ = function(param){return _g_;},
        _cq_ = function(param){return _h_;},
        res0_009 = caml_call3(Incremental_Bind[2], _cq_, _cp_, arg0_008);
       return [1, [0, _i_, [0, res0_009, 0]]];
      case 4:
       var
        arg0_010 = param[1],
        _cr_ = function(param){return _j_;},
        res0_011 = caml_call3(Incremental_Bind[2], _cr_, of_a_001, arg0_010);
       return [1, [0, _k_, [0, res0_011, 0]]];
      case 5:
       var arg0_012 = param[1], res0_013 = caml_call1(of_a_001, arg0_012);
       return [1, [0, _l_, [0, res0_013, 0]]];
      case 6:
       var
        arg0_014 = param[1],
        res0_015 = caml_call2(Incremental_Expert[2], of_a_001, arg0_014);
       return [1, [0, _m_, [0, res0_015, 0]]];
      case 7:
       var
        arg0_016 = param[1],
        res0_017 = caml_call2(Incremental_Freeze[2], of_a_001, arg0_016);
       return [1, [0, _n_, [0, res0_017, 0]]];
      case 8:
       var
        arg0_018 = param[1],
        _cs_ = function(param){return _o_;},
        res0_019 = caml_call2(Incremental_If_then_else[2], _cs_, arg0_018);
       return [1, [0, _p_, [0, res0_019, 0]]];
      case 9:
       var
        arg0_020 = param[1],
        res0_021 = caml_call2(Incremental_If_then_else[2], of_a_001, arg0_020);
       return [1, [0, _q_, [0, res0_021, 0]]];
      case 10:
       var
        arg0_022 = param[1],
        _ct_ = function(param){return _r_;},
        res0_023 = caml_call2(Incremental_Join[2], _ct_, arg0_022);
       return [1, [0, _s_, [0, res0_023, 0]]];
      case 11:
       var
        arg0_024 = param[1],
        res0_025 = caml_call2(Incremental_Join[2], of_a_001, arg0_024);
       return [1, [0, _t_, [0, res0_025, 0]]];
      case 12:
       var
        arg1_027 = param[2],
        _cu_ = function(_eQ_){return 0;},
        res0_028 = caml_call1(Sexplib0_Sexp_conv[24], _cu_),
        _cv_ = function(param){return _u_;},
        res1_029 = caml_call2(Incremental_Types[15][1], _cv_, arg1_027);
       return [1, [0, _v_, [0, res0_028, [0, res1_029, 0]]]];
      case 13:
       var
        arg0_030 = param[1],
        res0_031 = caml_call2(Incremental_Snapshot[2], of_a_001, arg0_030);
       return [1, [0, _w_, [0, res0_031, 0]]];
      case 14:
       var
        arg0_032 = param[1],
        res0_033 =
          caml_call2(Incremental_Step_function_node[2], of_a_001, arg0_032);
       return [1, [0, _x_, [0, res0_033, 0]]];
      case 15:
       var
        arg0_034 = param[1],
        _cw_ = function(param){return _y_;},
        res0_035 =
          caml_call3
           (Incremental_Unordered_array_fo[2], _cw_, of_a_001, arg0_034);
       return [1, [0, _z_, [0, res0_035, 0]]];
      case 16:
       var
        arg0_036 = param[1],
        res0_037 = caml_call2(Incremental_Var[2], of_a_001, arg0_036);
       return [1, [0, _A_, [0, res0_037, 0]]];
      case 17:
       var
        arg2_040 = param[3],
        arg1_039 = param[2],
        _cx_ = function(_eP_){return 0;},
        res0_041 = caml_call1(Sexplib0_Sexp_conv[24], _cx_),
        _cy_ = function(param){return _B_;},
        res1_042 = caml_call2(Incremental_Types[15][1], _cy_, arg1_039),
        _cz_ = function(param){return _C_;},
        res2_043 = caml_call2(Incremental_Types[15][1], _cz_, arg2_040);
       return [1, [0, _D_, [0, res0_041, [0, res1_042, [0, res2_043, 0]]]]];
      case 18:
       var
        arg3_047 = param[4],
        arg2_046 = param[3],
        arg1_045 = param[2],
        _cA_ = function(_eO_){return 0;},
        res0_048 = caml_call1(Sexplib0_Sexp_conv[24], _cA_),
        _cB_ = function(param){return _E_;},
        res1_049 = caml_call2(Incremental_Types[15][1], _cB_, arg1_045),
        _cC_ = function(param){return _F_;},
        res2_050 = caml_call2(Incremental_Types[15][1], _cC_, arg2_046),
        _cD_ = function(param){return _G_;},
        res3_051 = caml_call2(Incremental_Types[15][1], _cD_, arg3_047);
       return [1,
               [0,
                _H_,
                [0, res0_048, [0, res1_049, [0, res2_050, [0, res3_051, 0]]]]]];
      case 19:
       var
        arg4_056 = param[5],
        arg3_055 = param[4],
        arg2_054 = param[3],
        arg1_053 = param[2],
        _cE_ = function(_eN_){return 0;},
        res0_057 = caml_call1(Sexplib0_Sexp_conv[24], _cE_),
        _cF_ = function(param){return _I_;},
        res1_058 = caml_call2(Incremental_Types[15][1], _cF_, arg1_053),
        _cG_ = function(param){return _J_;},
        res2_059 = caml_call2(Incremental_Types[15][1], _cG_, arg2_054),
        _cH_ = function(param){return _K_;},
        res3_060 = caml_call2(Incremental_Types[15][1], _cH_, arg3_055),
        _cI_ = function(param){return _L_;},
        res4_061 = caml_call2(Incremental_Types[15][1], _cI_, arg4_056);
       return [1,
               [0,
                _M_,
                [0,
                 res0_057,
                 [0, res1_058, [0, res2_059, [0, res3_060, [0, res4_061, 0]]]]]]];
      case 20:
       var
        arg5_067 = param[6],
        arg4_066 = param[5],
        arg3_065 = param[4],
        arg2_064 = param[3],
        arg1_063 = param[2],
        _cJ_ = function(_eM_){return 0;},
        res0_068 = caml_call1(Sexplib0_Sexp_conv[24], _cJ_),
        _cK_ = function(param){return _N_;},
        res1_069 = caml_call2(Incremental_Types[15][1], _cK_, arg1_063),
        _cL_ = function(param){return _O_;},
        res2_070 = caml_call2(Incremental_Types[15][1], _cL_, arg2_064),
        _cM_ = function(param){return _P_;},
        res3_071 = caml_call2(Incremental_Types[15][1], _cM_, arg3_065),
        _cN_ = function(param){return _Q_;},
        res4_072 = caml_call2(Incremental_Types[15][1], _cN_, arg4_066),
        _cO_ = function(param){return _R_;},
        res5_073 = caml_call2(Incremental_Types[15][1], _cO_, arg5_067);
       return [1,
               [0,
                _S_,
                [0,
                 res0_068,
                 [0,
                  res1_069,
                  [0,
                   res2_070,
                   [0, res3_071, [0, res4_072, [0, res5_073, 0]]]]]]]];
      case 21:
       var
        arg6_080 = param[7],
        arg5_079 = param[6],
        arg4_078 = param[5],
        arg3_077 = param[4],
        arg2_076 = param[3],
        arg1_075 = param[2],
        _cP_ = function(_eL_){return 0;},
        res0_081 = caml_call1(Sexplib0_Sexp_conv[24], _cP_),
        _cQ_ = function(param){return _T_;},
        res1_082 = caml_call2(Incremental_Types[15][1], _cQ_, arg1_075),
        _cR_ = function(param){return _U_;},
        res2_083 = caml_call2(Incremental_Types[15][1], _cR_, arg2_076),
        _cS_ = function(param){return _V_;},
        res3_084 = caml_call2(Incremental_Types[15][1], _cS_, arg3_077),
        _cT_ = function(param){return _W_;},
        res4_085 = caml_call2(Incremental_Types[15][1], _cT_, arg4_078),
        _cU_ = function(param){return _X_;},
        res5_086 = caml_call2(Incremental_Types[15][1], _cU_, arg5_079),
        _cV_ = function(param){return _Y_;},
        res6_087 = caml_call2(Incremental_Types[15][1], _cV_, arg6_080);
       return [1,
               [0,
                _Z_,
                [0,
                 res0_081,
                 [0,
                  res1_082,
                  [0,
                   res2_083,
                   [0,
                    res3_084,
                    [0, res4_085, [0, res5_086, [0, res6_087, 0]]]]]]]]];
      case 22:
       var
        arg7_095 = param[8],
        arg6_094 = param[7],
        arg5_093 = param[6],
        arg4_092 = param[5],
        arg3_091 = param[4],
        arg2_090 = param[3],
        arg1_089 = param[2],
        _cW_ = function(_eK_){return 0;},
        res0_096 = caml_call1(Sexplib0_Sexp_conv[24], _cW_),
        _cX_ = function(param){return ___;},
        res1_097 = caml_call2(Incremental_Types[15][1], _cX_, arg1_089),
        _cY_ = function(param){return _$_;},
        res2_098 = caml_call2(Incremental_Types[15][1], _cY_, arg2_090),
        _cZ_ = function(param){return _aa_;},
        res3_099 = caml_call2(Incremental_Types[15][1], _cZ_, arg3_091),
        _c0_ = function(param){return _ab_;},
        res4_100 = caml_call2(Incremental_Types[15][1], _c0_, arg4_092),
        _c1_ = function(param){return _ac_;},
        res5_101 = caml_call2(Incremental_Types[15][1], _c1_, arg5_093),
        _c2_ = function(param){return _ad_;},
        res6_102 = caml_call2(Incremental_Types[15][1], _c2_, arg6_094),
        _c3_ = function(param){return _ae_;},
        res7_103 = caml_call2(Incremental_Types[15][1], _c3_, arg7_095);
       return [1,
               [0,
                _af_,
                [0,
                 res0_096,
                 [0,
                  res1_097,
                  [0,
                   res2_098,
                   [0,
                    res3_099,
                    [0,
                     res4_100,
                     [0, res5_101, [0, res6_102, [0, res7_103, 0]]]]]]]]]];
      case 23:
       var
        arg8_112 = param[9],
        arg7_111 = param[8],
        arg6_110 = param[7],
        arg5_109 = param[6],
        arg4_108 = param[5],
        arg3_107 = param[4],
        arg2_106 = param[3],
        arg1_105 = param[2],
        _c4_ = function(_eJ_){return 0;},
        res0_113 = caml_call1(Sexplib0_Sexp_conv[24], _c4_),
        _c5_ = function(param){return _ag_;},
        res1_114 = caml_call2(Incremental_Types[15][1], _c5_, arg1_105),
        _c6_ = function(param){return _ah_;},
        res2_115 = caml_call2(Incremental_Types[15][1], _c6_, arg2_106),
        _c7_ = function(param){return _ai_;},
        res3_116 = caml_call2(Incremental_Types[15][1], _c7_, arg3_107),
        _c8_ = function(param){return _aj_;},
        res4_117 = caml_call2(Incremental_Types[15][1], _c8_, arg4_108),
        _c9_ = function(param){return _ak_;},
        res5_118 = caml_call2(Incremental_Types[15][1], _c9_, arg5_109),
        _c__ = function(param){return _al_;},
        res6_119 = caml_call2(Incremental_Types[15][1], _c__, arg6_110),
        _c$_ = function(param){return _am_;},
        res7_120 = caml_call2(Incremental_Types[15][1], _c$_, arg7_111),
        _da_ = function(param){return _an_;},
        res8_121 = caml_call2(Incremental_Types[15][1], _da_, arg8_112);
       return [1,
               [0,
                _ao_,
                [0,
                 res0_113,
                 [0,
                  res1_114,
                  [0,
                   res2_115,
                   [0,
                    res3_116,
                    [0,
                     res4_117,
                     [0,
                      res5_118,
                      [0, res6_119, [0, res7_120, [0, res8_121, 0]]]]]]]]]]];
      case 24:
       var
        arg9_131 = param[10],
        arg8_130 = param[9],
        arg7_129 = param[8],
        arg6_128 = param[7],
        arg5_127 = param[6],
        arg4_126 = param[5],
        arg3_125 = param[4],
        arg2_124 = param[3],
        arg1_123 = param[2],
        _db_ = function(_eI_){return 0;},
        res0_132 = caml_call1(Sexplib0_Sexp_conv[24], _db_),
        _dc_ = function(param){return _ap_;},
        res1_133 = caml_call2(Incremental_Types[15][1], _dc_, arg1_123),
        _dd_ = function(param){return _aq_;},
        res2_134 = caml_call2(Incremental_Types[15][1], _dd_, arg2_124),
        _de_ = function(param){return _ar_;},
        res3_135 = caml_call2(Incremental_Types[15][1], _de_, arg3_125),
        _df_ = function(param){return _as_;},
        res4_136 = caml_call2(Incremental_Types[15][1], _df_, arg4_126),
        _dg_ = function(param){return _at_;},
        res5_137 = caml_call2(Incremental_Types[15][1], _dg_, arg5_127),
        _dh_ = function(param){return _au_;},
        res6_138 = caml_call2(Incremental_Types[15][1], _dh_, arg6_128),
        _di_ = function(param){return _av_;},
        res7_139 = caml_call2(Incremental_Types[15][1], _di_, arg7_129),
        _dj_ = function(param){return _aw_;},
        res8_140 = caml_call2(Incremental_Types[15][1], _dj_, arg8_130),
        _dk_ = function(param){return _ax_;},
        res9_141 = caml_call2(Incremental_Types[15][1], _dk_, arg9_131);
       return [1,
               [0,
                _ay_,
                [0,
                 res0_132,
                 [0,
                  res1_133,
                  [0,
                   res2_134,
                   [0,
                    res3_135,
                    [0,
                     res4_136,
                     [0,
                      res5_137,
                      [0,
                       res6_138,
                       [0, res7_139, [0, res8_140, [0, res9_141, 0]]]]]]]]]]]];
      case 25:
       var
        arg10_152 = param[11],
        arg9_151 = param[10],
        arg8_150 = param[9],
        arg7_149 = param[8],
        arg6_148 = param[7],
        arg5_147 = param[6],
        arg4_146 = param[5],
        arg3_145 = param[4],
        arg2_144 = param[3],
        arg1_143 = param[2],
        _dl_ = function(_eH_){return 0;},
        res0_153 = caml_call1(Sexplib0_Sexp_conv[24], _dl_),
        _dm_ = function(param){return _az_;},
        res1_154 = caml_call2(Incremental_Types[15][1], _dm_, arg1_143),
        _dn_ = function(param){return _aA_;},
        res2_155 = caml_call2(Incremental_Types[15][1], _dn_, arg2_144),
        _do_ = function(param){return _aB_;},
        res3_156 = caml_call2(Incremental_Types[15][1], _do_, arg3_145),
        _dp_ = function(param){return _aC_;},
        res4_157 = caml_call2(Incremental_Types[15][1], _dp_, arg4_146),
        _dq_ = function(param){return _aD_;},
        res5_158 = caml_call2(Incremental_Types[15][1], _dq_, arg5_147),
        _dr_ = function(param){return _aE_;},
        res6_159 = caml_call2(Incremental_Types[15][1], _dr_, arg6_148),
        _ds_ = function(param){return _aF_;},
        res7_160 = caml_call2(Incremental_Types[15][1], _ds_, arg7_149),
        _dt_ = function(param){return _aG_;},
        res8_161 = caml_call2(Incremental_Types[15][1], _dt_, arg8_150),
        _du_ = function(param){return _aH_;},
        res9_162 = caml_call2(Incremental_Types[15][1], _du_, arg9_151),
        _dv_ = function(param){return _aI_;},
        res10_163 = caml_call2(Incremental_Types[15][1], _dv_, arg10_152);
       return [1,
               [0,
                _aJ_,
                [0,
                 res0_153,
                 [0,
                  res1_154,
                  [0,
                   res2_155,
                   [0,
                    res3_156,
                    [0,
                     res4_157,
                     [0,
                      res5_158,
                      [0,
                       res6_159,
                       [0,
                        res7_160,
                        [0, res8_161, [0, res9_162, [0, res10_163, 0]]]]]]]]]]]]];
      case 26:
       var
        arg11_175 = param[12],
        arg10_174 = param[11],
        arg9_173 = param[10],
        arg8_172 = param[9],
        arg7_171 = param[8],
        arg6_170 = param[7],
        arg5_169 = param[6],
        arg4_168 = param[5],
        arg3_167 = param[4],
        arg2_166 = param[3],
        arg1_165 = param[2],
        _dw_ = function(_eG_){return 0;},
        res0_176 = caml_call1(Sexplib0_Sexp_conv[24], _dw_),
        _dx_ = function(param){return _aK_;},
        res1_177 = caml_call2(Incremental_Types[15][1], _dx_, arg1_165),
        _dy_ = function(param){return _aL_;},
        res2_178 = caml_call2(Incremental_Types[15][1], _dy_, arg2_166),
        _dz_ = function(param){return _aM_;},
        res3_179 = caml_call2(Incremental_Types[15][1], _dz_, arg3_167),
        _dA_ = function(param){return _aN_;},
        res4_180 = caml_call2(Incremental_Types[15][1], _dA_, arg4_168),
        _dB_ = function(param){return _aO_;},
        res5_181 = caml_call2(Incremental_Types[15][1], _dB_, arg5_169),
        _dC_ = function(param){return _aP_;},
        res6_182 = caml_call2(Incremental_Types[15][1], _dC_, arg6_170),
        _dD_ = function(param){return _aQ_;},
        res7_183 = caml_call2(Incremental_Types[15][1], _dD_, arg7_171),
        _dE_ = function(param){return _aR_;},
        res8_184 = caml_call2(Incremental_Types[15][1], _dE_, arg8_172),
        _dF_ = function(param){return _aS_;},
        res9_185 = caml_call2(Incremental_Types[15][1], _dF_, arg9_173),
        _dG_ = function(param){return _aT_;},
        res10_186 = caml_call2(Incremental_Types[15][1], _dG_, arg10_174),
        _dH_ = function(param){return _aU_;},
        res11_187 = caml_call2(Incremental_Types[15][1], _dH_, arg11_175);
       return [1,
               [0,
                _aV_,
                [0,
                 res0_176,
                 [0,
                  res1_177,
                  [0,
                   res2_178,
                   [0,
                    res3_179,
                    [0,
                     res4_180,
                     [0,
                      res5_181,
                      [0,
                       res6_182,
                       [0,
                        res7_183,
                        [0,
                         res8_184,
                         [0, res9_185, [0, res10_186, [0, res11_187, 0]]]]]]]]]]]]]];
      case 27:
       var
        arg12_200 = param[13],
        arg11_199 = param[12],
        arg10_198 = param[11],
        arg9_197 = param[10],
        arg8_196 = param[9],
        arg7_195 = param[8],
        arg6_194 = param[7],
        arg5_193 = param[6],
        arg4_192 = param[5],
        arg3_191 = param[4],
        arg2_190 = param[3],
        arg1_189 = param[2],
        _dI_ = function(_eF_){return 0;},
        res0_201 = caml_call1(Sexplib0_Sexp_conv[24], _dI_),
        _dJ_ = function(param){return _aW_;},
        res1_202 = caml_call2(Incremental_Types[15][1], _dJ_, arg1_189),
        _dK_ = function(param){return _aX_;},
        res2_203 = caml_call2(Incremental_Types[15][1], _dK_, arg2_190),
        _dL_ = function(param){return _aY_;},
        res3_204 = caml_call2(Incremental_Types[15][1], _dL_, arg3_191),
        _dM_ = function(param){return _aZ_;},
        res4_205 = caml_call2(Incremental_Types[15][1], _dM_, arg4_192),
        _dN_ = function(param){return _a0_;},
        res5_206 = caml_call2(Incremental_Types[15][1], _dN_, arg5_193),
        _dO_ = function(param){return _a1_;},
        res6_207 = caml_call2(Incremental_Types[15][1], _dO_, arg6_194),
        _dP_ = function(param){return _a2_;},
        res7_208 = caml_call2(Incremental_Types[15][1], _dP_, arg7_195),
        _dQ_ = function(param){return _a3_;},
        res8_209 = caml_call2(Incremental_Types[15][1], _dQ_, arg8_196),
        _dR_ = function(param){return _a4_;},
        res9_210 = caml_call2(Incremental_Types[15][1], _dR_, arg9_197),
        _dS_ = function(param){return _a5_;},
        res10_211 = caml_call2(Incremental_Types[15][1], _dS_, arg10_198),
        _dT_ = function(param){return _a6_;},
        res11_212 = caml_call2(Incremental_Types[15][1], _dT_, arg11_199),
        _dU_ = function(param){return _a7_;},
        res12_213 = caml_call2(Incremental_Types[15][1], _dU_, arg12_200);
       return [1,
               [0,
                _a8_,
                [0,
                 res0_201,
                 [0,
                  res1_202,
                  [0,
                   res2_203,
                   [0,
                    res3_204,
                    [0,
                     res4_205,
                     [0,
                      res5_206,
                      [0,
                       res6_207,
                       [0,
                        res7_208,
                        [0,
                         res8_209,
                         [0,
                          res9_210,
                          [0, res10_211, [0, res11_212, [0, res12_213, 0]]]]]]]]]]]]]]];
      case 28:
       var
        arg13_227 = param[14],
        arg12_226 = param[13],
        arg11_225 = param[12],
        arg10_224 = param[11],
        arg9_223 = param[10],
        arg8_222 = param[9],
        arg7_221 = param[8],
        arg6_220 = param[7],
        arg5_219 = param[6],
        arg4_218 = param[5],
        arg3_217 = param[4],
        arg2_216 = param[3],
        arg1_215 = param[2],
        _dV_ = function(_eE_){return 0;},
        res0_228 = caml_call1(Sexplib0_Sexp_conv[24], _dV_),
        _dW_ = function(param){return _a9_;},
        res1_229 = caml_call2(Incremental_Types[15][1], _dW_, arg1_215),
        _dX_ = function(param){return _a__;},
        res2_230 = caml_call2(Incremental_Types[15][1], _dX_, arg2_216),
        _dY_ = function(param){return _a$_;},
        res3_231 = caml_call2(Incremental_Types[15][1], _dY_, arg3_217),
        _dZ_ = function(param){return _ba_;},
        res4_232 = caml_call2(Incremental_Types[15][1], _dZ_, arg4_218),
        _d0_ = function(param){return _bb_;},
        res5_233 = caml_call2(Incremental_Types[15][1], _d0_, arg5_219),
        _d1_ = function(param){return _bc_;},
        res6_234 = caml_call2(Incremental_Types[15][1], _d1_, arg6_220),
        _d2_ = function(param){return _bd_;},
        res7_235 = caml_call2(Incremental_Types[15][1], _d2_, arg7_221),
        _d3_ = function(param){return _be_;},
        res8_236 = caml_call2(Incremental_Types[15][1], _d3_, arg8_222),
        _d4_ = function(param){return _bf_;},
        res9_237 = caml_call2(Incremental_Types[15][1], _d4_, arg9_223),
        _d5_ = function(param){return _bg_;},
        res10_238 = caml_call2(Incremental_Types[15][1], _d5_, arg10_224),
        _d6_ = function(param){return _bh_;},
        res11_239 = caml_call2(Incremental_Types[15][1], _d6_, arg11_225),
        _d7_ = function(param){return _bi_;},
        res12_240 = caml_call2(Incremental_Types[15][1], _d7_, arg12_226),
        _d8_ = function(param){return _bj_;},
        res13_241 = caml_call2(Incremental_Types[15][1], _d8_, arg13_227);
       return [1,
               [0,
                _bk_,
                [0,
                 res0_228,
                 [0,
                  res1_229,
                  [0,
                   res2_230,
                   [0,
                    res3_231,
                    [0,
                     res4_232,
                     [0,
                      res5_233,
                      [0,
                       res6_234,
                       [0,
                        res7_235,
                        [0,
                         res8_236,
                         [0,
                          res9_237,
                          [0,
                           res10_238,
                           [0, res11_239, [0, res12_240, [0, res13_241, 0]]]]]]]]]]]]]]]];
      case 29:
       var
        arg14_256 = param[15],
        arg13_255 = param[14],
        arg12_254 = param[13],
        arg11_253 = param[12],
        arg10_252 = param[11],
        arg9_251 = param[10],
        arg8_250 = param[9],
        arg7_249 = param[8],
        arg6_248 = param[7],
        arg5_247 = param[6],
        arg4_246 = param[5],
        arg3_245 = param[4],
        arg2_244 = param[3],
        arg1_243 = param[2],
        _d9_ = function(_eD_){return 0;},
        res0_257 = caml_call1(Sexplib0_Sexp_conv[24], _d9_),
        _d__ = function(param){return _bl_;},
        res1_258 = caml_call2(Incremental_Types[15][1], _d__, arg1_243),
        _d$_ = function(param){return _bm_;},
        res2_259 = caml_call2(Incremental_Types[15][1], _d$_, arg2_244),
        _ea_ = function(param){return _bn_;},
        res3_260 = caml_call2(Incremental_Types[15][1], _ea_, arg3_245),
        _eb_ = function(param){return _bo_;},
        res4_261 = caml_call2(Incremental_Types[15][1], _eb_, arg4_246),
        _ec_ = function(param){return _bp_;},
        res5_262 = caml_call2(Incremental_Types[15][1], _ec_, arg5_247),
        _ed_ = function(param){return _bq_;},
        res6_263 = caml_call2(Incremental_Types[15][1], _ed_, arg6_248),
        _ee_ = function(param){return _br_;},
        res7_264 = caml_call2(Incremental_Types[15][1], _ee_, arg7_249),
        _ef_ = function(param){return _bs_;},
        res8_265 = caml_call2(Incremental_Types[15][1], _ef_, arg8_250),
        _eg_ = function(param){return _bt_;},
        res9_266 = caml_call2(Incremental_Types[15][1], _eg_, arg9_251),
        _eh_ = function(param){return _bu_;},
        res10_267 = caml_call2(Incremental_Types[15][1], _eh_, arg10_252),
        _ei_ = function(param){return _bv_;},
        res11_268 = caml_call2(Incremental_Types[15][1], _ei_, arg11_253),
        _ej_ = function(param){return _bw_;},
        res12_269 = caml_call2(Incremental_Types[15][1], _ej_, arg12_254),
        _ek_ = function(param){return _bx_;},
        res13_270 = caml_call2(Incremental_Types[15][1], _ek_, arg13_255),
        _el_ = function(param){return _by_;},
        res14_271 = caml_call2(Incremental_Types[15][1], _el_, arg14_256);
       return [1,
               [0,
                _bz_,
                [0,
                 res0_257,
                 [0,
                  res1_258,
                  [0,
                   res2_259,
                   [0,
                    res3_260,
                    [0,
                     res4_261,
                     [0,
                      res5_262,
                      [0,
                       res6_263,
                       [0,
                        res7_264,
                        [0,
                         res8_265,
                         [0,
                          res9_266,
                          [0,
                           res10_267,
                           [0,
                            res11_268,
                            [0, res12_269, [0, res13_270, [0, res14_271, 0]]]]]]]]]]]]]]]]];
      default:
       var
        arg15_287 = param[16],
        arg14_286 = param[15],
        arg13_285 = param[14],
        arg12_284 = param[13],
        arg11_283 = param[12],
        arg10_282 = param[11],
        arg9_281 = param[10],
        arg8_280 = param[9],
        arg7_279 = param[8],
        arg6_278 = param[7],
        arg5_277 = param[6],
        arg4_276 = param[5],
        arg3_275 = param[4],
        arg2_274 = param[3],
        arg1_273 = param[2],
        _em_ = function(_eC_){return 0;},
        res0_288 = caml_call1(Sexplib0_Sexp_conv[24], _em_),
        _en_ = function(param){return _bA_;},
        res1_289 = caml_call2(Incremental_Types[15][1], _en_, arg1_273),
        _eo_ = function(param){return _bB_;},
        res2_290 = caml_call2(Incremental_Types[15][1], _eo_, arg2_274),
        _ep_ = function(param){return _bC_;},
        res3_291 = caml_call2(Incremental_Types[15][1], _ep_, arg3_275),
        _eq_ = function(param){return _bD_;},
        res4_292 = caml_call2(Incremental_Types[15][1], _eq_, arg4_276),
        _er_ = function(param){return _bE_;},
        res5_293 = caml_call2(Incremental_Types[15][1], _er_, arg5_277),
        _es_ = function(param){return _bF_;},
        res6_294 = caml_call2(Incremental_Types[15][1], _es_, arg6_278),
        _et_ = function(param){return _bG_;},
        res7_295 = caml_call2(Incremental_Types[15][1], _et_, arg7_279),
        _eu_ = function(param){return _bH_;},
        res8_296 = caml_call2(Incremental_Types[15][1], _eu_, arg8_280),
        _ev_ = function(param){return _bI_;},
        res9_297 = caml_call2(Incremental_Types[15][1], _ev_, arg9_281),
        _ew_ = function(param){return _bJ_;},
        res10_298 = caml_call2(Incremental_Types[15][1], _ew_, arg10_282),
        _ex_ = function(param){return _bK_;},
        res11_299 = caml_call2(Incremental_Types[15][1], _ex_, arg11_283),
        _ey_ = function(param){return _bL_;},
        res12_300 = caml_call2(Incremental_Types[15][1], _ey_, arg12_284),
        _ez_ = function(param){return _bM_;},
        res13_301 = caml_call2(Incremental_Types[15][1], _ez_, arg13_285),
        _eA_ = function(param){return _bN_;},
        res14_302 = caml_call2(Incremental_Types[15][1], _eA_, arg14_286),
        _eB_ = function(param){return _bO_;},
        res15_303 = caml_call2(Incremental_Types[15][1], _eB_, arg15_287);
       return [1,
               [0,
                _bP_,
                [0,
                 res0_288,
                 [0,
                  res1_289,
                  [0,
                   res2_290,
                   [0,
                    res3_291,
                    [0,
                     res4_292,
                     [0,
                      res5_293,
                      [0,
                       res6_294,
                       [0,
                        res7_295,
                        [0,
                         res8_296,
                         [0,
                          res9_297,
                          [0,
                           res10_298,
                           [0,
                            res11_299,
                            [0,
                             res12_300,
                             [0, res13_301, [0, res14_302, [0, res15_303, 0]]]]]]]]]]]]]]]]]];
    }
   }
   function name(param){
    if(typeof param === "number")
     return 0 === param ? cst_Invalid : cst_Uninitialized;
    switch(param[0]){
      case 0:
       return cst_Array_fold;
      case 1:
       return cst_At;
      case 2:
       return cst_At_intervals;
      case 3:
       return cst_Bind_lhs_change;
      case 4:
       return cst_Bind_main;
      case 5:
       return cst_Const;
      case 6:
       return cst_Expert;
      case 7:
       return cst_Freeze;
      case 8:
       return cst_If_test_change;
      case 9:
       return cst_If_then_else;
      case 10:
       return cst_Join_lhs_change;
      case 11:
       return cst_Join_main;
      case 12:
       return cst_Map;
      case 13:
       return cst_Snapshot;
      case 14:
       return cst_Step_function;
      case 15:
       return cst_Unordered_array_fold;
      case 16:
       return cst_Var;
      case 17:
       return cst_Map2;
      case 18:
       return cst_Map3;
      case 19:
       return cst_Map4;
      case 20:
       return cst_Map5;
      case 21:
       return cst_Map6;
      case 22:
       return cst_Map7;
      case 23:
       return cst_Map8;
      case 24:
       return cst_Map9;
      case 25:
       return cst_Map10;
      case 26:
       return cst_Map11;
      case 27:
       return cst_Map12;
      case 28:
       return cst_Map13;
      case 29:
       return cst_Map14;
      default: return cst_Map15;
    }
   }
   function invariant(invariant_a, t){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var array_fold = t[1], _b__ = function(_cn_){return 0;};
       return caml_call3
               (Incremental_Array_fold[2], _b__, invariant_a, array_fold);
      case 1:
       var at = t[1]; return caml_call1(Incremental_At[1], at);
      case 2:
       var at_intervals = t[1];
       return caml_call1(Incremental_At_intervals[1], at_intervals);
      case 3:
       var
        bind = t[1],
        _b$_ = function(_cm_){return 0;},
        _ca_ = function(_cl_){return 0;};
       return caml_call3(Incremental_Bind[1], _ca_, _b$_, bind);
      case 4:
       var bind$0 = t[1], _cb_ = function(_ck_){return 0;};
       return caml_call3(Incremental_Bind[1], _cb_, invariant_a, bind$0);
      case 5:
       var a = t[1]; return caml_call1(invariant_a, a);
      case 6:
       var e = t[1]; return caml_call2(Incremental_Expert[1], invariant_a, e);
      case 7:
       var freeze = t[1];
       return caml_call2(Incremental_Freeze[1], invariant_a, freeze);
      case 8:
       var if_then_else = t[1], _cc_ = function(_cj_){return 0;};
       return caml_call2(Incremental_If_then_else[1], _cc_, if_then_else);
      case 9:
       var if_then_else$0 = t[1];
       return caml_call2
               (Incremental_If_then_else[1], invariant_a, if_then_else$0);
      case 10:
       var join = t[1], _cd_ = function(_ci_){return 0;};
       return caml_call2(Incremental_Join[1], _cd_, join);
      case 11:
       var join$0 = t[1];
       return caml_call2(Incremental_Join[1], invariant_a, join$0);
      case 13:
       var snapshot = t[1];
       return caml_call2(Incremental_Snapshot[1], invariant_a, snapshot);
      case 14:
       var step_function_node = t[1];
       return caml_call2
               (Incremental_Step_function_node[1],
                invariant_a,
                step_function_node);
      case 15:
       var unordered_array_fold = t[1], _ce_ = function(_ch_){return 0;};
       return caml_call3
               (Incremental_Unordered_array_fo[1],
                _ce_,
                invariant_a,
                unordered_array_fold);
      case 16:
       var var$0 = t[1], _cf_ = function(_cg_){return 0;};
       return caml_call2(Incremental_Var[1], _cf_, var$0);
      default: return 0;
    }
   }
   function initial_num_children(t){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var children = t[1][3]; return children.length - 1;
      case 1:
       return 0;
      case 2:
       return 0;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 0;
      case 6:
       return 0;
      case 7:
       return 1;
      case 8:
       return 1;
      case 9:
       return 2;
      case 10:
       return 1;
      case 11:
       return 2;
      case 12:
       return 1;
      case 13:
       return 0;
      case 14:
       return 1;
      case 15:
       var children$0 = t[1][6]; return children$0.length - 1;
      case 16:
       return 0;
      case 17:
       return 2;
      case 18:
       return 3;
      case 19:
       return 4;
      case 20:
       return 5;
      case 21:
       return 6;
      case 22:
       return 7;
      case 23:
       return 8;
      case 24:
       return 9;
      case 25:
       return 10;
      case 26:
       return 11;
      case 27:
       return 12;
      case 28:
       return 13;
      case 29:
       return 14;
      default: return 15;
    }
   }
   var
    bind_rhs_child_index = 1,
    freeze_child_index = 0,
    if_branch_child_index = 1,
    join_rhs_child_index = 1;
   function iteri_children(t, f){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var children = t[1][3], _bX_ = children.length - 1 - 1 | 0, _bW_ = 0;
       if(_bX_ >= 0){
        var i = _bW_;
        for(;;){
         caml_call2(f, i, children[1 + i]);
         var _bY_ = i + 1 | 0;
         if(_bX_ === i) break;
         var i = _bY_;
        }
       }
       return 0;
      case 1:
       return 0;
      case 2:
       return 0;
      case 3:
       var bind = t[1]; return caml_call2(f, 0, bind[3]);
      case 4:
       var match = t[1], lhs_change = match[4], rhs = match[5];
       caml_call2(f, 0, lhs_change);
       var _bZ_ = caml_call1(Incremental_Import[16][6], rhs);
       return _bZ_
               ? caml_call2(f, 1, caml_call1(Incremental_Import[16][11], rhs))
               : _bZ_;
      case 5:
       return 0;
      case 6:
       var
        match$0 = t[1],
        children$0 = match$0[3],
        num_children = match$0[4],
        _b1_ = num_children - 1 | 0,
        _b0_ = 0;
       if(_b1_ >= 0){
        var i$0 = _b0_;
        for(;;){
         var _b2_ = caml_call2(Incremental_Import[17][20], children$0, i$0);
         caml_call2(f, i$0, caml_call1(Incremental_Import[16][7], _b2_)[1]);
         var _b3_ = i$0 + 1 | 0;
         if(_b1_ === i$0) break;
         var i$0 = _b3_;
        }
       }
       return 0;
      case 7:
       var child = t[1][2]; return caml_call2(f, 0, child);
      case 8:
       var test = t[1][2]; return caml_call2(f, 0, test);
      case 9:
       var
        match$1 = t[1],
        test_change = match$1[3],
        current_branch = match$1[4];
       caml_call2(f, 0, test_change);
       var _b4_ = caml_call1(Incremental_Import[16][6], current_branch);
       return _b4_
               ? caml_call2
                 (f,
                  1,
                  caml_call1(Incremental_Import[16][11], current_branch))
               : _b4_;
      case 10:
       var lhs = t[1][2]; return caml_call2(f, 0, lhs);
      case 11:
       var match$2 = t[1], lhs_change$0 = match$2[3], rhs$0 = match$2[4];
       caml_call2(f, 0, lhs_change$0);
       var _b5_ = caml_call1(Incremental_Import[16][6], rhs$0);
       return _b5_
               ? caml_call2
                 (f, 1, caml_call1(Incremental_Import[16][11], rhs$0))
               : _b5_;
      case 12:
       var node0 = t[2]; return caml_call2(f, 0, node0);
      case 13:
       return 0;
      case 14:
       var
        child$0 = t[1][2],
        _b6_ = caml_call1(Incremental_Import[16][6], child$0);
       return _b6_
               ? caml_call2
                 (f, 0, caml_call1(Incremental_Import[16][11], child$0))
               : _b6_;
      case 15:
       var
        children$1 = t[1][6],
        _b8_ = children$1.length - 1 - 1 | 0,
        _b7_ = 0;
       if(_b8_ >= 0){
        var i$1 = _b7_;
        for(;;){
         caml_call2(f, i$1, children$1[1 + i$1]);
         var _b9_ = i$1 + 1 | 0;
         if(_b8_ === i$1) break;
         var i$1 = _b9_;
        }
       }
       return 0;
      case 16:
       return 0;
      case 17:
       var node1 = t[3], node0$0 = t[2];
       caml_call2(f, 0, node0$0);
       return caml_call2(f, 1, node1);
      case 18:
       var node2 = t[4], node1$0 = t[3], node0$1 = t[2];
       caml_call2(f, 0, node0$1);
       caml_call2(f, 1, node1$0);
       return caml_call2(f, 2, node2);
      case 19:
       var node3 = t[5], node2$0 = t[4], node1$1 = t[3], node0$2 = t[2];
       caml_call2(f, 0, node0$2);
       caml_call2(f, 1, node1$1);
       caml_call2(f, 2, node2$0);
       return caml_call2(f, 3, node3);
      case 20:
       var
        node4 = t[6],
        node3$0 = t[5],
        node2$1 = t[4],
        node1$2 = t[3],
        node0$3 = t[2];
       caml_call2(f, 0, node0$3);
       caml_call2(f, 1, node1$2);
       caml_call2(f, 2, node2$1);
       caml_call2(f, 3, node3$0);
       return caml_call2(f, 4, node4);
      case 21:
       var
        node5 = t[7],
        node4$0 = t[6],
        node3$1 = t[5],
        node2$2 = t[4],
        node1$3 = t[3],
        node0$4 = t[2];
       caml_call2(f, 0, node0$4);
       caml_call2(f, 1, node1$3);
       caml_call2(f, 2, node2$2);
       caml_call2(f, 3, node3$1);
       caml_call2(f, 4, node4$0);
       return caml_call2(f, 5, node5);
      case 22:
       var
        node6 = t[8],
        node5$0 = t[7],
        node4$1 = t[6],
        node3$2 = t[5],
        node2$3 = t[4],
        node1$4 = t[3],
        node0$5 = t[2];
       caml_call2(f, 0, node0$5);
       caml_call2(f, 1, node1$4);
       caml_call2(f, 2, node2$3);
       caml_call2(f, 3, node3$2);
       caml_call2(f, 4, node4$1);
       caml_call2(f, 5, node5$0);
       return caml_call2(f, 6, node6);
      case 23:
       var
        node7 = t[9],
        node6$0 = t[8],
        node5$1 = t[7],
        node4$2 = t[6],
        node3$3 = t[5],
        node2$4 = t[4],
        node1$5 = t[3],
        node0$6 = t[2];
       caml_call2(f, 0, node0$6);
       caml_call2(f, 1, node1$5);
       caml_call2(f, 2, node2$4);
       caml_call2(f, 3, node3$3);
       caml_call2(f, 4, node4$2);
       caml_call2(f, 5, node5$1);
       caml_call2(f, 6, node6$0);
       return caml_call2(f, 7, node7);
      case 24:
       var
        node8 = t[10],
        node7$0 = t[9],
        node6$1 = t[8],
        node5$2 = t[7],
        node4$3 = t[6],
        node3$4 = t[5],
        node2$5 = t[4],
        node1$6 = t[3],
        node0$7 = t[2];
       caml_call2(f, 0, node0$7);
       caml_call2(f, 1, node1$6);
       caml_call2(f, 2, node2$5);
       caml_call2(f, 3, node3$4);
       caml_call2(f, 4, node4$3);
       caml_call2(f, 5, node5$2);
       caml_call2(f, 6, node6$1);
       caml_call2(f, 7, node7$0);
       return caml_call2(f, 8, node8);
      case 25:
       var
        node9 = t[11],
        node8$0 = t[10],
        node7$1 = t[9],
        node6$2 = t[8],
        node5$3 = t[7],
        node4$4 = t[6],
        node3$5 = t[5],
        node2$6 = t[4],
        node1$7 = t[3],
        node0$8 = t[2];
       caml_call2(f, 0, node0$8);
       caml_call2(f, 1, node1$7);
       caml_call2(f, 2, node2$6);
       caml_call2(f, 3, node3$5);
       caml_call2(f, 4, node4$4);
       caml_call2(f, 5, node5$3);
       caml_call2(f, 6, node6$2);
       caml_call2(f, 7, node7$1);
       caml_call2(f, 8, node8$0);
       return caml_call2(f, 9, node9);
      case 26:
       var
        node10 = t[12],
        node9$0 = t[11],
        node8$1 = t[10],
        node7$2 = t[9],
        node6$3 = t[8],
        node5$4 = t[7],
        node4$5 = t[6],
        node3$6 = t[5],
        node2$7 = t[4],
        node1$8 = t[3],
        node0$9 = t[2];
       caml_call2(f, 0, node0$9);
       caml_call2(f, 1, node1$8);
       caml_call2(f, 2, node2$7);
       caml_call2(f, 3, node3$6);
       caml_call2(f, 4, node4$5);
       caml_call2(f, 5, node5$4);
       caml_call2(f, 6, node6$3);
       caml_call2(f, 7, node7$2);
       caml_call2(f, 8, node8$1);
       caml_call2(f, 9, node9$0);
       return caml_call2(f, 10, node10);
      case 27:
       var
        node11 = t[13],
        node10$0 = t[12],
        node9$1 = t[11],
        node8$2 = t[10],
        node7$3 = t[9],
        node6$4 = t[8],
        node5$5 = t[7],
        node4$6 = t[6],
        node3$7 = t[5],
        node2$8 = t[4],
        node1$9 = t[3],
        node0$10 = t[2];
       caml_call2(f, 0, node0$10);
       caml_call2(f, 1, node1$9);
       caml_call2(f, 2, node2$8);
       caml_call2(f, 3, node3$7);
       caml_call2(f, 4, node4$6);
       caml_call2(f, 5, node5$5);
       caml_call2(f, 6, node6$4);
       caml_call2(f, 7, node7$3);
       caml_call2(f, 8, node8$2);
       caml_call2(f, 9, node9$1);
       caml_call2(f, 10, node10$0);
       return caml_call2(f, 11, node11);
      case 28:
       var
        node12 = t[14],
        node11$0 = t[13],
        node10$1 = t[12],
        node9$2 = t[11],
        node8$3 = t[10],
        node7$4 = t[9],
        node6$5 = t[8],
        node5$6 = t[7],
        node4$7 = t[6],
        node3$8 = t[5],
        node2$9 = t[4],
        node1$10 = t[3],
        node0$11 = t[2];
       caml_call2(f, 0, node0$11);
       caml_call2(f, 1, node1$10);
       caml_call2(f, 2, node2$9);
       caml_call2(f, 3, node3$8);
       caml_call2(f, 4, node4$7);
       caml_call2(f, 5, node5$6);
       caml_call2(f, 6, node6$5);
       caml_call2(f, 7, node7$4);
       caml_call2(f, 8, node8$3);
       caml_call2(f, 9, node9$2);
       caml_call2(f, 10, node10$1);
       caml_call2(f, 11, node11$0);
       return caml_call2(f, 12, node12);
      case 29:
       var
        node13 = t[15],
        node12$0 = t[14],
        node11$1 = t[13],
        node10$2 = t[12],
        node9$3 = t[11],
        node8$4 = t[10],
        node7$5 = t[9],
        node6$6 = t[8],
        node5$7 = t[7],
        node4$8 = t[6],
        node3$9 = t[5],
        node2$10 = t[4],
        node1$11 = t[3],
        node0$12 = t[2];
       caml_call2(f, 0, node0$12);
       caml_call2(f, 1, node1$11);
       caml_call2(f, 2, node2$10);
       caml_call2(f, 3, node3$9);
       caml_call2(f, 4, node4$8);
       caml_call2(f, 5, node5$7);
       caml_call2(f, 6, node6$6);
       caml_call2(f, 7, node7$5);
       caml_call2(f, 8, node8$4);
       caml_call2(f, 9, node9$3);
       caml_call2(f, 10, node10$2);
       caml_call2(f, 11, node11$1);
       caml_call2(f, 12, node12$0);
       return caml_call2(f, 13, node13);
      default:
       var
        node14 = t[16],
        node13$0 = t[15],
        node12$1 = t[14],
        node11$2 = t[13],
        node10$3 = t[12],
        node9$4 = t[11],
        node8$5 = t[10],
        node7$6 = t[9],
        node6$7 = t[8],
        node5$8 = t[7],
        node4$9 = t[6],
        node3$10 = t[5],
        node2$11 = t[4],
        node1$12 = t[3],
        node0$13 = t[2];
       caml_call2(f, 0, node0$13);
       caml_call2(f, 1, node1$12);
       caml_call2(f, 2, node2$11);
       caml_call2(f, 3, node3$10);
       caml_call2(f, 4, node4$9);
       caml_call2(f, 5, node5$8);
       caml_call2(f, 6, node6$7);
       caml_call2(f, 7, node7$6);
       caml_call2(f, 8, node8$5);
       caml_call2(f, 9, node9$4);
       caml_call2(f, 10, node10$3);
       caml_call2(f, 11, node11$2);
       caml_call2(f, 12, node12$1);
       caml_call2(f, 13, node13$0);
       return caml_call2(f, 14, node14);
    }
   }
   function slow_get_child(t, index){
    if(typeof t !== "number")
     switch(t[0]){
       case 0:
        var children = t[1][3];
        return caml_check_bound(children, index)[1 + index];
       case 6:
        var
         children$0 = t[1][3],
         _bT_ = caml_call2(Incremental_Import[17][19], children$0, index);
        return caml_call1(Incremental_Import[16][7], _bT_)[1];
       case 15:
        var children$1 = t[1][6];
        return caml_check_bound(children$1, index)[1 + index];
     }
    function _bS_(r){
     iteri_children
      (t,
       function(i, child){
        var _bV_ = caml_call2(Incremental_Import[3], i, index);
        return _bV_ ? caml_call1(r, child) : _bV_;
       });
     function _bU_(param){
      var
       arg1_306 = param[2],
       arg0_305 = param[1],
       res0_307 = caml_call1(Core[356], arg0_305),
       res1_308 = sexp_of_t(function(param){return _bQ_;}, arg1_306);
      return [1, [0, res0_307, [0, res1_308, 0]]];
     }
     return caml_call5
             (Core[236],
              0,
              _bR_,
              cst_Kind_slow_get_child_got_in,
              [0, index, t],
              _bU_);
    }
    return caml_call1(Core[260], _bS_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Kind);
   var
    Incremental_Kind =
      [0,
       invariant,
       sexp_of_t,
       name,
       initial_num_children,
       slow_get_child,
       bind_rhs_child_index,
       freeze_child_index,
       if_branch_child_index,
       join_rhs_child_index,
       iteri_children];
   runtime.caml_register_global(223, Incremental_Kind, cst_Incremental_Kind$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Node
//# unitInfo: Requires: Assert_failure, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Hash_set, Core__Info, Core__Int, Core__List, Core__String, Expect_test_collector, Incremental__Bind, Incremental__Cutoff, Incremental__Dot_user_info, Incremental__Expert, Incremental__Import, Incremental__Kind, Incremental__Node_id, Incremental__On_update_handler, Incremental__Scope, Incremental__Stabilization_num, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "  ",
    cst_rankdir_BT = "  rankdir = BT\n",
    cst$1 = " -> ",
    cst_Incremental_Node$0 = "Incremental__Node",
    cst$2 = "_",
    cst_changed_at$0 = "changed_at",
    cst_created_in$0 = "created_in",
    cst_cutoff$0 = "cutoff",
    cst_digraph_G = "digraph G {\n",
    cst_height$0 = "height",
    cst_height_in_adjust_heights_h$0 = "height_in_adjust_heights_heap",
    cst_height_in_recompute_heap$0 = "height_in_recompute_heap",
    cst_id$0 = "id",
    cst_incremental$0 = "incremental",
    cst_kind$0 = "kind",
    cst_my_child_index_in_parent_a$0 = "my_child_index_in_parent_at_index",
    cst_my_parent_index_in_child_a$0 = "my_parent_index_in_child_at_index",
    cst_next_in_adjust_heights_hea$0 = "next_in_adjust_heights_heap",
    cst_next_in_recompute_heap$0 = "next_in_recompute_heap",
    cst_next_node_in_same_scope$0 = "next_node_in_same_scope",
    cst_num_on_update_handlers$0 = "num_on_update_handlers",
    cst_num_parents$0 = "num_parents",
    cst_observers$0 = "observers",
    cst_old_value_opt$0 = "old_value_opt",
    cst_parent0$0 = "parent0",
    cst_parent1_and_beyond$0 = "parent1_and_beyond",
    cst_prev_in_recompute_heap$0 = "prev_in_recompute_heap",
    cst_recomputed_at$0 = "recomputed_at",
    cst_src_node_ml = "src/node.ml",
    cst_value_opt$0 = "value_opt",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$4 = "src/node.ml:331:27",
    pos$3 = "src/node.ml:343:24",
    pos$2 = "src/node.ml:350:22",
    pos$1 = "src/node.ml:411:29",
    pos$0 = "src/node.ml:429:26",
    pos = "src/node.ml:293:15",
    cst = "",
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Core_Hash_set = global_data.Core__Hash_set,
    Core = global_data.Core,
    Incremental_Bind = global_data.Incremental__Bind,
    Incremental_Node_id = global_data.Incremental__Node_id,
    Core_List = global_data.Core__List,
    Core_String = global_data.Core__String,
    Incremental_Kind = global_data.Incremental__Kind,
    Incremental_Dot_user_info = global_data.Incremental__Dot_user_info,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Base_Backtrace = global_data.Base__Backtrace,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Incremental_Scope = global_data.Incremental__Scope,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Incremental_Expert = global_data.Incremental__Expert,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Node$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_node_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _bk_ =
      [0,
       [11, cst$0, [2, 0, [11, cst$1, [2, 0, [11, " [style=dashed]\n", 0]]]]],
       "  %s -> %s [style=dashed]\n"],
    _bj_ =
      [0,
       [11, cst$0, [2, 0, [11, cst$1, [2, 0, [12, 10, 0]]]]],
       "  %s -> %s\n"],
    cst_n$0 = "n",
    cst_n = "n###",
    _bh_ = [0, [11, cst_digraph_G, 0], cst_digraph_G],
    _bi_ = [0, [11, cst_rankdir_BT, 0], cst_rankdir_BT],
    _bl_ = [0, [11, "}\n", [10, 0]], "}\n%!"],
    _bg_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _bf_ = [0, [11, "height=", [4, 0, 0, 0, 0]], "height=%d"],
    _be_ = [0, cst$2],
    _bd_ = [0, cst_src_node_ml, 629, 4],
    _bc_ = [0, cst_src_node_ml, 630, 4],
    _bb_ = [0, cst_src_node_ml, 639, 4],
    _ba_ = [0, cst_src_node_ml, 641, 4],
    _a$_ = [0, cst_src_node_ml, 608, 16],
    _a__ = [0, cst_src_node_ml, 610, 16],
    _a9_ = [0, cst_src_node_ml, 564, 18],
    _a8_ = [0, cst_src_node_ml, 568, 16],
    _a7_ = [0, cst_src_node_ml, 557, 16],
    _a6_ = [0, cst_src_node_ml, 473, 12],
    _a4_ = [0, cst_src_node_ml, 492, 33],
    _a5_ = [0, cst_src_node_ml, 485, 14],
    _a2_ = [0, cst$2],
    cst_attempt_to_get_value_of_an = "attempt to get value of an invalid node",
    _a3_ = [0, cst_src_node_ml, 452, 18787, 18810],
    _a0_ = [0, cst$2],
    _aY_ = [0, cst_src_node_ml, 312, 50],
    _aX_ = [0, cst_src_node_ml, 328, 16],
    _aW_ = [0, cst_src_node_ml, 338, 11],
    _aV_ = [0, cst_src_node_ml, 339, 11],
    _aU_ = [0, cst_src_node_ml, 355, 16],
    _aS_ = [0, cst_src_node_ml, 358, 34],
    _aT_ = [0, cst_src_node_ml, 358, 60],
    _aR_ = [0, cst_src_node_ml, 361, 11],
    _aQ_ = [0, cst_src_node_ml, 362, 11],
    _aP_ = [0, cst_src_node_ml, 366, 16],
    _aO_ = [0, cst_src_node_ml, 370, 13],
    _aN_ = [0, cst_src_node_ml, 371, 13],
    _aM_ = [0, cst_src_node_ml, 375, 16],
    _aL_ = [0, cst_src_node_ml, 379, 13],
    _aK_ = [0, cst_src_node_ml, 380, 13],
    _aJ_ = [0, cst_src_node_ml, 384, 16],
    _aI_ = [0, cst_src_node_ml, 388, 16],
    _aH_ = [0, cst_src_node_ml, 392, 13],
    _aG_ = [0, cst_src_node_ml, 393, 13],
    _aF_ = [0, cst_src_node_ml, 399, 13],
    _aE_ = [0, cst_src_node_ml, 402, 37],
    _aD_ = [0, cst_src_node_ml, 426, 15],
    _aC_ = [0, cst_src_node_ml, 417, 15],
    _aB_ = [0, cst_src_node_ml, 442, 15],
    _aA_ = [0, cst_src_node_ml, 433, 13],
    _az_ = [0, cst_src_node_ml, 302, 6],
    _ay_ = [0, cst_src_node_ml, 303, 6],
    _ax_ = [0, cst_src_node_ml, 304, 6],
    _av_ = [0, cst_src_node_ml, 298, 8],
    _au_ = [0, cst_src_node_ml, 299, 8],
    _aZ_ = [0, cst_src_node_ml, 296, 6],
    _aw_ = [0, cst_src_node_ml, 300, 6],
    _a1_ = [0, cst_src_node_ml, 292, 11852, 11874],
    _at_ = [0, cst_src_node_ml, 235, 21],
    _as_ = [0, cst_src_node_ml, 145, 21],
    _S_ = [0, "creation_backtrace"],
    _T_ = [0, "user_info"],
    _U_ = [0, "force_necessary"],
    _V_ = [0, cst_my_child_index_in_parent_a$0],
    _W_ = [0, cst_my_parent_index_in_child_a$0],
    _X_ = [0, "on_update_handlers"],
    _Y_ = [0, "is_in_handle_after_stabilization"],
    _Z_ = [0, cst_observers$0],
    ___ = [0, cst_old_value_opt$0],
    _$_ = [0, cst_next_in_adjust_heights_hea$0],
    _aa_ = [0, cst_height_in_adjust_heights_h$0],
    _ab_ = [0, cst_next_in_recompute_heap$0],
    _ac_ = [0, cst_prev_in_recompute_heap$0],
    _ad_ = [0, cst_height_in_recompute_heap$0],
    _ae_ = [0, cst_height$0],
    _af_ = [0, cst_next_node_in_same_scope$0],
    _ag_ = [0, cst_created_in$0],
    _ah_ = [0, cst_parent0$0],
    _ai_ = [0, cst_parent1_and_beyond$0],
    _aj_ = [0, cst_num_parents$0],
    _ak_ = [0, cst_num_on_update_handlers$0],
    _al_ = [0, cst_changed_at$0],
    _am_ = [0, cst_cutoff$0],
    _an_ = [0, cst_kind$0],
    _ao_ = [0, cst_value_opt$0],
    _ap_ = [0, cst_recomputed_at$0],
    _aq_ = [0, "state"],
    _ar_ = [0, cst_id$0],
    cst_my_child_index_in_parent_a = cst_my_child_index_in_parent_a$0,
    cst_my_parent_index_in_child_a = cst_my_parent_index_in_child_a$0,
    cst_observers = cst_observers$0,
    cst_old_value_opt = cst_old_value_opt$0,
    cst_next_in_adjust_heights_hea = cst_next_in_adjust_heights_hea$0,
    cst_height_in_adjust_heights_h = cst_height_in_adjust_heights_h$0,
    cst_next_in_recompute_heap = cst_next_in_recompute_heap$0,
    cst_prev_in_recompute_heap = cst_prev_in_recompute_heap$0,
    cst_height_in_recompute_heap = cst_height_in_recompute_heap$0,
    cst_height = cst_height$0,
    cst_next_node_in_same_scope = cst_next_node_in_same_scope$0,
    cst_created_in = cst_created_in$0,
    cst_parent0 = cst_parent0$0,
    cst_parent1_and_beyond = cst_parent1_and_beyond$0,
    cst_num_parents = cst_num_parents$0,
    cst_num_on_update_handlers = cst_num_on_update_handlers$0,
    cst_changed_at = cst_changed_at$0,
    cst_cutoff = cst_cutoff$0,
    cst_kind = cst_kind$0,
    cst_value_opt = cst_value_opt$0,
    cst_recomputed_at = cst_recomputed_at$0,
    cst_id = cst_id$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Node = cst_Incremental_Node$0;
   function my_child_index_in_parent_at_in(r){return r[25];}
   function set_my_child_index_in_parent_a(r, v){r[25] = v; return 0;}
   function my_parent_index_in_child_at_in(r){return r[24];}
   function set_my_parent_index_in_child_a(r, v){r[24] = v; return 0;}
   function observers(r){return r[21];}
   function set_observers(r, v){r[21] = v; return 0;}
   function old_value_opt(r){return r[20];}
   function set_old_value_opt(r, v){r[20] = v; return 0;}
   function next_in_adjust_heights_heap(r){return r[19];}
   function set_next_in_adjust_heights_hea(r, v){r[19] = v; return 0;}
   function height_in_adjust_heights_heap(r){return r[18];}
   function set_height_in_adjust_heights_h(r, v){r[18] = v; return 0;}
   function next_in_recompute_heap(r){return r[17];}
   function set_next_in_recompute_heap(r, v){r[17] = v; return 0;}
   function prev_in_recompute_heap(r){return r[16];}
   function set_prev_in_recompute_heap(r, v){r[16] = v; return 0;}
   function height_in_recompute_heap(r){return r[15];}
   function set_height_in_recompute_heap(r, v){r[15] = v; return 0;}
   function height(r){return r[14];}
   function set_height(r, v){r[14] = v; return 0;}
   function next_node_in_same_scope(r){return r[13];}
   function set_next_node_in_same_scope(r, v){r[13] = v; return 0;}
   function created_in(r){return r[12];}
   function set_created_in(r, v){r[12] = v; return 0;}
   function parent0(r){return r[11];}
   function set_parent0(r, v){r[11] = v; return 0;}
   function parent1_and_beyond(r){return r[10];}
   function set_parent1_and_beyond(r, v){r[10] = v; return 0;}
   function num_parents(r){return r[9];}
   function set_num_parents(r, v){r[9] = v; return 0;}
   function num_on_update_handlers(r){return r[8];}
   function set_num_on_update_handlers(r, v){r[8] = v; return 0;}
   function changed_at(r){return r[7];}
   function set_changed_at(r, v){r[7] = v; return 0;}
   function cutoff(r){return r[6];}
   function set_cutoff(r, v){r[6] = v; return 0;}
   function kind(r){return r[5];}
   function set_kind(r, v){r[5] = v; return 0;}
   function value_opt(r){return r[4];}
   function set_value_opt(r, v){r[4] = v; return 0;}
   function recomputed_at(r){return r[3];}
   function set_recomputed_at(r, v){r[3] = v; return 0;}
   function id(r){return r[1];}
   function _a_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27],
            r[28]];
   }
   var
    _b_ = [0, set_my_child_index_in_parent_a],
    my_child_index_in_parent_at_in$0 =
      [0,
       function(param){return 0;},
       cst_my_child_index_in_parent_a,
       _b_,
       my_child_index_in_parent_at_in,
       _a_];
   function _c_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _d_ = [0, set_my_parent_index_in_child_a],
    my_parent_index_in_child_at_in$0 =
      [0,
       function(param){return 0;},
       cst_my_parent_index_in_child_a,
       _d_,
       my_parent_index_in_child_at_in,
       _c_];
   function _e_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _f_ = [0, set_observers],
    observers$0 =
      [0, function(param){return 0;}, cst_observers, _f_, observers, _e_];
   function _g_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _h_ = [0, set_old_value_opt],
    old_value_opt$0 =
      [0,
       function(param){return 0;},
       cst_old_value_opt,
       _h_,
       old_value_opt,
       _g_];
   function _i_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _j_ = [0, set_next_in_adjust_heights_hea],
    next_in_adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_next_in_adjust_heights_hea,
       _j_,
       next_in_adjust_heights_heap,
       _i_];
   function _k_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _l_ = [0, set_height_in_adjust_heights_h],
    height_in_adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_height_in_adjust_heights_h,
       _l_,
       height_in_adjust_heights_heap,
       _k_];
   function _m_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _n_ = [0, set_next_in_recompute_heap],
    next_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_next_in_recompute_heap,
       _n_,
       next_in_recompute_heap,
       _m_];
   function _o_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _p_ = [0, set_prev_in_recompute_heap],
    prev_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_prev_in_recompute_heap,
       _p_,
       prev_in_recompute_heap,
       _o_];
   function _q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _r_ = [0, set_height_in_recompute_heap],
    height_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_height_in_recompute_heap,
       _r_,
       height_in_recompute_heap,
       _q_];
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _t_ = [0, set_height],
    height$0 = [0, function(param){return 0;}, cst_height, _t_, height, _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _v_ = [0, set_next_node_in_same_scope],
    next_node_in_same_scope$0 =
      [0,
       function(param){return 0;},
       cst_next_node_in_same_scope,
       _v_,
       next_node_in_same_scope,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _x_ = [0, set_created_in],
    created_in$0 =
      [0, function(param){return 0;}, cst_created_in, _x_, created_in, _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _z_ = [0, set_parent0],
    parent0$0 =
      [0, function(param){return 0;}, cst_parent0, _z_, parent0, _y_];
   function _A_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _B_ = [0, set_parent1_and_beyond],
    parent1_and_beyond$0 =
      [0,
       function(param){return 0;},
       cst_parent1_and_beyond,
       _B_,
       parent1_and_beyond,
       _A_];
   function _C_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _D_ = [0, set_num_parents],
    num_parents$0 =
      [0, function(param){return 0;}, cst_num_parents, _D_, num_parents, _C_];
   function _E_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _F_ = [0, set_num_on_update_handlers],
    num_on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_num_on_update_handlers,
       _F_,
       num_on_update_handlers,
       _E_];
   function _G_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _H_ = [0, set_changed_at],
    changed_at$0 =
      [0, function(param){return 0;}, cst_changed_at, _H_, changed_at, _G_];
   function _I_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _J_ = [0, set_cutoff],
    cutoff$0 = [0, function(param){return 0;}, cst_cutoff, _J_, cutoff, _I_];
   function _K_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _L_ = [0, set_kind],
    kind$0 = [0, function(param){return 0;}, cst_kind, _L_, kind, _K_];
   function _M_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _N_ = [0, set_value_opt],
    value_opt$0 =
      [0, function(param){return 0;}, cst_value_opt, _N_, value_opt, _M_];
   function _O_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _P_ = [0, set_recomputed_at],
    recomputed_at$0 =
      [0,
       function(param){return 0;},
       cst_recomputed_at,
       _P_,
       recomputed_at,
       _O_];
   function _Q_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var _R_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _R_, id, _Q_];
   function sexp_of_t(of_a_001, param){
    var
     state_005 = param[2],
     id_003 = param[1],
     recomputed_at_007 = param[3],
     value_opt_009 = param[4],
     kind_011 = param[5],
     cutoff_013 = param[6],
     changed_at_015 = param[7],
     num_on_update_handlers_017 = param[8],
     num_parents_019 = param[9],
     parent1_and_beyond_021 = param[10],
     parent0_023 = param[11],
     created_in_025 = param[12],
     next_node_in_same_scope_027 = param[13],
     height_029 = param[14],
     height_in_recompute_heap_031 = param[15],
     prev_in_recompute_heap_033 = param[16],
     next_in_recompute_heap_035 = param[17],
     height_in_adjust_heights_heap_ = param[18],
     next_in_adjust_heights_heap_03 = param[19],
     old_value_opt_041 = param[20],
     observers_043 = param[21],
     is_in_handle_after_stabilizati = param[22],
     on_update_handlers_047 = param[23],
     my_parent_index_in_child_at_in = param[24],
     my_child_index_in_parent_at_in = param[25],
     force_necessary_053 = param[26],
     user_info_055 = param[27],
     creation_backtrace_057 = param[28],
     arg_058 =
       caml_call2(Core[454], Base_Backtrace[1], creation_backtrace_057),
     bnds_002 = [0, [1, [0, _S_, [0, arg_058, 0]]], 0],
     arg_056 =
       caml_call2(Core[454], Incremental_Dot_user_info[3], user_info_055),
     bnds_002$0 = [0, [1, [0, _T_, [0, arg_056, 0]]], bnds_002],
     arg_054 = caml_call1(Core[305], force_necessary_053),
     bnds_002$1 = [0, [1, [0, _U_, [0, arg_054, 0]]], bnds_002$0],
     arg_052 =
       caml_call2(Core[288], Core[356], my_child_index_in_parent_at_in),
     bnds_002$2 = [0, [1, [0, _V_, [0, arg_052, 0]]], bnds_002$1],
     arg_050 =
       caml_call2(Core[288], Core[356], my_parent_index_in_child_at_in),
     bnds_002$3 = [0, [1, [0, _W_, [0, arg_050, 0]]], bnds_002$2],
     _cS_ = caml_call1(Incremental_On_update_handler[2], of_a_001),
     arg_048 = caml_call2(Core[421], _cS_, on_update_handlers_047),
     bnds_002$4 = [0, [1, [0, _X_, [0, arg_048, 0]]], bnds_002$3],
     arg_046 = caml_call1(Core[305], is_in_handle_after_stabilizati),
     bnds_002$5 = [0, [1, [0, _Y_, [0, arg_046, 0]]], bnds_002$4],
     arg_044 =
       caml_call2
        (Incremental_Import[16][1], Sexplib0_Sexp_conv[23], observers_043),
     bnds_002$6 = [0, [1, [0, _Z_, [0, arg_044, 0]]], bnds_002$5],
     arg_042 =
       caml_call2(Incremental_Import[16][1], of_a_001, old_value_opt_041),
     bnds_002$7 = [0, [1, [0, ___, [0, arg_042, 0]]], bnds_002$6],
     arg_040 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Types[15][2][1],
         next_in_adjust_heights_heap_03),
     bnds_002$8 = [0, [1, [0, _$_, [0, arg_040, 0]]], bnds_002$7],
     arg_038 = caml_call1(Core[356], height_in_adjust_heights_heap_),
     bnds_002$9 = [0, [1, [0, _aa_, [0, arg_038, 0]]], bnds_002$8],
     arg_036 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Types[15][2][1],
         next_in_recompute_heap_035),
     bnds_002$10 = [0, [1, [0, _ab_, [0, arg_036, 0]]], bnds_002$9],
     arg_034 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Types[15][2][1],
         prev_in_recompute_heap_033),
     bnds_002$11 = [0, [1, [0, _ac_, [0, arg_034, 0]]], bnds_002$10],
     arg_032 = caml_call1(Core[356], height_in_recompute_heap_031),
     bnds_002$12 = [0, [1, [0, _ad_, [0, arg_032, 0]]], bnds_002$11],
     arg_030 = caml_call1(Core[356], height_029),
     bnds_002$13 = [0, [1, [0, _ae_, [0, arg_030, 0]]], bnds_002$12],
     arg_028 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Types[15][2][1],
         next_node_in_same_scope_027),
     bnds_002$14 = [0, [1, [0, _af_, [0, arg_028, 0]]], bnds_002$13],
     arg_026 = caml_call1(Incremental_Scope[1], created_in_025),
     bnds_002$15 = [0, [1, [0, _ag_, [0, arg_026, 0]]], bnds_002$14],
     arg_024 =
       caml_call2
        (Incremental_Import[16][1], Incremental_Types[15][2][1], parent0_023),
     bnds_002$16 = [0, [1, [0, _ah_, [0, arg_024, 0]]], bnds_002$15],
     _cT_ = caml_call1(Incremental_Import[16][1], Incremental_Types[15][2][1]),
     arg_022 =
       caml_call2(Incremental_Import[17][10], _cT_, parent1_and_beyond_021),
     bnds_002$17 = [0, [1, [0, _ai_, [0, arg_022, 0]]], bnds_002$16],
     arg_020 = caml_call1(Core[356], num_parents_019),
     bnds_002$18 = [0, [1, [0, _aj_, [0, arg_020, 0]]], bnds_002$17],
     arg_018 = caml_call1(Core[356], num_on_update_handlers_017),
     bnds_002$19 = [0, [1, [0, _ak_, [0, arg_018, 0]]], bnds_002$18],
     arg_016 = caml_call1(Incremental_Stabilization_num[2], changed_at_015),
     bnds_002$20 = [0, [1, [0, _al_, [0, arg_016, 0]]], bnds_002$19],
     arg_014 = caml_call2(Incremental_Cutoff[1], of_a_001, cutoff_013),
     bnds_002$21 = [0, [1, [0, _am_, [0, arg_014, 0]]], bnds_002$20],
     arg_012 = caml_call2(Incremental_Kind[2], of_a_001, kind_011),
     bnds_002$22 = [0, [1, [0, _an_, [0, arg_012, 0]]], bnds_002$21],
     arg_010 = caml_call2(Incremental_Import[16][1], of_a_001, value_opt_009),
     bnds_002$23 = [0, [1, [0, _ao_, [0, arg_010, 0]]], bnds_002$22],
     arg_008 = caml_call1(Incremental_Stabilization_num[2], recomputed_at_007),
     bnds_002$24 = [0, [1, [0, _ap_, [0, arg_008, 0]]], bnds_002$23],
     arg_006 = caml_call1(Sexplib0_Sexp_conv[23], state_005),
     bnds_002$25 = [0, [1, [0, _aq_, [0, arg_006, 0]]], bnds_002$24],
     arg_004 = caml_call1(Incremental_Node_id[1], id_003),
     bnds_002$26 = [0, [1, [0, _ar_, [0, arg_004, 0]]], bnds_002$25];
    return [1, bnds_002$26];
   }
   function same(t1, t2){return caml_call2(Core[247], t1, t2);}
   function packed_same(param, t2){return same(param, t2);}
   var is_necessary = Incremental_Types[15][4];
   function iteri_children(t, f){
    return caml_call2(Incremental_Kind[10], t[5], f);
   }
   var
    is_valid = Incremental_Types[15][3],
    type_equal_if_phys_same = Incremental_Types[15][5];
   function user_info(t){
    var _cQ_ = t[27];
    if(! _cQ_) return 0;
    var other = _cQ_[1];
    if(1 === other[0]){var i = other[1]; return [0, i];}
    var _cR_ = caml_call1(Incremental_Dot_user_info[3], other);
    return [0, caml_call1(Core_Info[18], _cR_)];
   }
   function set_user_info(t, info){
    if(info) var i = info[1], _cP_ = [0, [1, i]]; else var _cP_ = 0;
    t[27] = _cP_;
    return 0;
   }
   function append_user_info_graphviz(t, label, attrs){
    var
     new$0 = caml_call2(Incremental_Dot_user_info[5], label, attrs),
     match = t[27];
    if(match)
     var
      other = match[1],
      _cO_ = [0, caml_call2(Incremental_Dot_user_info[7], other, new$0)];
    else
     var _cO_ = [0, new$0];
    t[27] = _cO_;
    return 0;
   }
   function edge_is_stale(child, parent){
    var
     _cN_ = caml_call2(Incremental_Stabilization_num[1], child[7], parent[3]);
    return caml_call2(Incremental_Import[4], _cN_, 0);
   }
   function is_stale_with_respect_to_a_chi(t){
    var is_stale = [0, 0];
    iteri_children
     (t,
      function(param, child){
       var
        _cL_ = edge_is_stale(child, t),
        _cM_ = _cL_ ? (is_stale[1] = 1, 0) : _cL_;
       return _cM_;
      });
    return is_stale[1];
   }
   function is_stale(t){
    var _cE_ = t[5];
    if(typeof _cE_ === "number"){
     if(0 === _cE_) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
    }
    switch(_cE_[0]){
      case 1:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 2:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 3:
       var _cG_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cG_ ? _cG_ : is_stale_with_respect_to_a_chi(t);
      case 5:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 6:
       var force_stale = _cE_[1][5];
       if(force_stale)
        var force_stale$0 = force_stale;
       else{
        var _cH_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
        if(! _cH_) return is_stale_with_respect_to_a_chi(t);
        var force_stale$0 = _cH_;
       }
       return force_stale$0;
      case 8:
       var _cI_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cI_ ? _cI_ : is_stale_with_respect_to_a_chi(t);
      case 10:
       var _cJ_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cJ_ ? _cJ_ : is_stale_with_respect_to_a_chi(t);
      case 13:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 16:
       var
        set_at = _cE_[1][3],
        _cK_ = caml_call2(Incremental_Stabilization_num[1], set_at, t[3]);
       return caml_call2(Incremental_Import[4], _cK_, 0);
      default:
       var _cF_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cF_ ? _cF_ : is_stale_with_respect_to_a_chi(t);
    }
   }
   function needs_to_be_computed(t){
    var _cD_ = caml_call1(is_necessary, t);
    return _cD_ ? is_stale(t) : _cD_;
   }
   function is_in_recompute_heap(t){
    return caml_call2(Incremental_Import[1], t[15], 0);
   }
   function is_in_adjust_heights_heap(t){
    return caml_call2(Incremental_Import[1], t[18], 0);
   }
   function get_parent(t, index){
    var
     _cC_ =
       caml_call2(Incremental_Import[3], index, 0)
        ? t[11]
        : caml_call2(Incremental_Import[17][19], t[10], index - 1 | 0);
    return caml_call1(Incremental_Import[16][7], _cC_);
   }
   function iteri_parents(t, f){
    if(caml_call2(Incremental_Import[4], t[9], 0)){
     caml_call2(f, 0, caml_call1(Incremental_Import[16][7], t[11]));
     var _cz_ = t[9] - 1 | 0, _cy_ = 1;
     if(_cz_ >= 1){
      var index = _cy_;
      for(;;){
       var
        _cA_ = caml_call2(Incremental_Import[17][19], t[10], index - 1 | 0);
       caml_call2(f, index, caml_call1(Incremental_Import[16][7], _cA_));
       var _cB_ = index + 1 | 0;
       if(_cz_ === index) break;
       var index = _cB_;
      }
     }
    }
    return;
   }
   function has_child(t, child){
    var has = [0, 0];
    iteri_children
     (t,
      function(param, child$0){
       var _cw_ = has[1], _cx_ = _cw_ || same(child, child$0);
       has[1] = _cx_;
       return 0;
      });
    return has[1];
   }
   function has_parent(t, parent){
    var has = [0, 0];
    iteri_parents
     (t,
      function(param, parent$0){
       var _cu_ = has[1], _cv_ = _cu_ || same(parent, parent$0);
       has[1] = _cv_;
       return 0;
      });
    return has[1];
   }
   function should_be_invalidated(t){
    var _cr_ = t[5];
    if(typeof _cr_ !== "number")
     switch(_cr_[0]){
       case 1:
        return 0;
       case 2:
        return 0;
       case 3:
        var lhs = _cr_[1][3]; return 1 - caml_call1(is_valid, lhs);
       case 4:
        var lhs_change = _cr_[1][4];
        return 1 - caml_call1(is_valid, lhs_change);
       case 6:
        return 0;
       case 8:
        var test = _cr_[1][2]; return 1 - caml_call1(is_valid, test);
       case 9:
        var test_change = _cr_[1][3];
        return 1 - caml_call1(is_valid, test_change);
       case 10:
        var lhs$0 = _cr_[1][2]; return 1 - caml_call1(is_valid, lhs$0);
       case 11:
        var lhs_change$0 = _cr_[1][3];
        return 1 - caml_call1(is_valid, lhs_change$0);
       case 5:
       case 13:
       case 16:
        return 0;
       default:
        var has = [0, 0];
        iteri_children
         (t,
          function(param, child){
           var _cs_ = has[1], _ct_ = _cs_ || 1 - caml_call1(is_valid, child);
           has[1] = _ct_;
           return 0;
          });
        return has[1];
     }
    if(0 === _cr_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _at_], 1);
   }
   function fold_observers(t, init, f){
    var r = [0, t[21]], ac = [0, init];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r[1])) return ac[1];
     var observer = caml_call1(Incremental_Import[16][7], r[1]);
     r[1] = observer[7];
     ac[1] = caml_call2(f, ac[1], observer);
    }
   }
   function invariant(invariant_a, t){
    function _b1_(param){
     var
      t2 = is_in_recompute_heap(t),
      t1 = needs_to_be_computed(t),
      sexpifier = Core[305],
      equal = 0,
      message = 0,
      here = 0;
     function comparator(a_060, b_061){
      return caml_call2(Core[301], a_060, b_061);
     }
     caml_call8
      (Ppx_assert_lib_Runtime[2],
       pos,
       sexpifier,
       comparator,
       here,
       message,
       equal,
       t1,
       t2);
     if(caml_call1(is_necessary, t)){
      var _b3_ = caml_call1(Incremental_Scope[5], t[12]);
      if(! caml_call2(Incremental_Import[4], t[14], _b3_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aZ_], 1);
      iteri_children
       (t,
        function(param, child){
         if(! caml_call2(Incremental_Import[4], t[14], child[14]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
         if(has_parent(child, t)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
        });
      if(should_be_invalidated(t))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aw_], 1);
     }
     iteri_parents
      (t,
       function(param, parent){
        if(! has_child(parent, t))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _az_], 1);
        if(! caml_call1(is_necessary, parent))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ay_], 1);
        if(caml_call2(Incremental_Import[5], t[14], parent[14])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _ax_], 1);
       });
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      my_child_index_in_parent_at_in =
        check
         (function(my_child_index_in_parent_at_in){
           var
            got = my_child_index_in_parent_at_in.length - 1,
            expect = caml_call1(Incremental_Import[17][18], t[10]) + 1 | 0,
            sexpifier = Core[356],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_070, b_071){
            return caml_call2(Core[352], a_070, b_071);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           iteri_parents
            (t,
             function(parent_index, param){
              var
               _cq_ =
                 caml_check_bound
                   (my_child_index_in_parent_at_in, parent_index)
                  [1 + parent_index];
              if
               (packed_same
                 (t, caml_call2(Incremental_Kind[5], param[5], _cq_)))
               return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _aA_], 1);
             });
           var
            _cn_ = Incremental_Import[11],
            _co_ = _cn_ ? 1 - caml_call1(is_necessary, t) : _cn_;
           if(! _co_) return _co_;
           function _cp_(x){
            if(caml_call2(Incremental_Import[3], x, -1)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aB_], 1);
           }
           return caml_call2
                   (Incremental_Import[15][22],
                    my_child_index_in_parent_at_in,
                    _cp_);
          }),
      my_parent_index_in_child_at_in =
        check
         (function(my_parent_index_in_child_at_in){
           var _cj_ = t[5];
           a:
           {
            if(typeof _cj_ !== "number" && 6 === _cj_[0]) break a;
            var
             got = my_parent_index_in_child_at_in.length - 1,
             expect = caml_call1(Incremental_Kind[4], t[5]),
             sexpifier = Core[356],
             equal = 0,
             message = 0,
             here = 0,
             comparator =
               function(a_068, b_069){
                return caml_call2(Core[352], a_068, b_069);
               };
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$1,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              got);
           }
           if(caml_call1(is_necessary, t))
            iteri_children
             (t,
              function(child_index, param){
               if
                (packed_same
                  (t,
                   get_parent
                    (param,
                     caml_check_bound
                       (my_parent_index_in_child_at_in, child_index)
                      [1 + child_index])))
                return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
              });
           var
            _ck_ = Incremental_Import[11],
            _cl_ = _ck_ ? 1 - caml_call1(is_necessary, t) : _ck_;
           if(! _cl_) return _cl_;
           function _cm_(x){
            if(caml_call2(Incremental_Import[3], x, -1)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aD_], 1);
           }
           return caml_call2
                   (Incremental_Import[15][22],
                    my_parent_index_in_child_at_in,
                    _cm_);
          }),
      observers_fun =
        check
         (function(param){
           return fold_observers
                   (t,
                    0,
                    function(param, observer){
                     var state = observer[1], observing = observer[2];
                     if(! caml_call2(Core[246], t, observing))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _aF_], 1);
                     if(1 < state - 1 >>> 0)
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _aE_], 1);
                     return 0;
                    });
          }),
      old_value_opt_fun =
        check(caml_call1(Incremental_Import[16][2], invariant_a)),
      next_in_adjust_heights_heap_fu =
        check
         (function(next_in_adjust_heights_heap){
           if(is_in_adjust_heights_heap(t)){
            var
             _ci_ =
               caml_call1
                (Incremental_Import[16][6], next_in_adjust_heights_heap);
            if(! _ci_) return _ci_;
            var
             next =
               caml_call1
                (Incremental_Import[16][7], next_in_adjust_heights_heap);
            if(! is_in_adjust_heights_heap(next))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _aH_], 1);
            if(caml_call2(Incremental_Import[3], t[18], next[18])) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aG_], 1);
           }
           if
            (caml_call1
              (Incremental_Import[16][5], next_in_adjust_heights_heap))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aI_], 1);
          }),
      height_in_adjust_heights_heap_ =
        check
         (function(height_in_adjust_heights_heap){
           var
            _ch_ =
              caml_call2
               (Incremental_Import[1], height_in_adjust_heights_heap, 0);
           if(! _ch_) return _ch_;
           if
            (caml_call2
              (Incremental_Import[5], height_in_adjust_heights_heap, t[14]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aJ_], 1);
          }),
      next_in_recompute_heap_fun =
        check
         (function(next_in_recompute_heap){
           if
            (1 - is_in_recompute_heap(t)
             &&
              !
              caml_call1(Incremental_Import[16][5], next_in_recompute_heap))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aM_], 1);
           var
            _cg_ =
              caml_call1(Incremental_Import[16][6], next_in_recompute_heap);
           if(! _cg_) return _cg_;
           var
            next =
              caml_call1(Incremental_Import[16][7], next_in_recompute_heap);
           if
            (!
             packed_same(t, caml_call1(Incremental_Import[16][7], next[16])))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aL_], 1);
           if(caml_call2(Incremental_Import[3], t[15], next[15])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aK_], 1);
          }),
      prev_in_recompute_heap_fun =
        check
         (function(prev_in_recompute_heap){
           if
            (1 - is_in_recompute_heap(t)
             &&
              !
              caml_call1(Incremental_Import[16][5], prev_in_recompute_heap))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aP_], 1);
           var
            _cf_ =
              caml_call1(Incremental_Import[16][6], prev_in_recompute_heap);
           if(! _cf_) return _cf_;
           var
            prev =
              caml_call1(Incremental_Import[16][7], prev_in_recompute_heap);
           if
            (!
             packed_same(t, caml_call1(Incremental_Import[16][7], prev[17])))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aO_], 1);
           if(caml_call2(Incremental_Import[3], t[15], prev[15])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
          }),
      height_in_recompute_heap_fun =
        check
         (function(height_in_recompute_heap){
           if
            (!
             caml_call2(Incremental_Import[1], height_in_recompute_heap, -1))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
           if
            (caml_call2
              (Incremental_Import[2], height_in_recompute_heap, t[14]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
          }),
      height_fun =
        check
         (function(height){
           if(caml_call1(is_necessary, t)){
            if(caml_call2(Incremental_Import[1], height, 0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
           }
           if(caml_call2(Incremental_Import[3], height, -1)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
          }),
      next_node_in_same_scope_fun =
        check
         (function(next_node_in_same_scope){
           var
            _cd_ = caml_call1(Incremental_Scope[4], t[12]),
            _ce_ = _cd_ || 1 - caml_call1(is_valid, t);
           if(! _ce_) return _ce_;
           if(caml_call1(Incremental_Import[16][5], next_node_in_same_scope))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aU_], 1);
          }),
      created_in_fun = check(Incremental_Scope[2]),
      parent0_fun =
        check
         (function(parent0){
           var
            t2 = caml_call1(Incremental_Import[16][6], parent0),
            t1 = caml_call2(Incremental_Import[4], t[9], 0),
            sexpifier = Core[305],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_066, b_067){
            return caml_call2(Core[301], a_066, b_067);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[2],
                    pos$2,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    t1,
                    t2);
          }),
      parent1_and_beyond_fun =
        check
         (function(parent1_and_beyond){
           var
            _ca_ = caml_call1(Incremental_Import[17][18], parent1_and_beyond),
            _b$_ = 1;
           if(_ca_ >= 1){
            var parent_index = _b$_;
            for(;;){
             var
              _cb_ =
                caml_call2
                 (Incremental_Import[17][19],
                  parent1_and_beyond,
                  parent_index - 1 | 0),
              t2 = caml_call1(Incremental_Import[16][6], _cb_),
              t1 = caml_call2(Incremental_Import[5], parent_index, t[9]),
              sexpifier = Core[305],
              equal = 0,
              message = 0,
              here = 0,
              comparator =
                function(a_064, b_065){
                 return caml_call2(Core[301], a_064, b_065);
                };
             caml_call8
              (Ppx_assert_lib_Runtime[2],
               pos$3,
               sexpifier,
               comparator,
               here,
               message,
               equal,
               t1,
               t2);
             var _cc_ = parent_index + 1 | 0;
             if(_ca_ === parent_index) break;
             var parent_index = _cc_;
            }
           }
           return 0;
          }),
      num_parents_fun =
        check
         (function(num_parents){
           if(! caml_call2(Incremental_Import[1], num_parents, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aW_], 1);
           var _b__ = 1 + caml_call1(Incremental_Import[17][18], t[10]) | 0;
           if(caml_call2(Incremental_Import[2], num_parents, _b__)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
          }),
      _b4_ =
        fold_observers
         (t,
          0,
          function(n, param){
           var on_update_handlers = param[3];
           return n + caml_call1(Core_List[7], on_update_handlers) | 0;
          }),
      expect = caml_call1(Core_List[7], t[23]) + _b4_ | 0,
      num_on_update_handlers_fun =
        check
         (function(eta){
           var sexpifier = Core[356], equal = 0, message = 0, here = 0;
           function comparator(a_062, b_063){
            return caml_call2(Core[352], a_062, b_063);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$4,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    eta);
          }),
      changed_at_fun =
        check
         (function(changed_at){
           caml_call1(Incremental_Stabilization_num[4], changed_at);
           var _b8_ = caml_call1(Incremental_Stabilization_num[8], t[3]);
           if(! _b8_) return _b8_;
           var
            _b9_ =
              caml_call2(Incremental_Stabilization_num[1], changed_at, t[3]);
           if(caml_call2(Incremental_Import[2], _b9_, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aX_], 1);
          }),
      cutoff_fun = check(caml_call1(Incremental_Cutoff[2], invariant_a)),
      kind_fun =
        check
         (function(kind){
           caml_call2(Incremental_Kind[1], invariant_a, kind);
           if(typeof kind !== "number" && 6 === kind[0]){
            var e = kind[1], _b7_ = caml_call1(is_necessary, t);
            return caml_call2(Incremental_Expert[4], e, _b7_);
           }
           return 0;
          }),
      value_opt_fun =
        check
         (function(value_opt){
           var
            _b5_ = caml_call1(is_valid, t),
            _b6_ = _b5_ ? 1 - is_stale(t) : _b5_;
           if(_b6_ && ! caml_call1(Incremental_Import[16][6], value_opt))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aY_], 1);
           return caml_call2
                   (Incremental_Import[16][2], invariant_a, value_opt);
          }),
      recomputed_at_fun = check(Incremental_Stabilization_num[4]),
      id_fun = check(Incremental_Node_id[9]);
     caml_call1(id_fun, id$0);
     caml_call1(recomputed_at_fun, recomputed_at$0);
     caml_call1(value_opt_fun, value_opt$0);
     caml_call1(kind_fun, kind$0);
     caml_call1(cutoff_fun, cutoff$0);
     caml_call1(changed_at_fun, changed_at$0);
     caml_call1(num_on_update_handlers_fun, num_on_update_handlers$0);
     caml_call1(num_parents_fun, num_parents$0);
     caml_call1(parent1_and_beyond_fun, parent1_and_beyond$0);
     caml_call1(parent0_fun, parent0$0);
     caml_call1(created_in_fun, created_in$0);
     caml_call1(next_node_in_same_scope_fun, next_node_in_same_scope$0);
     caml_call1(height_fun, height$0);
     caml_call1(height_in_recompute_heap_fun, height_in_recompute_heap$0);
     caml_call1(prev_in_recompute_heap_fun, prev_in_recompute_heap$0);
     caml_call1(next_in_recompute_heap_fun, next_in_recompute_heap$0);
     caml_call1
      (height_in_adjust_heights_heap_, height_in_adjust_heights_heap$0);
     caml_call1(next_in_adjust_heights_heap_fu, next_in_adjust_heights_heap$0);
     caml_call1(old_value_opt_fun, old_value_opt$0);
     caml_call1(observers_fun, observers$0);
     caml_call1
      (my_parent_index_in_child_at_in, my_parent_index_in_child_at_in$0);
     caml_call1
      (my_child_index_in_parent_at_in, my_child_index_in_parent_at_in$0);
     return 0;
    }
    function _b2_(x_059){
     return sexp_of_t(function(param){return _a0_;}, x_059);
    }
    return caml_call4(Base_Invariant[1], _a1_, t, _b2_, _b1_);
   }
   function unsafe_value(t){
    return caml_call1(Incremental_Import[16][11], t[4]);
   }
   function value_exn(t){
    if(caml_call1(Incremental_Import[16][6], t[4]))
     return caml_call1(Incremental_Import[16][11], t[4]);
    function _b0_(x_072){
     return sexp_of_t(function(param){return _a2_;}, x_072);
    }
    return caml_call5
            (Core[236], 0, _a3_, cst_attempt_to_get_value_of_an, t, _b0_);
   }
   function get_cutoff(t){return t[6];}
   function set_cutoff$0(t, cutoff){t[6] = cutoff; return 0;}
   function is_const(t){
    var _bZ_ = t[5];
    if(typeof _bZ_ !== "number" && 5 === _bZ_[0]) return 1;
    return 0;
   }
   function on_update(t, on_update_handler){
    t[23] = [0, on_update_handler, t[23]];
    t[8] = t[8] + 1 | 0;
    return 0;
   }
   function run_on_update_handlers(t, node_update, now){
    var r = [0, t[23]];
    for(;;){
     if(caml_call1(Core_List[8], r[1])) break;
     var match$0 = r[1];
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
     var rest$0 = match$0[2], on_update_handler$0 = match$0[1];
     r[1] = rest$0;
     caml_call3
      (Incremental_On_update_handler[4],
       on_update_handler$0,
       node_update,
       now);
    }
    var r$0 = [0, t[21]];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r$0[1])) return 0;
     var observer = caml_call1(Incremental_Import[16][7], r$0[1]);
     r$0[1] = observer[7];
     var r$1 = [0, observer[3]];
     for(;;){
      if(caml_call1(Core_List[8], r$1[1])) break;
      var match = r$1[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
      var rest = match[2], on_update_handler = match[1];
      r$1[1] = rest;
      var _bY_ = observer[1];
      a:
      if(_bY_){
       switch(_bY_ - 1 | 0){
         case 0:
          caml_call3
           (Incremental_On_update_handler[4],
            on_update_handler,
            node_update,
            now);
          break;
         case 1: break;
         default: break a;
       }
       continue;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a4_], 1);
     }
    }
   }
   function set_kind$0(t, kind){
    t[5] = kind;
    var _bX_ = caml_call1(Incremental_Kind[4], kind);
    t[24] = caml_call2(Incremental_Import[15][38], _bX_, -1);
    return 0;
   }
   function create(state, created_in, kind){
    var
     _bI_ = state[18] ? [0, caml_call2(Base_Backtrace[2], 0, 0)] : 0,
     _bJ_ = caml_call1(Incremental_Kind[4], kind),
     _bK_ = caml_call2(Incremental_Import[15][38], _bJ_, -1),
     _bL_ = Incremental_Import[16][3],
     _bM_ = Incremental_Import[16][3],
     _bN_ = Incremental_Import[16][3],
     _bO_ = Incremental_Import[16][3],
     _bP_ = Incremental_Import[16][3],
     _bQ_ = Incremental_Import[16][3],
     _bR_ = Incremental_Import[16][3],
     _bS_ = Incremental_Import[17][14],
     _bT_ = Incremental_Stabilization_num[5],
     _bU_ = Incremental_Cutoff[8],
     _bV_ = Incremental_Import[16][3],
     _bW_ = Incremental_Stabilization_num[5],
     t =
       [0,
        caml_call1(Incremental_Node_id[10], 0),
        state,
        _bW_,
        _bV_,
        kind,
        _bU_,
        _bT_,
        0,
        0,
        _bS_,
        _bR_,
        created_in,
        _bQ_,
        -1,
        -1,
        _bP_,
        _bO_,
        -1,
        _bN_,
        _bM_,
        _bL_,
        0,
        0,
        _bK_,
        [0, -1],
        0,
        0,
        _bI_];
    caml_call2(Incremental_Scope[8], created_in, t);
    return t;
   }
   function max_num_parents(t){
    return 1 + caml_call1(Incremental_Import[17][18], t[10]) | 0;
   }
   function set_parent(child, parent, parent_index){
    if(! caml_call2(Incremental_Import[3], parent_index, 0))
     return caml_call3
             (Incremental_Import[17][52],
              child[10],
              parent_index - 1 | 0,
              parent);
    child[11] = parent;
    return;
   }
   function link(child, child_index, parent, parent_index){
    set_parent
     (child, caml_call1(Incremental_Import[16][4], parent), parent_index);
    caml_check_bound(child[25], parent_index)[1 + parent_index] = child_index;
    caml_check_bound(parent[24], child_index)[1 + child_index] = parent_index;
    return;
   }
   function add_parent(child, parent, child_index){
    var _bG_ = max_num_parents(child);
    if(caml_call2(Incremental_Import[3], child[9], _bG_)){
     var new_max_num_parents = 2 * max_num_parents(child) | 0;
     child[10] =
      caml_call2
       (Incremental_Import[17][53], child[10], new_max_num_parents - 1 | 0);
     child[25] =
      caml_call3
       (Incremental_Import[15][123], child[25], new_max_num_parents, -1);
    }
    if(Incremental_Import[11]){
     var _bH_ = max_num_parents(child);
     if(! caml_call2(Incremental_Import[5], child[9], _bH_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a7_], 1);
    }
    var max_num_children = parent[24].length - 1;
    if(caml_call2(Incremental_Import[1], child_index, max_num_children)){
     if
      (Incremental_Import[11]
       && ! caml_call2(Incremental_Import[3], child_index, max_num_children))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a9_], 1);
     var
      new_max_num_children =
        caml_call2(Core_Int[93], 2, 2 * max_num_children | 0);
     parent[24] =
      caml_call3
       (Incremental_Import[15][123], parent[24], new_max_num_children, -1);
    }
    if
     (Incremental_Import[11]
      &&
       !
       caml_call2(Incremental_Import[5], child_index, parent[24].length - 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a8_], 1);
    link(child, child_index, parent, child[9]);
    child[9] = child[9] + 1 | 0;
    return 0;
   }
   function remove_parent(child, parent, child_index){
    if
     (Incremental_Import[11]
      && ! caml_call2(Incremental_Import[1], child[9], 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a$_], 1);
    var
     parent_index = caml_check_bound(parent[24], child_index)[1 + child_index];
    if
     (Incremental_Import[11]
      && ! packed_same(parent, get_parent(child, parent_index)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a__], 1);
    var last_parent_index = child[9] - 1 | 0;
    if(caml_call2(Incremental_Import[5], parent_index, last_parent_index)){
     var
      _bF_ =
        caml_call2
         (Incremental_Import[17][19], child[10], last_parent_index - 1 | 0),
      match = caml_call1(Incremental_Import[16][7], _bF_);
     link
      (child,
       caml_check_bound(child[25], last_parent_index)[1 + last_parent_index],
       match,
       parent_index);
    }
    set_parent(child, Incremental_Import[16][3], last_parent_index);
    if(Incremental_Import[11]){
     caml_check_bound(child[25], last_parent_index)[1 + last_parent_index] = -1;
     caml_check_bound(parent[24], child_index)[1 + child_index] = -1;
    }
    child[9] = child[9] - 1 | 0;
    return 0;
   }
   function swap_children_except_in_kind
   (parent, child1, child_index1, child2, child_index2){
    if(Incremental_Import[11]){
     if
      (!
       packed_same
        (child1, caml_call2(Incremental_Kind[5], parent[5], child_index1)))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bd_], 1);
     if
      (!
       packed_same
        (child2, caml_call2(Incremental_Kind[5], parent[5], child_index2)))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bc_], 1);
    }
    var
     index_of_parent_in_child1 =
       caml_check_bound(parent[24], child_index1)[1 + child_index1],
     index_of_parent_in_child2 =
       caml_check_bound(parent[24], child_index2)[1 + child_index2];
    if(Incremental_Import[11]){
     var
      _bD_ =
        caml_check_bound(child1[25], index_of_parent_in_child1)
         [1 + index_of_parent_in_child1];
     if(! caml_call2(Incremental_Import[3], _bD_, child_index1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bb_], 1);
     var
      _bE_ =
        caml_check_bound(child2[25], index_of_parent_in_child2)
         [1 + index_of_parent_in_child2];
     if(! caml_call2(Incremental_Import[3], _bE_, child_index2))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _ba_], 1);
    }
    caml_check_bound(child1[25], index_of_parent_in_child1)
     [1 + index_of_parent_in_child1]
    = child_index2;
    caml_check_bound(child2[25], index_of_parent_in_child2)
     [1 + index_of_parent_in_child2]
    = child_index1;
    caml_check_bound(parent[24], child_index1)[1 + child_index1] = index_of_parent_in_child2;
    caml_check_bound(parent[24], child_index2)[1 + child_index2] = index_of_parent_in_child1;
    return 0;
   }
   function sexp_of_t$0(x_073){
    return sexp_of_t(function(param){return _be_;}, x_073);
   }
   function invariant$0(param){
    return invariant(function(_bC_){return 0;}, param);
   }
   function iter_descendants_internal(ts, f){
    var seen = caml_call3(Incremental_Node_id[7][3], 0, 0, 0);
    function iter_descendants(t){
     var _bB_ = 1 - caml_call2(Core_Hash_set[20], seen, t[1]);
     return _bB_
             ? (caml_call2
                (Core_Hash_set[22], seen, t[1]),
               caml_call1(f, t),
               iteri_children
                (t, function(param, t){return iter_descendants(t);}))
             : _bB_;
    }
    caml_call2(Core_List[9], ts, iter_descendants);
    return seen;
   }
   function iter_descendants(ts, f){
    iter_descendants_internal(ts, f);
    return 0;
   }
   var
    to_dot = Incremental_Dot_user_info[6],
    append = Incremental_Dot_user_info[7],
    to_string = Incremental_Dot_user_info[8];
   function append_user_info_graphviz$0(param){
    return function(_bz_, _bA_){
     return append_user_info_graphviz(param, _bz_, _bA_);};
   }
   function save_dot(out, ts){
    var
     node_name =
       Core[541]
        ? function(param){return cst_n;}
        : function
         (node){
          var _by_ = caml_call1(Incremental_Node_id[11], node[1]);
          return caml_call2(Core[18], cst_n$0, _by_);
         };
    caml_call2(Core[238], out, _bh_);
    caml_call2(Core[238], out, _bi_);
    var
     bind_edges = [0, 0],
     seen =
       iter_descendants_internal
        (ts,
         function(t){
          var
           name = node_name(t),
           _bs_ = Core_String[140][3],
           _bt_ = [0, caml_call2(Core[257], _bf_, t[14]), 0],
           _bu_ = [0, name, [0, caml_call1(Incremental_Kind[3], t[5]), _bt_]],
           default$0 = caml_call2(Incremental_Dot_user_info[5], _bu_, _bs_),
           match = t[27];
          if(match)
           var
            user_info = match[1],
            info = caml_call2(append, default$0, user_info);
          else
           var info = default$0;
          var _bv_ = caml_call2(to_string, name, caml_call1(to_dot, info));
          caml_call3(Core[238], out, _bg_, _bv_);
          iteri_children
           (t,
            function(param, from){
             var _bx_ = node_name(from);
             return caml_call4(Core[238], out, _bj_, _bx_, name);
            });
          var match$0 = t[5];
          if(typeof match$0 !== "number" && 3 === match$0[0]){
           var
            bind = match$0[1],
            _bw_ =
              function(to){
               bind_edges[1] = [0, [0, t, to], bind_edges[1]];
               return 0;
              };
           return caml_call2(Incremental_Bind[4], bind, _bw_);
          }
          return 0;
         });
    function _bo_(param){
     var
      to = param[2],
      from = param[1],
      _bp_ = caml_call2(Core_Hash_set[20], seen, to[1]);
     if(! _bp_) return _bp_;
     var _bq_ = node_name(to), _br_ = node_name(from);
     return caml_call4(Core[238], out, _bk_, _br_, _bq_);
    }
    caml_call2(Core_List[9], bind_edges[1], _bo_);
    return caml_call2(Core[238], out, _bl_);
   }
   function save_dot_to_file(file, ts){
    function _bn_(out){return save_dot(out, ts);}
    return caml_call6(Stdio_Out_channel[6], 0, 0, 0, 0, file, _bn_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Node);
   var
    Incremental_Node =
      [0,
       [0,
        sexp_of_t$0,
        invariant$0,
        function(M){
         function fold(t, init, f){
          var ac = [0, init], r = [0, t];
          for(;;){
           if(! caml_call1(Incremental_Import[16][6], r[1])) return ac[1];
           var packed_node = caml_call1(Incremental_Import[16][11], r[1]);
           r[1] = caml_call1(M[1], packed_node);
           ac[1] = caml_call2(f, ac[1], packed_node);
          }
         }
         function iter(t, f){
          return fold(t, 0, function(param, n){return caml_call1(f, n);});
         }
         function invariant(t){return iter(t, invariant$0);}
         function length(t){
          return fold(t, 0, function(n, param){return n + 1 | 0;});
         }
         function sexp_of_t(t){
          var
           _bm_ = fold(t, 0, function(ac, n){return [0, n, ac];}),
           x_074 = caml_call1(Core_List[34], _bm_);
          return caml_call2(Core[421], Incremental_Types[15][2][1], x_074);
         }
         return [0, sexp_of_t, invariant, length, iter];
        },
        iter_descendants,
        save_dot,
        save_dot_to_file,
        append_user_info_graphviz$0],
       sexp_of_t,
       type_equal_if_phys_same,
       invariant,
       create,
       set_kind$0,
       same,
       iteri_children,
       get_parent,
       add_parent,
       remove_parent,
       swap_children_except_in_kind,
       is_const,
       is_in_recompute_heap,
       is_necessary,
       is_valid,
       should_be_invalidated,
       edge_is_stale,
       is_stale,
       needs_to_be_computed,
       value_exn,
       unsafe_value,
       get_cutoff,
       set_cutoff$0,
       on_update,
       run_on_update_handlers,
       user_info,
       set_user_info,
       append_user_info_graphviz,
       has_child,
       has_parent];
   runtime.caml_register_global(159, Incremental_Node, cst_Incremental_Node$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Recompute_heap
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Node, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Recompute_heap$0 = "Incremental__Recompute_heap",
    cst$0 = "_",
    cst_height_lower_bound$0 = "height_lower_bound",
    cst_incremental$0 = "incremental",
    cst_length$0 = "length",
    cst_nodes_by_height$0 = "nodes_by_height",
    cst_src_recompute_heap_ml = "src/recompute_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/recompute_heap.ml:38:22",
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Incremental_Node = global_data.Incremental__Node,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Recompute_heap$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_recompute_heap_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _z_ = [0, cst_src_recompute_heap_ml, 172, 16],
    cst_Recompute_heap_remove_min_ =
      "Recompute_heap.remove_min unexpectedly reached end of heap",
    _A_ = [0, cst_src_recompute_heap_ml, 180, 5927, 5941],
    _B_ = [0, cst_src_recompute_heap_ml, 192, 16],
    _y_ = [0, cst_src_recompute_heap_ml, 153, 4],
    _x_ = [0, cst_src_recompute_heap_ml, 154, 4],
    _w_ = [0, cst_src_recompute_heap_ml, 155, 4],
    _u_ = [0, cst$0],
    cst_incorrect_remove_of_node_f =
      "incorrect [remove] of node from recompute heap",
    _v_ = [0, cst_src_recompute_heap_ml, 140, 4695, 4707],
    _r_ = [0, cst$0],
    cst_incorrect_attempt_to_add_n =
      "incorrect attempt to add node to recompute heap",
    _s_ = [0, cst_src_recompute_heap_ml, 125, 4218, 4230],
    _t_ = [0, cst_src_recompute_heap_ml, 129, 16],
    _q_ = [0, cst_src_recompute_heap_ml, 99, 16],
    _p_ = [0, cst_src_recompute_heap_ml, 62, 6],
    _n_ = [0, cst_src_recompute_heap_ml, 41, 11],
    _m_ = [0, cst_src_recompute_heap_ml, 42, 11],
    _l_ = [0, cst_src_recompute_heap_ml, 44, 13],
    _k_ = [0, cst_src_recompute_heap_ml, 50, 15],
    _j_ = [0, cst_src_recompute_heap_ml, 51, 15],
    _o_ = [0, cst_src_recompute_heap_ml, 30, 873, 895],
    _g_ = [0, cst_nodes_by_height$0],
    _h_ = [0, cst_height_lower_bound$0],
    _i_ = [0, cst_length$0],
    cst_nodes_by_height = cst_nodes_by_height$0,
    cst_height_lower_bound = cst_height_lower_bound$0,
    cst_length = cst_length$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Recompute_heap = cst_Incremental_Recompute_heap$0;
   function next(param){return param[17];}
   var As_recompute_list = caml_call1(Incremental_Node[1][3], [0, next]);
   function nodes_by_height(r){return r[3];}
   function set_nodes_by_height(r, v){r[3] = v; return 0;}
   function height_lower_bound(r){return r[2];}
   function set_height_lower_bound(r, v){r[2] = v; return 0;}
   function length(r){return r[1];}
   function set_length(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = [0, set_nodes_by_height],
    nodes_by_height$0 =
      [0,
       function(param){return 0;},
       cst_nodes_by_height,
       _b_,
       nodes_by_height,
       _a_];
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = [0, set_height_lower_bound],
    height_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_height_lower_bound,
       _d_,
       height_lower_bound,
       _c_];
   function _e_(r, v){return [0, v, r[2], r[3]];}
   var
    _f_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _f_, length, _e_];
   function sexp_of_t(param){
    var
     length_003 = param[1],
     height_lower_bound_005 = param[2],
     nodes_by_height_007 = param[3],
     max_nonempty_index = [0, -1],
     bnds_002 = 0;
    function _am_(i, l){
     var
      _an_ = caml_call1(Incremental_Import[16][6], l),
      _ao_ = _an_ ? (max_nonempty_index[1] = i, 0) : _an_;
     return _ao_;
    }
    caml_call2(Incremental_Import[17][28], nodes_by_height_007, _am_);
    var
     x_001 =
       caml_call3
        (Incremental_Import[17][37],
         nodes_by_height_007,
         0,
         max_nonempty_index[1] + 1 | 0),
     arg_008 =
       caml_call2(Incremental_Import[17][10], As_recompute_list[1], x_001),
     bnds_002$0 = [0, [1, [0, _g_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call1(Core[356], height_lower_bound_005),
     bnds_002$1 = [0, [1, [0, _h_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(Core[356], length_003),
     bnds_002$2 = [0, [1, [0, _i_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function max_height_allowed(t){
    return caml_call1(Incremental_Import[17][18], t[3]) - 1 | 0;
   }
   function invariant(t){
    function _ac_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      nodes_by_height_fun =
        check
         (function(nodes_by_height){
           function _ak_(height, node){
            function _al_(node){
             if(! caml_call2(Incremental_Import[3], node[15], height))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
             if(caml_call1(Incremental_Node[20], node)) return 0;
             throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
            }
            return caml_call2(As_recompute_list[4], node, _al_);
           }
           return caml_call2
                   (Incremental_Import[17][28], nodes_by_height, _ak_);
          }),
      height_lower_bound_fun =
        check
         (function(height_lower_bound){
           if(! caml_call2(Incremental_Import[1], height_lower_bound, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           var _af_ = caml_call1(Incremental_Import[17][18], t[3]);
           if(! caml_call2(Incremental_Import[2], height_lower_bound, _af_))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
           var _ah_ = height_lower_bound - 1 | 0, _ag_ = 0;
           if(_ah_ >= 0){
            var height = _ag_;
            for(;;){
             var _ai_ = caml_call2(Incremental_Import[17][19], t[3], height);
             if(! caml_call1(Incremental_Import[16][5], _ai_))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
             var _aj_ = height + 1 | 0;
             if(_ah_ === height) break;
             var height = _aj_;
            }
           }
           return 0;
          }),
      length_fun =
        check
         (function(length){
           var actual_length = [0, 0];
           function _ad_(node){
            var _ae_ = caml_call1(As_recompute_list[3], node);
            actual_length[1] = actual_length[1] + _ae_ | 0;
            return 0;
           }
           caml_call2(Incremental_Import[17][27], t[3], _ad_);
           var
            t2 = actual_length[1],
            sexpifier = Core[356],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_009, b_010){
            return caml_call2(Core[352], a_009, b_010);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[2],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    length,
                    t2);
          });
     caml_call1(length_fun, length$0);
     caml_call1(height_lower_bound_fun, height_lower_bound$0);
     return caml_call1(nodes_by_height_fun, nodes_by_height$0);
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t, _ac_);
   }
   function create_nodes_by_height(max_height_allowed){
    return caml_call2
            (Incremental_Import[17][15],
             max_height_allowed + 1 | 0,
             Incremental_Import[16][3]);
   }
   function set_max_height_allowed(t, max_height_allowed){
    if(Incremental_Import[11]){
     var
      _W_ = max_height_allowed + 1 | 0,
      _X_ = caml_call1(Incremental_Import[17][18], t[3]) - 1 | 0;
     if(_X_ >= _W_){
      var i = _W_;
      for(;;){
       var _aa_ = caml_call2(Incremental_Import[17][19], t[3], i);
       if(! caml_call1(Incremental_Import[16][5], _aa_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
       var _ab_ = i + 1 | 0;
       if(_X_ === i) break;
       var i = _ab_;
      }
     }
    }
    var
     src = t[3],
     dst = create_nodes_by_height(max_height_allowed),
     _Y_ = caml_call1(Incremental_Import[17][18], dst),
     _Z_ = caml_call1(Incremental_Import[17][18], src),
     ___ = caml_call2(Incremental_Import[9], _Z_, _Y_);
    caml_call5(Incremental_Import[17][34], src, 0, dst, 0, ___);
    t[3] = dst;
    var _$_ = caml_call1(Incremental_Import[17][18], dst);
    t[2] = caml_call2(Incremental_Import[9], t[2], _$_);
    return 0;
   }
   function create(max_height_allowed){
    return [0,
            0,
            max_height_allowed + 1 | 0,
            create_nodes_by_height(max_height_allowed)];
   }
   function set_prev(next, prev){
    if(caml_call1(Incremental_Import[16][6], next))
     caml_call1(Incremental_Import[16][11], next)[16] = prev;
    return;
   }
   function link(t, node){
    var height = node[14];
    if(Incremental_Import[11]){
     var _U_ = max_height_allowed(t);
     if(! caml_call2(Incremental_Import[2], height, _U_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
    }
    node[15] = height;
    var next = caml_call2(Incremental_Import[17][19], t[3], height);
    node[17] = next;
    set_prev(next, caml_call1(Incremental_Import[16][4], node));
    var _V_ = caml_call1(Incremental_Import[16][4], node);
    return caml_call3(Incremental_Import[17][51], t[3], height, _V_);
   }
   function unlink(t, node){
    var
     prev = node[16],
     next = node[17],
     _S_ = caml_call2(Incremental_Import[17][19], t[3], node[15]),
     _T_ = caml_call1(Incremental_Import[16][4], node);
    if(caml_call2(Core[247], _T_, _S_))
     caml_call3(Incremental_Import[17][51], t[3], node[15], next);
    set_prev(next, prev);
    if(caml_call1(Incremental_Import[16][6], prev))
     caml_call1(Incremental_Import[16][11], prev)[17] = next;
    node[16] = Incremental_Import[16][3];
    return;
   }
   function add(t, node){
    var _M_ = Incremental_Import[11];
    if(_M_)
     var
      _N_ = caml_call1(Incremental_Node[14], node),
      _O_ = _N_ || 1 - caml_call1(Incremental_Node[20], node);
    else
     var _O_ = _M_;
    if(_O_){
     var
      _P_ =
        function(x_011){
         function _R_(param){return _r_;}
         return caml_call2(Incremental_Node[2], _R_, x_011);
        };
     caml_call5(Core[236], 0, _s_, cst_incorrect_attempt_to_add_n, node, _P_);
    }
    if(Incremental_Import[11]){
     var _Q_ = max_height_allowed(t);
     if(! caml_call2(Incremental_Import[2], node[14], _Q_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
    }
    var height = node[14];
    if(caml_call2(Incremental_Import[5], height, t[2])) t[2] = height;
    link(t, node);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function remove(t, node){
    var _H_ = Incremental_Import[11];
    if(_H_)
     var
      _I_ = 1 - caml_call1(Incremental_Node[14], node),
      _J_ = _I_ || caml_call1(Incremental_Node[20], node);
    else
     var _J_ = _H_;
    if(_J_){
     var
      _K_ =
        function(x_012){
         function _L_(param){return _u_;}
         return caml_call2(Incremental_Node[2], _L_, x_012);
        };
     caml_call5(Core[236], 0, _v_, cst_incorrect_remove_of_node_f, node, _K_);
    }
    unlink(t, node);
    node[17] = Incremental_Import[16][3];
    node[15] = -1;
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function increase_height(t, node){
    if(Incremental_Import[11]){
     if(! caml_call2(Incremental_Import[4], node[14], node[15]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
     var _G_ = max_height_allowed(t);
     if(! caml_call2(Incremental_Import[2], node[14], _G_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
     if(! caml_call1(Incremental_Node[14], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
    }
    unlink(t, node);
    return link(t, node);
   }
   function min_height(t){
    if(caml_call2(Incremental_Import[3], t[1], 0))
     t[2] = caml_call1(Incremental_Import[17][18], t[3]);
    else{
     var nodes_by_height = t[3];
     for(;;){
      var _F_ = caml_call2(Incremental_Import[17][19], nodes_by_height, t[2]);
      if(! caml_call1(Incremental_Import[16][5], _F_)) break;
      t[2] = t[2] + 1 | 0;
     }
    }
    return t[2];
   }
   function remove_min(t){
    if(Incremental_Import[11] && caml_call2(Incremental_Import[3], t[1], 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    var
     nodes_by_height = t[3],
     node = [0, caml_call2(Incremental_Import[17][19], nodes_by_height, t[2])];
    for(;;){
     if(! caml_call1(Incremental_Import[16][5], node[1])) break;
     t[2] = t[2] + 1 | 0;
     var _C_ = Incremental_Import[11];
     if(_C_)
      var
       _D_ = caml_call1(Incremental_Import[17][18], t[3]),
       _E_ = caml_call2(Incremental_Import[1], t[2], _D_);
     else
      var _E_ = _C_;
     if(_E_)
      caml_call5
       (Core[236], 0, _A_, cst_Recompute_heap_remove_min_, t, sexp_of_t);
     node[1] = caml_call2(Incremental_Import[17][19], nodes_by_height, t[2]);
    }
    var node$0 = caml_call1(Incremental_Import[16][11], node[1]);
    node$0[15] = -1;
    t[1] = t[1] - 1 | 0;
    var next = node$0[17];
    caml_call3(Incremental_Import[17][52], t[3], t[2], next);
    set_prev(next, Incremental_Import[16][3]);
    if
     (Incremental_Import[11]
      && ! caml_call1(Incremental_Import[16][5], node$0[16]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
    node$0[17] = Incremental_Import[16][3];
    return node$0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Recompute_heap);
   var
    Incremental_Recompute_heap =
      [0,
       sexp_of_t,
       invariant,
       create,
       length,
       max_height_allowed,
       set_max_height_allowed,
       min_height,
       add,
       remove,
       remove_min,
       increase_height];
   runtime.caml_register_global
    (48, Incremental_Recompute_heap, cst_Incremental_Recompute_heap$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Adjust_heights_heap
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Expect_test_collector, Incremental__Import, Incremental__Node, Incremental__Recompute_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Adjust_heights$0 = "Incremental__Adjust_heights_heap",
    cst$0 = "_",
    cst_height_lower_bound$0 = "height_lower_bound",
    cst_incremental$0 = "incremental",
    cst_length$0 = "length",
    cst_max_height_seen$0 = "max_height_seen",
    cst_nodes_by_height$0 = "nodes_by_height",
    cst_src_adjust_heights_heap_ml = "src/adjust_heights_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Recompute_heap = global_data.Incremental__Recompute_heap,
    Core = global_data.Core,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Adjust_heights$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_adjust_heights_heap_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _Q_ = [0, cst_src_adjust_heights_heap_ml, 166, 16],
    _P_ = [0, cst_src_adjust_heights_heap_ml, 167, 16],
    _O_ = [0, cst_src_adjust_heights_heap_ml, 206, 16],
    _N_ = [0, cst_src_adjust_heights_heap_ml, 207, 16],
    _I_ = [0, cst$0],
    _G_ = [0, cst$0],
    _H_ = [0, "child"],
    _J_ = [0, "parent"],
    _M_ = [0, cst_src_adjust_heights_heap_ml, 142, 16],
    _L_ = [0, cst_src_adjust_heights_heap_ml, 143, 16],
    cst_adding_edge_made_graph_cyc = "adding edge made graph cyclic",
    _K_ = [0, cst_src_adjust_heights_heap_ml, 147, 5103, 5115],
    _D_ = [0, "Height"],
    _E_ = [0, "Max"],
    cst_node_with_too_large_height = "node with too large height",
    _F_ = [0, cst_src_adjust_heights_heap_ml, 134, 4662, 4676],
    cst_Adjust_heights_heap_remove =
      "Adjust_heights_heap.remove_min of empty heap",
    _C_ = [0, cst_src_adjust_heights_heap_ml, 112, 3903, 3923],
    _B_ = [0, cst_src_adjust_heights_heap_ml, 100, 18],
    _A_ = [0, cst_src_adjust_heights_heap_ml, 102, 18],
    _x_ = [0, cst_max_height_seen$0],
    cst_cannot_set_max_height_allo =
      "cannot set_max_height_allowed less than the max height already seen",
    _y_ = [0, cst_src_adjust_heights_heap_ml, 86, 2771, 2783],
    _z_ = [0, cst_src_adjust_heights_heap_ml, 90, 16],
    _v_ = [0, cst_src_adjust_heights_heap_ml, 59, 11],
    _u_ = [0, cst_src_adjust_heights_heap_ml, 62, 11],
    _t_ = [0, cst_src_adjust_heights_heap_ml, 63, 11],
    _s_ = [0, cst_src_adjust_heights_heap_ml, 65, 13],
    _r_ = [0, cst_src_adjust_heights_heap_ml, 69, 11],
    _q_ = [0, cst_src_adjust_heights_heap_ml, 70, 11],
    _w_ = [0, cst_src_adjust_heights_heap_ml, 54, 1648, 1670],
    _m_ = [0, cst_nodes_by_height$0],
    _n_ = [0, cst_max_height_seen$0],
    _o_ = [0, cst_height_lower_bound$0],
    _p_ = [0, cst_length$0],
    _c_ = [0, cst_src_adjust_heights_heap_ml, 23, 10],
    _b_ = [0, cst_src_adjust_heights_heap_ml, 24, 10],
    _a_ = [0, cst_src_adjust_heights_heap_ml, 27, 12],
    _d_ = [0, cst_src_adjust_heights_heap_ml, 19, 538, 562],
    cst_nodes_by_height = cst_nodes_by_height$0,
    cst_max_height_seen = cst_max_height_seen$0,
    cst_height_lower_bound = cst_height_lower_bound$0,
    cst_length = cst_length$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Adjust_heights = cst_Incremental_Adjust_heights$0;
   function next(param){return param[19];}
   var As_adjust_heights_list = caml_call1(Incremental_Node[1][3], [0, next]);
   function sexp_of_t(t){
    var max_nonempty_index = [0, -1];
    function _ay_(i, l){
     var
      _az_ = caml_call1(Incremental_Import[16][6], l),
      _aA_ = _az_ ? (max_nonempty_index[1] = i, 0) : _az_;
     return _aA_;
    }
    caml_call2(Incremental_Import[17][28], t, _ay_);
    var
     x_001 =
       caml_call3
        (Incremental_Import[17][37], t, 0, max_nonempty_index[1] + 1 | 0);
    return caml_call2
            (Incremental_Import[17][10], As_adjust_heights_list[1], x_001);
   }
   function invariant(t){
    function _au_(param){
     function _av_(height, nodes){
      caml_call1(As_adjust_heights_list[2], nodes);
      function _aw_(node){
       if(! caml_call2(Incremental_Import[3], node[18], height))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(! caml_call2(Incremental_Import[4], node[14], node[18]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       var _ax_ = caml_call1(Incremental_Node[14], node);
       if(! _ax_) return _ax_;
       if(caml_call2(Incremental_Import[3], node[15], node[18])) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      return caml_call2(As_adjust_heights_list[4], nodes, _aw_);
     }
     return caml_call2(Incremental_Import[17][28], t, _av_);
    }
    return caml_call4(Base_Invariant[1], _d_, t, sexp_of_t, _au_);
   }
   function create(max_height_allowed){
    return caml_call2
            (Incremental_Import[17][15],
             max_height_allowed + 1 | 0,
             Incremental_Import[16][3]);
   }
   function nodes_by_height(r){return r[4];}
   function set_nodes_by_height(r, v){r[4] = v; return 0;}
   function max_height_seen(r){return r[3];}
   function set_max_height_seen(r, v){r[3] = v; return 0;}
   function height_lower_bound(r){return r[2];}
   function set_height_lower_bound(r, v){r[2] = v; return 0;}
   function length(r){return r[1];}
   function set_length(r, v){r[1] = v; return 0;}
   function _e_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _f_ = [0, set_nodes_by_height],
    nodes_by_height$0 =
      [0,
       function(param){return 0;},
       cst_nodes_by_height,
       _f_,
       nodes_by_height,
       _e_];
   function _g_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _h_ = [0, set_max_height_seen],
    max_height_seen$0 =
      [0,
       function(param){return 0;},
       cst_max_height_seen,
       _h_,
       max_height_seen,
       _g_];
   function _i_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _j_ = [0, set_height_lower_bound],
    height_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_height_lower_bound,
       _j_,
       height_lower_bound,
       _i_];
   function _k_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _l_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _l_, length, _k_];
   function sexp_of_t$0(param){
    var
     length_003 = param[1],
     height_lower_bound_005 = param[2],
     max_height_seen_007 = param[3],
     nodes_by_height_009 = param[4],
     arg_010 = sexp_of_t(nodes_by_height_009),
     bnds_002 = [0, [1, [0, _m_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(Core[356], max_height_seen_007),
     bnds_002$0 = [0, [1, [0, _n_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call1(Core[356], height_lower_bound_005),
     bnds_002$1 = [0, [1, [0, _o_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(Core[356], length_003),
     bnds_002$2 = [0, [1, [0, _p_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function is_empty(t){return caml_call2(Incremental_Import[3], t[1], 0);}
   function max_height_allowed(t){
    return caml_call1(Incremental_Import[17][18], t[4]) - 1 | 0;
   }
   function invariant$0(t){
    function _al_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      nodes_by_height_fun = check(invariant),
      max_height_seen_fun =
        check
         (function(max_height_seen){
           if(! caml_call2(Incremental_Import[1], max_height_seen, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
           var _at_ = max_height_allowed(t);
           if(caml_call2(Incremental_Import[2], max_height_seen, _at_))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
          }),
      height_lower_bound_fun =
        check
         (function(height_lower_bound){
           if(! caml_call2(Incremental_Import[1], height_lower_bound, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           var _ao_ = caml_call1(Incremental_Import[17][18], t[4]);
           if(! caml_call2(Incremental_Import[2], height_lower_bound, _ao_))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
           var _aq_ = height_lower_bound - 1 | 0, _ap_ = 0;
           if(_aq_ >= 0){
            var height = _ap_;
            for(;;){
             var _ar_ = caml_call2(Incremental_Import[17][19], t[4], height);
             if(! caml_call1(Incremental_Import[16][5], _ar_))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
             var _as_ = height + 1 | 0;
             if(_aq_ === height) break;
             var height = _as_;
            }
           }
           return 0;
          }),
      length_fun =
        check
         (function(length){
           var t$0 = t[4], r = [0, 0];
           function _am_(node){
            var _an_ = caml_call1(As_adjust_heights_list[3], node);
            r[1] = r[1] + _an_ | 0;
            return 0;
           }
           caml_call2(Incremental_Import[17][27], t$0, _am_);
           if(caml_call2(Incremental_Import[3], length, r[1])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
          });
     caml_call1(length_fun, length$0);
     caml_call1(height_lower_bound_fun, height_lower_bound$0);
     caml_call1(max_height_seen_fun, max_height_seen$0);
     return caml_call1(nodes_by_height_fun, nodes_by_height$0);
    }
    return caml_call4(Base_Invariant[1], _w_, t, sexp_of_t$0, _al_);
   }
   function create$0(max_height_allowed){
    return [0, 0, max_height_allowed + 1 | 0, 0, create(max_height_allowed)];
   }
   function set_max_height_allowed(t, max_height_allowed){
    if(caml_call2(Incremental_Import[5], max_height_allowed, t[3])){
     var
      _ak_ =
        function(param){
         var
          arg1_013 = param[2],
          arg0_012 = param[1],
          res0_014 = caml_call1(Core[356], arg0_012),
          v_011 = arg1_013[2],
          res1_015 = [1, [0, _x_, [0, caml_call1(Core[356], v_011), 0]]];
         return [1, [0, res0_014, [0, res1_015, 0]]];
        };
     caml_call5
      (Core[236],
       0,
       _y_,
       cst_cannot_set_max_height_allo,
       [0, max_height_allowed, [0, -794774856, t[3]]],
       _ak_);
    }
    if(Incremental_Import[11] && ! is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    t[4] = create(max_height_allowed);
    return 0;
   }
   function set_height(t, node, height){
    if(caml_call2(Incremental_Import[4], height, t[3])){
     t[3] = height;
     var _ah_ = max_height_allowed(t);
     if(caml_call2(Incremental_Import[4], height, _ah_)){
      var
       _ai_ =
         function(param){
          var
           arg1_019 = param[2],
           arg0_018 = param[1],
           v_016 = arg0_018[2],
           res0_020 = [1, [0, _D_, [0, caml_call1(Core[356], v_016), 0]]],
           v_017 = arg1_019[2],
           res1_021 = [1, [0, _E_, [0, caml_call1(Core[356], v_017), 0]]];
          return [1, [0, res0_020, [0, res1_021, 0]]];
         },
       _aj_ = [0, [0, 920681479, height], [0, 3850884, max_height_allowed(t)]];
      caml_call5
       (Core[236], 0, _F_, cst_node_with_too_large_height, _aj_, _ai_);
     }
    }
    node[14] = height;
    return 0;
   }
   function ensure_height_requirement
   (t, original_child, original_parent, child, parent){
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], child))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    if(caml_call2(Incremental_Node[7], parent, original_child)){
     var
      _ab_ =
        function(param){
         var
          arg1_025 = param[2],
          arg0_024 = param[1],
          v_022 = arg0_024[2],
          _ad_ = 0;
         function _ae_(param){return _G_;}
         var
          res0_026 =
            [1,
             [0, _H_, [0, caml_call2(Incremental_Node[2], _ae_, v_022), _ad_]]],
          v_023 = arg1_025[2],
          _af_ = 0;
         function _ag_(param){return _I_;}
         var
          res1_027 =
            [1,
             [0, _J_, [0, caml_call2(Incremental_Node[2], _ag_, v_023), _af_]]];
         return [1, [0, res0_026, [0, res1_027, 0]]];
        };
     caml_call5
      (Core[236],
       0,
       _K_,
       cst_adding_edge_made_graph_cyc,
       [0, [0, -977688164, original_child], [0, -310508246, original_parent]],
       _ab_);
    }
    var _ac_ = caml_call2(Incremental_Import[1], child[14], parent[14]);
    if(! _ac_) return _ac_;
    if(caml_call2(Incremental_Import[3], parent[18], -1)){
     var height = parent[14];
     if
      (Incremental_Import[11]
       && ! caml_call2(Incremental_Import[1], height, t[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     if(Incremental_Import[11]){
      var _$_ = max_height_allowed(t);
      if(! caml_call2(Incremental_Import[2], height, _$_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     parent[18] = height;
     t[1] = t[1] + 1 | 0;
     parent[19] = caml_call2(Incremental_Import[17][19], t[4], height);
     var _aa_ = caml_call1(Incremental_Import[16][4], parent);
     caml_call3(Incremental_Import[17][51], t[4], height, _aa_);
    }
    return set_height(t, parent, child[14] + 1 | 0);
   }
   function adjust_heights(t, recompute_heap, original_child, original_parent){
    if(Incremental_Import[11] && ! is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _Q_], 1);
    if
     (Incremental_Import[11]
      &&
       !
       caml_call2
        (Incremental_Import[1], original_child[14], original_parent[14]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    t[2] = original_parent[14];
    ensure_height_requirement
     (t, original_child, original_parent, original_child, original_parent);
    for(;;){
     if(! caml_call2(Incremental_Import[4], t[1], 0)){
      if(Incremental_Import[11] && ! is_empty(t))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
      var ___ = Incremental_Import[11];
      if(! ___) return ___;
      if
       (caml_call2
         (Incremental_Import[5], original_child[14], original_parent[14]))
       return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
     }
     var _R_ = Incremental_Import[11], _S_ = _R_ ? is_empty(t) : _R_;
     if(_S_)
      caml_call5
       (Core[236], 0, _C_, cst_Adjust_heights_heap_remove, t, sexp_of_t$0);
     var r = [0, t[2]];
     for(;;){
      var _T_ = caml_call2(Incremental_Import[17][19], t[4], r[1]);
      if(! caml_call1(Incremental_Import[16][5], _T_)) break;
      r[1]++;
     }
     var height = r[1];
     t[2] = height;
     var
      _U_ = caml_call2(Incremental_Import[17][20], t[4], height),
      child = caml_call1(Incremental_Import[16][11], _U_);
     child[18] = -1;
     t[1] = t[1] - 1 | 0;
     caml_call3(Incremental_Import[17][51], t[4], height, child[19]);
     child[19] = Incremental_Import[16][3];
     if(caml_call1(Incremental_Node[14], child))
      caml_call2(Incremental_Recompute_heap[11], recompute_heap, child);
     if(caml_call2(Incremental_Import[4], child[9], 0)){
      var parent = caml_call1(Incremental_Import[16][7], child[11]);
      ensure_height_requirement
       (t, original_child, original_parent, child, parent);
      var _W_ = child[9] - 1 | 0, _V_ = 1;
      if(_W_ >= 1){
       var parent_index = _V_;
       for(;;){
        var
         _Y_ =
           caml_call2
            (Incremental_Import[17][19], child[10], parent_index - 1 | 0);
        ensure_height_requirement
         (t,
          original_child,
          original_parent,
          child,
          caml_call1(Incremental_Import[16][7], _Y_));
        var _Z_ = parent_index + 1 | 0;
        if(_W_ === parent_index) break;
        var parent_index = _Z_;
       }
      }
     }
     var _X_ = child[5];
     a:
     if(typeof _X_ !== "number" && 3 === _X_[0]){
      var
       all_nodes_created_on_rhs = _X_[1][7],
       r$0 = [0, all_nodes_created_on_rhs];
      for(;;){
       if(! caml_call1(Incremental_Import[16][6], r$0[1])) break;
       var node_on_rhs = caml_call1(Incremental_Import[16][11], r$0[1]);
       r$0[1] = node_on_rhs[13];
       if(caml_call1(Incremental_Node[15], node_on_rhs))
        ensure_height_requirement
         (t, original_child, original_parent, child, node_on_rhs);
      }
      break a;
     }
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Adjust_heights);
   var
    Incremental_Adjust_heights_hea =
      [0,
       sexp_of_t$0,
       invariant$0,
       create$0,
       length,
       max_height_allowed,
       set_max_height_allowed,
       max_height_seen,
       set_height,
       adjust_heights];
   runtime.caml_register_global
    (62, Incremental_Adjust_heights_hea, cst_Incremental_Adjust_heights$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Alarm_value
//# unitInfo: Requires: Base__Field, Base__Invariant, Expect_test_collector, Incremental__At, Incremental__At_intervals, Incremental__Import, Incremental__Snapshot, Incremental__Step_function_node, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Alarm_value$0 = "Incremental__Alarm_value",
    cst$0 = "_",
    cst_action$0 = "action",
    cst_incremental$0 = "incremental",
    cst_src_alarm_value_ml = "src/alarm_value.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv;
   global_data.Base__Field;
   var
    Incremental_At = global_data.Incremental__At,
    Incremental_At_intervals = global_data.Incremental__At_intervals,
    Incremental_Snapshot = global_data.Incremental__Snapshot,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Alarm_value$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_alarm_value_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _k_ = [0, cst_src_alarm_value_ml, 30, 820, 842],
    _i_ = [0, "next_fired"],
    _j_ = [0, cst_action$0],
    _e_ = [0, cst$0],
    _c_ = [0, cst$0],
    _a_ = [0, "At"],
    _b_ = [0, "At_intervals"],
    _d_ = [0, "Snapshot"],
    _f_ = [0, "Step_function"],
    cst_action = cst_action$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Alarm_value = cst_Incremental_Alarm_value$0;
   function invariant(param){
    switch(param[0]){
      case 0:
       var at = param[1]; return caml_call1(Incremental_At[1], at);
      case 1:
       var at_intervals = param[1];
       return caml_call1(Incremental_At_intervals[1], at_intervals);
      case 2:
       var snapshot = param[1], _o_ = function(_r_){return 0;};
       return caml_call2(Incremental_Snapshot[1], _o_, snapshot);
      default:
       var step_function_node = param[1], _p_ = function(_q_){return 0;};
       return caml_call2
               (Incremental_Step_function_node[1], _p_, step_function_node);
    }
   }
   function action(r){return r[1];}
   function _g_(r, v){return [0, v, r[2]];}
   var
    _h_ = 0,
    action$0 = [0, function(param){return 0;}, cst_action, _h_, action, _g_];
   function sexp_of_t(param){
    var
     action_010 = param[1],
     next_fired_012 = param[2],
     arg_013 = caml_call1(Sexplib0_Sexp_conv[23], next_fired_012),
     bnds_009 = [0, [1, [0, _i_, [0, arg_013, 0]]], 0];
    switch(action_010[0]){
      case 0:
       var
        arg0_001 = action_010[1],
        res0_002 = caml_call1(Incremental_At[2], arg0_001),
        arg_011 = [1, [0, _a_, [0, res0_002, 0]]];
       break;
      case 1:
       var
        arg0_003 = action_010[1],
        res0_004 = caml_call1(Incremental_At_intervals[2], arg0_003),
        arg_011 = [1, [0, _b_, [0, res0_004, 0]]];
       break;
      case 2:
       var
        arg0_005 = action_010[1],
        _m_ = function(param){return _c_;},
        res0_006 = caml_call2(Incremental_Snapshot[2], _m_, arg0_005),
        arg_011 = [1, [0, _d_, [0, res0_006, 0]]];
       break;
      default:
       var
        arg0_007 = action_010[1],
        _n_ = function(param){return _e_;},
        res0_008 =
          caml_call2(Incremental_Step_function_node[2], _n_, arg0_007),
        arg_011 = [1, [0, _f_, [0, res0_008, 0]]];
    }
    var bnds_009$0 = [0, [1, [0, _j_, [0, arg_011, 0]]], bnds_009];
    return [1, bnds_009$0];
   }
   function invariant$0(t){
    function _l_(param){
     var action_fun = caml_call2(Base_Invariant[2], t, invariant);
     caml_call1(action_fun, action$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _k_, t, sexp_of_t, _l_);
   }
   function create(action){return [0, action, Incremental_Import[16][3]];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Alarm_value);
   var Incremental_Alarm_value = [0, [0], invariant$0, sexp_of_t, create];
   runtime.caml_register_global
    (31, Incremental_Alarm_value, cst_Incremental_Alarm_value$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Config_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Config_intf = "Incremental__Config_intf",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Config_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Expect_test_collector[5][1], "src/config_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Config_intf);
   var Incremental_Config_intf = [0];
   runtime.caml_register_global
    (11, Incremental_Config_intf, cst_Incremental_Config_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Config
//# unitInfo: Requires: Expect_test_collector, Incremental__Config_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Config$0 = "Incremental__Config",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Config$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/config.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Config = cst_Incremental_Config$0;
   function Default(symbol){return [0, 1];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Config);
   var Incremental_Config = [0, Default];
   runtime.caml_register_global
    (11, Incremental_Config, cst_Incremental_Config$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Internal_observer
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Core, Core__List, Expect_test_collector, Incremental__Import, Incremental__Node, Incremental__On_update_handler, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Internal_obser$0 = "Incremental__Internal_observer",
    cst$0 = "_",
    cst_incremental$0 = "incremental",
    cst_next_in_all$0 = "next_in_all",
    cst_next_in_observing$0 = "next_in_observing",
    cst_observing$0 = "observing",
    cst_on_update_handlers$0 = "on_update_handlers",
    cst_prev_in_all$0 = "prev_in_all",
    cst_prev_in_observing$0 = "prev_in_observing",
    cst_src_internal_observer_ml = "src/internal_observer.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Node = global_data.Incremental__Node,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler;
   global_data.Base__Field;
   var
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Internal_obser$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_internal_observer_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _S_ = [0, cst$0],
    _P_ = [0, cst$0],
    cst_on_update_disallowed = "on_update disallowed",
    _Q_ = [0, cst_src_internal_observer_ml, 144, 4466, 4486],
    _R_ = [0, cst_src_internal_observer_ml, 148, 32],
    _J_ = [0, cst$0],
    _N_ = [0, cst$0],
    _L_ = [0, cst$0],
    cst_Observer_value_exn_called_ =
      "Observer.value_exn called after disallow_future_use",
    _M_ = [0, cst_src_internal_observer_ml, 129, 4056, 4068],
    cst_Observer_value_exn_called_$0 =
      "Observer.value_exn called without stabilizing",
    _O_ = [0, cst_src_internal_observer_ml, 123, 3909, 3921],
    cst_attempt_to_get_value_of_an = "attempt to get value of an invalid node",
    _K_ = [0, cst_src_internal_observer_ml, 137, 4254, 4276],
    _H_ = [0, cst$0],
    _G_ = [0, cst_src_internal_observer_ml, 70, 25],
    _F_ = [0, cst_src_internal_observer_ml, 75, 36],
    _E_ = [0, cst_src_internal_observer_ml, 78, 13],
    _D_ = [0, cst_src_internal_observer_ml, 86, 36],
    _C_ = [0, cst_src_internal_observer_ml, 89, 13],
    _B_ = [0, cst_src_internal_observer_ml, 97, 36],
    _A_ = [0, cst_src_internal_observer_ml, 100, 13],
    _z_ = [0, cst_src_internal_observer_ml, 109, 36],
    _y_ = [0, cst_src_internal_observer_ml, 112, 13],
    _I_ = [0, cst_src_internal_observer_ml, 61, 1687, 1709],
    _r_ = [0, cst_next_in_observing$0],
    _s_ = [0, cst_prev_in_observing$0],
    _t_ = [0, cst_next_in_all$0],
    _u_ = [0, cst_prev_in_all$0],
    _v_ = [0, cst_on_update_handlers$0],
    _w_ = [0, cst_observing$0],
    _x_ = [0, "state"],
    _b_ = [0, "Created"],
    _c_ = [0, "In_use"],
    _d_ = [0, "Disallowed"],
    _e_ = [0, "Unlinked"],
    _a_ = [0, cst$0],
    cst_next_in_observing = cst_next_in_observing$0,
    cst_prev_in_observing = cst_prev_in_observing$0,
    cst_next_in_all = cst_next_in_all$0,
    cst_prev_in_all = cst_prev_in_all$0,
    cst_on_update_handlers = cst_on_update_handlers$0,
    cst_observing = cst_observing$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Internal_obser = cst_Incremental_Internal_obser$0;
   function sexp_of_t(param){
    var x_001 = param[2];
    function _ao_(param){return _a_;}
    return caml_call2(Incremental_Types[15][1], _ao_, x_001);
   }
   function next_in_all(param){return param[5];}
   function set_prev_in_all(param, t2){param[4] = t2; return 0;}
   function next_in_observing(r){return r[7];}
   function set_next_in_observing(r, v){r[7] = v; return 0;}
   function prev_in_observing(r){return r[6];}
   function set_prev_in_observing(r, v){r[6] = v; return 0;}
   function next_in_all$0(r){return r[5];}
   function set_next_in_all(r, v){r[5] = v; return 0;}
   function prev_in_all(r){return r[4];}
   function set_prev_in_all$0(r, v){r[4] = v; return 0;}
   function on_update_handlers(r){return r[3];}
   function set_on_update_handlers(r, v){r[3] = v; return 0;}
   function observing(r){return r[2];}
   function _f_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _g_ = [0, set_next_in_observing],
    next_in_observing$0 =
      [0,
       function(param){return 0;},
       cst_next_in_observing,
       _g_,
       next_in_observing,
       _f_];
   function _h_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _i_ = [0, set_prev_in_observing],
    prev_in_observing$0 =
      [0,
       function(param){return 0;},
       cst_prev_in_observing,
       _i_,
       prev_in_observing,
       _h_];
   function _j_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _k_ = [0, set_next_in_all],
    next_in_all$1 =
      [0,
       function(param){return 0;},
       cst_next_in_all,
       _k_,
       next_in_all$0,
       _j_];
   function _l_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _m_ = [0, set_prev_in_all$0],
    prev_in_all$0 =
      [0, function(param){return 0;}, cst_prev_in_all, _m_, prev_in_all, _l_];
   function _n_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _o_ = [0, set_on_update_handlers],
    on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_on_update_handlers,
       _o_,
       on_update_handlers,
       _n_];
   function _p_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _q_ = 0,
    observing$0 =
      [0, function(param){return 0;}, cst_observing, _q_, observing, _p_];
   function sexp_of_internal_observer(of_a_002, param){
    var
     state_004 = param[1],
     observing_006 = param[2],
     on_update_handlers_008 = param[3],
     prev_in_all_010 = param[4],
     next_in_all_012 = param[5],
     prev_in_observing_014 = param[6],
     next_in_observing_016 = param[7],
     arg_017 =
       caml_call2
        (Incremental_Import[16][1],
         Sexplib0_Sexp_conv[23],
         next_in_observing_016),
     bnds_003 = [0, [1, [0, _r_, [0, arg_017, 0]]], 0],
     arg_015 =
       caml_call2
        (Incremental_Import[16][1],
         Sexplib0_Sexp_conv[23],
         prev_in_observing_014),
     bnds_003$0 = [0, [1, [0, _s_, [0, arg_015, 0]]], bnds_003],
     arg_013 =
       caml_call2(Incremental_Import[16][1], sexp_of_t, next_in_all_012),
     bnds_003$1 = [0, [1, [0, _t_, [0, arg_013, 0]]], bnds_003$0],
     arg_011 =
       caml_call2(Incremental_Import[16][1], sexp_of_t, prev_in_all_010),
     bnds_003$2 = [0, [1, [0, _u_, [0, arg_011, 0]]], bnds_003$1],
     _an_ = caml_call1(Incremental_On_update_handler[2], of_a_002),
     arg_009 = caml_call2(Core[421], _an_, on_update_handlers_008),
     bnds_003$3 = [0, [1, [0, _v_, [0, arg_009, 0]]], bnds_003$2],
     arg_007 = caml_call2(Incremental_Node[2], of_a_002, observing_006),
     bnds_003$4 = [0, [1, [0, _w_, [0, arg_007, 0]]], bnds_003$3];
    switch(state_004){
      case 0:
       var arg_005 = _b_; break;
      case 1:
       var arg_005 = _c_; break;
      case 2:
       var arg_005 = _d_; break;
      default: var arg_005 = _e_;
    }
    var bnds_003$5 = [0, [1, [0, _x_, [0, arg_005, 0]]], bnds_003$4];
    return [1, bnds_003$5];
   }
   function incr_state(t){return t[2][2];}
   function use_is_allowed(t){return 2 <= t[1] ? 0 : 1;}
   function same(t1, t2){return caml_call2(Core[247], t1, t2);}
   function same_as_packed(t1, param){return same(t1, param);}
   function invariant(invariant_a, t){
    function _ab_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      next_in_observing_fun =
        check
         (function(next_in_observing){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[16][5], next_in_observing))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
           var
            _ak_ = caml_call1(Incremental_Import[16][6], next_in_observing);
           if(! _ak_) return _ak_;
           var
            _al_ = caml_call1(Incremental_Import[16][7], next_in_observing)[6],
            _am_ = caml_call1(Incremental_Import[16][7], _al_);
           if(caml_call2(Core[246], t, _am_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
          }),
      prev_in_observing_fun =
        check
         (function(prev_in_observing){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[16][5], prev_in_observing))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
           var
            _ah_ = caml_call1(Incremental_Import[16][6], prev_in_observing);
           if(! _ah_) return _ah_;
           var
            _ai_ = caml_call1(Incremental_Import[16][7], prev_in_observing)[7],
            _aj_ = caml_call1(Incremental_Import[16][7], _ai_);
           if(caml_call2(Core[246], t, _aj_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          }),
      next_in_all_fun =
        check
         (function(next_in_all){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[16][5], next_in_all))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
           var _af_ = caml_call1(Incremental_Import[16][6], next_in_all);
           if(! _af_) return _af_;
           var _ag_ = caml_call1(Incremental_Import[16][7], next_in_all)[4];
           if(same_as_packed(t, caml_call1(Incremental_Import[16][7], _ag_)))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
          }),
      prev_in_all_fun =
        check
         (function(prev_in_all){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[16][5], prev_in_all))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
           var _ad_ = caml_call1(Incremental_Import[16][6], prev_in_all);
           if(! _ad_) return _ad_;
           var _ae_ = caml_call1(Incremental_Import[16][7], prev_in_all)[5];
           if(same_as_packed(t, caml_call1(Incremental_Import[16][7], _ae_)))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
          }),
      on_update_handlers_fun =
        check
         (function(on_update_handlers){
           if(3 > t[1]) return 0;
           if(caml_call1(Core_List[8], on_update_handlers)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
          }),
      observing_fun = check(caml_call1(Incremental_Node[4], invariant_a));
     caml_call1(observing_fun, observing$0);
     caml_call1(on_update_handlers_fun, on_update_handlers$0);
     caml_call1(prev_in_all_fun, prev_in_all$0);
     caml_call1(next_in_all_fun, next_in_all$1);
     caml_call1(prev_in_observing_fun, prev_in_observing$0);
     return caml_call1(next_in_observing_fun, next_in_observing$0);
    }
    function _ac_(x_020){
     return sexp_of_internal_observer(function(param){return _H_;}, x_020);
    }
    return caml_call4(Base_Invariant[1], _I_, t, _ac_, _ab_);
   }
   function value_exn(t){
    var _Z_ = t[1];
    if(1 === _Z_){
     var uopt = t[2][4];
     if(caml_call1(Incremental_Import[16][5], uopt)){
      var
       ___ =
         function(x_023){
          return sexp_of_internal_observer
                  (function(param){return _J_;}, x_023);
         };
      caml_call5(Core[236], 0, _K_, cst_attempt_to_get_value_of_an, t, ___);
     }
     return caml_call1(Incremental_Import[16][11], uopt);
    }
    if(_Z_){
     var
      _$_ =
        function(x_022){
         return sexp_of_internal_observer(function(param){return _L_;}, x_022);
        };
     return caml_call5
             (Core[236], 0, _M_, cst_Observer_value_exn_called_, t, _$_);
    }
    function _aa_(x_021){
     return sexp_of_internal_observer(function(param){return _N_;}, x_021);
    }
    return caml_call5
            (Core[236], 0, _O_, cst_Observer_value_exn_called_$0, t, _aa_);
   }
   function on_update_exn(t, on_update_handler){
    if(2 <= t[1]){
     var
      _X_ =
        function(x_024){
         return sexp_of_internal_observer(function(param){return _P_;}, x_024);
        };
     return caml_call5(Core[236], 0, _Q_, cst_on_update_disallowed, t, _X_);
    }
    t[3] = [0, on_update_handler, t[3]];
    var _Y_ = t[1];
    if(1 === _Y_){
     var observing = t[2];
     observing[8] = observing[8] + 1 | 0;
     return 0;
    }
    if(_Y_) throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
    return 0;
   }
   function unlink(t){
    var prev = t[6], next = t[7];
    t[6] = Incremental_Import[16][3];
    t[7] = Incremental_Import[16][3];
    if(caml_call1(Incremental_Import[16][6], next))
     caml_call1(Incremental_Import[16][11], next)[6] = prev;
    if(caml_call1(Incremental_Import[16][6], prev))
     caml_call1(Incremental_Import[16][11], prev)[7] = next;
    var
     observing = t[2],
     _U_ = caml_call1(Incremental_Import[16][7], observing[21]);
    if(caml_call2(Core[246], t, _U_)) observing[21] = next;
    var _V_ = caml_call1(Core_List[7], t[3]);
    observing[8] = observing[8] - _V_ | 0;
    t[3] = 0;
    var prev$0 = t[4], next$0 = t[5];
    t[4] = Incremental_Import[16][3];
    t[5] = Incremental_Import[16][3];
    if(caml_call1(Incremental_Import[16][6], next$0))
     set_prev_in_all(caml_call1(Incremental_Import[16][11], next$0), prev$0);
    var _W_ = caml_call1(Incremental_Import[16][6], prev$0);
    return _W_
            ? (caml_call1(Incremental_Import[16][11], prev$0)[5] = next$0, 0)
            : _W_;
   }
   function sexp_of_t$0(x_025){
    return sexp_of_internal_observer(function(param){return _S_;}, x_025);
   }
   function invariant$0(param){
    return invariant(function(_T_){return 0;}, param);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Internal_obser);
   var
    Incremental_Internal_observer =
      [0,
       invariant,
       sexp_of_internal_observer,
       same,
       observing,
       use_is_allowed,
       value_exn,
       on_update_exn,
       unlink,
       incr_state,
       [0, sexp_of_t$0, invariant$0, next_in_all, set_prev_in_all]];
   runtime.caml_register_global
    (66, Incremental_Internal_observer, cst_Incremental_Internal_obser$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Observer
//# unitInfo: Requires: Core, Expect_test_collector, Incremental__Internal_observer, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Observer$0 = "Incremental__Observer",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_Internal_observer = global_data.Incremental__Internal_observer,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Observer$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/observer.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Observer = cst_Incremental_Observer$0;
   function sexp_of_t(of_a_001, x_002){
    var _a_ = caml_call1(Incremental_Internal_observer[2], of_a_001);
    return caml_call2(Core[501], _a_, x_002);
   }
   function invariant(invariant_a, t){
    return caml_call2(Incremental_Internal_observer[1], invariant_a, t[1]);
   }
   function observing(t){
    return caml_call1(Incremental_Internal_observer[4], t[1]);
   }
   function use_is_allowed(t){
    return caml_call1(Incremental_Internal_observer[5], t[1]);
   }
   function value_exn(t){
    return caml_call1(Incremental_Internal_observer[6], t[1]);
   }
   function incr_state(t){
    return caml_call1(Incremental_Internal_observer[9], t[1]);
   }
   function on_update_exn(t, on_update_handler){
    return caml_call2
            (Incremental_Internal_observer[7], t[1], on_update_handler);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Observer);
   var
    Incremental_Observer =
      [0,
       invariant,
       sexp_of_t,
       observing,
       use_is_allowed,
       value_exn,
       on_update_exn,
       incr_state];
   runtime.caml_register_global
    (13, Incremental_Observer, cst_Incremental_Observer$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__State
//# unitInfo: Requires: Assert_failure, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Error, Core__Fn, Core__Gc, Core__Hashtbl, Core__Int, Core__Lazy, Core__List, Core__Option, Core__Or_error, Core__Percent, Core__Sequence, Core__Stack, Core__Tuple, Expect_test_collector, Incremental__Adjust_heights_heap, Incremental__Alarm, Incremental__Alarm_value, Incremental__Array_fold, Incremental__Cutoff, Incremental__Expert, Incremental__Import, Incremental__Internal_observer, Incremental__Kind, Incremental__Node, Incremental__Observer, Incremental__On_update_handler, Incremental__Raised_exn, Incremental__Recompute_heap, Incremental__Scope, Incremental__Stabilization_num, Incremental__Step_function_node, Incremental__Unordered_array_fold, Incremental__Var, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Thread_safe_queue, Timing_wheel, Weak_hashtbl
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_during_stabilization$0 = " during stabilization",
    cst_Incremental_State$0 = "Incremental__State",
    cst_T = "T",
    cst$0 = "_",
    cst_adjust_heights_heap$0 = "adjust_heights_heap",
    cst_all_observers$0 = "all_observers",
    cst_bind_lhs_change_should_inv$0 = "bind_lhs_change_should_invalidate_rhs",
    cst_can_only_call$2 = "can only call ",
    cst_cannot = "cannot ",
    cst_current_kind = "current.kind",
    cst_current_scope$0 = "current_scope",
    cst_currently_running_node$0 = "currently_running_node",
    cst_disallowed_observers$0 = "disallowed_observers",
    cst_expert_nodes_created_by_cu$0 = "expert_nodes_created_by_current_node",
    cst_finalized_observers$0 = "finalized_observers",
    cst_fired_alarm_values$0 = "fired_alarm_values",
    cst_handle_after_stabilization$0 = "handle_after_stabilization",
    cst_handle_fired$0 = "handle_fired",
    cst_incremental$0 = "incremental",
    cst_keep_node_creation_backtra$0 = "keep_node_creation_backtrace",
    cst_max_num_parents$0 = "max_num_parents",
    cst_new_observers$0 = "new_observers",
    cst_node_kind = "node.kind",
    cst_now$0 = "now",
    cst_num_active_observers$0 = "num_active_observers",
    cst_num_nodes_became_necessary$0 = "num_nodes_became_necessary",
    cst_num_nodes_became_unnecessa$0 = "num_nodes_became_unnecessary",
    cst_num_nodes_changed$0 = "num_nodes_changed",
    cst_num_nodes_created$0 = "num_nodes_created",
    cst_num_nodes_invalidated$0 = "num_nodes_invalidated",
    cst_num_nodes_recomputed$0 = "num_nodes_recomputed",
    cst_num_nodes_recomputed_direc$1 =
      "num_nodes_recomputed_directly_because_min_height",
    cst_num_nodes_recomputed_direc$2 =
      "num_nodes_recomputed_directly_because_one_child",
    cst_num_var_sets$0 = "num_var_sets",
    cst_only_in_debug$0 = "only_in_debug",
    cst_percentage_of_nodes_by_num$0 = "percentage_of_nodes_by_num_parents",
    cst_propagate_invalidity$0 = "propagate_invalidity",
    cst_recompute_heap$0 = "recompute_heap",
    cst_run_on_update_handlers$0 = "run_on_update_handlers",
    cst_set_during_stabilization$0 = "set_during_stabilization",
    cst_src_state_ml = "src/state.ml",
    cst_stabilization_num$0 = "stabilization_num",
    cst_status$0 = "status",
    cst_timing_wheel$0 = "timing_wheel",
    cst_weak_hashtbls$0 = "weak_hashtbls",
    caml_check_bound = runtime.caml_check_bound,
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   function caml_call13
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    return (f.l >= 0 ? f.l : f.l = f.length) == 13
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   function caml_call15
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14){
    return (f.l >= 0 ? f.l : f.l = f.length) == 15
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14]);
   }
   function caml_call27
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26){
    return (f.l >= 0 ? f.l : f.l = f.length) == 27
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_currently_running_node$0,
       [0, cst_expert_nodes_created_by_cu$0, 0]],
    names$0 =
      caml_list_of_js_array
       ([cst_status$0,
         cst_bind_lhs_change_should_inv$0,
         cst_stabilization_num$0,
         cst_current_scope$0,
         cst_recompute_heap$0,
         cst_adjust_heights_heap$0,
         cst_propagate_invalidity$0,
         cst_num_active_observers$0,
         cst_all_observers$0,
         cst_finalized_observers$0,
         cst_new_observers$0,
         cst_disallowed_observers$0,
         cst_set_during_stabilization$0,
         cst_handle_after_stabilization$0,
         cst_run_on_update_handlers$0,
         cst_only_in_debug$0,
         cst_weak_hashtbls$0,
         cst_keep_node_creation_backtra$0,
         cst_num_nodes_became_necessary$0,
         cst_num_nodes_became_unnecessa$0,
         cst_num_nodes_changed$0,
         cst_num_nodes_created$0,
         cst_num_nodes_invalidated$0,
         cst_num_nodes_recomputed$0,
         cst_num_nodes_recomputed_direc$2,
         cst_num_nodes_recomputed_direc$1,
         cst_num_var_sets$0]),
    names$1 =
      [0,
       cst_timing_wheel$0,
       [0,
        cst_now$0,
        [0, cst_handle_fired$0, [0, cst_fired_alarm_values$0, 0]]]],
    error_source_095 = "src/state.ml.Stats.t",
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Expert = global_data.Incremental__Expert,
    Incremental_Unordered_array_fo =
      global_data.Incremental__Unordered_array_fold,
    Assert_failure = global_data.Assert_failure,
    Incremental_Recompute_heap = global_data.Incremental__Recompute_heap,
    Incremental_Scope = global_data.Incremental__Scope,
    Core_Stack = global_data.Core__Stack,
    Core = global_data.Core,
    Incremental_Array_fold = global_data.Incremental__Array_fold,
    Incremental_Kind = global_data.Incremental__Kind,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_step_function = global_data.Incremental_step_function,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Core_Sequence = global_data.Core__Sequence,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Core_List = global_data.Core__List,
    Core_Option = global_data.Core__Option,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Weak_hashtbl = global_data.Weak_hashtbl,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Incremental_Adjust_heights_hea =
      global_data.Incremental__Adjust_heights_heap,
    Timing_wheel = global_data.Timing_wheel,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Incremental_Alarm_value = global_data.Incremental__Alarm_value,
    Core_Or_error = global_data.Core__Or_error,
    Core_Fn = global_data.Core__Fn,
    Core_Int = global_data.Core__Int,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Lazy = global_data.Core__Lazy,
    Core_Gc = global_data.Core__Gc,
    Core_Tuple = global_data.Core__Tuple,
    Incremental_Raised_exn = global_data.Incremental__Raised_exn,
    Incremental_Var = global_data.Incremental__Var,
    Incremental_Observer = global_data.Incremental__Observer,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Core_Error = global_data.Core__Error,
    Incremental_Internal_observer = global_data.Incremental__Internal_observer,
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Invariant = global_data.Base__Invariant,
    Core_Percent = global_data.Core__Percent,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_State$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_state_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    _bv_ = [0, cst_src_state_ml, 396, 16],
    _bx_ = [0, cst_src_state_ml, 437, 18],
    _bw_ = [0, cst_src_state_ml, 470, 18],
    _bB_ = [0, cst_src_state_ml, 550, 16],
    _bE_ = [0, cst_src_state_ml, 584, 18],
    _bC_ = [0, cst$0],
    cst_Trying_to_make_a_node_nece =
      "Trying to make a node necessary whose defining bind is not necessary",
    _bD_ = [0, cst_src_state_ml, 568, 26058, 26070],
    _bF_ = [0, cst_src_state_ml, 589, 16],
    _bG_ = [0, cst_src_state_ml, 590, 16],
    _bL_ = [0, cst_src_state_ml, 766, 4],
    _bM_ = [0, cst_src_state_ml, 815, 21],
    _bN_ = [0, cst_src_state_ml, 696, 18],
    _bO_ = [0, cst_src_state_ml, 739, 18],
    _bP_ = [0, cst_src_state_ml, 784, 18],
    _bX_ = [0, cst_src_state_ml, 1032, 22],
    _bW_ = [0, cst_src_state_ml, 1065, 20],
    _bR_ = [0, cst_src_state_ml, 1070, 29],
    _bU_ = [0, cst_src_state_ml, 1072, 20],
    _bV_ = [0, cst_src_state_ml, 1073, 30],
    _bQ_ = [0, cst_src_state_ml, 1074, 54],
    _bT_ = [0, cst_src_state_ml, 1128, 24],
    _bS_ = [0, cst_src_state_ml, 1129, 24],
    cst_remove_dependency = "remove_dependency",
    _cq_ = [0, cst_src_state_ml, 2108, 20],
    cst_add_dependency = "add_dependency",
    _cp_ = [0, cst_src_state_ml, 2078, 22],
    cst_invalidate = "invalidate",
    cst_make_stale = "make_stale",
    _cn_ = [0, cst$0],
    _cl_ = [0, cst$0],
    _cm_ = [0, cst_current_kind],
    _co_ = [0, cst_node_kind],
    cst_on_children_nodes = " on children nodes",
    cst_can_only_call$1 = cst_can_only_call$2,
    _cj_ = [0, cst$0],
    _ch_ = [0, cst$0],
    _ci_ = [0, cst_current_kind],
    _ck_ = [0, cst_node_kind],
    cst_on_parent_nodes = " on parent nodes",
    cst_can_only_call$0 = cst_can_only_call$2,
    cst_during_stabilization = cst_during_stabilization$0,
    cst_can_only_call = cst_can_only_call$2,
    _cg_ = [0, cst$0],
    cst_unexpected_kind_for_expert = "unexpected kind for expert node",
    cst_advance_clock = "advance_clock",
    _ce_ = [5, 1],
    _cf_ = [0, cst_src_state_ml, 1899, 22],
    cst_cannot_take_snapshot_in_th = "cannot take snapshot in the past",
    cst_at_intervals_got_too_small = "at_intervals got too small interval",
    _cd_ = [0, cst_src_state_ml, 1806, 69449, 69461],
    _cb_ = [0, 0],
    _cc_ = [0, cst_src_state_ml, 1797, 16],
    _ca_ = [0, cst_src_state_ml, 1764, 16],
    cst_unordered_array_fold_got_n =
      "unordered_array_fold got non-positive full_compute_every_n_changes",
    _b$_ = [0, cst_src_state_ml, 1675, 65886, 65898],
    cst_step = "step",
    _b__ = [0, cst_src_state_ml, 1417, 6],
    _b8_ = [0, "Done"],
    _b9_ = [0, "Keep_going"],
    cst_stabilize = "stabilize",
    cst_cannot_set_var_stabilizati =
      "cannot set var -- stabilization previously raised",
    _b7_ = [0, cst_src_state_ml, 1304, 53749, 53761],
    _b6_ = [0, cst_src_state_ml, 1292, 18],
    _b3_ = [0, cst$0],
    cst_Observer_value_exn_called_ =
      "Observer.value_exn called during stabilization",
    _b4_ = [0, cst_src_state_ml, 1261, 52394, 52406],
    cst_Observer_value_exn_called_$0 =
      "Observer.value_exn called after stabilize previously raised",
    _b5_ = [0, cst_src_state_ml, 1255, 52225, 52237],
    _b1_ = [0, cst_src_state_ml, 1219, 29],
    _b2_ = [0, cst_src_state_ml, 1244, 20],
    _b0_ = [0, cst_src_state_ml, 1152, 6],
    _bY_ = [0, cst$0],
    cst_node_unexpectedly_does_not =
      "node unexpectedly does not need to be computed",
    _bZ_ = [0, cst_src_state_ml, 1139, 47947, 47959],
    _bK_ = [0, cst_src_state_ml, 678, 16],
    cst_attempt_to_run_within_an_i = "attempt to run within an invalid scope",
    _bJ_ = [0, cst_src_state_ml, 644, 29003, 29026],
    _bI_ = [0, cst_src_state_ml, 603, 16],
    _bH_ = [0, cst_src_state_ml, 621, 16],
    _bz_ = [0, cst_src_state_ml, 522, 22],
    _by_ = [0, cst_src_state_ml, 533, 20],
    cst_set_max_height_allowed = "set_max_height_allowed",
    _bp_ =
      [0,
       [11, cst_cannot, [2, 0, [11, cst_during_stabilization$0, 0]]],
       "cannot %s during stabilization"],
    _bq_ = [0, cst_src_state_ml, 346, 15414, 15426],
    _br_ =
      [0,
       [11, cst_cannot, [2, 0, [11, " during on-update handlers", 0]]],
       "cannot %s during on-update handlers"],
    _bs_ = [0, cst_src_state_ml, 332, 14948, 14962],
    _bt_ =
      [0,
       [11, cst_cannot, [2, 0, [11, " -- stabilize previously raised", 0]]],
       "cannot %s -- stabilize previously raised"],
    _bu_ = [0, cst_src_state_ml, 339, 15182, 15194],
    _bm_ = [0, cst_src_state_ml, 262, 39],
    _bl_ = [0, cst_src_state_ml, 266, 13],
    _bk_ = [0, cst_src_state_ml, 270, 13],
    _bj_ = [0, cst_src_state_ml, 272, 46],
    _bi_ = [0, cst_src_state_ml, 287, 41],
    _bh_ = [0, cst_src_state_ml, 295, 49],
    _bf_ = [0, cst_src_state_ml, 305, 20],
    _be_ = [0, cst_src_state_ml, 301, 15],
    _bg_ = [0, cst_src_state_ml, 299, 48],
    _bd_ = [0, cst_src_state_ml, 251, 39],
    _bc_ = [0, cst_src_state_ml, 252, 8],
    _ba_ = [0, cst$0],
    cst_member_of_all_observers_wi =
      "member of all_observers with unexpected state",
    _bb_ = [0, cst_src_state_ml, 244, 10839, 10858],
    _bn_ = [0, cst_src_state_ml, 254, 6],
    _bo_ = [0, cst_src_state_ml, 237, 10540, 10564],
    cst_cannot_call_am_stabilizing =
      "cannot call am_stabilizing -- stabilize previously raised",
    _a$_ = [0, cst_src_state_ml, 227, 10256, 10268],
    _a9_ = [0, cst_percentage_of_nodes_by_num$0],
    _a__ = [0, cst_max_num_parents$0],
    _a8_ = [0, cst_src_state_ml, 193, 2],
    cst_percentage_of_nodes_by_num = cst_percentage_of_nodes_by_num$0,
    cst_max_num_parents = cst_max_num_parents$0,
    _a6_ = [0, cst_src_state_ml, 156, 13],
    _a5_ = [0, cst_src_state_ml, 159, 44],
    _a7_ = [0, cst_src_state_ml, 151, 7499, 7523],
    _a1_ = [0, cst_fired_alarm_values$0],
    _a2_ = [0, cst_handle_fired$0],
    _a3_ = [0, cst_now$0],
    _a4_ = [0, cst_timing_wheel$0],
    _as_ = [0, cst_num_var_sets$0],
    _at_ = [0, cst_num_nodes_recomputed_direc$1],
    _au_ = [0, cst_num_nodes_recomputed_direc$2],
    _av_ = [0, cst_num_nodes_recomputed$0],
    _aw_ = [0, cst_num_nodes_invalidated$0],
    _ax_ = [0, cst_num_nodes_created$0],
    _ay_ = [0, cst_num_nodes_changed$0],
    _az_ = [0, cst_num_nodes_became_unnecessa$0],
    _aA_ = [0, cst_num_nodes_became_necessary$0],
    _aB_ = [0, cst_keep_node_creation_backtra$0],
    _aC_ = [0, cst_weak_hashtbls$0],
    _aD_ = [0, cst_only_in_debug$0],
    _aE_ = [0, cst_run_on_update_handlers$0],
    _aF_ = [0, cst_handle_after_stabilization$0],
    _aG_ = [0, cst_set_during_stabilization$0],
    _aH_ = [0, cst_disallowed_observers$0],
    _aI_ = [0, cst_new_observers$0],
    _aJ_ = [0, cst_finalized_observers$0],
    _aK_ = [0, cst_all_observers$0],
    _aL_ = [0, cst_num_active_observers$0],
    _aM_ = [0, cst_propagate_invalidity$0],
    _aN_ = [0, cst_adjust_heights_heap$0],
    _aO_ = [0, cst_recompute_heap$0],
    _aP_ = [0, cst_current_scope$0],
    _aQ_ = [0, cst_stabilization_num$0],
    _aR_ = [0, cst_bind_lhs_change_should_inv$0],
    _aS_ = [0, cst_status$0],
    _q_ = [0, cst$0],
    _p_ = [0, cst$0],
    _r_ = [0, cst_T],
    _o_ = [0, cst_src_state_ml, 38, 1149, 1173],
    _m_ = [0, cst_expert_nodes_created_by_cu$0],
    _n_ = [0, cst_currently_running_node$0],
    _h_ = [0, cst_src_state_ml, 25, 715, 739],
    _f_ = [0, cst$0],
    _e_ = [0, cst$0],
    _g_ = [0, cst_T],
    _a_ = [0, "Stabilizing"],
    _b_ = [0, "Running_on_update_handlers"],
    _c_ = [0, "Not_stabilizing"],
    _d_ = [0, "Stabilize_previously_raised"],
    cst_expert_nodes_created_by_cu = cst_expert_nodes_created_by_cu$0,
    cst_currently_running_node = cst_currently_running_node$0,
    cst_num_var_sets = cst_num_var_sets$0,
    cst_num_nodes_recomputed_direc = cst_num_nodes_recomputed_direc$1,
    cst_num_nodes_recomputed_direc$0 = cst_num_nodes_recomputed_direc$2,
    cst_num_nodes_recomputed = cst_num_nodes_recomputed$0,
    cst_num_nodes_invalidated = cst_num_nodes_invalidated$0,
    cst_num_nodes_created = cst_num_nodes_created$0,
    cst_num_nodes_changed = cst_num_nodes_changed$0,
    cst_num_nodes_became_unnecessa = cst_num_nodes_became_unnecessa$0,
    cst_num_nodes_became_necessary = cst_num_nodes_became_necessary$0,
    cst_keep_node_creation_backtra = cst_keep_node_creation_backtra$0,
    cst_weak_hashtbls = cst_weak_hashtbls$0,
    cst_only_in_debug = cst_only_in_debug$0,
    cst_run_on_update_handlers = cst_run_on_update_handlers$0,
    cst_handle_after_stabilization = cst_handle_after_stabilization$0,
    cst_set_during_stabilization = cst_set_during_stabilization$0,
    cst_disallowed_observers = cst_disallowed_observers$0,
    cst_new_observers = cst_new_observers$0,
    cst_finalized_observers = cst_finalized_observers$0,
    cst_all_observers = cst_all_observers$0,
    cst_num_active_observers = cst_num_active_observers$0,
    cst_propagate_invalidity = cst_propagate_invalidity$0,
    cst_adjust_heights_heap = cst_adjust_heights_heap$0,
    cst_recompute_heap = cst_recompute_heap$0,
    cst_current_scope = cst_current_scope$0,
    cst_stabilization_num = cst_stabilization_num$0,
    cst_bind_lhs_change_should_inv = cst_bind_lhs_change_should_inv$0,
    cst_status = cst_status$0,
    cst_fired_alarm_values = cst_fired_alarm_values$0,
    cst_handle_fired = cst_handle_fired$0,
    cst_now = cst_now$0,
    cst_timing_wheel = cst_timing_wheel$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_State = cst_Incremental_State$0;
   function sexp_of_status(param){
    if(typeof param === "number")
     switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;}
    var
     arg0_001 = param[1],
     res0_002 = caml_call1(Incremental_Raised_exn[1], arg0_001);
    return [1, [0, _d_, [0, res0_002, 0]]];
   }
   function sexp_of_t(param){
    var arg1_004 = param[2], arg0_003 = param[1];
    function _m8_(param){return _e_;}
    var res0_005 = caml_call2(Incremental_Node[2], _m8_, arg0_003);
    function _m9_(param){return _f_;}
    var
     res1_006 =
       caml_call2(Incremental_On_update_handler[1][2], _m9_, arg1_004);
    return [1, [0, _g_, [0, res0_005, [0, res1_006, 0]]]];
   }
   function invariant(t){
    var node = t[1];
    function _m5_(param){
     function _m6_(_m7_){return 0;}
     return caml_call2(Incremental_Node[4], _m6_, node);
    }
    return caml_call4(Base_Invariant[1], _h_, t, sexp_of_t, _m5_);
   }
   var Run_on_update_handlers = [0, sexp_of_t, invariant];
   function expert_nodes_created_by_curren(r){return r[2];}
   function set_expert_nodes_created_by_cu(r, v){r[2] = v; return 0;}
   function currently_running_node(r){return r[1];}
   function set_currently_running_node(r, v){r[1] = v; return 0;}
   function _i_(r, v){return [0, r[1], v];}
   var
    _j_ = [0, set_expert_nodes_created_by_cu],
    expert_nodes_created_by_curren$0 =
      [0,
       function(param){return 0;},
       cst_expert_nodes_created_by_cu,
       _j_,
       expert_nodes_created_by_curren,
       _i_];
   function _k_(r, v){return [0, v, r[2]];}
   var
    _l_ = [0, set_currently_running_node],
    currently_running_node$0 =
      [0,
       function(param){return 0;},
       cst_currently_running_node,
       _l_,
       currently_running_node,
       _k_];
   function make_creator
   (currently_running_node_fun, expert_nodes_created_by_curren, compile_acc){
    var
     match =
       caml_call2
        (currently_running_node_fun, currently_running_node$0, compile_acc),
     compile_acc$0 = match[2],
     currently_running_node_gen = match[1],
     match$0 =
       caml_call2
        (expert_nodes_created_by_curren,
         expert_nodes_created_by_curren$0,
         compile_acc$0),
     compile_acc$1 = match$0[2],
     expert_nodes_created_by_curren$1 = match$0[1];
    return [0,
            function(acc){
             var
              currently_running_node =
                caml_call1(currently_running_node_gen, acc),
              expert_nodes_created_by_curren =
                caml_call1(expert_nodes_created_by_curren$1, acc);
             return [0,
                     currently_running_node,
                     expert_nodes_created_by_curren];
            },
            compile_acc$1];
   }
   function create(currently_running_node, expert_nodes_created_by_curren){return [0, currently_running_node, expert_nodes_created_by_curren];
   }
   function map(currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _m4_ =
       caml_call1
        (expert_nodes_created_by_curren, expert_nodes_created_by_curren$0);
    return [0,
            caml_call1(currently_running_node_fun, currently_running_node$0),
            _m4_];
   }
   function iter(currently_running_node_fun, expert_nodes_created_by_curren){
    caml_call1(currently_running_node_fun, currently_running_node$0);
    return caml_call1
            (expert_nodes_created_by_curren, expert_nodes_created_by_curren$0);
   }
   function fold
   (init, currently_running_node_fun, expert_nodes_created_by_curren){
    return caml_call2
            (expert_nodes_created_by_curren,
             caml_call2
              (currently_running_node_fun, init, currently_running_node$0),
             expert_nodes_created_by_curren$0);
   }
   function map_poly(record){
    var
     _m3_ = [0, caml_call1(record[1], expert_nodes_created_by_curren$0), 0];
    return [0, caml_call1(record[1], currently_running_node$0), _m3_];
   }
   function for_all
   (currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _m2_ = caml_call1(currently_running_node_fun, currently_running_node$0);
    return _m2_
            ? caml_call1
              (expert_nodes_created_by_curren,
               expert_nodes_created_by_curren$0)
            : _m2_;
   }
   function exists(currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _m1_ = caml_call1(currently_running_node_fun, currently_running_node$0);
    return _m1_
            ? _m1_
            : caml_call1
              (expert_nodes_created_by_curren,
               expert_nodes_created_by_curren$0);
   }
   function to_list
   (currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _m0_ =
       [0,
        caml_call1
         (expert_nodes_created_by_curren, expert_nodes_created_by_curren$0),
        0];
    return [0,
            caml_call1(currently_running_node_fun, currently_running_node$0),
            _m0_];
   }
   function iter$0
   (record, currently_running_node_fun, expert_nodes_created_by_curren){
    caml_call3
     (currently_running_node_fun, currently_running_node$0, record, record[1]);
    return caml_call3
            (expert_nodes_created_by_curren,
             expert_nodes_created_by_curren$0,
             record,
             record[2]);
   }
   function fold$0
   (record, init, currently_running_node_fun, expert_nodes_created_by_curren){
    var _mZ_ = record[2];
    return caml_call4
            (expert_nodes_created_by_curren,
             caml_call4
              (currently_running_node_fun,
               init,
               currently_running_node$0,
               record,
               record[1]),
             expert_nodes_created_by_curren$0,
             record,
             _mZ_);
   }
   function for_all$0
   (record, currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _mY_ =
       caml_call3
        (currently_running_node_fun,
         currently_running_node$0,
         record,
         record[1]);
    return _mY_
            ? caml_call3
              (expert_nodes_created_by_curren,
               expert_nodes_created_by_curren$0,
               record,
               record[2])
            : _mY_;
   }
   function exists$0
   (record, currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _mX_ =
       caml_call3
        (currently_running_node_fun,
         currently_running_node$0,
         record,
         record[1]);
    return _mX_
            ? _mX_
            : caml_call3
              (expert_nodes_created_by_curren,
               expert_nodes_created_by_curren$0,
               record,
               record[2]);
   }
   function to_list$0
   (record, currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _mW_ =
       [0,
        caml_call3
         (expert_nodes_created_by_curren,
          expert_nodes_created_by_curren$0,
          record,
          record[2]),
        0];
    return [0,
            caml_call3
             (currently_running_node_fun,
              currently_running_node$0,
              record,
              record[1]),
            _mW_];
   }
   function map$0
   (record, currently_running_node_fun, expert_nodes_created_by_curren){
    var
     _mV_ =
       caml_call3
        (expert_nodes_created_by_curren,
         expert_nodes_created_by_curren$0,
         record,
         record[2]);
    return [0,
            caml_call3
             (currently_running_node_fun,
              currently_running_node$0,
              record,
              record[1]),
            _mV_];
   }
   function set_all_mutable_fields
   (record, currently_running_node, expert_nodes_created_by_curren){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = currently_running_node;
    record$0[2] = expert_nodes_created_by_curren;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       expert_nodes_created_by_curren$0,
       currently_running_node$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function sexp_of_t$0(param){
    var
     currently_running_node_008 = param[1],
     expert_nodes_created_by_curren = param[2],
     arg_011 =
       caml_call2
        (Core[421], Incremental_Node[1][1], expert_nodes_created_by_curren),
     bnds_007 = [0, [1, [0, _m_, [0, arg_011, 0]]], 0],
     arg_009 =
       caml_call2
        (Core[454], Incremental_Node[1][1], currently_running_node_008),
     bnds_007$0 = [0, [1, [0, _n_, [0, arg_009, 0]]], bnds_007];
    return [1, bnds_007$0];
   }
   function invariant$0(t){
    function _mQ_(param){
     function _mR_(_mU_){return 0;}
     function _mS_(_mT_){return 0;}
     return caml_call2(Fields[7], _mS_, _mR_);
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t$0, _mQ_);
   }
   function create$0(param){return [0, 0, 0];}
   var
    Only_in_debug =
      [0,
       expert_nodes_created_by_curren,
       set_expert_nodes_created_by_cu,
       currently_running_node,
       set_currently_running_node,
       Fields,
       sexp_of_t$0,
       invariant$0,
       create$0];
   function sexp_of_t$1(param){
    var arg0_012 = param[1];
    function _mO_(param){return _p_;}
    function _mP_(param){return _q_;}
    var res0_013 = caml_call3(Weak_hashtbl[1], _mP_, _mO_, arg0_012);
    return [1, [0, _r_, [0, res0_013, 0]]];
   }
   var Packed_weak_hashtbl = [0, sexp_of_t$1];
   function num_var_sets(r){return r[27];}
   function set_num_var_sets(r, v){r[27] = v; return 0;}
   function num_nodes_recomputed_directly_(r){return r[26];}
   function set_num_nodes_recomputed_direc(r, v){r[26] = v; return 0;}
   function num_nodes_recomputed_directly_$0(r){return r[25];}
   function set_num_nodes_recomputed_direc$0(r, v){r[25] = v; return 0;}
   function num_nodes_recomputed(r){return r[24];}
   function set_num_nodes_recomputed(r, v){r[24] = v; return 0;}
   function num_nodes_invalidated(r){return r[23];}
   function set_num_nodes_invalidated(r, v){r[23] = v; return 0;}
   function num_nodes_created(r){return r[22];}
   function set_num_nodes_created(r, v){r[22] = v; return 0;}
   function num_nodes_changed(r){return r[21];}
   function set_num_nodes_changed(r, v){r[21] = v; return 0;}
   function num_nodes_became_unnecessary(r){return r[20];}
   function set_num_nodes_became_unnecessa(r, v){r[20] = v; return 0;}
   function num_nodes_became_necessary(r){return r[19];}
   function set_num_nodes_became_necessary(r, v){r[19] = v; return 0;}
   function keep_node_creation_backtrace(r){return r[18];}
   function set_keep_node_creation_backtra(r, v){r[18] = v; return 0;}
   function weak_hashtbls(r){return r[17];}
   function only_in_debug(r){return r[16];}
   function set_only_in_debug(r, v){r[16] = v; return 0;}
   function run_on_update_handlers(r){return r[15];}
   function handle_after_stabilization(r){return r[14];}
   function set_during_stabilization(r){return r[13];}
   function disallowed_observers(r){return r[12];}
   function new_observers(r){return r[11];}
   function finalized_observers(r){return r[10];}
   function all_observers(r){return r[9];}
   function set_all_observers(r, v){r[9] = v; return 0;}
   function num_active_observers(r){return r[8];}
   function set_num_active_observers(r, v){r[8] = v; return 0;}
   function propagate_invalidity(r){return r[7];}
   function adjust_heights_heap(r){return r[6];}
   function recompute_heap(r){return r[5];}
   function current_scope(r){return r[4];}
   function set_current_scope(r, v){r[4] = v; return 0;}
   function stabilization_num(r){return r[3];}
   function set_stabilization_num(r, v){r[3] = v; return 0;}
   function bind_lhs_change_should_invalid(r){return r[2];}
   function status(r){return r[1];}
   function set_status(r, v){r[1] = v; return 0;}
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v];
   }
   var
    _t_ = [0, set_num_var_sets],
    num_var_sets$0 =
      [0,
       function(param){return 0;},
       cst_num_var_sets,
       _t_,
       num_var_sets,
       _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v,
            r[27]];
   }
   var
    _v_ = [0, set_num_nodes_recomputed_direc],
    num_nodes_recomputed_directly_$1 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed_direc,
       _v_,
       num_nodes_recomputed_directly_,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27]];
   }
   var
    _x_ = [0, set_num_nodes_recomputed_direc$0],
    num_nodes_recomputed_directly_$2 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed_direc$0,
       _x_,
       num_nodes_recomputed_directly_$0,
       _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27]];
   }
   var
    _z_ = [0, set_num_nodes_recomputed],
    num_nodes_recomputed$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed,
       _z_,
       num_nodes_recomputed,
       _y_];
   function _A_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _B_ = [0, set_num_nodes_invalidated],
    num_nodes_invalidated$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_invalidated,
       _B_,
       num_nodes_invalidated,
       _A_];
   function _C_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _D_ = [0, set_num_nodes_created],
    num_nodes_created$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_created,
       _D_,
       num_nodes_created,
       _C_];
   function _E_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _F_ = [0, set_num_nodes_changed],
    num_nodes_changed$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_changed,
       _F_,
       num_nodes_changed,
       _E_];
   function _G_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _H_ = [0, set_num_nodes_became_unnecessa],
    num_nodes_became_unnecessary$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_became_unnecessa,
       _H_,
       num_nodes_became_unnecessary,
       _G_];
   function _I_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _J_ = [0, set_num_nodes_became_necessary],
    num_nodes_became_necessary$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_became_necessary,
       _J_,
       num_nodes_became_necessary,
       _I_];
   function _K_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _L_ = [0, set_keep_node_creation_backtra],
    keep_node_creation_backtrace$0 =
      [0,
       function(param){return 0;},
       cst_keep_node_creation_backtra,
       _L_,
       keep_node_creation_backtrace,
       _K_];
   function _M_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _N_ = 0,
    weak_hashtbls$0 =
      [0,
       function(param){return 0;},
       cst_weak_hashtbls,
       _N_,
       weak_hashtbls,
       _M_];
   function _O_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _P_ = [0, set_only_in_debug],
    only_in_debug$0 =
      [0,
       function(param){return 0;},
       cst_only_in_debug,
       _P_,
       only_in_debug,
       _O_];
   function _Q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _R_ = 0,
    run_on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_run_on_update_handlers,
       _R_,
       run_on_update_handlers,
       _Q_];
   function _S_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _T_ = 0,
    handle_after_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_handle_after_stabilization,
       _T_,
       handle_after_stabilization,
       _S_];
   function _U_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _V_ = 0,
    set_during_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_set_during_stabilization,
       _V_,
       set_during_stabilization,
       _U_];
   function _W_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _X_ = 0,
    disallowed_observers$0 =
      [0,
       function(param){return 0;},
       cst_disallowed_observers,
       _X_,
       disallowed_observers,
       _W_];
   function _Y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _Z_ = 0,
    new_observers$0 =
      [0,
       function(param){return 0;},
       cst_new_observers,
       _Z_,
       new_observers,
       _Y_];
   function ___(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _$_ = 0,
    finalized_observers$0 =
      [0,
       function(param){return 0;},
       cst_finalized_observers,
       _$_,
       finalized_observers,
       ___];
   function _aa_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ab_ = [0, set_all_observers],
    all_observers$0 =
      [0,
       function(param){return 0;},
       cst_all_observers,
       _ab_,
       all_observers,
       _aa_];
   function _ac_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ad_ = [0, set_num_active_observers],
    num_active_observers$0 =
      [0,
       function(param){return 0;},
       cst_num_active_observers,
       _ad_,
       num_active_observers,
       _ac_];
   function _ae_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _af_ = 0,
    propagate_invalidity$0 =
      [0,
       function(param){return 0;},
       cst_propagate_invalidity,
       _af_,
       propagate_invalidity,
       _ae_];
   function _ag_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ah_ = 0,
    adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_adjust_heights_heap,
       _ah_,
       adjust_heights_heap,
       _ag_];
   function _ai_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _aj_ = 0,
    recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_recompute_heap,
       _aj_,
       recompute_heap,
       _ai_];
   function _ak_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _al_ = [0, set_current_scope],
    current_scope$0 =
      [0,
       function(param){return 0;},
       cst_current_scope,
       _al_,
       current_scope,
       _ak_];
   function _am_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _an_ = [0, set_stabilization_num],
    stabilization_num$0 =
      [0,
       function(param){return 0;},
       cst_stabilization_num,
       _an_,
       stabilization_num,
       _am_];
   function _ao_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ap_ = 0,
    bind_lhs_change_should_invalid$0 =
      [0,
       function(param){return 0;},
       cst_bind_lhs_change_should_inv,
       _ap_,
       bind_lhs_change_should_invalid,
       _ao_];
   function _aq_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ar_ = [0, set_status],
    status$0 = [0, function(param){return 0;}, cst_status, _ar_, status, _aq_];
   function make_creator$0
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun,
    compile_acc){
    var
     match = caml_call2(status_fun, status$0, compile_acc),
     compile_acc$0 = match[2],
     status_gen = match[1],
     match$0 =
       caml_call2
        (bind_lhs_change_should_invalid,
         bind_lhs_change_should_invalid$0,
         compile_acc$0),
     compile_acc$1 = match$0[2],
     bind_lhs_change_should_invalid$1 = match$0[1],
     match$1 =
       caml_call2(stabilization_num_fun, stabilization_num$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     stabilization_num_gen = match$1[1],
     match$2 = caml_call2(current_scope_fun, current_scope$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     current_scope_gen = match$2[1],
     match$3 = caml_call2(recompute_heap_fun, recompute_heap$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     recompute_heap_gen = match$3[1],
     match$4 =
       caml_call2
        (adjust_heights_heap_fun, adjust_heights_heap$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     adjust_heights_heap_gen = match$4[1],
     match$5 =
       caml_call2
        (propagate_invalidity_fun, propagate_invalidity$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     propagate_invalidity_gen = match$5[1],
     match$6 =
       caml_call2
        (num_active_observers_fun, num_active_observers$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     num_active_observers_gen = match$6[1],
     match$7 = caml_call2(all_observers_fun, all_observers$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     all_observers_gen = match$7[1],
     match$8 =
       caml_call2
        (finalized_observers_fun, finalized_observers$0, compile_acc$8),
     compile_acc$9 = match$8[2],
     finalized_observers_gen = match$8[1],
     match$9 = caml_call2(new_observers_fun, new_observers$0, compile_acc$9),
     compile_acc$10 = match$9[2],
     new_observers_gen = match$9[1],
     match$10 =
       caml_call2
        (disallowed_observers_fun, disallowed_observers$0, compile_acc$10),
     compile_acc$11 = match$10[2],
     disallowed_observers_gen = match$10[1],
     match$11 =
       caml_call2
        (set_during_stabilization_fun,
         set_during_stabilization$0,
         compile_acc$11),
     compile_acc$12 = match$11[2],
     set_during_stabilization_gen = match$11[1],
     match$12 =
       caml_call2
        (handle_after_stabilization_fun,
         handle_after_stabilization$0,
         compile_acc$12),
     compile_acc$13 = match$12[2],
     handle_after_stabilization_gen = match$12[1],
     match$13 =
       caml_call2
        (run_on_update_handlers_fun, run_on_update_handlers$0, compile_acc$13),
     compile_acc$14 = match$13[2],
     run_on_update_handlers_gen = match$13[1],
     match$14 = caml_call2(only_in_debug_fun, only_in_debug$0, compile_acc$14),
     compile_acc$15 = match$14[2],
     only_in_debug_gen = match$14[1],
     match$15 = caml_call2(weak_hashtbls_fun, weak_hashtbls$0, compile_acc$15),
     compile_acc$16 = match$15[2],
     weak_hashtbls_gen = match$15[1],
     match$16 =
       caml_call2
        (keep_node_creation_backtrace_f,
         keep_node_creation_backtrace$0,
         compile_acc$16),
     compile_acc$17 = match$16[2],
     keep_node_creation_backtrace_g = match$16[1],
     match$17 =
       caml_call2
        (num_nodes_became_necessary_fun,
         num_nodes_became_necessary$0,
         compile_acc$17),
     compile_acc$18 = match$17[2],
     num_nodes_became_necessary_gen = match$17[1],
     match$18 =
       caml_call2
        (num_nodes_became_unnecessary_f,
         num_nodes_became_unnecessary$0,
         compile_acc$18),
     compile_acc$19 = match$18[2],
     num_nodes_became_unnecessary_g = match$18[1],
     match$19 =
       caml_call2(num_nodes_changed_fun, num_nodes_changed$0, compile_acc$19),
     compile_acc$20 = match$19[2],
     num_nodes_changed_gen = match$19[1],
     match$20 =
       caml_call2(num_nodes_created_fun, num_nodes_created$0, compile_acc$20),
     compile_acc$21 = match$20[2],
     num_nodes_created_gen = match$20[1],
     match$21 =
       caml_call2
        (num_nodes_invalidated_fun, num_nodes_invalidated$0, compile_acc$21),
     compile_acc$22 = match$21[2],
     num_nodes_invalidated_gen = match$21[1],
     match$22 =
       caml_call2
        (num_nodes_recomputed_fun, num_nodes_recomputed$0, compile_acc$22),
     compile_acc$23 = match$22[2],
     num_nodes_recomputed_gen = match$22[1],
     match$23 =
       caml_call2
        (num_nodes_recomputed_directly_$0,
         num_nodes_recomputed_directly_$2,
         compile_acc$23),
     compile_acc$24 = match$23[2],
     num_nodes_recomputed_directly_$3 = match$23[1],
     match$24 =
       caml_call2
        (num_nodes_recomputed_directly_,
         num_nodes_recomputed_directly_$1,
         compile_acc$24),
     compile_acc$25 = match$24[2],
     num_nodes_recomputed_directly_$4 = match$24[1],
     match$25 = caml_call2(num_var_sets_fun, num_var_sets$0, compile_acc$25),
     compile_acc$26 = match$25[2],
     num_var_sets_gen = match$25[1];
    return [0,
            function(acc){
             var
              status = caml_call1(status_gen, acc),
              bind_lhs_change_should_invalid =
                caml_call1(bind_lhs_change_should_invalid$1, acc),
              stabilization_num = caml_call1(stabilization_num_gen, acc),
              current_scope = caml_call1(current_scope_gen, acc),
              recompute_heap = caml_call1(recompute_heap_gen, acc),
              adjust_heights_heap = caml_call1(adjust_heights_heap_gen, acc),
              propagate_invalidity = caml_call1(propagate_invalidity_gen, acc),
              num_active_observers = caml_call1(num_active_observers_gen, acc),
              all_observers = caml_call1(all_observers_gen, acc),
              finalized_observers = caml_call1(finalized_observers_gen, acc),
              new_observers = caml_call1(new_observers_gen, acc),
              disallowed_observers = caml_call1(disallowed_observers_gen, acc),
              set_during_stabilization =
                caml_call1(set_during_stabilization_gen, acc),
              handle_after_stabilization =
                caml_call1(handle_after_stabilization_gen, acc),
              run_on_update_handlers =
                caml_call1(run_on_update_handlers_gen, acc),
              only_in_debug = caml_call1(only_in_debug_gen, acc),
              weak_hashtbls = caml_call1(weak_hashtbls_gen, acc),
              keep_node_creation_backtrace =
                caml_call1(keep_node_creation_backtrace_g, acc),
              num_nodes_became_necessary =
                caml_call1(num_nodes_became_necessary_gen, acc),
              num_nodes_became_unnecessary =
                caml_call1(num_nodes_became_unnecessary_g, acc),
              num_nodes_changed = caml_call1(num_nodes_changed_gen, acc),
              num_nodes_created = caml_call1(num_nodes_created_gen, acc),
              num_nodes_invalidated =
                caml_call1(num_nodes_invalidated_gen, acc),
              num_nodes_recomputed = caml_call1(num_nodes_recomputed_gen, acc),
              num_nodes_recomputed_directly_ =
                caml_call1(num_nodes_recomputed_directly_$3, acc),
              num_nodes_recomputed_directly_$0 =
                caml_call1(num_nodes_recomputed_directly_$4, acc),
              num_var_sets = caml_call1(num_var_sets_gen, acc);
             return [0,
                     status,
                     bind_lhs_change_should_invalid,
                     stabilization_num,
                     current_scope,
                     recompute_heap,
                     adjust_heights_heap,
                     propagate_invalidity,
                     num_active_observers,
                     all_observers,
                     finalized_observers,
                     new_observers,
                     disallowed_observers,
                     set_during_stabilization,
                     handle_after_stabilization,
                     run_on_update_handlers,
                     only_in_debug,
                     weak_hashtbls,
                     keep_node_creation_backtrace,
                     num_nodes_became_necessary,
                     num_nodes_became_unnecessary,
                     num_nodes_changed,
                     num_nodes_created,
                     num_nodes_invalidated,
                     num_nodes_recomputed,
                     num_nodes_recomputed_directly_,
                     num_nodes_recomputed_directly_$0,
                     num_var_sets];
            },
            compile_acc$26];
   }
   function create$1
   (status,
    bind_lhs_change_should_invalid,
    stabilization_num,
    current_scope,
    recompute_heap,
    adjust_heights_heap,
    propagate_invalidity,
    num_active_observers,
    all_observers,
    finalized_observers,
    new_observers,
    disallowed_observers,
    set_during_stabilization,
    handle_after_stabilization,
    run_on_update_handlers,
    only_in_debug,
    weak_hashtbls,
    keep_node_creation_backtrace,
    num_nodes_became_necessary,
    num_nodes_became_unnecessary,
    num_nodes_changed,
    num_nodes_created,
    num_nodes_invalidated,
    num_nodes_recomputed,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets){
    return [0,
            status,
            bind_lhs_change_should_invalid,
            stabilization_num,
            current_scope,
            recompute_heap,
            adjust_heights_heap,
            propagate_invalidity,
            num_active_observers,
            all_observers,
            finalized_observers,
            new_observers,
            disallowed_observers,
            set_during_stabilization,
            handle_after_stabilization,
            run_on_update_handlers,
            only_in_debug,
            weak_hashtbls,
            keep_node_creation_backtrace,
            num_nodes_became_necessary,
            num_nodes_became_unnecessary,
            num_nodes_changed,
            num_nodes_created,
            num_nodes_invalidated,
            num_nodes_recomputed,
            num_nodes_recomputed_directly_$0,
            num_nodes_recomputed_directly_,
            num_var_sets];
   }
   function map$1
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _mo_ = caml_call1(num_var_sets_fun, num_var_sets$0),
     _mp_ =
       caml_call1
        (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1),
     _mq_ =
       caml_call1
        (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2),
     _mr_ = caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0),
     _ms_ = caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0),
     _mt_ = caml_call1(num_nodes_created_fun, num_nodes_created$0),
     _mu_ = caml_call1(num_nodes_changed_fun, num_nodes_changed$0),
     _mv_ =
       caml_call1
        (num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0),
     _mw_ =
       caml_call1
        (num_nodes_became_necessary_fun, num_nodes_became_necessary$0),
     _mx_ =
       caml_call1
        (keep_node_creation_backtrace_f, keep_node_creation_backtrace$0),
     _my_ = caml_call1(weak_hashtbls_fun, weak_hashtbls$0),
     _mz_ = caml_call1(only_in_debug_fun, only_in_debug$0),
     _mA_ = caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0),
     _mB_ =
       caml_call1
        (handle_after_stabilization_fun, handle_after_stabilization$0),
     _mC_ =
       caml_call1(set_during_stabilization_fun, set_during_stabilization$0),
     _mD_ = caml_call1(disallowed_observers_fun, disallowed_observers$0),
     _mE_ = caml_call1(new_observers_fun, new_observers$0),
     _mF_ = caml_call1(finalized_observers_fun, finalized_observers$0),
     _mG_ = caml_call1(all_observers_fun, all_observers$0),
     _mH_ = caml_call1(num_active_observers_fun, num_active_observers$0),
     _mI_ = caml_call1(propagate_invalidity_fun, propagate_invalidity$0),
     _mJ_ = caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0),
     _mK_ = caml_call1(recompute_heap_fun, recompute_heap$0),
     _mL_ = caml_call1(current_scope_fun, current_scope$0),
     _mM_ = caml_call1(stabilization_num_fun, stabilization_num$0),
     _mN_ =
       caml_call1
        (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0);
    return [0,
            caml_call1(status_fun, status$0),
            _mN_,
            _mM_,
            _mL_,
            _mK_,
            _mJ_,
            _mI_,
            _mH_,
            _mG_,
            _mF_,
            _mE_,
            _mD_,
            _mC_,
            _mB_,
            _mA_,
            _mz_,
            _my_,
            _mx_,
            _mw_,
            _mv_,
            _mu_,
            _mt_,
            _ms_,
            _mr_,
            _mq_,
            _mp_,
            _mo_];
   }
   function iter$1
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    caml_call1(status_fun, status$0);
    caml_call1
     (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0);
    caml_call1(stabilization_num_fun, stabilization_num$0);
    caml_call1(current_scope_fun, current_scope$0);
    caml_call1(recompute_heap_fun, recompute_heap$0);
    caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0);
    caml_call1(propagate_invalidity_fun, propagate_invalidity$0);
    caml_call1(num_active_observers_fun, num_active_observers$0);
    caml_call1(all_observers_fun, all_observers$0);
    caml_call1(finalized_observers_fun, finalized_observers$0);
    caml_call1(new_observers_fun, new_observers$0);
    caml_call1(disallowed_observers_fun, disallowed_observers$0);
    caml_call1(set_during_stabilization_fun, set_during_stabilization$0);
    caml_call1(handle_after_stabilization_fun, handle_after_stabilization$0);
    caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0);
    caml_call1(only_in_debug_fun, only_in_debug$0);
    caml_call1(weak_hashtbls_fun, weak_hashtbls$0);
    caml_call1(keep_node_creation_backtrace_f, keep_node_creation_backtrace$0);
    caml_call1(num_nodes_became_necessary_fun, num_nodes_became_necessary$0);
    caml_call1(num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0);
    caml_call1(num_nodes_changed_fun, num_nodes_changed$0);
    caml_call1(num_nodes_created_fun, num_nodes_created$0);
    caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0);
    caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0);
    caml_call1
     (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2);
    caml_call1
     (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1);
    return caml_call1(num_var_sets_fun, num_var_sets$0);
   }
   function fold$1
   (init,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    return caml_call2
            (num_var_sets_fun,
             caml_call2
              (num_nodes_recomputed_directly_,
               caml_call2
                (num_nodes_recomputed_directly_$0,
                 caml_call2
                  (num_nodes_recomputed_fun,
                   caml_call2
                    (num_nodes_invalidated_fun,
                     caml_call2
                      (num_nodes_created_fun,
                       caml_call2
                        (num_nodes_changed_fun,
                         caml_call2
                          (num_nodes_became_unnecessary_f,
                           caml_call2
                            (num_nodes_became_necessary_fun,
                             caml_call2
                              (keep_node_creation_backtrace_f,
                               caml_call2
                                (weak_hashtbls_fun,
                                 caml_call2
                                  (only_in_debug_fun,
                                   caml_call2
                                    (run_on_update_handlers_fun,
                                     caml_call2
                                      (handle_after_stabilization_fun,
                                       caml_call2
                                        (set_during_stabilization_fun,
                                         caml_call2
                                          (disallowed_observers_fun,
                                           caml_call2
                                            (new_observers_fun,
                                             caml_call2
                                              (finalized_observers_fun,
                                               caml_call2
                                                (all_observers_fun,
                                                 caml_call2
                                                  (num_active_observers_fun,
                                                   caml_call2
                                                    (propagate_invalidity_fun,
                                                     caml_call2
                                                      (adjust_heights_heap_fun,
                                                       caml_call2
                                                        (recompute_heap_fun,
                                                         caml_call2
                                                          (current_scope_fun,
                                                           caml_call2
                                                            (stabilization_num_fun,
                                                             caml_call2
                                                              (bind_lhs_change_should_invalid,
                                                               caml_call2(status_fun, init, status$0),
                                                               bind_lhs_change_should_invalid$0),
                                                             stabilization_num$0),
                                                           current_scope$0),
                                                         recompute_heap$0),
                                                       adjust_heights_heap$0),
                                                     propagate_invalidity$0),
                                                   num_active_observers$0),
                                                 all_observers$0),
                                               finalized_observers$0),
                                             new_observers$0),
                                           disallowed_observers$0),
                                         set_during_stabilization$0),
                                       handle_after_stabilization$0),
                                     run_on_update_handlers$0),
                                   only_in_debug$0),
                                 weak_hashtbls$0),
                               keep_node_creation_backtrace$0),
                             num_nodes_became_necessary$0),
                           num_nodes_became_unnecessary$0),
                         num_nodes_changed$0),
                       num_nodes_created$0),
                     num_nodes_invalidated$0),
                   num_nodes_recomputed$0),
                 num_nodes_recomputed_directly_$2),
               num_nodes_recomputed_directly_$1),
             num_var_sets$0);
   }
   function map_poly$0(record){
    var
     _l0_ = [0, caml_call1(record[1], num_var_sets$0), 0],
     _l1_ = [0, caml_call1(record[1], num_nodes_recomputed_directly_$1), _l0_],
     _l2_ = [0, caml_call1(record[1], num_nodes_recomputed_directly_$2), _l1_],
     _l3_ = [0, caml_call1(record[1], num_nodes_recomputed$0), _l2_],
     _l4_ = [0, caml_call1(record[1], num_nodes_invalidated$0), _l3_],
     _l5_ = [0, caml_call1(record[1], num_nodes_created$0), _l4_],
     _l6_ = [0, caml_call1(record[1], num_nodes_changed$0), _l5_],
     _l7_ = [0, caml_call1(record[1], num_nodes_became_unnecessary$0), _l6_],
     _l8_ = [0, caml_call1(record[1], num_nodes_became_necessary$0), _l7_],
     _l9_ = [0, caml_call1(record[1], keep_node_creation_backtrace$0), _l8_],
     _l__ = [0, caml_call1(record[1], weak_hashtbls$0), _l9_],
     _l$_ = [0, caml_call1(record[1], only_in_debug$0), _l__],
     _ma_ = [0, caml_call1(record[1], run_on_update_handlers$0), _l$_],
     _mb_ = [0, caml_call1(record[1], handle_after_stabilization$0), _ma_],
     _mc_ = [0, caml_call1(record[1], set_during_stabilization$0), _mb_],
     _md_ = [0, caml_call1(record[1], disallowed_observers$0), _mc_],
     _me_ = [0, caml_call1(record[1], new_observers$0), _md_],
     _mf_ = [0, caml_call1(record[1], finalized_observers$0), _me_],
     _mg_ = [0, caml_call1(record[1], all_observers$0), _mf_],
     _mh_ = [0, caml_call1(record[1], num_active_observers$0), _mg_],
     _mi_ = [0, caml_call1(record[1], propagate_invalidity$0), _mh_],
     _mj_ = [0, caml_call1(record[1], adjust_heights_heap$0), _mi_],
     _mk_ = [0, caml_call1(record[1], recompute_heap$0), _mj_],
     _ml_ = [0, caml_call1(record[1], current_scope$0), _mk_],
     _mm_ = [0, caml_call1(record[1], stabilization_num$0), _ml_],
     _mn_ = [0, caml_call1(record[1], bind_lhs_change_should_invalid$0), _mm_];
    return [0, caml_call1(record[1], status$0), _mn_];
   }
   function for_all$1
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _lA_ = caml_call1(status_fun, status$0),
     _lB_ =
       _lA_
        ? caml_call1
          (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0)
        : _lA_,
     _lC_ =
       _lB_ ? caml_call1(stabilization_num_fun, stabilization_num$0) : _lB_,
     _lD_ = _lC_ ? caml_call1(current_scope_fun, current_scope$0) : _lC_,
     _lE_ = _lD_ ? caml_call1(recompute_heap_fun, recompute_heap$0) : _lD_,
     _lF_ =
       _lE_
        ? caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0)
        : _lE_,
     _lG_ =
       _lF_
        ? caml_call1(propagate_invalidity_fun, propagate_invalidity$0)
        : _lF_,
     _lH_ =
       _lG_
        ? caml_call1(num_active_observers_fun, num_active_observers$0)
        : _lG_,
     _lI_ = _lH_ ? caml_call1(all_observers_fun, all_observers$0) : _lH_,
     _lJ_ =
       _lI_
        ? caml_call1(finalized_observers_fun, finalized_observers$0)
        : _lI_,
     _lK_ = _lJ_ ? caml_call1(new_observers_fun, new_observers$0) : _lJ_,
     _lL_ =
       _lK_
        ? caml_call1(disallowed_observers_fun, disallowed_observers$0)
        : _lK_,
     _lM_ =
       _lL_
        ? caml_call1(set_during_stabilization_fun, set_during_stabilization$0)
        : _lL_,
     _lN_ =
       _lM_
        ? caml_call1
          (handle_after_stabilization_fun, handle_after_stabilization$0)
        : _lM_,
     _lO_ =
       _lN_
        ? caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0)
        : _lN_,
     _lP_ = _lO_ ? caml_call1(only_in_debug_fun, only_in_debug$0) : _lO_,
     _lQ_ = _lP_ ? caml_call1(weak_hashtbls_fun, weak_hashtbls$0) : _lP_,
     _lR_ =
       _lQ_
        ? caml_call1
          (keep_node_creation_backtrace_f, keep_node_creation_backtrace$0)
        : _lQ_,
     _lS_ =
       _lR_
        ? caml_call1
          (num_nodes_became_necessary_fun, num_nodes_became_necessary$0)
        : _lR_,
     _lT_ =
       _lS_
        ? caml_call1
          (num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0)
        : _lS_,
     _lU_ =
       _lT_ ? caml_call1(num_nodes_changed_fun, num_nodes_changed$0) : _lT_,
     _lV_ =
       _lU_ ? caml_call1(num_nodes_created_fun, num_nodes_created$0) : _lU_,
     _lW_ =
       _lV_
        ? caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0)
        : _lV_,
     _lX_ =
       _lW_
        ? caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0)
        : _lW_,
     _lY_ =
       _lX_
        ? caml_call1
          (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2)
        : _lX_,
     _lZ_ =
       _lY_
        ? caml_call1
          (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1)
        : _lY_;
    return _lZ_ ? caml_call1(num_var_sets_fun, num_var_sets$0) : _lZ_;
   }
   function exists$1
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _lz_ = caml_call1(status_fun, status$0),
     _la_ =
       _lz_
       ||
        caml_call1
         (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0),
     _lb_ = _la_ || caml_call1(stabilization_num_fun, stabilization_num$0),
     _lc_ = _lb_ || caml_call1(current_scope_fun, current_scope$0),
     _ld_ = _lc_ || caml_call1(recompute_heap_fun, recompute_heap$0),
     _le_ = _ld_ || caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0),
     _lf_ =
       _le_ || caml_call1(propagate_invalidity_fun, propagate_invalidity$0),
     _lg_ =
       _lf_ || caml_call1(num_active_observers_fun, num_active_observers$0),
     _lh_ = _lg_ || caml_call1(all_observers_fun, all_observers$0),
     _li_ = _lh_ || caml_call1(finalized_observers_fun, finalized_observers$0),
     _lj_ = _li_ || caml_call1(new_observers_fun, new_observers$0),
     _lk_ =
       _lj_ || caml_call1(disallowed_observers_fun, disallowed_observers$0),
     _ll_ =
       _lk_
       || caml_call1(set_during_stabilization_fun, set_during_stabilization$0),
     _lm_ =
       _ll_
       ||
        caml_call1
         (handle_after_stabilization_fun, handle_after_stabilization$0),
     _ln_ =
       _lm_
       || caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0),
     _lo_ = _ln_ || caml_call1(only_in_debug_fun, only_in_debug$0),
     _lp_ = _lo_ || caml_call1(weak_hashtbls_fun, weak_hashtbls$0),
     _lq_ =
       _lp_
       ||
        caml_call1
         (keep_node_creation_backtrace_f, keep_node_creation_backtrace$0),
     _lr_ =
       _lq_
       ||
        caml_call1
         (num_nodes_became_necessary_fun, num_nodes_became_necessary$0),
     _ls_ =
       _lr_
       ||
        caml_call1
         (num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0),
     _lt_ = _ls_ || caml_call1(num_nodes_changed_fun, num_nodes_changed$0),
     _lu_ = _lt_ || caml_call1(num_nodes_created_fun, num_nodes_created$0),
     _lv_ =
       _lu_ || caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0),
     _lw_ =
       _lv_ || caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0),
     _lx_ =
       _lw_
       ||
        caml_call1
         (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2),
     _ly_ =
       _lx_
       ||
        caml_call1
         (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1);
    return _ly_ ? _ly_ : caml_call1(num_var_sets_fun, num_var_sets$0);
   }
   function to_list$1
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _kM_ = [0, caml_call1(num_var_sets_fun, num_var_sets$0), 0],
     _kN_ =
       [0,
        caml_call1
         (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1),
        _kM_],
     _kO_ =
       [0,
        caml_call1
         (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2),
        _kN_],
     _kP_ =
       [0, caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0), _kO_],
     _kQ_ =
       [0,
        caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0),
        _kP_],
     _kR_ = [0, caml_call1(num_nodes_created_fun, num_nodes_created$0), _kQ_],
     _kS_ = [0, caml_call1(num_nodes_changed_fun, num_nodes_changed$0), _kR_],
     _kT_ =
       [0,
        caml_call1
         (num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0),
        _kS_],
     _kU_ =
       [0,
        caml_call1
         (num_nodes_became_necessary_fun, num_nodes_became_necessary$0),
        _kT_],
     _kV_ =
       [0,
        caml_call1
         (keep_node_creation_backtrace_f, keep_node_creation_backtrace$0),
        _kU_],
     _kW_ = [0, caml_call1(weak_hashtbls_fun, weak_hashtbls$0), _kV_],
     _kX_ = [0, caml_call1(only_in_debug_fun, only_in_debug$0), _kW_],
     _kY_ =
       [0,
        caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0),
        _kX_],
     _kZ_ =
       [0,
        caml_call1
         (handle_after_stabilization_fun, handle_after_stabilization$0),
        _kY_],
     _k0_ =
       [0,
        caml_call1(set_during_stabilization_fun, set_during_stabilization$0),
        _kZ_],
     _k1_ =
       [0, caml_call1(disallowed_observers_fun, disallowed_observers$0), _k0_],
     _k2_ = [0, caml_call1(new_observers_fun, new_observers$0), _k1_],
     _k3_ =
       [0, caml_call1(finalized_observers_fun, finalized_observers$0), _k2_],
     _k4_ = [0, caml_call1(all_observers_fun, all_observers$0), _k3_],
     _k5_ =
       [0, caml_call1(num_active_observers_fun, num_active_observers$0), _k4_],
     _k6_ =
       [0, caml_call1(propagate_invalidity_fun, propagate_invalidity$0), _k5_],
     _k7_ =
       [0, caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0), _k6_],
     _k8_ = [0, caml_call1(recompute_heap_fun, recompute_heap$0), _k7_],
     _k9_ = [0, caml_call1(current_scope_fun, current_scope$0), _k8_],
     _k__ = [0, caml_call1(stabilization_num_fun, stabilization_num$0), _k9_],
     _k$_ =
       [0,
        caml_call1
         (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0),
        _k__];
    return [0, caml_call1(status_fun, status$0), _k$_];
   }
   function iter$2
   (record,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    caml_call3(status_fun, status$0, record, record[1]);
    caml_call3
     (bind_lhs_change_should_invalid,
      bind_lhs_change_should_invalid$0,
      record,
      record[2]);
    caml_call3(stabilization_num_fun, stabilization_num$0, record, record[3]);
    caml_call3(current_scope_fun, current_scope$0, record, record[4]);
    caml_call3(recompute_heap_fun, recompute_heap$0, record, record[5]);
    caml_call3
     (adjust_heights_heap_fun, adjust_heights_heap$0, record, record[6]);
    caml_call3
     (propagate_invalidity_fun, propagate_invalidity$0, record, record[7]);
    caml_call3
     (num_active_observers_fun, num_active_observers$0, record, record[8]);
    caml_call3(all_observers_fun, all_observers$0, record, record[9]);
    caml_call3
     (finalized_observers_fun, finalized_observers$0, record, record[10]);
    caml_call3(new_observers_fun, new_observers$0, record, record[11]);
    caml_call3
     (disallowed_observers_fun, disallowed_observers$0, record, record[12]);
    caml_call3
     (set_during_stabilization_fun,
      set_during_stabilization$0,
      record,
      record[13]);
    caml_call3
     (handle_after_stabilization_fun,
      handle_after_stabilization$0,
      record,
      record[14]);
    caml_call3
     (run_on_update_handlers_fun,
      run_on_update_handlers$0,
      record,
      record[15]);
    caml_call3(only_in_debug_fun, only_in_debug$0, record, record[16]);
    caml_call3(weak_hashtbls_fun, weak_hashtbls$0, record, record[17]);
    caml_call3
     (keep_node_creation_backtrace_f,
      keep_node_creation_backtrace$0,
      record,
      record[18]);
    caml_call3
     (num_nodes_became_necessary_fun,
      num_nodes_became_necessary$0,
      record,
      record[19]);
    caml_call3
     (num_nodes_became_unnecessary_f,
      num_nodes_became_unnecessary$0,
      record,
      record[20]);
    caml_call3(num_nodes_changed_fun, num_nodes_changed$0, record, record[21]);
    caml_call3(num_nodes_created_fun, num_nodes_created$0, record, record[22]);
    caml_call3
     (num_nodes_invalidated_fun, num_nodes_invalidated$0, record, record[23]);
    caml_call3
     (num_nodes_recomputed_fun, num_nodes_recomputed$0, record, record[24]);
    caml_call3
     (num_nodes_recomputed_directly_$0,
      num_nodes_recomputed_directly_$2,
      record,
      record[25]);
    caml_call3
     (num_nodes_recomputed_directly_,
      num_nodes_recomputed_directly_$1,
      record,
      record[26]);
    return caml_call3(num_var_sets_fun, num_var_sets$0, record, record[27]);
   }
   function fold$2
   (record,
    init,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _km_ = record[27],
     _kn_ = record[26],
     _ko_ = record[25],
     _kp_ = record[24],
     _kq_ = record[23],
     _kr_ = record[22],
     _ks_ = record[21],
     _kt_ = record[20],
     _ku_ = record[19],
     _kv_ = record[18],
     _kw_ = record[17],
     _kx_ = record[16],
     _ky_ = record[15],
     _kz_ = record[14],
     _kA_ = record[13],
     _kB_ = record[12],
     _kC_ = record[11],
     _kD_ = record[10],
     _kE_ = record[9],
     _kF_ = record[8],
     _kG_ = record[7],
     _kH_ = record[6],
     _kI_ = record[5],
     _kJ_ = record[4],
     _kK_ = record[3],
     _kL_ = record[2];
    return caml_call4
            (num_var_sets_fun,
             caml_call4
              (num_nodes_recomputed_directly_,
               caml_call4
                (num_nodes_recomputed_directly_$0,
                 caml_call4
                  (num_nodes_recomputed_fun,
                   caml_call4
                    (num_nodes_invalidated_fun,
                     caml_call4
                      (num_nodes_created_fun,
                       caml_call4
                        (num_nodes_changed_fun,
                         caml_call4
                          (num_nodes_became_unnecessary_f,
                           caml_call4
                            (num_nodes_became_necessary_fun,
                             caml_call4
                              (keep_node_creation_backtrace_f,
                               caml_call4
                                (weak_hashtbls_fun,
                                 caml_call4
                                  (only_in_debug_fun,
                                   caml_call4
                                    (run_on_update_handlers_fun,
                                     caml_call4
                                      (handle_after_stabilization_fun,
                                       caml_call4
                                        (set_during_stabilization_fun,
                                         caml_call4
                                          (disallowed_observers_fun,
                                           caml_call4
                                            (new_observers_fun,
                                             caml_call4
                                              (finalized_observers_fun,
                                               caml_call4
                                                (all_observers_fun,
                                                 caml_call4
                                                  (num_active_observers_fun,
                                                   caml_call4
                                                    (propagate_invalidity_fun,
                                                     caml_call4
                                                      (adjust_heights_heap_fun,
                                                       caml_call4
                                                        (recompute_heap_fun,
                                                         caml_call4
                                                          (current_scope_fun,
                                                           caml_call4
                                                            (stabilization_num_fun,
                                                             caml_call4
                                                              (bind_lhs_change_should_invalid,
                                                               caml_call4(status_fun, init, status$0, record, record[1]),
                                                               bind_lhs_change_should_invalid$0,
                                                               record,
                                                               _kL_),
                                                             stabilization_num$0,
                                                             record,
                                                             _kK_),
                                                           current_scope$0,
                                                           record,
                                                           _kJ_),
                                                         recompute_heap$0,
                                                         record,
                                                         _kI_),
                                                       adjust_heights_heap$0,
                                                       record,
                                                       _kH_),
                                                     propagate_invalidity$0,
                                                     record,
                                                     _kG_),
                                                   num_active_observers$0,
                                                   record,
                                                   _kF_),
                                                 all_observers$0,
                                                 record,
                                                 _kE_),
                                               finalized_observers$0,
                                               record,
                                               _kD_),
                                             new_observers$0,
                                             record,
                                             _kC_),
                                           disallowed_observers$0,
                                           record,
                                           _kB_),
                                         set_during_stabilization$0,
                                         record,
                                         _kA_),
                                       handle_after_stabilization$0,
                                       record,
                                       _kz_),
                                     run_on_update_handlers$0,
                                     record,
                                     _ky_),
                                   only_in_debug$0,
                                   record,
                                   _kx_),
                                 weak_hashtbls$0,
                                 record,
                                 _kw_),
                               keep_node_creation_backtrace$0,
                               record,
                               _kv_),
                             num_nodes_became_necessary$0,
                             record,
                             _ku_),
                           num_nodes_became_unnecessary$0,
                           record,
                           _kt_),
                         num_nodes_changed$0,
                         record,
                         _ks_),
                       num_nodes_created$0,
                       record,
                       _kr_),
                     num_nodes_invalidated$0,
                     record,
                     _kq_),
                   num_nodes_recomputed$0,
                   record,
                   _kp_),
                 num_nodes_recomputed_directly_$2,
                 record,
                 _ko_),
               num_nodes_recomputed_directly_$1,
               record,
               _kn_),
             num_var_sets$0,
             record,
             _km_);
   }
   function for_all$2
   (record,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _jY_ = caml_call3(status_fun, status$0, record, record[1]),
     _jZ_ =
       _jY_
        ? caml_call3
          (bind_lhs_change_should_invalid,
           bind_lhs_change_should_invalid$0,
           record,
           record[2])
        : _jY_,
     _j0_ =
       _jZ_
        ? caml_call3
          (stabilization_num_fun, stabilization_num$0, record, record[3])
        : _jZ_,
     _j1_ =
       _j0_
        ? caml_call3(current_scope_fun, current_scope$0, record, record[4])
        : _j0_,
     _j2_ =
       _j1_
        ? caml_call3(recompute_heap_fun, recompute_heap$0, record, record[5])
        : _j1_,
     _j3_ =
       _j2_
        ? caml_call3
          (adjust_heights_heap_fun, adjust_heights_heap$0, record, record[6])
        : _j2_,
     _j4_ =
       _j3_
        ? caml_call3
          (propagate_invalidity_fun,
           propagate_invalidity$0,
           record,
           record[7])
        : _j3_,
     _j5_ =
       _j4_
        ? caml_call3
          (num_active_observers_fun,
           num_active_observers$0,
           record,
           record[8])
        : _j4_,
     _j6_ =
       _j5_
        ? caml_call3(all_observers_fun, all_observers$0, record, record[9])
        : _j5_,
     _j7_ =
       _j6_
        ? caml_call3
          (finalized_observers_fun, finalized_observers$0, record, record[10])
        : _j6_,
     _j8_ =
       _j7_
        ? caml_call3(new_observers_fun, new_observers$0, record, record[11])
        : _j7_,
     _j9_ =
       _j8_
        ? caml_call3
          (disallowed_observers_fun,
           disallowed_observers$0,
           record,
           record[12])
        : _j8_,
     _j__ =
       _j9_
        ? caml_call3
          (set_during_stabilization_fun,
           set_during_stabilization$0,
           record,
           record[13])
        : _j9_,
     _j$_ =
       _j__
        ? caml_call3
          (handle_after_stabilization_fun,
           handle_after_stabilization$0,
           record,
           record[14])
        : _j__,
     _ka_ =
       _j$_
        ? caml_call3
          (run_on_update_handlers_fun,
           run_on_update_handlers$0,
           record,
           record[15])
        : _j$_,
     _kb_ =
       _ka_
        ? caml_call3(only_in_debug_fun, only_in_debug$0, record, record[16])
        : _ka_,
     _kc_ =
       _kb_
        ? caml_call3(weak_hashtbls_fun, weak_hashtbls$0, record, record[17])
        : _kb_,
     _kd_ =
       _kc_
        ? caml_call3
          (keep_node_creation_backtrace_f,
           keep_node_creation_backtrace$0,
           record,
           record[18])
        : _kc_,
     _ke_ =
       _kd_
        ? caml_call3
          (num_nodes_became_necessary_fun,
           num_nodes_became_necessary$0,
           record,
           record[19])
        : _kd_,
     _kf_ =
       _ke_
        ? caml_call3
          (num_nodes_became_unnecessary_f,
           num_nodes_became_unnecessary$0,
           record,
           record[20])
        : _ke_,
     _kg_ =
       _kf_
        ? caml_call3
          (num_nodes_changed_fun, num_nodes_changed$0, record, record[21])
        : _kf_,
     _kh_ =
       _kg_
        ? caml_call3
          (num_nodes_created_fun, num_nodes_created$0, record, record[22])
        : _kg_,
     _ki_ =
       _kh_
        ? caml_call3
          (num_nodes_invalidated_fun,
           num_nodes_invalidated$0,
           record,
           record[23])
        : _kh_,
     _kj_ =
       _ki_
        ? caml_call3
          (num_nodes_recomputed_fun,
           num_nodes_recomputed$0,
           record,
           record[24])
        : _ki_,
     _kk_ =
       _kj_
        ? caml_call3
          (num_nodes_recomputed_directly_$0,
           num_nodes_recomputed_directly_$2,
           record,
           record[25])
        : _kj_,
     _kl_ =
       _kk_
        ? caml_call3
          (num_nodes_recomputed_directly_,
           num_nodes_recomputed_directly_$1,
           record,
           record[26])
        : _kk_;
    return _kl_
            ? caml_call3(num_var_sets_fun, num_var_sets$0, record, record[27])
            : _kl_;
   }
   function exists$2
   (record,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _jX_ = caml_call3(status_fun, status$0, record, record[1]),
     _jy_ =
       _jX_
       ||
        caml_call3
         (bind_lhs_change_should_invalid,
          bind_lhs_change_should_invalid$0,
          record,
          record[2]),
     _jz_ =
       _jy_
       ||
        caml_call3
         (stabilization_num_fun, stabilization_num$0, record, record[3]),
     _jA_ =
       _jz_
       || caml_call3(current_scope_fun, current_scope$0, record, record[4]),
     _jB_ =
       _jA_
       || caml_call3(recompute_heap_fun, recompute_heap$0, record, record[5]),
     _jC_ =
       _jB_
       ||
        caml_call3
         (adjust_heights_heap_fun, adjust_heights_heap$0, record, record[6]),
     _jD_ =
       _jC_
       ||
        caml_call3
         (propagate_invalidity_fun, propagate_invalidity$0, record, record[7]),
     _jE_ =
       _jD_
       ||
        caml_call3
         (num_active_observers_fun, num_active_observers$0, record, record[8]),
     _jF_ =
       _jE_
       || caml_call3(all_observers_fun, all_observers$0, record, record[9]),
     _jG_ =
       _jF_
       ||
        caml_call3
         (finalized_observers_fun, finalized_observers$0, record, record[10]),
     _jH_ =
       _jG_
       || caml_call3(new_observers_fun, new_observers$0, record, record[11]),
     _jI_ =
       _jH_
       ||
        caml_call3
         (disallowed_observers_fun,
          disallowed_observers$0,
          record,
          record[12]),
     _jJ_ =
       _jI_
       ||
        caml_call3
         (set_during_stabilization_fun,
          set_during_stabilization$0,
          record,
          record[13]),
     _jK_ =
       _jJ_
       ||
        caml_call3
         (handle_after_stabilization_fun,
          handle_after_stabilization$0,
          record,
          record[14]),
     _jL_ =
       _jK_
       ||
        caml_call3
         (run_on_update_handlers_fun,
          run_on_update_handlers$0,
          record,
          record[15]),
     _jM_ =
       _jL_
       || caml_call3(only_in_debug_fun, only_in_debug$0, record, record[16]),
     _jN_ =
       _jM_
       || caml_call3(weak_hashtbls_fun, weak_hashtbls$0, record, record[17]),
     _jO_ =
       _jN_
       ||
        caml_call3
         (keep_node_creation_backtrace_f,
          keep_node_creation_backtrace$0,
          record,
          record[18]),
     _jP_ =
       _jO_
       ||
        caml_call3
         (num_nodes_became_necessary_fun,
          num_nodes_became_necessary$0,
          record,
          record[19]),
     _jQ_ =
       _jP_
       ||
        caml_call3
         (num_nodes_became_unnecessary_f,
          num_nodes_became_unnecessary$0,
          record,
          record[20]),
     _jR_ =
       _jQ_
       ||
        caml_call3
         (num_nodes_changed_fun, num_nodes_changed$0, record, record[21]),
     _jS_ =
       _jR_
       ||
        caml_call3
         (num_nodes_created_fun, num_nodes_created$0, record, record[22]),
     _jT_ =
       _jS_
       ||
        caml_call3
         (num_nodes_invalidated_fun,
          num_nodes_invalidated$0,
          record,
          record[23]),
     _jU_ =
       _jT_
       ||
        caml_call3
         (num_nodes_recomputed_fun,
          num_nodes_recomputed$0,
          record,
          record[24]),
     _jV_ =
       _jU_
       ||
        caml_call3
         (num_nodes_recomputed_directly_$0,
          num_nodes_recomputed_directly_$2,
          record,
          record[25]),
     _jW_ =
       _jV_
       ||
        caml_call3
         (num_nodes_recomputed_directly_,
          num_nodes_recomputed_directly_$1,
          record,
          record[26]);
    return _jW_
            ? _jW_
            : caml_call3(num_var_sets_fun, num_var_sets$0, record, record[27]);
   }
   function to_list$2
   (record,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _i__ =
       [0,
        caml_call3(num_var_sets_fun, num_var_sets$0, record, record[27]),
        0],
     _i$_ =
       [0,
        caml_call3
         (num_nodes_recomputed_directly_,
          num_nodes_recomputed_directly_$1,
          record,
          record[26]),
        _i__],
     _ja_ =
       [0,
        caml_call3
         (num_nodes_recomputed_directly_$0,
          num_nodes_recomputed_directly_$2,
          record,
          record[25]),
        _i$_],
     _jb_ =
       [0,
        caml_call3
         (num_nodes_recomputed_fun,
          num_nodes_recomputed$0,
          record,
          record[24]),
        _ja_],
     _jc_ =
       [0,
        caml_call3
         (num_nodes_invalidated_fun,
          num_nodes_invalidated$0,
          record,
          record[23]),
        _jb_],
     _jd_ =
       [0,
        caml_call3
         (num_nodes_created_fun, num_nodes_created$0, record, record[22]),
        _jc_],
     _je_ =
       [0,
        caml_call3
         (num_nodes_changed_fun, num_nodes_changed$0, record, record[21]),
        _jd_],
     _jf_ =
       [0,
        caml_call3
         (num_nodes_became_unnecessary_f,
          num_nodes_became_unnecessary$0,
          record,
          record[20]),
        _je_],
     _jg_ =
       [0,
        caml_call3
         (num_nodes_became_necessary_fun,
          num_nodes_became_necessary$0,
          record,
          record[19]),
        _jf_],
     _jh_ =
       [0,
        caml_call3
         (keep_node_creation_backtrace_f,
          keep_node_creation_backtrace$0,
          record,
          record[18]),
        _jg_],
     _ji_ =
       [0,
        caml_call3(weak_hashtbls_fun, weak_hashtbls$0, record, record[17]),
        _jh_],
     _jj_ =
       [0,
        caml_call3(only_in_debug_fun, only_in_debug$0, record, record[16]),
        _ji_],
     _jk_ =
       [0,
        caml_call3
         (run_on_update_handlers_fun,
          run_on_update_handlers$0,
          record,
          record[15]),
        _jj_],
     _jl_ =
       [0,
        caml_call3
         (handle_after_stabilization_fun,
          handle_after_stabilization$0,
          record,
          record[14]),
        _jk_],
     _jm_ =
       [0,
        caml_call3
         (set_during_stabilization_fun,
          set_during_stabilization$0,
          record,
          record[13]),
        _jl_],
     _jn_ =
       [0,
        caml_call3
         (disallowed_observers_fun,
          disallowed_observers$0,
          record,
          record[12]),
        _jm_],
     _jo_ =
       [0,
        caml_call3(new_observers_fun, new_observers$0, record, record[11]),
        _jn_],
     _jp_ =
       [0,
        caml_call3
         (finalized_observers_fun, finalized_observers$0, record, record[10]),
        _jo_],
     _jq_ =
       [0,
        caml_call3(all_observers_fun, all_observers$0, record, record[9]),
        _jp_],
     _jr_ =
       [0,
        caml_call3
         (num_active_observers_fun, num_active_observers$0, record, record[8]),
        _jq_],
     _js_ =
       [0,
        caml_call3
         (propagate_invalidity_fun, propagate_invalidity$0, record, record[7]),
        _jr_],
     _jt_ =
       [0,
        caml_call3
         (adjust_heights_heap_fun, adjust_heights_heap$0, record, record[6]),
        _js_],
     _ju_ =
       [0,
        caml_call3(recompute_heap_fun, recompute_heap$0, record, record[5]),
        _jt_],
     _jv_ =
       [0,
        caml_call3(current_scope_fun, current_scope$0, record, record[4]),
        _ju_],
     _jw_ =
       [0,
        caml_call3
         (stabilization_num_fun, stabilization_num$0, record, record[3]),
        _jv_],
     _jx_ =
       [0,
        caml_call3
         (bind_lhs_change_should_invalid,
          bind_lhs_change_should_invalid$0,
          record,
          record[2]),
        _jw_];
    return [0, caml_call3(status_fun, status$0, record, record[1]), _jx_];
   }
   function map$2
   (record,
    status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    var
     _iK_ = caml_call3(num_var_sets_fun, num_var_sets$0, record, record[27]),
     _iL_ =
       caml_call3
        (num_nodes_recomputed_directly_,
         num_nodes_recomputed_directly_$1,
         record,
         record[26]),
     _iM_ =
       caml_call3
        (num_nodes_recomputed_directly_$0,
         num_nodes_recomputed_directly_$2,
         record,
         record[25]),
     _iN_ =
       caml_call3
        (num_nodes_recomputed_fun, num_nodes_recomputed$0, record, record[24]),
     _iO_ =
       caml_call3
        (num_nodes_invalidated_fun,
         num_nodes_invalidated$0,
         record,
         record[23]),
     _iP_ =
       caml_call3
        (num_nodes_created_fun, num_nodes_created$0, record, record[22]),
     _iQ_ =
       caml_call3
        (num_nodes_changed_fun, num_nodes_changed$0, record, record[21]),
     _iR_ =
       caml_call3
        (num_nodes_became_unnecessary_f,
         num_nodes_became_unnecessary$0,
         record,
         record[20]),
     _iS_ =
       caml_call3
        (num_nodes_became_necessary_fun,
         num_nodes_became_necessary$0,
         record,
         record[19]),
     _iT_ =
       caml_call3
        (keep_node_creation_backtrace_f,
         keep_node_creation_backtrace$0,
         record,
         record[18]),
     _iU_ = caml_call3(weak_hashtbls_fun, weak_hashtbls$0, record, record[17]),
     _iV_ = caml_call3(only_in_debug_fun, only_in_debug$0, record, record[16]),
     _iW_ =
       caml_call3
        (run_on_update_handlers_fun,
         run_on_update_handlers$0,
         record,
         record[15]),
     _iX_ =
       caml_call3
        (handle_after_stabilization_fun,
         handle_after_stabilization$0,
         record,
         record[14]),
     _iY_ =
       caml_call3
        (set_during_stabilization_fun,
         set_during_stabilization$0,
         record,
         record[13]),
     _iZ_ =
       caml_call3
        (disallowed_observers_fun, disallowed_observers$0, record, record[12]),
     _i0_ = caml_call3(new_observers_fun, new_observers$0, record, record[11]),
     _i1_ =
       caml_call3
        (finalized_observers_fun, finalized_observers$0, record, record[10]),
     _i2_ = caml_call3(all_observers_fun, all_observers$0, record, record[9]),
     _i3_ =
       caml_call3
        (num_active_observers_fun, num_active_observers$0, record, record[8]),
     _i4_ =
       caml_call3
        (propagate_invalidity_fun, propagate_invalidity$0, record, record[7]),
     _i5_ =
       caml_call3
        (adjust_heights_heap_fun, adjust_heights_heap$0, record, record[6]),
     _i6_ =
       caml_call3(recompute_heap_fun, recompute_heap$0, record, record[5]),
     _i7_ = caml_call3(current_scope_fun, current_scope$0, record, record[4]),
     _i8_ =
       caml_call3
        (stabilization_num_fun, stabilization_num$0, record, record[3]),
     _i9_ =
       caml_call3
        (bind_lhs_change_should_invalid,
         bind_lhs_change_should_invalid$0,
         record,
         record[2]);
    return [0,
            caml_call3(status_fun, status$0, record, record[1]),
            _i9_,
            _i8_,
            _i7_,
            _i6_,
            _i5_,
            _i4_,
            _i3_,
            _i2_,
            _i1_,
            _i0_,
            _iZ_,
            _iY_,
            _iX_,
            _iW_,
            _iV_,
            _iU_,
            _iT_,
            _iS_,
            _iR_,
            _iQ_,
            _iP_,
            _iO_,
            _iN_,
            _iM_,
            _iL_,
            _iK_];
   }
   function set_all_mutable_fields$0
   (record,
    status,
    stabilization_num,
    current_scope,
    num_active_observers,
    all_observers,
    only_in_debug,
    keep_node_creation_backtrace,
    num_nodes_became_necessary,
    num_nodes_became_unnecessary,
    num_nodes_changed,
    num_nodes_created,
    num_nodes_invalidated,
    num_nodes_recomputed,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = status;
    record$0[3] = stabilization_num;
    record$0[4] = current_scope;
    record$0[8] = num_active_observers;
    record$0[9] = all_observers;
    record$0[16] = only_in_debug;
    record$0[18] = keep_node_creation_backtrace;
    record$0[19] = num_nodes_became_necessary;
    record$0[20] = num_nodes_became_unnecessary;
    record$0[21] = num_nodes_changed;
    record$0[22] = num_nodes_created;
    record$0[23] = num_nodes_invalidated;
    record$0[24] = num_nodes_recomputed;
    record$0[25] = num_nodes_recomputed_directly_$0;
    record$0[26] = num_nodes_recomputed_directly_;
    record$0[27] = num_var_sets;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       num_var_sets$0,
       num_nodes_recomputed_directly_$1,
       num_nodes_recomputed_directly_$2,
       num_nodes_recomputed$0,
       num_nodes_invalidated$0,
       num_nodes_created$0,
       num_nodes_changed$0,
       num_nodes_became_unnecessary$0,
       num_nodes_became_necessary$0,
       keep_node_creation_backtrace$0,
       weak_hashtbls$0,
       only_in_debug$0,
       run_on_update_handlers$0,
       handle_after_stabilization$0,
       set_during_stabilization$0,
       disallowed_observers$0,
       new_observers$0,
       finalized_observers$0,
       all_observers$0,
       num_active_observers$0,
       propagate_invalidity$0,
       adjust_heights_heap$0,
       recompute_heap$0,
       current_scope$0,
       stabilization_num$0,
       bind_lhs_change_should_invalid$0,
       status$0,
       make_creator$0,
       create$1,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0];
   function sexp_of_t$2(param){
    var
     status_015 = param[1],
     bind_lhs_change_should_invalid = param[2],
     stabilization_num_019 = param[3],
     current_scope_021 = param[4],
     propagate_invalidity_027 = param[7],
     adjust_heights_heap_025 = param[6],
     recompute_heap_023 = param[5],
     num_active_observers_029 = param[8],
     all_observers_031 = param[9],
     run_on_update_handlers_043 = param[15],
     handle_after_stabilization_041 = param[14],
     set_during_stabilization_039 = param[13],
     disallowed_observers_037 = param[12],
     new_observers_035 = param[11],
     finalized_observers_033 = param[10],
     only_in_debug_045 = param[16],
     weak_hashtbls_047 = param[17],
     keep_node_creation_backtrace_0 = param[18],
     num_nodes_became_necessary_051 = param[19],
     num_nodes_became_unnecessary_0 = param[20],
     num_nodes_changed_055 = param[21],
     num_nodes_created_057 = param[22],
     num_nodes_invalidated_059 = param[23],
     num_nodes_recomputed_061 = param[24],
     num_nodes_recomputed_directly_ = param[25],
     num_nodes_recomputed_directly_$0 = param[26],
     num_var_sets_067 = param[27],
     arg_068 = caml_call1(Core[356], num_var_sets_067),
     bnds_014 = [0, [1, [0, _as_, [0, arg_068, 0]]], 0],
     arg_066 = caml_call1(Core[356], num_nodes_recomputed_directly_$0),
     bnds_014$0 = [0, [1, [0, _at_, [0, arg_066, 0]]], bnds_014],
     arg_064 = caml_call1(Core[356], num_nodes_recomputed_directly_),
     bnds_014$1 = [0, [1, [0, _au_, [0, arg_064, 0]]], bnds_014$0],
     arg_062 = caml_call1(Core[356], num_nodes_recomputed_061),
     bnds_014$2 = [0, [1, [0, _av_, [0, arg_062, 0]]], bnds_014$1],
     arg_060 = caml_call1(Core[356], num_nodes_invalidated_059),
     bnds_014$3 = [0, [1, [0, _aw_, [0, arg_060, 0]]], bnds_014$2],
     arg_058 = caml_call1(Core[356], num_nodes_created_057),
     bnds_014$4 = [0, [1, [0, _ax_, [0, arg_058, 0]]], bnds_014$3],
     arg_056 = caml_call1(Core[356], num_nodes_changed_055),
     bnds_014$5 = [0, [1, [0, _ay_, [0, arg_056, 0]]], bnds_014$4],
     arg_054 = caml_call1(Core[356], num_nodes_became_unnecessary_0),
     bnds_014$6 = [0, [1, [0, _az_, [0, arg_054, 0]]], bnds_014$5],
     arg_052 = caml_call1(Core[356], num_nodes_became_necessary_051),
     bnds_014$7 = [0, [1, [0, _aA_, [0, arg_052, 0]]], bnds_014$6],
     arg_050 = caml_call1(Core[305], keep_node_creation_backtrace_0),
     bnds_014$8 = [0, [1, [0, _aB_, [0, arg_050, 0]]], bnds_014$7],
     arg_048 =
       caml_call2
        (Thread_safe_queue[1], Packed_weak_hashtbl[1], weak_hashtbls_047),
     bnds_014$9 = [0, [1, [0, _aC_, [0, arg_048, 0]]], bnds_014$8],
     arg_046 = caml_call1(Only_in_debug[6], only_in_debug_045),
     bnds_014$10 = [0, [1, [0, _aD_, [0, arg_046, 0]]], bnds_014$9],
     arg_044 =
       caml_call2
        (Core_Stack[2], Run_on_update_handlers[1], run_on_update_handlers_043),
     bnds_014$11 = [0, [1, [0, _aE_, [0, arg_044, 0]]], bnds_014$10],
     arg_042 =
       caml_call2
        (Core_Stack[2],
         Incremental_Node[1][1],
         handle_after_stabilization_041),
     bnds_014$12 = [0, [1, [0, _aF_, [0, arg_042, 0]]], bnds_014$11],
     arg_040 =
       caml_call2
        (Core_Stack[2], Incremental_Var[3][1], set_during_stabilization_039),
     bnds_014$13 = [0, [1, [0, _aG_, [0, arg_040, 0]]], bnds_014$12],
     arg_038 =
       caml_call2
        (Core_Stack[2],
         Incremental_Internal_observer[10][1],
         disallowed_observers_037),
     bnds_014$14 = [0, [1, [0, _aH_, [0, arg_038, 0]]], bnds_014$13],
     arg_036 =
       caml_call2
        (Core_Stack[2],
         Incremental_Internal_observer[10][1],
         new_observers_035),
     bnds_014$15 = [0, [1, [0, _aI_, [0, arg_036, 0]]], bnds_014$14],
     arg_034 =
       caml_call2
        (Thread_safe_queue[1],
         Incremental_Internal_observer[10][1],
         finalized_observers_033),
     bnds_014$16 = [0, [1, [0, _aJ_, [0, arg_034, 0]]], bnds_014$15],
     arg_032 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Internal_observer[10][1],
         all_observers_031),
     bnds_014$17 = [0, [1, [0, _aK_, [0, arg_032, 0]]], bnds_014$16],
     arg_030 = caml_call1(Core[356], num_active_observers_029),
     bnds_014$18 = [0, [1, [0, _aL_, [0, arg_030, 0]]], bnds_014$17],
     arg_028 =
       caml_call2
        (Core_Stack[2], Incremental_Node[1][1], propagate_invalidity_027),
     bnds_014$19 = [0, [1, [0, _aM_, [0, arg_028, 0]]], bnds_014$18],
     arg_026 =
       caml_call1(Incremental_Adjust_heights_hea[1], adjust_heights_heap_025),
     bnds_014$20 = [0, [1, [0, _aN_, [0, arg_026, 0]]], bnds_014$19],
     arg_024 = caml_call1(Incremental_Recompute_heap[1], recompute_heap_023),
     bnds_014$21 = [0, [1, [0, _aO_, [0, arg_024, 0]]], bnds_014$20],
     arg_022 = caml_call1(Incremental_Scope[1], current_scope_021),
     bnds_014$22 = [0, [1, [0, _aP_, [0, arg_022, 0]]], bnds_014$21],
     arg_020 =
       caml_call1(Incremental_Stabilization_num[2], stabilization_num_019),
     bnds_014$23 = [0, [1, [0, _aQ_, [0, arg_020, 0]]], bnds_014$22],
     arg_018 = caml_call1(Core[305], bind_lhs_change_should_invalid),
     bnds_014$24 = [0, [1, [0, _aR_, [0, arg_018, 0]]], bnds_014$23],
     arg_016 = sexp_of_status(status_015),
     bnds_014$25 = [0, [1, [0, _aS_, [0, arg_016, 0]]], bnds_014$24];
    return [1, bnds_014$25];
   }
   function fired_alarm_values(r){return r[4];}
   function set_fired_alarm_values(r, v){r[4] = v; return 0;}
   function handle_fired(r){return r[3];}
   function now(r){return r[2];}
   function timing_wheel(r){return r[1];}
   function _aT_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _aU_ = [0, set_fired_alarm_values],
    fired_alarm_values$0 =
      [0,
       function(param){return 0;},
       cst_fired_alarm_values,
       _aU_,
       fired_alarm_values,
       _aT_];
   function _aV_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _aW_ = 0,
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       _aW_,
       handle_fired,
       _aV_];
   function _aX_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _aY_ = 0,
    now$0 = [0, function(param){return 0;}, cst_now, _aY_, now, _aX_];
   function _aZ_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _a0_ = 0,
    timing_wheel$0 =
      [0,
       function(param){return 0;},
       cst_timing_wheel,
       _a0_,
       timing_wheel,
       _aZ_];
   function make_creator$1
   (timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun,
    compile_acc){
    var
     match = caml_call2(timing_wheel_fun, timing_wheel$0, compile_acc),
     compile_acc$0 = match[2],
     timing_wheel_gen = match[1],
     match$0 = caml_call2(now_fun, now$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     now_gen = match$0[1],
     match$1 = caml_call2(handle_fired_fun, handle_fired$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     handle_fired_gen = match$1[1],
     match$2 =
       caml_call2(fired_alarm_values_fun, fired_alarm_values$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     fired_alarm_values_gen = match$2[1];
    return [0,
            function(acc){
             var
              timing_wheel = caml_call1(timing_wheel_gen, acc),
              now = caml_call1(now_gen, acc),
              handle_fired = caml_call1(handle_fired_gen, acc),
              fired_alarm_values = caml_call1(fired_alarm_values_gen, acc);
             return [0, timing_wheel, now, handle_fired, fired_alarm_values];
            },
            compile_acc$3];
   }
   function create$2(timing_wheel, now, handle_fired, fired_alarm_values){return [0, timing_wheel, now, handle_fired, fired_alarm_values];
   }
   function map$3
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    var
     _iH_ = caml_call1(fired_alarm_values_fun, fired_alarm_values$0),
     _iI_ = caml_call1(handle_fired_fun, handle_fired$0),
     _iJ_ = caml_call1(now_fun, now$0);
    return [0, caml_call1(timing_wheel_fun, timing_wheel$0), _iJ_, _iI_, _iH_];
   }
   function iter$3
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    caml_call1(timing_wheel_fun, timing_wheel$0);
    caml_call1(now_fun, now$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    return caml_call1(fired_alarm_values_fun, fired_alarm_values$0);
   }
   function fold$3
   (init, timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    return caml_call2
            (fired_alarm_values_fun,
             caml_call2
              (handle_fired_fun,
               caml_call2
                (now_fun,
                 caml_call2(timing_wheel_fun, init, timing_wheel$0),
                 now$0),
               handle_fired$0),
             fired_alarm_values$0);
   }
   function map_poly$1(record){
    var
     _iE_ = [0, caml_call1(record[1], fired_alarm_values$0), 0],
     _iF_ = [0, caml_call1(record[1], handle_fired$0), _iE_],
     _iG_ = [0, caml_call1(record[1], now$0), _iF_];
    return [0, caml_call1(record[1], timing_wheel$0), _iG_];
   }
   function for_all$3
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    var
     _iB_ = caml_call1(timing_wheel_fun, timing_wheel$0),
     _iC_ = _iB_ ? caml_call1(now_fun, now$0) : _iB_,
     _iD_ = _iC_ ? caml_call1(handle_fired_fun, handle_fired$0) : _iC_;
    return _iD_
            ? caml_call1(fired_alarm_values_fun, fired_alarm_values$0)
            : _iD_;
   }
   function exists$3
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    var
     _iA_ = caml_call1(timing_wheel_fun, timing_wheel$0),
     _iy_ = _iA_ || caml_call1(now_fun, now$0),
     _iz_ = _iy_ || caml_call1(handle_fired_fun, handle_fired$0);
    return _iz_
            ? _iz_
            : caml_call1(fired_alarm_values_fun, fired_alarm_values$0);
   }
   function to_list$3
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    var
     _iv_ = [0, caml_call1(fired_alarm_values_fun, fired_alarm_values$0), 0],
     _iw_ = [0, caml_call1(handle_fired_fun, handle_fired$0), _iv_],
     _ix_ = [0, caml_call1(now_fun, now$0), _iw_];
    return [0, caml_call1(timing_wheel_fun, timing_wheel$0), _ix_];
   }
   function iter$4
   (record,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    caml_call3(timing_wheel_fun, timing_wheel$0, record, record[1]);
    caml_call3(now_fun, now$0, record, record[2]);
    caml_call3(handle_fired_fun, handle_fired$0, record, record[3]);
    return caml_call3
            (fired_alarm_values_fun, fired_alarm_values$0, record, record[4]);
   }
   function fold$4
   (record,
    init,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    var _is_ = record[4], _it_ = record[3], _iu_ = record[2];
    return caml_call4
            (fired_alarm_values_fun,
             caml_call4
              (handle_fired_fun,
               caml_call4
                (now_fun,
                 caml_call4
                  (timing_wheel_fun, init, timing_wheel$0, record, record[1]),
                 now$0,
                 record,
                 _iu_),
               handle_fired$0,
               record,
               _it_),
             fired_alarm_values$0,
             record,
             _is_);
   }
   function for_all$4
   (record,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    var
     _ip_ = caml_call3(timing_wheel_fun, timing_wheel$0, record, record[1]),
     _iq_ = _ip_ ? caml_call3(now_fun, now$0, record, record[2]) : _ip_,
     _ir_ =
       _iq_
        ? caml_call3(handle_fired_fun, handle_fired$0, record, record[3])
        : _iq_;
    return _ir_
            ? caml_call3
              (fired_alarm_values_fun,
               fired_alarm_values$0,
               record,
               record[4])
            : _ir_;
   }
   function exists$4
   (record,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    var
     _io_ = caml_call3(timing_wheel_fun, timing_wheel$0, record, record[1]),
     _im_ = _io_ || caml_call3(now_fun, now$0, record, record[2]),
     _in_ =
       _im_ || caml_call3(handle_fired_fun, handle_fired$0, record, record[3]);
    return _in_
            ? _in_
            : caml_call3
              (fired_alarm_values_fun,
               fired_alarm_values$0,
               record,
               record[4]);
   }
   function to_list$4
   (record,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    var
     _ij_ =
       [0,
        caml_call3
         (fired_alarm_values_fun, fired_alarm_values$0, record, record[4]),
        0],
     _ik_ =
       [0,
        caml_call3(handle_fired_fun, handle_fired$0, record, record[3]),
        _ij_],
     _il_ = [0, caml_call3(now_fun, now$0, record, record[2]), _ik_];
    return [0,
            caml_call3(timing_wheel_fun, timing_wheel$0, record, record[1]),
            _il_];
   }
   function map$4
   (record,
    timing_wheel_fun,
    now_fun,
    handle_fired_fun,
    fired_alarm_values_fun){
    var
     _ig_ =
       caml_call3
        (fired_alarm_values_fun, fired_alarm_values$0, record, record[4]),
     _ih_ = caml_call3(handle_fired_fun, handle_fired$0, record, record[3]),
     _ii_ = caml_call3(now_fun, now$0, record, record[2]);
    return [0,
            caml_call3(timing_wheel_fun, timing_wheel$0, record, record[1]),
            _ii_,
            _ih_,
            _ig_];
   }
   function set_all_mutable_fields$1(record, fired_alarm_values){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[4] = fired_alarm_values;
    return 0;
   }
   var
    Direct$1 =
      [0,
       iter$4,
       fold$4,
       for_all$4,
       exists$4,
       to_list$4,
       map$4,
       set_all_mutable_fields$1],
    Fields$1 =
      [0,
       names$1,
       fired_alarm_values$0,
       handle_fired$0,
       now$0,
       timing_wheel$0,
       make_creator$1,
       create$2,
       map$3,
       iter$3,
       fold$3,
       map_poly$1,
       for_all$3,
       exists$3,
       to_list$3,
       Direct$1];
   function sexp_of_t$3(param){
    var
     now_072 = param[2],
     timing_wheel_070 = param[1],
     fired_alarm_values_076 = param[4],
     arg_077 =
       caml_call2
        (Incremental_Import[16][1],
         Incremental_Alarm_value[3],
         fired_alarm_values_076),
     bnds_069 = [0, [1, [0, _a1_, [0, arg_077, 0]]], 0];
    function _ie_(_if_){return 0;}
    var
     arg_075 = caml_call1(Sexplib0_Sexp_conv[24], _ie_),
     bnds_069$0 = [0, [1, [0, _a2_, [0, arg_075, 0]]], bnds_069],
     arg_073 =
       caml_call2(Incremental_Var[2], Incremental_Import[14][119], now_072),
     bnds_069$1 = [0, [1, [0, _a3_, [0, arg_073, 0]]], bnds_069$0],
     arg_071 =
       caml_call2
        (Timing_wheel[2], Incremental_Alarm_value[3], timing_wheel_070),
     bnds_069$2 = [0, [1, [0, _a4_, [0, arg_071, 0]]], bnds_069$1];
    return [1, bnds_069$2];
   }
   function invariant$1(t){
    function _h9_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      _h__ =
        check
         (function(fired_alarm_values){
           if(caml_call1(Incremental_Import[16][5], fired_alarm_values))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
          });
     function _h$_(_id_){return 0;}
     var
      _ia_ =
        check
         (function(now){
           var _ic_ = caml_call1(Timing_wheel[11], t[1]);
           if(caml_call2(Incremental_Import[14][21], now[1], _ic_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
          }),
      _ib_ = check(caml_call1(Timing_wheel[6], Incremental_Alarm_value[2]));
     return caml_call4(Fields$1[9], _ib_, _ia_, _h$_, _h__);
    }
    return caml_call4(Base_Invariant[1], _a7_, t, sexp_of_t$3, _h9_);
   }
   function incr_state(t){return caml_call1(Incremental_Var[5], t[2]);}
   var
    Clock =
      [0,
       fired_alarm_values,
       set_fired_alarm_values,
       handle_fired,
       now,
       timing_wheel,
       Fields$1,
       sexp_of_t$3,
       invariant$1,
       incr_state];
   function now$1(clock){return clock[2][1];}
   function timing_wheel_length(clock){
    return caml_call1(Timing_wheel[14], clock[1]);
   }
   function num_stabilizes(t){
    return caml_call1(Incremental_Stabilization_num[10], t[3]);
   }
   function max_height_allowed(t){
    return caml_call1(Incremental_Adjust_heights_hea[5], t[6]);
   }
   function max_height_seen(t){
    return caml_call1(Incremental_Adjust_heights_hea[7], t[6]);
   }
   function iter_observers(t, f){
    var r = [0, t[9]];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r[1])) return 0;
     var observer = caml_call1(Incremental_Import[16][11], r[1]);
     r[1] = caml_call1(Incremental_Internal_observer[10][3], observer);
     caml_call1(f, observer);
    }
   }
   function directly_observed(t){
    var r = [0, 0];
    iter_observers(t, function(param){r[1] = [0, param[2], r[1]]; return 0;});
    return r[1];
   }
   function save_dot(t, out){
    var _h8_ = directly_observed(t);
    return caml_call2(Incremental_Node[1][5], out, _h8_);
   }
   function save_dot_to_file(t, file){
    var _h7_ = directly_observed(t);
    return caml_call2(Incremental_Node[1][6], file, _h7_);
   }
   function iter_observer_descendants(t, f){
    var _h6_ = directly_observed(t);
    return caml_call2(Incremental_Node[1][4], _h6_, f);
   }
   function t_of_sexp(sexp_079){
    if(0 === sexp_079[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_095, sexp_079);
    var
     field_sexps_080 = sexp_079[1],
     max_num_parents_081 = [0, 0],
     percentage_of_nodes_by_num_par = [0, 0],
     duplicates_085 = [0, 0],
     extra_086 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_080;
       for(;;){
        if(! param) break;
        var sexp_079$0 = param[1];
        if(1 !== sexp_079$0[0]) break b;
        var _h0_ = sexp_079$0[1];
        if(! _h0_) break c;
        var _h1_ = _h0_[1];
        if(0 !== _h1_[0]) break e;
        var field_sexps_089 = _h0_[2], field_name_087 = _h1_[1];
        if(field_sexps_089 && field_sexps_089[2]) break d;
        var
         tail_099 = param[2],
         field_sexp_088$2 =
           function(field_sexps_089){
            function field_sexp_088(param){
             if(! field_sexps_089)
              return caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_095, sexp_079);
             if(field_sexps_089[2])
              throw caml_maybe_attach_backtrace([0, Assert_failure, _a8_], 1);
             var x_100 = field_sexps_089[1];
             return x_100;
            }
            return field_sexp_088;
           },
         field_sexp_088 = field_sexp_088$2(field_sexps_089);
        if(caml_string_notequal(field_name_087, cst_max_num_parents$0))
         if
          (caml_string_notequal
            (field_name_087, cst_percentage_of_nodes_by_num$0)){
          if(Sexplib0_Sexp_conv[26][1])
           extra_086[1] = [0, field_name_087, extra_086[1]];
         }
         else if(percentage_of_nodes_by_num_par[1])
          duplicates_085[1] = [0, field_name_087, duplicates_085[1]];
         else{
          var
           field_sexp_088$0 = field_sexp_088(0),
           _h2_ =
             function(sexp_094){
              if(1 === sexp_094[0]){
               var _h4_ = sexp_094[1];
               if(_h4_){
                var _h5_ = _h4_[2];
                if(_h5_ && ! _h5_[2]){
                 var
                  arg1_091 = _h5_[1],
                  arg0_090 = _h4_[1],
                  res0_092 = caml_call1(Core[357], arg0_090),
                  res1_093 = caml_call1(Core_Percent[7], arg1_091);
                 return [0, res0_092, res1_093];
                }
               }
              }
              return caml_call3
                      (Sexplib0_Sexp_conv_error[2], error_source_095, 2, sexp_094);
             },
           fvalue_096 = caml_call2(Core[422], _h2_, field_sexp_088$0);
          percentage_of_nodes_by_num_par[1] = [0, fvalue_096];
         }
        else if(max_num_parents_081[1])
         duplicates_085[1] = [0, field_name_087, duplicates_085[1]];
        else{
         var
          field_sexp_088$1 = field_sexp_088(0),
          fvalue_097 = caml_call1(Core[357], field_sexp_088$1);
         max_num_parents_081[1] = [0, fvalue_097];
        }
        var param = tail_099;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_095, sexp_079$0);
    }
    if(duplicates_085[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_095,
              duplicates_085[1],
              sexp_079);
    if(extra_086[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_095,
              extra_086[1],
              sexp_079);
    var
     _h3_ = max_num_parents_081[1],
     match = percentage_of_nodes_by_num_par[1];
    if(_h3_ && match){
     var
      percentage_of_nodes_by_num_par$0 = match[1],
      max_num_parents_082 = _h3_[1];
     return [0, max_num_parents_082, percentage_of_nodes_by_num_par$0];
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[15],
             error_source_095,
             sexp_079,
             [0,
              [0, 0 === max_num_parents_081[1] ? 1 : 0, cst_max_num_parents],
              [0,
               [0,
                0 === percentage_of_nodes_by_num_par[1] ? 1 : 0,
                cst_percentage_of_nodes_by_num],
               0]]);
   }
   function sexp_of_t$4(param){
    var
     percentage_of_nodes_by_num_par = param[2],
     max_num_parents_102 = param[1],
     bnds_101 = 0;
    function _hZ_(param){
     var
      arg1_107 = param[2],
      arg0_106 = param[1],
      res0_108 = caml_call1(Core[356], arg0_106),
      res1_109 = caml_call1(Core_Percent[8], arg1_107);
     return [1, [0, res0_108, [0, res1_109, 0]]];
    }
    var
     arg_105 = caml_call2(Core[421], _hZ_, percentage_of_nodes_by_num_par),
     bnds_101$0 = [0, [1, [0, _a9_, [0, arg_105, 0]]], bnds_101],
     arg_103 = caml_call1(Core[356], max_num_parents_102),
     bnds_101$1 = [0, [1, [0, _a__, [0, arg_103, 0]]], bnds_101$0];
    return [1, bnds_101$1];
   }
   var Stats = [0, t_of_sexp, sexp_of_t$4];
   function stats(t){
    var max_num_parents = [0, -1], num_necessary_nodes = [0, 0];
    iter_observer_descendants
     (t,
      function(param){
       num_necessary_nodes[1]++;
       max_num_parents[1] =
        caml_call2(Core_Int[93], max_num_parents[1], param[9]);
       return 0;
      });
    var
     max_num_parents$0 = max_num_parents[1],
     num_nodes_by_num_parents =
       caml_call2(Incremental_Import[15][38], max_num_parents$0 + 1 | 0, 0);
    iter_observer_descendants
     (t,
      function(param){
       var num_parents = param[9];
       num_nodes_by_num_parents[1 + num_parents] =
        caml_check_bound(num_nodes_by_num_parents, num_parents)
         [1 + num_parents]
        + 1
        | 0;
       return 0;
      });
    function _hX_(i, ac, num_nodes){
     return caml_call2(Incremental_Import[3], num_nodes, 0)
             ? ac
             : [0,
               [0,
                i,
                caml_call1
                 (Core_Percent[71], num_nodes / num_necessary_nodes[1])],
               ac];
    }
    var
     _hY_ =
       caml_call3
        (Incremental_Import[15][60], num_nodes_by_num_parents, 0, _hX_),
     percentage_of_nodes_by_num_par = caml_call1(Core_List[34], _hY_);
    return [0, max_num_parents$0, percentage_of_nodes_by_num_par];
   }
   function am_stabilizing(t){
    var match = t[1];
    if(typeof match === "number") return 2 <= match ? 0 : 1;
    var raised_exn = match[1];
    return caml_call5
            (Core[236],
             0,
             _a$_,
             cst_cannot_call_am_stabilizing,
             raised_exn,
             Incremental_Raised_exn[1]);
   }
   function invariant$2(t){
    if(typeof t[1] !== "number") return 0;
    function _g4_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     iter_observers
      (t,
       function(internal_observer){
        if(1 < internal_observer[1] - 1 >>> 0){
         var
          _hT_ =
            function(x_110){
             function _hW_(param){return _ba_;}
             return caml_call2(Incremental_Internal_observer[2], _hW_, x_110);
            };
         caml_call5
          (Core[236],
           0,
           _bb_,
           cst_member_of_all_observers_wi,
           internal_observer,
           _hT_);
        }
        function _hU_(_hV_){return 0;}
        return caml_call2
                (Incremental_Internal_observer[1], _hU_, internal_observer);
       });
     iter_observer_descendants
      (t,
       function(node){
        function _hQ_(_hS_){return 0;}
        caml_call2(Incremental_Node[4], _hQ_, node);
        if
         (1 - am_stabilizing(t)
          && ! caml_call1(Incremental_Import[16][5], node[20]))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bd_], 1);
        var _hR_ = caml_call1(Incremental_Adjust_heights_hea[7], t[6]);
        if(caml_call2(Incremental_Import[2], node[14], _hR_)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bc_], 1);
       });
     var
      _g5_ = caml_call1(Incremental_Recompute_heap[5], t[5]),
      _g6_ = caml_call1(Incremental_Adjust_heights_hea[5], t[6]);
     if(! caml_call2(Incremental_Import[3], _g6_, _g5_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bn_], 1);
     function _g7_(_hP_){return 0;}
     function _g8_(_hO_){return 0;}
     function _g9_(_hN_){return 0;}
     function _g__(_hM_){return 0;}
     function _g$_(_hL_){return 0;}
     function _ha_(_hK_){return 0;}
     function _hb_(_hJ_){return 0;}
     function _hc_(_hI_){return 0;}
     function _hd_(_hH_){return 0;}
     function _he_(_hG_){return 0;}
     function _hf_(_hF_){return 0;}
     var
      _hg_ = check(Only_in_debug[7]),
      _hh_ = check(caml_call1(Core_Stack[4], Run_on_update_handlers[2])),
      _hi_ = check(caml_call1(Core_Stack[4], Incremental_Node[1][2])),
      _hj_ =
        check
         (function(set_during_stabilization){
           var _hD_ = t[1];
           if(typeof _hD_ !== "number")
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bg_], 1);
           if(! _hD_){
            var
             _hE_ =
               function(param){
                if(caml_call1(Incremental_Import[16][6], param[2])) return 0;
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bf_], 1);
               };
            return caml_call2(Core_Stack[4], _hE_, set_during_stabilization);
           }
           if(caml_call1(Core_Stack[7], set_during_stabilization)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _be_], 1);
          });
     function _hk_(packed){
      caml_call1(Incremental_Internal_observer[10][2], packed);
      if(2 === packed[1]) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bh_], 1);
     }
     var _hl_ = check(caml_call1(Core_Stack[4], _hk_));
     function _hm_(packed){
      caml_call1(Incremental_Internal_observer[10][2], packed);
      if(1 < packed[1] - 1 >>> 0) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bi_], 1);
     }
     var _hn_ = check(caml_call1(Core_Stack[4], _hm_));
     function _ho_(_hC_){return 0;}
     function _hp_(_hB_){return 0;}
     var
      _hq_ =
        check
         (function(num_active_observers){
           if(caml_call2(Incremental_Import[1], num_active_observers, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bj_], 1);
          }),
      _hr_ =
        check
         (function(propagate_invalidity){
           if(caml_call1(Core_Stack[7], propagate_invalidity)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bk_], 1);
          }),
      _hs_ =
        check
         (function(adjust_heights_heap){
           var
            _hA_ =
              caml_call1
               (Incremental_Adjust_heights_hea[4], adjust_heights_heap);
           if(caml_call2(Incremental_Import[3], _hA_, 0))
            return caml_call1
                    (Incremental_Adjust_heights_hea[2], adjust_heights_heap);
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bl_], 1);
          }),
      _ht_ = check(Incremental_Recompute_heap[2]),
      _hu_ =
        check
         (function(current_scope){
           if(caml_call2(Core[246], current_scope, Incremental_Scope[3]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bm_], 1);
          }),
      _hv_ = check(Incremental_Stabilization_num[4]);
     function _hw_(_hz_){return 0;}
     function _hx_(_hy_){return 0;}
     return caml_call27
             (Fields$0[32],
              _hx_,
              _hw_,
              _hv_,
              _hu_,
              _ht_,
              _hs_,
              _hr_,
              _hq_,
              _hp_,
              _ho_,
              _hn_,
              _hl_,
              _hj_,
              _hi_,
              _hh_,
              _hg_,
              _hf_,
              _he_,
              _hd_,
              _hc_,
              _hb_,
              _ha_,
              _g$_,
              _g__,
              _g9_,
              _g8_,
              _g7_);
    }
    return caml_call4(Base_Invariant[1], _bo_, t, sexp_of_t$2, _g4_);
   }
   function ensure_not_stabilizing(t, name, allow_in_update_handler){
    var match = t[1];
    if(typeof match === "number")
     switch(match){
       case 0:
        var
         backtrace = caml_call2(Base_Backtrace[2], 0, 0),
         _gX_ = Base_Backtrace[1],
         _gY_ = caml_call2(Core[257], _bp_, name);
        return caml_call5(Core[236], 0, _bq_, _gY_, backtrace, _gX_);
       case 1:
        var _gZ_ = 1 - allow_in_update_handler;
        if(! _gZ_) return _gZ_;
        var
         backtrace$0 = caml_call2(Base_Backtrace[2], 0, 0),
         _g0_ = Base_Backtrace[1],
         _g1_ = caml_call2(Core[257], _br_, name);
        return caml_call5(Core[236], 0, _bs_, _g1_, backtrace$0, _g0_);
       default: return 0;
     }
    var
     raised_exn = match[1],
     backtrace$1 = caml_call2(Base_Backtrace[2], 0, 0);
    function _g2_(param){
     var
      arg1_112 = param[2],
      arg0_111 = param[1],
      res0_113 = caml_call1(Incremental_Raised_exn[1], arg0_111),
      res1_114 = caml_call1(Base_Backtrace[1], arg1_112);
     return [1, [0, res0_113, [0, res1_114, 0]]];
    }
    var _g3_ = caml_call2(Core[257], _bt_, name);
    return caml_call5
            (Core[236], 0, _bu_, _g3_, [0, raised_exn, backtrace$1], _g2_);
   }
   function set_height(node, height){
    var t = node[2];
    return caml_call3(Incremental_Adjust_heights_hea[8], t[6], node, height);
   }
   function set_max_height_allowed(t, height){
    ensure_not_stabilizing(t, cst_set_max_height_allowed, 1);
    caml_call2(Incremental_Adjust_heights_hea[6], t[6], height);
    return caml_call2(Incremental_Recompute_heap[6], t[5], height);
   }
   function handle_after_stabilization$1(node){
    var _gW_ = 1 - node[22];
    if(! _gW_) return _gW_;
    var t = node[2];
    node[22] = 1;
    return caml_call2(Core_Stack[25], t[14], node);
   }
   function remove_children(parent){
    function _gV_(child_index, param){
     return remove_child(param, parent, child_index);
    }
    return caml_call2(Incremental_Node[8], parent, _gV_);
   }
   function remove_child(child, parent, child_index){
    caml_call3(Incremental_Node[11], child, parent, child_index);
    return check_if_unnecessary(child);
   }
   function check_if_unnecessary(node){
    var _gU_ = 1 - caml_call1(Incremental_Node[15], node);
    return _gU_ ? became_unnecessary(node) : _gU_;
   }
   function became_unnecessary(node){
    var t = node[2];
    t[20] = t[20] + 1 | 0;
    if(caml_call2(Incremental_Import[4], node[8], 0))
     handle_after_stabilization$1(node);
    node[14] = -1;
    remove_children(node);
    var match = node[5];
    a:
    if(typeof match !== "number")
     switch(match[0]){
       case 6:
        var p = match[1]; caml_call2(Incremental_Expert[14], p, 0); break a;
       case 15:
        var u = match[1];
        caml_call1(Incremental_Unordered_array_fo[7], u);
        break a;
     }
    if(Incremental_Import[11] && caml_call1(Incremental_Node[20], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bv_], 1);
    var _gT_ = caml_call1(Incremental_Node[14], node);
    return _gT_ ? caml_call2(Incremental_Recompute_heap[9], t[5], node) : _gT_;
   }
   function remove_alarm(clock, alarm){
    var _gS_ = caml_call2(Timing_wheel[27], clock[1], alarm);
    return _gS_ ? caml_call2(Timing_wheel[28], clock[1], alarm) : _gS_;
   }
   function invalidate_node(node){
    var _gL_ = caml_call1(Incremental_Node[16], node);
    if(_gL_){
     var t = node[2];
     if(caml_call2(Incremental_Import[4], node[8], 0))
      handle_after_stabilization$1(node);
     node[4] = Incremental_Import[16][3];
     if
      (Incremental_Import[11]
       && ! caml_call1(Incremental_Import[16][5], node[20]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bx_], 1);
     node[7] = t[3];
     node[3] = t[3];
     t[23] = t[23] + 1 | 0;
     if(caml_call1(Incremental_Node[15], node)){
      remove_children(node);
      node[14] = caml_call1(Incremental_Scope[5], node[12]) + 1 | 0;
     }
     var match = node[5];
     a:
     if(typeof match !== "number")
      switch(match[0]){
        case 1:
         var at = match[1]; remove_alarm(at[4], at[3]); break a;
        case 2:
         var at_intervals = match[1];
         remove_alarm(at_intervals[5], at_intervals[4]);
         break a;
        case 4:
         var bind = match[1];
         invalidate_nodes_created_on_rh(bind[7]);
         break a;
        case 14:
         var match$0 = match[1], alarm = match$0[6], clock = match$0[8];
         remove_alarm(clock, alarm);
         break a;
      }
     caml_call2(Incremental_Node[6], node, 0);
     var _gN_ = node[9] - 1 | 0, _gM_ = 0;
     if(_gN_ >= 0){
      var index = _gM_;
      for(;;){
       var _gQ_ = caml_call2(Incremental_Node[9], node, index);
       caml_call2(Core_Stack[25], t[7], _gQ_);
       var _gR_ = index + 1 | 0;
       if(_gN_ === index) break;
       var index = _gR_;
      }
     }
     if(Incremental_Import[11] && caml_call1(Incremental_Node[20], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bw_], 1);
     var _gO_ = caml_call1(Incremental_Node[14], node);
     if(_gO_) return caml_call2(Incremental_Recompute_heap[9], t[5], node);
     var _gP_ = _gO_;
    }
    else
     var _gP_ = _gL_;
    return _gP_;
   }
   function invalidate_nodes_created_on_rh(node){
    var r = [0, node];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r[1])) return 0;
     var match = caml_call1(Incremental_Import[16][11], r[1]);
     r[1] = match[13];
     match[13] = Incremental_Import[16][3];
     invalidate_node(match);
    }
   }
   function rescope_nodes_created_on_rhs(t, first_node_on_rhs, new_scope){
    var r = [0, first_node_on_rhs];
    for(;;){
     if(! caml_call1(Incremental_Import[16][6], r[1])) return 0;
     var match = caml_call1(Incremental_Import[16][11], r[1]);
     r[1] = match[13];
     match[13] = Incremental_Import[16][3];
     match[12] = new_scope;
     caml_call2(Incremental_Scope[8], new_scope, match);
    }
   }
   function propagate_invalidity$1(t){
    for(;;){
     if(caml_call1(Core_Stack[7], t[7])) return 0;
     var node = caml_call1(Core_Stack[27], t[7]);
     if(caml_call1(Incremental_Node[16], node))
      if(caml_call1(Incremental_Node[17], node))
       invalidate_node(node);
      else{
       if(Incremental_Import[11] && ! caml_call1(Incremental_Node[20], node))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bz_], 1);
       var kind = node[5];
       a:
       {
        if(typeof kind !== "number" && 6 === kind[0]){
         var expert = kind[1];
         caml_call1(Incremental_Expert[7], expert);
         break a;
        }
        if(Incremental_Import[11]){
         if(typeof kind !== "number")
          switch(kind[0]){case 4:case 9:case 11: break a;}
         throw caml_maybe_attach_backtrace([0, Assert_failure, _by_], 1);
        }
       }
       if(1 - caml_call1(Incremental_Node[14], node))
        caml_call2(Incremental_Recompute_heap[8], t[5], node);
      }
    }
   }
   function add_parent_without_adjusting_h(child, parent, child_index){
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bB_], 1);
    var t = child[2], was_necessary = caml_call1(Incremental_Node[15], child);
    caml_call3(Incremental_Node[10], child, parent, child_index);
    if(1 - caml_call1(Incremental_Node[16], child))
     caml_call2(Core_Stack[25], t[7], parent);
    if(1 - was_necessary) _bA_(child);
    var match = parent[5];
    if(typeof match !== "number" && 6 === match[0]){
     var e = match[1];
     return caml_call2(Incremental_Expert[15], e, child_index);
    }
    return 0;
   }
   function _bA_(node){
    var
     _gF_ = caml_call1(Incremental_Node[16], node),
     _gG_ = _gF_ ? 1 - caml_call1(Incremental_Scope[7], node[12]) : _gF_;
    if(_gG_){
     var
      _gH_ =
        function(x_115){
         function _gK_(param){return _bC_;}
         return caml_call2(Incremental_Node[2], _gK_, x_115);
        };
     caml_call5
      (Core[236], 0, _bD_, cst_Trying_to_make_a_node_nece, node, _gH_);
    }
    var t = node[2];
    t[19] = t[19] + 1 | 0;
    if(caml_call2(Incremental_Import[4], node[8], 0))
     handle_after_stabilization$1(node);
    set_height(node, caml_call1(Incremental_Scope[5], node[12]) + 1 | 0);
    function _gI_(child_index, child){
     add_parent_without_adjusting_h(child, node, child_index);
     if
      (Incremental_Import[11]
       && ! caml_call2(Incremental_Import[1], child[14], 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bE_], 1);
     var _gJ_ = caml_call2(Incremental_Import[1], child[14], node[14]);
     return _gJ_ ? set_height(node, child[14] + 1 | 0) : _gJ_;
    }
    caml_call2(Incremental_Node[8], node, _gI_);
    if(Incremental_Import[11] && caml_call1(Incremental_Node[14], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bF_], 1);
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bG_], 1);
    if(caml_call1(Incremental_Node[19], node))
     caml_call2(Incremental_Recompute_heap[8], t[5], node);
    var match = node[5];
    if(typeof match !== "number" && 6 === match[0]){
     var p = match[1];
     return caml_call2(Incremental_Expert[14], p, 1);
    }
    return;
   }
   function became_necessary(node){
    _bA_(node);
    return propagate_invalidity$1(node[2]);
   }
   function add_parent(child, parent, child_index){
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bI_], 1);
    var t = parent[2];
    add_parent_without_adjusting_h(child, parent, child_index);
    if(caml_call2(Incremental_Import[1], child[14], parent[14]))
     caml_call4(Incremental_Adjust_heights_hea[9], t[6], t[5], child, parent);
    propagate_invalidity$1(t);
    if(Incremental_Import[11] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bH_], 1);
    var _gC_ = 1 - caml_call1(Incremental_Node[14], parent);
    if(_gC_)
     var
      _gD_ = caml_call1(Incremental_Stabilization_num[7], parent[3]),
      _gE_ = _gD_ || caml_call2(Incremental_Node[18], child, parent);
    else
     var _gE_ = _gC_;
    return _gE_
            ? caml_call2(Incremental_Recompute_heap[8], t[5], parent)
            : _gE_;
   }
   function run_with_scope(t, scope, f){
    var saved = t[4];
    t[4] = scope;
    try{var v = caml_call1(f, 0); t[4] = saved; return v;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[4] = saved;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function within_scope(t, scope, f){
    if(1 - caml_call1(Incremental_Scope[6], scope))
     caml_call5
      (Core[236], 0, _bJ_, cst_attempt_to_run_within_an_i, t, sexp_of_t$2);
    return run_with_scope(t, scope, f);
   }
   function change_child(parent, old_child, new_child, child_index){
    if(caml_call1(Incremental_Import[16][5], old_child))
     return add_parent(new_child, parent, child_index);
    var
     old_child$0 = caml_call1(Incremental_Import[16][11], old_child),
     _gB_ = 1 - caml_call2(Core[246], old_child$0, new_child);
    return _gB_
            ? (caml_call3
               (Incremental_Node[11], old_child$0, parent, child_index),
              old_child$0[26] = 1,
              add_parent(new_child, parent, child_index),
              old_child$0[26] = 0,
              check_if_unnecessary(old_child$0))
            : _gB_;
   }
   function add_alarm(clock, at, alarm_value){
    if(Incremental_Import[11]){
     var _gA_ = now$1(clock);
     if(! caml_call2(Incremental_Import[14][18], at, _gA_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bK_], 1);
    }
    return caml_call3(Timing_wheel[25], clock[1], at, alarm_value);
   }
   function recompute(node){
    var t = node[2];
    if(Incremental_Import[11]){t[16][1] = [0, node]; t[16][2] = 0;}
    t[24] = t[24] + 1 | 0;
    node[3] = t[3];
    var match = node[5];
    if(typeof match === "number"){
     if(0 === match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bL_], 1);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bM_], 1);
    }
    switch(match[0]){
      case 0:
       var array_fold = match[1];
       return maybe_change_value
               (node, caml_call1(Incremental_Array_fold[3], array_fold));
      case 1:
       var match$0 = match[1], at = match$0[2], clock = match$0[4];
       if(Incremental_Import[11]){
        var _eS_ = now$1(clock);
        if(! caml_call2(Incremental_Import[14][18], at, _eS_))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bN_], 1);
       }
       return maybe_change_value(node, 0);
      case 2:
       return maybe_change_value(node, 0);
      case 3:
       var
        bind = match[1],
        main = bind[1],
        f = bind[2],
        lhs = bind[3],
        old_rhs = bind[5],
        rhs_scope = bind[6],
        old_all_nodes_created_on_rhs = bind[7];
       bind[7] = Incremental_Import[16][3];
       var
        rhs =
          run_with_scope
           (t,
            rhs_scope,
            function(param){
             return caml_call1(f, caml_call1(Incremental_Node[21], lhs));
            });
       bind[5] = caml_call1(Incremental_Import[16][4], rhs);
       node[7] = t[3];
       change_child(main, old_rhs, rhs, Incremental_Kind[6]);
       if(caml_call1(Incremental_Import[16][6], old_rhs)){
        if(t[2])
         invalidate_nodes_created_on_rh(old_all_nodes_created_on_rhs);
        else
         rescope_nodes_created_on_rhs
          (t, old_all_nodes_created_on_rhs, main[12]);
        propagate_invalidity$1(t);
       }
       if(Incremental_Import[11] && ! caml_call1(Incremental_Node[16], node))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bO_], 1);
       return maybe_change_value(node, 0);
      case 4:
       var rhs$0 = match[1][5];
       return copy_child(node, caml_call1(Incremental_Import[16][7], rhs$0));
      case 5:
       var a = match[1]; return maybe_change_value(node, a);
      case 6:
       var expert = match[1];
       return 144245463 <= caml_call1(Incremental_Expert[13], expert)
               ? (invalidate_node(node), propagate_invalidity$1(t))
               : maybe_change_value(node, caml_call1(expert[1], 0));
      case 7:
       var
        match$1 = match[1],
        only_freeze_when = match$1[3],
        child = match$1[2],
        value = caml_call1(Incremental_Node[21], child);
       if(caml_call1(only_freeze_when, value)){
        remove_children(node);
        caml_call2(Incremental_Node[6], node, [5, value]);
        if(caml_call1(Incremental_Node[15], node))
         set_height(node, 0);
        else
         became_unnecessary(node);
       }
       return maybe_change_value(node, value);
      case 8:
       var
        if_then_else = match[1],
        test = if_then_else[2],
        main$0 = if_then_else[1],
        current_branch = if_then_else[4],
        else$0 = if_then_else[6],
        then = if_then_else[5],
        desired_branch =
          caml_call1(Incremental_Node[21], test) ? then : else$0;
       if_then_else[4] = caml_call1(Incremental_Import[16][4], desired_branch);
       node[7] = t[3];
       change_child
        (main$0, current_branch, desired_branch, Incremental_Kind[8]);
       return maybe_change_value(node, 0);
      case 9:
       var current_branch$0 = match[1][4];
       return copy_child
               (node, caml_call1(Incremental_Import[16][7], current_branch$0));
      case 10:
       var
        join = match[1],
        lhs$0 = join[2],
        main$1 = join[1],
        old_rhs$0 = join[4],
        rhs$1 = caml_call1(Incremental_Node[21], lhs$0);
       join[4] = caml_call1(Incremental_Import[16][4], rhs$1);
       node[7] = t[3];
       change_child(main$1, old_rhs$0, rhs$1, Incremental_Kind[9]);
       return maybe_change_value(node, 0);
      case 11:
       var rhs$2 = match[1][4];
       return copy_child(node, caml_call1(Incremental_Import[16][7], rhs$2));
      case 12:
       var n1 = match[2], f$0 = match[1];
       return maybe_change_value
               (node, caml_call1(f$0, caml_call1(Incremental_Node[21], n1)));
      case 13:
       var
        match$2 = match[1],
        clock$0 = match$2[5],
        before = match$2[3],
        at$0 = match$2[2];
       if(Incremental_Import[11]){
        var _eT_ = now$1(clock$0);
        if(! caml_call2(Incremental_Import[14][18], at$0, _eT_))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bP_], 1);
       }
       return maybe_change_value(node, before);
      case 14:
       var
        step_function_node = match[1],
        child$0 = step_function_node[2],
        clock$1 = step_function_node[8];
       if(caml_call1(Incremental_Import[16][6], child$0)){
        var
         child$1 = caml_call1(Incremental_Import[16][7], child$0),
         _eU_ =
           caml_call2
            (Incremental_Stabilization_num[1],
             child$1[7],
             step_function_node[3]);
        if(caml_call2(Incremental_Import[4], _eU_, 0)){
         step_function_node[3] = child$1[7];
         remove_alarm(clock$1, step_function_node[6]);
         var
          step_function = caml_call1(Incremental_Node[21], child$1),
          _eV_ = caml_call1(Incremental_step_function[3], step_function);
         step_function_node[4] = caml_call1(Incremental_Import[16][4], _eV_);
         step_function_node[5] =
          caml_call1(Incremental_step_function[4], step_function);
         if(caml_call1(Incremental_Node[13], child$1)){
          remove_children(node);
          step_function_node[2] = Incremental_Import[16][3];
          set_height(node, caml_call1(Incremental_Scope[5], node[12]) + 1 | 0);
         }
        }
       }
       var _eW_ = now$1(clock$1);
       caml_call2(Incremental_Step_function_node[3], step_function_node, _eW_);
       var
        step_function_value =
          caml_call1(Incremental_Import[16][7], step_function_node[4]),
        match$3 = caml_call1(Core_Sequence[63], step_function_node[5]);
       if(match$3){
        var at$1 = match$3[1][1];
        step_function_node[6] =
         add_alarm(clock$1, at$1, step_function_node[7]);
       }
       else if(caml_call1(Incremental_Import[16][5], child$0))
        caml_call2(Incremental_Node[6], node, [5, step_function_value]);
       return maybe_change_value(node, step_function_value);
      case 15:
       var u = match[1];
       return maybe_change_value
               (node, caml_call1(Incremental_Unordered_array_fo[5], u));
      case 16:
       var var$0 = match[1]; return maybe_change_value(node, var$0[1]);
      case 17:
       var
        n2 = match[3],
        n1$0 = match[2],
        f$1 = match[1],
        _eX_ = caml_call1(Incremental_Node[21], n2);
       return maybe_change_value
               (node,
                caml_call2(f$1, caml_call1(Incremental_Node[21], n1$0), _eX_));
      case 18:
       var
        n3 = match[4],
        n2$0 = match[3],
        n1$1 = match[2],
        f$2 = match[1],
        _eY_ = caml_call1(Incremental_Node[21], n3),
        _eZ_ = caml_call1(Incremental_Node[21], n2$0);
       return maybe_change_value
               (node,
                caml_call3
                 (f$2, caml_call1(Incremental_Node[21], n1$1), _eZ_, _eY_));
      case 19:
       var
        n4 = match[5],
        n3$0 = match[4],
        n2$1 = match[3],
        n1$2 = match[2],
        f$3 = match[1],
        _e0_ = caml_call1(Incremental_Node[21], n4),
        _e1_ = caml_call1(Incremental_Node[21], n3$0),
        _e2_ = caml_call1(Incremental_Node[21], n2$1);
       return maybe_change_value
               (node,
                caml_call4
                 (f$3,
                  caml_call1(Incremental_Node[21], n1$2),
                  _e2_,
                  _e1_,
                  _e0_));
      case 20:
       var
        n5 = match[6],
        n4$0 = match[5],
        n3$1 = match[4],
        n2$2 = match[3],
        n1$3 = match[2],
        f$4 = match[1],
        _e3_ = caml_call1(Incremental_Node[21], n5),
        _e4_ = caml_call1(Incremental_Node[21], n4$0),
        _e5_ = caml_call1(Incremental_Node[21], n3$1),
        _e6_ = caml_call1(Incremental_Node[21], n2$2);
       return maybe_change_value
               (node,
                caml_call5
                 (f$4,
                  caml_call1(Incremental_Node[21], n1$3),
                  _e6_,
                  _e5_,
                  _e4_,
                  _e3_));
      case 21:
       var
        n6 = match[7],
        n5$0 = match[6],
        n4$1 = match[5],
        n3$2 = match[4],
        n2$3 = match[3],
        n1$4 = match[2],
        f$5 = match[1],
        _e7_ = caml_call1(Incremental_Node[21], n6),
        _e8_ = caml_call1(Incremental_Node[21], n5$0),
        _e9_ = caml_call1(Incremental_Node[21], n4$1),
        _e__ = caml_call1(Incremental_Node[21], n3$2),
        _e$_ = caml_call1(Incremental_Node[21], n2$3);
       return maybe_change_value
               (node,
                caml_call6
                 (f$5,
                  caml_call1(Incremental_Node[21], n1$4),
                  _e$_,
                  _e__,
                  _e9_,
                  _e8_,
                  _e7_));
      case 22:
       var
        n7 = match[8],
        n6$0 = match[7],
        n5$1 = match[6],
        n4$2 = match[5],
        n3$3 = match[4],
        n2$4 = match[3],
        n1$5 = match[2],
        f$6 = match[1],
        _fa_ = caml_call1(Incremental_Node[21], n7),
        _fb_ = caml_call1(Incremental_Node[21], n6$0),
        _fc_ = caml_call1(Incremental_Node[21], n5$1),
        _fd_ = caml_call1(Incremental_Node[21], n4$2),
        _fe_ = caml_call1(Incremental_Node[21], n3$3),
        _ff_ = caml_call1(Incremental_Node[21], n2$4);
       return maybe_change_value
               (node,
                caml_call7
                 (f$6,
                  caml_call1(Incremental_Node[21], n1$5),
                  _ff_,
                  _fe_,
                  _fd_,
                  _fc_,
                  _fb_,
                  _fa_));
      case 23:
       var
        n8 = match[9],
        n7$0 = match[8],
        n6$1 = match[7],
        n5$2 = match[6],
        n4$3 = match[5],
        n3$4 = match[4],
        n2$5 = match[3],
        n1$6 = match[2],
        f$7 = match[1],
        _fg_ = caml_call1(Incremental_Node[21], n8),
        _fh_ = caml_call1(Incremental_Node[21], n7$0),
        _fi_ = caml_call1(Incremental_Node[21], n6$1),
        _fj_ = caml_call1(Incremental_Node[21], n5$2),
        _fk_ = caml_call1(Incremental_Node[21], n4$3),
        _fl_ = caml_call1(Incremental_Node[21], n3$4),
        _fm_ = caml_call1(Incremental_Node[21], n2$5);
       return maybe_change_value
               (node,
                caml_call8
                 (f$7,
                  caml_call1(Incremental_Node[21], n1$6),
                  _fm_,
                  _fl_,
                  _fk_,
                  _fj_,
                  _fi_,
                  _fh_,
                  _fg_));
      case 24:
       var
        n9 = match[10],
        n8$0 = match[9],
        n7$1 = match[8],
        n6$2 = match[7],
        n5$3 = match[6],
        n4$4 = match[5],
        n3$5 = match[4],
        n2$6 = match[3],
        n1$7 = match[2],
        f$8 = match[1],
        _fn_ = caml_call1(Incremental_Node[21], n9),
        _fo_ = caml_call1(Incremental_Node[21], n8$0),
        _fp_ = caml_call1(Incremental_Node[21], n7$1),
        _fq_ = caml_call1(Incremental_Node[21], n6$2),
        _fr_ = caml_call1(Incremental_Node[21], n5$3),
        _fs_ = caml_call1(Incremental_Node[21], n4$4),
        _ft_ = caml_call1(Incremental_Node[21], n3$5),
        _fu_ = caml_call1(Incremental_Node[21], n2$6);
       return maybe_change_value
               (node,
                caml_call9
                 (f$8,
                  caml_call1(Incremental_Node[21], n1$7),
                  _fu_,
                  _ft_,
                  _fs_,
                  _fr_,
                  _fq_,
                  _fp_,
                  _fo_,
                  _fn_));
      case 25:
       var
        n10 = match[11],
        n9$0 = match[10],
        n8$1 = match[9],
        n7$2 = match[8],
        n6$3 = match[7],
        n5$4 = match[6],
        n4$5 = match[5],
        n3$6 = match[4],
        n2$7 = match[3],
        n1$8 = match[2],
        f$9 = match[1],
        _fv_ = caml_call1(Incremental_Node[21], n10),
        _fw_ = caml_call1(Incremental_Node[21], n9$0),
        _fx_ = caml_call1(Incremental_Node[21], n8$1),
        _fy_ = caml_call1(Incremental_Node[21], n7$2),
        _fz_ = caml_call1(Incremental_Node[21], n6$3),
        _fA_ = caml_call1(Incremental_Node[21], n5$4),
        _fB_ = caml_call1(Incremental_Node[21], n4$5),
        _fC_ = caml_call1(Incremental_Node[21], n3$6),
        _fD_ = caml_call1(Incremental_Node[21], n2$7);
       return maybe_change_value
               (node,
                caml_call10
                 (f$9,
                  caml_call1(Incremental_Node[21], n1$8),
                  _fD_,
                  _fC_,
                  _fB_,
                  _fA_,
                  _fz_,
                  _fy_,
                  _fx_,
                  _fw_,
                  _fv_));
      case 26:
       var
        n11 = match[12],
        n10$0 = match[11],
        n9$1 = match[10],
        n8$2 = match[9],
        n7$3 = match[8],
        n6$4 = match[7],
        n5$5 = match[6],
        n4$6 = match[5],
        n3$7 = match[4],
        n2$8 = match[3],
        n1$9 = match[2],
        f$10 = match[1],
        _fE_ = caml_call1(Incremental_Node[21], n11),
        _fF_ = caml_call1(Incremental_Node[21], n10$0),
        _fG_ = caml_call1(Incremental_Node[21], n9$1),
        _fH_ = caml_call1(Incremental_Node[21], n8$2),
        _fI_ = caml_call1(Incremental_Node[21], n7$3),
        _fJ_ = caml_call1(Incremental_Node[21], n6$4),
        _fK_ = caml_call1(Incremental_Node[21], n5$5),
        _fL_ = caml_call1(Incremental_Node[21], n4$6),
        _fM_ = caml_call1(Incremental_Node[21], n3$7),
        _fN_ = caml_call1(Incremental_Node[21], n2$8);
       return maybe_change_value
               (node,
                caml_call11
                 (f$10,
                  caml_call1(Incremental_Node[21], n1$9),
                  _fN_,
                  _fM_,
                  _fL_,
                  _fK_,
                  _fJ_,
                  _fI_,
                  _fH_,
                  _fG_,
                  _fF_,
                  _fE_));
      case 27:
       var
        n12 = match[13],
        n11$0 = match[12],
        n10$1 = match[11],
        n9$2 = match[10],
        n8$3 = match[9],
        n7$4 = match[8],
        n6$5 = match[7],
        n5$6 = match[6],
        n4$7 = match[5],
        n3$8 = match[4],
        n2$9 = match[3],
        n1$10 = match[2],
        f$11 = match[1],
        _fO_ = caml_call1(Incremental_Node[21], n12),
        _fP_ = caml_call1(Incremental_Node[21], n11$0),
        _fQ_ = caml_call1(Incremental_Node[21], n10$1),
        _fR_ = caml_call1(Incremental_Node[21], n9$2),
        _fS_ = caml_call1(Incremental_Node[21], n8$3),
        _fT_ = caml_call1(Incremental_Node[21], n7$4),
        _fU_ = caml_call1(Incremental_Node[21], n6$5),
        _fV_ = caml_call1(Incremental_Node[21], n5$6),
        _fW_ = caml_call1(Incremental_Node[21], n4$7),
        _fX_ = caml_call1(Incremental_Node[21], n3$8),
        _fY_ = caml_call1(Incremental_Node[21], n2$9);
       return maybe_change_value
               (node,
                caml_call12
                 (f$11,
                  caml_call1(Incremental_Node[21], n1$10),
                  _fY_,
                  _fX_,
                  _fW_,
                  _fV_,
                  _fU_,
                  _fT_,
                  _fS_,
                  _fR_,
                  _fQ_,
                  _fP_,
                  _fO_));
      case 28:
       var
        n13 = match[14],
        n12$0 = match[13],
        n11$1 = match[12],
        n10$2 = match[11],
        n9$3 = match[10],
        n8$4 = match[9],
        n7$5 = match[8],
        n6$6 = match[7],
        n5$7 = match[6],
        n4$8 = match[5],
        n3$9 = match[4],
        n2$10 = match[3],
        n1$11 = match[2],
        f$12 = match[1],
        _fZ_ = caml_call1(Incremental_Node[21], n13),
        _f0_ = caml_call1(Incremental_Node[21], n12$0),
        _f1_ = caml_call1(Incremental_Node[21], n11$1),
        _f2_ = caml_call1(Incremental_Node[21], n10$2),
        _f3_ = caml_call1(Incremental_Node[21], n9$3),
        _f4_ = caml_call1(Incremental_Node[21], n8$4),
        _f5_ = caml_call1(Incremental_Node[21], n7$5),
        _f6_ = caml_call1(Incremental_Node[21], n6$6),
        _f7_ = caml_call1(Incremental_Node[21], n5$7),
        _f8_ = caml_call1(Incremental_Node[21], n4$8),
        _f9_ = caml_call1(Incremental_Node[21], n3$9),
        _f__ = caml_call1(Incremental_Node[21], n2$10);
       return maybe_change_value
               (node,
                caml_call13
                 (f$12,
                  caml_call1(Incremental_Node[21], n1$11),
                  _f__,
                  _f9_,
                  _f8_,
                  _f7_,
                  _f6_,
                  _f5_,
                  _f4_,
                  _f3_,
                  _f2_,
                  _f1_,
                  _f0_,
                  _fZ_));
      case 29:
       var
        n14 = match[15],
        n13$0 = match[14],
        n12$1 = match[13],
        n11$2 = match[12],
        n10$3 = match[11],
        n9$4 = match[10],
        n8$5 = match[9],
        n7$6 = match[8],
        n6$7 = match[7],
        n5$8 = match[6],
        n4$9 = match[5],
        n3$10 = match[4],
        n2$11 = match[3],
        n1$12 = match[2],
        f$13 = match[1],
        _f$_ = caml_call1(Incremental_Node[21], n14),
        _ga_ = caml_call1(Incremental_Node[21], n13$0),
        _gb_ = caml_call1(Incremental_Node[21], n12$1),
        _gc_ = caml_call1(Incremental_Node[21], n11$2),
        _gd_ = caml_call1(Incremental_Node[21], n10$3),
        _ge_ = caml_call1(Incremental_Node[21], n9$4),
        _gf_ = caml_call1(Incremental_Node[21], n8$5),
        _gg_ = caml_call1(Incremental_Node[21], n7$6),
        _gh_ = caml_call1(Incremental_Node[21], n6$7),
        _gi_ = caml_call1(Incremental_Node[21], n5$8),
        _gj_ = caml_call1(Incremental_Node[21], n4$9),
        _gk_ = caml_call1(Incremental_Node[21], n3$10),
        _gl_ = caml_call1(Incremental_Node[21], n2$11);
       return maybe_change_value
               (node,
                caml_call14
                 (f$13,
                  caml_call1(Incremental_Node[21], n1$12),
                  _gl_,
                  _gk_,
                  _gj_,
                  _gi_,
                  _gh_,
                  _gg_,
                  _gf_,
                  _ge_,
                  _gd_,
                  _gc_,
                  _gb_,
                  _ga_,
                  _f$_));
      default:
       var
        n15 = match[16],
        n14$0 = match[15],
        n13$1 = match[14],
        n12$2 = match[13],
        n11$3 = match[12],
        n10$4 = match[11],
        n9$5 = match[10],
        n8$6 = match[9],
        n7$7 = match[8],
        n6$8 = match[7],
        n5$9 = match[6],
        n4$10 = match[5],
        n3$11 = match[4],
        n2$12 = match[3],
        n1$13 = match[2],
        f$14 = match[1],
        _gm_ = caml_call1(Incremental_Node[21], n15),
        _gn_ = caml_call1(Incremental_Node[21], n14$0),
        _go_ = caml_call1(Incremental_Node[21], n13$1),
        _gp_ = caml_call1(Incremental_Node[21], n12$2),
        _gq_ = caml_call1(Incremental_Node[21], n11$3),
        _gr_ = caml_call1(Incremental_Node[21], n10$4),
        _gs_ = caml_call1(Incremental_Node[21], n9$5),
        _gt_ = caml_call1(Incremental_Node[21], n8$6),
        _gu_ = caml_call1(Incremental_Node[21], n7$7),
        _gv_ = caml_call1(Incremental_Node[21], n6$8),
        _gw_ = caml_call1(Incremental_Node[21], n5$9),
        _gx_ = caml_call1(Incremental_Node[21], n4$10),
        _gy_ = caml_call1(Incremental_Node[21], n3$11),
        _gz_ = caml_call1(Incremental_Node[21], n2$12);
       return maybe_change_value
               (node,
                caml_call15
                 (f$14,
                  caml_call1(Incremental_Node[21], n1$13),
                  _gz_,
                  _gy_,
                  _gx_,
                  _gw_,
                  _gv_,
                  _gu_,
                  _gt_,
                  _gs_,
                  _gr_,
                  _gq_,
                  _gp_,
                  _go_,
                  _gn_,
                  _gm_));
    }
   }
   function copy_child(parent, child){
    return caml_call1(Incremental_Node[16], child)
            ? maybe_change_value
              (parent, caml_call1(Incremental_Node[21], child))
            : (invalidate_node(parent), propagate_invalidity$1(parent[2]));
   }
   function maybe_change_value(node, new_value){
    var
     t = node[2],
     old_value_opt = node[4],
     _eB_ = caml_call1(Incremental_Import[16][5], old_value_opt);
    if(_eB_)
     var _eC_ = _eB_;
    else
     var
      _eR_ = caml_call1(Incremental_Import[16][11], old_value_opt),
      _eC_ = 1 - caml_call3(Incremental_Cutoff[11], node[6], _eR_, new_value);
    if(_eC_){
     node[4] = caml_call1(Incremental_Import[16][4], new_value);
     node[7] = t[3];
     t[21] = t[21] + 1 | 0;
     if(caml_call2(Incremental_Import[4], node[8], 0)){
      node[20] = old_value_opt;
      handle_after_stabilization$1(node);
     }
     if(caml_call2(Incremental_Import[1], node[9], 1)){
      var _eE_ = node[9] - 1 | 0, _eD_ = 1;
      if(_eE_ >= 1){
       var parent_index = _eD_;
       for(;;){
        var
         _eO_ =
           caml_call2
            (Incremental_Import[17][19], node[10], parent_index - 1 | 0),
         parent$0 = caml_call1(Incremental_Import[16][7], _eO_),
         match$1 = parent$0[5];
        a:
        if(typeof match$1 !== "number")
         switch(match$1[0]){
           case 6:
            var
             expert = match$1[1],
             child_index$0 =
               caml_check_bound(node[25], parent_index)[1 + parent_index];
            caml_call2(Incremental_Expert[15], expert, child_index$0);
            break a;
           case 15:
            var
             u$0 = match$1[1],
             _eQ_ = caml_check_bound(node[25], parent_index)[1 + parent_index];
            caml_call5
             (Incremental_Unordered_array_fo[6],
              u$0,
              node,
              _eQ_,
              old_value_opt,
              new_value);
            break a;
         }
        if
         (Incremental_Import[11]
          && ! caml_call1(Incremental_Node[20], parent$0))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bX_], 1);
        if(1 - caml_call1(Incremental_Node[14], parent$0))
         caml_call2(Incremental_Recompute_heap[8], t[5], parent$0);
        var _eP_ = parent_index + 1 | 0;
        if(_eE_ === parent_index) break;
        var parent_index = _eP_;
       }
      }
      var
       parent = caml_call1(Incremental_Import[16][7], node[11]),
       match = parent[5];
      a:
      if(typeof match !== "number")
       switch(match[0]){
         case 6:
          var p = match[1], child_index = caml_check_bound(node[25], 0)[1];
          caml_call2(Incremental_Expert[15], p, child_index);
          break a;
         case 15:
          var u = match[1], _eN_ = caml_check_bound(node[25], 0)[1];
          caml_call5
           (Incremental_Unordered_array_fo[6],
            u,
            node,
            _eN_,
            old_value_opt,
            new_value);
          break a;
       }
      if(Incremental_Import[11] && ! caml_call1(Incremental_Node[20], parent))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bW_], 1);
      a:
      if(1 - caml_call1(Incremental_Node[14], parent)){
       var match$0 = parent[5];
       b:
       {
        if(typeof match$0 !== "number"){
         switch(match$0[0]){
           case 1:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bU_], 1);
           case 2:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bV_], 1);
           case 3:
            var
             _eH_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eH_);
            break;
           case 4:
            var
             b = match$0[1],
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], b[4][14]);
            break;
           case 7:
            var
             _eI_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eI_);
            break;
           case 8:
            var
             _eJ_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eJ_);
            break;
           case 9:
            var
             i = match$0[1],
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], i[3][14]);
            break;
           case 10:
            var
             _eK_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eK_);
            break;
           case 11:
            var
             j = match$0[1],
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], j[3][14]);
            break;
           case 12:
            var
             _eL_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eL_);
            break;
           case 14:
            var
             _eM_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now =
               caml_call2(Incremental_Import[4], node[14], _eM_);
            break;
           case 5:
           case 13:
           case 16:
            break b;
           default: var can_recompute_now = 0;
         }
         if(can_recompute_now){
          t[25] = t[25] + 1 | 0;
          recompute(parent);
         }
         else{
          var _eG_ = caml_call1(Incremental_Recompute_heap[7], t[5]);
          if(caml_call2(Incremental_Import[2], parent[14], _eG_)){t[26] = t[26] + 1 | 0; recompute(parent);}
          else{
           if
            (Incremental_Import[11]
             && ! caml_call1(Incremental_Node[20], parent))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bT_], 1);
           if
            (Incremental_Import[11]
             && caml_call1(Incremental_Node[14], parent))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bS_], 1);
           caml_call2(Incremental_Recompute_heap[8], t[5], parent);
          }
         }
         break a;
        }
        if(1 === match$0)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bR_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bQ_], 1);
      }
     }
    }
    var _eF_ = Incremental_Import[11];
    return _eF_ ? invariant$2(t) : _eF_;
   }
   function recompute_first_node_that_is_n(r){
    var
     node = caml_call1(Incremental_Recompute_heap[10], r),
     _ex_ = Incremental_Import[11],
     _ey_ = _ex_ ? 1 - caml_call1(Incremental_Node[20], node) : _ex_;
    if(_ey_){
     var
      _ez_ =
        function(x_116){
         function _eA_(param){return _bY_;}
         return caml_call2(Incremental_Node[2], _eA_, x_116);
        };
     caml_call5
      (Core[236], 0, _bZ_, cst_node_unexpectedly_does_not, node, _ez_);
    }
    return recompute(node);
   }
   function unlink_disallowed_observers(t){
    for(;;){
     var _ev_ = caml_call1(Core_Stack[6], t[12]);
     if(! caml_call2(Incremental_Import[4], _ev_, 0)) return 0;
     var internal_observer = caml_call1(Core_Stack[27], t[12]);
     if(Incremental_Import[11]){
      var _ew_ = 2 === internal_observer[1] ? 1 : 0;
      if(! _ew_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b0_], 1);
     }
     internal_observer[1] = 3;
     var all_observers = caml_call1(Incremental_Import[16][7], t[9]);
     if
      (caml_call2
        (Incremental_Internal_observer[3], internal_observer, all_observers))
      t[9] = internal_observer[5];
     caml_call1(Incremental_Internal_observer[8], internal_observer);
     check_if_unnecessary(internal_observer[2]);
    }
   }
   function disallow_future_use(internal_observer){
    var
     t = caml_call1(Incremental_Internal_observer[9], internal_observer),
     _eu_ = internal_observer[1];
    return 1 === _eu_
            ? (t
               [8]
              = t[8] - 1 | 0,
              internal_observer[1] = 2,
              caml_call2(Core_Stack[25], t[12], internal_observer))
            : _eu_
              ? 0
              : (t
                 [8]
                = t[8] - 1 | 0,
                internal_observer[1] = 3,
                internal_observer[3] = 0,
                0);
   }
   function disallow_finalized_observers(t){
    for(;;){
     var _et_ = caml_call1(Thread_safe_queue[4], t[10]);
     if(! caml_call2(Incremental_Import[4], _et_, 0)) return 0;
     var internal_observer = caml_call1(Thread_safe_queue[6], t[10]);
     if(caml_call1(Core_List[8], internal_observer[3]))
      disallow_future_use(internal_observer);
    }
   }
   function observer_finalizer(t){
    function _es_(observer){
     var internal_observer = observer[1];
     return caml_call2(Thread_safe_queue[5], t[10], internal_observer);
    }
    return caml_call1(Core[258], _es_);
   }
   function create_observer(opt, observing){
    if(opt)
     var sth = opt[1], should_finalize = sth;
    else
     var should_finalize = 1;
    var
     t = observing[2],
     internal_observer =
       [0,
        0,
        observing,
        0,
        Incremental_Import[16][3],
        Incremental_Import[16][3],
        Incremental_Import[16][3],
        Incremental_Import[16][3]];
    caml_call2(Core_Stack[25], t[11], internal_observer);
    var observer = [0, internal_observer];
    if(should_finalize){
     var _eq_ = observer_finalizer(t), _er_ = caml_call1(Core[259], _eq_);
     caml_call2(Core_Gc[10][2], observer, _er_);
    }
    t[8] = t[8] + 1 | 0;
    return observer;
   }
   function add_new_observers(t){
    for(;;){
     var _ek_ = caml_call1(Core_Stack[6], t[11]);
     if(! caml_call2(Incremental_Import[4], _ek_, 0)) return 0;
     var
      internal_observer = caml_call1(Core_Stack[27], t[11]),
      _el_ = internal_observer[1];
     if(_el_){
      if(3 > _el_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b1_], 1);
     }
     else{
      internal_observer[1] = 1;
      var old_all_observers = t[9];
      if(caml_call1(Incremental_Import[16][6], old_all_observers)){
       internal_observer[5] = old_all_observers;
       var
        _em_ = caml_call1(Incremental_Import[16][4], internal_observer),
        _en_ = caml_call1(Incremental_Import[16][11], old_all_observers);
       caml_call2(Incremental_Internal_observer[10][4], _en_, _em_);
      }
      t[9] = caml_call1(Incremental_Import[16][4], internal_observer);
      var
       observing = internal_observer[2],
       was_necessary = caml_call1(Incremental_Node[15], observing),
       _eo_ = caml_call1(Core_List[7], internal_observer[3]);
      observing[8] = observing[8] + _eo_ | 0;
      var old_observers = observing[21];
      if(caml_call1(Incremental_Import[16][6], old_observers)){
       internal_observer[7] = old_observers;
       var _ep_ = caml_call1(Incremental_Import[16][4], internal_observer);
       caml_call1(Incremental_Import[16][11], old_observers)[6] = _ep_;
      }
      observing[21] = caml_call1(Incremental_Import[16][4], internal_observer);
      handle_after_stabilization$1(observing);
      if
       (Incremental_Import[11]
        && ! caml_call1(Incremental_Node[15], observing))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b2_], 1);
      if(1 - was_necessary) became_necessary(observing);
     }
    }
   }
   function observer_value_exn(observer){
    var t = caml_call1(Incremental_Observer[7], observer), match = t[1];
    if(typeof match !== "number"){
     var raised_exn = match[1];
     return caml_call5
             (Core[236],
              0,
              _b5_,
              cst_Observer_value_exn_called_$0,
              raised_exn,
              Incremental_Raised_exn[1]);
    }
    if(match) return caml_call1(Incremental_Observer[5], observer);
    function _ei_(x_117){
     function _ej_(param){return _b3_;}
     return caml_call2(Incremental_Observer[2], _ej_, x_117);
    }
    return caml_call5
            (Core[236],
             0,
             _b4_,
             cst_Observer_value_exn_called_,
             observer,
             _ei_);
   }
   function observer_value(observer){
    try{var _eh_ = [0, observer_value_exn(observer)]; return _eh_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [1, caml_call2(Core_Error[25], 0, exn)];
    }
   }
   function node_on_update(node, f){
    var
     t = node[2],
     _eg_ = caml_call2(Incremental_On_update_handler[3], f, t[3]);
    caml_call2(Incremental_Node[25], node, _eg_);
    return handle_after_stabilization$1(node);
   }
   function observer_on_update_exn(observer, f){
    var
     t = caml_call1(Incremental_Observer[7], observer),
     _ef_ = caml_call2(Incremental_On_update_handler[3], f, t[3]);
    caml_call2(Incremental_Observer[6], observer, _ef_);
    return handle_after_stabilization$1
            (caml_call1(Incremental_Observer[3], observer));
   }
   function set_var_while_not_stabilizing(var$0, value){
    var t = caml_call1(Incremental_Var[5], var$0);
    t[27] = t[27] + 1 | 0;
    var$0[1] = value;
    var
     _ea_ = caml_call2(Incremental_Stabilization_num[1], var$0[3], t[3]),
     _eb_ = caml_call2(Incremental_Import[5], _ea_, 0);
    if(_eb_){
     var$0[3] = t[3];
     var watch = var$0[4];
     if(Incremental_Import[11] && ! caml_call1(Incremental_Node[19], watch))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b6_], 1);
     var
      _ec_ = caml_call1(Incremental_Node[15], watch),
      _ed_ = _ec_ ? 1 - caml_call1(Incremental_Node[14], watch) : _ec_;
     if(_ed_) return caml_call2(Incremental_Recompute_heap[8], t[5], watch);
     var _ee_ = _ed_;
    }
    else
     var _ee_ = _eb_;
    return _ee_;
   }
   function set_var(var$0, value){
    var t = caml_call1(Incremental_Var[5], var$0), match = t[1];
    if(typeof match !== "number"){
     var raised_exn = match[1];
     return caml_call5
             (Core[236],
              0,
              _b7_,
              cst_cannot_set_var_stabilizati,
              raised_exn,
              Incremental_Raised_exn[1]);
    }
    if(match) return set_var_while_not_stabilizing(var$0, value);
    if(caml_call1(Incremental_Import[16][5], var$0[2]))
     caml_call2(Core_Stack[25], t[13], var$0);
    var$0[2] = caml_call1(Incremental_Import[16][4], value);
    return 0;
   }
   function reclaim_space_in_weak_hashtbls(t){
    for(;;){
     var _d$_ = caml_call1(Thread_safe_queue[4], t[17]);
     if(! caml_call2(Incremental_Import[4], _d$_, 0)) return 0;
     var weak_hashtbl = caml_call1(Thread_safe_queue[6], t[17])[1];
     caml_call1(Weak_hashtbl[11], weak_hashtbl);
    }
   }
   function stabilize_start(t){
    t[1] = 0;
    disallow_finalized_observers(t);
    add_new_observers(t);
    unlink_disallowed_observers(t);
    var _d__ = Incremental_Import[11];
    return _d__ ? invariant$2(t) : _d__;
   }
   function stabilize_end(t){
    if(Incremental_Import[11]){t[16][1] = 0; t[16][2] = 0;}
    t[3] = caml_call1(Incremental_Stabilization_num[9], t[3]);
    for(;;){
     if(caml_call1(Core_Stack[7], t[13])) break;
     var
      match$0 = caml_call1(Core_Stack[27], t[13]),
      value = caml_call1(Incremental_Import[16][7], match$0[2]);
     match$0[2] = Incremental_Import[16][3];
     set_var_while_not_stabilizing(match$0, value);
    }
    for(;;){
     if(caml_call1(Core_Stack[7], t[14])) break;
     var node$0 = caml_call1(Core_Stack[27], t[14]);
     node$0[22] = 0;
     var old_value = node$0[20];
     node$0[20] = Incremental_Import[16][3];
     if(caml_call1(Incremental_Node[16], node$0))
      if(caml_call1(Incremental_Node[15], node$0))
       var
        new_value = caml_call1(Incremental_Import[16][7], node$0[4]),
        _d9_ =
          caml_call1(Incremental_Import[16][5], old_value)
           ? [0, new_value]
           : [1, caml_call1(Incremental_Import[16][11], old_value), new_value],
        node_update$0 = _d9_;
      else
       var node_update$0 = 1;
     else
      var node_update$0 = 0;
     caml_call2(Core_Stack[25], t[15], [0, node$0, node_update$0]);
    }
    t[1] = 1;
    var now = t[3];
    for(;;){
     if(caml_call1(Core_Stack[7], t[15])){
      t[1] = 2;
      return reclaim_space_in_weak_hashtbls(t);
     }
     var
      match = caml_call1(Core_Stack[27], t[15]),
      node_update = match[2],
      node = match[1];
     caml_call3(Incremental_Node[26], node, node_update, now);
    }
   }
   function raise_during_stabilization(t, exn){
    t[1] = [0, caml_call1(Incremental_Raised_exn[2], exn)];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function stabilize(t){
    ensure_not_stabilizing(t, cst_stabilize, 0);
    try{
     stabilize_start(t);
     var r = t[5];
     for(;;){
      var _d7_ = caml_call1(Incremental_Recompute_heap[4], r);
      if(! caml_call2(Incremental_Import[4], _d7_, 0)){var _d8_ = stabilize_end(t); return _d8_;}
      recompute_first_node_that_is_n(r);
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return raise_during_stabilization(t, exn);
    }
   }
   function sexp_of_t$5(param){return param ? _b8_ : _b9_;}
   var Step_result = [0, sexp_of_t$5];
   function do_one_step_of_stabilize(t){
    try{
     var _d3_ = t[1];
     a:
     if(typeof _d3_ === "number"){
      switch(_d3_){
        case 0:
         var
          r = t[5],
          _d4_ = caml_call1(Incremental_Recompute_heap[4], r),
          _d5_ =
            caml_call2(Incremental_Import[4], _d4_, 0)
             ? (recompute_first_node_that_is_n(r), 0)
             : (stabilize_end(t), 1),
          _d6_ = _d5_;
         break;
        case 2:
         stabilize_start(t); var _d6_ = 0; break;
        default: break a;
      }
      return _d6_;
     }
     ensure_not_stabilizing(t, cst_step, 0);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b__], 1);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(typeof t[1] === "number") return raise_during_stabilization(t, exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function create_node_in(t, created_in, kind){
    t[22] = t[22] + 1 | 0;
    return caml_call3(Incremental_Node[5], t, created_in, kind);
   }
   function create_node(t, kind){return create_node_in(t, t[4], kind);}
   function create_node_top(t, kind){
    return create_node_in(t, Incremental_Scope[3], kind);
   }
   function create_var(t, opt, value){
    if(opt)
     var sth = opt[1], use_current_scope = sth;
    else
     var use_current_scope = 0;
    var
     scope = use_current_scope ? t[4] : Incremental_Scope[3],
     watch = create_node_in(t, scope, 1),
     var$0 = [0, value, Incremental_Import[16][3], t[3], watch];
    caml_call2(Incremental_Node[6], watch, [16, var$0]);
    return var$0;
   }
   function const$0(t, a){return create_node(t, [5, a]);}
   function map$5(n, f){return create_node(n[2], [12, f, n]);}
   function map2(n1, n2, f){return create_node(n1[2], [17, f, n1, n2]);}
   function both(n1, n2){
    var _d2_ = n1[5];
    a:
    if(typeof _d2_ !== "number" && 5 === _d2_[0]){
     var a = _d2_[1], match = n2[5];
     if(typeof match !== "number" && 5 === match[0]){
      var b = match[1];
      return const$0(n1[2], [0, a, b]);
     }
     break a;
    }
    return map2(n1, n2, Core_Tuple[1][6]);
   }
   function map3(n1, n2, n3, f){
    return create_node(n1[2], [18, f, n1, n2, n3]);
   }
   function map4(n1, n2, n3, n4, f){
    return create_node(n1[2], [19, f, n1, n2, n3, n4]);
   }
   function map5(n1, n2, n3, n4, n5, f){
    return create_node(n1[2], [20, f, n1, n2, n3, n4, n5]);
   }
   function map6(n1, n2, n3, n4, n5, n6, f){
    return create_node(n1[2], [21, f, n1, n2, n3, n4, n5, n6]);
   }
   function map7(n1, n2, n3, n4, n5, n6, n7, f){
    return create_node(n1[2], [22, f, n1, n2, n3, n4, n5, n6, n7]);
   }
   function map8(n1, n2, n3, n4, n5, n6, n7, n8, f){
    return create_node(n1[2], [23, f, n1, n2, n3, n4, n5, n6, n7, n8]);
   }
   function map9(n1, n2, n3, n4, n5, n6, n7, n8, n9, f){
    return create_node(n1[2], [24, f, n1, n2, n3, n4, n5, n6, n7, n8, n9]);
   }
   function map10(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, f){
    return create_node
            (n1[2], [25, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10]);
   }
   function map11(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, f){
    return create_node
            (n1[2], [26, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11]);
   }
   function map12(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, f){
    return create_node
            (n1[2],
             [27, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12]);
   }
   function map13(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, f){
    return create_node
            (n1[2],
             [28, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13]);
   }
   function map14
   (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, f){
    return create_node
            (n1[2],
             [29,
              f,
              n1,
              n2,
              n3,
              n4,
              n5,
              n6,
              n7,
              n8,
              n9,
              n10,
              n11,
              n12,
              n13,
              n14]);
   }
   function map15
   (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, f){
    return create_node
            (n1[2],
             [30,
              f,
              n1,
              n2,
              n3,
              n4,
              n5,
              n6,
              n7,
              n8,
              n9,
              n10,
              n11,
              n12,
              n13,
              n14,
              n15]);
   }
   function preserve_cutoff(input, output){
    function _dZ_(param, _d1_){
     return caml_call2(Incremental_Stabilization_num[3], input[7], output[7]);
    }
    var _d0_ = caml_call1(Incremental_Cutoff[3], _dZ_);
    return caml_call2(Incremental_Node[24], output, _d0_);
   }
   function depend_on(input, depend_on){
    var output = map2(input, depend_on, function(a, param){return a;});
    preserve_cutoff(input, output);
    return output;
   }
   function necessary_if_alive(input){
    var
     observer = create_observer(0, input),
     output =
       map$5(input, function(a){caml_call1(Core_Gc[5], observer); return a;});
    preserve_cutoff(input, output);
    return output;
   }
   function bind(lhs, f){
    var
     t = lhs[2],
     lhs_change = create_node(t, 1),
     main = create_node(t, 1),
     bind =
       [0,
        main,
        f,
        lhs,
        lhs_change,
        Incremental_Import[16][3],
        Incremental_Scope[3],
        Incremental_Import[16][3]];
    caml_call2(Incremental_Node[24], lhs_change, Incremental_Cutoff[7]);
    bind[6] = [0, bind];
    caml_call2(Incremental_Node[6], lhs_change, [3, bind]);
    caml_call2(Incremental_Node[6], main, [4, bind]);
    return main;
   }
   function bind2(n1, n2, f){
    function _dY_(param){
     var v2 = param[2], v1 = param[1];
     return caml_call2(f, v1, v2);
    }
    return bind(map2(n1, n2, function(v1, v2){return [0, v1, v2];}), _dY_);
   }
   function bind3(n1, n2, n3, f){
    function _dX_(param){
     var v3 = param[3], v2 = param[2], v1 = param[1];
     return caml_call3(f, v1, v2, v3);
    }
    return bind
            (map3(n1, n2, n3, function(v1, v2, v3){return [0, v1, v2, v3];}),
             _dX_);
   }
   function bind4(n1, n2, n3, n4, f){
    function _dW_(param){
     var v4 = param[4], v3 = param[3], v2 = param[2], v1 = param[1];
     return caml_call4(f, v1, v2, v3, v4);
    }
    return bind
            (map4
              (n1,
               n2,
               n3,
               n4,
               function(v1, v2, v3, v4){return [0, v1, v2, v3, v4];}),
             _dW_);
   }
   function join(lhs){
    var
     t = lhs[2],
     lhs_change = create_node(t, 1),
     main = create_node(t, 1),
     join = [0, main, lhs, lhs_change, Incremental_Import[16][3]];
    caml_call2(Incremental_Node[24], lhs_change, Incremental_Cutoff[7]);
    caml_call2(Incremental_Node[6], lhs_change, [10, join]);
    caml_call2(Incremental_Node[6], main, [11, join]);
    return main;
   }
   function if$0(test, then, else$0){
    var
     t = test[2],
     test_change = create_node(t, 1),
     main = create_node(t, 1),
     if_then_else =
       [0, main, test, test_change, Incremental_Import[16][3], then, else$0];
    caml_call2(Incremental_Node[24], test_change, Incremental_Cutoff[7]);
    caml_call2(Incremental_Node[6], test_change, [8, if_then_else]);
    caml_call2(Incremental_Node[6], main, [9, if_then_else]);
    return main;
   }
   function lazy_from_fun(t, f){
    var scope = t[4];
    function _dV_(param){return within_scope(t, scope, f);}
    return caml_call1(Core_Lazy[33], _dV_);
   }
   var default_hash_table_initial_siz = 4;
   function memoize_fun_by_key(opt, t, hashable, project_key, f){
    if(opt)
     var sth = opt[1], initial_size = sth;
    else
     var initial_size = default_hash_table_initial_siz;
    var
     scope = t[4],
     table = caml_call3(Core_Hashtbl[4], 0, [0, initial_size], hashable);
    function _dU_(a){
     var
      key = caml_call1(project_key, a),
      match = caml_call2(Core_Hashtbl[53], table, key);
     if(match){var b = match[1]; return b;}
     var
      b$0 = within_scope(t, scope, function(param){return caml_call1(f, a);});
     caml_call3(Core_Hashtbl[36], table, key, b$0);
     return b$0;
    }
    return caml_call1(Core[258], _dU_);
   }
   function array_fold(t, children, init, f){
    return caml_call2(Incremental_Import[3], children.length - 1, 0)
            ? const$0(t, init)
            : create_node(t, [0, [0, init, f, children]]);
   }
   function all(t, ts){
    function _dT_(ac, a){return [0, a, ac];}
    return array_fold(t, caml_call1(Incremental_Import[15][90], ts), 0, _dT_);
   }
   function unordered_array_fold(t, opt, children, init, f, update){
    if(opt)
     var sth = opt[1], full_compute_every_n_changes = sth;
    else
     var full_compute_every_n_changes = Core_Int[41];
    if(caml_call2(Incremental_Import[3], children.length - 1, 0))
     return const$0(t, init);
    if(caml_call2(Incremental_Import[2], full_compute_every_n_changes, 0))
     return caml_call5
             (Core[236],
              0,
              _b$_,
              cst_unordered_array_fold_got_n,
              full_compute_every_n_changes,
              Core[356]);
    var
     main = create_node(t, 1),
     _dS_ =
       [15,
        caml_call6
         (Incremental_Unordered_array_fo[4],
          init,
          f,
          update,
          full_compute_every_n_changes,
          children,
          main)];
    caml_call2(Incremental_Node[6], main, _dS_);
    return main;
   }
   function opt_unordered_array_fold
   (t, full_compute_every_n_changes, ts, init, f, f_inverse){
    function f$0(param, x){
     var num_invalid = param[2], accum = param[1];
     if(! x) return [0, accum, num_invalid + 1 | 0];
     var x$0 = x[1];
     return [0, caml_call2(f, accum, x$0), num_invalid];
    }
    function f_inverse$0(param, x){
     var num_invalid = param[2], accum = param[1];
     if(! x) return [0, accum, num_invalid - 1 | 0];
     var x$0 = x[1];
     return [0, caml_call2(f_inverse, accum, x$0), num_invalid];
    }
    function _dR_(param){
     var num_invalid = param[2], accum = param[1];
     return caml_call2(Incremental_Import[3], num_invalid, 0) ? [0, accum] : 0;
    }
    return map$5
            (unordered_array_fold
              (t,
               full_compute_every_n_changes,
               ts,
               [0, init, 0],
               f$0,
               [0, f_inverse$0]),
             _dR_);
   }
   function at_least_k_of(t, nodes, k){
    function bool_to_int(b){return b ? 1 : 0;}
    function _dP_(i){return caml_call2(Incremental_Import[1], i, k);}
    var
     _dQ_ = [0, function(num_true, b){return num_true - bool_to_int(b) | 0;}];
    return map$5
            (unordered_array_fold
              (t,
               0,
               nodes,
               0,
               function(num_true, b){return num_true + bool_to_int(b) | 0;},
               _dQ_),
             _dP_);
   }
   function exists$5(t, nodes){return at_least_k_of(t, nodes, 1);}
   function for_all$5(t, nodes){
    return at_least_k_of(t, nodes, nodes.length - 1);
   }
   function sum(t, full_compute_every_n_changes, nodes, zero, add, sub){
    return unordered_array_fold
            (t, full_compute_every_n_changes, nodes, zero, add, [0, sub]);
   }
   function opt_sum(t, full_compute_every_n_changes, nodes, zero, add, sub){
    return opt_unordered_array_fold
            (t, full_compute_every_n_changes, nodes, zero, add, sub);
   }
   function sum_int(t, nodes){
    function _dK_(_dO_, _dN_){return _dO_ - _dN_ | 0;}
    return sum
            (t,
             0,
             nodes,
             0,
             function(_dM_, _dL_){return _dM_ + _dL_ | 0;},
             _dK_);
   }
   function sum_float(t, nodes){
    function _dF_(_dJ_, _dI_){return _dJ_ - _dI_;}
    return sum
            (t,
             [0, nodes.length - 1],
             nodes,
             0.,
             function(_dH_, _dG_){return _dH_ + _dG_;},
             _dF_);
   }
   function set_freeze(node, child, only_freeze_when){
    if(Incremental_Import[11] && ! caml_call1(Incremental_Scope[4], node[12]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ca_], 1);
    var was_necessary = caml_call1(Incremental_Node[15], node);
    caml_call2
     (Incremental_Node[6], node, [7, [0, node, child, only_freeze_when]]);
    return was_necessary
            ? add_parent(child, node, Incremental_Kind[7])
            : became_necessary(node);
   }
   function freeze(child, only_freeze_when){
    var t = child[2], node = create_node_top(t, 1);
    set_freeze(node, child, only_freeze_when);
    return node;
   }
   function at(clock, time){
    var t = caml_call1(Clock[9], clock), _dE_ = now$1(clock);
    if(caml_call2(Incremental_Import[14][16], time, _dE_))
     return const$0(t, 1);
    var
     main = create_node(t, 1),
     at = [0, main, time, Incremental_Alarm[3], clock];
    caml_call2(Incremental_Node[6], main, [1, at]);
    at[3] =
     add_alarm(clock, time, caml_call1(Incremental_Alarm_value[4], [0, at]));
    return main;
   }
   function after(clock, span){
    var _dD_ = now$1(clock);
    return at(clock, caml_call2(Incremental_Import[14][66], _dD_, span));
   }
   function next_interval_alarm_strict(clock, base, interval){
    var
     after = now$1(clock),
     at =
       caml_call5(Incremental_Import[14][80], _cb_, base, after, interval, 0);
    if
     (Incremental_Import[11]
      && ! caml_call2(Incremental_Import[14][18], at, after))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _cc_], 1);
    return at;
   }
   function at_intervals(clock, interval){
    var
     t = caml_call1(Clock[9], clock),
     _dB_ = caml_call1(Timing_wheel[10], clock[1]);
    if(caml_call2(Incremental_Import[14][1][19], interval, _dB_))
     caml_call5
      (Core[236],
       0,
       _cd_,
       cst_at_intervals_got_too_small,
       interval,
       Incremental_Import[14][1][10]);
    var
     main = create_node(t, 1),
     base = now$1(clock),
     at_intervals = [0, main, base, interval, Incremental_Alarm[3], clock];
    caml_call2(Incremental_Node[6], main, [2, at_intervals]);
    caml_call2(Incremental_Node[24], main, Incremental_Cutoff[7]);
    var _dC_ = caml_call1(Incremental_Alarm_value[4], [1, at_intervals]);
    at_intervals[4] =
     add_alarm(clock, next_interval_alarm_strict(clock, base, interval), _dC_);
    return main;
   }
   function snapshot(clock, value_at, at, before){
    var t = caml_call1(Clock[9], clock), _dz_ = now$1(clock);
    if(caml_call2(Incremental_Import[14][16], at, _dz_)){
     var _dA_ = now$1(clock);
     return caml_call2(Incremental_Import[14][19], at, _dA_)
             ? caml_call5
               (Core_Or_error[39],
                0,
                0,
                cst_cannot_take_snapshot_in_th,
                at,
                Incremental_Import[14][119])
             : [0, freeze(value_at, caml_call1(Core_Fn[1], 1))];
    }
    var
     main = create_node_top(t, 1),
     snapshot = [0, main, at, before, value_at, clock];
    caml_call2(Incremental_Node[6], main, [13, snapshot]);
    add_alarm
     (clock, at, caml_call1(Incremental_Alarm_value[4], [2, snapshot]));
    return [0, main];
   }
   function incremental_step_function(clock, child){
    var
     t = caml_call1(Clock[9], clock),
     main = create_node(t, 1),
     _dv_ = Incremental_Alarm[3],
     _dw_ = Core_Sequence[46],
     _dx_ = Incremental_Import[16][3],
     _dy_ = Incremental_Stabilization_num[5],
     step_function_node =
       [0,
        main,
        caml_call1(Incremental_Import[16][4], child),
        _dy_,
        _dx_,
        _dw_,
        _dv_,
        0,
        clock];
    step_function_node[7] =
     caml_call1(Incremental_Alarm_value[4], [3, step_function_node]);
    caml_call2(Incremental_Node[6], main, [14, step_function_node]);
    return main;
   }
   function make_stale(node){
    var t = node[2];
    node[3] = Incremental_Stabilization_num[5];
    var
     _dt_ = caml_call1(Incremental_Node[20], node),
     _du_ = _dt_ ? 1 - caml_call1(Incremental_Node[14], node) : _dt_;
    return _du_ ? caml_call2(Incremental_Recompute_heap[8], t[5], node) : _du_;
   }
   function advance_clock(clock, to){
    var t = caml_call1(Clock[9], clock);
    ensure_not_stabilizing(t, cst_advance_clock, 1);
    if(Incremental_Import[11]) invariant$2(t);
    var
     _dp_ = now$1(clock),
     _dq_ = caml_call2(Incremental_Import[14][18], to, _dp_);
    if(_dq_){
     set_var_while_not_stabilizing(clock[2], to);
     caml_call3(Timing_wheel[20], clock[1], to, clock[3]);
     caml_call2(Timing_wheel[21], clock[1], clock[3]);
     for(;;){
      if(! caml_call1(Incremental_Import[16][6], clock[4])){
       var _dr_ = Incremental_Import[11];
       if(_dr_) return invariant$2(t);
       var _ds_ = _dr_;
       break;
      }
      var alarm_value = caml_call1(Incremental_Import[16][11], clock[4]);
      clock[4] = alarm_value[2];
      alarm_value[2] = Incremental_Import[16][3];
      var match = alarm_value[1];
      switch(match[0]){
        case 0:
         var main = match[1][1];
         if(caml_call1(Incremental_Node[16], main)){
          caml_call2(Incremental_Node[6], main, _ce_);
          make_stale(main);
         }
         break;
        case 1:
         var
          at_intervals = match[1],
          interval = at_intervals[3],
          base = at_intervals[2],
          main$0 = at_intervals[1];
         if(caml_call1(Incremental_Node[16], main$0)){
          at_intervals[4] =
           add_alarm
            (clock,
             next_interval_alarm_strict(clock, base, interval),
             alarm_value);
          make_stale(main$0);
         }
         break;
        case 2:
         var match$0 = match[1], value_at = match$0[4], main$1 = match$0[1];
         if
          (Incremental_Import[11]
           && ! caml_call1(Incremental_Node[16], main$1))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _cf_], 1);
         set_freeze(main$1, value_at, function(param){return 1;});
         make_stale(main$1);
         break;
        default:
         var main$2 = match[1][1];
         if(caml_call1(Incremental_Node[16], main$2)) make_stale(main$2);
      }
     }
    }
    else
     var _ds_ = _dq_;
    return _ds_;
   }
   function create_clock(t, timing_wheel_config, start){
    var
     timing_wheel = caml_call2(Timing_wheel[9], timing_wheel_config, start),
     clock = [],
     handle_fired = function _do_(_dn_){return _do_.fun(_dn_);},
     _dm_ = Incremental_Import[16][3];
    caml_update_dummy
     (clock, [0, timing_wheel, create_var(t, 0, start), handle_fired, _dm_]);
    caml_update_dummy
     (handle_fired,
      function(alarm){
       var alarm_value = caml_call2(Timing_wheel[5][5], clock[1], alarm);
       alarm_value[2] = clock[4];
       clock[4] = caml_call1(Incremental_Import[16][4], alarm_value);
       return 0;
      });
    return clock;
   }
   function create$3(Config){
    return function(max_height_allowed){
     var
      adjust_heights_heap =
        caml_call1(Incremental_Adjust_heights_hea[3], max_height_allowed),
      recompute_heap =
        caml_call1(Incremental_Recompute_heap[3], max_height_allowed),
      _dc_ = caml_call1(Thread_safe_queue[3], 0),
      _dd_ = caml_call1(Only_in_debug[8], 0),
      _de_ = caml_call1(Core_Stack[23], 0),
      _df_ = caml_call1(Core_Stack[23], 0),
      _dg_ = caml_call1(Core_Stack[23], 0),
      _dh_ = caml_call1(Core_Stack[23], 0),
      _di_ = caml_call1(Core_Stack[23], 0),
      _dj_ = caml_call1(Thread_safe_queue[3], 0),
      _dk_ = Incremental_Import[16][3],
      _dl_ = caml_call1(Core_Stack[23], 0),
      t =
        [0,
         2,
         Config[1],
         Incremental_Stabilization_num[6],
         Incremental_Scope[3],
         recompute_heap,
         adjust_heights_heap,
         _dl_,
         0,
         _dk_,
         _dj_,
         _di_,
         _dh_,
         _dg_,
         _df_,
         _de_,
         _dd_,
         _dc_,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0];
     return t;};
   }
   function weak_memoize_fun_by_key(opt, t, hashable, project_key, f){
    if(opt)
     var sth = opt[1], initial_size = sth;
    else
     var initial_size = default_hash_table_initial_siz;
    var
     scope = t[4],
     table = caml_call3(Weak_hashtbl[2], 0, [0, initial_size], hashable),
     packed = [0, table];
    function _da_(param){
     return caml_call2(Thread_safe_queue[5], t[17], packed);
    }
    caml_call2(Weak_hashtbl[12], table, _da_);
    function _db_(a){
     var
      key = caml_call1(project_key, a),
      match = caml_call2(Weak_hashtbl[5], table, key);
     if(match){var b = match[1]; return b;}
     var
      b$0 = within_scope(t, scope, function(param){return caml_call1(f, a);});
     caml_call3(Weak_hashtbl[8], table, key, b$0);
     return b$0;
    }
    return caml_call1(Core[258], _db_);
   }
   function expert_kind_of_node(node){
    var x_118 = node[5];
    if(typeof x_118 === "number"){
     if(0 === x_118) return Incremental_Import[16][3];
    }
    else if(6 === x_118[0]){
     var e = x_118[1];
     return caml_call1(Incremental_Import[16][4], e);
    }
    var _c8_ = 0;
    function _c9_(param){return _cg_;}
    var
     _c__ = [0, caml_call2(Incremental_Kind[2], _c9_, x_118), _c8_],
     _c$_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_unexpected_kind_for_expert),
         _c__]];
    return caml_call1(Core[253], _c$_);
   }
   function create$4(state, on_observability_change, f){
    var
     e = caml_call2(Incremental_Expert[5], f, on_observability_change),
     node = create_node(state, [6, e]);
    if(Incremental_Import[11] && caml_call1(Core_Option[57], state[16][1]))
     state[16][2] = [0, node, state[16][2]];
    return node;
   }
   function currently_running_node_exn(state, name){
    var match = state[16][1];
    if(match){var current = match[1]; return current;}
    var
     _c5_ = caml_call2(Core[18], name, cst_during_stabilization),
     _c6_ = caml_call2(Core[18], cst_can_only_call, _c5_),
     _c7_ = caml_call1(Core[471], _c6_);
    return caml_call1(Core[253], _c7_);
   }
   function assert_currently_running_node_(state, node, name){
    var
     current = currently_running_node_exn(state, name),
     _cU_ = 1 - caml_call2(Incremental_Node[30], node, current);
    if(! _cU_) return _cU_;
    var x_120 = current[5], _cV_ = 0, _cW_ = 0;
    function _cX_(param){return _ch_;}
    var
     _cY_ =
       [0,
        [1,
         [0, _ci_, [0, caml_call2(Incremental_Kind[2], _cX_, x_120), _cW_]]],
        _cV_],
     x_119 = node[5],
     _cZ_ = 0;
    function _c0_(param){return _cj_;}
    var
     _c1_ =
       [0,
        [1,
         [0, _ck_, [0, caml_call2(Incremental_Kind[2], _c0_, x_119), _cZ_]]],
        _cY_],
     _c2_ = caml_call2(Core[18], name, cst_on_parent_nodes),
     _c3_ = caml_call2(Core[18], cst_can_only_call$0, _c2_),
     _c4_ = [1, [0, caml_call1(Core[471], _c3_), _c1_]];
    return caml_call1(Core[253], _c4_);
   }
   function assert_currently_running_node_$0(state, node, name){
    var
     current = currently_running_node_exn(state, name),
     _cJ_ = 1 - caml_call2(Incremental_Node[31], node, current);
    if(! _cJ_) return _cJ_;
    var x_122 = current[5], _cK_ = 0, _cL_ = 0;
    function _cM_(param){return _cl_;}
    var
     _cN_ =
       [0,
        [1,
         [0, _cm_, [0, caml_call2(Incremental_Kind[2], _cM_, x_122), _cL_]]],
        _cK_],
     x_121 = node[5],
     _cO_ = 0;
    function _cP_(param){return _cn_;}
    var
     _cQ_ =
       [0,
        [1,
         [0, _co_, [0, caml_call2(Incremental_Kind[2], _cP_, x_121), _cO_]]],
        _cN_],
     _cR_ = caml_call2(Core[18], name, cst_on_children_nodes),
     _cS_ = caml_call2(Core[18], cst_can_only_call$1, _cR_),
     _cT_ = [1, [0, caml_call1(Core[471], _cS_), _cQ_]];
    return caml_call1(Core[253], _cT_);
   }
   function make_stale$0(node){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _cF_ = caml_call1(Incremental_Import[16][6], e_opt);
    if(_cF_){
     if(Incremental_Import[11])
      assert_currently_running_node_(state, node, cst_make_stale);
     var e = caml_call1(Incremental_Import[16][11], e_opt);
     if(534011858 <= caml_call1(Incremental_Expert[6], e)) return 0;
     var
      _cG_ = caml_call1(Incremental_Node[15], node),
      _cH_ = _cG_ ? 1 - caml_call1(Incremental_Node[14], node) : _cG_;
     if(_cH_)
      return caml_call2(Incremental_Recompute_heap[8], state[5], node);
     var _cI_ = _cH_;
    }
    else
     var _cI_ = _cF_;
    return _cI_;
   }
   function invalidate(node){
    var state = node[2];
    if(Incremental_Import[11])
     assert_currently_running_node_(state, node, cst_invalidate);
    invalidate_node(node);
    return propagate_invalidity$1(state);
   }
   function add_dependency(node, dep){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _cy_ = caml_call1(Incremental_Import[16][6], e_opt);
    if(_cy_){
     if(Incremental_Import[11]){
      var
       _cz_ = am_stabilizing(state),
       _cA_ =
         _cz_
          ? 1 - caml_call3(Core_List[6], state[16][2], node, Core[246])
          : _cz_;
      if(_cA_)
       assert_currently_running_node_(state, node, cst_add_dependency);
     }
     var
      e = caml_call1(Incremental_Import[16][11], e_opt),
      new_child_index = caml_call2(Incremental_Expert[9], e, dep),
      _cB_ = caml_call1(Incremental_Node[15], node);
     if(_cB_){
      add_parent(dep[1], node, new_child_index);
      if(Incremental_Import[11] && ! caml_call1(Incremental_Node[20], node))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _cp_], 1);
      var _cC_ = 1 - caml_call1(Incremental_Node[14], node);
      if(_cC_)
       return caml_call2(Incremental_Recompute_heap[8], state[5], node);
      var _cD_ = _cC_;
     }
     else
      var _cD_ = _cB_;
     var _cE_ = _cD_;
    }
    else
     var _cE_ = _cy_;
    return _cE_;
   }
   function remove_dependency(node, edge){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _cr_ = caml_call1(Incremental_Import[16][6], e_opt);
    if(_cr_){
     if(Incremental_Import[11])
      assert_currently_running_node_(state, node, cst_remove_dependency);
     var
      e = caml_call1(Incremental_Import[16][11], e_opt),
      edge_index = caml_call1(Incremental_Import[16][7], edge[3]),
      last_edge = caml_call1(Incremental_Expert[11], e),
      last_edge_index = caml_call1(Incremental_Import[16][7], last_edge[3]);
     if(caml_call2(Incremental_Import[6], edge_index, last_edge_index)){
      if(caml_call1(Incremental_Node[15], node))
       caml_call5
        (Incremental_Node[12],
         node,
         edge[1],
         edge_index,
         last_edge[1],
         last_edge_index);
      caml_call3(Incremental_Expert[10], e, edge_index, last_edge_index);
      if(Incremental_Import[11]){
       var _cs_ = function(_cx_){return 0;};
       caml_call2(Incremental_Node[4], _cs_, node);
      }
     }
     caml_call1(Incremental_Expert[12], e);
     if(Incremental_Import[11] && ! caml_call1(Incremental_Node[19], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _cq_], 1);
     var _ct_ = caml_call1(Incremental_Node[15], node);
     if(_ct_){
      remove_child(edge[1], node, last_edge_index);
      if(1 - caml_call1(Incremental_Node[14], node))
       caml_call2(Incremental_Recompute_heap[8], state[5], node);
      var _cu_ = 1 - caml_call1(Incremental_Node[16], edge[1]);
      if(_cu_) return caml_call1(Incremental_Expert[8], e);
      var _cv_ = _cu_;
     }
     else
      var _cv_ = _ct_;
     var _cw_ = _cv_;
    }
    else
     var _cw_ = _cr_;
    return _cw_;
   }
   var
    Expert =
      [0,
       expert_kind_of_node,
       create$4,
       currently_running_node_exn,
       assert_currently_running_node_,
       assert_currently_running_node_$0,
       make_stale$0,
       invalidate,
       add_dependency,
       remove_dependency];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_State);
   var
    Incremental_State =
      [0,
       sexp_of_status,
       Run_on_update_handlers,
       Only_in_debug,
       Packed_weak_hashtbl,
       num_var_sets,
       set_num_var_sets,
       num_nodes_recomputed_directly_,
       set_num_nodes_recomputed_direc,
       num_nodes_recomputed_directly_$0,
       set_num_nodes_recomputed_direc$0,
       num_nodes_recomputed,
       set_num_nodes_recomputed,
       num_nodes_invalidated,
       set_num_nodes_invalidated,
       num_nodes_created,
       set_num_nodes_created,
       num_nodes_changed,
       set_num_nodes_changed,
       num_nodes_became_unnecessary,
       set_num_nodes_became_unnecessa,
       num_nodes_became_necessary,
       set_num_nodes_became_necessary,
       keep_node_creation_backtrace,
       set_keep_node_creation_backtra,
       weak_hashtbls,
       only_in_debug,
       set_only_in_debug,
       run_on_update_handlers,
       set_during_stabilization,
       disallowed_observers,
       new_observers,
       finalized_observers,
       all_observers,
       set_all_observers,
       num_active_observers,
       set_num_active_observers,
       adjust_heights_heap,
       recompute_heap,
       current_scope,
       set_current_scope,
       stabilization_num,
       set_stabilization_num,
       bind_lhs_change_should_invalid,
       status,
       set_status,
       Fields$0,
       sexp_of_t$2,
       Clock,
       now$1,
       timing_wheel_length,
       num_stabilizes,
       max_height_allowed,
       max_height_seen,
       iter_observers,
       directly_observed,
       save_dot,
       save_dot_to_file,
       iter_observer_descendants,
       Stats,
       stats,
       am_stabilizing,
       invariant$2,
       ensure_not_stabilizing,
       set_height,
       set_max_height_allowed,
       handle_after_stabilization$1,
       remove_children,
       remove_child,
       check_if_unnecessary,
       became_unnecessary,
       remove_alarm,
       invalidate_node,
       invalidate_nodes_created_on_rh,
       rescope_nodes_created_on_rhs,
       propagate_invalidity$1,
       add_parent_without_adjusting_h,
       became_necessary,
       add_parent,
       run_with_scope,
       within_scope,
       change_child,
       add_alarm,
       recompute,
       copy_child,
       maybe_change_value,
       recompute_first_node_that_is_n,
       unlink_disallowed_observers,
       disallow_future_use,
       disallow_finalized_observers,
       observer_finalizer,
       create_observer,
       add_new_observers,
       observer_value_exn,
       observer_value,
       node_on_update,
       observer_on_update_exn,
       set_var_while_not_stabilizing,
       set_var,
       reclaim_space_in_weak_hashtbls,
       stabilize_start,
       stabilize_end,
       raise_during_stabilization,
       stabilize,
       Step_result,
       do_one_step_of_stabilize,
       create_node_in,
       create_node,
       create_node_top,
       create_var,
       const$0,
       map$5,
       map2,
       both,
       map3,
       map4,
       map5,
       map6,
       map7,
       map8,
       map9,
       map10,
       map11,
       map12,
       map13,
       map14,
       map15,
       preserve_cutoff,
       depend_on,
       necessary_if_alive,
       bind,
       bind2,
       bind3,
       bind4,
       join,
       if$0,
       lazy_from_fun,
       default_hash_table_initial_siz,
       memoize_fun_by_key,
       array_fold,
       all,
       unordered_array_fold,
       opt_unordered_array_fold,
       at_least_k_of,
       exists$5,
       for_all$5,
       sum,
       opt_sum,
       sum_int,
       sum_float,
       set_freeze,
       freeze,
       at,
       after,
       next_interval_alarm_strict,
       at_intervals,
       snapshot,
       incremental_step_function,
       make_stale,
       advance_clock,
       create_clock,
       create$3,
       weak_memoize_fun_by_key,
       Expert];
   runtime.caml_register_global
    (254, Incremental_State, cst_Incremental_State$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Expert1
//# unitInfo: Requires: Expect_test_collector, Incremental__Expert, Incremental__Import, Incremental__Node, Incremental__State, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Expert1$0 = "Incremental__Expert1",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Incremental_State = global_data.Incremental__State,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Node = global_data.Incremental__Node,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Incremental_Expert = global_data.Incremental__Expert;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Expert1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/expert1.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    sexp_of_t = Incremental_Expert[3],
    cst_Dependency_value = "Dependency.value",
    cst_incremental = cst_incremental$0,
    cst_Incremental_Expert1 = cst_Incremental_Expert1$0;
   function create(opt, child){
    if(opt)
     var sth = opt[1], on_change = sth;
    else
     var on_change = function(_b_){return 0;};
    return [0, child, on_change, Incremental_Import[16][3]];
   }
   function value(t){
    var state = t[1][2];
    if(Incremental_Import[11])
     caml_call3(Incremental_State[163][5], state, t[1], cst_Dependency_value);
    return caml_call1(Incremental_Node[21], t[1]);
   }
   var
    Dependency = [0, sexp_of_t, create, value],
    sexp_of_t$0 = Incremental_Node[2];
   function create$0(state, opt, f){
    if(opt)
     var sth = opt[1], on_observability_change = sth;
    else
     var on_observability_change = function(param){return 0;};
    return caml_call3
            (Incremental_State[163][2], state, on_observability_change, f);
   }
   var make_stale = Incremental_State[163][6];
   function watch(_a_){return _a_;}
   var
    invalidate = Incremental_State[163][7],
    add_dependency = Incremental_State[163][8],
    remove_dependency = Incremental_State[163][9];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Expert1);
   var
    Incremental_Expert1 =
      [0,
       Dependency,
       [0,
        sexp_of_t$0,
        create$0,
        watch,
        make_stale,
        invalidate,
        add_dependency,
        remove_dependency]];
   runtime.caml_register_global
    (16, Incremental_Expert1, cst_Incremental_Expert1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Reduce_balanced
//# unitInfo: Requires: Balanced_reducer, Core, Expect_test_collector, Incremental__Expert1, Incremental__Import, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Reduce_balance$0 = "Incremental__Reduce_balanced",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Balanced_reducer = global_data.Balanced_reducer,
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Incremental_Expert1 = global_data.Incremental__Expert1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Reduce_balance$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], "src/reduce_balanced.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Reduce_balance = cst_Incremental_Reduce_balance$0;
   function create(state, children, f, reduce){
    var len = children.length - 1;
    if(caml_call2(Incremental_Import[3], len, 0)) return 0;
    var reducer = caml_call4(Balanced_reducer[3], 0, 0, len, reduce);
    if(Incremental_Import[11]){
     var _a_ = caml_call1(Core[230], 0);
     caml_call2(Balanced_reducer[2], _a_, reducer);
    }
    function _b_(param){
     var a = caml_call1(Balanced_reducer[6], reducer);
     if(Incremental_Import[11]){
      var _l_ = caml_call1(Core[230], 0);
      caml_call2(Balanced_reducer[2], _l_, reducer);
     }
     return a;
    }
    var
     node = caml_call3(Incremental_Expert1[2][2], state, 0, _b_),
     _d_ = len - 1 | 0,
     _c_ = 0;
    if(_d_ >= 0){
     var i = _c_;
     for(;;){
      var
       _e_ = runtime.caml_check_bound(children, i)[1 + i],
       _f_ =
         [0,
          function(i){
            return function(a){
             var _i_ = caml_call1(f, a);
             caml_call3(Balanced_reducer[4], reducer, i, _i_);
             var _j_ = Incremental_Import[11];
             if(! _j_) return _j_;
             var _k_ = caml_call1(Core[230], 0);
             return caml_call2(Balanced_reducer[2], _k_, reducer);};
           }
           (i)],
       _g_ = caml_call2(Incremental_Expert1[1][2], _f_, _e_);
      caml_call2(Incremental_Expert1[2][6], node, _g_);
      var _h_ = i + 1 | 0;
      if(_d_ === i) break;
      var i = _h_;
     }
    }
    return [0, caml_call1(Incremental_Expert1[2][3], node)];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Reduce_balance);
   var Incremental_Reduce_balanced = [0, create];
   runtime.caml_register_global
    (15, Incremental_Reduce_balanced, cst_Incremental_Reduce_balance$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Incremental_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Incremental_in = "Incremental__Incremental_intf",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Incremental_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Expect_test_collector[5][1], "src/incremental_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Incremental_in);
   var Incremental_Incremental_intf = [0];
   runtime.caml_register_global
    (11, Incremental_Incremental_intf, cst_Incremental_Incremental_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental
//# unitInfo: Requires: Assert_failure, Core, Expect_test_collector, Incremental__Before_or_after, Incremental__Config, Incremental__Cutoff, Incremental__Expert1, Incremental__Import, Incremental__Incremental_intf, Incremental__Node, Incremental__Observer, Incremental__On_update_handler, Incremental__Reduce_balanced, Incremental__Scope, Incremental__State, Incremental__Unordered_array_fold, Incremental__Var, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdio__Out_channel, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_invalid$1 = "<invalid>",
    cst_Incremental$0 = "Incremental",
    cst_incremental$0 = "incremental",
    cst_src_incremental_ml = "src/incremental.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    level_bits = [0, 14, [0, 13, [0, 5, 0]]],
    Incremental_Before_or_after = global_data.Incremental__Before_or_after,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Incremental_Config = global_data.Incremental__Config,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Assert_failure = global_data.Assert_failure,
    Incremental_Expert1 = global_data.Incremental__Expert1;
   global_data.Incremental__Unordered_array_fold;
   var
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_step_function = global_data.Incremental_step_function,
    Timing_wheel = global_data.Timing_wheel,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Incremental_Reduce_balanced = global_data.Incremental__Reduce_balanced,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Incremental_State = global_data.Incremental__State,
    Incremental_Scope = global_data.Incremental__Scope,
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Var = global_data.Incremental__Var,
    Incremental_Observer = global_data.Incremental__Observer;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Expect_test_collector[5][1], cst_src_incremental_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incremental$0, cst);
   var
    sexp_of_status = Incremental_State[1],
    Run_on_update_handlers = Incremental_State[2],
    Only_in_debug = Incremental_State[3],
    Packed_weak_hashtbl = Incremental_State[4],
    num_var_sets = Incremental_State[5],
    set_num_var_sets = Incremental_State[6],
    num_nodes_recomputed_directly_ = Incremental_State[7],
    set_num_nodes_recomputed_direc = Incremental_State[8],
    num_nodes_recomputed_directly_$0 = Incremental_State[9],
    set_num_nodes_recomputed_direc$0 = Incremental_State[10],
    num_nodes_recomputed = Incremental_State[11],
    set_num_nodes_recomputed = Incremental_State[12],
    num_nodes_invalidated = Incremental_State[13],
    set_num_nodes_invalidated = Incremental_State[14],
    num_nodes_created = Incremental_State[15],
    set_num_nodes_created = Incremental_State[16],
    num_nodes_changed = Incremental_State[17],
    set_num_nodes_changed = Incremental_State[18],
    num_nodes_became_unnecessary = Incremental_State[19],
    set_num_nodes_became_unnecessa = Incremental_State[20],
    num_nodes_became_necessary = Incremental_State[21],
    set_num_nodes_became_necessary = Incremental_State[22],
    keep_node_creation_backtrace = Incremental_State[23],
    set_keep_node_creation_backtra = Incremental_State[24],
    weak_hashtbls = Incremental_State[25],
    only_in_debug = Incremental_State[26],
    set_only_in_debug = Incremental_State[27],
    run_on_update_handlers = Incremental_State[28],
    set_during_stabilization = Incremental_State[29],
    disallowed_observers = Incremental_State[30],
    new_observers = Incremental_State[31],
    finalized_observers = Incremental_State[32],
    all_observers = Incremental_State[33],
    set_all_observers = Incremental_State[34],
    num_active_observers = Incremental_State[35],
    set_num_active_observers = Incremental_State[36],
    adjust_heights_heap = Incremental_State[37],
    recompute_heap = Incremental_State[38],
    current_scope = Incremental_State[39],
    set_current_scope = Incremental_State[40],
    stabilization_num = Incremental_State[41],
    set_stabilization_num = Incremental_State[42],
    bind_lhs_change_should_invalid = Incremental_State[43],
    status = Incremental_State[44],
    set_status = Incremental_State[45],
    Fields = Incremental_State[46],
    sexp_of_t = Incremental_State[47],
    include = Incremental_State[48],
    now = Incremental_State[49],
    timing_wheel_length = Incremental_State[50],
    num_stabilizes = Incremental_State[51],
    max_height_allowed = Incremental_State[52],
    max_height_seen = Incremental_State[53],
    iter_observers = Incremental_State[54],
    directly_observed = Incremental_State[55],
    save_dot = Incremental_State[56],
    save_dot_to_file = Incremental_State[57],
    iter_observer_descendants = Incremental_State[58],
    Stats = Incremental_State[59],
    stats = Incremental_State[60],
    am_stabilizing = Incremental_State[61],
    invariant = Incremental_State[62],
    ensure_not_stabilizing = Incremental_State[63],
    set_height = Incremental_State[64],
    set_max_height_allowed = Incremental_State[65],
    handle_after_stabilization = Incremental_State[66],
    remove_children = Incremental_State[67],
    remove_child = Incremental_State[68],
    check_if_unnecessary = Incremental_State[69],
    became_unnecessary = Incremental_State[70],
    remove_alarm = Incremental_State[71],
    invalidate_node = Incremental_State[72],
    invalidate_nodes_created_on_rh = Incremental_State[73],
    rescope_nodes_created_on_rhs = Incremental_State[74],
    propagate_invalidity = Incremental_State[75],
    add_parent_without_adjusting_h = Incremental_State[76],
    became_necessary = Incremental_State[77],
    add_parent = Incremental_State[78],
    run_with_scope = Incremental_State[79],
    within_scope = Incremental_State[80],
    change_child = Incremental_State[81],
    add_alarm = Incremental_State[82],
    recompute = Incremental_State[83],
    copy_child = Incremental_State[84],
    maybe_change_value = Incremental_State[85],
    recompute_first_node_that_is_n = Incremental_State[86],
    unlink_disallowed_observers = Incremental_State[87],
    disallow_future_use = Incremental_State[88],
    disallow_finalized_observers = Incremental_State[89],
    observer_finalizer = Incremental_State[90],
    create_observer = Incremental_State[91],
    add_new_observers = Incremental_State[92],
    observer_value_exn = Incremental_State[93],
    observer_value = Incremental_State[94],
    node_on_update = Incremental_State[95],
    observer_on_update_exn = Incremental_State[96],
    set_var_while_not_stabilizing = Incremental_State[97],
    set_var = Incremental_State[98],
    reclaim_space_in_weak_hashtbls = Incremental_State[99],
    stabilize_start = Incremental_State[100],
    stabilize_end = Incremental_State[101],
    raise_during_stabilization = Incremental_State[102],
    stabilize = Incremental_State[103],
    Step_result = Incremental_State[104],
    do_one_step_of_stabilize = Incremental_State[105],
    create_node_in = Incremental_State[106],
    create_node = Incremental_State[107],
    create_node_top = Incremental_State[108],
    create_var = Incremental_State[109],
    const$0 = Incremental_State[110],
    map = Incremental_State[111],
    map2 = Incremental_State[112],
    both = Incremental_State[113],
    map3 = Incremental_State[114],
    map4 = Incremental_State[115],
    map5 = Incremental_State[116],
    map6 = Incremental_State[117],
    map7 = Incremental_State[118],
    map8 = Incremental_State[119],
    map9 = Incremental_State[120],
    map10 = Incremental_State[121],
    map11 = Incremental_State[122],
    map12 = Incremental_State[123],
    map13 = Incremental_State[124],
    map14 = Incremental_State[125],
    map15 = Incremental_State[126],
    preserve_cutoff = Incremental_State[127],
    depend_on = Incremental_State[128],
    necessary_if_alive = Incremental_State[129],
    bind = Incremental_State[130],
    bind2 = Incremental_State[131],
    bind3 = Incremental_State[132],
    bind4 = Incremental_State[133],
    join = Incremental_State[134],
    if$0 = Incremental_State[135],
    lazy_from_fun = Incremental_State[136],
    default_hash_table_initial_siz = Incremental_State[137],
    memoize_fun_by_key = Incremental_State[138],
    array_fold = Incremental_State[139],
    all = Incremental_State[140],
    unordered_array_fold = Incremental_State[141],
    opt_unordered_array_fold = Incremental_State[142],
    at_least_k_of = Incremental_State[143],
    exists = Incremental_State[144],
    for_all = Incremental_State[145],
    sum = Incremental_State[146],
    opt_sum = Incremental_State[147],
    sum_int = Incremental_State[148],
    sum_float = Incremental_State[149],
    set_freeze = Incremental_State[150],
    freeze = Incremental_State[151],
    at = Incremental_State[152],
    after = Incremental_State[153],
    next_interval_alarm_strict = Incremental_State[154],
    at_intervals = Incremental_State[155],
    snapshot = Incremental_State[156],
    incremental_step_function = Incremental_State[157],
    make_stale = Incremental_State[158],
    advance_clock = Incremental_State[159],
    create_clock = Incremental_State[160],
    create_internal = Incremental_State[161],
    weak_memoize_fun_by_key = Incremental_State[162],
    Expert = Incremental_State[163],
    _m_ = [0, cst_src_incremental_ml, 282, 2],
    cst_invalid$0 = cst_invalid$1,
    cst_unnecessary = "<unnecessary>",
    cst_uncomputed = "<uncomputed>",
    _j_ = [0, "Invalid"],
    _k_ = [0, "Necessary_maybe_stale"],
    _l_ = [0, "Unnecessary_maybe_stale"],
    cst_disallowed = "<disallowed>",
    cst_unstabilized = "<unstabilized>",
    cst_invalid = cst_invalid$1,
    _f_ = [0, "_"],
    cst_Incremental_bug_Observer_o =
      "Incremental bug -- Observer.on_update_exn got unexpected update Unnecessary",
    _g_ = [0, cst_src_incremental_ml, 141, 3574, 3592],
    _c_ = [0, "Invalidated"],
    _d_ = [0, "Initialized"],
    _e_ = [0, "Changed"],
    _a_ = [0, cst_src_incremental_ml, 30, 8],
    _h_ = [0, 1],
    cst_incremental = cst_incremental$0,
    cst_Incremental = cst_Incremental$0,
    default_max_height_allowed = 128;
   function create(opt, param){
    if(opt)
     var sth = opt[1], max_height_allowed = sth;
    else
     var max_height_allowed = default_max_height_allowed;
    function sexp_of_state_witness(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    }
    var
     t =
       caml_call2
        (create_internal,
         caml_call1(Incremental_Config[1], [0]),
         max_height_allowed);
    return [0, sexp_of_state_witness, t];
   }
   var
    sexp_of_t$0 = Incremental_Scope[1],
    invariant$0 = Incremental_Scope[2],
    top = Incremental_Scope[3],
    is_top = Incremental_Scope[4],
    height = Incremental_Scope[5],
    is_valid = Incremental_Scope[6],
    is_necessary = Incremental_Scope[7],
    add_node = Incremental_Scope[8];
   function current(state, param){return state[4];}
   function within(state, t, f){return caml_call3(within_scope, state, t, f);}
   var
    Packed = Incremental_Node[1],
    invariant$1 = Incremental_Node[4],
    is_const = Incremental_Node[13],
    is_necessary$0 = Incremental_Node[15],
    is_valid$0 = Incremental_Node[16],
    unsafe_value = Incremental_Node[22],
    get_cutoff = Incremental_Node[23],
    set_cutoff = Incremental_Node[24],
    user_info = Incremental_Node[27],
    set_user_info = Incremental_Node[28],
    append_user_info_graphviz = Incremental_Node[29];
   function state(t){return t[2];}
   function pack(t){return t;}
   function return$0(state, a){return caml_call2(const$0, state, a);}
   var
    N_ary_map_and_bind =
      [0,
       map2,
       map3,
       map4,
       map5,
       map6,
       map7,
       map8,
       map9,
       map10,
       map11,
       map12,
       map13,
       map14,
       map15,
       bind2,
       bind3,
       bind4],
    map2$0 = N_ary_map_and_bind[1],
    map3$0 = N_ary_map_and_bind[2],
    map4$0 = N_ary_map_and_bind[3],
    map5$0 = N_ary_map_and_bind[4],
    map6$0 = N_ary_map_and_bind[5],
    map7$0 = N_ary_map_and_bind[6],
    map8$0 = N_ary_map_and_bind[7],
    map9$0 = N_ary_map_and_bind[8],
    map10$0 = N_ary_map_and_bind[9],
    map11$0 = N_ary_map_and_bind[10],
    map12$0 = N_ary_map_and_bind[11],
    map13$0 = N_ary_map_and_bind[12],
    map14$0 = N_ary_map_and_bind[13],
    map15$0 = N_ary_map_and_bind[14],
    bind2$0 = N_ary_map_and_bind[15],
    bind3$0 = N_ary_map_and_bind[16],
    bind4$0 = N_ary_map_and_bind[17];
   function symbol_map(t, f){return caml_call2(map, t, f);}
   function symbol_bind(t, f){return caml_call2(bind, t, f);}
   var
    Infix = [0, symbol_map, symbol_bind],
    symbol_map$0 = Infix[1],
    symbol_bind$0 = Infix[2];
   function lazy_from_fun$0(state, f){
    return caml_call2(lazy_from_fun, state, f);
   }
   function memoize_fun(initial_size, state, hashable, f){
    return caml_call5
            (memoize_fun_by_key,
             initial_size,
             state,
             hashable,
             function(_X_){return _X_;},
             f);
   }
   function array_fold$0(state, ts, init, f){
    return caml_call4(array_fold, state, ts, init, f);
   }
   function reduce_balanced(state, ts, f, reduce){
    return caml_call4(Incremental_Reduce_balanced[1], state, ts, f, reduce);
   }
   var
    invariant$2 = Incremental_Var[1],
    Packed$0 = Incremental_Var[3],
    latest_value = Incremental_Var[4],
    incr_state = Incremental_Var[5];
   function value(t){return t[1];}
   function watch(t){return t[4];}
   function sexp_of_t$1(sexp_of_a, t){return caml_call1(sexp_of_a, t[1]);}
   function replace(t, f){
    return caml_call2(set_var, t, caml_call1(f, caml_call1(latest_value, t)));
   }
   var
    invariant$3 = Incremental_Observer[1],
    observing = Incremental_Observer[3],
    use_is_allowed = Incremental_Observer[4],
    incr_state$0 = Incremental_Observer[7],
    _b_ = Incremental_Observer[2];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number") return 0;
     if(1 === b_002[0]) return 1;
    }
    else{
     if(0 === a_001[0]){
      var a_003 = a_001[1];
      if(typeof b_002 !== "number" && 0 === b_002[0]){
       var b_004 = b_002[1];
       return caml_call2(cmp_a, a_003, b_004);
      }
      return -1;
     }
     var a_007 = a_001[2], a_005 = a_001[1];
     if(typeof b_002 === "number") return -1;
     if(0 !== b_002[0]){
      var
       b_008 = b_002[2],
       b_006 = b_002[1],
       n = caml_call2(cmp_a, a_005, b_006);
      return 0 === n ? caml_call2(cmp_a, a_007, b_008) : n;
     }
    }
    return 1;
   }
   function sexp_of_t$2(of_a_009, param){
    if(typeof param === "number") return _c_;
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_009, arg0_010);
     return [1, [0, _d_, [0, res0_011, 0]]];
    }
    var
     arg1_013 = param[2],
     arg0_012 = param[1],
     res0_014 = caml_call1(of_a_009, arg0_012),
     res1_015 = caml_call1(of_a_009, arg1_013);
    return [1, [0, _e_, [0, res0_014, [0, res1_015, 0]]]];
   }
   var Update = [0, compare, sexp_of_t$2];
   function on_update_exn(t, f){
    return caml_call2
            (observer_on_update_exn,
             t,
             function(param){
              if(typeof param === "number"){
               if(0 === param) return caml_call1(f, 0);
               var
                _W_ =
                  function(x_017){
                   return caml_call2(_b_, function(param){return _f_;}, x_017);
                  };
               return caml_call5
                       (Core[236], 0, _g_, cst_Incremental_bug_Observer_o, t, _W_);
              }
              if(0 === param[0]){
               var a = param[1];
               return caml_call1(f, [0, a]);
              }
              var a2 = param[2], a1 = param[1];
              return caml_call1(f, [1, a1, a2]);
             });
   }
   function disallow_future_use$0(t){
    return caml_call1(disallow_future_use, t[1]);
   }
   function sexp_of_t$3(sexp_of_a, t){
    var _V_ = t[1][1];
    if(1 !== _V_)
     return _V_
             ? caml_call1(Sexplib0_Sexp_conv[7], cst_disallowed)
             : caml_call1(Sexplib0_Sexp_conv[7], cst_unstabilized);
    var uopt = t[1][2][4];
    return caml_call1(Incremental_Import[16][5], uopt)
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_invalid)
            : caml_call1
              (sexp_of_a, caml_call1(Incremental_Import[16][11], uopt));
   }
   var
    Observer =
      [0,
       invariant$3,
       observing,
       use_is_allowed,
       incr_state$0,
       Update,
       on_update_exn,
       disallow_future_use$0,
       observer_value,
       observer_value_exn,
       sexp_of_t$3],
    fired_alarm_values = include[1],
    set_fired_alarm_values = include[2],
    handle_fired = include[3],
    timing_wheel = include[5],
    Fields$0 = include[6],
    sexp_of_t$4 = include[7],
    invariant$4 = include[8],
    incr_state$1 = include[9],
    alarm_precision = Timing_wheel[1][10],
    _i_ = [0, caml_call2(Timing_wheel[7][5], _h_, level_bits)],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _i_, alarm_precision, 0);
   function create$0(state, opt, start, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = default_timing_wheel_config;
    var
     _U_ = caml_call1(Incremental_Import[14][86], start),
     start$0 = caml_call1(Incremental_Import[14][88], _U_);
    return caml_call3(create_clock, state, timing_wheel_config, start$0);
   }
   function alarm_precision$0(t){return caml_call1(Timing_wheel[10], t[1]);}
   function watch_now(t){return t[2][4];}
   function advance_clock_by(t, span){
    var _T_ = caml_call1(now, t);
    return caml_call2
            (advance_clock,
             t,
             caml_call2(Incremental_Import[14][66], _T_, span));
   }
   function step_function(t, init, steps){
    var _S_ = caml_call2(Incremental_step_function[7], init, steps);
    return caml_call2
            (incremental_step_function,
             t,
             return$0(caml_call1(incr_state$1, t), _S_));
   }
   function freeze$0(opt, t){
    if(opt)
     var sth = opt[1], when = sth;
    else
     var when = function(param){return 1;};
    return caml_call2(freeze, t, when);
   }
   function depend_on$0(t, depend_on$0){
    return caml_call2(depend_on, t, depend_on$0);
   }
   function stabilize$0(state){return caml_call1(stabilize, state);}
   function am_stabilizing$0(state){return caml_call1(am_stabilizing, state);}
   function sexp_of_t$5(of_a_018, param){
    if(typeof param === "number") return _j_;
    if(0 === param[0]){
     var
      arg0_019 = param[1],
      res0_020 = caml_call2(Core[454], of_a_018, arg0_019);
     return [1, [0, _k_, [0, res0_020, 0]]];
    }
    var
     arg0_021 = param[1],
     res0_022 = caml_call2(Core[454], of_a_018, arg0_021);
    return [1, [0, _l_, [0, res0_022, 0]]];
   }
   var Node_value = [0, sexp_of_t$5];
   function node_value(t){
    return caml_call1(is_valid$0, t)
            ? caml_call1
               (is_necessary$0, t)
              ? [0, caml_call1(Incremental_Import[16][8], t[4])]
              : [1, caml_call1(Incremental_Import[16][8], t[4])]
            : 0;
   }
   function sexp_of_t$6(sexp_of_a, t){
    return caml_call1(is_valid$0, t)
            ? caml_call1
               (is_necessary$0, t)
              ? caml_call1
                 (Incremental_Import[16][5], t[4])
                ? caml_call1(Core[471], cst_uncomputed)
                : caml_call1(sexp_of_a, caml_call1(unsafe_value, t))
              : caml_call1(Core[471], cst_unnecessary)
            : caml_call1(Core[471], cst_invalid$0);
   }
   function both$0(t1, t2){
    return caml_call3(map2$0, t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   var
    map2$1 = N_ary_map_and_bind[1],
    map3$1 = N_ary_map_and_bind[2],
    map4$1 = N_ary_map_and_bind[3],
    map5$1 = N_ary_map_and_bind[4],
    map6$1 = N_ary_map_and_bind[5],
    map7$1 = N_ary_map_and_bind[6],
    map8$1 = N_ary_map_and_bind[7],
    map9$1 = N_ary_map_and_bind[8],
    map10$1 = N_ary_map_and_bind[9],
    map11$1 = N_ary_map_and_bind[10],
    map12$1 = N_ary_map_and_bind[11],
    map13$1 = N_ary_map_and_bind[12],
    map14$1 = N_ary_map_and_bind[13],
    map15$1 = N_ary_map_and_bind[14],
    bind2$1 = N_ary_map_and_bind[15],
    bind3$1 = N_ary_map_and_bind[16],
    bind4$1 = N_ary_map_and_bind[17],
    Open_on_rhs = [0, watch];
   function weak_memoize_fun(initial_size, state, hashable, f){
    return caml_call5
            (weak_memoize_fun_by_key,
             initial_size,
             state,
             hashable,
             function(_R_){return _R_;},
             f);
   }
   function Make_with_config(Incremental_config, symbol){
    function sexp_of_state_witness(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    }
    var
     t = caml_call2(create_internal, Incremental_config, 128),
     State =
       [0,
        sexp_of_status,
        Run_on_update_handlers,
        Only_in_debug,
        Packed_weak_hashtbl,
        num_var_sets,
        set_num_var_sets,
        num_nodes_recomputed_directly_,
        set_num_nodes_recomputed_direc,
        num_nodes_recomputed_directly_$0,
        set_num_nodes_recomputed_direc$0,
        num_nodes_recomputed,
        set_num_nodes_recomputed,
        num_nodes_invalidated,
        set_num_nodes_invalidated,
        num_nodes_created,
        set_num_nodes_created,
        num_nodes_changed,
        set_num_nodes_changed,
        num_nodes_became_unnecessary,
        set_num_nodes_became_unnecessa,
        num_nodes_became_necessary,
        set_num_nodes_became_necessary,
        keep_node_creation_backtrace,
        set_keep_node_creation_backtra,
        weak_hashtbls,
        only_in_debug,
        set_only_in_debug,
        run_on_update_handlers,
        set_during_stabilization,
        disallowed_observers,
        new_observers,
        finalized_observers,
        all_observers,
        set_all_observers,
        num_active_observers,
        set_num_active_observers,
        adjust_heights_heap,
        recompute_heap,
        current_scope,
        set_current_scope,
        stabilization_num,
        set_stabilization_num,
        bind_lhs_change_should_invalid,
        status,
        set_status,
        Fields,
        sexp_of_t,
        include,
        now,
        timing_wheel_length,
        num_stabilizes,
        max_height_allowed,
        max_height_seen,
        iter_observers,
        directly_observed,
        save_dot,
        save_dot_to_file,
        iter_observer_descendants,
        Stats,
        stats,
        am_stabilizing,
        invariant,
        ensure_not_stabilizing,
        set_height,
        set_max_height_allowed,
        handle_after_stabilization,
        remove_children,
        remove_child,
        check_if_unnecessary,
        became_unnecessary,
        remove_alarm,
        invalidate_node,
        invalidate_nodes_created_on_rh,
        rescope_nodes_created_on_rhs,
        propagate_invalidity,
        add_parent_without_adjusting_h,
        became_necessary,
        add_parent,
        run_with_scope,
        within_scope,
        change_child,
        add_alarm,
        recompute,
        copy_child,
        maybe_change_value,
        recompute_first_node_that_is_n,
        unlink_disallowed_observers,
        disallow_future_use,
        disallow_finalized_observers,
        observer_finalizer,
        create_observer,
        add_new_observers,
        observer_value_exn,
        observer_value,
        node_on_update,
        observer_on_update_exn,
        set_var_while_not_stabilizing,
        set_var,
        reclaim_space_in_weak_hashtbls,
        stabilize_start,
        stabilize_end,
        raise_during_stabilization,
        stabilize,
        Step_result,
        do_one_step_of_stabilize,
        create_node_in,
        create_node,
        create_node_top,
        create_var,
        const$0,
        map,
        map2,
        both,
        map3,
        map4,
        map5,
        map6,
        map7,
        map8,
        map9,
        map10,
        map11,
        map12,
        map13,
        map14,
        map15,
        preserve_cutoff,
        depend_on,
        necessary_if_alive,
        bind,
        bind2,
        bind3,
        bind4,
        join,
        if$0,
        lazy_from_fun,
        default_hash_table_initial_siz,
        memoize_fun_by_key,
        array_fold,
        all,
        unordered_array_fold,
        opt_unordered_array_fold,
        at_least_k_of,
        exists,
        for_all,
        sum,
        opt_sum,
        sum_int,
        sum_float,
        set_freeze,
        freeze,
        at,
        after,
        next_interval_alarm_strict,
        at_intervals,
        snapshot,
        incremental_step_function,
        make_stale,
        advance_clock,
        create_clock,
        weak_memoize_fun_by_key,
        Expert,
        create_internal,
        create,
        t];
    function create$1(timing_wheel_config, start, param){
     return create$0(State[165], timing_wheel_config, start, 0);
    }
    var
     Clock =
       [0,
        fired_alarm_values,
        set_fired_alarm_values,
        handle_fired,
        timing_wheel,
        Fields$0,
        sexp_of_t$4,
        invariant$4,
        incr_state$1,
        incr_state$1,
        default_timing_wheel_config,
        alarm_precision$0,
        timing_wheel_length,
        now,
        watch_now,
        at,
        after,
        at_intervals,
        advance_clock,
        advance_clock_by,
        incremental_step_function,
        step_function,
        snapshot,
        create$1],
     Dependency = Incremental_Expert1[1],
     Node = Incremental_Expert1[2],
     sexp_of_t$2 = Node[1],
     watch$0 = Node[3],
     make_stale$0 = Node[4],
     invalidate = Node[5],
     add_dependency = Node[6],
     remove_dependency = Node[7],
     _Q_ = Node[2];
    function create$2(on_observability_change, f){
     return caml_call3(_Q_, State[165], on_observability_change, f);
    }
    var
     Node$0 =
       [0,
        sexp_of_t$2,
        watch$0,
        make_stale$0,
        invalidate,
        add_dependency,
        remove_dependency,
        create$2];
    function do_one_step_of_stabilize$0(param){
     return caml_call1(State[105], State[165]);
    }
    var Expert$0 = [0, Dependency, Node$0, do_one_step_of_stabilize$0];
    function return$1(a){return return$0(State[165], a);}
    var
     Let_syntax =
       [0,
        bind,
        map,
        both$0,
        map2$1,
        map3$1,
        map4$1,
        map5$1,
        map6$1,
        map7$1,
        map8$1,
        map9$1,
        map10$1,
        map11$1,
        map12$1,
        map13$1,
        map14$1,
        map15$1,
        bind2$1,
        bind3$1,
        bind4$1,
        Open_on_rhs,
        return$1],
     Let_syntax$0 = [0, symbol_map$0, symbol_bind$0, return$1, Let_syntax];
    function current(param){return State[165][4];}
    function within$0(t, f){return within(State[165], t, f);}
    var
     Scope =
       [0,
        sexp_of_t$0,
        invariant$0,
        top,
        is_top,
        height,
        is_valid,
        is_necessary,
        add_node,
        current,
        within$0];
    function create$3(use_current_scope, value){
     return caml_call3(create_var, State[165], use_current_scope, value);
    }
    var
     Var =
       [0,
        invariant$2,
        Packed$0,
        latest_value,
        incr_state,
        set_var,
        value,
        watch,
        sexp_of_t$1,
        replace,
        create$3];
    function const$1(a){return return$0(State[165], a);}
    function return$2(a){return return$0(State[165], a);}
    function all$0(ts){return caml_call2(all, State[165], ts);}
    function exists$0(ts){return caml_call2(exists, State[165], ts);}
    function for_all$0(ts){return caml_call2(for_all, State[165], ts);}
    function memoize_fun_by_key$0(initial_size, hashable, project_key, f){
     return caml_call5
             (memoize_fun_by_key,
              initial_size,
              State[165],
              hashable,
              project_key,
              f);
    }
    function memoize_fun$0(initial_size, hashable, f){
     return memoize_fun(initial_size, State[165], hashable, f);
    }
    function array_fold$1(ts, init, f){
     return array_fold$0(State[165], ts, init, f);
    }
    function reduce_balanced$0(ts, f, reduce){
     return reduce_balanced(State[165], ts, f, reduce);
    }
    function unordered_array_fold$0
    (full_compute_every_n_changes, ts, init, f, update){
     return caml_call6
             (unordered_array_fold,
              State[165],
              full_compute_every_n_changes,
              ts,
              init,
              f,
              update);
    }
    function opt_unordered_array_fold$0
    (full_compute_every_n_changes, ts, init, f, f_inverse){
     return caml_call6
             (opt_unordered_array_fold,
              State[165],
              full_compute_every_n_changes,
              ts,
              init,
              f,
              f_inverse);
    }
    function sum$0(full_compute_every_n_changes, ts, zero, add, sub){
     return caml_call6
             (sum,
              State[165],
              full_compute_every_n_changes,
              ts,
              zero,
              add,
              sub);
    }
    function opt_sum$0(full_compute_every_n_changes, ts, zero, add, sub){
     return caml_call6
             (opt_sum,
              State[165],
              full_compute_every_n_changes,
              ts,
              zero,
              add,
              sub);
    }
    function sum_int$0(ts){return caml_call2(sum_int, State[165], ts);}
    function sum_float$0(ts){return caml_call2(sum_float, State[165], ts);}
    function stabilize$1(param){return stabilize$0(State[165]);}
    function am_stabilizing$1(param){return am_stabilizing$0(State[165]);}
    function save_dot$0(out){return caml_call2(save_dot, State[165], out);}
    function save_dot_to_file$0(file){
     return caml_call6(Stdio_Out_channel[6], 0, 0, 0, 0, file, save_dot$0);
    }
    function lazy_from_fun$0(f){
     var state = State[165];
     return caml_call2(State[136], state, f);
    }
    function weak_memoize_fun_by_key$0(initial_size, hashable, project_key, f){
     return caml_call5
             (weak_memoize_fun_by_key,
              initial_size,
              State[165],
              hashable,
              project_key,
              f);
    }
    function weak_memoize_fun$0(initial_size, hashable, f){
     return weak_memoize_fun(initial_size, State[165], hashable, f);
    }
    return [0,
            sexp_of_state_witness,
            Packed,
            ,
            invariant$1,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            is_const,
            ,
            is_necessary$0,
            is_valid$0,
            ,
            ,
            ,
            ,
            ,
            ,
            get_cutoff,
            set_cutoff,
            ,
            user_info,
            set_user_info,
            append_user_info_graphviz,
            ,
            ,
            ,
            pack,
            create_observer,
            map,
            bind,
            ,
            map2$0,
            map3$0,
            map4$0,
            map5$0,
            map6$0,
            map7$0,
            map8$0,
            map9$0,
            map10$0,
            map11$0,
            map12$0,
            map13$0,
            map14$0,
            map15$0,
            bind2$0,
            bind3$0,
            bind4$0,
            Infix,
            symbol_map$0,
            symbol_bind$0,
            join,
            if$0,
            default_hash_table_initial_siz,
            ,
            both,
            Observer,
            freeze$0,
            depend_on$0,
            necessary_if_alive,
            node_on_update,
            Node_value,
            node_value,
            sexp_of_t$6,
            State,
            Clock,
            Expert$0,
            Let_syntax$0,
            Scope,
            Var,
            const$1,
            return$2,
            all$0,
            exists$0,
            for_all$0,
            memoize_fun_by_key$0,
            memoize_fun$0,
            array_fold$1,
            reduce_balanced$0,
            unordered_array_fold$0,
            opt_unordered_array_fold$0,
            sum$0,
            opt_sum$0,
            sum_int$0,
            sum_float$0,
            stabilize$1,
            am_stabilizing$1,
            save_dot$0,
            save_dot_to_file$0,
            lazy_from_fun$0,
            weak_memoize_fun_by_key$0,
            weak_memoize_fun$0];
   }
   function Add_witness0(M){
    function sexp_of_t(param, t){return caml_call1(M[1], t);}
    return [0, sexp_of_t];
   }
   function Add_witness1(M){
    function invariant(invariant_a, param, t){return caml_call2(M[2], invariant_a, t);
    }
    function sexp_of_t(sexp_of_a, param, t){return caml_call2(M[1], sexp_of_a, t);
    }
    return [0, sexp_of_t, invariant];
   }
   var
    include$0 = Add_witness0([0, sexp_of_t$4, invariant$4]),
    sexp_of_t$7 = include$0[1],
    Dependency = Incremental_Expert1[1],
    Node = Incremental_Expert1[2],
    create$1 = Dependency[2],
    value$0 = Dependency[3],
    sexp_of_t$8 = Dependency[1];
   function invariant$5(param, _P_){return 0;}
   var
    include$1 = Add_witness1([0, sexp_of_t$8, invariant$5]),
    sexp_of_t$9 = include$1[1],
    create$2 = Node[2],
    watch$0 = Node[3],
    make_stale$0 = Node[4],
    invalidate = Node[5],
    add_dependency = Node[6],
    remove_dependency = Node[7],
    sexp_of_t$10 = Node[1];
   function invariant$6(param, _O_){return 0;}
   var
    include$2 = Add_witness1([0, sexp_of_t$10, invariant$6]),
    sexp_of_t$11 = include$2[1];
   function do_one_step_of_stabilize$0(state){
    return caml_call1(do_one_step_of_stabilize, state);
   }
   var
    include$3 = Add_witness1([0, Incremental_Node[2], Incremental_Node[4]]),
    sexp_of_t$12 = include$3[1],
    invariant$7 = include$3[2],
    observing$0 = Observer[2],
    use_is_allowed$0 = Observer[3],
    Update$0 = Observer[5],
    on_update_exn$0 = Observer[6],
    disallow_future_use$1 = Observer[7],
    value$1 = Observer[8],
    value_exn = Observer[9],
    include$4 = Add_witness1([0, Observer[10], Observer[1]]),
    sexp_of_t$13 = include$4[1],
    invariant$8 = include$4[2],
    include$5 = Add_witness0([0, sexp_of_t, invariant]),
    sexp_of_t$14 = include$5[1],
    include$6 = Add_witness1([0, sexp_of_t$1, invariant$2]),
    sexp_of_t$15 = include$6[1],
    debug = Incremental_Import[11],
    Private = [0, debug];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incremental);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental);
   function _n_(_C_, _B_){
    var
     _D_ = Make_with_config(_C_, _B_),
     _E_ = _D_[72],
     _F_ = _E_[2],
     _G_ = _D_[71],
     _H_ = _D_[73],
     _I_ = _H_[4],
     _J_ = _D_[2],
     _K_ = _D_[62],
     _L_ = _D_[75],
     _M_ = _D_[74],
     _N_ = _D_[70];
    return [0,
            _D_[1],
            [0,
             _N_[47],
             _N_[62],
             _N_[165],
             _N_[23],
             _N_[24],
             _N_[52],
             _N_[65],
             _N_[35],
             _N_[53],
             _N_[21],
             _N_[19],
             _N_[17],
             _N_[15],
             _N_[13],
             _N_[11],
             _N_[9],
             _N_[7],
             _N_[51],
             _N_[5],
             [0, _N_[59][2]],
             _N_[60]],
            _D_[69],
            _D_[4],
            _D_[13],
            _D_[16],
            _D_[15],
            _D_[76],
            _D_[77],
            _D_[34],
            _D_[55],
            _D_[37],
            _D_[38],
            _D_[39],
            _D_[40],
            _D_[41],
            _D_[42],
            _D_[43],
            _D_[44],
            _D_[45],
            _D_[46],
            _D_[47],
            _D_[48],
            _D_[49],
            _D_[50],
            _D_[35],
            _D_[56],
            _D_[51],
            _D_[52],
            _D_[53],
            _D_[54],
            _D_[57],
            _D_[58],
            _D_[63],
            _D_[64],
            _D_[65],
            _D_[80],
            _D_[79],
            _D_[78],
            _D_[61],
            _D_[83],
            _D_[84],
            [0],
            _D_[85],
            _D_[86],
            _D_[87],
            _D_[88],
            _D_[89],
            _D_[90],
            [0, _M_[3], _M_[9], _M_[10]],
            [0, _L_[8], _L_[10], _L_[5], _L_[7], _L_[6], _L_[3], _L_[9]],
            [0,
             _K_[10],
             _K_[1],
             _K_[2],
             _K_[3],
             _K_[8],
             _K_[9],
             _K_[5],
             _K_[6],
             _K_[7]],
            _D_[33],
            Incremental_On_update_handler[1],
            _D_[66],
            _D_[91],
            _D_[92],
            [0,
             Incremental_Cutoff[1],
             Incremental_Cutoff[2],
             Incremental_Cutoff[3],
             Incremental_Cutoff[4],
             Incremental_Cutoff[5],
             Incremental_Cutoff[6],
             Incremental_Cutoff[7],
             Incremental_Cutoff[8],
             Incremental_Cutoff[9],
             Incremental_Cutoff[11],
             Incremental_Cutoff[10]],
            _D_[24],
            _D_[23],
            _D_[95],
            _D_[59],
            _D_[82],
            _D_[81],
            _D_[97],
            _D_[96],
            _D_[26],
            _D_[27],
            _D_[28],
            _D_[67],
            _D_[68],
            [0, _J_[5], _J_[6], _J_[7]],
            _D_[32],
            _D_[93],
            _D_[94],
            [0,
             _H_[3],
             _H_[1],
             _H_[2],
             [0,
              _I_[1],
              _I_[22],
              _I_[18],
              _I_[19],
              _I_[20],
              _I_[2],
              _I_[4],
              _I_[5],
              _I_[6],
              _I_[7],
              _I_[8],
              _I_[9],
              _I_[10],
              _I_[11],
              _I_[12],
              _I_[13],
              _I_[14],
              _I_[15],
              _I_[16],
              _I_[17],
              _I_[3],
              _I_[21]]],
            Incremental_Before_or_after,
            [0,
             _G_[6],
             _G_[10],
             _G_[23],
             _G_[11],
             _G_[12],
             _G_[13],
             _G_[14],
             _G_[18],
             _G_[19],
             _G_[15],
             _G_[16],
             _G_[17],
             _G_[21],
             _G_[20],
             _G_[22]],
            [0,
             _E_[1],
             [0, _F_[1], _F_[7], _F_[2], _F_[3], _F_[4], _F_[5], _F_[6]],
             _D_[70][104],
             _E_[3]]];
   }
   function _o_(_p_){
    var
     _A_ = Make_with_config(caml_call1(Incremental_Config[1], [0]), [0]),
     _q_ = _A_[72],
     _r_ = _q_[2],
     _s_ = _A_[71],
     _t_ = _A_[73],
     _u_ = _t_[4],
     _v_ = _A_[2],
     _w_ = _A_[62],
     _x_ = _A_[75],
     _y_ = _A_[74],
     _z_ = _A_[70];
    return [0,
            _A_[1],
            [0,
             _z_[47],
             _z_[62],
             _z_[165],
             _z_[23],
             _z_[24],
             _z_[52],
             _z_[65],
             _z_[35],
             _z_[53],
             _z_[21],
             _z_[19],
             _z_[17],
             _z_[15],
             _z_[13],
             _z_[11],
             _z_[9],
             _z_[7],
             _z_[51],
             _z_[5],
             [0, _z_[59][2]],
             _z_[60]],
            _A_[69],
            _A_[4],
            _A_[13],
            _A_[16],
            _A_[15],
            _A_[76],
            _A_[77],
            _A_[34],
            _A_[55],
            _A_[37],
            _A_[38],
            _A_[39],
            _A_[40],
            _A_[41],
            _A_[42],
            _A_[43],
            _A_[44],
            _A_[45],
            _A_[46],
            _A_[47],
            _A_[48],
            _A_[49],
            _A_[50],
            _A_[35],
            _A_[56],
            _A_[51],
            _A_[52],
            _A_[53],
            _A_[54],
            _A_[57],
            _A_[58],
            _A_[63],
            _A_[64],
            _A_[65],
            _A_[80],
            _A_[79],
            _A_[78],
            _A_[61],
            _A_[83],
            _A_[84],
            [0],
            _A_[85],
            _A_[86],
            _A_[87],
            _A_[88],
            _A_[89],
            _A_[90],
            [0, _y_[3], _y_[9], _y_[10]],
            [0, _x_[8], _x_[10], _x_[5], _x_[7], _x_[6], _x_[3], _x_[9]],
            [0,
             _w_[10],
             _w_[1],
             _w_[2],
             _w_[3],
             _w_[8],
             _w_[9],
             _w_[5],
             _w_[6],
             _w_[7]],
            _A_[33],
            Incremental_On_update_handler[1],
            _A_[66],
            _A_[91],
            _A_[92],
            [0,
             Incremental_Cutoff[1],
             Incremental_Cutoff[2],
             Incremental_Cutoff[3],
             Incremental_Cutoff[4],
             Incremental_Cutoff[5],
             Incremental_Cutoff[6],
             Incremental_Cutoff[7],
             Incremental_Cutoff[8],
             Incremental_Cutoff[9],
             Incremental_Cutoff[11],
             Incremental_Cutoff[10]],
            _A_[24],
            _A_[23],
            _A_[95],
            _A_[59],
            _A_[82],
            _A_[81],
            _A_[97],
            _A_[96],
            _A_[26],
            _A_[27],
            _A_[28],
            _A_[67],
            _A_[68],
            [0, _v_[5], _v_[6], _v_[7]],
            _A_[32],
            _A_[93],
            _A_[94],
            [0,
             _t_[3],
             _t_[1],
             _t_[2],
             [0,
              _u_[1],
              _u_[22],
              _u_[18],
              _u_[19],
              _u_[20],
              _u_[2],
              _u_[4],
              _u_[5],
              _u_[6],
              _u_[7],
              _u_[8],
              _u_[9],
              _u_[10],
              _u_[11],
              _u_[12],
              _u_[13],
              _u_[14],
              _u_[15],
              _u_[16],
              _u_[17],
              _u_[3],
              _u_[21]]],
            Incremental_Before_or_after,
            [0,
             _s_[6],
             _s_[10],
             _s_[23],
             _s_[11],
             _s_[12],
             _s_[13],
             _s_[14],
             _s_[18],
             _s_[19],
             _s_[15],
             _s_[16],
             _s_[17],
             _s_[21],
             _s_[20],
             _s_[22]],
            [0,
             _q_[1],
             [0, _r_[1], _r_[7], _r_[2], _r_[3], _r_[4], _r_[5], _r_[6]],
             _A_[70][104],
             _q_[3]]];
   }
   var
    Incremental =
      [0,
       [0,
        sexp_of_t$14,
        create,
        keep_node_creation_backtrace,
        set_keep_node_creation_backtra,
        max_height_allowed,
        set_max_height_allowed,
        num_active_observers,
        max_height_seen,
        num_nodes_became_necessary,
        num_nodes_became_unnecessary,
        num_nodes_changed,
        num_nodes_created,
        num_nodes_invalidated,
        num_nodes_recomputed,
        num_nodes_recomputed_directly_$0,
        num_nodes_recomputed_directly_,
        num_stabilizes,
        num_var_sets,
        [0, Stats[2]],
        stats],
       sexp_of_t$12,
       invariant$7,
       state,
       is_const,
       is_valid$0,
       is_necessary$0,
       return$0,
       return$0,
       map,
       symbol_map$0,
       map2$0,
       map3$0,
       map4$0,
       map5$0,
       map6$0,
       map7$0,
       map8$0,
       map9$0,
       map10$0,
       map11$0,
       map12$0,
       map13$0,
       map14$0,
       map15$0,
       bind,
       symbol_bind$0,
       bind2$0,
       bind3$0,
       bind4$0,
       Infix,
       join,
       if$0,
       freeze$0,
       depend_on$0,
       necessary_if_alive,
       for_all,
       exists,
       all,
       both,
       array_fold$0,
       reduce_balanced,
       [0],
       unordered_array_fold,
       opt_unordered_array_fold,
       sum,
       opt_sum,
       sum_int,
       sum_float,
       [0, top, current, within],
       [0,
        sexp_of_t$15,
        create_var,
        set_var,
        watch,
        value,
        latest_value,
        replace],
       [0,
        sexp_of_t$13,
        invariant$8,
        observing$0,
        use_is_allowed$0,
        value$1,
        value_exn,
        Update$0,
        on_update_exn$0,
        disallow_future_use$1],
       create_observer,
       Incremental_On_update_handler[1],
       node_on_update,
       stabilize$0,
       am_stabilizing$0,
       [0,
        Incremental_Cutoff[1],
        Incremental_Cutoff[2],
        Incremental_Cutoff[3],
        Incremental_Cutoff[4],
        Incremental_Cutoff[5],
        Incremental_Cutoff[6],
        Incremental_Cutoff[7],
        Incremental_Cutoff[8],
        Incremental_Cutoff[9],
        Incremental_Cutoff[11],
        Incremental_Cutoff[10]],
       set_cutoff,
       get_cutoff,
       lazy_from_fun$0,
       default_hash_table_initial_siz,
       memoize_fun,
       memoize_fun_by_key,
       weak_memoize_fun,
       weak_memoize_fun_by_key,
       user_info,
       set_user_info,
       append_user_info_graphviz,
       Node_value,
       node_value,
       [0, Packed[5], Packed[6]],
       pack,
       save_dot,
       save_dot_to_file,
       [0,
        symbol_map$0,
        symbol_bind$0,
        [0,
         bind,
         bind2$1,
         bind3$1,
         bind4$1,
         map,
         map2$1,
         map3$1,
         map4$1,
         map5$1,
         map6$1,
         map7$1,
         map8$1,
         map9$1,
         map10$1,
         map11$1,
         map12$1,
         map13$1,
         map14$1,
         map15$1,
         both$0,
         Open_on_rhs]],
       Incremental_Before_or_after,
       [0,
        sexp_of_t$7,
        default_timing_wheel_config,
        create$0,
        alarm_precision$0,
        incr_state$1,
        timing_wheel_length,
        now,
        watch_now,
        advance_clock,
        advance_clock_by,
        at,
        after,
        at_intervals,
        step_function,
        incremental_step_function,
        snapshot],
       [0,
        [0, sexp_of_t$9, create$1, value$0],
        [0,
         sexp_of_t$11,
         create$2,
         watch$0,
         make_stale$0,
         invalidate,
         add_dependency,
         remove_dependency],
        Step_result,
        do_one_step_of_stabilize$0],
       _o_,
       Incremental_Config,
       _n_,
       Private];
   runtime.caml_register_global(50, Incremental, cst_Incremental$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyZW1lbnRhbC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwiY29uY2F0IiwiZGVidWciLCJ0YWciLCJhcmcwXzAwMSIsImFyZzFfMDAyIiwic2V4cF9vZl9hIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsInJlYWxsb2MiLCJ0IiwibGVuIiwiYSIsIm5ld190IiwicmVhbGxvYyQwIiwicmVzMF8wMDUiLCJyZXMwXzAwNyIsImludmFyaWFudCIsInhfMDA5IiwiY3JlYXRlIiwiZiIsIm9mX2NvbXBhcmUiLCJvZl9lcXVhbCIsInBvbHlfZXF1YWwiLCJuZXZlciIsImFsd2F5cyIsInNob3VsZF9jdXRvZmYiLCJvbGRfdmFsdWUiLCJuZXdfdmFsdWUiLCJmJDAiLCJmJDEiLCJlcXVhbCIsInQxIiwidDIiLCJmMSIsImYyIiwiZjEkMCIsImYyJDAiLCJmMSQxIiwiZjIkMSIsImNvbXBhcmUiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsInhfMDA1Iiwic2V4cF9vZl9kb3QiLCJhdHRyaWJ1dGVzXzAwOSIsImxhYmVsXzAwNyIsImFyZ18wMTAiLCJibmRzXzAwNiIsImFyZ18wMDgiLCJibmRzXzAwNiQwIiwic2V4cF9vZl90JDAiLCJhcmcwXzAxMSIsInJlczBfMDEyIiwiYXJnMF8wMTMiLCJyZXMwXzAxNCIsIm5ld18wMTgiLCJwcmlvcl8wMTYiLCJhcmdfMDE5IiwiYm5kc18wMTUiLCJhcmdfMDE3IiwiYm5kc18wMTUkMCIsImluZm8iLCJhcHBlbmQiLCJwcmlvciIsIm5ldyQwIiwiZG90IiwibGFiZWwiLCJhdHRyaWJ1dGVzIiwibGFiZWwkMCIsInRvX2RvdCIsImkiLCJwcmlvciQwIiwibmV3JDEiLCJsZWZ0IiwicmlnaHQiLCJlc2NhcGVfZG90X3N0cmluZyIsInMiLCJlc2NhcGVfcmVjb3JkX2xhYmVsIiwiYyIsInRvX3N0cmluZyIsIm5hbWUiLCJjb2xzIiwidiIsImsiLCJhdHRyaWJ1dGVzJDAiLCJyIiwibmV4dCIsIm5vbmUiLCJpc19ub25lIiwiaXNfc29tZSIsImFkZDEiLCJjbXBfYSIsImFfMDA3IiwiYV8wMDUiLCJiXzAwOCIsImJfMDA2IiwibiIsIm9mX2FfMDA5IiwiYXJnMF8wMTAiLCJyZXMwXzAxMSIsImFyZzFfMDEzIiwiYXJnMF8wMTIiLCJyZXMxXzAxNSIsIm9mX2FfMDE3IiwicHJldmlvdXNfdXBkYXRlX2tpbmRfMDIxIiwiY3JlYXRlZF9hdF8wMjMiLCJhcmdfMDI0IiwiYm5kc18wMTgiLCJhcmdfMDIyIiwiYm5kc18wMTgkMCIsImFyZ18wMjAiLCJibmRzXzAxOCQxIiwiY3JlYXRlZF9hdCIsInJlYWxseV9ydW4iLCJub2RlX3VwZGF0ZSIsInJ1biIsIm5vdyIsImJhY2t0cmFjZV8wMDQiLCJleG5fMDAyIiwiYXJnXzAwNSIsImJuZHNfMDAxIiwiYXJnXzAwMyIsImJuZHNfMDAxJDAiLCJleG4iLCJzZXhwX29mX25vZGUiLCJ4XzAwMyIsImlzX3ZhbGlkIiwiaXNfbmVjZXNzYXJ5IiwidHlwZV9lcXVhbF9pZl9waHlzX3NhbWUiLCJiaW5kIiwieF8wMDQiLCJ3YXRjaCIsInNldF9hdCIsInNldF9zZXRfYXQiLCJ2YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24iLCJzZXRfdmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemEiLCJ2YWx1ZSIsInNldF92YWx1ZSIsIndhdGNoJDAiLCJzZXRfYXQkMCIsInZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiQwIiwidmFsdWUkMCIsInNleHBfb2ZfdmFyIiwib2ZfYV8wMDEiLCJ2YWx1ZV8wMDMiLCJzZXRfYXRfMDA3Iiwid2F0Y2hfMDA5IiwiYm5kc18wMDIiLCJibmRzXzAwMiQwIiwiYXJnXzAwNiIsImJuZHNfMDAyJDEiLCJhcmdfMDA0IiwiYm5kc18wMDIkMiIsImludmFyaWFudF9hIiwiY2hlY2siLCJ3YXRjaF9mdW4iLCJ0JDAiLCJzZXRfYXRfZnVuIiwidmFsdWVfZnVuIiwieF8wMTEiLCJpbmNyX3N0YXRlIiwicGFyYW0iLCJyZXMwXzAxNSIsImxhdGVzdF92YWx1ZSIsInBvcyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJudW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY28iLCJzZXRfbnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWwiLCJmb2xkX3ZhbHVlIiwic2V0X2ZvbGRfdmFsdWUiLCJjaGlsZHJlbiIsImZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMiLCJpbml0IiwibWFpbiIsIm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jbyQwIiwiZm9sZF92YWx1ZSQwIiwiY2hpbGRyZW4kMCIsImZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMkMCIsImluaXQkMCIsIm1haW4kMCIsIm9mX2FjY18wMTAiLCJjaGlsZHJlbl8wMjIiLCJmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXzAiLCJpbml0XzAxNCIsIm1haW5fMDEyIiwiZm9sZF92YWx1ZV8wMjQiLCJhcmdfMDI3IiwiYm5kc18wMTEiLCJhcmdfMDI1IiwiYm5kc18wMTEkMCIsImFyZ18wMjMiLCJibmRzXzAxMSQxIiwiYXJnXzAyMSIsImJuZHNfMDExJDIiLCJibmRzXzAxMSQzIiwiYm5kc18wMTEkNCIsImFyZ18wMTUiLCJibmRzXzAxMSQ1IiwiYXJnXzAxMyIsImJuZHNfMDExJDYiLCJpbnZhcmlhbnRfYWNjIiwiZm9sZF92YWx1ZV9mdW4iLCJnb3QiLCJleHBlY3QiLCJzZXhwaWZpZXIiLCJtZXNzYWdlIiwiaGVyZSIsImNvbXBhcmF0b3IiLCJhXzAyOSIsImJfMDMwIiwiY2hpbGRyZW5fZnVuIiwiY2hpbGQiLCJmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzX2YiLCJpbml0X2Z1biIsIm1haW5fZnVuIiwieF8wMjgiLCJ1cGRhdGUkMCIsImZfaW52ZXJzZSIsInVwZGF0ZSIsImNvbXB1dGUiLCJyZXN1bHQiLCJmb3JjZV9mdWxsX2NvbXB1dGUiLCJjaGlsZF9jaGFuZ2VkIiwieF8wMzEiLCJjaGlsZF9pbmRleCIsIm9sZF92YWx1ZV9vcHQiLCJjaGlsZF9hdF9pbmRleCIsInhfMDAxIiwibnVsbCQwIiwiYWxhcm1fdmFsdWUiLCJzZXRfYWxhcm1fdmFsdWUiLCJhbGFybSIsInNldF9hbGFybSIsImFsYXJtX3ZhbHVlJDAiLCJhbGFybSQwIiwibWFpbl8wMDMiLCJjaGlsZF8wMDUiLCJleHRyYWN0ZWRfc3RlcF9mdW5jdGlvbl9mcm9tX2MiLCJ2YWx1ZV8wMDkiLCJ1cGNvbWluZ19zdGVwc18wMTEiLCJhbGFybV8wMTciLCJhbGFybV92YWx1ZV8wMTkiLCJjbG9ja18wMjEiLCJhcmdfMDE4IiwiYXJnMV8wMTQiLCJyZXMxXzAxNiIsImFyZ18wMTIiLCJibmRzXzAwMiQzIiwiYm5kc18wMDIkNCIsImJuZHNfMDAyJDUiLCJibmRzXzAwMiQ2IiwiYWxhcm1fdmFsdWVfZnVuIiwiYWxhcm1fZnVuIiwieF8wMjMiLCJhZHZhbmNlIiwidG8iLCJzdGVwcyQwIiwiYTEkMCIsImExIiwic3RlcHMiLCJzdGVwczIiLCJhMiIsInN0ZXBfYXQiLCJvZl9hY2NfMDAyIiwiY2hpbGRyZW5fMDA4IiwiaW5pdF8wMDQiLCJhcmdfMDA5IiwiYm5kc18wMDMiLCJhcmdfMDA3IiwiYm5kc18wMDMkMCIsImJuZHNfMDAzJDEiLCJ4XzAxMCIsImF0XzAwNCIsIm1haW5fMDAyIiwiYWxhcm1fMDA2IiwiY2xvY2tfMDA4IiwiYm5kc18wMDEkMSIsImJuZHNfMDAxJDIiLCJpbnRlcnZhbCIsImludGVydmFsJDAiLCJpbnRlcnZhbF8wMDYiLCJiYXNlXzAwNCIsImFsYXJtXzAwOCIsImNsb2NrXzAxMCIsImFyZ18wMTEiLCJibmRzXzAwMSQzIiwiaW50ZXJ2YWxfZnVuIiwiYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzIiwic2V0X2FsbF9ub2Rlc19jcmVhdGVkX29uX3JocyIsInJoc19zY29wZSIsInNldF9yaHNfc2NvcGUiLCJsaHNfY2hhbmdlIiwiYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzJDAiLCJyaHNfc2NvcGUkMCIsImxoc19jaGFuZ2UkMCIsIm9mX2JfMDAyIiwibWFpbl8wMDQiLCJsaHNfY2hhbmdlXzAxMCIsImxoc18wMDgiLCJyaHNfMDEyIiwicmhzX3Njb3BlXzAxNCIsImFsbF9ub2Rlc19jcmVhdGVkX29uX3Joc18wMTYiLCJibmRzXzAwMyQyIiwiYm5kc18wMDMkMyIsImJuZHNfMDAzJDQiLCJibmRzXzAwMyQ1Iiwic2FtZSIsIml0ZXJfbm9kZXNfY3JlYXRlZF9vbl9yaHMiLCJtYXRjaCIsImludmFyaWFudF9iIiwiYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzX2Z1biIsIm5vZGUiLCJyaHNfc2NvcGVfZnVuIiwibGhzX2NoYW5nZV9mdW4iLCJ4XzAxOCIsInBvcyQwIiwicG9zJDEiLCJzZXhwX29mX2VkZ2UiLCJjaGlsZF8wMDMiLCJpbmRleF8wMDciLCJzZXhwX29mX3BhY2tlZF9lZGdlIiwicmVzMF8wMTAiLCJvZl9hXzAxMSIsImNoaWxkcmVuXzAxNyIsIm51bV9jaGlsZHJlbl8wMTkiLCJmb3JjZV9zdGFsZV8wMjEiLCJudW1faW52YWxpZF9jaGlsZHJlbl8wMjMiLCJ3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrc18wMjUiLCJhcmdfMDI2IiwiYm5kc18wMTIiLCJibmRzXzAxMiQwIiwiYm5kc18wMTIkMSIsImJuZHNfMDEyJDIiLCJibmRzXzAxMiQzIiwiYXJnXzAxNiIsImJuZHNfMDEyJDQiLCJhcmdfMDE0IiwiYm5kc18wMTIkNSIsIm51bV9jaGlsZHJlbiIsInVvcHQiLCJhXzAyNyIsImJfMDI4IiwiaW52YXJpYW50X2Fib3V0X251bV9pbnZhbGlkX2NoIiwibnVtX2ludmFsaWRfY2hpbGRyZW4iLCJzZXhwaWZpZXIkMCIsImV4cGVjdCQwIiwiZXF1YWwkMCIsIm1lc3NhZ2UkMCIsImhlcmUkMCIsImNvbXBhcmF0b3IkMCIsImNvdW50X2ludmFsaWRfY2hpbGRyZW4iLCJhXzAzMSIsImJfMDMyIiwib25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UiLCJtYWtlX3N0YWxlIiwiaW5jcl9pbnZhbGlkX2NoaWxkcmVuIiwiZGVjcl9pbnZhbGlkX2NoaWxkcmVuIiwiYWRkX2NoaWxkX2VkZ2UiLCJwYWNrZWRfZWRnZSIsIm5ld19tYXgiLCJuZXdfY2hpbGRfaW5kZXgiLCJzd2FwX2NoaWxkcmVuIiwiY2hpbGRfaW5kZXgxIiwiY2hpbGRfaW5kZXgyIiwiZWRnZTEiLCJsYXN0X2NoaWxkX2VkZ2VfZXhuIiwibGFzdF9pbmRleCIsInJlbW92ZV9sYXN0X2NoaWxkX2VkZ2VfZXhuIiwicGFja2VkX2VkZ2Vfb3B0IiwiYmVmb3JlX21haW5fY29tcHV0YXRpb24iLCJ3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyIsIm9ic2VydmFiaWxpdHlfY2hhbmdlIiwiaXNfbm93X29ic2VydmFibGUiLCJydW5fZWRnZV9jYWxsYmFjayIsInRvcCIsImlzX3RvcCIsImhlaWdodCIsImFkZF9ub2RlIiwiY3VycmVudF9icmFuY2giLCJzZXRfY3VycmVudF9icmFuY2giLCJ0ZXN0X2NoYW5nZSIsImN1cnJlbnRfYnJhbmNoJDAiLCJ0ZXN0X2NoYW5nZSQwIiwidGVzdF9jaGFuZ2VfMDA3IiwidGVzdF8wMDUiLCJjdXJyZW50X2JyYW5jaF8wMDkiLCJlbHNlXzAxMyIsInRoZW5fMDExIiwiY3VycmVudF9icmFuY2hfZnVuIiwidGVzdF9jaGFuZ2VfZnVuIiwieF8wMTUiLCJsaHNfY2hhbmdlXzAwNyIsImxoc18wMDUiLCJyaHNfMDA5IiwiYmVmb3JlIiwiYmVmb3JlJDAiLCJjbG9ja18wMTEiLCJ2YWx1ZV9hdF8wMDkiLCJiZWZvcmVfMDA3IiwiYXRfMDA1IiwiYmVmb3JlX2Z1biIsInhfMDEzIiwiYXJnMF8wMDIiLCJhcmcwXzAwNCIsImFyZzBfMDA2IiwiYXJnMF8wMDgiLCJyZXMwXzAwOSIsInJlczBfMDEzIiwiYXJnMF8wMTQiLCJhcmcwXzAxNiIsInJlczBfMDE3IiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwiYXJnMF8wMjQiLCJyZXMwXzAyNSIsImFyZzFfMDI3IiwicmVzMF8wMjgiLCJyZXMxXzAyOSIsImFyZzBfMDMwIiwicmVzMF8wMzEiLCJhcmcwXzAzMiIsInJlczBfMDMzIiwiYXJnMF8wMzQiLCJyZXMwXzAzNSIsImFyZzBfMDM2IiwicmVzMF8wMzciLCJhcmcyXzA0MCIsImFyZzFfMDM5IiwicmVzMF8wNDEiLCJyZXMxXzA0MiIsInJlczJfMDQzIiwiYXJnM18wNDciLCJhcmcyXzA0NiIsImFyZzFfMDQ1IiwicmVzMF8wNDgiLCJyZXMxXzA0OSIsInJlczJfMDUwIiwicmVzM18wNTEiLCJhcmc0XzA1NiIsImFyZzNfMDU1IiwiYXJnMl8wNTQiLCJhcmcxXzA1MyIsInJlczBfMDU3IiwicmVzMV8wNTgiLCJyZXMyXzA1OSIsInJlczNfMDYwIiwicmVzNF8wNjEiLCJhcmc1XzA2NyIsImFyZzRfMDY2IiwiYXJnM18wNjUiLCJhcmcyXzA2NCIsImFyZzFfMDYzIiwicmVzMF8wNjgiLCJyZXMxXzA2OSIsInJlczJfMDcwIiwicmVzM18wNzEiLCJyZXM0XzA3MiIsInJlczVfMDczIiwiYXJnNl8wODAiLCJhcmc1XzA3OSIsImFyZzRfMDc4IiwiYXJnM18wNzciLCJhcmcyXzA3NiIsImFyZzFfMDc1IiwicmVzMF8wODEiLCJyZXMxXzA4MiIsInJlczJfMDgzIiwicmVzM18wODQiLCJyZXM0XzA4NSIsInJlczVfMDg2IiwicmVzNl8wODciLCJhcmc3XzA5NSIsImFyZzZfMDk0IiwiYXJnNV8wOTMiLCJhcmc0XzA5MiIsImFyZzNfMDkxIiwiYXJnMl8wOTAiLCJhcmcxXzA4OSIsInJlczBfMDk2IiwicmVzMV8wOTciLCJyZXMyXzA5OCIsInJlczNfMDk5IiwicmVzNF8xMDAiLCJyZXM1XzEwMSIsInJlczZfMTAyIiwicmVzN18xMDMiLCJhcmc4XzExMiIsImFyZzdfMTExIiwiYXJnNl8xMTAiLCJhcmc1XzEwOSIsImFyZzRfMTA4IiwiYXJnM18xMDciLCJhcmcyXzEwNiIsImFyZzFfMTA1IiwicmVzMF8xMTMiLCJyZXMxXzExNCIsInJlczJfMTE1IiwicmVzM18xMTYiLCJyZXM0XzExNyIsInJlczVfMTE4IiwicmVzNl8xMTkiLCJyZXM3XzEyMCIsInJlczhfMTIxIiwiYXJnOV8xMzEiLCJhcmc4XzEzMCIsImFyZzdfMTI5IiwiYXJnNl8xMjgiLCJhcmc1XzEyNyIsImFyZzRfMTI2IiwiYXJnM18xMjUiLCJhcmcyXzEyNCIsImFyZzFfMTIzIiwicmVzMF8xMzIiLCJyZXMxXzEzMyIsInJlczJfMTM0IiwicmVzM18xMzUiLCJyZXM0XzEzNiIsInJlczVfMTM3IiwicmVzNl8xMzgiLCJyZXM3XzEzOSIsInJlczhfMTQwIiwicmVzOV8xNDEiLCJhcmcxMF8xNTIiLCJhcmc5XzE1MSIsImFyZzhfMTUwIiwiYXJnN18xNDkiLCJhcmc2XzE0OCIsImFyZzVfMTQ3IiwiYXJnNF8xNDYiLCJhcmczXzE0NSIsImFyZzJfMTQ0IiwiYXJnMV8xNDMiLCJyZXMwXzE1MyIsInJlczFfMTU0IiwicmVzMl8xNTUiLCJyZXMzXzE1NiIsInJlczRfMTU3IiwicmVzNV8xNTgiLCJyZXM2XzE1OSIsInJlczdfMTYwIiwicmVzOF8xNjEiLCJyZXM5XzE2MiIsInJlczEwXzE2MyIsImFyZzExXzE3NSIsImFyZzEwXzE3NCIsImFyZzlfMTczIiwiYXJnOF8xNzIiLCJhcmc3XzE3MSIsImFyZzZfMTcwIiwiYXJnNV8xNjkiLCJhcmc0XzE2OCIsImFyZzNfMTY3IiwiYXJnMl8xNjYiLCJhcmcxXzE2NSIsInJlczBfMTc2IiwicmVzMV8xNzciLCJyZXMyXzE3OCIsInJlczNfMTc5IiwicmVzNF8xODAiLCJyZXM1XzE4MSIsInJlczZfMTgyIiwicmVzN18xODMiLCJyZXM4XzE4NCIsInJlczlfMTg1IiwicmVzMTBfMTg2IiwicmVzMTFfMTg3IiwiYXJnMTJfMjAwIiwiYXJnMTFfMTk5IiwiYXJnMTBfMTk4IiwiYXJnOV8xOTciLCJhcmc4XzE5NiIsImFyZzdfMTk1IiwiYXJnNl8xOTQiLCJhcmc1XzE5MyIsImFyZzRfMTkyIiwiYXJnM18xOTEiLCJhcmcyXzE5MCIsImFyZzFfMTg5IiwicmVzMF8yMDEiLCJyZXMxXzIwMiIsInJlczJfMjAzIiwicmVzM18yMDQiLCJyZXM0XzIwNSIsInJlczVfMjA2IiwicmVzNl8yMDciLCJyZXM3XzIwOCIsInJlczhfMjA5IiwicmVzOV8yMTAiLCJyZXMxMF8yMTEiLCJyZXMxMV8yMTIiLCJyZXMxMl8yMTMiLCJhcmcxM18yMjciLCJhcmcxMl8yMjYiLCJhcmcxMV8yMjUiLCJhcmcxMF8yMjQiLCJhcmc5XzIyMyIsImFyZzhfMjIyIiwiYXJnN18yMjEiLCJhcmc2XzIyMCIsImFyZzVfMjE5IiwiYXJnNF8yMTgiLCJhcmczXzIxNyIsImFyZzJfMjE2IiwiYXJnMV8yMTUiLCJyZXMwXzIyOCIsInJlczFfMjI5IiwicmVzMl8yMzAiLCJyZXMzXzIzMSIsInJlczRfMjMyIiwicmVzNV8yMzMiLCJyZXM2XzIzNCIsInJlczdfMjM1IiwicmVzOF8yMzYiLCJyZXM5XzIzNyIsInJlczEwXzIzOCIsInJlczExXzIzOSIsInJlczEyXzI0MCIsInJlczEzXzI0MSIsImFyZzE0XzI1NiIsImFyZzEzXzI1NSIsImFyZzEyXzI1NCIsImFyZzExXzI1MyIsImFyZzEwXzI1MiIsImFyZzlfMjUxIiwiYXJnOF8yNTAiLCJhcmc3XzI0OSIsImFyZzZfMjQ4IiwiYXJnNV8yNDciLCJhcmc0XzI0NiIsImFyZzNfMjQ1IiwiYXJnMl8yNDQiLCJhcmcxXzI0MyIsInJlczBfMjU3IiwicmVzMV8yNTgiLCJyZXMyXzI1OSIsInJlczNfMjYwIiwicmVzNF8yNjEiLCJyZXM1XzI2MiIsInJlczZfMjYzIiwicmVzN18yNjQiLCJyZXM4XzI2NSIsInJlczlfMjY2IiwicmVzMTBfMjY3IiwicmVzMTFfMjY4IiwicmVzMTJfMjY5IiwicmVzMTNfMjcwIiwicmVzMTRfMjcxIiwiYXJnMTVfMjg3IiwiYXJnMTRfMjg2IiwiYXJnMTNfMjg1IiwiYXJnMTJfMjg0IiwiYXJnMTFfMjgzIiwiYXJnMTBfMjgyIiwiYXJnOV8yODEiLCJhcmc4XzI4MCIsImFyZzdfMjc5IiwiYXJnNl8yNzgiLCJhcmc1XzI3NyIsImFyZzRfMjc2IiwiYXJnM18yNzUiLCJhcmcyXzI3NCIsImFyZzFfMjczIiwicmVzMF8yODgiLCJyZXMxXzI4OSIsInJlczJfMjkwIiwicmVzM18yOTEiLCJyZXM0XzI5MiIsInJlczVfMjkzIiwicmVzNl8yOTQiLCJyZXM3XzI5NSIsInJlczhfMjk2IiwicmVzOV8yOTciLCJyZXMxMF8yOTgiLCJyZXMxMV8yOTkiLCJyZXMxMl8zMDAiLCJyZXMxM18zMDEiLCJyZXMxNF8zMDIiLCJyZXMxNV8zMDMiLCJhcnJheV9mb2xkIiwiYXQiLCJhdF9pbnRlcnZhbHMiLCJiaW5kJDAiLCJlIiwiZnJlZXplIiwiaWZfdGhlbl9lbHNlIiwiaWZfdGhlbl9lbHNlJDAiLCJqb2luIiwiam9pbiQwIiwic25hcHNob3QiLCJzdGVwX2Z1bmN0aW9uX25vZGUiLCJ1bm9yZGVyZWRfYXJyYXlfZm9sZCIsInZhciQwIiwiaW5pdGlhbF9udW1fY2hpbGRyZW4iLCJiaW5kX3Joc19jaGlsZF9pbmRleCIsImZyZWV6ZV9jaGlsZF9pbmRleCIsImlmX2JyYW5jaF9jaGlsZF9pbmRleCIsImpvaW5fcmhzX2NoaWxkX2luZGV4IiwiaXRlcmlfY2hpbGRyZW4iLCJyaHMiLCJpJDAiLCJ0ZXN0IiwibGhzIiwicmhzJDAiLCJub2RlMCIsImNoaWxkJDAiLCJjaGlsZHJlbiQxIiwiaSQxIiwibm9kZTEiLCJub2RlMCQwIiwibm9kZTIiLCJub2RlMSQwIiwibm9kZTAkMSIsIm5vZGUzIiwibm9kZTIkMCIsIm5vZGUxJDEiLCJub2RlMCQyIiwibm9kZTQiLCJub2RlMyQwIiwibm9kZTIkMSIsIm5vZGUxJDIiLCJub2RlMCQzIiwibm9kZTUiLCJub2RlNCQwIiwibm9kZTMkMSIsIm5vZGUyJDIiLCJub2RlMSQzIiwibm9kZTAkNCIsIm5vZGU2Iiwibm9kZTUkMCIsIm5vZGU0JDEiLCJub2RlMyQyIiwibm9kZTIkMyIsIm5vZGUxJDQiLCJub2RlMCQ1Iiwibm9kZTciLCJub2RlNiQwIiwibm9kZTUkMSIsIm5vZGU0JDIiLCJub2RlMyQzIiwibm9kZTIkNCIsIm5vZGUxJDUiLCJub2RlMCQ2Iiwibm9kZTgiLCJub2RlNyQwIiwibm9kZTYkMSIsIm5vZGU1JDIiLCJub2RlNCQzIiwibm9kZTMkNCIsIm5vZGUyJDUiLCJub2RlMSQ2Iiwibm9kZTAkNyIsIm5vZGU5Iiwibm9kZTgkMCIsIm5vZGU3JDEiLCJub2RlNiQyIiwibm9kZTUkMyIsIm5vZGU0JDQiLCJub2RlMyQ1Iiwibm9kZTIkNiIsIm5vZGUxJDciLCJub2RlMCQ4Iiwibm9kZTEwIiwibm9kZTkkMCIsIm5vZGU4JDEiLCJub2RlNyQyIiwibm9kZTYkMyIsIm5vZGU1JDQiLCJub2RlNCQ1Iiwibm9kZTMkNiIsIm5vZGUyJDciLCJub2RlMSQ4Iiwibm9kZTAkOSIsIm5vZGUxMSIsIm5vZGUxMCQwIiwibm9kZTkkMSIsIm5vZGU4JDIiLCJub2RlNyQzIiwibm9kZTYkNCIsIm5vZGU1JDUiLCJub2RlNCQ2Iiwibm9kZTMkNyIsIm5vZGUyJDgiLCJub2RlMSQ5Iiwibm9kZTAkMTAiLCJub2RlMTIiLCJub2RlMTEkMCIsIm5vZGUxMCQxIiwibm9kZTkkMiIsIm5vZGU4JDMiLCJub2RlNyQ0Iiwibm9kZTYkNSIsIm5vZGU1JDYiLCJub2RlNCQ3Iiwibm9kZTMkOCIsIm5vZGUyJDkiLCJub2RlMSQxMCIsIm5vZGUwJDExIiwibm9kZTEzIiwibm9kZTEyJDAiLCJub2RlMTEkMSIsIm5vZGUxMCQyIiwibm9kZTkkMyIsIm5vZGU4JDQiLCJub2RlNyQ1Iiwibm9kZTYkNiIsIm5vZGU1JDciLCJub2RlNCQ4Iiwibm9kZTMkOSIsIm5vZGUyJDEwIiwibm9kZTEkMTEiLCJub2RlMCQxMiIsIm5vZGUxNCIsIm5vZGUxMyQwIiwibm9kZTEyJDEiLCJub2RlMTEkMiIsIm5vZGUxMCQzIiwibm9kZTkkNCIsIm5vZGU4JDUiLCJub2RlNyQ2Iiwibm9kZTYkNyIsIm5vZGU1JDgiLCJub2RlNCQ5Iiwibm9kZTMkMTAiLCJub2RlMiQxMSIsIm5vZGUxJDEyIiwibm9kZTAkMTMiLCJzbG93X2dldF9jaGlsZCIsImluZGV4IiwiYXJnMV8zMDYiLCJhcmcwXzMwNSIsInJlczBfMzA3IiwicmVzMV8zMDgiLCJwb3MkNCIsInBvcyQzIiwicG9zJDIiLCJteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW4iLCJzZXRfbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2EiLCJteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW4iLCJzZXRfbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2EiLCJvYnNlcnZlcnMiLCJzZXRfb2JzZXJ2ZXJzIiwic2V0X29sZF92YWx1ZV9vcHQiLCJuZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAiLCJzZXRfbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWEiLCJoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCIsInNldF9oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaCIsIm5leHRfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCIsInByZXZfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfcHJldl9pbl9yZWNvbXB1dGVfaGVhcCIsImhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCIsInNldF9oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfaGVpZ2h0IiwibmV4dF9ub2RlX2luX3NhbWVfc2NvcGUiLCJzZXRfbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUiLCJjcmVhdGVkX2luIiwic2V0X2NyZWF0ZWRfaW4iLCJwYXJlbnQwIiwic2V0X3BhcmVudDAiLCJwYXJlbnQxX2FuZF9iZXlvbmQiLCJzZXRfcGFyZW50MV9hbmRfYmV5b25kIiwibnVtX3BhcmVudHMiLCJzZXRfbnVtX3BhcmVudHMiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzIiwic2V0X251bV9vbl91cGRhdGVfaGFuZGxlcnMiLCJjaGFuZ2VkX2F0Iiwic2V0X2NoYW5nZWRfYXQiLCJjdXRvZmYiLCJzZXRfY3V0b2ZmIiwia2luZCIsInNldF9raW5kIiwidmFsdWVfb3B0Iiwic2V0X3ZhbHVlX29wdCIsInJlY29tcHV0ZWRfYXQiLCJzZXRfcmVjb21wdXRlZF9hdCIsImlkIiwibXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luJDAiLCJteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW4kMCIsIm9ic2VydmVycyQwIiwib2xkX3ZhbHVlX29wdCQwIiwibmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwJDAiLCJoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCQwIiwibmV4dF9pbl9yZWNvbXB1dGVfaGVhcCQwIiwicHJldl9pbl9yZWNvbXB1dGVfaGVhcCQwIiwiaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwJDAiLCJoZWlnaHQkMCIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlJDAiLCJjcmVhdGVkX2luJDAiLCJwYXJlbnQwJDAiLCJwYXJlbnQxX2FuZF9iZXlvbmQkMCIsIm51bV9wYXJlbnRzJDAiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzJDAiLCJjaGFuZ2VkX2F0JDAiLCJjdXRvZmYkMCIsImtpbmQkMCIsInZhbHVlX29wdCQwIiwicmVjb21wdXRlZF9hdCQwIiwiaWQkMCIsInN0YXRlXzAwNSIsImlkXzAwMyIsInJlY29tcHV0ZWRfYXRfMDA3IiwidmFsdWVfb3B0XzAwOSIsImtpbmRfMDExIiwiY3V0b2ZmXzAxMyIsImNoYW5nZWRfYXRfMDE1IiwibnVtX29uX3VwZGF0ZV9oYW5kbGVyc18wMTciLCJudW1fcGFyZW50c18wMTkiLCJwYXJlbnQxX2FuZF9iZXlvbmRfMDIxIiwicGFyZW50MF8wMjMiLCJjcmVhdGVkX2luXzAyNSIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXzAyNyIsImhlaWdodF8wMjkiLCJoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBfMDMxIiwicHJldl9pbl9yZWNvbXB1dGVfaGVhcF8wMzMiLCJuZXh0X2luX3JlY29tcHV0ZV9oZWFwXzAzNSIsImhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXyIsIm5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcF8wMyIsIm9sZF92YWx1ZV9vcHRfMDQxIiwib2JzZXJ2ZXJzXzA0MyIsImlzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aSIsIm9uX3VwZGF0ZV9oYW5kbGVyc18wNDciLCJmb3JjZV9uZWNlc3NhcnlfMDUzIiwidXNlcl9pbmZvXzA1NSIsImNyZWF0aW9uX2JhY2t0cmFjZV8wNTciLCJhcmdfMDU4IiwiYXJnXzA1NiIsImFyZ18wNTQiLCJhcmdfMDUyIiwiYXJnXzA1MCIsImFyZ18wNDgiLCJhcmdfMDQ2IiwiYXJnXzA0NCIsImFyZ18wNDIiLCJibmRzXzAwMiQ3IiwiYXJnXzA0MCIsImJuZHNfMDAyJDgiLCJhcmdfMDM4IiwiYm5kc18wMDIkOSIsImFyZ18wMzYiLCJibmRzXzAwMiQxMCIsImFyZ18wMzQiLCJibmRzXzAwMiQxMSIsImFyZ18wMzIiLCJibmRzXzAwMiQxMiIsImFyZ18wMzAiLCJibmRzXzAwMiQxMyIsImFyZ18wMjgiLCJibmRzXzAwMiQxNCIsImJuZHNfMDAyJDE1IiwiYm5kc18wMDIkMTYiLCJibmRzXzAwMiQxNyIsImJuZHNfMDAyJDE4IiwiYm5kc18wMDIkMTkiLCJibmRzXzAwMiQyMCIsImJuZHNfMDAyJDIxIiwiYm5kc18wMDIkMjIiLCJibmRzXzAwMiQyMyIsImJuZHNfMDAyJDI0IiwiYm5kc18wMDIkMjUiLCJibmRzXzAwMiQyNiIsInBhY2tlZF9zYW1lIiwidXNlcl9pbmZvIiwib3RoZXIiLCJzZXRfdXNlcl9pbmZvIiwiYXBwZW5kX3VzZXJfaW5mb19ncmFwaHZpeiIsImF0dHJzIiwiZWRnZV9pc19zdGFsZSIsInBhcmVudCIsImlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaSIsImlzX3N0YWxlIiwiZm9yY2Vfc3RhbGUiLCJmb3JjZV9zdGFsZSQwIiwibmVlZHNfdG9fYmVfY29tcHV0ZWQiLCJpc19pbl9yZWNvbXB1dGVfaGVhcCIsImlzX2luX2FkanVzdF9oZWlnaHRzX2hlYXAiLCJnZXRfcGFyZW50IiwiaXRlcmlfcGFyZW50cyIsImhhc19jaGlsZCIsImhhcyIsImhhc19wYXJlbnQiLCJwYXJlbnQkMCIsInNob3VsZF9iZV9pbnZhbGlkYXRlZCIsImxocyQwIiwiZm9sZF9vYnNlcnZlcnMiLCJhYyIsIm9ic2VydmVyIiwiYV8wNjAiLCJiXzA2MSIsImFfMDcwIiwiYl8wNzEiLCJwYXJlbnRfaW5kZXgiLCJ4IiwiYV8wNjgiLCJiXzA2OSIsIm9ic2VydmVyc19mdW4iLCJzdGF0ZSIsIm9ic2VydmluZyIsIm9sZF92YWx1ZV9vcHRfZnVuIiwibmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwX2Z1IiwibmV4dF9pbl9yZWNvbXB1dGVfaGVhcF9mdW4iLCJwcmV2X2luX3JlY29tcHV0ZV9oZWFwX2Z1biIsInByZXYiLCJoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBfZnVuIiwiaGVpZ2h0X2Z1biIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlX2Z1biIsImNyZWF0ZWRfaW5fZnVuIiwicGFyZW50MF9mdW4iLCJhXzA2NiIsImJfMDY3IiwicGFyZW50MV9hbmRfYmV5b25kX2Z1biIsImFfMDY0IiwiYl8wNjUiLCJudW1fcGFyZW50c19mdW4iLCJvbl91cGRhdGVfaGFuZGxlcnMiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzX2Z1biIsImV0YSIsImFfMDYyIiwiYl8wNjMiLCJjaGFuZ2VkX2F0X2Z1biIsImN1dG9mZl9mdW4iLCJraW5kX2Z1biIsInZhbHVlX29wdF9mdW4iLCJyZWNvbXB1dGVkX2F0X2Z1biIsImlkX2Z1biIsInhfMDU5IiwidW5zYWZlX3ZhbHVlIiwidmFsdWVfZXhuIiwieF8wNzIiLCJnZXRfY3V0b2ZmIiwic2V0X2N1dG9mZiQwIiwiaXNfY29uc3QiLCJvbl91cGRhdGUiLCJvbl91cGRhdGVfaGFuZGxlciIsInJ1bl9vbl91cGRhdGVfaGFuZGxlcnMiLCJyZXN0JDAiLCJvbl91cGRhdGVfaGFuZGxlciQwIiwiciQwIiwiciQxIiwicmVzdCIsInNldF9raW5kJDAiLCJtYXhfbnVtX3BhcmVudHMiLCJzZXRfcGFyZW50IiwibGluayIsImFkZF9wYXJlbnQiLCJuZXdfbWF4X251bV9wYXJlbnRzIiwibWF4X251bV9jaGlsZHJlbiIsIm5ld19tYXhfbnVtX2NoaWxkcmVuIiwicmVtb3ZlX3BhcmVudCIsImxhc3RfcGFyZW50X2luZGV4Iiwic3dhcF9jaGlsZHJlbl9leGNlcHRfaW5fa2luZCIsImNoaWxkMSIsImNoaWxkMiIsImluZGV4X29mX3BhcmVudF9pbl9jaGlsZDEiLCJpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQyIiwieF8wNzMiLCJpbnZhcmlhbnQkMCIsIml0ZXJfZGVzY2VuZGFudHNfaW50ZXJuYWwiLCJ0cyIsInNlZW4iLCJpdGVyX2Rlc2NlbmRhbnRzIiwiYXBwZW5kX3VzZXJfaW5mb19ncmFwaHZpeiQwIiwic2F2ZV9kb3QiLCJvdXQiLCJub2RlX25hbWUiLCJiaW5kX2VkZ2VzIiwiZGVmYXVsdCQwIiwiZnJvbSIsInNhdmVfZG90X3RvX2ZpbGUiLCJmaWxlIiwiZm9sZCIsInBhY2tlZF9ub2RlIiwiaXRlciIsImxlbmd0aCIsInhfMDc0Iiwibm9kZXNfYnlfaGVpZ2h0Iiwic2V0X25vZGVzX2J5X2hlaWdodCIsImhlaWdodF9sb3dlcl9ib3VuZCIsInNldF9oZWlnaHRfbG93ZXJfYm91bmQiLCJzZXRfbGVuZ3RoIiwibm9kZXNfYnlfaGVpZ2h0JDAiLCJoZWlnaHRfbG93ZXJfYm91bmQkMCIsImxlbmd0aCQwIiwibGVuZ3RoXzAwMyIsImhlaWdodF9sb3dlcl9ib3VuZF8wMDUiLCJub2Rlc19ieV9oZWlnaHRfMDA3IiwibWF4X25vbmVtcHR5X2luZGV4IiwibCIsIm1heF9oZWlnaHRfYWxsb3dlZCIsIm5vZGVzX2J5X2hlaWdodF9mdW4iLCJoZWlnaHRfbG93ZXJfYm91bmRfZnVuIiwibGVuZ3RoX2Z1biIsImFjdHVhbF9sZW5ndGgiLCJhXzAwOSIsImJfMDEwIiwiY3JlYXRlX25vZGVzX2J5X2hlaWdodCIsInNldF9tYXhfaGVpZ2h0X2FsbG93ZWQiLCJzcmMiLCJkc3QiLCJzZXRfcHJldiIsInVubGluayIsImFkZCIsInJlbW92ZSIsInhfMDEyIiwiaW5jcmVhc2VfaGVpZ2h0IiwibWluX2hlaWdodCIsInJlbW92ZV9taW4iLCJub2RlJDAiLCJub2RlcyIsIm1heF9oZWlnaHRfc2VlbiIsInNldF9tYXhfaGVpZ2h0X3NlZW4iLCJtYXhfaGVpZ2h0X3NlZW4kMCIsIm1heF9oZWlnaHRfc2Vlbl8wMDciLCJub2Rlc19ieV9oZWlnaHRfMDA5IiwiaXNfZW1wdHkiLCJtYXhfaGVpZ2h0X3NlZW5fZnVuIiwiY3JlYXRlJDAiLCJ2XzAxMSIsImFyZzFfMDE5Iiwidl8wMTYiLCJyZXMwXzAyMCIsInZfMDE3IiwicmVzMV8wMjEiLCJlbnN1cmVfaGVpZ2h0X3JlcXVpcmVtZW50Iiwib3JpZ2luYWxfY2hpbGQiLCJvcmlnaW5hbF9wYXJlbnQiLCJhcmcxXzAyNSIsInZfMDIyIiwicmVzMF8wMjYiLCJ2XzAyMyIsInJlczFfMDI3IiwiYWRqdXN0X2hlaWdodHMiLCJyZWNvbXB1dGVfaGVhcCIsIm5vZGVfb25fcmhzIiwiYWN0aW9uIiwiYWN0aW9uJDAiLCJhY3Rpb25fMDEwIiwibmV4dF9maXJlZF8wMTIiLCJibmRzXzAwOSIsInJlczBfMDAyIiwiYXJnMF8wMDMiLCJhcmcwXzAwNSIsImFyZzBfMDA3IiwicmVzMF8wMDgiLCJibmRzXzAwOSQwIiwiYWN0aW9uX2Z1biIsIm5leHRfaW5fYWxsIiwic2V0X3ByZXZfaW5fYWxsIiwibmV4dF9pbl9vYnNlcnZpbmciLCJzZXRfbmV4dF9pbl9vYnNlcnZpbmciLCJwcmV2X2luX29ic2VydmluZyIsInNldF9wcmV2X2luX29ic2VydmluZyIsIm5leHRfaW5fYWxsJDAiLCJzZXRfbmV4dF9pbl9hbGwiLCJwcmV2X2luX2FsbCIsInNldF9wcmV2X2luX2FsbCQwIiwic2V0X29uX3VwZGF0ZV9oYW5kbGVycyIsIm5leHRfaW5fb2JzZXJ2aW5nJDAiLCJwcmV2X2luX29ic2VydmluZyQwIiwibmV4dF9pbl9hbGwkMSIsInByZXZfaW5fYWxsJDAiLCJvbl91cGRhdGVfaGFuZGxlcnMkMCIsIm9ic2VydmluZyQwIiwic2V4cF9vZl9pbnRlcm5hbF9vYnNlcnZlciIsIm9mX2FfMDAyIiwic3RhdGVfMDA0Iiwib2JzZXJ2aW5nXzAwNiIsIm9uX3VwZGF0ZV9oYW5kbGVyc18wMDgiLCJwcmV2X2luX2FsbF8wMTAiLCJuZXh0X2luX2FsbF8wMTIiLCJwcmV2X2luX29ic2VydmluZ18wMTQiLCJuZXh0X2luX29ic2VydmluZ18wMTYiLCJ1c2VfaXNfYWxsb3dlZCIsInNhbWVfYXNfcGFja2VkIiwibmV4dF9pbl9vYnNlcnZpbmdfZnVuIiwicHJldl9pbl9vYnNlcnZpbmdfZnVuIiwibmV4dF9pbl9hbGxfZnVuIiwicHJldl9pbl9hbGxfZnVuIiwib25fdXBkYXRlX2hhbmRsZXJzX2Z1biIsIm9ic2VydmluZ19mdW4iLCJ4XzAyMCIsInhfMDIyIiwieF8wMjEiLCJvbl91cGRhdGVfZXhuIiwieF8wMjQiLCJwcmV2JDAiLCJuZXh0JDAiLCJ4XzAyNSIsInhfMDAyIiwibmFtZXMiLCJuYW1lcyQwIiwibmFtZXMkMSIsImVycm9yX3NvdXJjZV8wOTUiLCJzZXhwX29mX3N0YXR1cyIsImFyZzFfMDA0IiwicmVzMV8wMDYiLCJleHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW4iLCJzZXRfZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3UiLCJjdXJyZW50bHlfcnVubmluZ19ub2RlIiwic2V0X2N1cnJlbnRseV9ydW5uaW5nX25vZGUiLCJleHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW4kMCIsImN1cnJlbnRseV9ydW5uaW5nX25vZGUkMCIsIm1ha2VfY3JlYXRvciIsImN1cnJlbnRseV9ydW5uaW5nX25vZGVfZnVuIiwiY29tcGlsZV9hY2MiLCJjb21waWxlX2FjYyQwIiwiY3VycmVudGx5X3J1bm5pbmdfbm9kZV9nZW4iLCJjb21waWxlX2FjYyQxIiwiZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVuJDEiLCJhY2MiLCJtYXAiLCJtYXBfcG9seSIsInJlY29yZCIsImZvcl9hbGwiLCJleGlzdHMiLCJ0b19saXN0IiwiaXRlciQwIiwiZm9sZCQwIiwiZm9yX2FsbCQwIiwiZXhpc3RzJDAiLCJ0b19saXN0JDAiLCJtYXAkMCIsInNldF9hbGxfbXV0YWJsZV9maWVsZHMiLCJyZWNvcmQkMCIsImN1cnJlbnRseV9ydW5uaW5nX25vZGVfMDA4IiwiYm5kc18wMDciLCJibmRzXzAwNyQwIiwic2V4cF9vZl90JDEiLCJudW1fdmFyX3NldHMiLCJzZXRfbnVtX3Zhcl9zZXRzIiwibnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfIiwic2V0X251bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjIiwibnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfJDAiLCJzZXRfbnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWMkMCIsIm51bV9ub2Rlc19yZWNvbXB1dGVkIiwic2V0X251bV9ub2Rlc19yZWNvbXB1dGVkIiwibnVtX25vZGVzX2ludmFsaWRhdGVkIiwic2V0X251bV9ub2Rlc19pbnZhbGlkYXRlZCIsIm51bV9ub2Rlc19jcmVhdGVkIiwic2V0X251bV9ub2Rlc19jcmVhdGVkIiwibnVtX25vZGVzX2NoYW5nZWQiLCJzZXRfbnVtX25vZGVzX2NoYW5nZWQiLCJudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5Iiwic2V0X251bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhIiwibnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkiLCJzZXRfbnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkiLCJrZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYWNlIiwic2V0X2tlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhIiwid2Vha19oYXNodGJscyIsIm9ubHlfaW5fZGVidWciLCJzZXRfb25seV9pbl9kZWJ1ZyIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIiwic2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIiwiZGlzYWxsb3dlZF9vYnNlcnZlcnMiLCJuZXdfb2JzZXJ2ZXJzIiwiZmluYWxpemVkX29ic2VydmVycyIsImFsbF9vYnNlcnZlcnMiLCJzZXRfYWxsX29ic2VydmVycyIsIm51bV9hY3RpdmVfb2JzZXJ2ZXJzIiwic2V0X251bV9hY3RpdmVfb2JzZXJ2ZXJzIiwicHJvcGFnYXRlX2ludmFsaWRpdHkiLCJhZGp1c3RfaGVpZ2h0c19oZWFwIiwiY3VycmVudF9zY29wZSIsInNldF9jdXJyZW50X3Njb3BlIiwic3RhYmlsaXphdGlvbl9udW0iLCJzZXRfc3RhYmlsaXphdGlvbl9udW0iLCJiaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWQiLCJzdGF0dXMiLCJzZXRfc3RhdHVzIiwibnVtX3Zhcl9zZXRzJDAiLCJudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV8kMSIsIm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5XyQyIiwibnVtX25vZGVzX3JlY29tcHV0ZWQkMCIsIm51bV9ub2Rlc19pbnZhbGlkYXRlZCQwIiwibnVtX25vZGVzX2NyZWF0ZWQkMCIsIm51bV9ub2Rlc19jaGFuZ2VkJDAiLCJudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5JDAiLCJudW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeSQwIiwia2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZSQwIiwid2Vha19oYXNodGJscyQwIiwib25seV9pbl9kZWJ1ZyQwIiwicnVuX29uX3VwZGF0ZV9oYW5kbGVycyQwIiwiaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24kMCIsInNldF9kdXJpbmdfc3RhYmlsaXphdGlvbiQwIiwiZGlzYWxsb3dlZF9vYnNlcnZlcnMkMCIsIm5ld19vYnNlcnZlcnMkMCIsImZpbmFsaXplZF9vYnNlcnZlcnMkMCIsImFsbF9vYnNlcnZlcnMkMCIsIm51bV9hY3RpdmVfb2JzZXJ2ZXJzJDAiLCJwcm9wYWdhdGVfaW52YWxpZGl0eSQwIiwiYWRqdXN0X2hlaWdodHNfaGVhcCQwIiwicmVjb21wdXRlX2hlYXAkMCIsImN1cnJlbnRfc2NvcGUkMCIsInN0YWJpbGl6YXRpb25fbnVtJDAiLCJiaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWQkMCIsInN0YXR1cyQwIiwibWFrZV9jcmVhdG9yJDAiLCJzdGF0dXNfZnVuIiwic3RhYmlsaXphdGlvbl9udW1fZnVuIiwiY3VycmVudF9zY29wZV9mdW4iLCJyZWNvbXB1dGVfaGVhcF9mdW4iLCJhZGp1c3RfaGVpZ2h0c19oZWFwX2Z1biIsInByb3BhZ2F0ZV9pbnZhbGlkaXR5X2Z1biIsIm51bV9hY3RpdmVfb2JzZXJ2ZXJzX2Z1biIsImFsbF9vYnNlcnZlcnNfZnVuIiwiZmluYWxpemVkX29ic2VydmVyc19mdW4iLCJuZXdfb2JzZXJ2ZXJzX2Z1biIsImRpc2FsbG93ZWRfb2JzZXJ2ZXJzX2Z1biIsInNldF9kdXJpbmdfc3RhYmlsaXphdGlvbl9mdW4iLCJoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl9mdW4iLCJydW5fb25fdXBkYXRlX2hhbmRsZXJzX2Z1biIsIm9ubHlfaW5fZGVidWdfZnVuIiwid2Vha19oYXNodGJsc19mdW4iLCJrZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYWNlX2YiLCJudW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeV9mdW4iLCJudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5X2YiLCJudW1fbm9kZXNfY2hhbmdlZF9mdW4iLCJudW1fbm9kZXNfY3JlYXRlZF9mdW4iLCJudW1fbm9kZXNfaW52YWxpZGF0ZWRfZnVuIiwibnVtX25vZGVzX3JlY29tcHV0ZWRfZnVuIiwibnVtX3Zhcl9zZXRzX2Z1biIsInN0YXR1c19nZW4iLCJiaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWQkMSIsImNvbXBpbGVfYWNjJDIiLCJzdGFiaWxpemF0aW9uX251bV9nZW4iLCJjb21waWxlX2FjYyQzIiwiY3VycmVudF9zY29wZV9nZW4iLCJjb21waWxlX2FjYyQ0IiwicmVjb21wdXRlX2hlYXBfZ2VuIiwiY29tcGlsZV9hY2MkNSIsImFkanVzdF9oZWlnaHRzX2hlYXBfZ2VuIiwiY29tcGlsZV9hY2MkNiIsInByb3BhZ2F0ZV9pbnZhbGlkaXR5X2dlbiIsImNvbXBpbGVfYWNjJDciLCJudW1fYWN0aXZlX29ic2VydmVyc19nZW4iLCJjb21waWxlX2FjYyQ4IiwiYWxsX29ic2VydmVyc19nZW4iLCJjb21waWxlX2FjYyQ5IiwiZmluYWxpemVkX29ic2VydmVyc19nZW4iLCJjb21waWxlX2FjYyQxMCIsIm5ld19vYnNlcnZlcnNfZ2VuIiwiY29tcGlsZV9hY2MkMTEiLCJkaXNhbGxvd2VkX29ic2VydmVyc19nZW4iLCJjb21waWxlX2FjYyQxMiIsInNldF9kdXJpbmdfc3RhYmlsaXphdGlvbl9nZW4iLCJjb21waWxlX2FjYyQxMyIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uX2dlbiIsImNvbXBpbGVfYWNjJDE0IiwicnVuX29uX3VwZGF0ZV9oYW5kbGVyc19nZW4iLCJjb21waWxlX2FjYyQxNSIsIm9ubHlfaW5fZGVidWdfZ2VuIiwiY29tcGlsZV9hY2MkMTYiLCJ3ZWFrX2hhc2h0YmxzX2dlbiIsImNvbXBpbGVfYWNjJDE3Iiwia2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZV9nIiwiY29tcGlsZV9hY2MkMTgiLCJudW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeV9nZW4iLCJjb21waWxlX2FjYyQxOSIsIm51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnlfZyIsImNvbXBpbGVfYWNjJDIwIiwibnVtX25vZGVzX2NoYW5nZWRfZ2VuIiwiY29tcGlsZV9hY2MkMjEiLCJudW1fbm9kZXNfY3JlYXRlZF9nZW4iLCJjb21waWxlX2FjYyQyMiIsIm51bV9ub2Rlc19pbnZhbGlkYXRlZF9nZW4iLCJjb21waWxlX2FjYyQyMyIsIm51bV9ub2Rlc19yZWNvbXB1dGVkX2dlbiIsImNvbXBpbGVfYWNjJDI0IiwibnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfJDMiLCJjb21waWxlX2FjYyQyNSIsIm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5XyQ0IiwiY29tcGlsZV9hY2MkMjYiLCJudW1fdmFyX3NldHNfZ2VuIiwiY3JlYXRlJDEiLCJtYXAkMSIsIml0ZXIkMSIsImZvbGQkMSIsIm1hcF9wb2x5JDAiLCJmb3JfYWxsJDEiLCJleGlzdHMkMSIsInRvX2xpc3QkMSIsIml0ZXIkMiIsImZvbGQkMiIsImZvcl9hbGwkMiIsImV4aXN0cyQyIiwidG9fbGlzdCQyIiwibWFwJDIiLCJzZXRfYWxsX211dGFibGVfZmllbGRzJDAiLCJzZXhwX29mX3QkMiIsInN0YXR1c18wMTUiLCJzdGFiaWxpemF0aW9uX251bV8wMTkiLCJjdXJyZW50X3Njb3BlXzAyMSIsInByb3BhZ2F0ZV9pbnZhbGlkaXR5XzAyNyIsImFkanVzdF9oZWlnaHRzX2hlYXBfMDI1IiwicmVjb21wdXRlX2hlYXBfMDIzIiwibnVtX2FjdGl2ZV9vYnNlcnZlcnNfMDI5IiwiYWxsX29ic2VydmVyc18wMzEiLCJydW5fb25fdXBkYXRlX2hhbmRsZXJzXzA0MyIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXzA0MSIsInNldF9kdXJpbmdfc3RhYmlsaXphdGlvbl8wMzkiLCJkaXNhbGxvd2VkX29ic2VydmVyc18wMzciLCJuZXdfb2JzZXJ2ZXJzXzAzNSIsImZpbmFsaXplZF9vYnNlcnZlcnNfMDMzIiwib25seV9pbl9kZWJ1Z18wNDUiLCJ3ZWFrX2hhc2h0YmxzXzA0NyIsImtlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhY2VfMCIsIm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5XzA1MSIsIm51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnlfMCIsIm51bV9ub2Rlc19jaGFuZ2VkXzA1NSIsIm51bV9ub2Rlc19jcmVhdGVkXzA1NyIsIm51bV9ub2Rlc19pbnZhbGlkYXRlZF8wNTkiLCJudW1fbm9kZXNfcmVjb21wdXRlZF8wNjEiLCJudW1fdmFyX3NldHNfMDY3IiwiYXJnXzA2OCIsImJuZHNfMDE0IiwiYXJnXzA2NiIsImJuZHNfMDE0JDAiLCJhcmdfMDY0IiwiYm5kc18wMTQkMSIsImFyZ18wNjIiLCJibmRzXzAxNCQyIiwiYXJnXzA2MCIsImJuZHNfMDE0JDMiLCJibmRzXzAxNCQ0IiwiYm5kc18wMTQkNSIsImJuZHNfMDE0JDYiLCJibmRzXzAxNCQ3IiwiYm5kc18wMTQkOCIsImJuZHNfMDE0JDkiLCJibmRzXzAxNCQxMCIsImJuZHNfMDE0JDExIiwiYm5kc18wMTQkMTIiLCJibmRzXzAxNCQxMyIsImJuZHNfMDE0JDE0IiwiYm5kc18wMTQkMTUiLCJibmRzXzAxNCQxNiIsImJuZHNfMDE0JDE3IiwiYm5kc18wMTQkMTgiLCJibmRzXzAxNCQxOSIsImJuZHNfMDE0JDIwIiwiYm5kc18wMTQkMjEiLCJibmRzXzAxNCQyMiIsImJuZHNfMDE0JDIzIiwiYm5kc18wMTQkMjQiLCJibmRzXzAxNCQyNSIsImZpcmVkX2FsYXJtX3ZhbHVlcyIsInNldF9maXJlZF9hbGFybV92YWx1ZXMiLCJoYW5kbGVfZmlyZWQiLCJ0aW1pbmdfd2hlZWwiLCJmaXJlZF9hbGFybV92YWx1ZXMkMCIsImhhbmRsZV9maXJlZCQwIiwibm93JDAiLCJ0aW1pbmdfd2hlZWwkMCIsIm1ha2VfY3JlYXRvciQxIiwidGltaW5nX3doZWVsX2Z1biIsIm5vd19mdW4iLCJoYW5kbGVfZmlyZWRfZnVuIiwiZmlyZWRfYWxhcm1fdmFsdWVzX2Z1biIsInRpbWluZ193aGVlbF9nZW4iLCJub3dfZ2VuIiwiaGFuZGxlX2ZpcmVkX2dlbiIsImZpcmVkX2FsYXJtX3ZhbHVlc19nZW4iLCJjcmVhdGUkMiIsIm1hcCQzIiwiaXRlciQzIiwiZm9sZCQzIiwibWFwX3BvbHkkMSIsImZvcl9hbGwkMyIsImV4aXN0cyQzIiwidG9fbGlzdCQzIiwiaXRlciQ0IiwiZm9sZCQ0IiwiZm9yX2FsbCQ0IiwiZXhpc3RzJDQiLCJ0b19saXN0JDQiLCJtYXAkNCIsInNldF9hbGxfbXV0YWJsZV9maWVsZHMkMSIsInNleHBfb2ZfdCQzIiwibm93XzA3MiIsInRpbWluZ193aGVlbF8wNzAiLCJmaXJlZF9hbGFybV92YWx1ZXNfMDc2IiwiYXJnXzA3NyIsImJuZHNfMDY5IiwiYXJnXzA3NSIsImJuZHNfMDY5JDAiLCJhcmdfMDczIiwiYm5kc18wNjkkMSIsImFyZ18wNzEiLCJibmRzXzA2OSQyIiwiaW52YXJpYW50JDEiLCJub3ckMSIsImNsb2NrIiwidGltaW5nX3doZWVsX2xlbmd0aCIsIm51bV9zdGFiaWxpemVzIiwiaXRlcl9vYnNlcnZlcnMiLCJkaXJlY3RseV9vYnNlcnZlZCIsIml0ZXJfb2JzZXJ2ZXJfZGVzY2VuZGFudHMiLCJ0X29mX3NleHAiLCJzZXhwXzA3OSIsImZpZWxkX3NleHBzXzA4MCIsIm1heF9udW1fcGFyZW50c18wODEiLCJwZXJjZW50YWdlX29mX25vZGVzX2J5X251bV9wYXIiLCJkdXBsaWNhdGVzXzA4NSIsImV4dHJhXzA4NiIsInNleHBfMDc5JDAiLCJmaWVsZF9zZXhwc18wODkiLCJmaWVsZF9uYW1lXzA4NyIsInRhaWxfMDk5IiwiZmllbGRfc2V4cF8wODgkMiIsImZpZWxkX3NleHBfMDg4IiwieF8xMDAiLCJmaWVsZF9zZXhwXzA4OCQwIiwic2V4cF8wOTQiLCJhcmcxXzA5MSIsImFyZzBfMDkwIiwicmVzMF8wOTIiLCJyZXMxXzA5MyIsImZ2YWx1ZV8wOTYiLCJmaWVsZF9zZXhwXzA4OCQxIiwiZnZhbHVlXzA5NyIsInBlcmNlbnRhZ2Vfb2Zfbm9kZXNfYnlfbnVtX3BhciQwIiwibWF4X251bV9wYXJlbnRzXzA4MiIsInNleHBfb2ZfdCQ0IiwibWF4X251bV9wYXJlbnRzXzEwMiIsImJuZHNfMTAxIiwiYXJnMV8xMDciLCJhcmcwXzEwNiIsInJlczBfMTA4IiwicmVzMV8xMDkiLCJhcmdfMTA1IiwiYm5kc18xMDEkMCIsImFyZ18xMDMiLCJibmRzXzEwMSQxIiwic3RhdHMiLCJudW1fbmVjZXNzYXJ5X25vZGVzIiwibWF4X251bV9wYXJlbnRzJDAiLCJudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMiLCJudW1fbm9kZXMiLCJhbV9zdGFiaWxpemluZyIsInJhaXNlZF9leG4iLCJpbnZhcmlhbnQkMiIsImludGVybmFsX29ic2VydmVyIiwieF8xMTAiLCJwYWNrZWQiLCJlbnN1cmVfbm90X3N0YWJpbGl6aW5nIiwiYWxsb3dfaW5fdXBkYXRlX2hhbmRsZXIiLCJiYWNrdHJhY2UiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYXJnMV8xMTIiLCJhcmcwXzExMSIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uJDEiLCJyZW1vdmVfY2hpbGRyZW4iLCJyZW1vdmVfY2hpbGQiLCJjaGVja19pZl91bm5lY2Vzc2FyeSIsImJlY2FtZV91bm5lY2Vzc2FyeSIsInAiLCJ1IiwicmVtb3ZlX2FsYXJtIiwiaW52YWxpZGF0ZV9ub2RlIiwiaW52YWxpZGF0ZV9ub2Rlc19jcmVhdGVkX29uX3JoIiwicmVzY29wZV9ub2Rlc19jcmVhdGVkX29uX3JocyIsImZpcnN0X25vZGVfb25fcmhzIiwibmV3X3Njb3BlIiwicHJvcGFnYXRlX2ludmFsaWRpdHkkMSIsImV4cGVydCIsImFkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaCIsIndhc19uZWNlc3NhcnkiLCJ4XzExNSIsImJlY2FtZV9uZWNlc3NhcnkiLCJydW5fd2l0aF9zY29wZSIsInNjb3BlIiwic2F2ZWQiLCJleG4kMCIsIndpdGhpbl9zY29wZSIsImNoYW5nZV9jaGlsZCIsIm9sZF9jaGlsZCIsIm5ld19jaGlsZCIsIm9sZF9jaGlsZCQwIiwiYWRkX2FsYXJtIiwicmVjb21wdXRlIiwibWF5YmVfY2hhbmdlX3ZhbHVlIiwib2xkX3JocyIsIm9sZF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMiLCJjb3B5X2NoaWxkIiwib25seV9mcmVlemVfd2hlbiIsImVsc2UkMCIsInRoZW4iLCJkZXNpcmVkX2JyYW5jaCIsIm1haW4kMSIsIm9sZF9yaHMkMCIsInJocyQxIiwicmhzJDIiLCJuMSIsImNsb2NrJDAiLCJhdCQwIiwiY2xvY2skMSIsImNoaWxkJDEiLCJzdGVwX2Z1bmN0aW9uIiwic3RlcF9mdW5jdGlvbl92YWx1ZSIsImF0JDEiLCJuMiIsIm4xJDAiLCJuMyIsIm4yJDAiLCJuMSQxIiwiZiQyIiwibjQiLCJuMyQwIiwibjIkMSIsIm4xJDIiLCJmJDMiLCJuNSIsIm40JDAiLCJuMyQxIiwibjIkMiIsIm4xJDMiLCJmJDQiLCJuNiIsIm41JDAiLCJuNCQxIiwibjMkMiIsIm4yJDMiLCJuMSQ0IiwiZiQ1IiwibjciLCJuNiQwIiwibjUkMSIsIm40JDIiLCJuMyQzIiwibjIkNCIsIm4xJDUiLCJmJDYiLCJuOCIsIm43JDAiLCJuNiQxIiwibjUkMiIsIm40JDMiLCJuMyQ0IiwibjIkNSIsIm4xJDYiLCJmJDciLCJuOSIsIm44JDAiLCJuNyQxIiwibjYkMiIsIm41JDMiLCJuNCQ0IiwibjMkNSIsIm4yJDYiLCJuMSQ3IiwiZiQ4IiwibjEwIiwibjkkMCIsIm44JDEiLCJuNyQyIiwibjYkMyIsIm41JDQiLCJuNCQ1IiwibjMkNiIsIm4yJDciLCJuMSQ4IiwiZiQ5IiwibjExIiwibjEwJDAiLCJuOSQxIiwibjgkMiIsIm43JDMiLCJuNiQ0IiwibjUkNSIsIm40JDYiLCJuMyQ3IiwibjIkOCIsIm4xJDkiLCJmJDEwIiwibjEyIiwibjExJDAiLCJuMTAkMSIsIm45JDIiLCJuOCQzIiwibjckNCIsIm42JDUiLCJuNSQ2IiwibjQkNyIsIm4zJDgiLCJuMiQ5IiwibjEkMTAiLCJmJDExIiwibjEzIiwibjEyJDAiLCJuMTEkMSIsIm4xMCQyIiwibjkkMyIsIm44JDQiLCJuNyQ1IiwibjYkNiIsIm41JDciLCJuNCQ4IiwibjMkOSIsIm4yJDEwIiwibjEkMTEiLCJmJDEyIiwibjE0IiwibjEzJDAiLCJuMTIkMSIsIm4xMSQyIiwibjEwJDMiLCJuOSQ0IiwibjgkNSIsIm43JDYiLCJuNiQ3IiwibjUkOCIsIm40JDkiLCJuMyQxMCIsIm4yJDExIiwibjEkMTIiLCJmJDEzIiwibjE1IiwibjE0JDAiLCJuMTMkMSIsIm4xMiQyIiwibjExJDMiLCJuMTAkNCIsIm45JDUiLCJuOCQ2IiwibjckNyIsIm42JDgiLCJuNSQ5IiwibjQkMTAiLCJuMyQxMSIsIm4yJDEyIiwibjEkMTMiLCJmJDE0IiwiY2hpbGRfaW5kZXgkMCIsInUkMCIsImNhbl9yZWNvbXB1dGVfbm93IiwiYiIsImoiLCJyZWNvbXB1dGVfZmlyc3Rfbm9kZV90aGF0X2lzX24iLCJ4XzExNiIsInVubGlua19kaXNhbGxvd2VkX29ic2VydmVycyIsImRpc2FsbG93X2Z1dHVyZV91c2UiLCJkaXNhbGxvd19maW5hbGl6ZWRfb2JzZXJ2ZXJzIiwib2JzZXJ2ZXJfZmluYWxpemVyIiwiY3JlYXRlX29ic2VydmVyIiwib3B0Iiwic3RoIiwic2hvdWxkX2ZpbmFsaXplIiwiYWRkX25ld19vYnNlcnZlcnMiLCJvbGRfYWxsX29ic2VydmVycyIsIm9sZF9vYnNlcnZlcnMiLCJvYnNlcnZlcl92YWx1ZV9leG4iLCJ4XzExNyIsIm9ic2VydmVyX3ZhbHVlIiwibm9kZV9vbl91cGRhdGUiLCJvYnNlcnZlcl9vbl91cGRhdGVfZXhuIiwic2V0X3Zhcl93aGlsZV9ub3Rfc3RhYmlsaXppbmciLCJzZXRfdmFyIiwicmVjbGFpbV9zcGFjZV9pbl93ZWFrX2hhc2h0YmxzIiwid2Vha19oYXNodGJsIiwic3RhYmlsaXplX3N0YXJ0Iiwic3RhYmlsaXplX2VuZCIsIm1hdGNoJDAiLCJub2RlX3VwZGF0ZSQwIiwicmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb24iLCJzdGFiaWxpemUiLCJzZXhwX29mX3QkNSIsImRvX29uZV9zdGVwX29mX3N0YWJpbGl6ZSIsImNyZWF0ZV9ub2RlX2luIiwiY3JlYXRlX25vZGUiLCJjcmVhdGVfbm9kZV90b3AiLCJjcmVhdGVfdmFyIiwidXNlX2N1cnJlbnRfc2NvcGUiLCJjb25zdCQwIiwibWFwJDUiLCJtYXAyIiwiYm90aCIsIm1hcDMiLCJtYXA0IiwibWFwNSIsIm1hcDYiLCJtYXA3IiwibWFwOCIsIm1hcDkiLCJtYXAxMCIsIm1hcDExIiwibWFwMTIiLCJtYXAxMyIsIm1hcDE0IiwibWFwMTUiLCJwcmVzZXJ2ZV9jdXRvZmYiLCJpbnB1dCIsIm91dHB1dCIsImRlcGVuZF9vbiIsIm5lY2Vzc2FyeV9pZl9hbGl2ZSIsImJpbmQyIiwidjIiLCJ2MSIsImJpbmQzIiwidjMiLCJiaW5kNCIsInY0IiwiaWYkMCIsImxhenlfZnJvbV9mdW4iLCJkZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXoiLCJtZW1vaXplX2Z1bl9ieV9rZXkiLCJoYXNoYWJsZSIsInByb2plY3Rfa2V5IiwiaW5pdGlhbF9zaXplIiwidGFibGUiLCJrZXkiLCJiJDAiLCJhbGwiLCJvcHRfdW5vcmRlcmVkX2FycmF5X2ZvbGQiLCJudW1faW52YWxpZCIsImFjY3VtIiwieCQwIiwiZl9pbnZlcnNlJDAiLCJhdF9sZWFzdF9rX29mIiwiYm9vbF90b19pbnQiLCJudW1fdHJ1ZSIsImV4aXN0cyQ1IiwiZm9yX2FsbCQ1Iiwic3VtIiwiemVybyIsInN1YiIsIm9wdF9zdW0iLCJzdW1faW50Iiwic3VtX2Zsb2F0Iiwic2V0X2ZyZWV6ZSIsInRpbWUiLCJhZnRlciIsInNwYW4iLCJuZXh0X2ludGVydmFsX2FsYXJtX3N0cmljdCIsImJhc2UiLCJ2YWx1ZV9hdCIsImluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb24iLCJhZHZhbmNlX2Nsb2NrIiwibWFpbiQyIiwiY3JlYXRlX2Nsb2NrIiwidGltaW5nX3doZWVsX2NvbmZpZyIsInN0YXJ0IiwiY3JlYXRlJDMiLCJDb25maWciLCJ3ZWFrX21lbW9pemVfZnVuX2J5X2tleSIsImV4cGVydF9raW5kX29mX25vZGUiLCJ4XzExOCIsImNyZWF0ZSQ0IiwiY3VycmVudGx5X3J1bm5pbmdfbm9kZV9leG4iLCJjdXJyZW50IiwiYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfIiwieF8xMjAiLCJ4XzExOSIsImFzc2VydF9jdXJyZW50bHlfcnVubmluZ19ub2RlXyQwIiwieF8xMjIiLCJ4XzEyMSIsIm1ha2Vfc3RhbGUkMCIsImVfb3B0IiwiaW52YWxpZGF0ZSIsImFkZF9kZXBlbmRlbmN5IiwiZGVwIiwicmVtb3ZlX2RlcGVuZGVuY3kiLCJlZGdlIiwiZWRnZV9pbmRleCIsImxhc3RfZWRnZSIsImxhc3RfZWRnZV9pbmRleCIsIm9uX2NoYW5nZSIsInJlZHVjZSIsInJlZHVjZXIiLCJsZXZlbF9iaXRzIiwiY3JlYXRlX2ludGVybmFsIiwiZGVmYXVsdF9tYXhfaGVpZ2h0X2FsbG93ZWQiLCJzZXhwX29mX3N0YXRlX3dpdG5lc3MiLCJ3aXRoaW4iLCJwYWNrIiwicmV0dXJuJDAiLCJtYXAyJDAiLCJtYXAzJDAiLCJtYXA0JDAiLCJtYXA1JDAiLCJtYXA2JDAiLCJtYXA3JDAiLCJtYXA4JDAiLCJtYXA5JDAiLCJtYXAxMCQwIiwibWFwMTEkMCIsIm1hcDEyJDAiLCJtYXAxMyQwIiwibWFwMTQkMCIsIm1hcDE1JDAiLCJiaW5kMiQwIiwiYmluZDMkMCIsImJpbmQ0JDAiLCJzeW1ib2xfbWFwIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwJDAiLCJzeW1ib2xfYmluZCQwIiwibGF6eV9mcm9tX2Z1biQwIiwibWVtb2l6ZV9mdW4iLCJhcnJheV9mb2xkJDAiLCJyZWR1Y2VfYmFsYW5jZWQiLCJyZXBsYWNlIiwieF8wMTciLCJkaXNhbGxvd19mdXR1cmVfdXNlJDAiLCJpbmNyX3N0YXRlJDEiLCJhbGFybV9wcmVjaXNpb24iLCJkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWciLCJzdGFydCQwIiwiYWxhcm1fcHJlY2lzaW9uJDAiLCJ3YXRjaF9ub3ciLCJhZHZhbmNlX2Nsb2NrX2J5IiwiZnJlZXplJDAiLCJ3aGVuIiwiZGVwZW5kX29uJDAiLCJzdGFiaWxpemUkMCIsImFtX3N0YWJpbGl6aW5nJDAiLCJvZl9hXzAxOCIsImFyZzBfMDE5IiwiYXJnMF8wMjEiLCJyZXMwXzAyMiIsIm5vZGVfdmFsdWUiLCJzZXhwX29mX3QkNiIsImJvdGgkMCIsIngxIiwieDIiLCJtYXAyJDEiLCJtYXAzJDEiLCJtYXA0JDEiLCJtYXA1JDEiLCJtYXA2JDEiLCJtYXA3JDEiLCJtYXA4JDEiLCJtYXA5JDEiLCJtYXAxMCQxIiwibWFwMTEkMSIsIm1hcDEyJDEiLCJtYXAxMyQxIiwibWFwMTQkMSIsIm1hcDE1JDEiLCJiaW5kMiQxIiwiYmluZDMkMSIsImJpbmQ0JDEiLCJ3ZWFrX21lbW9pemVfZnVuIiwiZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplJDAiLCJyZXR1cm4kMSIsIndpdGhpbiQwIiwiY29uc3QkMSIsInJldHVybiQyIiwiYWxsJDAiLCJtZW1vaXplX2Z1bl9ieV9rZXkkMCIsIm1lbW9pemVfZnVuJDAiLCJhcnJheV9mb2xkJDEiLCJyZWR1Y2VfYmFsYW5jZWQkMCIsInVub3JkZXJlZF9hcnJheV9mb2xkJDAiLCJvcHRfdW5vcmRlcmVkX2FycmF5X2ZvbGQkMCIsInN1bSQwIiwib3B0X3N1bSQwIiwic3VtX2ludCQwIiwic3VtX2Zsb2F0JDAiLCJzdGFiaWxpemUkMSIsImFtX3N0YWJpbGl6aW5nJDEiLCJzYXZlX2RvdCQwIiwic2F2ZV9kb3RfdG9fZmlsZSQwIiwid2Vha19tZW1vaXplX2Z1bl9ieV9rZXkkMCIsIndlYWtfbWVtb2l6ZV9mdW4kMCIsInNleHBfb2ZfdCQ3IiwiaW52YXJpYW50JDUiLCJzZXhwX29mX3QkOSIsImludmFyaWFudCQ2Iiwic2V4cF9vZl90JDExIiwic2V4cF9vZl90JDEyIiwiaW52YXJpYW50JDciLCJvbl91cGRhdGVfZXhuJDAiLCJkaXNhbGxvd19mdXR1cmVfdXNlJDEiLCJ2YWx1ZSQxIiwic2V4cF9vZl90JDEzIiwiaW52YXJpYW50JDgiLCJzZXhwX29mX3QkMTQiLCJzZXhwX29mX3QkMTUiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2JlZm9yZV9vcl9hZnRlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvaW1wb3J0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9jdXRvZmYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2RvdF91c2VyX2luZm8ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL25vZGVfaWQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL3N0YWJpbGl6YXRpb25fbnVtLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9vbl91cGRhdGVfaGFuZGxlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvcmFpc2VkX2V4bi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvdHlwZXMubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL3Zhci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvdW5vcmRlcmVkX2FycmF5X2ZvbGQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2FsYXJtLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9zdGVwX2Z1bmN0aW9uX25vZGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2FycmF5X2ZvbGQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2F0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9hdF9pbnRlcnZhbHMubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2JpbmQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2V4cGVydC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvc2NvcGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2ZyZWV6ZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvaWZfdGhlbl9lbHNlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9qb2luLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9zbmFwc2hvdC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwva2luZC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvbm9kZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvcmVjb21wdXRlX2hlYXAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2FkanVzdF9oZWlnaHRzX2hlYXAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2FsYXJtX3ZhbHVlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9jb25maWcubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2ludGVybmFsX29ic2VydmVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9pbmNyZW1lbnRhbC9vYnNlcnZlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvc3RhdGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL2V4cGVydDEubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JlbWVudGFsL3JlZHVjZV9iYWxhbmNlZC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvaW5jcmVtZW50YWwvaW5jcmVtZW50YWwu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RUF6cEI7T0EwQkU2cUI7T0F0QkFuQjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQWhCRnB1RDtPQTBCRTJ1RDtPQVRBTjtPQUNBQztPQUNBQzs7T0FZRnJyQztPQUNBMmxDO09Ba0lBNkc7T0FDQUU7T0FDQXZIO09BbEhBcmtCO09BREFDO09BREFzbEI7T0FHQXBDO09BVkEySDtPQUNBQzs7T0FJQXpyQztPQUNBa21DO09BS0FVO09BQ0FHO09BQ0FDO09BQ0FDO2dCQW5FRXFCLFNBQ0F3Qjs7UUFpWE55RztRQTFTTS9NO1FBQ0FkO1FBRUE5bEQ7UUFEQUs7O1FBTUF5dUQ7O1FBa1NOMEU7UUFFUUM7OztRQXZRRkY7UUFDQW43Qjs7UUFoQkFpN0I7UUFjQUM7T0FsR0ZyTzs7T0EwS0FVO09BQ0FnSztPQUNBQzs7Ozs7Ozs7Ozs7Ozs7O09BeklBbEI7T0FDQTdGO09BR0E4RjtPQUZBN0Y7T0E2TEF5STtPQUZBbEc7Ozs7O09BeENBNEU7O09BM0xBOUM7T0FnTEE1eUI7T0FDQU07O1FBbkpFMnpCO1FBQ0FDOztTQTFCRjN1RDtTQWlCRXN4RDtTQUNBQztTQUNBQztTQXBCRjN0QjtTQUlFMnNCO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBb01FaEI7Ozs7UUFtSVIyQztRQTlOTTNEO1FBVUF0eEI7UUFXQXd4QjtRQXZCQUo7UUF3QkE1WjtRQUNBcDJDO1FBQ0Fxd0Q7UUFJQXhFO1FBQ0F5RTtRQUpBOXNDO1FBQ0ErbkM7UUFDQTluQztRQUtBcTVCO1FBRkE4TztRQVFBM25DOztZQXVNTjh2Qzs7U0FBQUU7Ozs7Ozs7O1FBd0NJMUI7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbInR5cGUgdCA9XG4gIHwgQmVmb3JlXG4gIHwgQWZ0ZXJcbltAQGRlcml2aW5nIHNleHBfb2ZdXG4iLCJbJSVpbXBvcnQgXCJkZWJ1Zy5tbGhcIl1cblxub3BlbiBDb3JlXG5pbmNsdWRlIEludC5SZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuKCogQWxsIFthc3NlcnRdcyBhbmQgb3RoZXIgY2hlY2tzIHRocm91Z2hvdXQgdGhlIGNvZGUgYXJlIGd1YXJkZWQgYnkgW2lmIGRlYnVnXS4gIFRoZVxuICAgREVCVUcgdmFyaWFibGUgaXMgc2V0IGluIHRoZSBsaWIgW2luY3JlbWVudGFsXSBhbmQgdW5zZXQgaW4gdGhlIGxpYlxuICAgW2luY3JlbWVudGFsX2RlYnVnXSwgYnV0IGFwYXJ0IGZyb20gdGhhdCB0aGV5IGFyZSBpZGVudGljYWwuICBUZXN0cyBhcmUgcnVuIHdpdGggYm90aFxuICAgdGhlIHByb2R1Y3Rpb24gYW5kIGRlYnVnIGxpYiwgYW5kIHVzZXJzIGNhbiBjaG9vc2UgdG8gYnVpbGQgd2l0aCB0aGUgZGVidWcgbGlicmFyeSwgaWZcbiAgIHRoZXkgc3VzcGVjdCB0aGV5IGZvdW5kIGEgYnVnIGluIGluY3JlbWVudGFsLiAqKVxuXG5bJSVpZiBKU0NfREVCVUddXG5cbmxldCBkZWJ1ZyA9IHRydWVcblxuWyUlZWxzZV1cblxubGV0IGRlYnVnID0gZmFsc2VcblxuWyUlZW5kaWZdXG5cbmxldCBjb25jYXQgPSBTdHJpbmcuY29uY2F0XG5sZXQgdGFnIG5hbWUgYSBzZXhwX29mX2EgPSAobmFtZSwgYSkgfD4gWyVzZXhwX29mOiBzdHJpbmcgKiBhXVxuXG5tb2R1bGUgU3RlcF9mdW5jdGlvbiA9IEluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb25cblxubW9kdWxlIFRpbWVfbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUaW1lX25zXG5cbiAgbGV0IHNleHBfb2ZfdCA9IFRpbWVfbnMuQWx0ZXJuYXRlX3NleHAuc2V4cF9vZl90XG5lbmRcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGluY2x1ZGUgQXJyYXlcblxuICAoKiBOb3QgZGVmaW5pbmcgYWxpYXNlcyBpbiBwcm9kdWN0aW9uIG1vZGUsIHNpbmNlIHRoZXkgYnJlYWsgdHlwZSBzcGVjaWFsaXphdGlvbiBvZlxuICAgICBhcnJheSBhY2Nlc3Nlcy4gKilcbiAgWyUlaWYgSlNDX0RFQlVHXVxuXG4gIGxldCB1bnNhZmVfZ2V0ID0gZ2V0XG4gIGxldCB1bnNhZmVfc2V0ID0gc2V0XG5cbiAgWyUlZW5kaWZdXG5cbiAgKCogUmVxdWlyZXMgW2xlbiA+PSBsZW5ndGggdF0uICopXG4gIGxldCByZWFsbG9jIHQgfmxlbiBhID1cbiAgICBsZXQgbmV3X3QgPSBjcmVhdGUgfmxlbiBhIGluXG4gICAgQXJyYXkuYmxpdCB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om5ld190IH5kc3RfcG9zOjAgfmxlbjoobGVuZ3RoIHQpO1xuICAgIG5ld190XG4gIDs7XG5lbmRcblxubW9kdWxlIFVvcHQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBVb3B0XG5cbiAgbGV0IHVuc2FmZV92YWx1ZSA9IGlmIGRlYnVnIHRoZW4gdmFsdWVfZXhuIGVsc2UgdW5zYWZlX3ZhbHVlXG5lbmRcblxubW9kdWxlIFVuaWZvcm1fYXJyYXkgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBVbmlmb3JtX2FycmF5XG5cbiAgWyUlaWYgSlNDX0RFQlVHXVxuXG4gIGxldCB1bnNhZmVfZ2V0ID0gZ2V0XG4gIGxldCB1bnNhZmVfc2V0ID0gc2V0X3dpdGhfY2FtbF9tb2RpZnlcblxuICBbJSVlbHNlXVxuXG4gICgqIFVuaWZvcm1fYXJyYXkgaXMgYmVpbmcgXCJzbWFydFwiIGJ5IGNoZWNraW5nIGlmIGVsZW1lbnRzIGFyZSBpbnRlZ2VycywgYnV0IFVvcHQudFxuICAgICBhbG1vc3QgbmV2ZXIgY29udGFpbiBpbnRlZ2Vycywgc28gdGhlIGV4dHJhIGNoZWNrIHRvIG1ha2UgZ2VuZXJhdGVkIGNvZGUgaGFyZGVyIHRvXG4gICAgIHJlYWQgYW5kIHBvdGVudGlhbGx5IHNsb3dlci4gKilcbiAgbGV0IHVuc2FmZV9zZXQgPSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnlcbiAgbGV0IHNldCA9IHNldF93aXRoX2NhbWxfbW9kaWZ5XG5cbiAgWyUlZW5kaWZdXG5cbiAgKCogUmVxdWlyZXMgW2xlbiA+PSBsZW5ndGggdF0uICopXG4gIGxldCByZWFsbG9jIHQgfmxlbiA9XG4gICAgbGV0IG5ld190ID0gY3JlYXRlIH5sZW4gVW9wdC5ub25lIGluXG4gICAgYmxpdCB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om5ld190IH5kc3RfcG9zOjAgfmxlbjoobGVuZ3RoIHQpO1xuICAgIG5ld190XG4gIDs7XG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA9IFRpbWluZ193aGVlbC5BbGFybV9wcmVjaXNpb25cbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9XG4gICgqIFdlIHNwZWNpYWxpemUgc29tZSBjdXRvZmZzIHRvIGF2b2lkIGFuIGluZGlyZWN0IGZ1bmN0aW9uIGNhbGw7IGluIHBhcnRpY3VsYXIgd2VcbiAgICAgc3BlY2lhbGl6ZSB0aGUgZGVmYXVsdCAoYW5kIGhlbmNlIG92ZXJ3aGVsbWluZ2x5IGNvbW1vbikgY2FzZSBvZiBwaHlzaWNhbFxuICAgICBlcXVhbGl0eS4gKilcbiAgfCBBbHdheXNcbiAgfCBOZXZlclxuICB8IFBoeXNfZXF1YWxcbiAgfCBDb21wYXJlIG9mICgnYSAtPiAnYSAtPiBpbnQpXG4gIHwgRXF1YWwgb2YgKCdhIC0+ICdhIC0+IGJvb2wpXG4gIHwgRiBvZiAob2xkX3ZhbHVlOidhIC0+IG5ld192YWx1ZTonYSAtPiBib29sKVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQWx3YXlzIHwgTmV2ZXIgfCBQaHlzX2VxdWFsIHwgQ29tcGFyZSBfIHwgRXF1YWwgXyB8IEYgXyAtPiAoKSlcbjs7XG5cbmxldCBjcmVhdGUgZiA9IEYgZlxubGV0IG9mX2NvbXBhcmUgZiA9IENvbXBhcmUgZlxubGV0IG9mX2VxdWFsIGYgPSBFcXVhbCBmXG5sZXQgbmV2ZXIgPSBOZXZlclxubGV0IGFsd2F5cyA9IEFsd2F5c1xubGV0IHBvbHlfZXF1YWwgPSBFcXVhbCBQb2x5LmVxdWFsXG5cbmxldCBzaG91bGRfY3V0b2ZmIHQgfm9sZF92YWx1ZSB+bmV3X3ZhbHVlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgUGh5c19lcXVhbCAtPiBwaHlzX2VxdWFsIG9sZF92YWx1ZSBuZXdfdmFsdWVcbiAgfCBOZXZlciAtPiBmYWxzZVxuICB8IEFsd2F5cyAtPiB0cnVlXG4gIHwgQ29tcGFyZSBmIC0+IGYgb2xkX3ZhbHVlIG5ld192YWx1ZSA9IDBcbiAgfCBFcXVhbCBmIC0+IGYgb2xkX3ZhbHVlIG5ld192YWx1ZVxuICB8IEYgZiAtPiBmIH5vbGRfdmFsdWUgfm5ld192YWx1ZVxuOztcblxubGV0IGVxdWFsIHQxIHQyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBBbHdheXMsIEFsd2F5cyAtPiB0cnVlXG4gIHwgQWx3YXlzLCBfIC0+IGZhbHNlXG4gIHwgTmV2ZXIsIE5ldmVyIC0+IHRydWVcbiAgfCBOZXZlciwgXyAtPiBmYWxzZVxuICB8IFBoeXNfZXF1YWwsIFBoeXNfZXF1YWwgLT4gdHJ1ZVxuICB8IFBoeXNfZXF1YWwsIF8gLT4gZmFsc2VcbiAgfCBDb21wYXJlIGYxLCBDb21wYXJlIGYyIC0+IHBoeXNfZXF1YWwgZjEgZjJcbiAgfCBDb21wYXJlIF8sIF8gLT4gZmFsc2VcbiAgfCBFcXVhbCBmMSwgRXF1YWwgZjIgLT4gcGh5c19lcXVhbCBmMSBmMlxuICB8IEVxdWFsIF8sIF8gLT4gZmFsc2VcbiAgfCBGIGYxLCBGIGYyIC0+IHBoeXNfZXF1YWwgZjEgZjJcbiAgfCBGIF8sIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwaHlzX2VxdWFsID0gUGh5c19lcXVhbFxuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIFN0cmluZ19saXN0ID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSAodmFsIENvbXBhcmF0b3IubWFrZSB+c2V4cF9vZl90IH5jb21wYXJlKVxuZW5kXG5cbnR5cGUgZG90ID1cbiAgeyBsYWJlbCA6IFNldC5NKFN0cmluZ19saXN0KS50XG4gIDsgYXR0cmlidXRlcyA6IHN0cmluZyBTdHJpbmcuTWFwLnRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSB0ID1cbiAgfCBEb3Qgb2YgZG90XG4gIHwgSW5mbyBvZiBJbmZvLnRcbiAgfCBBcHBlbmQgb2ZcbiAgICAgIHsgcHJpb3IgOiB0XG4gICAgICA7IG5ld18gOiB0XG4gICAgICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW5mbyBpbmZvID0gSW5mbyBpbmZvXG5sZXQgYXBwZW5kIHByaW9yIG5ld18gPSBBcHBlbmQgeyBwcmlvcjsgbmV3XyB9XG5cbmxldCBkb3QgfmxhYmVsIH5hdHRyaWJ1dGVzID1cbiAgbGV0IGxhYmVsID0gU2V0LnNpbmdsZXRvbiAobW9kdWxlIFN0cmluZ19saXN0KSBsYWJlbCBpblxuICBEb3QgeyBsYWJlbDsgYXR0cmlidXRlcyB9XG47O1xuXG5sZXQgcmVjIHRvX2RvdCA9IGZ1bmN0aW9uXG4gIHwgSW5mbyBpIC0+XG4gICAgeyBsYWJlbCA9IFNldC5zaW5nbGV0b24gKG1vZHVsZSBTdHJpbmdfbGlzdCkgWyBJbmZvLnRvX3N0cmluZ19odW0gaSBdXG4gICAgOyBhdHRyaWJ1dGVzID0gU3RyaW5nLk1hcC5lbXB0eVxuICAgIH1cbiAgfCBEb3QgZG90IC0+IGRvdFxuICB8IEFwcGVuZCB7IHByaW9yOyBuZXdfIH0gLT5cbiAgICBsZXQgcHJpb3IgPSB0b19kb3QgcHJpb3IgaW5cbiAgICBsZXQgbmV3XyA9IHRvX2RvdCBuZXdfIGluXG4gICAgbGV0IGxhYmVsID0gU2V0LnVuaW9uIHByaW9yLmxhYmVsIG5ld18ubGFiZWwgaW5cbiAgICBsZXQgYXR0cmlidXRlcyA9XG4gICAgICBNYXAubWVyZ2Vfc2tld2VkXG4gICAgICAgIHByaW9yLmF0dHJpYnV0ZXNcbiAgICAgICAgbmV3Xy5hdHRyaWJ1dGVzXG4gICAgICAgIH5jb21iaW5lOihmdW4gfmtleTpfIF9sZWZ0IHJpZ2h0IC0+IHJpZ2h0KVxuICAgIGluXG4gICAgeyBsYWJlbDsgYXR0cmlidXRlcyB9XG47O1xuXG5sZXQgZXNjYXBlX2RvdF9zdHJpbmcgcyA9XG4gICgqIGh0dHBzOi8vZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbCAqKVxuICBcIlxcXCJcIiBeIFN0cmluZy5zdWJzdHJfcmVwbGFjZV9hbGwgcyB+cGF0dGVybjpcIlxcXCJcIiB+d2l0aF86XCJcXFxcXFxcIlwiIF4gXCJcXFwiXCJcbjs7XG5cbmxldCBlc2NhcGVfcmVjb3JkX2xhYmVsIHMgPVxuICAoKiBodHRwczovL2dyYXBodml6Lm9yZy9kb2MvaW5mby9zaGFwZXMuaHRtbCAqKVxuICBTdHJpbmcuY29uY2F0X21hcCBzIH5mOihmdW5jdGlvblxuICAgIHwgKCc8JyB8ICc+JyB8ICd7JyB8ICd9JyB8ICd8JyB8ICdcXFxcJyB8ICcgJykgYXMgYyAtPiBcIlxcXFxcIiBeIFN0cmluZy5vZl9jaGFyIGNcbiAgICB8IGMgLT4gU3RyaW5nLm9mX2NoYXIgYylcbjs7XG5cbmxldCB0b19zdHJpbmcgfm5hbWUgeyBsYWJlbDsgYXR0cmlidXRlcyB9ID1cbiAgbGV0IGxhYmVsID1cbiAgICBsYWJlbFxuICAgIHw+IFNldC50b19saXN0XG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBjb2xzIC0+XG4gICAgICBcIntcIiBeIFN0cmluZy5jb25jYXQgKExpc3QubWFwIGNvbHMgfmY6ZXNjYXBlX3JlY29yZF9sYWJlbCkgfnNlcDpcInxcIiBeIFwifVwiKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcInxcIlxuICAgIHw+IGZ1biBzIC0+IFwie1wiIF4gcyBeIFwifVwiXG4gIGluXG4gIGxldCBhdHRyaWJ1dGVzID1cbiAgICBhdHRyaWJ1dGVzXG4gICAgfD4gTWFwLnRvX2FsaXN0XG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biAoaywgdikgLT5cbiAgICAgIHNwcmludGYge3wgJXM9JXN8fSAoZXNjYXBlX2RvdF9zdHJpbmcgaykgKGVzY2FwZV9kb3Rfc3RyaW5nIHYpKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIiBcIlxuICBpblxuICBzcHJpbnRmIHt8ICAlcyBbc2hhcGU9TXJlY29yZCBsYWJlbD0lcyAlc118fSBuYW1lIChlc2NhcGVfZG90X3N0cmluZyBsYWJlbCkgYXR0cmlidXRlc1xuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludFxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKHQgPj0gMSlcblxubGV0IG5leHQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludFxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKHQgPj0gLTEpXG5sZXQgbm9uZSA9IC0xXG5sZXQgaXNfbm9uZSB0ID0gdCA9IG5vbmVcbmxldCBpc19zb21lIHQgPSB0ID49IDBcbmxldCBhZGQxIHQgPSB0ICsgMVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBQcmV2aW91c191cGRhdGVfa2luZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmV2ZXJfYmVlbl91cGRhdGVkXG4gICAgfCBOZWNlc3NhcnlcbiAgICB8IENoYW5nZWRcbiAgICB8IEludmFsaWRhdGVkXG4gICAgfCBVbm5lY2Vzc2FyeVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbm1vZHVsZSBOb2RlX3VwZGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgTmVjZXNzYXJ5IG9mICdhXG4gICAgfCBDaGFuZ2VkIG9mICdhICogJ2FcbiAgICB8IEludmFsaWRhdGVkXG4gICAgfCBVbm5lY2Vzc2FyeVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuZW5kXG5cbnR5cGUgJ2EgdCA9XG4gIHsgZiA6ICdhIE5vZGVfdXBkYXRlLnQgLT4gdW5pdFxuICA7IG11dGFibGUgcHJldmlvdXNfdXBkYXRlX2tpbmQgOiBQcmV2aW91c191cGRhdGVfa2luZC50XG4gIDsgY3JlYXRlZF9hdCA6IFN0YWJpbGl6YXRpb25fbnVtLnRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGNyZWF0ZSBmIH5hdDpjcmVhdGVkX2F0ID0geyBmOyBwcmV2aW91c191cGRhdGVfa2luZCA9IE5ldmVyX2JlZW5fdXBkYXRlZDsgY3JlYXRlZF9hdCB9XG5cbmxldCByZWFsbHlfcnVuIHQgKG5vZGVfdXBkYXRlIDogXyBOb2RlX3VwZGF0ZS50KSA9XG4gIHQucHJldmlvdXNfdXBkYXRlX2tpbmRcbiAgPC0gKG1hdGNoIG5vZGVfdXBkYXRlIHdpdGhcbiAgICB8IE5lY2Vzc2FyeSBfIC0+IE5lY2Vzc2FyeVxuICAgIHwgQ2hhbmdlZCBfIC0+IENoYW5nZWRcbiAgICB8IEludmFsaWRhdGVkIC0+IEludmFsaWRhdGVkXG4gICAgfCBVbm5lY2Vzc2FyeSAtPiBVbm5lY2Vzc2FyeSk7XG4gIHQuZiBub2RlX3VwZGF0ZVxuOztcblxubGV0IHJ1biB0IChub2RlX3VwZGF0ZSA6IF8gTm9kZV91cGRhdGUudCkgfm5vdyA9XG4gICgqIFdlIG9ubHkgcnVuIHRoZSBoYW5kbGVyIGlmIHdhcyBjcmVhdGVkIGluIGFuIGVhcmxpZXIgc3RhYmlsaXphdGlvbiBjeWNsZS4gIElmIHRoZVxuICAgICBoYW5kbGVyIHdhcyBjcmVhdGVkIGJ5IGFub3RoZXIgb24tdXBkYXRlIGhhbmRsZXIgZHVyaW5nIHRoZSBydW5uaW5nIG9mIG9uLXVwZGF0ZVxuICAgICBoYW5kbGVycyBpbiB0aGUgY3VycmVudCBzdGFiaWxpemF0aW9uLCB3ZSB0cmVhdCB0aGUgYWRkZWQgaGFuZGxlciBhcyBpZiBpdCB3ZXJlIGFkZGVkXG4gICAgIGFmdGVyIHRoaXMgc3RhYmlsaXphdGlvbiBmaW5pc2hlZC4gIFdlIHdpbGwgcnVuIGl0IGF0IHRoZSBuZXh0IHN0YWJpbGl6YXRpb24sIGJlY2F1c2VcbiAgICAgdGhlIG5vZGUgd2l0aCB0aGUgaGFuZGxlciB3YXMgcHVzaGVkIG9uIFtzdGF0ZS5oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0uICopXG4gIGlmIFN0YWJpbGl6YXRpb25fbnVtLmNvbXBhcmUgdC5jcmVhdGVkX2F0IG5vdyA8IDBcbiAgdGhlbiAoXG4gICAgbWF0Y2ggdC5wcmV2aW91c191cGRhdGVfa2luZCwgbm9kZV91cGRhdGUgd2l0aFxuICAgICgqIE9uY2UgYSBub2RlIGlzIGludmFsaWRhdGVkLCB0aGVyZSB3aWxsIG5ldmVyIGJlIGZ1cnRoZXIgaW5mb3JtYXRpb24gdG8gcHJvdmlkZSxcbiAgICAgICBzaW5jZSBpbmNyZW1lbnRhbCBkb2VzIG5vdCBhbGxvdyBhbiBpbnZhbGlkIG5vZGUgdG8gYmVjb21lIHZhbGlkLiAqKVxuICAgIHwgSW52YWxpZGF0ZWQsIF8gLT4gKClcbiAgICAoKiBUaGVzZSBjYXNlcyBjYW4gaGFwcGVuIGlmIGEgbm9kZSBpcyBoYW5kbGVkIGFmdGVyIHN0YWJpbGl6YXRpb24gZHVlIHRvIGFub3RoZXJcbiAgICAgICBoYW5kbGVyLiAgQnV0IGZvciB0aGUgY3VycmVudCBoYW5kbGVyLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGJlY2F1c2UgdGhlcmUgaXMgbm9cbiAgICAgICBuZXcgaW5mb3JtYXRpb24gdG8gcHJvdmlkZS4gKilcbiAgICB8IENoYW5nZWQsIE5lY2Vzc2FyeSBfIHwgTmVjZXNzYXJ5LCBOZWNlc3NhcnkgXyB8IFVubmVjZXNzYXJ5LCBVbm5lY2Vzc2FyeSAtPiAoKVxuICAgICgqIElmIHRoaXMgaGFuZGxlciBoYXNuJ3Qgc2VlbiBhIG5vZGUgdGhhdCBpcyBjaGFuZ2luZywgd2UgdHJlYXQgdGhlIHVwZGF0ZSBhcyBhblxuICAgICAgIGluaXRpYWxpemF0aW9uLiAqKVxuICAgIHwgKE5ldmVyX2JlZW5fdXBkYXRlZCB8IFVubmVjZXNzYXJ5KSwgQ2hhbmdlZCAoXywgYSkgLT4gcmVhbGx5X3J1biB0IChOZWNlc3NhcnkgYSlcbiAgICAoKiBBbGwgb3RoZXIgdXBkYXRlcyBhcmUgcnVuIGFzIGlzLiAqKVxuICAgIHwgTmV2ZXJfYmVlbl91cGRhdGVkLCAoTmVjZXNzYXJ5IF8gfCBVbm5lY2Vzc2FyeSB8IEludmFsaWRhdGVkKVxuICAgIHwgVW5uZWNlc3NhcnksIChOZWNlc3NhcnkgXyB8IEludmFsaWRhdGVkKVxuICAgIHwgTmVjZXNzYXJ5LCAoQ2hhbmdlZCBfIHwgVW5uZWNlc3NhcnkgfCBJbnZhbGlkYXRlZClcbiAgICB8IENoYW5nZWQsIChDaGFuZ2VkIF8gfCBVbm5lY2Vzc2FyeSB8IEludmFsaWRhdGVkKSAtPiByZWFsbHlfcnVuIHQgbm9kZV91cGRhdGUpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgeyBleG4gOiBleG5cbiAgOyBiYWNrdHJhY2UgOiBCYWNrdHJhY2UudFxuICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgY3JlYXRlIGV4biA9IHsgZXhuOyBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIH1cbiIsIigqIFRoaXMgbW9kdWxlIGhhcyBhIGdpYW50IFttb2R1bGUgcmVjXSBkZWZpbmluZyBhbGwgdGhlIG11dHVhbGx5IHJlY3Vyc2l2ZSB0eXBlcyB1c2VkXG4gICBpbiB0aGUgaW1wbGVtZW50YXRpb24uICBUaGUgZGVmaW5pdGlvbiBvZiBlYWNoIHR5cGUgaXMgdGhlbiByZXBlYXRlZCBpbiBpdHMgZmlsZTtcbiAgIGNvbW1lbnRzIGJlbG9uZyB0aGVyZSwgbm90IGhlcmUuXG5cbiAgIFdlIHB1dCBqdXN0IGVub3VnaCBzZXhwIGNvbnZlcnRlcnMgaGVyZSB0byBkaXNwbGF5IG5vZGUgaWRzLiAgVGhlIGRldGFpbGVkIHNleHBcbiAgIGNvbnZlcnRlcnMgYXJlIGdlbmVyYXRlZCB2aWEgW3dpdGggc2V4cF0gaW4gdGhlIGluZGl2aWR1YWwgZmlsZXMuICBEZWZpbmluZyB0aGUgc2V4cFxuICAgY29udmVydGVycyBvdXRzaWRlIG9mIHRoZSBbbW9kdWxlIHJlY10gbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBhY2NpZGVudGFsbHkgaW50cm9kdWNlIGFcbiAgIHNleHAgY29udmVydGVyIHRoYXQgd291bGQgdHJ5IHRvIHByb2R1Y2UgYW4gaW5maW5pdGUgc2V4cC5cbiopXG5cbm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcblxubW9kdWxlIHJlYyBBZGp1c3RfaGVpZ2h0c19oZWFwIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgIDsgbXV0YWJsZSBoZWlnaHRfbG93ZXJfYm91bmQgOiBpbnRcbiAgICA7IG11dGFibGUgbWF4X2hlaWdodF9zZWVuIDogaW50XG4gICAgOyBtdXRhYmxlIG5vZGVzX2J5X2hlaWdodCA6IE5vZGUuUGFja2VkLnQgVW9wdC50IFVuaWZvcm1fYXJyYXkudFxuICAgIH1cbmVuZCA9XG4gIEFkanVzdF9oZWlnaHRzX2hlYXBcblxuYW5kIEFsYXJtIDogc2lnXG4gIHR5cGUgdCA9IEFsYXJtX3ZhbHVlLnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbmVuZCA9XG4gIEFsYXJtXG5cbmFuZCBBbGFybV92YWx1ZSA6IHNpZ1xuICBtb2R1bGUgQWN0aW9uIDogc2lnXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQXQgb2YgQXQudFxuICAgICAgfCBBdF9pbnRlcnZhbHMgb2YgQXRfaW50ZXJ2YWxzLnRcbiAgICAgIHwgU25hcHNob3QgOiBfIFNuYXBzaG90LnQgLT4gdFxuICAgICAgfCBTdGVwX2Z1bmN0aW9uIDogXyBTdGVwX2Z1bmN0aW9uX25vZGUudCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgdCA9XG4gICAgeyBhY3Rpb24gOiBBY3Rpb24udFxuICAgIDsgbXV0YWJsZSBuZXh0X2ZpcmVkIDogdCBVb3B0LnRcbiAgICB9XG5lbmQgPVxuICBBbGFybV92YWx1ZVxuXG5hbmQgQXJyYXlfZm9sZCA6IHNpZ1xuICB0eXBlICgnYSwgJ2FjYykgdCA9XG4gICAgeyBpbml0IDogJ2FjY1xuICAgIDsgZiA6ICdhY2MgLT4gJ2EgLT4gJ2FjY1xuICAgIDsgY2hpbGRyZW4gOiAnYSBOb2RlLnQgYXJyYXlcbiAgICB9XG5lbmQgPVxuICBBcnJheV9mb2xkXG5cbmFuZCBBdCA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbWFpbiA6IEJlZm9yZV9vcl9hZnRlci50IE5vZGUudFxuICAgIDsgYXQgOiBUaW1lX25zLnRcbiAgICA7IG11dGFibGUgYWxhcm0gOiBBbGFybS50XG4gICAgOyBjbG9jayA6IENsb2NrLnRcbiAgICB9XG5lbmQgPVxuICBBdFxuXG5hbmQgQXRfaW50ZXJ2YWxzIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgeyBtYWluIDogdW5pdCBOb2RlLnRcbiAgICA7IGJhc2UgOiBUaW1lX25zLnRcbiAgICA7IGludGVydmFsIDogVGltZV9ucy5TcGFuLnRcbiAgICA7IG11dGFibGUgYWxhcm0gOiBBbGFybS50XG4gICAgOyBjbG9jayA6IENsb2NrLnRcbiAgICB9XG5lbmQgPVxuICBBdF9pbnRlcnZhbHNcblxuYW5kIEJpbmQgOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB7IG1haW4gOiAnYiBOb2RlLnRcbiAgICA7IG11dGFibGUgZiA6ICdhIC0+ICdiIE5vZGUudFxuICAgIDsgbGhzIDogJ2EgTm9kZS50XG4gICAgOyBsaHNfY2hhbmdlIDogdW5pdCBOb2RlLnRcbiAgICA7IG11dGFibGUgcmhzIDogJ2IgTm9kZS50IFVvcHQudFxuICAgIDsgbXV0YWJsZSByaHNfc2NvcGUgOiBTY29wZS50XG4gICAgOyBtdXRhYmxlIGFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyA6IE5vZGUuUGFja2VkLnQgVW9wdC50XG4gICAgfVxuZW5kID1cbiAgQmluZFxuXG5hbmQgQ2xvY2sgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IHRpbWluZ193aGVlbCA6IEFsYXJtX3ZhbHVlLnQgVGltaW5nX3doZWVsLnRcbiAgICA7IG5vdyA6IFRpbWVfbnMudCBWYXIudFxuICAgIDsgaGFuZGxlX2ZpcmVkIDogQWxhcm0udCAtPiB1bml0XG4gICAgOyBtdXRhYmxlIGZpcmVkX2FsYXJtX3ZhbHVlcyA6IEFsYXJtX3ZhbHVlLnQgVW9wdC50XG4gICAgfVxuZW5kID1cbiAgQ2xvY2tcblxuYW5kIEV4cGVydCA6IHNpZ1xuICB0eXBlICdhIGVkZ2UgPVxuICAgIHsgY2hpbGQgOiAnYSBOb2RlLnRcbiAgICA7IG9uX2NoYW5nZSA6ICdhIC0+IHVuaXRcbiAgICA7IG11dGFibGUgaW5kZXggOiBpbnQgVW9wdC50XG4gICAgfVxuXG4gIHR5cGUgcGFja2VkX2VkZ2UgPSBFIDogJ2EgZWRnZSAtPiBwYWNrZWRfZWRnZSBbQEB1bmJveGVkXVxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBmIDogdW5pdCAtPiAnYVxuICAgIDsgb25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgOiBpc19ub3dfb2JzZXJ2YWJsZTpib29sIC0+IHVuaXRcbiAgICA7IG11dGFibGUgY2hpbGRyZW4gOiBwYWNrZWRfZWRnZSBVb3B0LnQgVW5pZm9ybV9hcnJheS50XG4gICAgOyBtdXRhYmxlIG51bV9jaGlsZHJlbiA6IGludFxuICAgIDsgbXV0YWJsZSBmb3JjZV9zdGFsZSA6IGJvb2xcbiAgICA7IG11dGFibGUgbnVtX2ludmFsaWRfY2hpbGRyZW4gOiBpbnRcbiAgICA7IG11dGFibGUgd2lsbF9maXJlX2FsbF9jYWxsYmFja3MgOiBib29sXG4gICAgfVxuZW5kID1cbiAgRXhwZXJ0XG5cbmFuZCBGcmVlemUgOiBzaWdcbiAgdHlwZSAnYSB0ID1cbiAgICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgICA7IGNoaWxkIDogJ2EgTm9kZS50XG4gICAgOyBvbmx5X2ZyZWV6ZV93aGVuIDogJ2EgLT4gYm9vbFxuICAgIH1cbmVuZCA9XG4gIEZyZWV6ZVxuXG5hbmQgSWZfdGhlbl9lbHNlIDogc2lnXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBtYWluIDogJ2EgTm9kZS50XG4gICAgOyB0ZXN0IDogYm9vbCBOb2RlLnRcbiAgICA7IHRlc3RfY2hhbmdlIDogdW5pdCBOb2RlLnRcbiAgICA7IG11dGFibGUgY3VycmVudF9icmFuY2ggOiAnYSBOb2RlLnQgVW9wdC50XG4gICAgOyB0aGVuXyA6ICdhIE5vZGUudFxuICAgIDsgZWxzZV8gOiAnYSBOb2RlLnRcbiAgICB9XG5lbmQgPVxuICBJZl90aGVuX2Vsc2VcblxuYW5kIEludGVybmFsX29ic2VydmVyIDogc2lnXG4gIG1vZHVsZSBTdGF0ZSA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IENyZWF0ZWRcbiAgICAgIHwgSW5fdXNlXG4gICAgICB8IERpc2FsbG93ZWRcbiAgICAgIHwgVW5saW5rZWRcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IG11dGFibGUgc3RhdGUgOiBTdGF0ZS50XG4gICAgOyBvYnNlcnZpbmcgOiAnYSBOb2RlLnRcbiAgICA7IG11dGFibGUgb25fdXBkYXRlX2hhbmRsZXJzIDogJ2EgT25fdXBkYXRlX2hhbmRsZXIudCBsaXN0XG4gICAgOyBtdXRhYmxlIHByZXZfaW5fYWxsIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgVW9wdC50XG4gICAgOyBtdXRhYmxlIG5leHRfaW5fYWxsIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgVW9wdC50XG4gICAgOyBtdXRhYmxlIHByZXZfaW5fb2JzZXJ2aW5nIDogJ2EgdCBVb3B0LnRcbiAgICA7IG11dGFibGUgbmV4dF9pbl9vYnNlcnZpbmcgOiAnYSB0IFVvcHQudFxuICAgIH1cblxuICB0eXBlICdhIGludGVybmFsX29ic2VydmVyID0gJ2EgdFxuXG4gIG1vZHVsZSBQYWNrZWQgOiBzaWdcbiAgICB0eXBlIHQgPSBUIDogXyBpbnRlcm5hbF9vYnNlcnZlciAtPiB0IFtAQHVuYm94ZWRdXG4gIGVuZFxuZW5kID1cbiAgSW50ZXJuYWxfb2JzZXJ2ZXJcblxuYW5kIEpvaW4gOiBzaWdcbiAgdHlwZSAnYSB0ID1cbiAgICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgICA7IGxocyA6ICdhIE5vZGUudCBOb2RlLnRcbiAgICA7IGxoc19jaGFuZ2UgOiB1bml0IE5vZGUudFxuICAgIDsgbXV0YWJsZSByaHMgOiAnYSBOb2RlLnQgVW9wdC50XG4gICAgfVxuZW5kID1cbiAgSm9pblxuXG5hbmQgS2luZCA6IHNpZ1xuICB0eXBlICdhIHQgPVxuICAgIHwgQXJyYXlfZm9sZCA6IChfLCAnYSkgQXJyYXlfZm9sZC50IC0+ICdhIHRcbiAgICB8IEF0IDogQXQudCAtPiBCZWZvcmVfb3JfYWZ0ZXIudCB0XG4gICAgfCBBdF9pbnRlcnZhbHMgOiBBdF9pbnRlcnZhbHMudCAtPiB1bml0IHRcbiAgICB8IEJpbmRfbGhzX2NoYW5nZSA6IChfLCBfKSBCaW5kLnQgLT4gdW5pdCB0XG4gICAgfCBCaW5kX21haW4gOiAoXywgJ2EpIEJpbmQudCAtPiAnYSB0XG4gICAgfCBDb25zdCBvZiAnYVxuICAgIHwgRXhwZXJ0IG9mICdhIEV4cGVydC50XG4gICAgfCBGcmVlemUgb2YgJ2EgRnJlZXplLnRcbiAgICB8IElmX3Rlc3RfY2hhbmdlIDogXyBJZl90aGVuX2Vsc2UudCAtPiB1bml0IHRcbiAgICB8IElmX3RoZW5fZWxzZSBvZiAnYSBJZl90aGVuX2Vsc2UudFxuICAgIHwgSW52YWxpZFxuICAgIHwgSm9pbl9saHNfY2hhbmdlIDogXyBKb2luLnQgLT4gdW5pdCB0XG4gICAgfCBKb2luX21haW4gb2YgJ2EgSm9pbi50XG4gICAgfCBNYXAgOiAoJ2ExIC0+ICdhKSAqICdhMSBOb2RlLnQgLT4gJ2EgdFxuICAgIHwgU25hcHNob3Qgb2YgJ2EgU25hcHNob3QudFxuICAgIHwgU3RlcF9mdW5jdGlvbiBvZiAnYSBTdGVwX2Z1bmN0aW9uX25vZGUudFxuICAgIHwgVW5pbml0aWFsaXplZFxuICAgIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgOiAoXywgJ2EpIFVub3JkZXJlZF9hcnJheV9mb2xkLnQgLT4gJ2EgdFxuICAgIHwgVmFyIG9mICdhIFZhci50XG4gICAgfCBNYXAyIDogKCdhMSAtPiAnYTIgLT4gJ2EpICogJ2ExIE5vZGUudCAqICdhMiBOb2RlLnQgLT4gJ2EgdFxuICAgIHwgTWFwMyA6ICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYSkgKiAnYTEgTm9kZS50ICogJ2EyIE5vZGUudCAqICdhMyBOb2RlLnQgLT4gJ2EgdFxuICAgIHwgTWFwNCA6XG4gICAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2EpXG4gICAgICAgICogJ2ExIE5vZGUudFxuICAgICAgICAqICdhMiBOb2RlLnRcbiAgICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAgICogJ2E0IE5vZGUudFxuICAgICAgICAtPiAnYSB0XG4gICAgfCBNYXA1IDpcbiAgICAgICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2EpXG4gICAgICAgICogJ2ExIE5vZGUudFxuICAgICAgICAqICdhMiBOb2RlLnRcbiAgICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAgICogJ2E0IE5vZGUudFxuICAgICAgICAqICdhNSBOb2RlLnRcbiAgICAgICAgLT4gJ2EgdFxuICAgIHwgTWFwNiA6XG4gICAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgLT4gJ2EgdFxuICAgIHwgTWFwNyA6XG4gICAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2EpXG4gICAgICAgICogJ2ExIE5vZGUudFxuICAgICAgICAqICdhMiBOb2RlLnRcbiAgICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAgICogJ2E0IE5vZGUudFxuICAgICAgICAqICdhNSBOb2RlLnRcbiAgICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAgICogJ2E3IE5vZGUudFxuICAgICAgICAtPiAnYSB0XG4gICAgfCBNYXA4IDpcbiAgICAgICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYTggLT4gJ2EpXG4gICAgICAgICogJ2ExIE5vZGUudFxuICAgICAgICAqICdhMiBOb2RlLnRcbiAgICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAgICogJ2E0IE5vZGUudFxuICAgICAgICAqICdhNSBOb2RlLnRcbiAgICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAgICogJ2E3IE5vZGUudFxuICAgICAgICAqICdhOCBOb2RlLnRcbiAgICAgICAgLT4gJ2EgdFxuICAgIHwgTWFwOSA6XG4gICAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2E4IC0+ICdhOSAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAgICogJ2E4IE5vZGUudFxuICAgICAgICAqICdhOSBOb2RlLnRcbiAgICAgICAgLT4gJ2EgdFxuICAgIHwgTWFwMTAgOlxuICAgICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhOCAtPiAnYTkgLT4gJ2ExMCAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAgICogJ2E4IE5vZGUudFxuICAgICAgICAqICdhOSBOb2RlLnRcbiAgICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgICAtPiAnYSB0XG4gICAgfCBNYXAxMSA6XG4gICAgICAgICgnYTFcbiAgICAgICAgIC0+ICdhMlxuICAgICAgICAgLT4gJ2EzXG4gICAgICAgICAtPiAnYTRcbiAgICAgICAgIC0+ICdhNVxuICAgICAgICAgLT4gJ2E2XG4gICAgICAgICAtPiAnYTdcbiAgICAgICAgIC0+ICdhOFxuICAgICAgICAgLT4gJ2E5XG4gICAgICAgICAtPiAnYTEwXG4gICAgICAgICAtPiAnYTExXG4gICAgICAgICAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAgICogJ2E4IE5vZGUudFxuICAgICAgICAqICdhOSBOb2RlLnRcbiAgICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgICAqICdhMTEgTm9kZS50XG4gICAgICAgIC0+ICdhIHRcbiAgICB8IE1hcDEyIDpcbiAgICAgICAgKCdhMVxuICAgICAgICAgLT4gJ2EyXG4gICAgICAgICAtPiAnYTNcbiAgICAgICAgIC0+ICdhNFxuICAgICAgICAgLT4gJ2E1XG4gICAgICAgICAtPiAnYTZcbiAgICAgICAgIC0+ICdhN1xuICAgICAgICAgLT4gJ2E4XG4gICAgICAgICAtPiAnYTlcbiAgICAgICAgIC0+ICdhMTBcbiAgICAgICAgIC0+ICdhMTFcbiAgICAgICAgIC0+ICdhMTJcbiAgICAgICAgIC0+ICdhKVxuICAgICAgICAqICdhMSBOb2RlLnRcbiAgICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAgICogJ2EzIE5vZGUudFxuICAgICAgICAqICdhNCBOb2RlLnRcbiAgICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAgICogJ2E2IE5vZGUudFxuICAgICAgICAqICdhNyBOb2RlLnRcbiAgICAgICAgKiAnYTggTm9kZS50XG4gICAgICAgICogJ2E5IE5vZGUudFxuICAgICAgICAqICdhMTAgTm9kZS50XG4gICAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICAgKiAnYTEyIE5vZGUudFxuICAgICAgICAtPiAnYSB0XG4gICAgfCBNYXAxMyA6XG4gICAgICAgICgnYTFcbiAgICAgICAgIC0+ICdhMlxuICAgICAgICAgLT4gJ2EzXG4gICAgICAgICAtPiAnYTRcbiAgICAgICAgIC0+ICdhNVxuICAgICAgICAgLT4gJ2E2XG4gICAgICAgICAtPiAnYTdcbiAgICAgICAgIC0+ICdhOFxuICAgICAgICAgLT4gJ2E5XG4gICAgICAgICAtPiAnYTEwXG4gICAgICAgICAtPiAnYTExXG4gICAgICAgICAtPiAnYTEyXG4gICAgICAgICAtPiAnYTEzXG4gICAgICAgICAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAgICogJ2E4IE5vZGUudFxuICAgICAgICAqICdhOSBOb2RlLnRcbiAgICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgICAqICdhMTEgTm9kZS50XG4gICAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgICAgKiAnYTEzIE5vZGUudFxuICAgICAgICAtPiAnYSB0XG4gICAgfCBNYXAxNCA6XG4gICAgICAgICgnYTFcbiAgICAgICAgIC0+ICdhMlxuICAgICAgICAgLT4gJ2EzXG4gICAgICAgICAtPiAnYTRcbiAgICAgICAgIC0+ICdhNVxuICAgICAgICAgLT4gJ2E2XG4gICAgICAgICAtPiAnYTdcbiAgICAgICAgIC0+ICdhOFxuICAgICAgICAgLT4gJ2E5XG4gICAgICAgICAtPiAnYTEwXG4gICAgICAgICAtPiAnYTExXG4gICAgICAgICAtPiAnYTEyXG4gICAgICAgICAtPiAnYTEzXG4gICAgICAgICAtPiAnYTE0XG4gICAgICAgICAtPiAnYSlcbiAgICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAgICogJ2EyIE5vZGUudFxuICAgICAgICAqICdhMyBOb2RlLnRcbiAgICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAgICogJ2E1IE5vZGUudFxuICAgICAgICAqICdhNiBOb2RlLnRcbiAgICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAgICogJ2E4IE5vZGUudFxuICAgICAgICAqICdhOSBOb2RlLnRcbiAgICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgICAqICdhMTEgTm9kZS50XG4gICAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgICAgKiAnYTEzIE5vZGUudFxuICAgICAgICAqICdhMTQgTm9kZS50XG4gICAgICAgIC0+ICdhIHRcbiAgICB8IE1hcDE1IDpcbiAgICAgICAgKCdhMVxuICAgICAgICAgLT4gJ2EyXG4gICAgICAgICAtPiAnYTNcbiAgICAgICAgIC0+ICdhNFxuICAgICAgICAgLT4gJ2E1XG4gICAgICAgICAtPiAnYTZcbiAgICAgICAgIC0+ICdhN1xuICAgICAgICAgLT4gJ2E4XG4gICAgICAgICAtPiAnYTlcbiAgICAgICAgIC0+ICdhMTBcbiAgICAgICAgIC0+ICdhMTFcbiAgICAgICAgIC0+ICdhMTJcbiAgICAgICAgIC0+ICdhMTNcbiAgICAgICAgIC0+ICdhMTRcbiAgICAgICAgIC0+ICdhMTVcbiAgICAgICAgIC0+ICdhKVxuICAgICAgICAqICdhMSBOb2RlLnRcbiAgICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAgICogJ2EzIE5vZGUudFxuICAgICAgICAqICdhNCBOb2RlLnRcbiAgICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAgICogJ2E2IE5vZGUudFxuICAgICAgICAqICdhNyBOb2RlLnRcbiAgICAgICAgKiAnYTggTm9kZS50XG4gICAgICAgICogJ2E5IE5vZGUudFxuICAgICAgICAqICdhMTAgTm9kZS50XG4gICAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICAgKiAnYTEyIE5vZGUudFxuICAgICAgICAqICdhMTMgTm9kZS50XG4gICAgICAgICogJ2ExNCBOb2RlLnRcbiAgICAgICAgKiAnYTE1IE5vZGUudFxuICAgICAgICAtPiAnYSB0XG5lbmQgPVxuICBLaW5kXG5cbmFuZCBOb2RlIDogc2lnXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBpZCA6IE5vZGVfaWQudFxuICAgIDsgc3RhdGUgOiBTdGF0ZS50XG4gICAgOyBtdXRhYmxlIHJlY29tcHV0ZWRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gICAgOyBtdXRhYmxlIHZhbHVlX29wdCA6ICdhIFVvcHQudFxuICAgIDsgbXV0YWJsZSBraW5kIDogJ2EgS2luZC50XG4gICAgOyBtdXRhYmxlIGN1dG9mZiA6ICdhIEN1dG9mZi50XG4gICAgOyBtdXRhYmxlIGNoYW5nZWRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gICAgOyBtdXRhYmxlIG51bV9vbl91cGRhdGVfaGFuZGxlcnMgOiBpbnRcbiAgICA7IG11dGFibGUgbnVtX3BhcmVudHMgOiBpbnRcbiAgICA7XG4gICAgICBtdXRhYmxlIHBhcmVudDFfYW5kX2JleW9uZCA6IE5vZGUuUGFja2VkLnQgVW9wdC50IFVuaWZvcm1fYXJyYXkudFxuICAgIDsgbXV0YWJsZSBwYXJlbnQwIDogTm9kZS5QYWNrZWQudCBVb3B0LnRcbiAgICA7IG11dGFibGUgY3JlYXRlZF9pbiA6IFNjb3BlLnRcbiAgICA7IG11dGFibGUgbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUgOiBOb2RlLlBhY2tlZC50IFVvcHQudFxuICAgIDsgbXV0YWJsZSBoZWlnaHQgOiBpbnRcbiAgICA7IG11dGFibGUgaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwIDogaW50XG4gICAgOyBtdXRhYmxlIHByZXZfaW5fcmVjb21wdXRlX2hlYXAgOiBOb2RlLlBhY2tlZC50IFVvcHQudFxuICAgIDsgbXV0YWJsZSBuZXh0X2luX3JlY29tcHV0ZV9oZWFwIDogTm9kZS5QYWNrZWQudCBVb3B0LnRcbiAgICA7IG11dGFibGUgaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgOiBpbnRcbiAgICA7IG11dGFibGUgbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDogTm9kZS5QYWNrZWQudCBVb3B0LnRcbiAgICA7IG11dGFibGUgb2xkX3ZhbHVlX29wdCA6ICdhIFVvcHQudFxuICAgIDsgbXV0YWJsZSBvYnNlcnZlcnMgOiAnYSBJbnRlcm5hbF9vYnNlcnZlci50IFVvcHQudFxuICAgIDsgbXV0YWJsZSBpc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiA6IGJvb2xcbiAgICA7IG11dGFibGUgb25fdXBkYXRlX2hhbmRsZXJzIDogJ2EgT25fdXBkYXRlX2hhbmRsZXIudCBsaXN0XG4gICAgOyBtdXRhYmxlIG15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleCA6IGludCBhcnJheVxuICAgIDsgbXV0YWJsZSBteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXggOiBpbnQgYXJyYXlcbiAgICA7IG11dGFibGUgZm9yY2VfbmVjZXNzYXJ5IDogYm9vbFxuICAgIDsgbXV0YWJsZSB1c2VyX2luZm8gOiBEb3RfdXNlcl9pbmZvLnQgb3B0aW9uXG4gICAgOyBjcmVhdGlvbl9iYWNrdHJhY2UgOiBCYWNrdHJhY2UudCBvcHRpb25cbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbW9kdWxlIFBhY2tlZCA6IHNpZ1xuICAgIHR5cGUgJ2Egbm9kZSA9ICdhIHRcbiAgICB0eXBlIHQgPSBUIDogXyBub2RlIC0+IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl0gW0BAdW5ib3hlZF1cbiAgZW5kXG5cbiAgdmFsIGlzX3ZhbGlkIDogXyB0IC0+IGJvb2xcbiAgdmFsIGlzX25lY2Vzc2FyeSA6IF8gdCAtPiBib29sXG4gIHZhbCB0eXBlX2VxdWFsX2lmX3BoeXNfc2FtZSA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSAoXG4gICAgTm9kZSA6XG4gICAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTm9kZVxuICAgIGVuZFxuICAgIHdpdGggbW9kdWxlIFBhY2tlZCA6PSBOb2RlLlBhY2tlZClcblxuICBsZXQgc2V4cF9vZl90IF8gdCA9IGNvbmNhdCBbIFwiblwiOyBOb2RlX2lkLnRvX3N0cmluZyB0LmlkIF0gfD4gWyVzZXhwX29mOiBzdHJpbmddXG5cbiAgbW9kdWxlIFBhY2tlZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2Egbm9kZSA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICB0eXBlIHQgPSBUIDogXyBub2RlIC0+IHQgW0BAdW5ib3hlZF1cblxuICAgIGxldCBzZXhwX29mX3QgKFQgdCkgPSB0IHw+IFslc2V4cF9vZjogXyBub2RlXVxuICBlbmRcblxuICBsZXQgaXNfdmFsaWQgdCA9XG4gICAgbWF0Y2ggdC5raW5kIHdpdGhcbiAgICB8IEludmFsaWQgLT4gZmFsc2VcbiAgICB8IF8gLT4gdHJ1ZVxuICA7O1xuXG4gICgqIFtpc19uZWNlc3NhcnldIGlzIGRlZmluZWQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgaXQgYmVmb3JlIG5vZGUubWwgaXMgYXZhaWxhYmxlLiAgSXQgaXNcbiAgICAgdXNlZCBkdXJpbmcgZ3JhcGggbWFuaXB1bGF0aW9uLCBhbmQgc28gaXMgd3JpdHRlbiB3aXRoIHNvbWUgY2FyZSB0byBiZSBmYXN0LiAqKVxuICBsZXQgaXNfbmVjZXNzYXJ5IHQgPVxuICAgIHQubnVtX3BhcmVudHMgPiAwXG4gICAgfHwgVW9wdC5pc19zb21lIHQub2JzZXJ2ZXJzXG4gICAgfHwgKG1hdGNoIHQua2luZCB3aXRoXG4gICAgICB8IEZyZWV6ZSBfIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZSlcbiAgICB8fCB0LmZvcmNlX25lY2Vzc2FyeVxuICA7O1xuXG4gIGxldCB0X2lzX2luamVjdGl2ZSAodHlwZSBhIGIpIChUIDogKGEgdCwgYiB0KSBUeXBlX2VxdWFsLnQpIDogKGEsIGIpIFR5cGVfZXF1YWwudCA9IFRcblxuICBsZXQgdHlwZV9lcXVhbF9pZl9waHlzX3NhbWUgKHR5cGUgYSBiKSAodDEgOiBhIHQpICh0MiA6IGIgdCkgPVxuICAgICgqIFRoaXMgaXMgdHlwZS1zYWZlIGFzc3VtaW5nIG5vIG9uZSBjYW4gZ2l2ZSB0aGUgc2FtZSBpbmNyZW1lbnRhbCBub2RlIHR3byBkaWZmZXJlbnRcbiAgICAgICB0eXBlcy4gIFRoaXMgaXMgdHJ1ZSBiZWNhdXNlIHRoZSBmaWVsZCBbbXV0YWJsZSBvbGRfdmFsdWVfb3B0IDogJ2Egb3B0aW9uXSBwcmV2ZW50c1xuICAgICAgIGJvdGggc3VidHlwaW5nIGFuZCBwYXJhbWV0ZXJpYyBwb2x5bW9ycGhpc20uICBCdXQgdGhpcyBhbGxvd3MgdG8gYnJlYWtcbiAgICAgICBhYnN0cmFjdGlvbnMsIGFzIGluIHNvbWVvbmUgY291bGQgd3JpdGU6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0XG4gICAgICAgICB0eXBlIHUgKCogPSB0IHVuZGVybmVhdGggKilcbiAgICAgICAgIHZhbCBjcmVhdGUgOiB1bml0IC0+IHQgSW5jci50ICogdSBJbmNyLnQgKCogdGhlIHR3byBpbmNyZW1lbnRhbHMgYXJlIHBoeXNfZXF1YWwgKilcbiAgICAgICBdfVxuXG4gICAgICAgYW5kIHdlIHdvdWxkIGZpZ3VyZSBvdXQgdGhhdCB0eXBlIHQgPSB1LiAgSG93ZXZlciwgd2UgY291bGQgYWRkIGEgVHlwZV9lcXVhbC5JZCB0b1xuICAgICAgIG5vZGVzIGFuZCBkbyB0aGUgc2FtZSwgc28gaXQgc2VlbXMgdG8gYmUgYSBtb3JlIGdlbmVyYWwgaXNzdWUuICopXG4gICAgaWYgcGh5c19zYW1lIHQxIHQyXG4gICAgdGhlbiBTb21lICh0X2lzX2luamVjdGl2ZSAoT2JqLm1hZ2ljIChUIDogXyBUeXBlX2VxdWFsLnQpIDogKGEgdCwgYiB0KSBUeXBlX2VxdWFsLnQpKVxuICAgIGVsc2UgTm9uZVxuICA7O1xuZW5kXG5cbmFuZCBPYnNlcnZlciA6IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBJbnRlcm5hbF9vYnNlcnZlci50IHJlZlxuZW5kID1cbiAgT2JzZXJ2ZXJcblxuYW5kIE9ubHlfaW5fZGVidWcgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgY3VycmVudGx5X3J1bm5pbmdfbm9kZSA6IE5vZGUuUGFja2VkLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZSA6IE5vZGUuUGFja2VkLnQgbGlzdFxuICAgIH1cbmVuZCA9XG4gIE9ubHlfaW5fZGVidWdcblxuYW5kIFBhY2tlZF93ZWFrX2hhc2h0YmwgOiBzaWdcbiAgdHlwZSB0ID0gVCA6IChfLCBfKSBXZWFrX2hhc2h0YmwudCAtPiB0XG5lbmQgPVxuICBQYWNrZWRfd2Vha19oYXNodGJsXG5cbmFuZCBSZWNvbXB1dGVfaGVhcCA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICA7IG11dGFibGUgaGVpZ2h0X2xvd2VyX2JvdW5kIDogaW50XG4gICAgOyBtdXRhYmxlIG5vZGVzX2J5X2hlaWdodCA6IE5vZGUuUGFja2VkLnQgVW9wdC50IFVuaWZvcm1fYXJyYXkudFxuICAgIH1cbmVuZCA9XG4gIFJlY29tcHV0ZV9oZWFwXG5cbmFuZCBSdW5fb25fdXBkYXRlX2hhbmRsZXJzIDogc2lnXG4gIHR5cGUgdCA9IFQgOiAnYSBOb2RlLnQgKiAnYSBPbl91cGRhdGVfaGFuZGxlci5Ob2RlX3VwZGF0ZS50IC0+IHRcbmVuZCA9XG4gIFJ1bl9vbl91cGRhdGVfaGFuZGxlcnNcblxuYW5kIFNjb3BlIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgfCBUb3BcbiAgICB8IEJpbmQgOiAoXywgXykgQmluZC50IC0+IHRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgVG9wXG4gICAgfCBCaW5kIDogKF8sIF8pIEJpbmQudCAtPiB0XG5cbiAgbGV0IHNleHBfb2ZfdCA9IGZ1bmN0aW9uXG4gICAgfCBUb3AgLT4gXCJUb3BcIiB8PiBbJXNleHBfb2Y6IHN0cmluZ11cbiAgICB8IEJpbmQgYmluZCAtPiBiaW5kLm1haW4gfD4gWyVzZXhwX29mOiBfIE5vZGUudF1cbiAgOztcbmVuZFxuXG5hbmQgU25hcHNob3QgOiBzaWdcbiAgdHlwZSAnYSB0ID1cbiAgICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgICA7IGF0IDogVGltZV9ucy50XG4gICAgOyBiZWZvcmUgOiAnYVxuICAgIDsgdmFsdWVfYXQgOiAnYSBOb2RlLnRcbiAgICA7IGNsb2NrIDogQ2xvY2sudFxuICAgIH1cbmVuZCA9XG4gIFNuYXBzaG90XG5cbmFuZCBTdGF0ZSA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgIDsgYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3JocyA6IGJvb2xcbiAgICA7IG11dGFibGUgc3RhYmlsaXphdGlvbl9udW0gOiBTdGFiaWxpemF0aW9uX251bS50XG4gICAgOyBtdXRhYmxlIGN1cnJlbnRfc2NvcGUgOiBTY29wZS50XG4gICAgOyByZWNvbXB1dGVfaGVhcCA6IFJlY29tcHV0ZV9oZWFwLnRcbiAgICA7IGFkanVzdF9oZWlnaHRzX2hlYXAgOiBBZGp1c3RfaGVpZ2h0c19oZWFwLnRcbiAgICA7IHByb3BhZ2F0ZV9pbnZhbGlkaXR5IDogTm9kZS5QYWNrZWQudCBTdGFjay50XG4gICAgOyBtdXRhYmxlIG51bV9hY3RpdmVfb2JzZXJ2ZXJzIDogaW50XG4gICAgOyBtdXRhYmxlIGFsbF9vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBVb3B0LnRcbiAgICA7IGZpbmFsaXplZF9vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gICAgOyBuZXdfb2JzZXJ2ZXJzIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgU3RhY2sudFxuICAgIDsgZGlzYWxsb3dlZF9vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBTdGFjay50XG4gICAgOyBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gOiBWYXIuUGFja2VkLnQgU3RhY2sudFxuICAgIDsgaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gOiBOb2RlLlBhY2tlZC50IFN0YWNrLnRcbiAgICA7IHJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgOiBSdW5fb25fdXBkYXRlX2hhbmRsZXJzLnQgU3RhY2sudFxuICAgIDsgbXV0YWJsZSBvbmx5X2luX2RlYnVnIDogT25seV9pbl9kZWJ1Zy50XG4gICAgOyB3ZWFrX2hhc2h0YmxzIDogUGFja2VkX3dlYWtfaGFzaHRibC50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgICA7IG11dGFibGUga2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZSA6IGJvb2xcbiAgICA7IG11dGFibGUgbnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkgOiBpbnRcbiAgICA7IG11dGFibGUgbnVtX25vZGVzX2JlY2FtZV91bm5lY2Vzc2FyeSA6IGludFxuICAgIDsgbXV0YWJsZSBudW1fbm9kZXNfY2hhbmdlZCA6IGludFxuICAgIDsgbXV0YWJsZSBudW1fbm9kZXNfY3JlYXRlZCA6IGludFxuICAgIDsgbXV0YWJsZSBudW1fbm9kZXNfaW52YWxpZGF0ZWQgOiBpbnRcbiAgICA7IG11dGFibGUgbnVtX25vZGVzX3JlY29tcHV0ZWQgOiBpbnRcbiAgICA7IG11dGFibGUgbnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9vbmVfY2hpbGQgOiBpbnRcbiAgICA7IG11dGFibGUgbnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9taW5faGVpZ2h0IDogaW50XG4gICAgOyBtdXRhYmxlIG51bV92YXJfc2V0cyA6IGludFxuICAgIH1cbmVuZCA9XG4gIFN0YXRlXG5cbmFuZCBTdGF0dXMgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB8IFN0YWJpbGl6aW5nXG4gICAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVyc1xuICAgIHwgTm90X3N0YWJpbGl6aW5nXG4gICAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgb2YgUmFpc2VkX2V4bi50XG5lbmQgPVxuICBTdGF0dXNcblxuYW5kIFN0ZXBfZnVuY3Rpb25fbm9kZSA6IHNpZ1xuICB0eXBlICdhIHQgPVxuICAgIHsgbWFpbiA6ICdhIE5vZGUudFxuICAgIDsgbXV0YWJsZSBjaGlsZCA6ICdhIFN0ZXBfZnVuY3Rpb24udCBOb2RlLnQgVW9wdC50XG4gICAgOyBtdXRhYmxlIGV4dHJhY3RlZF9zdGVwX2Z1bmN0aW9uX2Zyb21fY2hpbGRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gICAgOyBtdXRhYmxlIHZhbHVlIDogJ2EgVW9wdC50XG4gICAgOyBtdXRhYmxlIHVwY29taW5nX3N0ZXBzIDogKFRpbWVfbnMudCAqICdhKSBTZXF1ZW5jZS50XG4gICAgOyBtdXRhYmxlIGFsYXJtIDogQWxhcm0udFxuICAgIDsgbXV0YWJsZSBhbGFybV92YWx1ZSA6IEFsYXJtX3ZhbHVlLnRcbiAgICA7IGNsb2NrIDogQ2xvY2sudFxuICAgIH1cbmVuZCA9XG4gIFN0ZXBfZnVuY3Rpb25fbm9kZVxuXG5hbmQgVW5vcmRlcmVkX2FycmF5X2ZvbGQgOiBzaWdcbiAgdHlwZSAoJ2EsICdhY2MpIHQgPVxuICAgIHsgbWFpbiA6ICdhY2MgTm9kZS50XG4gICAgOyBpbml0IDogJ2FjY1xuICAgIDsgZiA6ICdhY2MgLT4gJ2EgLT4gJ2FjY1xuICAgIDsgdXBkYXRlIDogJ2FjYyAtPiBvbGRfdmFsdWU6J2EgLT4gbmV3X3ZhbHVlOidhIC0+ICdhY2NcbiAgICA7IGZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgOiBpbnRcbiAgICA7IGNoaWxkcmVuIDogJ2EgTm9kZS50IGFycmF5XG4gICAgOyBtdXRhYmxlIGZvbGRfdmFsdWUgOiAnYWNjIFVvcHQudFxuICAgIDsgbXV0YWJsZSBudW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA6IGludFxuICAgIH1cbmVuZCA9XG4gIFVub3JkZXJlZF9hcnJheV9mb2xkXG5cbmFuZCBWYXIgOiBzaWdcbiAgdHlwZSAnYSB0ID1cbiAgICB7IG11dGFibGUgdmFsdWUgOiAnYVxuICAgIDsgbXV0YWJsZSB2YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gOiAnYSBVb3B0LnRcbiAgICA7IG11dGFibGUgc2V0X2F0IDogU3RhYmlsaXphdGlvbl9udW0udFxuICAgIDsgd2F0Y2ggOiAnYSBOb2RlLnRcbiAgICB9XG5cbiAgdHlwZSAnYSB2YXIgOj0gJ2EgdFxuXG4gIG1vZHVsZSBQYWNrZWQgOiBzaWdcbiAgICB0eXBlIHQgPSBUIDogXyB2YXIgLT4gdCBbQEB1bmJveGVkXVxuICBlbmRcbmVuZCA9XG4gIFZhclxuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5WYXIudCA9XG4gIHsgbXV0YWJsZSB2YWx1ZSA6ICdhXG4gIDsgKCogW3ZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbl0gaXMgb25seSBzZXQgdG8gW1VvcHQuc29tZV0gaWYgdGhlIHVzZXIgY2FsbHNcbiAgICAgICBbVmFyLnNldF0gZHVyaW5nIHN0YWJpbGl6YXRpb24sIGluIHdoaWNoIGNhc2UgaXQgaG9sZHMgdGhlIChsYXN0KSB2YWx1ZSBzZXQuICBBdFxuICAgICAgIHRoZSBlbmQgb2Ygc3RhYmlsaXphdGlvbiwgYWxsIHN1Y2ggdmFyaWFibGVzIGFyZSBwcm9jZXNzZWQgdG8gZG8gW3QudmFsdWUgPC1cbiAgICAgICB0LnZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbl0uICopXG4gICAgbXV0YWJsZSB2YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gOiAnYSBVb3B0LnRcbiAgOyAoKiBbc2V0X2F0XSB0aGUgc3RhYmlsaXphdGlvbiBudW1iZXIgaW4gZWZmZWN0IHRoZSBtb3N0IHJlY2VudCB0aW1lIFt0LnZhbHVlXSBjaGFuZ2VkLlxuICAgICAgIFRoaXMgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHRoZSBzdGFiaWxpemF0aW9uIG51bWJlciBpbiBlZmZlY3QgdGhlIG1vc3RcbiAgICAgICByZWNlbnQgdGltZSBbVmFyLnNldCB0XSB3YXMgY2FsbGVkLCBkdWUgdG8gdGhlIGVmZmVjdCBvZiBbVmFyLnNldF0gZHVyaW5nXG4gICAgICAgc3RhYmlsaXphdGlvbiBiZWluZyBkZWxheWVkIHVudGlsIGFmdGVyIHRoZSBzdGFiaWxpemF0aW9uLiAqKVxuICAgIG11dGFibGUgc2V0X2F0IDogU3RhYmlsaXphdGlvbl9udW0udFxuICA7IHdhdGNoIDogJ2EgTm9kZS50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfnZhbHVlOihjaGVjayBpbnZhcmlhbnRfYSlcbiAgICAgIH52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb246KGNoZWNrIChVb3B0LmludmFyaWFudCBpbnZhcmlhbnRfYSkpXG4gICAgICB+c2V0X2F0OihjaGVjayBTdGFiaWxpemF0aW9uX251bS5pbnZhcmlhbnQpXG4gICAgICB+d2F0Y2g6XG4gICAgICAgIChjaGVjayAoZnVuICh3YXRjaCA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBtYXRjaCB3YXRjaC5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpICgqIHBvc3NpYmxlIHdpdGggW351c2VfY3VycmVudF9zY29wZTp0cnVlXSAqKVxuICAgICAgICAgICB8IFZhciB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpKVxuOztcblxubGV0IGluY3Jfc3RhdGUgdCA9IHQud2F0Y2guc3RhdGVcblxubW9kdWxlIFBhY2tlZCA9IHN0cnVjdFxuICB0eXBlICdhIHZhciA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSB0ID0gVHlwZXMuVmFyLlBhY2tlZC50ID0gVCA6IF8gdmFyIC0+IHQgW0BAdW5ib3hlZF0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgbGF0ZXN0X3ZhbHVlIHQgPVxuICBpZiBVb3B0LmlzX3NvbWUgdC52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb25cbiAgdGhlbiBVb3B0LnVuc2FmZV92YWx1ZSB0LnZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvblxuICBlbHNlIHQudmFsdWVcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG5tb2R1bGUgVXBkYXRlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBGX2ludmVyc2Ugb2YgKCdiIC0+ICdhIC0+ICdiKVxuICAgIHwgVXBkYXRlIG9mICgnYiAtPiBvbGRfdmFsdWU6J2EgLT4gbmV3X3ZhbHVlOidhIC0+ICdiKVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCB1cGRhdGUgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBVcGRhdGUgdXBkYXRlIC0+IHVwZGF0ZVxuICAgIHwgRl9pbnZlcnNlIGZfaW52ZXJzZSAtPlxuICAgICAgZnVuIGZvbGRfdmFsdWUgfm9sZF92YWx1ZSB+bmV3X3ZhbHVlIC0+IGYgKGZfaW52ZXJzZSBmb2xkX3ZhbHVlIG9sZF92YWx1ZSkgbmV3X3ZhbHVlXG4gIDs7XG5lbmRcblxudHlwZSAoJ2EsICdhY2MpIHQgPSAoJ2EsICdhY2MpIFR5cGVzLlVub3JkZXJlZF9hcnJheV9mb2xkLnQgPVxuICB7IG1haW4gOiAnYWNjIE5vZGUudFxuICA7IGluaXQgOiAnYWNjXG4gIDsgZiA6ICdhY2MgLT4gJ2EgLT4gJ2FjY1xuICA7IHVwZGF0ZSA6ICdhY2MgLT4gb2xkX3ZhbHVlOidhIC0+IG5ld192YWx1ZTonYSAtPiAnYWNjXG4gIDsgZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA6IGludFxuICA7IGNoaWxkcmVuIDogJ2EgTm9kZS50IGFycmF5XG4gIDsgbXV0YWJsZSBmb2xkX3ZhbHVlIDogJ2FjYyBVb3B0LnRcbiAgOyBtdXRhYmxlIG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDogaW50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogKF8sIF8pIHQpICh0MiA6IChfLCBfKSB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIGludmFyaWFudF9hY2MgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogKF8sIF8pIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5pbml0OihjaGVjayBpbnZhcmlhbnRfYWNjKVxuICAgICAgfmY6aWdub3JlXG4gICAgICB+dXBkYXRlOmlnbm9yZVxuICAgICAgfmNoaWxkcmVuOlxuICAgICAgICAoY2hlY2sgKGZ1biBjaGlsZHJlbiAtPlxuICAgICAgICAgICBBcnJheS5pdGVyIGNoaWxkcmVuIH5mOihmdW4gKGNoaWxkIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgICAgVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2EgY2hpbGQudmFsdWVfb3B0O1xuICAgICAgICAgICAgIGlmIHQubnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvbXB1dGVcbiAgICAgICAgICAgICAgICA8IHQuZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICAgICAgICAgICAgIHRoZW4gYXNzZXJ0IChVb3B0LmlzX3NvbWUgY2hpbGQudmFsdWVfb3B0KSkpKVxuICAgICAgfmZvbGRfdmFsdWU6XG4gICAgICAgIChjaGVjayAoZnVuIGZvbGRfdmFsdWUgLT5cbiAgICAgICAgICAgVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2FjYyBmb2xkX3ZhbHVlO1xuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBib29sXVxuICAgICAgICAgICAgIChVb3B0LmlzX3NvbWUgZm9sZF92YWx1ZSlcbiAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgKHQubnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvbXB1dGUgPCB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMpKSlcbiAgICAgIH5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZTpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvbXB1dGUgLT5cbiAgICAgICAgICAgYXNzZXJ0IChudW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBudW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8PSB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMpKSlcbiAgICAgIH5mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzOlxuICAgICAgICAoY2hlY2sgKGZ1biBmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIC0+XG4gICAgICAgICAgIGFzc2VydCAoZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA+IDApKSkpXG47O1xuXG5sZXQgY3JlYXRlIH5pbml0IH5mIH51cGRhdGUgfmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgfmNoaWxkcmVuIH5tYWluID1cbiAgeyBpbml0XG4gIDsgZlxuICA7IHVwZGF0ZSA9IFVwZGF0ZS51cGRhdGUgdXBkYXRlIH5mXG4gIDsgZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICA7IGNoaWxkcmVuXG4gIDsgbWFpblxuICA7IGZvbGRfdmFsdWUgPVxuICAgICAgVW9wdC5ub25lXG4gICgqIFdlIG1ha2UgW251bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlID0gZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc11cbiAgICAgc28gdGhhdCB0aGVyZSB3aWxsIGJlIGEgZnVsbCBjb21wdXRhdGlvbiB0aGUgbmV4dCB0aW1lIHRoZSBub2RlIGlzIGNvbXB1dGVkLiAqKVxuICA7IG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlID0gZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICB9XG47O1xuXG5sZXQgZnVsbF9jb21wdXRlIHsgaW5pdDsgZjsgY2hpbGRyZW47IF8gfSA9XG4gIGxldCByZXN1bHQgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNoaWxkcmVuIC0gMSBkb1xuICAgIHJlc3VsdCA6PSBmICFyZXN1bHQgKFVvcHQudmFsdWVfZXhuIChBcnJheS51bnNhZmVfZ2V0IGNoaWxkcmVuIGkpLnZhbHVlX29wdClcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGNvbXB1dGUgdCA9XG4gIGlmIHQubnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvbXB1dGUgPSB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbiAgdGhlbiAoXG4gICAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSAwO1xuICAgIHQuZm9sZF92YWx1ZSA8LSBVb3B0LnNvbWUgKGZ1bGxfY29tcHV0ZSB0KSk7XG4gIFVvcHQudmFsdWVfZXhuIHQuZm9sZF92YWx1ZVxuOztcblxubGV0IGZvcmNlX2Z1bGxfY29tcHV0ZSB0ID1cbiAgdC5mb2xkX3ZhbHVlIDwtIFVvcHQubm9uZTtcbiAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbjs7XG5cbmxldCBjaGlsZF9jaGFuZ2VkXG4gICAgICAodHlwZSBhIGIpXG4gICAgICAodCA6IChhLCBfKSB0KVxuICAgICAgfihjaGlsZCA6IGIgTm9kZS50KVxuICAgICAgfmNoaWxkX2luZGV4XG4gICAgICB+KG9sZF92YWx1ZV9vcHQgOiBiIFVvcHQudClcbiAgICAgIH4obmV3X3ZhbHVlIDogYilcbiAgPVxuICBsZXQgY2hpbGRfYXRfaW5kZXggPSB0LmNoaWxkcmVuLihjaGlsZF9pbmRleCkgaW5cbiAgbWF0Y2ggTm9kZS50eXBlX2VxdWFsX2lmX3BoeXNfc2FtZSBjaGlsZCBjaGlsZF9hdF9pbmRleCB3aXRoXG4gIHwgTm9uZSAtPlxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIltVbm9yZGVyZWRfYXJyYXlfZm9sZC5jaGlsZF9jaGFuZ2VkXSBtaXNtYXRjaFwiXG4gICAgICAgICAgfnVub3JkZXJlZF9hcnJheV9mb2xkOih0IDogKF8sIF8pIHQpXG4gICAgICAgICAgKGNoaWxkX2luZGV4IDogaW50KVxuICAgICAgICAgIChjaGlsZCA6IF8gTm9kZS50KV1cbiAgfCBTb21lIFQgLT5cbiAgICBpZiB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDwgdC5mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIC0gMVxuICAgIHRoZW4gKFxuICAgICAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlICsgMTtcbiAgICAgICgqIFdlIG9ubHkgcmVhY2ggdGhpcyBjYXNlIGlmIHdlIGhhdmUgYWxyZWFkeSBkb25lIGEgZnVsbCBjb21wdXRlLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICBbVW9wdC5pc19zb21lIHQuZm9sZF92YWx1ZV0gYW5kIFtVb3B0LmlzX3NvbWUgb2xkX3ZhbHVlX29wdF0uICopXG4gICAgICB0LmZvbGRfdmFsdWVcbiAgICAgIDwtIFVvcHQuc29tZVxuICAgICAgICAgICAodC51cGRhdGVcbiAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIHQuZm9sZF92YWx1ZSlcbiAgICAgICAgICAgICAgfm9sZF92YWx1ZTooVW9wdC52YWx1ZV9leG4gb2xkX3ZhbHVlX29wdClcbiAgICAgICAgICAgICAgfm5ld192YWx1ZSkpXG4gICAgZWxzZSBpZiB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDwgdC5mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG4gICAgdGhlbiBmb3JjZV9mdWxsX2NvbXB1dGUgdFxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIEFsYXJtID0gVGltaW5nX3doZWVsLkFsYXJtXG5cbnR5cGUgdCA9IChUeXBlcy5BbGFybV92YWx1ZS50W0BzZXhwLm9wYXF1ZV0pIEFsYXJtLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBudWxsID0gQWxhcm0ubnVsbCAoKVxuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIEFsYXJtX3ZhbHVlID0gVHlwZXMuQWxhcm1fdmFsdWVcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5TdGVwX2Z1bmN0aW9uX25vZGUudCA9XG4gIHsgbWFpbiA6ICdhIE5vZGUudFxuICA7IG11dGFibGUgY2hpbGQgOiAnYSBTdGVwX2Z1bmN0aW9uLnQgTm9kZS50IFVvcHQudFxuICA7IG11dGFibGUgZXh0cmFjdGVkX3N0ZXBfZnVuY3Rpb25fZnJvbV9jaGlsZF9hdCA6IFN0YWJpbGl6YXRpb25fbnVtLnRcbiAgOyBtdXRhYmxlIHZhbHVlIDogJ2EgVW9wdC50XG4gIDsgbXV0YWJsZSB1cGNvbWluZ19zdGVwcyA6IChUaW1lX25zLnQgKiAnYSkgU2VxdWVuY2UudFxuICA7IG11dGFibGUgYWxhcm0gOiBBbGFybS50XG4gIDsgbXV0YWJsZSBhbGFybV92YWx1ZSA6IChBbGFybV92YWx1ZS50W0BzZXhwLm9wYXF1ZV0pXG4gIDsgY2xvY2sgOiAoVHlwZXMuQ2xvY2sudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBwaHlzX3NhbWUgKHQxIDogXyB0KSAodDIgOiBfIHQpID0gcGh5c19zYW1lIHQxIHQyXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5tYWluOlxuICAgICAgICAoY2hlY2sgKGZ1biAobWFpbiA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBtYXRjaCBtYWluLmtpbmQgd2l0aFxuICAgICAgICAgICB8IEludmFsaWQgLT4gKClcbiAgICAgICAgICAgfCBDb25zdCBfIC0+ICgpICgqIGhhcHBlbnMgd2hlbiBbdXBjb21pbmdfc3RlcHNdIGJlY29tZXMgZW1wdHkuICopXG4gICAgICAgICAgIHwgU3RlcF9mdW5jdGlvbiB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+Y2hpbGQ6aWdub3JlXG4gICAgICB+ZXh0cmFjdGVkX3N0ZXBfZnVuY3Rpb25fZnJvbV9jaGlsZF9hdDppZ25vcmVcbiAgICAgIH52YWx1ZTooY2hlY2sgKFVvcHQuaW52YXJpYW50IGludmFyaWFudF9hKSlcbiAgICAgIH51cGNvbWluZ19zdGVwczppZ25vcmVcbiAgICAgIH5hbGFybTooY2hlY2sgQWxhcm0uaW52YXJpYW50KVxuICAgICAgfmFsYXJtX3ZhbHVlOlxuICAgICAgICAoY2hlY2sgKGZ1biAoYWxhcm1fdmFsdWUgOiBBbGFybV92YWx1ZS50KSAtPlxuICAgICAgICAgICBtYXRjaCBhbGFybV92YWx1ZS5hY3Rpb24gd2l0aFxuICAgICAgICAgICB8IFN0ZXBfZnVuY3Rpb24gdDIgLT4gYXNzZXJ0IChwaHlzX3NhbWUgdCB0MilcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+Y2xvY2s6aWdub3JlKVxuOztcblxubGV0IHJlYyBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyBhMSBzdGVwcyA9XG4gIG1hdGNoIFNlcXVlbmNlLm5leHQgc3RlcHMgd2l0aFxuICB8IFNvbWUgKChzdGVwX2F0LCBhMiksIHN0ZXBzMikgd2hlbiBUaW1lX25zLiggPj0gKSB0b18gc3RlcF9hdCAtPlxuICAgIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIGEyIHN0ZXBzMlxuICB8IF8gLT5cbiAgICB0LnZhbHVlIDwtIFVvcHQuc29tZSBhMTtcbiAgICB0LnVwY29taW5nX3N0ZXBzIDwtIHN0ZXBzXG47O1xuXG5sZXQgYWR2YW5jZSB0IH50b18gPSBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyAoVW9wdC52YWx1ZV9leG4gdC52YWx1ZSkgdC51cGNvbWluZ19zdGVwc1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICgnYSwgJ2FjYykgdCA9ICgnYSwgJ2FjYykgVHlwZXMuQXJyYXlfZm9sZC50ID1cbiAgeyBpbml0IDogJ2FjY1xuICA7IGYgOiAnYWNjIC0+ICdhIC0+ICdhY2NcbiAgOyBjaGlsZHJlbiA6ICdhIE5vZGUudCBhcnJheVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgaW52YXJpYW50X2FjYyB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aW5pdDooY2hlY2sgaW52YXJpYW50X2FjYylcbiAgICAgIH5mOmlnbm9yZVxuICAgICAgfmNoaWxkcmVuOlxuICAgICAgICAoY2hlY2sgKGZ1biBjaGlsZHJlbiAtPlxuICAgICAgICAgICBBcnJheS5pdGVyIGNoaWxkcmVuIH5mOihmdW4gKGNoaWxkIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgICAgVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2EgY2hpbGQudmFsdWVfb3B0KSkpKVxuOztcblxubGV0IGNvbXB1dGUgeyBpbml0OyBmOyBjaGlsZHJlbiB9ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY2hpbGRyZW4gLSAxIGRvXG4gICAgcmVzdWx0IDo9IGYgIXJlc3VsdCAoVW9wdC52YWx1ZV9leG4gKEFycmF5LnVuc2FmZV9nZXQgY2hpbGRyZW4gaSkudmFsdWVfb3B0KVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgdCA9IFR5cGVzLkF0LnQgPVxuICB7IG1haW4gOiBCZWZvcmVfb3JfYWZ0ZXIudCBOb2RlLnRcbiAgOyBhdCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgYWxhcm0gOiBBbGFybS50XG4gIDsgY2xvY2sgOiAoVHlwZXMuQ2xvY2sudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBCZWZvcmVfb3JfYWZ0ZXIudCBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IENvbnN0IEFmdGVyIC0+ICgpICgqIGhhcHBlbnMgb25jZSB0aGUgY3VycmVudCB0aW1lIHBhc3NlcyBbdC5hdF0uICopXG4gICAgICAgICAgIHwgQXQgdCcgLT4gYXNzZXJ0IChwaHlzX2VxdWFsIHQgdCcpXG4gICAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpKVxuICAgICAgfmF0Omlnbm9yZVxuICAgICAgfmFsYXJtOihjaGVjayBBbGFybS5pbnZhcmlhbnQpXG4gICAgICB+Y2xvY2s6aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlIHQgPSBUeXBlcy5BdF9pbnRlcnZhbHMudCA9XG4gIHsgbWFpbiA6IHVuaXQgTm9kZS50XG4gIDsgYmFzZSA6IFRpbWVfbnMudFxuICA7IGludGVydmFsIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIGFsYXJtIDogQWxhcm0udFxuICA7IGNsb2NrIDogKFR5cGVzLkNsb2NrLnRbQHNleHAub3BhcXVlXSlcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IEF0X2ludGVydmFscyB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+YmFzZTppZ25vcmVcbiAgICAgIH5pbnRlcnZhbDooY2hlY2sgKGZ1biBpbnRlcnZhbCAtPiBhc3NlcnQgKFRpbWVfbnMuU3Bhbi5pc19wb3NpdGl2ZSBpbnRlcnZhbCkpKVxuICAgICAgfmFsYXJtOihjaGVjayBBbGFybS5pbnZhcmlhbnQpXG4gICAgICB+Y2xvY2s6aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBCaW5kID0gVHlwZXMuQmluZFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5tb2R1bGUgU2NvcGUgPSBUeXBlcy5TY29wZVxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBCaW5kLnQgPVxuICB7IG1haW4gOiAnYiBOb2RlLnRcbiAgOyAoKiBbZl0gaXMgdGhlIHVzZXItc3VwcGxpZWQgZnVuY3Rpb24gdGhhdCB3ZSBydW4gZWFjaCB0aW1lIFt0Lmxoc10gY2hhbmdlcy4gIEl0IGlzXG4gICAgICAgbXV0YWJsZSBvbmx5IHNvIHdlIGNhbiBjbGVhciBpdCB3aGVuIFt0XSBpcyBpbnZhbGlkYXRlZC4gKilcbiAgICBtdXRhYmxlIGYgOiAnYSAtPiAnYiBOb2RlLnRcbiAgOyBsaHMgOiAnYSBOb2RlLnRcbiAgOyBsaHNfY2hhbmdlIDogdW5pdCBOb2RlLnRcbiAgOyAoKiBbcmhzXSBpcyBpbml0aWFsbHkgW25vbmVdLCBhbmQgYWZ0ZXIgdGhhdCBpcyBbc29tZV0gb2YgdGhlIHJlc3VsdCBvZiB0aGUgbW9zdCByZWNlbnRcbiAgICAgICBjYWxsIHRvIFtmXS4gKilcbiAgICBtdXRhYmxlIHJocyA6ICdiIE5vZGUudCBVb3B0LnRcbiAgOyAoKiBbcmhzX3Njb3BlXSBpcyB0aGUgc2NvcGUgaW4gd2hpY2ggW3QuZl0gaXMgcnVuLCBpLmUuIGl0IGlzIFtTY29wZS5CaW5kIHRdLiAgSXQgaXNcbiAgICAgICBbbXV0YWJsZV0gb25seSB0byBhdm9pZCBhIFtsZXQgcmVjXSBkdXJpbmcgY3JlYXRpb24uICopXG4gICAgbXV0YWJsZSByaHNfc2NvcGUgOiBTY29wZS50XG4gIDsgKCogW2FsbF9ub2Rlc19jcmVhdGVkX29uX3Joc10gaXMgdGhlIGhlYWQgb2YgdGhlIHNpbmdseS1saW5rZWQgbGlzdCBvZiBub2RlcyBjcmVhdGVkIG9uXG4gICAgICAgdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiBbdF0sIGkuZS4gaW4gW3QucmhzX3Njb3BlXS4gKilcbiAgICBtdXRhYmxlIGFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyA6IE5vZGUuUGFja2VkLnQgVW9wdC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogKF8sIF8pIHQpICh0MiA6IChfLCBfKSB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaXNfdmFsaWQgdCA9XG4gIG1hdGNoIHQubWFpbi5raW5kIHdpdGhcbiAgfCBJbnZhbGlkIC0+IGZhbHNlXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5sZXQgaXRlcl9ub2Rlc19jcmVhdGVkX29uX3JocyB0IH4oZiA6IE5vZGUuUGFja2VkLnQgLT4gdW5pdCkgPVxuICBsZXQgciA9IHJlZiB0LmFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyBpblxuICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICBsZXQgKFQgbm9kZV9vbl9yaHMpID0gVW9wdC51bnNhZmVfdmFsdWUgIXIgaW5cbiAgICByIDo9IG5vZGVfb25fcmhzLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlO1xuICAgIGYgKFQgbm9kZV9vbl9yaHMpXG4gIGRvbmVcbjs7XG5cbmxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIF9pbnZhcmlhbnRfYiB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggbWFpbi5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgQmluZF9tYWluIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5mOmlnbm9yZVxuICAgICAgfmxoczppZ25vcmVcbiAgICAgIH5saHNfY2hhbmdlOlxuICAgICAgICAoY2hlY2sgKGZ1biAobGhzX2NoYW5nZSA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgbGhzX2NoYW5nZS5jcmVhdGVkX2luIHQubWFpbi5jcmVhdGVkX2luKTtcbiAgICAgICAgICAgbWF0Y2ggbGhzX2NoYW5nZS5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgQmluZF9saHNfY2hhbmdlIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5yaHM6aWdub3JlXG4gICAgICB+cmhzX3Njb3BlOlxuICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgIHwgU2NvcGUuVG9wIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICB8IEJpbmQgdCcgLT4gYXNzZXJ0IChzYW1lIHQgdCcpKSlcbiAgICAgIH5hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHM6XG4gICAgICAgIChjaGVjayAoZnVuIF8gLT5cbiAgICAgICAgICAgaXRlcl9ub2Rlc19jcmVhdGVkX29uX3JocyB0IH5mOihmdW4gKFQgbm9kZSkgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgbm9kZS5jcmVhdGVkX2luIHQucmhzX3Njb3BlKTtcbiAgICAgICAgICAgICBpZiBOb2RlLmlzX25lY2Vzc2FyeSBub2RlXG4gICAgICAgICAgICAgdGhlbiBhc3NlcnQgKHQubGhzX2NoYW5nZS5oZWlnaHQgPCBub2RlLmhlaWdodCkpKSkpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcblxudHlwZSAnYSBlZGdlID0gJ2EgVHlwZXMuRXhwZXJ0LmVkZ2UgPVxuICB7IGNoaWxkIDogJ2EgTm9kZS50XG4gIDsgb25fY2hhbmdlIDogJ2EgLT4gdW5pdFxuICA7ICgqIFtpbmRleF0gaXMgZGVmaW5lZCB3aGVuZXZlciB0aGUgW2VkZ2VdIGlzIGluIHRoZSBbY2hpbGRyZW5dIG9mIHNvbWUgW3RdLiBUaGVuIGl0IGlzXG4gICAgICAgdGhlIGluZGV4IG9mIHRoaXMgW2VkZ2VdIGluIHRoYXQgW2NoaWxkcmVuXSBhcnJheS4gSXQgbWlnaHQgc2VlbSByZWR1bmRhbnQgd2l0aCBhbGxcbiAgICAgICB0aGUgb3RoZXIgaW5kZXhlcyB3ZSBoYXZlLCBidXQgaXQgaXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBjaGlsZHJlbi4gIFRoZSBpbmRleCBtYXlcbiAgICAgICBjaGFuZ2UgYXMgc2libGluZyBjaGlsZHJlbiBhcmUgcmVtb3ZlZC4gKilcbiAgICBtdXRhYmxlIGluZGV4IDogaW50IFVvcHQudFxuICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG50eXBlIHBhY2tlZF9lZGdlID0gVHlwZXMuRXhwZXJ0LnBhY2tlZF9lZGdlID0gRSA6ICdhIGVkZ2UgLT4gcGFja2VkX2VkZ2VcbltAQHVuYm94ZWRdIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLkV4cGVydC50ID1cbiAgeyBmIDogdW5pdCAtPiAnYVxuICA7IG9uX29ic2VydmFiaWxpdHlfY2hhbmdlIDogaXNfbm93X29ic2VydmFibGU6Ym9vbCAtPiB1bml0XG4gIDsgbXV0YWJsZSBjaGlsZHJlbiA6IHBhY2tlZF9lZGdlIFVvcHQudCBVbmlmb3JtX2FycmF5LnRcbiAgOyBtdXRhYmxlIG51bV9jaGlsZHJlbiA6IGludFxuICA7ICgqIFdoZW4gc2V0LCBtYWtlcyB0aGUgbm9kZSBvZiBbdF0gc3RhbGUuICBJdCBpcyBzZXQgd2hlbiB0aGUgc2V0IG9mIGNoaWxkcmVuIGNoYW5nZXMuXG4gICAgICAgT3RoZXJ3aXNlIHRoZSBub3JtYWwgY2hlY2sgb2Ygc3RhbGVuZXNzIChjb21wYXJpbmcgdGhlIFtjaGFuZ2VkX2F0XSBmaWVsZCBvZlxuICAgICAgIGNoaWxkcmVuIGFuZCB0aGUgW3JlY29tcHV0ZWRfYXRdIGZpZWxkIGZvciB0aGUgbm9kZSBvZiBbdF0pIHdvdWxkIG5vdCBiZSBlbm91Z2guXG4gICAgICAgVGhpcyBwbGF5cyBhIHJvbGUgc2ltaWxhciB0byB0aGUgY3V0b2ZmIG9mIFtOZXZlcl0gZm9yIHRoZSBsaHMtY2hhbmdlIG9mIGJpbmRzLCBidXRcbiAgICAgICB3ZSBkb24ndCBoYXZlIGEgc3BlY2lhbCBjaGlsZC4gKilcbiAgICBtdXRhYmxlIGZvcmNlX3N0YWxlIDogYm9vbFxuICA7ICgqIFRoZSBudW1iZXIgb2YgaW52YWxpZCBjaGlsZHJlbiB0aGF0IHBvaW50IHRvIHVzLiAgVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZVxuICAgICAgIG9mIFt0XSBuZWVkcyB0byBpbnZhbGlkYXRlZCwgd2l0aG91dCBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIGNoaWxkcmVuLiAgVGhpcyBpcyBub3RcbiAgICAgICBuZWVkZWQgZm9yIG90aGVyIG5vZGVzLCBiZWNhdXNlIHRoZXJlIGFyZSBubyBvdGhlciBub2RlcyB0aGF0IGhhdmUgYSBwb3RlbnRpYWxseVxuICAgICAgIGxhcmdlIGFuZCBkeW5hbWljIHNldCBvZiBjaGlsZHJlbi4gKilcbiAgICBtdXRhYmxlIG51bV9pbnZhbGlkX2NoaWxkcmVuIDogaW50XG4gIDsgKCogV2hldGhlciB3ZSB3aWxsIGZpcmUgdGhlIFtvbl9jaGFuZ2VdIGNhbGxiYWNrcyBmb3IgYWxsIGNoaWxkcmVuIHdoZW4gdGhlIG5vZGUgb2YgW3RdXG4gICAgICAgaXRzZWxmIHJ1bnMuICBVc2VkIHRvIG1ha2Ugc3VyZSB3ZSByZXJ1biBldmVyeXRoaW5nIGFmdGVyIFt0XSBzd2l0Y2hlcyBmcm9tXG4gICAgICAgdW5vYnNlcnZhYmxlIGFuZCBiYWNrIHRvIG9ic2VydmFibGUuICopXG4gICAgbXV0YWJsZSB3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyA6IGJvb2xcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudFxuICAgICAgX2ludmFyaWFudF9hXG4gICAgICB7IGYgPSBfXG4gICAgICA7IGNoaWxkcmVuXG4gICAgICA7IG51bV9jaGlsZHJlblxuICAgICAgOyBmb3JjZV9zdGFsZSA9IF9cbiAgICAgIDsgbnVtX2ludmFsaWRfY2hpbGRyZW5cbiAgICAgIDsgb25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgPSBfXG4gICAgICA7IHdpbGxfZmlyZV9hbGxfY2FsbGJhY2tzID0gX1xuICAgICAgfVxuICA9XG4gIGFzc2VydCAobnVtX2NoaWxkcmVuIDw9IFVuaWZvcm1fYXJyYXkubGVuZ3RoIGNoaWxkcmVuKTtcbiAgaWdub3JlIG51bV9pbnZhbGlkX2NoaWxkcmVuO1xuICAoKiBpbnZhcmlhbnQgaXMgYmVsb3csIGJlY2F1c2Ugd2UgbmVlZCBzb21lIGNvbnRleHQgKilcbiAgVW5pZm9ybV9hcnJheS5pdGVyaSBjaGlsZHJlbiB+ZjooZnVuIGkgdW9wdCAtPlxuICAgIG1hdGNoIGkgPCBudW1fY2hpbGRyZW4gd2l0aFxuICAgIHwgdHJ1ZSAtPlxuICAgICAgbGV0IChFIHIpID0gVW9wdC52YWx1ZV9leG4gdW9wdCBpblxuICAgICAgWyV0ZXN0X3Jlc3VsdDogaW50XSAoVW9wdC52YWx1ZV9leG4gci5pbmRleCkgfmV4cGVjdDppXG4gICAgfCBmYWxzZSAtPiBhc3NlcnQgKFVvcHQuaXNfbm9uZSB1b3B0KSlcbjs7XG5cbmxldCBpbnZhcmlhbnRfYWJvdXRfbnVtX2ludmFsaWRfY2hpbGRyZW5cbiAgICAgIHsgY2hpbGRyZW47IG51bV9jaGlsZHJlbjsgbnVtX2ludmFsaWRfY2hpbGRyZW47IF8gfVxuICAgICAgfmlzX25lY2Vzc2FyeVxuICA9XG4gIGlmIG5vdCBpc19uZWNlc3NhcnlcbiAgdGhlbiBbJXRlc3RfcmVzdWx0OiBpbnRdIG51bV9pbnZhbGlkX2NoaWxkcmVuIH5leHBlY3Q6MFxuICBlbHNlIChcbiAgICBsZXQgY291bnRfaW52YWxpZF9jaGlsZHJlbiA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG51bV9jaGlsZHJlbiAtIDEgZG9cbiAgICAgIGxldCAoRSByKSA9IFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCBjaGlsZHJlbiBpKSBpblxuICAgICAgaWYgbm90IChOb2RlLmlzX3ZhbGlkIHIuY2hpbGQpIHRoZW4gaW5jciBjb3VudF9pbnZhbGlkX2NoaWxkcmVuXG4gICAgZG9uZTtcbiAgICBbJXRlc3RfcmVzdWx0OiBpbnRdIG51bV9pbnZhbGlkX2NoaWxkcmVuIH5leHBlY3Q6IWNvdW50X2ludmFsaWRfY2hpbGRyZW4pXG47O1xuXG5sZXQgY3JlYXRlIH5mIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZSA9XG4gIHsgZlxuICA7IG9uX29ic2VydmFiaWxpdHlfY2hhbmdlXG4gIDsgY2hpbGRyZW4gPSBVbmlmb3JtX2FycmF5LmVtcHR5XG4gIDsgbnVtX2NoaWxkcmVuID0gMFxuICA7IGZvcmNlX3N0YWxlID0gZmFsc2VcbiAgOyBudW1faW52YWxpZF9jaGlsZHJlbiA9IDBcbiAgOyB3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyA9IHRydWVcbiAgfVxuOztcblxubGV0IG1ha2Vfc3RhbGUgdCA9XG4gIGlmIHQuZm9yY2Vfc3RhbGVcbiAgdGhlbiBgQWxyZWFkeV9zdGFsZVxuICBlbHNlIChcbiAgICB0LmZvcmNlX3N0YWxlIDwtIHRydWU7XG4gICAgYE9rKVxuOztcblxubGV0IGluY3JfaW52YWxpZF9jaGlsZHJlbiB0ID0gdC5udW1faW52YWxpZF9jaGlsZHJlbiA8LSB0Lm51bV9pbnZhbGlkX2NoaWxkcmVuICsgMVxubGV0IGRlY3JfaW52YWxpZF9jaGlsZHJlbiB0ID0gdC5udW1faW52YWxpZF9jaGlsZHJlbiA8LSB0Lm51bV9pbnZhbGlkX2NoaWxkcmVuIC0gMVxuXG5sZXQgbWFrZV9zcGFjZV9mb3JfY2hpbGRfaWZfbmVjZXNzYXJ5IHQgPVxuICBpZiB0Lm51bV9jaGlsZHJlbiA+PSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0LmNoaWxkcmVuXG4gIHRoZW4gKFxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0ICh0Lm51bV9jaGlsZHJlbiA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQuY2hpbGRyZW4pO1xuICAgIGxldCBuZXdfbWF4ID0gSW50Lm1heCAyICgyICogVW5pZm9ybV9hcnJheS5sZW5ndGggdC5jaGlsZHJlbikgaW5cbiAgICB0LmNoaWxkcmVuIDwtIFVuaWZvcm1fYXJyYXkucmVhbGxvYyB0LmNoaWxkcmVuIH5sZW46bmV3X21heClcbjs7XG5cbmxldCBhZGRfY2hpbGRfZWRnZSB0IHBhY2tlZF9lZGdlID1cbiAgbGV0IChFIGVkZ2UpID0gcGFja2VkX2VkZ2UgaW5cbiAgYXNzZXJ0IChVb3B0LmlzX25vbmUgZWRnZS5pbmRleCk7XG4gIG1ha2Vfc3BhY2VfZm9yX2NoaWxkX2lmX25lY2Vzc2FyeSB0O1xuICBsZXQgbmV3X2NoaWxkX2luZGV4ID0gdC5udW1fY2hpbGRyZW4gaW5cbiAgZWRnZS5pbmRleCA8LSBVb3B0LnNvbWUgbmV3X2NoaWxkX2luZGV4O1xuICBVbmlmb3JtX2FycmF5LnNldCB0LmNoaWxkcmVuIG5ld19jaGlsZF9pbmRleCAoVW9wdC5zb21lIHBhY2tlZF9lZGdlKTtcbiAgdC5udW1fY2hpbGRyZW4gPC0gdC5udW1fY2hpbGRyZW4gKyAxO1xuICB0LmZvcmNlX3N0YWxlIDwtIHRydWU7XG4gICgqIFdlIHdpbGwgYnVtcCB0aGUgbnVtYmVyIG9mIGludmFsaWQgY2hpbGRyZW4gaWYgbmVjZXNzYXJ5IHdoZW4gY29ubmVjdGluZyBjaGlsZCBhbmRcbiAgICAgcGFyZW50LiAgU2FtZSB0aGluZyBmb3IgcnVubmluZyB0aGUgW29uX2NoYW5nZV0gY2FsbGJhY2tzLiAqKVxuICBuZXdfY2hpbGRfaW5kZXhcbjs7XG5cbmxldCBzd2FwX2NoaWxkcmVuIHQgfmNoaWxkX2luZGV4MSB+Y2hpbGRfaW5kZXgyID1cbiAgbGV0IChFIGVkZ2UxKSA9IFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0LmNoaWxkcmVuIGNoaWxkX2luZGV4MSkgaW5cbiAgbGV0IChFIGVkZ2UyKSA9IFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0LmNoaWxkcmVuIGNoaWxkX2luZGV4MikgaW5cbiAgZWRnZTEuaW5kZXggPC0gVW9wdC5zb21lIGNoaWxkX2luZGV4MjtcbiAgZWRnZTIuaW5kZXggPC0gVW9wdC5zb21lIGNoaWxkX2luZGV4MTtcbiAgVW5pZm9ybV9hcnJheS5zd2FwIHQuY2hpbGRyZW4gY2hpbGRfaW5kZXgxIGNoaWxkX2luZGV4MlxuOztcblxubGV0IGxhc3RfY2hpbGRfZWRnZV9leG4gdCA9XG4gIGxldCBsYXN0X2luZGV4ID0gdC5udW1fY2hpbGRyZW4gLSAxIGluXG4gIFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0LmNoaWxkcmVuIGxhc3RfaW5kZXgpXG47O1xuXG5sZXQgcmVtb3ZlX2xhc3RfY2hpbGRfZWRnZV9leG4gdCA9XG4gIGxldCBsYXN0X2luZGV4ID0gdC5udW1fY2hpbGRyZW4gLSAxIGluXG4gIGxldCBwYWNrZWRfZWRnZV9vcHQgPSBVbmlmb3JtX2FycmF5LmdldCB0LmNoaWxkcmVuIGxhc3RfaW5kZXggaW5cbiAgVW5pZm9ybV9hcnJheS5zZXQgdC5jaGlsZHJlbiBsYXN0X2luZGV4IFVvcHQubm9uZTtcbiAgdC5udW1fY2hpbGRyZW4gPC0gbGFzdF9pbmRleDtcbiAgdC5mb3JjZV9zdGFsZSA8LSB0cnVlO1xuICBhc3NlcnQgKFVvcHQuaXNfc29tZSBwYWNrZWRfZWRnZV9vcHQpO1xuICBsZXQgKEUgZWRnZSkgPSBVb3B0LnVuc2FmZV92YWx1ZSBwYWNrZWRfZWRnZV9vcHQgaW5cbiAgZWRnZS5pbmRleCA8LSBVb3B0Lm5vbmVcbjs7XG5cbmxldCBiZWZvcmVfbWFpbl9jb21wdXRhdGlvbiB0ID1cbiAgaWYgdC5udW1faW52YWxpZF9jaGlsZHJlbiA+IDBcbiAgdGhlbiBgSW52YWxpZFxuICBlbHNlIChcbiAgICB0LmZvcmNlX3N0YWxlIDwtIGZhbHNlO1xuICAgIGxldCB3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyA9IHQud2lsbF9maXJlX2FsbF9jYWxsYmFja3MgaW5cbiAgICB0LndpbGxfZmlyZV9hbGxfY2FsbGJhY2tzIDwtIGZhbHNlO1xuICAgIGlmIHdpbGxfZmlyZV9hbGxfY2FsbGJhY2tzXG4gICAgdGhlblxuICAgICAgZm9yIGkgPSAwIHRvIHQubnVtX2NoaWxkcmVuIC0gMSBkb1xuICAgICAgICBsZXQgKEUgcikgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBpKSBpblxuICAgICAgICByLm9uX2NoYW5nZSAoVW9wdC52YWx1ZV9leG4gci5jaGlsZC52YWx1ZV9vcHQpXG4gICAgICBkb25lO1xuICAgIGBPaylcbjs7XG5cbmxldCBvYnNlcnZhYmlsaXR5X2NoYW5nZSB0IH5pc19ub3dfb2JzZXJ2YWJsZSA9XG4gIHQub25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgfmlzX25vd19vYnNlcnZhYmxlO1xuICBpZiBub3QgaXNfbm93X29ic2VydmFibGVcbiAgdGhlbiAoXG4gICAgdC53aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyA8LSB0cnVlO1xuICAgICgqIElmIHdlIGRvbid0IHJlc2V0IG51bV9pbnZhbGlkX2NoaWxkcmVuLCB3ZSB3b3VsZCBkb3VibGUgY291bnQgdGhlbToganVzdCBpbWFnaW5lXG4gICAgICAgd2hhdCBoYXBwZW5zIHdlIGlmIHJlY29ubmVjdC9kaXNjb25uZWN0L3JlY29ubmVjdC9kaXNjb25uZWN0IHdpdGggYW4gaW52YWxpZFxuICAgICAgIGNoaWxkLiAqKVxuICAgIHQubnVtX2ludmFsaWRfY2hpbGRyZW4gPC0gMClcbjs7XG5cbmxldCBydW5fZWRnZV9jYWxsYmFjayB0IH5jaGlsZF9pbmRleCA9XG4gIGlmIG5vdCB0LndpbGxfZmlyZV9hbGxfY2FsbGJhY2tzXG4gIHRoZW4gKFxuICAgIGxldCAoRSByKSA9IFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0LmNoaWxkcmVuIGNoaWxkX2luZGV4KSBpblxuICAgICgqIFRoaXMgdmFsdWUgaXMgbm90IG5lY2Vzc2FyaWx5IHNldCwgYmVjYXVzZSB3ZSB0cnkgdG8gcnVuIHRoaXMgd2hlbiBjb25uZWN0aW5nIHRoZVxuICAgICAgIG5vZGUgdG8gaXRzIGNoaWxkcmVuLCB3aGljaCBjb3VsZCBiZSBiZWZvcmUgdGhleSBoYXZlIHJ1biBldmVuIG9uY2UuICBBbHNvIHRoZSBub2RlXG4gICAgICAgY291bGQgYmUgaW52YWxpZC4gKilcbiAgICBpZiBVb3B0LmlzX3NvbWUgci5jaGlsZC52YWx1ZV9vcHRcbiAgICB0aGVuIHIub25fY2hhbmdlIChVb3B0LnVuc2FmZV92YWx1ZSByLmNoaWxkLnZhbHVlX29wdCkpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuaW5jbHVkZSBUeXBlcy5TY29wZVxuXG5sZXQgdG9wID0gVG9wXG5cbmxldCBpc190b3AgPSBmdW5jdGlvblxuICB8IFRvcCAtPiB0cnVlXG4gIHwgQmluZCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaW52YXJpYW50ID0gZnVuY3Rpb25cbiAgfCBUb3AgLT4gKClcbiAgfCBCaW5kIGJpbmQgLT4gQmluZC5pbnZhcmlhbnQgaWdub3JlIGlnbm9yZSBiaW5kXG47O1xuXG4oKiBVbmxpa2UgZm9yIG5vZGVzLCB0aGVyZSBpcyBubyBpbnZhcmlhbnQgW2lzX25lY2Vzc2FyeSB0IDw9PiBoZWlnaHQgPiAtMV0gKGRvZXNuJ3Qgd29ya1xuICAgYmVjYXVzZSBvZiBbVG9wXSkuICBUaGlzIGlzIGZpbmUgc2luY2UgdGhlIGhlaWdodCBvZiBhIHNjb3BlIGlzIG9ubHkgdXNlZCB0byBjb25zdHJhaW5cbiAgIG90aGVyIGhlaWdodHMsIG5vdCB0byBzY2hlZHVsZSBpdC4gKilcbmxldCBoZWlnaHQgPSBmdW5jdGlvblxuICB8IFRvcCAtPiAtMVxuICB8IEJpbmQgYmluZCAtPiBiaW5kLmxoc19jaGFuZ2UuaGVpZ2h0XG47O1xuXG5sZXQgaXNfdmFsaWQgPSBmdW5jdGlvblxuICB8IFRvcCAtPiB0cnVlXG4gIHwgQmluZCBiaW5kIC0+IEJpbmQuaXNfdmFsaWQgYmluZFxuOztcblxubGV0IGlzX25lY2Vzc2FyeSA9IGZ1bmN0aW9uXG4gIHwgVG9wIC0+IHRydWVcbiAgfCBCaW5kIGJpbmQgLT4gTm9kZS5pc19uZWNlc3NhcnkgYmluZC5tYWluXG47O1xuXG5sZXQgYWRkX25vZGUgdCAobm9kZSA6IF8gTm9kZS50KSA9XG4gIGFzc2VydCAocGh5c19lcXVhbCBub2RlLmNyZWF0ZWRfaW4gdCk7XG4gIG1hdGNoIHQgd2l0aFxuICB8IFRvcCAtPiAoKVxuICB8IEJpbmQgYmluZCAtPlxuICAgIG5vZGUubmV4dF9ub2RlX2luX3NhbWVfc2NvcGUgPC0gYmluZC5hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHM7XG4gICAgYmluZC5hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMgPC0gVW9wdC5zb21lIChUeXBlcy5Ob2RlLlBhY2tlZC5UIG5vZGUpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLkZyZWV6ZS50ID1cbiAgeyBtYWluIDogJ2EgTm9kZS50XG4gIDsgY2hpbGQgOiAnYSBOb2RlLnRcbiAgOyBvbmx5X2ZyZWV6ZV93aGVuIDogJ2EgLT4gYm9vbFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgYXNzZXJ0IChTY29wZS5pc190b3AgbWFpbi5jcmVhdGVkX2luKTtcbiAgICAgICAgICAgbWF0Y2ggbWFpbi5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpICgqIGhhcHBlbnMgd2hlbiBmcmVlemluZyBhbiBpbnZhbGlkIHZhbHVlICopXG4gICAgICAgICAgIHwgQ29uc3QgXyAtPiAoKSAoKiBoYXBwZW5zIG9uIGJlY29taW5nIGZyb3plbiAqKVxuICAgICAgICAgICB8IEZyZWV6ZSB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+Y2hpbGQ6aWdub3JlXG4gICAgICB+b25seV9mcmVlemVfd2hlbjppZ25vcmUpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLklmX3RoZW5fZWxzZS50ID1cbiAgeyBtYWluIDogJ2EgTm9kZS50XG4gIDsgdGVzdCA6IGJvb2wgTm9kZS50XG4gIDsgdGVzdF9jaGFuZ2UgOiB1bml0IE5vZGUudFxuICA7IG11dGFibGUgY3VycmVudF9icmFuY2ggOiAnYSBOb2RlLnQgVW9wdC50XG4gIDsgdGhlbl8gOiAnYSBOb2RlLnRcbiAgOyBlbHNlXyA6ICdhIE5vZGUudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBzYW1lICh0MSA6IF8gdCkgKHQyIDogXyB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IElmX3RoZW5fZWxzZSB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+ICgpKSlcbiAgICAgIH50ZXN0Omlnbm9yZVxuICAgICAgfnRlc3RfY2hhbmdlOlxuICAgICAgICAoY2hlY2sgKGZ1biAodGVzdF9jaGFuZ2UgOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggdGVzdF9jaGFuZ2Uua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IElmX3Rlc3RfY2hhbmdlIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5jdXJyZW50X2JyYW5jaDpcbiAgICAgICAgKGNoZWNrIChmdW4gY3VycmVudF9icmFuY2ggLT5cbiAgICAgICAgICAgaWYgVW9wdC5pc19zb21lIGN1cnJlbnRfYnJhbmNoXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCBjdXJyZW50X2JyYW5jaCA9IFVvcHQudmFsdWVfZXhuIGN1cnJlbnRfYnJhbmNoIGluXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWwgY3VycmVudF9icmFuY2ggdC50aGVuXyB8fCBwaHlzX2VxdWFsIGN1cnJlbnRfYnJhbmNoIHQuZWxzZV8pKSkpXG4gICAgICB+dGhlbl86aWdub3JlXG4gICAgICB+ZWxzZV86aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5Kb2luLnQgPVxuICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgOyBsaHMgOiAnYSBOb2RlLnQgTm9kZS50XG4gIDsgbGhzX2NoYW5nZSA6IHVuaXQgTm9kZS50XG4gIDsgbXV0YWJsZSByaHMgOiAnYSBOb2RlLnQgVW9wdC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogXyB0KSAodDIgOiBfIHQpID0gcGh5c19zYW1lIHQxIHQyXG5cbmxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggbWFpbi5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgSm9pbl9tYWluIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5saHM6aWdub3JlXG4gICAgICB+bGhzX2NoYW5nZTpcbiAgICAgICAgKGNoZWNrIChmdW4gKGxoc19jaGFuZ2UgOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggbGhzX2NoYW5nZS5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgSm9pbl9saHNfY2hhbmdlIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5yaHM6aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5TbmFwc2hvdC50ID1cbiAgeyBtYWluIDogJ2EgTm9kZS50XG4gIDsgYXQgOiBUaW1lX25zLnRcbiAgOyBiZWZvcmUgOiAnYVxuICA7IHZhbHVlX2F0IDogJ2EgTm9kZS50XG4gIDsgY2xvY2sgOiAoVHlwZXMuQ2xvY2sudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5tYWluOlxuICAgICAgICAoY2hlY2sgKGZ1biAobWFpbiA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBhc3NlcnQgKFNjb3BlLmlzX3RvcCBtYWluLmNyZWF0ZWRfaW4pO1xuICAgICAgICAgICBtYXRjaCBtYWluLmtpbmQgd2l0aFxuICAgICAgICAgICB8IEludmFsaWQgLT4gKCkgKCogaGFwcGVucyB3aGVuIHNuYXBzaG90dGluZyBhbiBpbnZhbGlkIG5vZGUgKilcbiAgICAgICAgICAgfCBDb25zdCBfIC0+ICgpICgqIGhhcHBlbnMgYWZ0ZXIgdGhlIHNuYXBzaG90ICopXG4gICAgICAgICAgIHwgU25hcHNob3QgdCcgLT4gYXNzZXJ0IChwaHlzX2VxdWFsIHQgdCcpXG4gICAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpKVxuICAgICAgfmF0Omlnbm9yZVxuICAgICAgfmJlZm9yZTooY2hlY2sgaW52YXJpYW50X2EpXG4gICAgICB+dmFsdWVfYXQ6aWdub3JlXG4gICAgICB+Y2xvY2s6aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5LaW5kLnQgPVxuICB8IEFycmF5X2ZvbGQgOiAoXywgJ2EpIEFycmF5X2ZvbGQudCAtPiAnYSB0XG4gIHwgQXQgOiBBdC50IC0+IEJlZm9yZV9vcl9hZnRlci50IHRcbiAgfCBBdF9pbnRlcnZhbHMgOiBBdF9pbnRlcnZhbHMudCAtPiB1bml0IHRcbiAgfCBCaW5kX2xoc19jaGFuZ2UgOiAoXywgXykgQmluZC50IC0+IHVuaXQgdFxuICB8IEJpbmRfbWFpbiA6IChfLCAnYSkgQmluZC50IC0+ICdhIHRcbiAgfCBDb25zdCBvZiAnYVxuICB8IEV4cGVydCBvZiAnYSBFeHBlcnQudFxuICB8IEZyZWV6ZSBvZiAnYSBGcmVlemUudFxuICB8IElmX3Rlc3RfY2hhbmdlIDogXyBJZl90aGVuX2Vsc2UudCAtPiB1bml0IHRcbiAgfCBJZl90aGVuX2Vsc2Ugb2YgJ2EgSWZfdGhlbl9lbHNlLnRcbiAgfCBJbnZhbGlkXG4gIHwgSm9pbl9saHNfY2hhbmdlIDogXyBKb2luLnQgLT4gdW5pdCB0XG4gIHwgSm9pbl9tYWluIG9mICdhIEpvaW4udFxuICB8IE1hcCA6ICgnYTEgLT4gJ2EpICogJ2ExIE5vZGUudCAtPiAnYSB0XG4gIHwgU25hcHNob3Qgb2YgJ2EgU25hcHNob3QudFxuICB8IFN0ZXBfZnVuY3Rpb24gb2YgJ2EgU3RlcF9mdW5jdGlvbl9ub2RlLnRcbiAgfCBVbmluaXRpYWxpemVkXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgOiAoXywgJ2EpIFVub3JkZXJlZF9hcnJheV9mb2xkLnQgLT4gJ2EgdFxuICB8IFZhciBvZiAnYSBWYXIudFxuICB8IE1hcDIgOiAoJ2ExIC0+ICdhMiAtPiAnYSkgKiAnYTEgTm9kZS50ICogJ2EyIE5vZGUudCAtPiAnYSB0XG4gIHwgTWFwMyA6ICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYSkgKiAnYTEgTm9kZS50ICogJ2EyIE5vZGUudCAqICdhMyBOb2RlLnQgLT4gJ2EgdFxuICB8IE1hcDQgOlxuICAgICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYSkgKiAnYTEgTm9kZS50ICogJ2EyIE5vZGUudCAqICdhMyBOb2RlLnQgKiAnYTQgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwNSA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwNiA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwNyA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgICogJ2E2IE5vZGUudFxuICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwOCA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhOCAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwOSA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhOCAtPiAnYTkgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAqICdhNyBOb2RlLnRcbiAgICAgICogJ2E4IE5vZGUudFxuICAgICAgKiAnYTkgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwMTAgOlxuICAgICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYTggLT4gJ2E5IC0+ICdhMTAgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAqICdhNyBOb2RlLnRcbiAgICAgICogJ2E4IE5vZGUudFxuICAgICAgKiAnYTkgTm9kZS50XG4gICAgICAqICdhMTAgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwMTEgOlxuICAgICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYTggLT4gJ2E5IC0+ICdhMTAgLT4gJ2ExMSAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxMiA6XG4gICAgICAoJ2ExXG4gICAgICAgLT4gJ2EyXG4gICAgICAgLT4gJ2EzXG4gICAgICAgLT4gJ2E0XG4gICAgICAgLT4gJ2E1XG4gICAgICAgLT4gJ2E2XG4gICAgICAgLT4gJ2E3XG4gICAgICAgLT4gJ2E4XG4gICAgICAgLT4gJ2E5XG4gICAgICAgLT4gJ2ExMFxuICAgICAgIC0+ICdhMTFcbiAgICAgICAtPiAnYTEyXG4gICAgICAgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAqICdhNyBOb2RlLnRcbiAgICAgICogJ2E4IE5vZGUudFxuICAgICAgKiAnYTkgTm9kZS50XG4gICAgICAqICdhMTAgTm9kZS50XG4gICAgICAqICdhMTEgTm9kZS50XG4gICAgICAqICdhMTIgTm9kZS50XG4gICAgICAtPiAnYSB0XG4gIHwgTWFwMTMgOlxuICAgICAgKCdhMVxuICAgICAgIC0+ICdhMlxuICAgICAgIC0+ICdhM1xuICAgICAgIC0+ICdhNFxuICAgICAgIC0+ICdhNVxuICAgICAgIC0+ICdhNlxuICAgICAgIC0+ICdhN1xuICAgICAgIC0+ICdhOFxuICAgICAgIC0+ICdhOVxuICAgICAgIC0+ICdhMTBcbiAgICAgICAtPiAnYTExXG4gICAgICAgLT4gJ2ExMlxuICAgICAgIC0+ICdhMTNcbiAgICAgICAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgICogJ2ExMyBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxNCA6XG4gICAgICAoJ2ExXG4gICAgICAgLT4gJ2EyXG4gICAgICAgLT4gJ2EzXG4gICAgICAgLT4gJ2E0XG4gICAgICAgLT4gJ2E1XG4gICAgICAgLT4gJ2E2XG4gICAgICAgLT4gJ2E3XG4gICAgICAgLT4gJ2E4XG4gICAgICAgLT4gJ2E5XG4gICAgICAgLT4gJ2ExMFxuICAgICAgIC0+ICdhMTFcbiAgICAgICAtPiAnYTEyXG4gICAgICAgLT4gJ2ExM1xuICAgICAgIC0+ICdhMTRcbiAgICAgICAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgICogJ2ExMyBOb2RlLnRcbiAgICAgICogJ2ExNCBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxNSA6XG4gICAgICAoJ2ExXG4gICAgICAgLT4gJ2EyXG4gICAgICAgLT4gJ2EzXG4gICAgICAgLT4gJ2E0XG4gICAgICAgLT4gJ2E1XG4gICAgICAgLT4gJ2E2XG4gICAgICAgLT4gJ2E3XG4gICAgICAgLT4gJ2E4XG4gICAgICAgLT4gJ2E5XG4gICAgICAgLT4gJ2ExMFxuICAgICAgIC0+ICdhMTFcbiAgICAgICAtPiAnYTEyXG4gICAgICAgLT4gJ2ExM1xuICAgICAgIC0+ICdhMTRcbiAgICAgICAtPiAnYTE1XG4gICAgICAgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAqICdhNyBOb2RlLnRcbiAgICAgICogJ2E4IE5vZGUudFxuICAgICAgKiAnYTkgTm9kZS50XG4gICAgICAqICdhMTAgTm9kZS50XG4gICAgICAqICdhMTEgTm9kZS50XG4gICAgICAqICdhMTIgTm9kZS50XG4gICAgICAqICdhMTMgTm9kZS50XG4gICAgICAqICdhMTQgTm9kZS50XG4gICAgICAqICdhMTUgTm9kZS50XG4gICAgICAtPiAnYSB0XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgbmFtZSA6IHR5cGUgYS4gYSB0IC0+IHN0cmluZyA9IGZ1bmN0aW9uXG4gIHwgQXJyYXlfZm9sZCBfIC0+IFwiQXJyYXlfZm9sZFwiXG4gIHwgQXQgXyAtPiBcIkF0XCJcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiBcIkF0X2ludGVydmFsc1wiXG4gIHwgQmluZF9saHNfY2hhbmdlIF8gLT4gXCJCaW5kX2xoc19jaGFuZ2VcIlxuICB8IEJpbmRfbWFpbiBfIC0+IFwiQmluZF9tYWluXCJcbiAgfCBDb25zdCBfIC0+IFwiQ29uc3RcIlxuICB8IEV4cGVydCBfIC0+IFwiRXhwZXJ0XCJcbiAgfCBGcmVlemUgXyAtPiBcIkZyZWV6ZVwiXG4gIHwgSWZfdGVzdF9jaGFuZ2UgXyAtPiBcIklmX3Rlc3RfY2hhbmdlXCJcbiAgfCBJZl90aGVuX2Vsc2UgXyAtPiBcIklmX3RoZW5fZWxzZVwiXG4gIHwgSW52YWxpZCAtPiBcIkludmFsaWRcIlxuICB8IEpvaW5fbGhzX2NoYW5nZSBfIC0+IFwiSm9pbl9saHNfY2hhbmdlXCJcbiAgfCBKb2luX21haW4gXyAtPiBcIkpvaW5fbWFpblwiXG4gIHwgTWFwIF8gLT4gXCJNYXBcIlxuICB8IE1hcDIgXyAtPiBcIk1hcDJcIlxuICB8IE1hcDMgXyAtPiBcIk1hcDNcIlxuICB8IE1hcDQgXyAtPiBcIk1hcDRcIlxuICB8IE1hcDUgXyAtPiBcIk1hcDVcIlxuICB8IE1hcDYgXyAtPiBcIk1hcDZcIlxuICB8IE1hcDcgXyAtPiBcIk1hcDdcIlxuICB8IE1hcDggXyAtPiBcIk1hcDhcIlxuICB8IE1hcDkgXyAtPiBcIk1hcDlcIlxuICB8IE1hcDEwIF8gLT4gXCJNYXAxMFwiXG4gIHwgTWFwMTEgXyAtPiBcIk1hcDExXCJcbiAgfCBNYXAxMiBfIC0+IFwiTWFwMTJcIlxuICB8IE1hcDEzIF8gLT4gXCJNYXAxM1wiXG4gIHwgTWFwMTQgXyAtPiBcIk1hcDE0XCJcbiAgfCBNYXAxNSBfIC0+IFwiTWFwMTVcIlxuICB8IFNuYXBzaG90IF8gLT4gXCJTbmFwc2hvdFwiXG4gIHwgU3RlcF9mdW5jdGlvbiBfIC0+IFwiU3RlcF9mdW5jdGlvblwiXG4gIHwgVW5pbml0aWFsaXplZCAtPiBcIlVuaW5pdGlhbGl6ZWRcIlxuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIF8gLT4gXCJVbm9yZGVyZWRfYXJyYXlfZm9sZFwiXG4gIHwgVmFyIF8gLT4gXCJWYXJcIlxuOztcblxubGV0IGludmFyaWFudCA6IHR5cGUgYS4gYSBJbnZhcmlhbnQudCAtPiBhIHQgSW52YXJpYW50LnQgPVxuICBmdW4gaW52YXJpYW50X2EgdCAtPlxuICBtYXRjaCB0IHdpdGhcbiAgfCBBcnJheV9mb2xkIGFycmF5X2ZvbGQgLT4gQXJyYXlfZm9sZC5pbnZhcmlhbnQgaWdub3JlIGludmFyaWFudF9hIGFycmF5X2ZvbGRcbiAgfCBBdCBhdCAtPiBBdC5pbnZhcmlhbnQgYXRcbiAgfCBBdF9pbnRlcnZhbHMgYXRfaW50ZXJ2YWxzIC0+IEF0X2ludGVydmFscy5pbnZhcmlhbnQgYXRfaW50ZXJ2YWxzXG4gIHwgQmluZF9saHNfY2hhbmdlIGJpbmQgLT4gQmluZC5pbnZhcmlhbnQgaWdub3JlIGlnbm9yZSBiaW5kXG4gIHwgQmluZF9tYWluIGJpbmQgLT4gQmluZC5pbnZhcmlhbnQgaWdub3JlIGludmFyaWFudF9hIGJpbmRcbiAgfCBDb25zdCBhIC0+IGludmFyaWFudF9hIGFcbiAgfCBFeHBlcnQgZSAtPiBFeHBlcnQuaW52YXJpYW50IGludmFyaWFudF9hIGVcbiAgfCBGcmVlemUgZnJlZXplIC0+IEZyZWV6ZS5pbnZhcmlhbnQgaW52YXJpYW50X2EgZnJlZXplXG4gIHwgSWZfdGVzdF9jaGFuZ2UgaWZfdGhlbl9lbHNlIC0+IElmX3RoZW5fZWxzZS5pbnZhcmlhbnQgaWdub3JlIGlmX3RoZW5fZWxzZVxuICB8IElmX3RoZW5fZWxzZSBpZl90aGVuX2Vsc2UgLT4gSWZfdGhlbl9lbHNlLmludmFyaWFudCBpbnZhcmlhbnRfYSBpZl90aGVuX2Vsc2VcbiAgfCBJbnZhbGlkIC0+ICgpXG4gIHwgSm9pbl9saHNfY2hhbmdlIGpvaW4gLT4gSm9pbi5pbnZhcmlhbnQgaWdub3JlIGpvaW5cbiAgfCBKb2luX21haW4gam9pbiAtPiBKb2luLmludmFyaWFudCBpbnZhcmlhbnRfYSBqb2luXG4gIHwgTWFwIF9cbiAgfCBNYXAyIF9cbiAgfCBNYXAzIF9cbiAgfCBNYXA0IF9cbiAgfCBNYXA1IF9cbiAgfCBNYXA2IF9cbiAgfCBNYXA3IF9cbiAgfCBNYXA4IF9cbiAgfCBNYXA5IF9cbiAgfCBNYXAxMCBfXG4gIHwgTWFwMTEgX1xuICB8IE1hcDEyIF9cbiAgfCBNYXAxMyBfXG4gIHwgTWFwMTQgX1xuICB8IE1hcDE1IF8gLT4gKClcbiAgfCBTbmFwc2hvdCBzbmFwc2hvdCAtPiBTbmFwc2hvdC5pbnZhcmlhbnQgaW52YXJpYW50X2Egc25hcHNob3RcbiAgfCBTdGVwX2Z1bmN0aW9uIHN0ZXBfZnVuY3Rpb25fbm9kZSAtPlxuICAgIFN0ZXBfZnVuY3Rpb25fbm9kZS5pbnZhcmlhbnQgaW52YXJpYW50X2Egc3RlcF9mdW5jdGlvbl9ub2RlXG4gIHwgVW5pbml0aWFsaXplZCAtPiAoKVxuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHVub3JkZXJlZF9hcnJheV9mb2xkIC0+XG4gICAgVW5vcmRlcmVkX2FycmF5X2ZvbGQuaW52YXJpYW50IGlnbm9yZSBpbnZhcmlhbnRfYSB1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICB8IFZhciB2YXIgLT4gVmFyLmludmFyaWFudCBpZ25vcmUgdmFyXG47O1xuXG5sZXQgaW5pdGlhbF9udW1fY2hpbGRyZW4gKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQXQgXyAtPiAwXG4gIHwgQXRfaW50ZXJ2YWxzIF8gLT4gMFxuICB8IEJpbmRfbGhzX2NoYW5nZSBfIC0+IDFcbiAgfCBCaW5kX21haW4gXyAtPiAyXG4gIHwgQ29uc3QgXyAtPiAwXG4gIHwgRXhwZXJ0IF8gLT4gMFxuICB8IEZyZWV6ZSBfIC0+IDFcbiAgfCBJZl90ZXN0X2NoYW5nZSBfIC0+IDFcbiAgfCBJZl90aGVuX2Vsc2UgXyAtPiAyXG4gIHwgSW52YWxpZCAtPiAwXG4gIHwgSm9pbl9saHNfY2hhbmdlIF8gLT4gMVxuICB8IEpvaW5fbWFpbiBfIC0+IDJcbiAgfCBNYXAgXyAtPiAxXG4gIHwgTWFwMiBfIC0+IDJcbiAgfCBNYXAzIF8gLT4gM1xuICB8IE1hcDQgXyAtPiA0XG4gIHwgTWFwNSBfIC0+IDVcbiAgfCBNYXA2IF8gLT4gNlxuICB8IE1hcDcgXyAtPiA3XG4gIHwgTWFwOCBfIC0+IDhcbiAgfCBNYXA5IF8gLT4gOVxuICB8IE1hcDEwIF8gLT4gMTBcbiAgfCBNYXAxMSBfIC0+IDExXG4gIHwgTWFwMTIgXyAtPiAxMlxuICB8IE1hcDEzIF8gLT4gMTNcbiAgfCBNYXAxNCBfIC0+IDE0XG4gIHwgTWFwMTUgXyAtPiAxNVxuICB8IFNuYXBzaG90IF8gLT4gMFxuICB8IFN0ZXBfZnVuY3Rpb24gXyAtPiAxXG4gIHwgVW5pbml0aWFsaXplZCAtPiAwXG4gIHwgVmFyIF8gLT4gMFxuICB8IEFycmF5X2ZvbGQgeyBjaGlsZHJlbjsgXyB9IC0+IEFycmF5Lmxlbmd0aCBjaGlsZHJlblxuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHsgY2hpbGRyZW47IF8gfSAtPiBBcnJheS5sZW5ndGggY2hpbGRyZW5cbjs7XG5cbmxldCBiaW5kX3Joc19jaGlsZF9pbmRleCA9IDFcbmxldCBmcmVlemVfY2hpbGRfaW5kZXggPSAwXG5sZXQgaWZfYnJhbmNoX2NoaWxkX2luZGV4ID0gMVxubGV0IGpvaW5fcmhzX2NoaWxkX2luZGV4ID0gMVxuXG4oKiBXZSBkbyBub3QgaW1wbGVtZW50IHRoZSB0aW1lLWJhc2VkIG5vZGVzIChbQXRdLCBbQXRfaW50ZXJ2YWxzXSwgW1NuYXBzaG90XSxcbiAgIFtTdGVwX2Z1bmN0aW9uXSkgYXMgcGFyZW50cyBvZiB0aGUgY3VycmVudC10aW1lIG5vZGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBXZSBkb24ndFxuICAgd2FudCBhbGwgc3VjaCBub2RlcyB0byBiZSByZWNvbXB1dGVkIHdoZW5ldmVyIHRoZSB0aW1lIGNoYW5nZXMsIHdoaWNoIHdvdWxkIGJlIGhvcnJpYmx5XG4gICBpbm5lZmljaWVudC4gIEluc3RlYWQsIHdlIG9ubHkgd2FudCB0aGVtIHRvIGJlIHJlY29tcHV0ZWQgYXQgdGhlIFwicmlnaHRcIiB0aW1lLFxuICAgaS5lLiB3aGVuIHRpbWUgcGFzc2VzIHNvbWUgdGhyZXNob2xkIHJlbGV2YW50IHRvIHRoZW0uICBXZSBkbyB0aGlzIHZpYSBzY2hlZHVsaW5nXG4gICBhbGFybXMgYXQgdGhvc2UgdGhyZXNob2xkcy4gKilcbmxldCBpdGVyaV9jaGlsZHJlbiAodHlwZSBhKSAodCA6IGEgdCkgfihmIDogaW50IC0+IE5vZGUuUGFja2VkLnQgLT4gdW5pdCkgOiB1bml0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQXJyYXlfZm9sZCB7IGNoaWxkcmVuOyBfIH0gLT5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNoaWxkcmVuIC0gMSBkb1xuICAgICAgZiBpIChUIChBcnJheS51bnNhZmVfZ2V0IGNoaWxkcmVuIGkpKVxuICAgIGRvbmVcbiAgfCBBdCBfIC0+ICgpXG4gIHwgQXRfaW50ZXJ2YWxzIF8gLT4gKClcbiAgfCBCaW5kX2xoc19jaGFuZ2UgYmluZCAtPiBmIDAgKFQgYmluZC5saHMpXG4gIHwgQmluZF9tYWluIHsgbGhzX2NoYW5nZTsgcmhzOyBfIH0gLT5cbiAgICAoKiBWYXJpb3VzIGNvZGUsIGUuZy4gW3N0YXRlLmJlY2FtZV9uZWNlc3NhcnldLCByZWxpZXMgb24gcHJvY2Vzc2luZyBbbGhzX2NoYW5nZV1cbiAgICAgICBiZWZvcmUgW3Joc10uICopXG4gICAgZiAwIChUIGxoc19jaGFuZ2UpO1xuICAgIGlmIFVvcHQuaXNfc29tZSByaHMgdGhlbiBmIDEgKFQgKFVvcHQudW5zYWZlX3ZhbHVlIHJocykpXG4gIHwgQ29uc3QgXyAtPiAoKVxuICB8IEV4cGVydCB7IGNoaWxkcmVuOyBudW1fY2hpbGRyZW47IF8gfSAtPlxuICAgIGZvciBpID0gMCB0byBudW1fY2hpbGRyZW4gLSAxIGRvXG4gICAgICBsZXQgKEV4cGVydC5FIHIpID0gVW9wdC52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCBjaGlsZHJlbiBpKSBpblxuICAgICAgZiBpIChUIHIuY2hpbGQpXG4gICAgZG9uZVxuICB8IEZyZWV6ZSB7IGNoaWxkOyBfIH0gLT4gZiAwIChUIGNoaWxkKVxuICB8IElmX3Rlc3RfY2hhbmdlIHsgdGVzdDsgXyB9IC0+IGYgMCAoVCB0ZXN0KVxuICB8IElmX3RoZW5fZWxzZSB7IHRlc3RfY2hhbmdlOyBjdXJyZW50X2JyYW5jaDsgXyB9IC0+XG4gICAgZiAwIChUIHRlc3RfY2hhbmdlKTtcbiAgICBpZiBVb3B0LmlzX3NvbWUgY3VycmVudF9icmFuY2ggdGhlbiBmIDEgKFQgKFVvcHQudW5zYWZlX3ZhbHVlIGN1cnJlbnRfYnJhbmNoKSlcbiAgfCBJbnZhbGlkIC0+ICgpXG4gIHwgSm9pbl9saHNfY2hhbmdlIHsgbGhzOyBfIH0gLT4gZiAwIChUIGxocylcbiAgfCBKb2luX21haW4geyBsaHNfY2hhbmdlOyByaHM7IF8gfSAtPlxuICAgIGYgMCAoVCBsaHNfY2hhbmdlKTtcbiAgICBpZiBVb3B0LmlzX3NvbWUgcmhzIHRoZW4gZiAxIChUIChVb3B0LnVuc2FmZV92YWx1ZSByaHMpKVxuICB8IFNuYXBzaG90IF8gLT4gKClcbiAgfCBTdGVwX2Z1bmN0aW9uIHsgY2hpbGQ7IF8gfSAtPlxuICAgIGlmIFVvcHQuaXNfc29tZSBjaGlsZCB0aGVuIGYgMCAoVCAoVW9wdC51bnNhZmVfdmFsdWUgY2hpbGQpKVxuICB8IFVuaW5pdGlhbGl6ZWQgLT4gKClcbiAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCB7IGNoaWxkcmVuOyBfIH0gLT5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNoaWxkcmVuIC0gMSBkb1xuICAgICAgZiBpIChUIChBcnJheS51bnNhZmVfZ2V0IGNoaWxkcmVuIGkpKVxuICAgIGRvbmVcbiAgfCBWYXIgXyAtPiAoKVxuICB8IE1hcCAoXywgbm9kZTApIC0+IGYgMCAoVCBub2RlMClcbiAgfCBNYXAyIChfLCBub2RlMCwgbm9kZTEpIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpXG4gIHwgTWFwMyAoXywgbm9kZTAsIG5vZGUxLCBub2RlMikgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKVxuICB8IE1hcDQgKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzKSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMylcbiAgfCBNYXA1IChfLCBub2RlMCwgbm9kZTEsIG5vZGUyLCBub2RlMywgbm9kZTQpIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpXG4gIHwgTWFwNiAoXywgbm9kZTAsIG5vZGUxLCBub2RlMiwgbm9kZTMsIG5vZGU0LCBub2RlNSkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KVxuICB8IE1hcDcgKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzLCBub2RlNCwgbm9kZTUsIG5vZGU2KSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpO1xuICAgIGYgNiAoVCBub2RlNilcbiAgfCBNYXA4IChfLCBub2RlMCwgbm9kZTEsIG5vZGUyLCBub2RlMywgbm9kZTQsIG5vZGU1LCBub2RlNiwgbm9kZTcpIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpO1xuICAgIGYgNSAoVCBub2RlNSk7XG4gICAgZiA2IChUIG5vZGU2KTtcbiAgICBmIDcgKFQgbm9kZTcpXG4gIHwgTWFwOSAoXywgbm9kZTAsIG5vZGUxLCBub2RlMiwgbm9kZTMsIG5vZGU0LCBub2RlNSwgbm9kZTYsIG5vZGU3LCBub2RlOCkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KVxuICB8IE1hcDEwIChfLCBub2RlMCwgbm9kZTEsIG5vZGUyLCBub2RlMywgbm9kZTQsIG5vZGU1LCBub2RlNiwgbm9kZTcsIG5vZGU4LCBub2RlOSkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpXG4gIHwgTWFwMTEgKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzLCBub2RlNCwgbm9kZTUsIG5vZGU2LCBub2RlNywgbm9kZTgsIG5vZGU5LCBub2RlMTApXG4gICAgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpO1xuICAgIGYgMTAgKFQgbm9kZTEwKVxuICB8IE1hcDEyXG4gICAgICAoIF9cbiAgICAgICwgbm9kZTBcbiAgICAgICwgbm9kZTFcbiAgICAgICwgbm9kZTJcbiAgICAgICwgbm9kZTNcbiAgICAgICwgbm9kZTRcbiAgICAgICwgbm9kZTVcbiAgICAgICwgbm9kZTZcbiAgICAgICwgbm9kZTdcbiAgICAgICwgbm9kZThcbiAgICAgICwgbm9kZTlcbiAgICAgICwgbm9kZTEwXG4gICAgICAsIG5vZGUxMSApIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpO1xuICAgIGYgNSAoVCBub2RlNSk7XG4gICAgZiA2IChUIG5vZGU2KTtcbiAgICBmIDcgKFQgbm9kZTcpO1xuICAgIGYgOCAoVCBub2RlOCk7XG4gICAgZiA5IChUIG5vZGU5KTtcbiAgICBmIDEwIChUIG5vZGUxMCk7XG4gICAgZiAxMSAoVCBub2RlMTEpXG4gIHwgTWFwMTNcbiAgICAgICggX1xuICAgICAgLCBub2RlMFxuICAgICAgLCBub2RlMVxuICAgICAgLCBub2RlMlxuICAgICAgLCBub2RlM1xuICAgICAgLCBub2RlNFxuICAgICAgLCBub2RlNVxuICAgICAgLCBub2RlNlxuICAgICAgLCBub2RlN1xuICAgICAgLCBub2RlOFxuICAgICAgLCBub2RlOVxuICAgICAgLCBub2RlMTBcbiAgICAgICwgbm9kZTExXG4gICAgICAsIG5vZGUxMiApIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpO1xuICAgIGYgNSAoVCBub2RlNSk7XG4gICAgZiA2IChUIG5vZGU2KTtcbiAgICBmIDcgKFQgbm9kZTcpO1xuICAgIGYgOCAoVCBub2RlOCk7XG4gICAgZiA5IChUIG5vZGU5KTtcbiAgICBmIDEwIChUIG5vZGUxMCk7XG4gICAgZiAxMSAoVCBub2RlMTEpO1xuICAgIGYgMTIgKFQgbm9kZTEyKVxuICB8IE1hcDE0XG4gICAgICAoIF9cbiAgICAgICwgbm9kZTBcbiAgICAgICwgbm9kZTFcbiAgICAgICwgbm9kZTJcbiAgICAgICwgbm9kZTNcbiAgICAgICwgbm9kZTRcbiAgICAgICwgbm9kZTVcbiAgICAgICwgbm9kZTZcbiAgICAgICwgbm9kZTdcbiAgICAgICwgbm9kZThcbiAgICAgICwgbm9kZTlcbiAgICAgICwgbm9kZTEwXG4gICAgICAsIG5vZGUxMVxuICAgICAgLCBub2RlMTJcbiAgICAgICwgbm9kZTEzICkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpO1xuICAgIGYgMTAgKFQgbm9kZTEwKTtcbiAgICBmIDExIChUIG5vZGUxMSk7XG4gICAgZiAxMiAoVCBub2RlMTIpO1xuICAgIGYgMTMgKFQgbm9kZTEzKVxuICB8IE1hcDE1XG4gICAgICAoIF9cbiAgICAgICwgbm9kZTBcbiAgICAgICwgbm9kZTFcbiAgICAgICwgbm9kZTJcbiAgICAgICwgbm9kZTNcbiAgICAgICwgbm9kZTRcbiAgICAgICwgbm9kZTVcbiAgICAgICwgbm9kZTZcbiAgICAgICwgbm9kZTdcbiAgICAgICwgbm9kZThcbiAgICAgICwgbm9kZTlcbiAgICAgICwgbm9kZTEwXG4gICAgICAsIG5vZGUxMVxuICAgICAgLCBub2RlMTJcbiAgICAgICwgbm9kZTEzXG4gICAgICAsIG5vZGUxNCApIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpO1xuICAgIGYgNSAoVCBub2RlNSk7XG4gICAgZiA2IChUIG5vZGU2KTtcbiAgICBmIDcgKFQgbm9kZTcpO1xuICAgIGYgOCAoVCBub2RlOCk7XG4gICAgZiA5IChUIG5vZGU5KTtcbiAgICBmIDEwIChUIG5vZGUxMCk7XG4gICAgZiAxMSAoVCBub2RlMTEpO1xuICAgIGYgMTIgKFQgbm9kZTEyKTtcbiAgICBmIDEzIChUIG5vZGUxMyk7XG4gICAgZiAxNCAoVCBub2RlMTQpXG47O1xuXG4oKiBbc2xvd19nZXRfY2hpbGRdIGlzIG9ubHkgdXNlZCBieSBbTm9kZS5pbnZhcmlhbnRdLCBzbyB3ZSBkb24ndCBtaW5kIHVzaW5nIFt3aXRoX3JldHVybl1cbiAgIGFuZCBbaXRlcmlfY2hpbGRyZW5dLiAgSWYgd2UgZXZlciBuZWVkIGEgZmFzdCBbZ2V0X2NoaWxkXSwgd2UgY29kZWQgaXQgaW4gcmV2XG4gICA0OGRiZmQwM2M5YzUuICopXG5sZXQgc2xvd19nZXRfY2hpbGQgOiB0eXBlIGEuIGEgdCAtPiBpbmRleDpfIC0+IE5vZGUuUGFja2VkLnQgPVxuICBmdW4gdCB+aW5kZXggLT5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQXJyYXlfZm9sZCB7IGNoaWxkcmVuOyBfIH0gLT4gVCBjaGlsZHJlbi4oaW5kZXgpXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgeyBjaGlsZHJlbjsgXyB9IC0+IFQgY2hpbGRyZW4uKGluZGV4KVxuICB8IEV4cGVydCB7IGNoaWxkcmVuOyBfIH0gLT5cbiAgICBsZXQgKEUgZWRnZSkgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgY2hpbGRyZW4gaW5kZXgpIGluXG4gICAgVCBlZGdlLmNoaWxkXG4gIHwgXyAtPlxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmlfY2hpbGRyZW4gdCB+ZjooZnVuIGkgY2hpbGQgLT4gaWYgaSA9IGluZGV4IHRoZW4gci5yZXR1cm4gY2hpbGQpO1xuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJLaW5kLnNsb3dfZ2V0X2NoaWxkIGdvdCBpbnZhbGlkIGluZGV4XCJcbiAgICAgICAgKGluZGV4LCB0KVxuICAgICAgICBbJXNleHBfb2Y6IGludCAqIF8gdF0pXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBLaW5kXG5tb2R1bGUgSW50ZXJuYWxfb2JzZXJ2ZXIgPSBUeXBlcy5JbnRlcm5hbF9vYnNlcnZlclxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5vcGVuIE5vZGVcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuTm9kZS50ID1cbiAgeyAoKiBbaWRdIGlzIGEgdW5pcXVlIGlkIGZvciB0aGUgbm9kZS4gKilcbiAgICBpZCA6IE5vZGVfaWQudFxuICA7IHN0YXRlIDogKFR5cGVzLlN0YXRlLnRbQHNleHAub3BhcXVlXSlcbiAgOyAoKiBUaGUgZmllbGRzIGZyb20gW3JlY29tcHV0ZWRfYXRdIHRvIFtjcmVhdGVkX2luXSBhcmUgZ3JvdXBlZCB0b2dldGhlciBhbmQgYXJlIGluIHRoZVxuICAgICAgIHNhbWUgb3JkZXIgYXMgdGhleSBhcmUgdXNlZCBieSBbU3RhdGUucmVjb21wdXRlXSBUaGlzIGhhcyBhIHBvc2l0aXZlIHBlcmZvcm1hbmNlXG4gICAgICAgaW1wYWN0IGR1ZSB0byBjYWNoZSBlZmZlY3RzLiAgRG9uJ3QgY2hhbmdlIHRoZSBvcmRlciBvZiB0aGVzZSBub2RlcyB3aXRob3V0XG4gICAgICAgcGVyZm9ybWFuY2UgdGVzdGluZy4gKilcbiAgICAoKiBbcmVjb21wdXRlZF9hdF0gaXMgdGhlIGxhc3Qgc3RhYmlsaXphdGlvbiB3aGVuIFt0XSdzIHZhbHVlIHdhcyByZWNvbXB1dGVkLCBldmVuIGlmXG4gICAgICAgaXQgd2FzIGN1dCBvZmYuICopXG4gICAgbXV0YWJsZSByZWNvbXB1dGVkX2F0IDogU3RhYmlsaXphdGlvbl9udW0udFxuICA7ICgqIFt2YWx1ZV9vcHRdIHN0YXJ0cyBhcyBbbm9uZV0sIGFuZCB0aGUgZmlyc3QgdGltZSBbdF0gaXMgY29tcHV0ZWQgaXQgaXMgc2V0IHRvXG4gICAgICAgW3NvbWVdLCBhbmQgcmVtYWlucyBbc29tZV0gdGhlcmVhZnRlciwgdW50aWwgW3RdIGlzIGludmFsaWRhdGVkLCBpZiBldmVyLiAqKVxuICAgIG11dGFibGUgdmFsdWVfb3B0IDogJ2EgVW9wdC50XG4gIDsgKCogW2tpbmRdIGlzIHRoZSBraW5kIG9mIERBRyBub2RlIFt0XSBpcy4gIFtraW5kXSBpcyBtdXRhYmxlIGJvdGggZm9yIGluaXRpYWxpemF0aW9uXG4gICAgICAgYW5kIGJlY2F1c2UgaXQgY2FuIGNoYW5nZSwgZS5nLiBpZiBbdF0gaXMgaW52YWxpZGF0ZWQuICopXG4gICAgbXV0YWJsZSBraW5kIDogJ2EgS2luZC50XG4gIDsgbXV0YWJsZSBjdXRvZmYgOiAnYSBDdXRvZmYudFxuICA7ICgqIFtjaGFuZ2VkX2F0XSBpcyB0aGUgbGFzdCBzdGFiaWxpemF0aW9uIHdoZW4gdGhpcyBub2RlIHdhcyBjb21wdXRlZCBhbmQgbm90IGN1dCBvZmYuXG4gICAgICAgSXQgaXMgdXNlZCB0byBkZXRlY3Qgd2hlbiBbdF0ncyBwYXJlbnRzIGFyZSBzdGFsZSBhbmQgKGJlY2F1c2UgYWxsIHBhcmVudHMgYXJlXG4gICAgICAgbmVjZXNzYXJ5KSBuZWVkIHRvIGJlIHJlY29tcHV0ZWQuICopXG4gICAgbXV0YWJsZSBjaGFuZ2VkX2F0IDogU3RhYmlsaXphdGlvbl9udW0udFxuICA7ICgqIFtudW1fb25fdXBkYXRlX2hhbmRsZXJzXSBpcyBbTGlzdC5sZW5ndGggdC5vbl91cGRhdGVfaGFuZGxlcnNdIHBsdXMgdGhlIG51bWJlciBvZlxuICAgICAgIG9uLXVwZGF0ZSBoYW5kbGVycyBzdW1tZWQgb3ZlciBhbGwgb2JzZXJ2ZXJzIGluIFt0Lm9ic2VydmVyc10uICBJdCBpcyB1c2VkIHRvXG4gICAgICAgcXVpY2tseSBkZWNpZGUgd2hldGhlciBbdF0gbmVlZHMgdG8gYmUgYWRkZWQgdG8gW3N0YXRlLmhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXVxuICAgICAgIHdoZW4gW3RdIGNoYW5nZXMuICBbbnVtX29uX3VwZGF0ZV9oYW5kbGVyc10gd2lsbCBkZWNyZWFzZSB3aGVuIGFuIG9ic2VydmVyIGlzXG4gICAgICAgcmVtb3ZlZCBmcm9tIFt0Lm9ic2VydmVyc10sIGlmIHRoZSBvYnNlcnZlciBoYXMgb24tdXBkYXRlIGhhbmRsZXJzLiAqKVxuICAgIG11dGFibGUgbnVtX29uX3VwZGF0ZV9oYW5kbGVycyA6IGludFxuICA7ICgqIFRoZSBwYXJlbnRzIG9mIFt0XSBhcmUgdGhlIG5vZGVzIHRoYXQgZGVwZW5kIG9uIGl0LCBhbmQgc2hvdWxkIGJlIGNvbXB1dGVkIHdoZW4gW3RdXG4gICAgICAgY2hhbmdlcywgb25jZSBhbGwgb2YgdGhlaXIgb3RoZXIgY2hpbGRyZW4gYXJlIHVwIHRvIGRhdGUuICBbbnVtX3BhcmVudHNdIGlzIHRoZVxuICAgICAgIG51bWJlciBvZiBwYXJlbnRzLiAgSWYgW251bV9wYXJlbnRzID49IDFdLCB0aGVuIFtwYXJlbnQwXSBpcyB0aGUgZmlyc3QgcGFyZW50LlxuICAgICAgIFtwYXJlbnQxX2FuZF9iZXlvbmRdIGhvbGRzIHRoZSByZW1haW5pbmcgcGFyZW50cy4gIFRoZSBvcmRlciBvZiB0aGUgcGFyZW50cyBkb2Vzbid0XG4gICAgICAgbWF0dGVyLiAgT25lIG5vZGUgbWF5IG9jY3VyIG11bHRpcGxlIHRpbWVzIGFzIGEgcGFyZW50IG9mIGFub3RoZXIgKGUuZy4gY29uc2lkZXJcbiAgICAgICBbbWFwMiBuMSBuMSB+Zl0pLlxuXG4gICAgICAgVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIHRoZSBvdmVyd2hlbG1pbmdseSBjb21tb24gY2FzZSB0aGF0IGEgbm9kZSBoYXNcbiAgICAgICBvbmx5IG9uZSBwYXJlbnQuICopXG4gICAgbXV0YWJsZSBudW1fcGFyZW50cyA6IGludFxuICA7IG11dGFibGUgcGFyZW50MV9hbmRfYmV5b25kIDogUGFja2VkLnQgVW9wdC50IFVuaWZvcm1fYXJyYXkudFxuICA7IG11dGFibGUgcGFyZW50MCA6IFBhY2tlZC50IFVvcHQudFxuICA7ICgqIFtjcmVhdGVkX2luXSBpcyBpbml0aWFsbHkgdGhlIHNjb3BlIHRoYXQgdGhlIG5vZGUgaXMgY3JlYXRlZCBpbi4gIElmIGEgbm9kZSBpc1xuICAgICAgIGxhdGVyIFwicmVzY29wZWRcIiwgdGhlbiBjcmVhdGVkX2luIHdpbGwgYmUgYWRqdXN0ZWQgdG8gdGhlIG5ldyBzY29wZSB0aGF0IHRoZSBub2RlXG4gICAgICAgaXMgcGFydCBvZi4gKilcbiAgICBtdXRhYmxlIGNyZWF0ZWRfaW4gOiBTY29wZS50XG4gIDsgKCogW25leHRfbm9kZV9pbl9zYW1lX3Njb3BlXSBzaW5nbHkgbGlua3MgYWxsIG5vZGVzIGNyZWF0ZWQgaW4gW3QuY3JlYXRlZF9pbl0uICopXG4gICAgbXV0YWJsZSBuZXh0X25vZGVfaW5fc2FtZV9zY29wZSA6IFBhY2tlZC50IFVvcHQudFxuICA7ICgqIFtoZWlnaHRdIGlzIHVzZWQgdG8gdmlzaXQgbm9kZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuICBJZiBbaXNfbmVjZXNzYXJ5IHRdLCB0aGVuXG4gICAgICAgW2hlaWdodCA+IGMuaGVpZ2h0XSBmb3IgYWxsIGNoaWxkcmVuIFtjXSBvZiBbdF0sIGFuZCBbaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0XG4gICAgICAgdC5jcmVhdGVkX2luXS4gIElmIFtub3QgKGlzX25lY2Vzc2FyeSB0KV0sIHRoZW4gW2hlaWdodCA9IC0xXS4gKilcbiAgICBtdXRhYmxlIGhlaWdodCA6IGludFxuICA7ICgqIFtoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBdIGlzIHRoZSBoZWlnaHQgYXQgd2hpY2ggW3RdIGlzIHN0b3JlZCBpbiB0aGUgcmVjb21wdXRlXG4gICAgICAgaGVhcCwgYW5kIGlzIG5vbi1uZWdhdGl2ZSBpZmYgW3RdIGlzIGluIHRoZSByZWNvbXB1dGUgaGVhcC4gIElmIFt0XSBpcyB0aGVcbiAgICAgICByZWNvbXB1dGUgaGVhcCwgdGhlbiB0eXBpY2FsbHkgW3QuaGVpZ2h0ID0gdC5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBdOyBob3dldmVyLFxuICAgICAgIHdoaWxlIGhlaWdodCBpcyBiZWluZyBhZGp1c3RlZCwgb25lIGNhbiB0ZW1wb3JhcmlseSBoYXZlIFt0LmhlaWdodCA+XG4gICAgICAgdC5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBdLiAgV2hlbiBoZWlnaHQgYWRqdXN0bWVudCBmaW5pc2hlcywgZXF1YWxpdHkgaXMgcmVzdG9yZWRcbiAgICAgICBieSBpbmNyZWFzaW5nIFt0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcF0gdG8gW3QuaGVpZ2h0XSBhbmQgc2hpZnRpbmcgW3RdJ3NcbiAgICAgICBwb3NpdGlvbiBpbiB0aGUgcmVjb21wdXRlIGhlYXAuICopXG4gICAgbXV0YWJsZSBoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgOiBpbnRcbiAgOyAoKiBbcHJldl9pbl9yZWNvbXB1dGVfaGVhcF0gYW5kIFtuZXh0X2luX3JlY29tcHV0ZV9oZWFwXSBkb3VibHkgbGluayBhbGwgbm9kZXMgb2YgdGhlXG4gICAgICAgc2FtZSBoZWlnaHQgaW4gdGhlIHJlY29tcHV0ZSBoZWFwLiAqKVxuICAgIG11dGFibGUgcHJldl9pbl9yZWNvbXB1dGVfaGVhcCA6IFBhY2tlZC50IFVvcHQudFxuICA7IG11dGFibGUgbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCA6IFBhY2tlZC50IFVvcHQudFxuICA7ICgqIFtoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcF0gaXMgdXNlZCBvbmx5IGR1cmluZyBoZWlnaHQgYWRqdXN0bWVudCwgYW5kIGlzXG4gICAgICAgbm9uLW5lZ2F0aXZlIGlmZiBbdF0gaXMgaW4gdGhlIGFkanVzdC1oZWlnaHRzIGhlYXAuICBJdCBob2xkcyB0aGUgcHJlLWFkanVzdGVkXG4gICAgICAgaGVpZ2h0IG9mIFt0XS4gKilcbiAgICBtdXRhYmxlIGhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDogaW50XG4gIDsgKCogW25leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcF0gc2luZ2x5IGxpbmtzIGFsbCBub2RlcyBvZiB0aGUgc2FtZSBoZWlnaHQgaW4gdGhlXG4gICAgICAgYWRqdXN0LWhlaWdodHMgaGVhcC4gKilcbiAgICBtdXRhYmxlIG5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA6IFBhY2tlZC50IFVvcHQudFxuICA7ICgqIFtvbGRfdmFsdWVfb3B0XSBpcyB1c2VkIG9ubHkgZHVyaW5nIHN0YWJpbGl6YXRpb24sIGFuZCBvbmx5IGlmXG4gICAgICAgW3QubnVtX29uX3VwZGF0ZV9oYW5kbGVycyA+IDBdLiAgSXQgaG9sZHMgdGhlIHByZS1zdGFiaWxpemF0aW9uIHZhbHVlIG9mIFt0XS4gIEl0XG4gICAgICAgaXMgY2xlYXJlZCB3aGVuIHJ1bm5pbmcgW3RdJ3Mgb24tdXBkYXRlIGhhbmRsZXJzLCBhbmQgc28gaXMgYWx3YXlzIFtVb3B0Lm5vbmVdXG4gICAgICAgYmV0d2VlbiBzdGFiaWxpemF0aW9ucy4gKilcbiAgICBtdXRhYmxlIG9sZF92YWx1ZV9vcHQgOiAnYSBVb3B0LnRcbiAgOyAoKiBbb2JzZXJ2ZXJzXSBpcyB0aGUgaGVhZCBvZiB0aGUgZG91Ymx5LWxpbmtlZCBsaXN0IG9mIG9ic2VydmVycyBvZiBbdF0sIG9yXG4gICAgICAgW1VvcHQubm9uZV0gaWYgdGhlcmUgYXJlIG5vIG9ic2VydmVycy4gKilcbiAgICBtdXRhYmxlIG9ic2VydmVycyA6ICgnYSBJbnRlcm5hbF9vYnNlcnZlci50W0BzZXhwLm9wYXF1ZV0pIFVvcHQudFxuICA7ICgqIFtpc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0gaXMgdXNlZCB0byBhdm9pZCBwdXNoaW5nIHRoZSBzYW1lIG5vZGUgbXVsdGlwbGVcbiAgICAgICB0aW1lcyBvbnRvIFtzdGF0ZS5oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0uICopXG4gICAgbXV0YWJsZSBpc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiA6IGJvb2xcbiAgOyAoKiBbb25fdXBkYXRlX2hhbmRsZXJzXSBpcyB0aGUgZnVuY3Rpb25zIHN1cHBsaWVkIHRvIFtJbmNyZW1lbnRhbC5vbl91cGRhdGVdIHRvIGJlIHJ1blxuICAgICAgIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kdWxlIFtPbl91cGRhdGVfaGFuZGxlcl0uICBbb25fdXBkYXRlX2hhbmRsZXJzXSBkb2VzIG5vdFxuICAgICAgIGNvbnRhaW4gdGhlIG9uLXVwZGF0ZSBoYW5kbGVycyBpbiBbdC5vYnNlcnZlcnNdLiAgW29uX3VwZGF0ZV9oYW5kbGVyc10gb25seSBldmVyXG4gICAgICAgZ2V0cyBsb25nZXI7IHRoZXJlIGlzIG5vIHdheSB0byByZW1vdmUgZWxlbWVudHMuICopXG4gICAgbXV0YWJsZSBvbl91cGRhdGVfaGFuZGxlcnMgOiAnYSBPbl91cGRhdGVfaGFuZGxlci50IGxpc3RcbiAgOyBtdXRhYmxlIG15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleCA6IGludCBhcnJheVxuICA7IG11dGFibGUgbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4IDogaW50IGFycmF5XG4gIDsgbXV0YWJsZSBmb3JjZV9uZWNlc3NhcnkgOiBib29sXG4gIDsgbXV0YWJsZSB1c2VyX2luZm8gOiBEb3RfdXNlcl9pbmZvLnQgb3B0aW9uXG4gIDsgY3JlYXRpb25fYmFja3RyYWNlIDogQmFja3RyYWNlLnQgb3B0aW9uXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogXyB0KSAodDIgOiBfIHQpID0gcGh5c19zYW1lIHQxIHQyXG5sZXQgcGFja2VkX3NhbWUgKFBhY2tlZC5UIHQxKSAoUGFja2VkLlQgdDIpID0gc2FtZSB0MSB0MlxubGV0IGlzX25lY2Vzc2FyeSA9IE5vZGUuaXNfbmVjZXNzYXJ5XG5sZXQgaW5pdGlhbF9udW1fY2hpbGRyZW4gdCA9IEtpbmQuaW5pdGlhbF9udW1fY2hpbGRyZW4gdC5raW5kXG5sZXQgaXRlcmlfY2hpbGRyZW4gdCB+ZiA9IEtpbmQuaXRlcmlfY2hpbGRyZW4gdC5raW5kIH5mXG5sZXQgaXNfdmFsaWQgPSBOb2RlLmlzX3ZhbGlkXG5sZXQgdHlwZV9lcXVhbF9pZl9waHlzX3NhbWUgPSB0eXBlX2VxdWFsX2lmX3BoeXNfc2FtZVxuXG5sZXQgdXNlcl9pbmZvIHQgPVxuICBtYXRjaCB0LnVzZXJfaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoSW5mbyBpKSAtPiBTb21lIGlcbiAgfCBTb21lIG90aGVyIC0+IFNvbWUgKEluZm8uY3JlYXRlX3MgKERvdF91c2VyX2luZm8uc2V4cF9vZl90IG90aGVyKSlcbjs7XG5cbmxldCBzZXRfdXNlcl9pbmZvIHQgaW5mbyA9XG4gIHQudXNlcl9pbmZvXG4gIDwtIChtYXRjaCBpbmZvIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBpIC0+IFNvbWUgKEluZm8gaSkpXG47O1xuXG5sZXQgYXBwZW5kX3VzZXJfaW5mb19ncmFwaHZpeiB0IH5sYWJlbCB+YXR0cnMgPVxuICBsZXQgbmV3XyA9IERvdF91c2VyX2luZm8uZG90IH5sYWJlbCB+YXR0cmlidXRlczphdHRycyBpblxuICB0LnVzZXJfaW5mb1xuICA8LSAobWF0Y2ggdC51c2VyX2luZm8gd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIG5ld19cbiAgICB8IFNvbWUgb3RoZXIgLT4gU29tZSAoRG90X3VzZXJfaW5mby5hcHBlbmQgb3RoZXIgbmV3XykpXG47O1xuXG5sZXQgZWRnZV9pc19zdGFsZSB+Y2hpbGQgfnBhcmVudCA9XG4gIFN0YWJpbGl6YXRpb25fbnVtLmNvbXBhcmUgY2hpbGQuY2hhbmdlZF9hdCBwYXJlbnQucmVjb21wdXRlZF9hdCA+IDBcbjs7XG5cbmxldCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0ID1cbiAgbGV0IGlzX3N0YWxlID0gcmVmIGZhbHNlIGluXG4gIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIChUIGNoaWxkKSAtPlxuICAgIGlmIGVkZ2VfaXNfc3RhbGUgfmNoaWxkIH5wYXJlbnQ6dCB0aGVuIGlzX3N0YWxlIDo9IHRydWUpO1xuICAhaXNfc3RhbGVcbjs7XG5cbmxldCBpc19zdGFsZSA6IHR5cGUgYS4gYSB0IC0+IGJvb2wgPVxuICBmdW4gKHQgOiBhIHQpIC0+XG4gIG1hdGNoIHQua2luZCB3aXRoXG4gIHwgVW5pbml0aWFsaXplZCAtPiBhc3NlcnQgZmFsc2VcbiAgKCogQSBjb25zdCBub2RlIGlzIHN0YWxlIG9ubHkgYXQgaW5pdGlhbGl6YXRpb24uICopXG4gIHwgQ29uc3QgXyAtPiBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdFxuICAoKiBUaW1lLWJhc2VkIG5vZGVzIGFyZSBjb25zaWRlcmVkIHN0YWxlIHdoZW4gW3QucmVjb21wdXRlZF9hdF0gaXMgbm9uZSwgd2hpY2ggaGFwcGVuc1xuICAgICBhdCBpbml0aWFsaXphdGlvbiBhbmQgd2hlbiB0aGUgYWxhcm0gbWVjaGFuaXNtIG1ha2VzIGEgbm9kZSBzdGFsZSAoaXQgc2V0cyB0aGVcbiAgICAgW3QucmVjb21wdXRlZF9hdF0gdG8gW1N0YWJpbGl6YXRpb25fbnVtLm5vbmVdKS4gKilcbiAgfCBBdCBfIC0+IFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0XG4gIHwgQXRfaW50ZXJ2YWxzIF8gLT4gU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSB0LnJlY29tcHV0ZWRfYXRcbiAgfCBTbmFwc2hvdCBfIC0+IFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0XG4gICgqIFdlIG5ldmVyIGNvbnNpZGVyIGFuIGludmFsaWRhdGVkIG5vZGUgdG8gYmUgc3RhbGUgLS0gd2hlbiB3ZSBpbnZhbGlkYXRlIGEgbm9kZSwgd2VcbiAgICAgaW1tZWRpYXRlbHkgcHJvcGFnYXRlIGludmFsaWRpdHkgdG8gaXRzIGFuY2VzdG9ycy4gKilcbiAgfCBJbnZhbGlkIC0+IGZhbHNlXG4gICgqIEEgW1Zhcl0gbm9kZSBpcyBzdGFsZSBpZiBpdCB3YXMgc2V0IHNpbmNlIGl0IHdhcyByZWNvbXB1dGVkLiAqKVxuICB8IFZhciB7IHNldF9hdDsgXyB9IC0+IFN0YWJpbGl6YXRpb25fbnVtLmNvbXBhcmUgc2V0X2F0IHQucmVjb21wdXRlZF9hdCA+IDBcbiAgKCogTm9kZXMgdGhhdCBoYXZlIGNoaWxkcmVuLiAqKVxuICB8IEJpbmRfbGhzX2NoYW5nZSBfIC0+XG4gICAgU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSB0LnJlY29tcHV0ZWRfYXQgfHwgaXNfc3RhbGVfd2l0aF9yZXNwZWN0X3RvX2FfY2hpbGQgdFxuICB8IElmX3Rlc3RfY2hhbmdlIF8gLT5cbiAgICBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdCB8fCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0XG4gIHwgSm9pbl9saHNfY2hhbmdlIF8gLT5cbiAgICBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdCB8fCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0XG4gIHwgQXJyYXlfZm9sZCBfXG4gIHwgQmluZF9tYWluIF9cbiAgfCBGcmVlemUgX1xuICB8IElmX3RoZW5fZWxzZSBfXG4gIHwgSm9pbl9tYWluIF9cbiAgfCBNYXAgX1xuICB8IE1hcDIgX1xuICB8IE1hcDMgX1xuICB8IE1hcDQgX1xuICB8IE1hcDUgX1xuICB8IE1hcDYgX1xuICB8IE1hcDcgX1xuICB8IE1hcDggX1xuICB8IE1hcDkgX1xuICB8IE1hcDEwIF9cbiAgfCBNYXAxMSBfXG4gIHwgTWFwMTIgX1xuICB8IE1hcDEzIF9cbiAgfCBNYXAxNCBfXG4gIHwgTWFwMTUgX1xuICB8IFN0ZXBfZnVuY3Rpb24gX1xuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIF8gLT5cbiAgICBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdCB8fCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0XG4gIHwgRXhwZXJ0IHsgZm9yY2Vfc3RhbGU7IF8gfSAtPlxuICAgIGZvcmNlX3N0YWxlXG4gICAgfHwgU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSB0LnJlY29tcHV0ZWRfYXRcbiAgICB8fCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0XG47O1xuXG5sZXQgbmVlZHNfdG9fYmVfY29tcHV0ZWQgdCA9IGlzX25lY2Vzc2FyeSB0ICYmIGlzX3N0YWxlIHRcbmxldCBpc19pbl9yZWNvbXB1dGVfaGVhcCB0ID0gdC5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPj0gMFxubGV0IGlzX2luX2FkanVzdF9oZWlnaHRzX2hlYXAgdCA9IHQuaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPj0gMFxuXG5sZXQgZ2V0X3BhcmVudCB0IH5pbmRleCA9XG4gIFVvcHQudmFsdWVfZXhuXG4gICAgKGlmIGluZGV4ID0gMCB0aGVuIHQucGFyZW50MCBlbHNlIFVuaWZvcm1fYXJyYXkuZ2V0IHQucGFyZW50MV9hbmRfYmV5b25kIChpbmRleCAtIDEpKVxuOztcblxubGV0IGl0ZXJpX3BhcmVudHMgdCB+ZiA9XG4gIGlmIHQubnVtX3BhcmVudHMgPiAwXG4gIHRoZW4gKFxuICAgIGYgMCAoVW9wdC52YWx1ZV9leG4gdC5wYXJlbnQwKTtcbiAgICBmb3IgaW5kZXggPSAxIHRvIHQubnVtX3BhcmVudHMgLSAxIGRvXG4gICAgICBmIGluZGV4IChVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5wYXJlbnQxX2FuZF9iZXlvbmQgKGluZGV4IC0gMSkpKVxuICAgIGRvbmUpXG47O1xuXG5sZXQgaGFzX2NoaWxkIHQgfmNoaWxkID1cbiAgbGV0IGhhcyA9IHJlZiBmYWxzZSBpblxuICBpdGVyaV9jaGlsZHJlbiB0IH5mOihmdW4gXyAoVCBjaGlsZCcpIC0+IGhhcyA6PSAhaGFzIHx8IHNhbWUgY2hpbGQgY2hpbGQnKTtcbiAgIWhhc1xuOztcblxubGV0IGhhc19pbnZhbGlkX2NoaWxkIHQgPVxuICBsZXQgaGFzID0gcmVmIGZhbHNlIGluXG4gIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIChUIGNoaWxkKSAtPiBoYXMgOj0gIWhhcyB8fCBub3QgKGlzX3ZhbGlkIGNoaWxkKSk7XG4gICFoYXNcbjs7XG5cbmxldCBoYXNfcGFyZW50ICh0IDogXyB0KSB+cGFyZW50ID1cbiAgbGV0IGhhcyA9IHJlZiBmYWxzZSBpblxuICBpdGVyaV9wYXJlbnRzIHQgfmY6KGZ1biBfIChUIHBhcmVudCcpIC0+IGhhcyA6PSAhaGFzIHx8IHNhbWUgcGFyZW50IHBhcmVudCcpO1xuICAhaGFzXG47O1xuXG5sZXQgc2hvdWxkX2JlX2ludmFsaWRhdGVkIDogdHlwZSBhLiBhIHQgLT4gYm9vbCA9XG4gIGZ1biB0IC0+XG4gIG1hdGNoIHQua2luZCB3aXRoXG4gICgqIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gKilcbiAgfCBVbmluaXRpYWxpemVkIC0+IGFzc2VydCBmYWxzZVxuICB8IEF0IF8gLT4gZmFsc2VcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiBmYWxzZVxuICB8IENvbnN0IF8gfCBTbmFwc2hvdCBfIHwgVmFyIF8gLT4gZmFsc2VcbiAgfCBJbnZhbGlkIC0+IGZhbHNlXG4gICgqIE5vZGVzIHdpdGggYSBmaXhlZCBzZXQgb2YgY2hpbGRyZW4gYXJlIGludmFsaWQgaWYgYW55IGNoaWxkIGlzIGludmFsaWQuICopXG4gIHwgQXJyYXlfZm9sZCBfXG4gIHwgRnJlZXplIF9cbiAgfCBNYXAgX1xuICB8IE1hcDIgX1xuICB8IE1hcDMgX1xuICB8IE1hcDQgX1xuICB8IE1hcDUgX1xuICB8IE1hcDYgX1xuICB8IE1hcDcgX1xuICB8IE1hcDggX1xuICB8IE1hcDkgX1xuICB8IE1hcDEwIF9cbiAgfCBNYXAxMSBfXG4gIHwgTWFwMTIgX1xuICB8IE1hcDEzIF9cbiAgfCBNYXAxNCBfXG4gIHwgTWFwMTUgX1xuICB8IFN0ZXBfZnVuY3Rpb24gX1xuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIF8gLT4gaGFzX2ludmFsaWRfY2hpbGQgdFxuICAoKiBBICpfY2hhbmdlIG5vZGUgaXMgaW52YWxpZCBpZiB0aGUgbm9kZSBpdCBpcyB3YXRjaGluZyBmb3IgY2hhbmdlcyBpcyBpbnZhbGlkIChzYW1lXG4gICAgIHJlYXNvbiBhcyBhYm92ZSkuICBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gW2hhc19pbnZhbGlkX2NoaWxkIHRdLiAqKVxuICB8IEJpbmRfbGhzX2NoYW5nZSB7IGxoczsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgbGhzKVxuICB8IElmX3Rlc3RfY2hhbmdlIHsgdGVzdDsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgdGVzdClcbiAgfCBKb2luX2xoc19jaGFuZ2UgeyBsaHM7IF8gfSAtPiBub3QgKGlzX3ZhbGlkIGxocylcbiAgKCogW0JpbmRfbWFpbl0sIFtJZl90aGVuX2Vsc2VdLCBhbmQgW0pvaW5fbWFpbl0gYXJlIGludmFsaWQgaWYgdGhlaXIgKl9jaGFuZ2UgY2hpbGQgaXMsXG4gICAgIGJ1dCBub3QgbmVjZXNzYXJpbHkgaWYgdGhlaXIgb3RoZXIgY2hpbGRyZW4gYXJlIC0tIHRoZSBncmFwaCBtYXkgYmUgcmVzdHJ1Y3R1cmVkIHRvXG4gICAgIGF2b2lkIHRoZSBpbnZhbGlkaXR5IG9mIHRob3NlLiAqKVxuICB8IEJpbmRfbWFpbiB7IGxoc19jaGFuZ2U7IF8gfSAtPiBub3QgKGlzX3ZhbGlkIGxoc19jaGFuZ2UpXG4gIHwgSWZfdGhlbl9lbHNlIHsgdGVzdF9jaGFuZ2U7IF8gfSAtPiBub3QgKGlzX3ZhbGlkIHRlc3RfY2hhbmdlKVxuICB8IEpvaW5fbWFpbiB7IGxoc19jaGFuZ2U7IF8gfSAtPiBub3QgKGlzX3ZhbGlkIGxoc19jaGFuZ2UpXG4gIHwgRXhwZXJ0IF8gLT5cbiAgICAoKiBUaGlzIGlzIHNpbWlsYXIgdG8gd2hhdCB3ZSBkbyBmb3IgYmluZCBhYm92ZSwgZXhjZXB0IHRoYXQgYW55IGludmFsaWQgY2hpbGQgY2FuIGJlXG4gICAgICAgcmVtb3ZlZCwgc28gd2UgY2FuIG9ubHkgdGVsbCBpZiBhbiBleHBlcnQgbm9kZSBiZWNvbWVzIGludmFsaWQgd2hlbiBhbGwgaXRzXG4gICAgICAgZGVwZW5kZW5jaWVzIGhhdmUgZmlyZWQgKHdoaWNoIGluIHByYWN0aWNlIG1lYW5zIHdoZW4gd2UgYXJlIGFib3V0IHRvIHJ1biBpdCkuICopXG4gICAgZmFsc2Vcbjs7XG5cbmxldCBmb2xkX29ic2VydmVycyAodCA6IF8gdCkgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiB0Lm9ic2VydmVycyBpblxuICBsZXQgYWMgPSByZWYgaW5pdCBpblxuICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICBsZXQgb2JzZXJ2ZXIgPSBVb3B0LnZhbHVlX2V4biAhciBpblxuICAgIHIgOj0gb2JzZXJ2ZXIubmV4dF9pbl9vYnNlcnZpbmc7XG4gICAgYWMgOj0gZiAhYWMgb2JzZXJ2ZXJcbiAgZG9uZTtcbiAgIWFjXG47O1xuXG5sZXQgaXRlcl9vYnNlcnZlcnMgdCB+ZiA9IGZvbGRfb2JzZXJ2ZXJzIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBvYnNlcnZlciAtPiBmIG9ic2VydmVyKVxuXG5sZXQgaW52YXJpYW50ICh0eXBlIGEpIChpbnZhcmlhbnRfYSA6IGEgLT4gdW5pdCkgKHQgOiBhIHQpID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBbJXRlc3RfZXE6IGJvb2xdIChuZWVkc190b19iZV9jb21wdXRlZCB0KSAoaXNfaW5fcmVjb21wdXRlX2hlYXAgdCk7XG4gICAgaWYgaXNfbmVjZXNzYXJ5IHRcbiAgICB0aGVuIChcbiAgICAgIGFzc2VydCAodC5oZWlnaHQgPiBTY29wZS5oZWlnaHQgdC5jcmVhdGVkX2luKTtcbiAgICAgIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIChUIGNoaWxkKSAtPlxuICAgICAgICBhc3NlcnQgKHQuaGVpZ2h0ID4gY2hpbGQuaGVpZ2h0KTtcbiAgICAgICAgYXNzZXJ0IChoYXNfcGFyZW50IGNoaWxkIH5wYXJlbnQ6dCkpO1xuICAgICAgYXNzZXJ0IChub3QgKHNob3VsZF9iZV9pbnZhbGlkYXRlZCB0KSkpO1xuICAgIGl0ZXJpX3BhcmVudHMgdCB+ZjooZnVuIF8gKFQgcGFyZW50KSAtPlxuICAgICAgYXNzZXJ0IChoYXNfY2hpbGQgcGFyZW50IH5jaGlsZDp0KTtcbiAgICAgIGFzc2VydCAoaXNfbmVjZXNzYXJ5IHBhcmVudCk7XG4gICAgICBhc3NlcnQgKHQuaGVpZ2h0IDwgcGFyZW50LmhlaWdodCkpO1xuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aWQ6KGNoZWNrIE5vZGVfaWQuaW52YXJpYW50KVxuICAgICAgfnN0YXRlOmlnbm9yZVxuICAgICAgfnJlY29tcHV0ZWRfYXQ6KGNoZWNrIFN0YWJpbGl6YXRpb25fbnVtLmludmFyaWFudClcbiAgICAgIH52YWx1ZV9vcHQ6XG4gICAgICAgIChjaGVjayAoZnVuIHZhbHVlX29wdCAtPlxuICAgICAgICAgICBpZiBpc192YWxpZCB0ICYmIG5vdCAoaXNfc3RhbGUgdCkgdGhlbiBhc3NlcnQgKFVvcHQuaXNfc29tZSB2YWx1ZV9vcHQpO1xuICAgICAgICAgICBVb3B0LmludmFyaWFudCBpbnZhcmlhbnRfYSB2YWx1ZV9vcHQpKVxuICAgICAgfmtpbmQ6XG4gICAgICAgIChjaGVjayAoZnVuIGtpbmQgLT5cbiAgICAgICAgICAgS2luZC5pbnZhcmlhbnQgaW52YXJpYW50X2Ega2luZDtcbiAgICAgICAgICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICAgICAgIHwgRXhwZXJ0IGUgLT5cbiAgICAgICAgICAgICBFeHBlcnQuaW52YXJpYW50X2Fib3V0X251bV9pbnZhbGlkX2NoaWxkcmVuXG4gICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICB+aXNfbmVjZXNzYXJ5Oihpc19uZWNlc3NhcnkgdClcbiAgICAgICAgICAgfCBfIC0+ICgpKSlcbiAgICAgIH5jdXRvZmY6KGNoZWNrIChDdXRvZmYuaW52YXJpYW50IGludmFyaWFudF9hKSlcbiAgICAgIH5jaGFuZ2VkX2F0OlxuICAgICAgICAoY2hlY2sgKGZ1biBjaGFuZ2VkX2F0IC0+XG4gICAgICAgICAgIFN0YWJpbGl6YXRpb25fbnVtLmludmFyaWFudCBjaGFuZ2VkX2F0O1xuICAgICAgICAgICBpZiBTdGFiaWxpemF0aW9uX251bS5pc19zb21lIHQucmVjb21wdXRlZF9hdFxuICAgICAgICAgICB0aGVuIGFzc2VydCAoU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZSBjaGFuZ2VkX2F0IHQucmVjb21wdXRlZF9hdCA8PSAwKSkpXG4gICAgICB+bnVtX29uX3VwZGF0ZV9oYW5kbGVyczpcbiAgICAgICAgKGNoZWNrXG4gICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBpbnRdXG4gICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgKExpc3QubGVuZ3RoIHQub25fdXBkYXRlX2hhbmRsZXJzXG4gICAgICAgICAgICAgICAgICsgZm9sZF9vYnNlcnZlcnMgdCB+aW5pdDowIH5mOihmdW4gbiB7IG9uX3VwZGF0ZV9oYW5kbGVyczsgXyB9IC0+XG4gICAgICAgICAgICAgICAgICAgbiArIExpc3QubGVuZ3RoIG9uX3VwZGF0ZV9oYW5kbGVycykpKSlcbiAgICAgIH5udW1fcGFyZW50czpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX3BhcmVudHMgLT5cbiAgICAgICAgICAgYXNzZXJ0IChudW1fcGFyZW50cyA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChudW1fcGFyZW50cyA8PSAxICsgVW5pZm9ybV9hcnJheS5sZW5ndGggdC5wYXJlbnQxX2FuZF9iZXlvbmQpKSlcbiAgICAgIH5wYXJlbnQxX2FuZF9iZXlvbmQ6XG4gICAgICAgIChjaGVjayAoZnVuIHBhcmVudDFfYW5kX2JleW9uZCAtPlxuICAgICAgICAgICBmb3IgcGFyZW50X2luZGV4ID0gMSB0byBVbmlmb3JtX2FycmF5Lmxlbmd0aCBwYXJlbnQxX2FuZF9iZXlvbmQgZG9cbiAgICAgICAgICAgICBbJXRlc3RfZXE6IGJvb2xdXG4gICAgICAgICAgICAgICAocGFyZW50X2luZGV4IDwgdC5udW1fcGFyZW50cylcbiAgICAgICAgICAgICAgIChVb3B0LmlzX3NvbWVcbiAgICAgICAgICAgICAgICAgIChVbmlmb3JtX2FycmF5LmdldCBwYXJlbnQxX2FuZF9iZXlvbmQgKHBhcmVudF9pbmRleCAtIDEpKSlcbiAgICAgICAgICAgZG9uZSkpXG4gICAgICB+cGFyZW50MDpcbiAgICAgICAgKGNoZWNrIChmdW4gcGFyZW50MCAtPlxuICAgICAgICAgICBbJXRlc3RfZXE6IGJvb2xdICh0Lm51bV9wYXJlbnRzID4gMCkgKFVvcHQuaXNfc29tZSBwYXJlbnQwKSkpXG4gICAgICB+Y3JlYXRlZF9pbjooY2hlY2sgU2NvcGUuaW52YXJpYW50KVxuICAgICAgfm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlOlxuICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X25vZGVfaW5fc2FtZV9zY29wZSAtPlxuICAgICAgICAgICBpZiBTY29wZS5pc190b3AgdC5jcmVhdGVkX2luIHx8IG5vdCAoaXNfdmFsaWQgdClcbiAgICAgICAgICAgdGhlbiBhc3NlcnQgKFVvcHQuaXNfbm9uZSBuZXh0X25vZGVfaW5fc2FtZV9zY29wZSkpKVxuICAgICAgfmhlaWdodDpcbiAgICAgICAgKGNoZWNrIChmdW4gaGVpZ2h0IC0+XG4gICAgICAgICAgIGlmIGlzX25lY2Vzc2FyeSB0IHRoZW4gYXNzZXJ0IChoZWlnaHQgPj0gMCkgZWxzZSBhc3NlcnQgKGhlaWdodCA9IC0xKSkpXG4gICAgICB+aGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwOlxuICAgICAgICAoY2hlY2sgKGZ1biBoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgLT5cbiAgICAgICAgICAgYXNzZXJ0IChoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPj0gLTEpO1xuICAgICAgICAgICBhc3NlcnQgKGhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA8PSB0LmhlaWdodCkpKVxuICAgICAgfnByZXZfaW5fcmVjb21wdXRlX2hlYXA6XG4gICAgICAgIChjaGVjayAoZnVuIChwcmV2X2luX3JlY29tcHV0ZV9oZWFwIDogUGFja2VkLnQgVW9wdC50KSAtPlxuICAgICAgICAgICBpZiBub3QgKGlzX2luX3JlY29tcHV0ZV9oZWFwIHQpXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChVb3B0LmlzX25vbmUgcHJldl9pbl9yZWNvbXB1dGVfaGVhcCk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBwcmV2X2luX3JlY29tcHV0ZV9oZWFwXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCAoVCBwcmV2KSA9IFVvcHQudmFsdWVfZXhuIHByZXZfaW5fcmVjb21wdXRlX2hlYXAgaW5cbiAgICAgICAgICAgICBhc3NlcnQgKHBhY2tlZF9zYW1lIChUIHQpIChVb3B0LnZhbHVlX2V4biBwcmV2Lm5leHRfaW5fcmVjb21wdXRlX2hlYXApKTtcbiAgICAgICAgICAgICBhc3NlcnQgKHQuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwID0gcHJldi5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXApKSkpXG4gICAgICB+bmV4dF9pbl9yZWNvbXB1dGVfaGVhcDpcbiAgICAgICAgKGNoZWNrIChmdW4gKG5leHRfaW5fcmVjb21wdXRlX2hlYXAgOiBQYWNrZWQudCBVb3B0LnQpIC0+XG4gICAgICAgICAgIGlmIG5vdCAoaXNfaW5fcmVjb21wdXRlX2hlYXAgdClcbiAgICAgICAgICAgdGhlbiBhc3NlcnQgKFVvcHQuaXNfbm9uZSBuZXh0X2luX3JlY29tcHV0ZV9oZWFwKTtcbiAgICAgICAgICAgaWYgVW9wdC5pc19zb21lIG5leHRfaW5fcmVjb21wdXRlX2hlYXBcbiAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgbGV0IChUIG5leHQpID0gVW9wdC52YWx1ZV9leG4gbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCBpblxuICAgICAgICAgICAgIGFzc2VydCAocGFja2VkX3NhbWUgKFQgdCkgKFVvcHQudmFsdWVfZXhuIG5leHQucHJldl9pbl9yZWNvbXB1dGVfaGVhcCkpO1xuICAgICAgICAgICAgIGFzc2VydCAodC5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPSBuZXh0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCkpKSlcbiAgICAgIH5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcDpcbiAgICAgICAgKGNoZWNrIChmdW4gaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgLT5cbiAgICAgICAgICAgaWYgaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPj0gMFxuICAgICAgICAgICB0aGVuIGFzc2VydCAoaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPCB0LmhlaWdodCkpKVxuICAgICAgfm5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcDpcbiAgICAgICAgKGNoZWNrIChmdW4gKG5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA6IFBhY2tlZC50IFVvcHQudCkgLT5cbiAgICAgICAgICAgaWYgbm90IChpc19pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIHQpXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChVb3B0LmlzX25vbmUgbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwKVxuICAgICAgICAgICBlbHNlIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXBcbiAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgbGV0IChUIG5leHQpID0gVW9wdC52YWx1ZV9leG4gbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIGluXG4gICAgICAgICAgICAgYXNzZXJ0IChpc19pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIG5leHQpO1xuICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICB0LmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwID0gbmV4dC5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCkpKSlcbiAgICAgIH5vbGRfdmFsdWVfb3B0OihjaGVjayAoVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfm9ic2VydmVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gXyAtPlxuICAgICAgICAgICBpdGVyX29ic2VydmVycyB0IH5mOihmdW4geyBzdGF0ZTsgb2JzZXJ2aW5nOyBfIH0gLT5cbiAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgdCBvYnNlcnZpbmcpO1xuICAgICAgICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgICB8IENyZWF0ZWQgfCBVbmxpbmtlZCAtPiBhc3NlcnQgZmFsc2UpKSlcbiAgICAgIH5pc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbjppZ25vcmVcbiAgICAgIH5vbl91cGRhdGVfaGFuZGxlcnM6aWdub3JlXG4gICAgICB+dXNlcl9pbmZvOmlnbm9yZVxuICAgICAgfm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleDpcbiAgICAgICAgKGNoZWNrIChmdW4gbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IC0+XG4gICAgICAgICAgIChtYXRjaCB0LmtpbmQgd2l0aFxuICAgICAgICAgICAgfCBFeHBlcnQgXyAtPiAoKVxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IGludF1cbiAgICAgICAgICAgICAgICAoQXJyYXkubGVuZ3RoIG15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleClcbiAgICAgICAgICAgICAgICB+ZXhwZWN0Oihpbml0aWFsX251bV9jaGlsZHJlbiB0KSk7XG4gICAgICAgICAgIGlmIGlzX25lY2Vzc2FyeSB0XG4gICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICBpdGVyaV9jaGlsZHJlbiB0IH5mOihmdW4gY2hpbGRfaW5kZXggKFQgY2hpbGQpIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBwYWNrZWRfc2FtZVxuICAgICAgICAgICAgICAgICAgIChUIHQpXG4gICAgICAgICAgICAgICAgICAgKGdldF9wYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgIH5pbmRleDpteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4KSkpKTtcbiAgICAgICAgICAgaWYgZGVidWcgJiYgbm90IChpc19uZWNlc3NhcnkgdClcbiAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgIEFycmF5Lml0ZXIgbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IH5mOihmdW4geCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0ICh4ID0gLTEpKSkpXG4gICAgICB+bXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4OlxuICAgICAgICAoY2hlY2sgKGZ1biBteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXggLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogaW50XVxuICAgICAgICAgICAgIChBcnJheS5sZW5ndGggbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4KVxuICAgICAgICAgICAgIH5leHBlY3Q6KFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQucGFyZW50MV9hbmRfYmV5b25kICsgMSk7XG4gICAgICAgICAgIGl0ZXJpX3BhcmVudHMgdCB+ZjooZnVuIHBhcmVudF9pbmRleCAoVCBwYXJlbnQpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBhY2tlZF9zYW1lXG4gICAgICAgICAgICAgICAgIChUIHQpXG4gICAgICAgICAgICAgICAgIChLaW5kLnNsb3dfZ2V0X2NoaWxkXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5raW5kXG4gICAgICAgICAgICAgICAgICAgIH5pbmRleDpteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKHBhcmVudF9pbmRleCkpKSk7XG4gICAgICAgICAgIGlmIGRlYnVnICYmIG5vdCAoaXNfbmVjZXNzYXJ5IHQpXG4gICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICBBcnJheS5pdGVyIG15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleCB+ZjooZnVuIHggLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoeCA9IC0xKSkpKVxuICAgICAgfmZvcmNlX25lY2Vzc2FyeTppZ25vcmVcbiAgICAgIH5jcmVhdGlvbl9iYWNrdHJhY2U6aWdub3JlKVxuOztcblxubGV0IHVuc2FmZV92YWx1ZSB0ID0gVW9wdC51bnNhZmVfdmFsdWUgdC52YWx1ZV9vcHRcblxubGV0IHZhbHVlX2V4biB0ID1cbiAgaWYgVW9wdC5pc19zb21lIHQudmFsdWVfb3B0XG4gIHRoZW4gVW9wdC51bnNhZmVfdmFsdWUgdC52YWx1ZV9vcHRcbiAgZWxzZSBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImF0dGVtcHQgdG8gZ2V0IHZhbHVlIG9mIGFuIGludmFsaWQgbm9kZVwiIHQgWyVzZXhwX29mOiBfIHRdXG47O1xuXG5sZXQgZ2V0X2N1dG9mZiB0ID0gdC5jdXRvZmZcbmxldCBzZXRfY3V0b2ZmIHQgY3V0b2ZmID0gdC5jdXRvZmYgPC0gY3V0b2ZmXG5cbmxldCBpc19jb25zdCB0ID1cbiAgbWF0Y2ggdC5raW5kIHdpdGhcbiAgfCBDb25zdCBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgb25fdXBkYXRlIHQgb25fdXBkYXRlX2hhbmRsZXIgPVxuICB0Lm9uX3VwZGF0ZV9oYW5kbGVycyA8LSBvbl91cGRhdGVfaGFuZGxlciA6OiB0Lm9uX3VwZGF0ZV9oYW5kbGVycztcbiAgdC5udW1fb25fdXBkYXRlX2hhbmRsZXJzIDwtIHQubnVtX29uX3VwZGF0ZV9oYW5kbGVycyArIDFcbjs7XG5cbmxldCBydW5fb25fdXBkYXRlX2hhbmRsZXJzIHQgbm9kZV91cGRhdGUgfm5vdyA9XG4gIGxldCByID0gcmVmIHQub25fdXBkYXRlX2hhbmRsZXJzIGluXG4gIHdoaWxlIG5vdCAoTGlzdC5pc19lbXB0eSAhcikgZG9cbiAgICBtYXRjaCAhciB3aXRoXG4gICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IG9uX3VwZGF0ZV9oYW5kbGVyIDo6IHJlc3QgLT5cbiAgICAgIHIgOj0gcmVzdDtcbiAgICAgIE9uX3VwZGF0ZV9oYW5kbGVyLnJ1biBvbl91cGRhdGVfaGFuZGxlciBub2RlX3VwZGF0ZSB+bm93XG4gIGRvbmU7XG4gIGxldCByID0gcmVmIHQub2JzZXJ2ZXJzIGluXG4gIHdoaWxlIFVvcHQuaXNfc29tZSAhciBkb1xuICAgIGxldCBvYnNlcnZlciA9IFVvcHQudmFsdWVfZXhuICFyIGluXG4gICAgciA6PSBvYnNlcnZlci5uZXh0X2luX29ic2VydmluZztcbiAgICBsZXQgciA9IHJlZiBvYnNlcnZlci5vbl91cGRhdGVfaGFuZGxlcnMgaW5cbiAgICB3aGlsZSBub3QgKExpc3QuaXNfZW1wdHkgIXIpIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBvbl91cGRhdGVfaGFuZGxlciA6OiByZXN0IC0+XG4gICAgICAgIHIgOj0gcmVzdDtcbiAgICAgICAgKCogV2UgaGF2ZSB0byB0ZXN0IFtzdGF0ZV0gYmVmb3JlIGVhY2ggb24tdXBkYXRlIGhhbmRsZXIsIGJlY2F1c2UgYW4gb24tdXBkYXRlXG4gICAgICAgICAgIGhhbmRsZXIgbWlnaHQgZGlzYWJsZSBpdHMgb3duIG9ic2VydmVyLCB3aGljaCBzaG91bGQgcHJldmVudCBvdGhlciBvbi11cGRhdGVcbiAgICAgICAgICAgaGFuZGxlcnMgaW4gdGhlIHNhbWUgb2JzZXJ2ZXIgZnJvbSBydW5uaW5nLiAqKVxuICAgICAgICAobWF0Y2ggb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgICAgICAgfCBDcmVhdGVkIHwgVW5saW5rZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgIHwgSW5fdXNlIC0+IE9uX3VwZGF0ZV9oYW5kbGVyLnJ1biBvbl91cGRhdGVfaGFuZGxlciBub2RlX3VwZGF0ZSB+bm93KVxuICAgIGRvbmVcbiAgZG9uZVxuOztcblxubGV0IHNldF9raW5kIHQga2luZCA9XG4gIHQua2luZCA8LSBraW5kO1xuICB0Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleFxuICA8LSBBcnJheS5jcmVhdGUgfmxlbjooS2luZC5pbml0aWFsX251bV9jaGlsZHJlbiBraW5kKSAoLTEpXG47O1xuXG5sZXQgY3JlYXRlIHN0YXRlIGNyZWF0ZWRfaW4ga2luZCA9XG4gIGxldCB0ID1cbiAgICB7IGlkID0gTm9kZV9pZC5uZXh0ICgpXG4gICAgOyBzdGF0ZVxuICAgIDsgcmVjb21wdXRlZF9hdCA9IFN0YWJpbGl6YXRpb25fbnVtLm5vbmVcbiAgICA7IHZhbHVlX29wdCA9IFVvcHQubm9uZVxuICAgIDsga2luZFxuICAgIDsgY3V0b2ZmID0gQ3V0b2ZmLnBoeXNfZXF1YWxcbiAgICA7IGNoYW5nZWRfYXQgPSBTdGFiaWxpemF0aW9uX251bS5ub25lXG4gICAgOyBudW1fb25fdXBkYXRlX2hhbmRsZXJzID0gMFxuICAgIDsgbnVtX3BhcmVudHMgPSAwXG4gICAgOyBwYXJlbnQxX2FuZF9iZXlvbmQgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG4gICAgOyBwYXJlbnQwID0gVW9wdC5ub25lXG4gICAgOyBjcmVhdGVkX2luXG4gICAgOyBuZXh0X25vZGVfaW5fc2FtZV9zY29wZSA9IFVvcHQubm9uZVxuICAgIDsgaGVpZ2h0ID0gLTFcbiAgICA7IGhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA9IC0xXG4gICAgOyBwcmV2X2luX3JlY29tcHV0ZV9oZWFwID0gVW9wdC5ub25lXG4gICAgOyBuZXh0X2luX3JlY29tcHV0ZV9oZWFwID0gVW9wdC5ub25lXG4gICAgOyBoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA9IC0xXG4gICAgOyBuZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPSBVb3B0Lm5vbmVcbiAgICA7IG9sZF92YWx1ZV9vcHQgPSBVb3B0Lm5vbmVcbiAgICA7IG9ic2VydmVycyA9IFVvcHQubm9uZVxuICAgIDsgaXNfaW5faGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gPSBmYWxzZVxuICAgIDsgb25fdXBkYXRlX2hhbmRsZXJzID0gW11cbiAgICA7IG15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleCA9XG4gICAgICAgIEFycmF5LmNyZWF0ZSB+bGVuOihLaW5kLmluaXRpYWxfbnVtX2NoaWxkcmVuIGtpbmQpICgtMSlcbiAgICAoKiBbbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4XSBoYXMgb25lIGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgbmVlZCB0byBob2xkXG4gICAgICAgdGhlIGNoaWxkIGluZGV4IG9mIFtwYXJlbnQwXS4gKilcbiAgICA7IG15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleCA9IFt8IC0xIHxdXG4gICAgOyBmb3JjZV9uZWNlc3NhcnkgPSBmYWxzZVxuICAgIDsgdXNlcl9pbmZvID0gTm9uZVxuICAgIDsgY3JlYXRpb25fYmFja3RyYWNlID1cbiAgICAgICAgKGlmIHN0YXRlLmtlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhY2UgdGhlbiBTb21lIChCYWNrdHJhY2UuZ2V0ICgpKSBlbHNlIE5vbmUpXG4gICAgfVxuICBpblxuICBTY29wZS5hZGRfbm9kZSBjcmVhdGVkX2luIHQ7XG4gICgqIFtpbnZhcmlhbnRdIGRvZXMgbm90IHlldCBob2xkIGhlcmUgYmVjYXVzZSBtYW55IHVzZXMgb2YgW05vZGUuY3JlYXRlXSB1c2UgW2tpbmQgPVxuICAgICBVbmluaXRpYWxpemVkXSwgYW5kIHRoZW4gbXV0YXRlIFt0LmtpbmRdIGxhdGVyLiAqKVxuICB0XG47O1xuXG5sZXQgbWF4X251bV9wYXJlbnRzIHQgPSAxICsgVW5pZm9ybV9hcnJheS5sZW5ndGggdC5wYXJlbnQxX2FuZF9iZXlvbmRcblxubGV0IG1ha2Vfc3BhY2VfZm9yX3BhcmVudF9pZl9uZWNlc3NhcnkgdCA9XG4gIGlmIHQubnVtX3BhcmVudHMgPSBtYXhfbnVtX3BhcmVudHMgdFxuICB0aGVuIChcbiAgICBsZXQgbmV3X21heF9udW1fcGFyZW50cyA9IDIgKiBtYXhfbnVtX3BhcmVudHMgdCBpblxuICAgIHQucGFyZW50MV9hbmRfYmV5b25kXG4gICAgPC0gVW5pZm9ybV9hcnJheS5yZWFsbG9jIHQucGFyZW50MV9hbmRfYmV5b25kIH5sZW46KG5ld19tYXhfbnVtX3BhcmVudHMgLSAxKTtcbiAgICB0Lm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleFxuICAgIDwtIEFycmF5LnJlYWxsb2MgdC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXggfmxlbjpuZXdfbWF4X251bV9wYXJlbnRzICgtMSkpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAodC5udW1fcGFyZW50cyA8IG1heF9udW1fcGFyZW50cyB0KVxuOztcblxubGV0IG1ha2Vfc3BhY2VfZm9yX2NoaWxkX2lmX25lY2Vzc2FyeSB0IH5jaGlsZF9pbmRleCA9XG4gIGxldCBtYXhfbnVtX2NoaWxkcmVuID0gQXJyYXkubGVuZ3RoIHQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IGluXG4gIGlmIGNoaWxkX2luZGV4ID49IG1heF9udW1fY2hpbGRyZW5cbiAgdGhlbiAoXG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGNoaWxkX2luZGV4ID0gbWF4X251bV9jaGlsZHJlbik7XG4gICAgbGV0IG5ld19tYXhfbnVtX2NoaWxkcmVuID0gSW50Lm1heCAyICgyICogbWF4X251bV9jaGlsZHJlbikgaW5cbiAgICB0Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleFxuICAgIDwtIEFycmF5LnJlYWxsb2MgdC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXggfmxlbjpuZXdfbWF4X251bV9jaGlsZHJlbiAoLTEpKTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGNoaWxkX2luZGV4IDwgQXJyYXkubGVuZ3RoIHQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4KVxuOztcblxubGV0IHNldF9wYXJlbnQgOiB0eXBlIGEuIGNoaWxkOmEgdCAtPiBwYXJlbnQ6UGFja2VkLnQgVW9wdC50IC0+IHBhcmVudF9pbmRleDppbnQgLT4gdW5pdCA9XG4gIGZ1biB+Y2hpbGQgfnBhcmVudCB+cGFyZW50X2luZGV4IC0+XG4gIGlmIHBhcmVudF9pbmRleCA9IDBcbiAgdGhlbiBjaGlsZC5wYXJlbnQwIDwtIHBhcmVudFxuICBlbHNlIFVuaWZvcm1fYXJyYXkuc2V0IGNoaWxkLnBhcmVudDFfYW5kX2JleW9uZCAocGFyZW50X2luZGV4IC0gMSkgcGFyZW50XG47O1xuXG5sZXQgbGlua1xuICA6IHR5cGUgYSBiLiBjaGlsZDphIHQgLT4gY2hpbGRfaW5kZXg6aW50IC0+IHBhcmVudDpiIHQgLT4gcGFyZW50X2luZGV4OmludCAtPiB1bml0XG4gID1cbiAgZnVuIH5jaGlsZCB+Y2hpbGRfaW5kZXggfnBhcmVudCB+cGFyZW50X2luZGV4IC0+XG4gIHNldF9wYXJlbnQgfmNoaWxkIH5wYXJlbnQ6KFVvcHQuc29tZSAoUGFja2VkLlQgcGFyZW50KSkgfnBhcmVudF9pbmRleDtcbiAgY2hpbGQubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihwYXJlbnRfaW5kZXgpIDwtIGNoaWxkX2luZGV4O1xuICBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleCkgPC0gcGFyZW50X2luZGV4XG47O1xuXG5sZXQgdW5saW5rXG4gIDogdHlwZSBhIGIuIGNoaWxkOmEgdCAtPiBjaGlsZF9pbmRleDppbnQgLT4gcGFyZW50OmIgdCAtPiBwYXJlbnRfaW5kZXg6aW50IC0+IHVuaXRcbiAgPVxuICBmdW4gfmNoaWxkIH5jaGlsZF9pbmRleCB+cGFyZW50IH5wYXJlbnRfaW5kZXggLT5cbiAgc2V0X3BhcmVudCB+Y2hpbGQgfnBhcmVudDpVb3B0Lm5vbmUgfnBhcmVudF9pbmRleDtcbiAgaWYgZGVidWdcbiAgdGhlbiAoXG4gICAgY2hpbGQubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihwYXJlbnRfaW5kZXgpIDwtIC0xO1xuICAgIHBhcmVudC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4KSA8LSAtMSlcbjs7XG5cbmxldCBhZGRfcGFyZW50IDogdHlwZSBhIGIuIGNoaWxkOmEgdCAtPiBwYXJlbnQ6YiB0IC0+IGNoaWxkX2luZGV4OmludCAtPiB1bml0ID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCAtPlxuICBtYWtlX3NwYWNlX2Zvcl9wYXJlbnRfaWZfbmVjZXNzYXJ5IGNoaWxkO1xuICBtYWtlX3NwYWNlX2Zvcl9jaGlsZF9pZl9uZWNlc3NhcnkgcGFyZW50IH5jaGlsZF9pbmRleDtcbiAgbGluayB+Y2hpbGQgfmNoaWxkX2luZGV4IH5wYXJlbnQgfnBhcmVudF9pbmRleDpjaGlsZC5udW1fcGFyZW50cztcbiAgY2hpbGQubnVtX3BhcmVudHMgPC0gY2hpbGQubnVtX3BhcmVudHMgKyAxXG47O1xuXG5sZXQgcmVtb3ZlX3BhcmVudCA6IHR5cGUgYSBiLiBjaGlsZDphIHQgLT4gcGFyZW50OmIgdCAtPiBjaGlsZF9pbmRleDppbnQgLT4gdW5pdCA9XG4gIGZ1biB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXggLT5cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGNoaWxkLm51bV9wYXJlbnRzID49IDEpO1xuICBsZXQgcGFyZW50X2luZGV4ID0gcGFyZW50Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleC4oY2hpbGRfaW5kZXgpIGluXG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChwYWNrZWRfc2FtZSAoVCBwYXJlbnQpIChnZXRfcGFyZW50IGNoaWxkIH5pbmRleDpwYXJlbnRfaW5kZXgpKTtcbiAgbGV0IGxhc3RfcGFyZW50X2luZGV4ID0gY2hpbGQubnVtX3BhcmVudHMgLSAxIGluXG4gIGlmIHBhcmVudF9pbmRleCA8IGxhc3RfcGFyZW50X2luZGV4XG4gIHRoZW4gKFxuICAgIGxldCAoVCBwYXJlbnQpID1cbiAgICAgIFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCBjaGlsZC5wYXJlbnQxX2FuZF9iZXlvbmQgKGxhc3RfcGFyZW50X2luZGV4IC0gMSkpXG4gICAgaW5cbiAgICBsaW5rXG4gICAgICB+Y2hpbGRcbiAgICAgIH5jaGlsZF9pbmRleDpjaGlsZC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKGxhc3RfcGFyZW50X2luZGV4KVxuICAgICAgfnBhcmVudFxuICAgICAgfnBhcmVudF9pbmRleCk7XG4gIHVubGluayB+Y2hpbGQgfmNoaWxkX2luZGV4IH5wYXJlbnQgfnBhcmVudF9pbmRleDpsYXN0X3BhcmVudF9pbmRleDtcbiAgY2hpbGQubnVtX3BhcmVudHMgPC0gY2hpbGQubnVtX3BhcmVudHMgLSAxXG47O1xuXG5sZXQgc3dhcF9jaGlsZHJlbl9leGNlcHRfaW5fa2luZCBwYXJlbnQgfmNoaWxkMSB+Y2hpbGRfaW5kZXgxIH5jaGlsZDIgfmNoaWxkX2luZGV4MiA9XG4gIGlmIGRlYnVnXG4gIHRoZW4gKFxuICAgIGFzc2VydCAocGFja2VkX3NhbWUgKFQgY2hpbGQxKSAoS2luZC5zbG93X2dldF9jaGlsZCBwYXJlbnQua2luZCB+aW5kZXg6Y2hpbGRfaW5kZXgxKSk7XG4gICAgYXNzZXJ0IChwYWNrZWRfc2FtZSAoVCBjaGlsZDIpIChLaW5kLnNsb3dfZ2V0X2NoaWxkIHBhcmVudC5raW5kIH5pbmRleDpjaGlsZF9pbmRleDIpKSk7XG4gIGxldCBpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQxID1cbiAgICBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleDEpXG4gIGluXG4gIGxldCBpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQyID1cbiAgICBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleDIpXG4gIGluXG4gIGlmIGRlYnVnXG4gIHRoZW4gKFxuICAgIGFzc2VydCAoXG4gICAgICBjaGlsZDEubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQxKSA9IGNoaWxkX2luZGV4MSk7XG4gICAgYXNzZXJ0IChcbiAgICAgIGNoaWxkMi5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDIpID0gY2hpbGRfaW5kZXgyKSk7XG4gICgqIG5vdyBzdGFydCBzd2FwcGluZyAqKVxuICBjaGlsZDEubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQxKSA8LSBjaGlsZF9pbmRleDI7XG4gIGNoaWxkMi5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDIpIDwtIGNoaWxkX2luZGV4MTtcbiAgcGFyZW50Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleC4oY2hpbGRfaW5kZXgxKSA8LSBpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQyO1xuICBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleDIpIDwtIGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDFcbjs7XG5cbm1vZHVsZSBQYWNrZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUGFja2VkLnQgPSBUIDogXyBUeXBlcy5Ob2RlLnQgLT4gdCBbQEB1bmJveGVkXVxuXG4gIGxldCBzZXhwX29mX3QgKFQgdCkgPSB0IHw+IFslc2V4cF9vZjogXyB0XVxuICBsZXQgaW52YXJpYW50IChUIHQpID0gaW52YXJpYW50IGlnbm9yZSB0XG5cbiAgbW9kdWxlIEFzX2xpc3QgKE0gOiBzaWdcbiAgICAgIHZhbCBuZXh0IDogUGFja2VkLnQgLT4gUGFja2VkLnQgVW9wdC50XG4gICAgZW5kKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IFBhY2tlZC50IFVvcHQudFxuXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gICAgICBsZXQgYWMgPSByZWYgaW5pdCBpblxuICAgICAgbGV0IHIgPSByZWYgdCBpblxuICAgICAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgICAgIGxldCBwYWNrZWRfbm9kZSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgICAgIHIgOj0gTS5uZXh0IHBhY2tlZF9ub2RlO1xuICAgICAgICBhYyA6PSBmICFhYyBwYWNrZWRfbm9kZVxuICAgICAgZG9uZTtcbiAgICAgICFhY1xuICAgIDs7XG5cbiAgICBsZXQgaXRlciB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgbiAtPiBmIG4pXG4gICAgbGV0IGludmFyaWFudCB0ID0gaXRlciB0IH5mOmludmFyaWFudFxuICAgIGxldCBsZW5ndGggdCA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBfIC0+IG4gKyAxKVxuICAgIGxldCB0b19saXN0IHQgPSBMaXN0LnJldiAoZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWMgbiAtPiBuIDo6IGFjKSlcbiAgICBsZXQgc2V4cF9vZl90IHQgPSB0b19saXN0IHQgfD4gWyVzZXhwX29mOiBQYWNrZWQudCBsaXN0XVxuICBlbmRcblxuICBsZXQgaXRlcl9kZXNjZW5kYW50c19pbnRlcm5hbCB0cyB+ZiA9XG4gICAgbGV0IHNlZW4gPSBOb2RlX2lkLkhhc2hfc2V0LmNyZWF0ZSAoKSBpblxuICAgIGxldCByZWMgaXRlcl9kZXNjZW5kYW50cyAoVCB0KSA9XG4gICAgICBpZiBub3QgKEhhc2hfc2V0Lm1lbSBzZWVuIHQuaWQpXG4gICAgICB0aGVuIChcbiAgICAgICAgSGFzaF9zZXQuYWRkIHNlZW4gdC5pZDtcbiAgICAgICAgZiAoVCB0KTtcbiAgICAgICAgaXRlcmlfY2hpbGRyZW4gdCB+ZjooZnVuIF8gdCAtPiBpdGVyX2Rlc2NlbmRhbnRzIHQpKVxuICAgIGluXG4gICAgTGlzdC5pdGVyIHRzIH5mOml0ZXJfZGVzY2VuZGFudHM7XG4gICAgc2VlblxuICA7O1xuXG4gIGxldCBpdGVyX2Rlc2NlbmRhbnRzIHRzIH5mID0gaWdub3JlIChpdGVyX2Rlc2NlbmRhbnRzX2ludGVybmFsIHRzIH5mIDogXyBIYXNoX3NldC50KVxuXG4gIG1vZHVsZSBEb3RfdXNlcl9pbmZvID0gc3RydWN0XG4gICAgaW5jbHVkZSBEb3RfdXNlcl9pbmZvXG5cbiAgICBsZXQgZGVmYXVsdCB+bmFtZSB0ID1cbiAgICAgIERvdF91c2VyX2luZm8uZG90XG4gICAgICAgIH5sYWJlbDpbIG5hbWU7IEtpbmQubmFtZSB0LmtpbmQ7IHNwcmludGYgXCJoZWlnaHQ9JWRcIiB0LmhlaWdodCBdXG4gICAgICAgIH5hdHRyaWJ1dGVzOlN0cmluZy5NYXAuZW1wdHlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgYXBwZW5kX3VzZXJfaW5mb19ncmFwaHZpeiAoVCB0KSA9IGFwcGVuZF91c2VyX2luZm9fZ3JhcGh2aXogdFxuXG4gIGxldCBwcmludF9ub2RlIG91dCB+bmFtZSB0ID1cbiAgICBsZXQgZGVmYXVsdCA9IERvdF91c2VyX2luZm8uZGVmYXVsdCB+bmFtZSB0IGluXG4gICAgbGV0IGluZm8gPVxuICAgICAgbWF0Y2ggdC51c2VyX2luZm8gd2l0aFxuICAgICAgfCBOb25lIC0+IGRlZmF1bHRcbiAgICAgIHwgU29tZSB1c2VyX2luZm8gLT4gRG90X3VzZXJfaW5mby5hcHBlbmQgZGVmYXVsdCB1c2VyX2luZm9cbiAgICBpblxuICAgIGZwcmludGYgb3V0IFwiJXNcXG5cIiAoRG90X3VzZXJfaW5mby50b19zdHJpbmcgfm5hbWUgKERvdF91c2VyX2luZm8udG9fZG90IGluZm8pKVxuICA7O1xuXG4gIGxldCBzYXZlX2RvdCBvdXQgdHMgPVxuICAgIGxldCBub2RlX25hbWUgPVxuICAgICAgaWYgYW1fcnVubmluZ190ZXN0XG4gICAgICB0aGVuIGZ1biBfIC0+IFwibiMjI1wiXG4gICAgICBlbHNlIGZ1biBub2RlIC0+IFwiblwiIF4gTm9kZV9pZC50b19zdHJpbmcgbm9kZS5pZFxuICAgIGluXG4gICAgZnByaW50ZiBvdXQgXCJkaWdyYXBoIEcge1xcblwiO1xuICAgIGZwcmludGYgb3V0IFwiICByYW5rZGlyID0gQlRcXG5cIjtcbiAgICBsZXQgYmluZF9lZGdlcyA9IHJlZiBbXSBpblxuICAgIGxldCBzZWVuID1cbiAgICAgIGl0ZXJfZGVzY2VuZGFudHNfaW50ZXJuYWwgdHMgfmY6KGZ1biAoVCB0KSAtPlxuICAgICAgICBsZXQgbmFtZSA9IG5vZGVfbmFtZSB0IGluXG4gICAgICAgIHByaW50X25vZGUgb3V0IH5uYW1lIHQ7XG4gICAgICAgIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIChUIGZyb21fKSAtPlxuICAgICAgICAgIGZwcmludGYgb3V0IFwiICAlcyAtPiAlc1xcblwiIChub2RlX25hbWUgZnJvbV8pIG5hbWUpO1xuICAgICAgICBtYXRjaCB0LmtpbmQgd2l0aFxuICAgICAgICB8IEJpbmRfbGhzX2NoYW5nZSBiaW5kIC0+XG4gICAgICAgICAgQmluZC5pdGVyX25vZGVzX2NyZWF0ZWRfb25fcmhzIGJpbmQgfmY6KGZ1biB0b18gLT5cbiAgICAgICAgICAgIGJpbmRfZWRnZXMgOj0gKFQgdCwgdG9fKSA6OiAhYmluZF9lZGdlcylcbiAgICAgICAgfCBfIC0+ICgpKVxuICAgIGluXG4gICAgTGlzdC5pdGVyICFiaW5kX2VkZ2VzIH5mOihmdW4gKFQgZnJvbSwgVCB0b18pIC0+XG4gICAgICBpZiBIYXNoX3NldC5tZW0gc2VlbiB0b18uaWRcbiAgICAgIHRoZW4gZnByaW50ZiBvdXQgXCIgICVzIC0+ICVzIFtzdHlsZT1kYXNoZWRdXFxuXCIgKG5vZGVfbmFtZSBmcm9tKSAobm9kZV9uYW1lIHRvXykpO1xuICAgIGZwcmludGYgb3V0IFwifVxcbiUhXCJcbiAgOztcblxuICBsZXQgc2F2ZV9kb3RfdG9fZmlsZSBmaWxlIHRzID1cbiAgICBPdXRfY2hhbm5lbC53aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIG91dCAtPiBzYXZlX2RvdCBvdXQgdHMpXG4gIDs7XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcblxubW9kdWxlIEFzX3JlY29tcHV0ZV9saXN0ID0gTm9kZS5QYWNrZWQuQXNfbGlzdCAoc3RydWN0XG4gICAgbGV0IG5leHQgKE5vZGUuUGFja2VkLlQgbm9kZSkgPSBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXBcbiAgZW5kKVxuXG5tb2R1bGUgTm9kZXNfYnlfaGVpZ2h0ID0gc3RydWN0XG4gIHR5cGUgdCA9IEFzX3JlY29tcHV0ZV9saXN0LnQgVW5pZm9ybV9hcnJheS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgKCogV2UgZGlzcGxheSB0aGUgc21hbGxlc3QgcHJlZml4IG9mIFtub2Rlc19ieV9oZWlnaHRdIHRoYXQgaW5jbHVkZXMgYWxsIG5vZGVzLiAqKVxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBtYXhfbm9uZW1wdHlfaW5kZXggPSByZWYgKC0xKSBpblxuICAgIFVuaWZvcm1fYXJyYXkuaXRlcmkgdCB+ZjooZnVuIGkgbCAtPiBpZiBVb3B0LmlzX3NvbWUgbCB0aGVuIG1heF9ub25lbXB0eV9pbmRleCA6PSBpKTtcbiAgICBVbmlmb3JtX2FycmF5LnN1YiB0IH5wb3M6MCB+bGVuOighbWF4X25vbmVtcHR5X2luZGV4ICsgMSkgfD4gWyVzZXhwX29mOiB0XVxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IFR5cGVzLlJlY29tcHV0ZV9oZWFwLnQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBoZWlnaHRfbG93ZXJfYm91bmQgOiBpbnRcbiAgOyBtdXRhYmxlIG5vZGVzX2J5X2hlaWdodCA6IE5vZGVzX2J5X2hlaWdodC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IG1heF9oZWlnaHRfYWxsb3dlZCB0ID0gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5ub2Rlc19ieV9oZWlnaHQgLSAxXG5sZXQgaXNfZW1wdHkgdCA9IHQubGVuZ3RoID0gMFxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmxlbmd0aDpcbiAgICAgICAgKGNoZWNrIChmdW4gbGVuZ3RoIC0+XG4gICAgICAgICAgIGxldCBhY3R1YWxfbGVuZ3RoID0gcmVmIDAgaW5cbiAgICAgICAgICAgVW5pZm9ybV9hcnJheS5pdGVyIHQubm9kZXNfYnlfaGVpZ2h0IH5mOihmdW4gbm9kZSAtPlxuICAgICAgICAgICAgIGFjdHVhbF9sZW5ndGggOj0gIWFjdHVhbF9sZW5ndGggKyBBc19yZWNvbXB1dGVfbGlzdC5sZW5ndGggbm9kZSk7XG4gICAgICAgICAgIFsldGVzdF9lcTogaW50XSBsZW5ndGggIWFjdHVhbF9sZW5ndGgpKVxuICAgICAgfmhlaWdodF9sb3dlcl9ib3VuZDpcbiAgICAgICAgKGNoZWNrIChmdW4gaGVpZ2h0X2xvd2VyX2JvdW5kIC0+XG4gICAgICAgICAgIGFzc2VydCAoaGVpZ2h0X2xvd2VyX2JvdW5kID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKGhlaWdodF9sb3dlcl9ib3VuZCA8PSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0Lm5vZGVzX2J5X2hlaWdodCk7XG4gICAgICAgICAgIGZvciBoZWlnaHQgPSAwIHRvIGhlaWdodF9sb3dlcl9ib3VuZCAtIDEgZG9cbiAgICAgICAgICAgICBhc3NlcnQgKFVvcHQuaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdC5ub2Rlc19ieV9oZWlnaHQgaGVpZ2h0KSlcbiAgICAgICAgICAgZG9uZSkpXG4gICAgICB+bm9kZXNfYnlfaGVpZ2h0OlxuICAgICAgICAoY2hlY2sgKGZ1biBub2Rlc19ieV9oZWlnaHQgLT5cbiAgICAgICAgICAgVW5pZm9ybV9hcnJheS5pdGVyaSBub2Rlc19ieV9oZWlnaHQgfmY6KGZ1biBoZWlnaHQgbm9kZSAtPlxuICAgICAgICAgICAgIEFzX3JlY29tcHV0ZV9saXN0Lml0ZXIgbm9kZSB+ZjooZnVuIChUIG5vZGUpIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwID0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgIGFzc2VydCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlKSkpKSkpXG47O1xuXG5sZXQgY3JlYXRlX25vZGVzX2J5X2hlaWdodCB+bWF4X2hlaWdodF9hbGxvd2VkID1cbiAgVW5pZm9ybV9hcnJheS5jcmVhdGUgfmxlbjoobWF4X2hlaWdodF9hbGxvd2VkICsgMSkgVW9wdC5ub25lXG47O1xuXG5sZXQgc2V0X21heF9oZWlnaHRfYWxsb3dlZCB0IG1heF9oZWlnaHRfYWxsb3dlZCA9XG4gIGlmIGRlYnVnXG4gIHRoZW5cbiAgICBmb3IgaSA9IG1heF9oZWlnaHRfYWxsb3dlZCArIDEgdG8gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5ub2Rlc19ieV9oZWlnaHQgLSAxIGRvXG4gICAgICBhc3NlcnQgKFVvcHQuaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdC5ub2Rlc19ieV9oZWlnaHQgaSkpXG4gICAgZG9uZTtcbiAgbGV0IHNyYyA9IHQubm9kZXNfYnlfaGVpZ2h0IGluXG4gIGxldCBkc3QgPSBjcmVhdGVfbm9kZXNfYnlfaGVpZ2h0IH5tYXhfaGVpZ2h0X2FsbG93ZWQgaW5cbiAgVW5pZm9ybV9hcnJheS5ibGl0XG4gICAgfnNyY1xuICAgIH5zcmNfcG9zOjBcbiAgICB+ZHN0XG4gICAgfmRzdF9wb3M6MFxuICAgIH5sZW46KG1pbiAoVW5pZm9ybV9hcnJheS5sZW5ndGggc3JjKSAoVW5pZm9ybV9hcnJheS5sZW5ndGggZHN0KSk7XG4gIHQubm9kZXNfYnlfaGVpZ2h0IDwtIGRzdDtcbiAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gbWluIHQuaGVpZ2h0X2xvd2VyX2JvdW5kIChVbmlmb3JtX2FycmF5Lmxlbmd0aCBkc3QpXG47O1xuXG5sZXQgY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICB7IGxlbmd0aCA9IDBcbiAgOyBoZWlnaHRfbG93ZXJfYm91bmQgPSBtYXhfaGVpZ2h0X2FsbG93ZWQgKyAxXG4gIDsgbm9kZXNfYnlfaGVpZ2h0ID0gY3JlYXRlX25vZGVzX2J5X2hlaWdodCB+bWF4X2hlaWdodF9hbGxvd2VkXG4gIH1cbjs7XG5cbmxldCBzZXRfbmV4dCAocHJldiA6IE5vZGUuUGFja2VkLnQgVW9wdC50KSB+bmV4dCA9XG4gIGlmIFVvcHQuaXNfc29tZSBwcmV2XG4gIHRoZW4gKFxuICAgIGxldCAoVCBwcmV2KSA9IFVvcHQudW5zYWZlX3ZhbHVlIHByZXYgaW5cbiAgICBwcmV2Lm5leHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gbmV4dClcbjs7XG5cbmxldCBzZXRfcHJldiAobmV4dCA6IE5vZGUuUGFja2VkLnQgVW9wdC50KSB+cHJldiA9XG4gIGlmIFVvcHQuaXNfc29tZSBuZXh0XG4gIHRoZW4gKFxuICAgIGxldCAoVCBuZXh0KSA9IFVvcHQudW5zYWZlX3ZhbHVlIG5leHQgaW5cbiAgICBuZXh0LnByZXZfaW5fcmVjb21wdXRlX2hlYXAgPC0gcHJldilcbjs7XG5cbmxldCBsaW5rICh0eXBlIGEpIHQgKG5vZGUgOiBhIE5vZGUudCkgPVxuICBsZXQgaGVpZ2h0ID0gbm9kZS5oZWlnaHQgaW5cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGhlaWdodCA8PSBtYXhfaGVpZ2h0X2FsbG93ZWQgdCk7XG4gIG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwIDwtIGhlaWdodDtcbiAgbGV0IG5leHQgPSBVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQgaW5cbiAgbm9kZS5uZXh0X2luX3JlY29tcHV0ZV9oZWFwIDwtIG5leHQ7XG4gIHNldF9wcmV2IG5leHQgfnByZXY6KFVvcHQuc29tZSAoTm9kZS5QYWNrZWQuVCBub2RlKSk7XG4gIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQgKFVvcHQuc29tZSAoTm9kZS5QYWNrZWQuVCBub2RlKSlcbjs7XG5cbmxldCB1bmxpbmsgKHR5cGUgYSkgdCAobm9kZSA6IGEgTm9kZS50KSA9XG4gIGxldCBwcmV2ID0gbm9kZS5wcmV2X2luX3JlY29tcHV0ZV9oZWFwIGluXG4gIGxldCBuZXh0ID0gbm9kZS5uZXh0X2luX3JlY29tcHV0ZV9oZWFwIGluXG4gIGlmIHBoeXNfc2FtZVxuICAgICAgIChVb3B0LnNvbWUgbm9kZSlcbiAgICAgICAoVW5pZm9ybV9hcnJheS5nZXQgdC5ub2Rlc19ieV9oZWlnaHQgbm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXApXG4gIHRoZW4gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQubm9kZXNfYnlfaGVpZ2h0IG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwIG5leHQ7XG4gIHNldF9wcmV2IG5leHQgfnByZXY7XG4gIHNldF9uZXh0IHByZXYgfm5leHQ7XG4gIG5vZGUucHJldl9pbl9yZWNvbXB1dGVfaGVhcCA8LSBVb3B0Lm5vbmVcbjs7XG5cbigqIFdlIGRvbid0IHNldCBbbm9kZS5uZXh0X2luX3JlY29tcHV0ZV9oZWFwXSBoZXJlLCBidXQgcmF0aGVyIGFmdGVyIGNhbGxpbmcgW3VubGlua10uICopXG5cbmxldCBhZGQgKHR5cGUgYSkgdCAobm9kZSA6IGEgTm9kZS50KSA9XG4gIGlmIGRlYnVnICYmIChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGUgfHwgbm90IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpKVxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcImluY29ycmVjdCBhdHRlbXB0IHRvIGFkZCBub2RlIHRvIHJlY29tcHV0ZSBoZWFwXCJcbiAgICAgIG5vZGVcbiAgICAgIFslc2V4cF9vZjogXyBOb2RlLnRdO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAobm9kZS5oZWlnaHQgPD0gbWF4X2hlaWdodF9hbGxvd2VkIHQpO1xuICBsZXQgaGVpZ2h0ID0gbm9kZS5oZWlnaHQgaW5cbiAgaWYgaGVpZ2h0IDwgdC5oZWlnaHRfbG93ZXJfYm91bmQgdGhlbiB0LmhlaWdodF9sb3dlcl9ib3VuZCA8LSBoZWlnaHQ7XG4gIGxpbmsgdCBub2RlO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCByZW1vdmUgKHR5cGUgYSkgdCAobm9kZSA6IGEgTm9kZS50KSA9XG4gIGlmIGRlYnVnICYmICgobm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGUpKSB8fCBOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiaW5jb3JyZWN0IFtyZW1vdmVdIG9mIG5vZGUgZnJvbSByZWNvbXB1dGUgaGVhcFwiXG4gICAgICBub2RlXG4gICAgICBbJXNleHBfb2Y6IF8gTm9kZS50XTtcbiAgdW5saW5rIHQgbm9kZTtcbiAgbm9kZS5uZXh0X2luX3JlY29tcHV0ZV9oZWFwIDwtIFVvcHQubm9uZTtcbiAgbm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gLTE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMVxuOztcblxubGV0IGluY3JlYXNlX2hlaWdodCAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgaWYgZGVidWdcbiAgdGhlbiAoXG4gICAgYXNzZXJ0IChub2RlLmhlaWdodCA+IG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwKTtcbiAgICBhc3NlcnQgKG5vZGUuaGVpZ2h0IDw9IG1heF9oZWlnaHRfYWxsb3dlZCB0KTtcbiAgICBhc3NlcnQgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSkpO1xuICB1bmxpbmsgdCBub2RlO1xuICBsaW5rIHQgbm9kZVxuOztcblxubGV0IG1pbl9oZWlnaHQgdCA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuIHQuaGVpZ2h0X2xvd2VyX2JvdW5kIDwtIFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0XG4gIGVsc2UgKFxuICAgIGxldCBub2Rlc19ieV9oZWlnaHQgPSB0Lm5vZGVzX2J5X2hlaWdodCBpblxuICAgIHdoaWxlIFVvcHQuaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgbm9kZXNfYnlfaGVpZ2h0IHQuaGVpZ2h0X2xvd2VyX2JvdW5kKSBkb1xuICAgICAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gdC5oZWlnaHRfbG93ZXJfYm91bmQgKyAxXG4gICAgZG9uZSk7XG4gIHQuaGVpZ2h0X2xvd2VyX2JvdW5kXG47O1xuXG5sZXQgcmVtb3ZlX21pbiB0IDogTm9kZS5QYWNrZWQudCA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChub3QgKGlzX2VtcHR5IHQpKTtcbiAgbGV0IG5vZGVzX2J5X2hlaWdodCA9IHQubm9kZXNfYnlfaGVpZ2h0IGluXG4gIGxldCBub2RlID0gcmVmIChVbmlmb3JtX2FycmF5LmdldCBub2Rlc19ieV9oZWlnaHQgdC5oZWlnaHRfbG93ZXJfYm91bmQpIGluXG4gIHdoaWxlIFVvcHQuaXNfbm9uZSAhbm9kZSBkb1xuICAgIHQuaGVpZ2h0X2xvd2VyX2JvdW5kIDwtIHQuaGVpZ2h0X2xvd2VyX2JvdW5kICsgMTtcbiAgICBpZiBkZWJ1ZyAmJiB0LmhlaWdodF9sb3dlcl9ib3VuZCA+PSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0Lm5vZGVzX2J5X2hlaWdodFxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoc1xuICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgIFwiUmVjb21wdXRlX2hlYXAucmVtb3ZlX21pbiB1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgaGVhcFwiXG4gICAgICAgIHRcbiAgICAgICAgWyVzZXhwX29mOiB0XTtcbiAgICBub2RlIDo9IFVuaWZvcm1fYXJyYXkuZ2V0IG5vZGVzX2J5X2hlaWdodCB0LmhlaWdodF9sb3dlcl9ib3VuZFxuICBkb25lO1xuICBsZXQgKFQgbm9kZSkgPSBVb3B0LnVuc2FmZV92YWx1ZSAhbm9kZSBpblxuICBub2RlLmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA8LSAtMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICBsZXQgbmV4dCA9IG5vZGUubmV4dF9pbl9yZWNvbXB1dGVfaGVhcCBpblxuICBVbmlmb3JtX2FycmF5LnNldCB0Lm5vZGVzX2J5X2hlaWdodCB0LmhlaWdodF9sb3dlcl9ib3VuZCBuZXh0O1xuICBzZXRfcHJldiBuZXh0IH5wcmV2OlVvcHQubm9uZTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKFVvcHQuaXNfbm9uZSBub2RlLnByZXZfaW5fcmVjb21wdXRlX2hlYXApO1xuICBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gVW9wdC5ub25lO1xuICBUIG5vZGVcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcblxubW9kdWxlIEFzX2FkanVzdF9oZWlnaHRzX2xpc3QgPSBOb2RlLlBhY2tlZC5Bc19saXN0IChzdHJ1Y3RcbiAgICBsZXQgbmV4dCAoTm9kZS5QYWNrZWQuVCBub2RlKSA9IG5vZGUubmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXG4gIGVuZClcblxubW9kdWxlIE5vZGVzX2J5X2hlaWdodCA9IHN0cnVjdFxuICB0eXBlIHQgPSBBc19hZGp1c3RfaGVpZ2h0c19saXN0LnQgVW5pZm9ybV9hcnJheS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBsZXQgbWF4X25vbmVtcHR5X2luZGV4ID0gcmVmICgtMSkgaW5cbiAgICBVbmlmb3JtX2FycmF5Lml0ZXJpIHQgfmY6KGZ1biBpIGwgLT4gaWYgVW9wdC5pc19zb21lIGwgdGhlbiBtYXhfbm9uZW1wdHlfaW5kZXggOj0gaSk7XG4gICAgVW5pZm9ybV9hcnJheS5zdWIgdCB+cG9zOjAgfmxlbjooIW1heF9ub25lbXB0eV9pbmRleCArIDEpIHw+IFslc2V4cF9vZjogdF1cbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgVW5pZm9ybV9hcnJheS5pdGVyaSB0IH5mOihmdW4gaGVpZ2h0IG5vZGVzIC0+XG4gICAgICAgIEFzX2FkanVzdF9oZWlnaHRzX2xpc3QuaW52YXJpYW50IG5vZGVzO1xuICAgICAgICBBc19hZGp1c3RfaGVpZ2h0c19saXN0Lml0ZXIgbm9kZXMgfmY6KGZ1biAoVCBub2RlKSAtPlxuICAgICAgICAgIGFzc2VydCAobm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA9IGhlaWdodCk7XG4gICAgICAgICAgYXNzZXJ0IChub2RlLmhlaWdodCA+IG5vZGUuaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXApO1xuICAgICAgICAgIGlmIE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZVxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgIG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwID0gbm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCkpKSlcbiAgOztcblxuICBsZXQgY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICAgIFVuaWZvcm1fYXJyYXkuY3JlYXRlIH5sZW46KG1heF9oZWlnaHRfYWxsb3dlZCArIDEpIFVvcHQubm9uZVxuICA7O1xuXG4gIGxldCBsZW5ndGggdCA9XG4gICAgbGV0IHIgPSByZWYgMCBpblxuICAgIFVuaWZvcm1fYXJyYXkuaXRlciB0IH5mOihmdW4gbm9kZSAtPiByIDo9ICFyICsgQXNfYWRqdXN0X2hlaWdodHNfbGlzdC5sZW5ndGggbm9kZSk7XG4gICAgIXJcbiAgOztcbmVuZFxuXG50eXBlIHQgPSBUeXBlcy5BZGp1c3RfaGVpZ2h0c19oZWFwLnQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBoZWlnaHRfbG93ZXJfYm91bmQgOiBpbnRcbiAgOyBtdXRhYmxlIG1heF9oZWlnaHRfc2VlbiA6IGludFxuICA7IG11dGFibGUgbm9kZXNfYnlfaGVpZ2h0IDogTm9kZXNfYnlfaGVpZ2h0LnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxubGV0IG1heF9oZWlnaHRfYWxsb3dlZCB0ID0gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5ub2Rlc19ieV9oZWlnaHQgLSAxXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgYXNzZXJ0IChsZW5ndGggPSBOb2Rlc19ieV9oZWlnaHQubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0KSkpXG4gICAgICB+aGVpZ2h0X2xvd2VyX2JvdW5kOlxuICAgICAgICAoY2hlY2sgKGZ1biBoZWlnaHRfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChoZWlnaHRfbG93ZXJfYm91bmQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAoaGVpZ2h0X2xvd2VyX2JvdW5kIDw9IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0KTtcbiAgICAgICAgICAgZm9yIGhlaWdodCA9IDAgdG8gaGVpZ2h0X2xvd2VyX2JvdW5kIC0gMSBkb1xuICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQpKVxuICAgICAgICAgICBkb25lKSlcbiAgICAgIH5tYXhfaGVpZ2h0X3NlZW46XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9oZWlnaHRfc2VlbiAtPlxuICAgICAgICAgICBhc3NlcnQgKG1heF9oZWlnaHRfc2VlbiA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChtYXhfaGVpZ2h0X3NlZW4gPD0gbWF4X2hlaWdodF9hbGxvd2VkIHQpKSlcbiAgICAgIH5ub2Rlc19ieV9oZWlnaHQ6KGNoZWNrIE5vZGVzX2J5X2hlaWdodC5pbnZhcmlhbnQpKVxuOztcblxubGV0IGNyZWF0ZSB+bWF4X2hlaWdodF9hbGxvd2VkID1cbiAgeyBsZW5ndGggPSAwXG4gIDsgaGVpZ2h0X2xvd2VyX2JvdW5kID0gbWF4X2hlaWdodF9hbGxvd2VkICsgMVxuICA7IG1heF9oZWlnaHRfc2VlbiA9IDBcbiAgOyBub2Rlc19ieV9oZWlnaHQgPSBOb2Rlc19ieV9oZWlnaHQuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbiAgfVxuOztcblxubGV0IHNldF9tYXhfaGVpZ2h0X2FsbG93ZWQgdCBtYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICBpZiBtYXhfaGVpZ2h0X2FsbG93ZWQgPCB0Lm1heF9oZWlnaHRfc2VlblxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcImNhbm5vdCBzZXRfbWF4X2hlaWdodF9hbGxvd2VkIGxlc3MgdGhhbiB0aGUgbWF4IGhlaWdodCBhbHJlYWR5IHNlZW5cIlxuICAgICAgKG1heF9oZWlnaHRfYWxsb3dlZCwgYG1heF9oZWlnaHRfc2VlbiB0Lm1heF9oZWlnaHRfc2VlbilcbiAgICAgIFslc2V4cF9vZjogaW50ICogWyBgbWF4X2hlaWdodF9zZWVuIG9mIGludCBdXTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGlzX2VtcHR5IHQpO1xuICB0Lm5vZGVzX2J5X2hlaWdodCA8LSBOb2Rlc19ieV9oZWlnaHQuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbjs7XG5cbmxldCBhZGRfdW5sZXNzX21lbSAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgaWYgbm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA9IC0xXG4gIHRoZW4gKFxuICAgIGxldCBoZWlnaHQgPSBub2RlLmhlaWdodCBpblxuICAgICgqIFdlIHByb2Nlc3Mgbm9kZXMgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBwcmUtYWRqdXN0ZWQgaGVpZ2h0LCBzbyBpdCBpcyBhIGJ1ZyBpZiB3ZVxuICAgICAgIGV2ZXIgdHJ5IHRvIGFkZCBhIG5vZGUgdGhhdCB3b3VsZCB2aW9sYXRlIHRoYXQuICopXG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGhlaWdodCA+PSB0LmhlaWdodF9sb3dlcl9ib3VuZCk7XG4gICAgKCogV2hlbmV2ZXIgd2Ugc2V0IGEgbm9kZSdzIGhlaWdodCwgd2UgdXNlIFtzZXRfaGVpZ2h0XSwgd2hpY2ggZW5mb3JjZXMgdGhpcy4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoaGVpZ2h0IDw9IG1heF9oZWlnaHRfYWxsb3dlZCB0KTtcbiAgICBub2RlLmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDwtIGhlaWdodDtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gICAgbm9kZS5uZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPC0gVW5pZm9ybV9hcnJheS5nZXQgdC5ub2Rlc19ieV9oZWlnaHQgaGVpZ2h0O1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQgKFVvcHQuc29tZSAoTm9kZS5QYWNrZWQuVCBub2RlKSkpXG47O1xuXG5sZXQgcmVtb3ZlX21pbl9leG4gdCA6IE5vZGUuUGFja2VkLnQgPVxuICBpZiBkZWJ1ZyAmJiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIkFkanVzdF9oZWlnaHRzX2hlYXAucmVtb3ZlX21pbiBvZiBlbXB0eSBoZWFwXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBsZXQgciA9IHJlZiB0LmhlaWdodF9sb3dlcl9ib3VuZCBpblxuICB3aGlsZSBVb3B0LmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQubm9kZXNfYnlfaGVpZ2h0ICFyKSBkb1xuICAgIGluY3IgclxuICBkb25lO1xuICBsZXQgaGVpZ2h0ID0gIXIgaW5cbiAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gaGVpZ2h0O1xuICBsZXQgKFQgbm9kZSkgPSBVb3B0LnVuc2FmZV92YWx1ZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQubm9kZXNfYnlfaGVpZ2h0IGhlaWdodCkgaW5cbiAgbm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA8LSAtMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdC5ub2Rlc19ieV9oZWlnaHQgaGVpZ2h0IG5vZGUubmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwO1xuICBub2RlLm5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA8LSBVb3B0Lm5vbmU7XG4gIFQgbm9kZVxuOztcblxubGV0IHNldF9oZWlnaHQgdCAobm9kZSA6IF8gTm9kZS50KSBoZWlnaHQgPVxuICBpZiBoZWlnaHQgPiB0Lm1heF9oZWlnaHRfc2VlblxuICB0aGVuIChcbiAgICB0Lm1heF9oZWlnaHRfc2VlbiA8LSBoZWlnaHQ7XG4gICAgaWYgaGVpZ2h0ID4gbWF4X2hlaWdodF9hbGxvd2VkIHRcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIm5vZGUgd2l0aCB0b28gbGFyZ2UgaGVpZ2h0XCJcbiAgICAgICAgKGBIZWlnaHQgaGVpZ2h0LCBgTWF4IChtYXhfaGVpZ2h0X2FsbG93ZWQgdCkpXG4gICAgICAgIFslc2V4cF9vZjogWyBgSGVpZ2h0IG9mIGludCBdICogWyBgTWF4IG9mIGludCBdXSk7XG4gIG5vZGUuaGVpZ2h0IDwtIGhlaWdodFxuOztcblxubGV0IGVuc3VyZV9oZWlnaHRfcmVxdWlyZW1lbnQgdCB+b3JpZ2luYWxfY2hpbGQgfm9yaWdpbmFsX3BhcmVudCB+Y2hpbGQgfnBhcmVudCA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBjaGlsZCk7XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBwYXJlbnQpO1xuICBpZiBOb2RlLnNhbWUgcGFyZW50IG9yaWdpbmFsX2NoaWxkXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiYWRkaW5nIGVkZ2UgbWFkZSBncmFwaCBjeWNsaWNcIlxuICAgICAgKGBjaGlsZCBvcmlnaW5hbF9jaGlsZCwgYHBhcmVudCBvcmlnaW5hbF9wYXJlbnQpXG4gICAgICBbJXNleHBfb2Y6IFsgYGNoaWxkIG9mIF8gTm9kZS50IF0gKiBbIGBwYXJlbnQgb2YgXyBOb2RlLnQgXV07XG4gIGlmIGNoaWxkLmhlaWdodCA+PSBwYXJlbnQuaGVpZ2h0XG4gIHRoZW4gKFxuICAgIGFkZF91bmxlc3NfbWVtIHQgcGFyZW50O1xuICAgICgqIFdlIHNldCBbcGFyZW50LmhlaWdodF0gYWZ0ZXIgYWRkaW5nIFtwYXJlbnRdIHRvIHRoZSBoZWFwLCBzbyB0aGF0IFtwYXJlbnRdIGdvZXNcbiAgICAgICBpbiB0aGUgaGVhcCB3aXRoIGl0cyBwcmUtYWRqdXN0ZWQgaGVpZ2h0LiAqKVxuICAgIHNldF9oZWlnaHQgdCBwYXJlbnQgKGNoaWxkLmhlaWdodCArIDEpKVxuOztcblxubGV0IGFkanVzdF9oZWlnaHRzXG4gICAgICAodHlwZSBhIGIpXG4gICAgICB0XG4gICAgICByZWNvbXB1dGVfaGVhcFxuICAgICAgfmNoaWxkOihvcmlnaW5hbF9jaGlsZCA6IGEgTm9kZS50KVxuICAgICAgfnBhcmVudDoob3JpZ2luYWxfcGFyZW50IDogYiBOb2RlLnQpXG4gID1cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGlzX2VtcHR5IHQpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAob3JpZ2luYWxfY2hpbGQuaGVpZ2h0ID49IG9yaWdpbmFsX3BhcmVudC5oZWlnaHQpO1xuICB0LmhlaWdodF9sb3dlcl9ib3VuZCA8LSBvcmlnaW5hbF9wYXJlbnQuaGVpZ2h0O1xuICBlbnN1cmVfaGVpZ2h0X3JlcXVpcmVtZW50XG4gICAgdFxuICAgIH5vcmlnaW5hbF9jaGlsZFxuICAgIH5vcmlnaW5hbF9wYXJlbnRcbiAgICB+Y2hpbGQ6b3JpZ2luYWxfY2hpbGRcbiAgICB+cGFyZW50Om9yaWdpbmFsX3BhcmVudDtcbiAgd2hpbGUgbGVuZ3RoIHQgPiAwIGRvXG4gICAgbGV0IChUIGNoaWxkKSA9IHJlbW92ZV9taW5fZXhuIHQgaW5cbiAgICBpZiBOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIGNoaWxkXG4gICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5pbmNyZWFzZV9oZWlnaHQgcmVjb21wdXRlX2hlYXAgY2hpbGQ7XG4gICAgaWYgY2hpbGQubnVtX3BhcmVudHMgPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgKFQgcGFyZW50KSA9IFVvcHQudmFsdWVfZXhuIGNoaWxkLnBhcmVudDAgaW5cbiAgICAgIGVuc3VyZV9oZWlnaHRfcmVxdWlyZW1lbnQgdCB+b3JpZ2luYWxfY2hpbGQgfm9yaWdpbmFsX3BhcmVudCB+Y2hpbGQgfnBhcmVudDtcbiAgICAgIGZvciBwYXJlbnRfaW5kZXggPSAxIHRvIGNoaWxkLm51bV9wYXJlbnRzIC0gMSBkb1xuICAgICAgICBsZXQgKFQgcGFyZW50KSA9XG4gICAgICAgICAgVW9wdC52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkuZ2V0IGNoaWxkLnBhcmVudDFfYW5kX2JleW9uZCAocGFyZW50X2luZGV4IC0gMSkpXG4gICAgICAgIGluXG4gICAgICAgIGVuc3VyZV9oZWlnaHRfcmVxdWlyZW1lbnQgdCB+b3JpZ2luYWxfY2hpbGQgfm9yaWdpbmFsX3BhcmVudCB+Y2hpbGQgfnBhcmVudFxuICAgICAgZG9uZSk7XG4gICAgbWF0Y2ggY2hpbGQua2luZCB3aXRoXG4gICAgfCBCaW5kX2xoc19jaGFuZ2UgeyBhbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHM7IF8gfSAtPlxuICAgICAgbGV0IHIgPSByZWYgYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzIGluXG4gICAgICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICAgICAgbGV0IChUIG5vZGVfb25fcmhzKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgICAgIHIgOj0gbm9kZV9vbl9yaHMubmV4dF9ub2RlX2luX3NhbWVfc2NvcGU7XG4gICAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVfb25fcmhzXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBlbnN1cmVfaGVpZ2h0X3JlcXVpcmVtZW50XG4gICAgICAgICAgICB0XG4gICAgICAgICAgICB+b3JpZ2luYWxfY2hpbGRcbiAgICAgICAgICAgIH5vcmlnaW5hbF9wYXJlbnRcbiAgICAgICAgICAgIH5jaGlsZFxuICAgICAgICAgICAgfnBhcmVudDpub2RlX29uX3Joc1xuICAgICAgZG9uZVxuICAgIHwgXyAtPiAoKVxuICBkb25lO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoaXNfZW1wdHkgdCk7XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChvcmlnaW5hbF9jaGlsZC5oZWlnaHQgPCBvcmlnaW5hbF9wYXJlbnQuaGVpZ2h0KVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBY3Rpb24gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVHlwZXMuQWxhcm1fdmFsdWUuQWN0aW9uLnQgPVxuICAgIHwgQXQgb2YgQXQudFxuICAgIHwgQXRfaW50ZXJ2YWxzIG9mIEF0X2ludGVydmFscy50XG4gICAgfCBTbmFwc2hvdCA6IF8gU25hcHNob3QudCAtPiB0XG4gICAgfCBTdGVwX2Z1bmN0aW9uIDogXyBTdGVwX2Z1bmN0aW9uX25vZGUudCAtPiB0XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGZ1bmN0aW9uXG4gICAgfCBBdCBhdCAtPiBBdC5pbnZhcmlhbnQgYXRcbiAgICB8IEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMgLT4gQXRfaW50ZXJ2YWxzLmludmFyaWFudCBhdF9pbnRlcnZhbHNcbiAgICB8IFNuYXBzaG90IHNuYXBzaG90IC0+IFNuYXBzaG90LmludmFyaWFudCBpZ25vcmUgc25hcHNob3RcbiAgICB8IFN0ZXBfZnVuY3Rpb24gc3RlcF9mdW5jdGlvbl9ub2RlIC0+XG4gICAgICBTdGVwX2Z1bmN0aW9uX25vZGUuaW52YXJpYW50IGlnbm9yZSBzdGVwX2Z1bmN0aW9uX25vZGVcbiAgOztcbmVuZFxuXG50eXBlIHQgPSBUeXBlcy5BbGFybV92YWx1ZS50ID1cbiAgeyBhY3Rpb24gOiBBY3Rpb24udFxuICA7ICgqIFtuZXh0X2ZpcmVkXSBzaW5nbHkgbGlua3MgYWxsIGFsYXJtIHZhbHVlcyB0aGF0IGZpcmUgZHVyaW5nIGEgc2luZ2xlIGNhbGwgdG9cbiAgICAgICBbYWR2YW5jZV9jbG9ja10uICopXG4gICAgbXV0YWJsZSBuZXh0X2ZpcmVkIDogKHQgVW9wdC50W0BzZXhwLm9wYXF1ZV0pXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXIgfmFjdGlvbjooY2hlY2sgQWN0aW9uLmludmFyaWFudCkgfm5leHRfZmlyZWQ6aWdub3JlKVxuOztcblxubGV0IGNyZWF0ZSBhY3Rpb24gPSB7IGFjdGlvbjsgbmV4dF9maXJlZCA9IFVvcHQubm9uZSB9XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29uZmlnX2ludGZcblxubW9kdWxlIERlZmF1bHQgKCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmRfbGhzX2NoYW5nZV9zaG91bGRfaW52YWxpZGF0ZV9yaHMgPSB0cnVlXG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLkludGVybmFsX29ic2VydmVyXG5cbm1vZHVsZSBQYWNrZWRfID0gc3RydWN0XG4gIGluY2x1ZGUgVHlwZXMuSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkXG5cbiAgbGV0IHNleHBfb2ZfdCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPVxuICAgIGludGVybmFsX29ic2VydmVyLm9ic2VydmluZyB8PiBbJXNleHBfb2Y6IF8gVHlwZXMuTm9kZS50XVxuICA7O1xuXG4gIGxldCBwcmV2X2luX2FsbCAoVCB0KSA9IHQucHJldl9pbl9hbGxcbiAgbGV0IG5leHRfaW5fYWxsIChUIHQpID0gdC5uZXh0X2luX2FsbFxuICBsZXQgc2V0X3ByZXZfaW5fYWxsIChUIHQxKSB0MiA9IHQxLnByZXZfaW5fYWxsIDwtIHQyXG4gIGxldCBzZXRfbmV4dF9pbl9hbGwgKFQgdDEpIHQyID0gdDEubmV4dF9pbl9hbGwgPC0gdDJcbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVHlwZXMuSW50ZXJuYWxfb2JzZXJ2ZXIuU3RhdGUudCA9XG4gICAgfCBDcmVhdGVkXG4gICAgfCBJbl91c2VcbiAgICB8IERpc2FsbG93ZWRcbiAgICB8IFVubGlua2VkXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuSW50ZXJuYWxfb2JzZXJ2ZXIudCA9XG4gIHsgKCogU3RhdGUgdHJhbnNpdGlvbnM6XG5cbiAgICAgICB7dlxuICAgICAgICAgQ3JlYXRlZCAtLT4gSW5fdXNlIC0tPiBEaXNhbGxvd2VkIC0tPiBVbmxpbmtlZFxuICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgXFwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tL1xuICAgICAgIHZ9ICopXG4gICAgbXV0YWJsZSBzdGF0ZSA6IFN0YXRlLnRcbiAgOyBvYnNlcnZpbmcgOiAnYSBOb2RlLnRcbiAgOyBtdXRhYmxlIG9uX3VwZGF0ZV9oYW5kbGVycyA6ICdhIE9uX3VwZGF0ZV9oYW5kbGVyLnQgbGlzdFxuICA7ICgqIFt7cHJldixuZXh0fV9pbl9hbGxdIGRvdWJseSBsaW5rIGFsbCBvYnNlcnZlcnMgaW4gW3N0YXRlLmFsbF9vYnNlcnZlcnNdLiAqKVxuICAgIG11dGFibGUgcHJldl9pbl9hbGwgOiBQYWNrZWRfLnQgVW9wdC50XG4gIDsgbXV0YWJsZSBuZXh0X2luX2FsbCA6IFBhY2tlZF8udCBVb3B0LnRcbiAgOyAoKiBbe3ByZXYsbmV4dH1faW5fb2JzZXJ2aW5nXSBkb3VibHkgbGluayBhbGwgb2JzZXJ2ZXJzIG9mIFtvYnNlcnZpbmddLiAqKVxuICAgIG11dGFibGUgcHJldl9pbl9vYnNlcnZpbmcgOiAoJ2EgdFtAc2V4cC5vcGFxdWVdKSBVb3B0LnRcbiAgOyBtdXRhYmxlIG5leHRfaW5fb2JzZXJ2aW5nIDogKCdhIHRbQHNleHAub3BhcXVlXSkgVW9wdC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxudHlwZSAnYSBpbnRlcm5hbF9vYnNlcnZlciA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGluY3Jfc3RhdGUgdCA9IHQub2JzZXJ2aW5nLnN0YXRlXG5cbmxldCB1c2VfaXNfYWxsb3dlZCB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ3JlYXRlZCB8IEluX3VzZSAtPiB0cnVlXG4gIHwgRGlzYWxsb3dlZCB8IFVubGlua2VkIC0+IGZhbHNlXG47O1xuXG5sZXQgc2FtZSAodDEgOiBfIHQpICh0MiA6IF8gdCkgPSBwaHlzX3NhbWUgdDEgdDJcbmxldCBzYW1lX2FzX3BhY2tlZCAodDEgOiBfIHQpIChQYWNrZWRfLlQgdDIpID0gc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+c3RhdGU6aWdub3JlXG4gICAgICB+b2JzZXJ2aW5nOihjaGVjayAoTm9kZS5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfm9uX3VwZGF0ZV9oYW5kbGVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gb25fdXBkYXRlX2hhbmRsZXJzIC0+XG4gICAgICAgICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgICAgICB8IENyZWF0ZWQgfCBJbl91c2UgfCBEaXNhbGxvd2VkIC0+ICgpXG4gICAgICAgICAgIHwgVW5saW5rZWQgLT4gYXNzZXJ0IChMaXN0LmlzX2VtcHR5IG9uX3VwZGF0ZV9oYW5kbGVycykpKVxuICAgICAgfnByZXZfaW5fYWxsOlxuICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2luX2FsbCAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIHByZXZfaW5fYWxsKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBwcmV2X2luX2FsbFxuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHNhbWVfYXNfcGFja2VkXG4gICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIChQYWNrZWRfLm5leHRfaW5fYWxsIChVb3B0LnZhbHVlX2V4biBwcmV2X2luX2FsbCkpKSkpKVxuICAgICAgfm5leHRfaW5fYWxsOlxuICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2luX2FsbCAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIG5leHRfaW5fYWxsKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX2FsbFxuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHNhbWVfYXNfcGFja2VkXG4gICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIChQYWNrZWRfLnByZXZfaW5fYWxsIChVb3B0LnZhbHVlX2V4biBuZXh0X2luX2FsbCkpKSkpKVxuICAgICAgfnByZXZfaW5fb2JzZXJ2aW5nOlxuICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2luX29ic2VydmluZyAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIHByZXZfaW5fb2JzZXJ2aW5nKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBwcmV2X2luX29ic2VydmluZ1xuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWxcbiAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAoVW9wdC52YWx1ZV9leG5cbiAgICAgICAgICAgICAgICAgICAgKG5leHRfaW5fb2JzZXJ2aW5nIChVb3B0LnZhbHVlX2V4biBwcmV2X2luX29ic2VydmluZykpKSkpKVxuICAgICAgfm5leHRfaW5fb2JzZXJ2aW5nOlxuICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2luX29ic2VydmluZyAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIG5leHRfaW5fb2JzZXJ2aW5nKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX29ic2VydmluZ1xuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWxcbiAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAoVW9wdC52YWx1ZV9leG5cbiAgICAgICAgICAgICAgICAgICAgKHByZXZfaW5fb2JzZXJ2aW5nIChVb3B0LnZhbHVlX2V4biBuZXh0X2luX29ic2VydmluZykpKSkpKSlcbjs7XG5cbmxldCB2YWx1ZV9leG4gdCA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IENyZWF0ZWQgLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiT2JzZXJ2ZXIudmFsdWVfZXhuIGNhbGxlZCB3aXRob3V0IHN0YWJpbGl6aW5nXCJcbiAgICAgIHRcbiAgICAgIFslc2V4cF9vZjogXyB0XVxuICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPlxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJPYnNlcnZlci52YWx1ZV9leG4gY2FsbGVkIGFmdGVyIGRpc2FsbG93X2Z1dHVyZV91c2VcIlxuICAgICAgdFxuICAgICAgWyVzZXhwX29mOiBfIHRdXG4gIHwgSW5fdXNlIC0+XG4gICAgbGV0IHVvcHQgPSB0Lm9ic2VydmluZy52YWx1ZV9vcHQgaW5cbiAgICBpZiBVb3B0LmlzX25vbmUgdW9wdFxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiYXR0ZW1wdCB0byBnZXQgdmFsdWUgb2YgYW4gaW52YWxpZCBub2RlXCIgdCBbJXNleHBfb2Y6IF8gdF07XG4gICAgVW9wdC51bnNhZmVfdmFsdWUgdW9wdFxuOztcblxubGV0IG9uX3VwZGF0ZV9leG4gdCBvbl91cGRhdGVfaGFuZGxlciA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPlxuICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwib25fdXBkYXRlIGRpc2FsbG93ZWRcIiB0IFslc2V4cF9vZjogXyB0XVxuICB8IENyZWF0ZWQgfCBJbl91c2UgLT5cbiAgICB0Lm9uX3VwZGF0ZV9oYW5kbGVycyA8LSBvbl91cGRhdGVfaGFuZGxlciA6OiB0Lm9uX3VwZGF0ZV9oYW5kbGVycztcbiAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgIHwgRGlzYWxsb3dlZCB8IFVubGlua2VkIC0+IGFzc2VydCBmYWxzZVxuICAgICB8IENyZWF0ZWQgLT5cbiAgICAgICAoKiBXZSdsbCBidW1wIFtvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVyc10gd2hlbiBbdF0gaXMgYWN0dWFsbHkgYWRkZWQgdG9cbiAgICAgICAgICBbb2JzZXJ2aW5nLm9ic2VydmVyc10gYXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHN0YWJpbGl6YXRpb24uICopXG4gICAgICAgKClcbiAgICAgfCBJbl91c2UgLT5cbiAgICAgICBsZXQgb2JzZXJ2aW5nID0gdC5vYnNlcnZpbmcgaW5cbiAgICAgICBvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVycyA8LSBvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVycyArIDEpXG47O1xuXG5sZXQgdW5saW5rX2Zyb21fb2JzZXJ2aW5nIHQgPVxuICBsZXQgcHJldiA9IHQucHJldl9pbl9vYnNlcnZpbmcgaW5cbiAgbGV0IG5leHQgPSB0Lm5leHRfaW5fb2JzZXJ2aW5nIGluXG4gIHQucHJldl9pbl9vYnNlcnZpbmcgPC0gVW9wdC5ub25lO1xuICB0Lm5leHRfaW5fb2JzZXJ2aW5nIDwtIFVvcHQubm9uZTtcbiAgaWYgVW9wdC5pc19zb21lIG5leHQgdGhlbiAoVW9wdC51bnNhZmVfdmFsdWUgbmV4dCkucHJldl9pbl9vYnNlcnZpbmcgPC0gcHJldjtcbiAgaWYgVW9wdC5pc19zb21lIHByZXYgdGhlbiAoVW9wdC51bnNhZmVfdmFsdWUgcHJldikubmV4dF9pbl9vYnNlcnZpbmcgPC0gbmV4dDtcbiAgbGV0IG9ic2VydmluZyA9IHQub2JzZXJ2aW5nIGluXG4gIGlmIHBoeXNfZXF1YWwgdCAoVW9wdC52YWx1ZV9leG4gb2JzZXJ2aW5nLm9ic2VydmVycykgdGhlbiBvYnNlcnZpbmcub2JzZXJ2ZXJzIDwtIG5leHQ7XG4gIG9ic2VydmluZy5udW1fb25fdXBkYXRlX2hhbmRsZXJzXG4gIDwtIG9ic2VydmluZy5udW1fb25fdXBkYXRlX2hhbmRsZXJzIC0gTGlzdC5sZW5ndGggdC5vbl91cGRhdGVfaGFuZGxlcnM7XG4gIHQub25fdXBkYXRlX2hhbmRsZXJzIDwtIFtdXG47O1xuXG5sZXQgdW5saW5rX2Zyb21fYWxsIHQgPVxuICBsZXQgcHJldiA9IHQucHJldl9pbl9hbGwgaW5cbiAgbGV0IG5leHQgPSB0Lm5leHRfaW5fYWxsIGluXG4gIHQucHJldl9pbl9hbGwgPC0gVW9wdC5ub25lO1xuICB0Lm5leHRfaW5fYWxsIDwtIFVvcHQubm9uZTtcbiAgaWYgVW9wdC5pc19zb21lIG5leHQgdGhlbiBQYWNrZWRfLnNldF9wcmV2X2luX2FsbCAoVW9wdC51bnNhZmVfdmFsdWUgbmV4dCkgcHJldjtcbiAgaWYgVW9wdC5pc19zb21lIHByZXYgdGhlbiBQYWNrZWRfLnNldF9uZXh0X2luX2FsbCAoVW9wdC51bnNhZmVfdmFsdWUgcHJldikgbmV4dFxuOztcblxubGV0IHVubGluayB0ID1cbiAgdW5saW5rX2Zyb21fb2JzZXJ2aW5nIHQ7XG4gIHVubGlua19mcm9tX2FsbCB0XG47O1xuXG5tb2R1bGUgUGFja2VkID0gc3RydWN0XG4gIGluY2x1ZGUgUGFja2VkX1xuXG4gIGxldCBzZXhwX29mX3QgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpID1cbiAgICBpbnRlcm5hbF9vYnNlcnZlciB8PiBbJXNleHBfb2Y6IF8gaW50ZXJuYWxfb2JzZXJ2ZXJdXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCAoVCB0KSA9IGludmFyaWFudCBpZ25vcmUgdFxuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPSAnYSBJbnRlcm5hbF9vYnNlcnZlci50IHJlZiBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBJbnRlcm5hbF9vYnNlcnZlci5pbnZhcmlhbnQgaW52YXJpYW50X2EgIXRcbmxldCBvYnNlcnZpbmcgdCA9IEludGVybmFsX29ic2VydmVyLm9ic2VydmluZyAhdFxubGV0IHVzZV9pc19hbGxvd2VkIHQgPSBJbnRlcm5hbF9vYnNlcnZlci51c2VfaXNfYWxsb3dlZCAhdFxubGV0IHZhbHVlX2V4biB0ID0gSW50ZXJuYWxfb2JzZXJ2ZXIudmFsdWVfZXhuICF0XG5sZXQgaW5jcl9zdGF0ZSB0ID0gSW50ZXJuYWxfb2JzZXJ2ZXIuaW5jcl9zdGF0ZSAhdFxuXG5sZXQgb25fdXBkYXRlX2V4biB0IG9uX3VwZGF0ZV9oYW5kbGVyID1cbiAgSW50ZXJuYWxfb2JzZXJ2ZXIub25fdXBkYXRlX2V4biAhdCBvbl91cGRhdGVfaGFuZGxlclxuOztcbiIsIigqIFtTdGF0ZV0gZGVmaW5lcyB0aGUgZ2xvYmFsIHN0YXRlIG9mIHdoaWNoIHRoZXJlIGlzIG9uZSBpbnN0YW5jZSBmb3IgZWFjaCBjYWxsIHRvXG4gICBbSW5jcmVtZW50YWwuTWFrZV0uXG5cbiAgIFRoaXMgbW9kdWxlIGRvZXMgbm90IGhhdmUgYW4gbWxpIGJlY2F1c2UgaXQgd291bGQgZXNzZW50aWFsbHkgZHVwbGljYXRlXG4gICBbSW5jcmVtZW50YWwuU10sIGV4Y2VwdCBhZGRpbmcgYW4gZXh0cmEgW1N0YXRlLnRdIGFyZ3VtZW50IHRvIGZ1bmN0aW9ucy4gKilcblxub3BlbiBDb3JlXG5vcGVuIEltcG9ydFxub3BlbiBUeXBlcy5LaW5kXG5cbnR5cGUgc3RhdHVzID0gVHlwZXMuU3RhdHVzLnQgPVxuICB8IFN0YWJpbGl6aW5nXG4gIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnNcbiAgfCBOb3Rfc3RhYmlsaXppbmdcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgb2YgUmFpc2VkX2V4bi50XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgTm9kZV91cGRhdGUgPSBPbl91cGRhdGVfaGFuZGxlci5Ob2RlX3VwZGF0ZVxuXG5tb2R1bGUgUnVuX29uX3VwZGF0ZV9oYW5kbGVycyA9IHN0cnVjdFxuICB0eXBlIHQgPSBUeXBlcy5SdW5fb25fdXBkYXRlX2hhbmRsZXJzLnQgPSBUIDogJ2EgTm9kZS50ICogJ2EgTm9kZV91cGRhdGUudCAtPiB0XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCAoVCAobm9kZSwgX25vZGVfdXBkYXRlKSBhcyB0KSA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+IE5vZGUuaW52YXJpYW50IGlnbm9yZSBub2RlKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPbmx5X2luX2RlYnVnID0gc3RydWN0XG4gICgqIEV4dHJhIHN0YXRlIGtlcHQgb25seSB3aGVuIFtkZWJ1Z10gZm9yIHRoZSBwdXJwb3NlIG9mIHdyaXRpbmcgYXNzZXJ0aW9ucy4gKilcbiAgdHlwZSB0ID0gVHlwZXMuT25seV9pbl9kZWJ1Zy50ID1cbiAgICB7IG11dGFibGUgY3VycmVudGx5X3J1bm5pbmdfbm9kZSA6IE5vZGUuUGFja2VkLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZSA6IE5vZGUuUGFja2VkLnQgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+Y3VycmVudGx5X3J1bm5pbmdfbm9kZTppZ25vcmVcbiAgICAgICAgfmV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZTppZ25vcmUpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSAoKSA9XG4gICAgeyBjdXJyZW50bHlfcnVubmluZ19ub2RlID0gTm9uZTsgZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlID0gW10gfVxuICA7O1xuZW5kXG5cbm1vZHVsZSBQYWNrZWRfd2Vha19oYXNodGJsID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLlBhY2tlZF93ZWFrX2hhc2h0YmwudCA9IFQgOiAoXywgXykgV2Vha19oYXNodGJsLnQgLT4gdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbnR5cGUgdCA9IFR5cGVzLlN0YXRlLnQgPVxuICB7IG11dGFibGUgc3RhdHVzIDogc3RhdHVzXG4gIDsgYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3JocyA6IGJvb2xcbiAgOyAoKiBbc3RhYmlsaXphdGlvbl9udW1dIHN0YXJ0cyBhdCB6ZXJvLCBhbmQgaXMgaW5jcmVtZW50ZWQgYXQgdGhlIGVuZCBvZiBlYWNoXG4gICAgICAgc3RhYmlsaXphdGlvbi4gKilcbiAgICBtdXRhYmxlIHN0YWJpbGl6YXRpb25fbnVtIDogU3RhYmlsaXphdGlvbl9udW0udFxuICA7IG11dGFibGUgY3VycmVudF9zY29wZSA6IFNjb3BlLnRcbiAgOyByZWNvbXB1dGVfaGVhcCA6IFJlY29tcHV0ZV9oZWFwLnRcbiAgOyBhZGp1c3RfaGVpZ2h0c19oZWFwIDogQWRqdXN0X2hlaWdodHNfaGVhcC50XG4gIDsgKCogW3Byb3BhZ2F0ZV9pbnZhbGlkaXR5XSBob2xkcyBub2RlcyB0aGF0IGhhdmUgaW52YWxpZCBjaGlsZHJlbiB0aGF0IHNob3VsZCBiZVxuICAgICAgIGNvbnNpZGVyZWQgZm9yIGludmFsaWRhdGlvbi4gIEl0IGlzIG9ubHkgdXNlZCBkdXJpbmcgZ3JhcGggcmVzdHJ1Y3R1cmluZzpcbiAgICAgICBbaW52YWxpZGF0ZV9ub2RlXSBhbmQgW2FkZF9wYXJlbnRdLiAgT25jZSBhbiBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBzdGFjaywgd2UgdGhlblxuICAgICAgIGl0ZXJhdGUgdW50aWwgaW52YWxpZGl0eSBoYXMgcHJvcGFnYXRlZCB0byBhbGwgYW5jZXN0b3JzIGFzIG5lY2Vzc2FyeSwgYWNjb3JkaW5nIHRvXG4gICAgICAgW05vZGUuc2hvdWxkX2JlX2ludmFsaWRhdGVkXS4gKilcbiAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSA6IE5vZGUuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFtudW1fYWN0aXZlX29ic2VydmVyc10gaXMgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgd2hvc2Ugc3RhdGUgaXMgW0NyZWF0ZWRdIG9yXG4gICAgICAgW0luX3VzZV0uICopXG4gICAgbXV0YWJsZSBudW1fYWN0aXZlX29ic2VydmVycyA6IGludFxuICA7ICgqIFthbGxfb2JzZXJ2ZXJzXSBpcyB0aGUgZG91Ymx5LWxpbmtlZCBsaXN0IG9mIGFsbCBvYnNlcnZlcnMgaW4gZWZmZWN0LCBvciB0aGF0IGhhdmVcbiAgICAgICBiZWVuIGRpc2FsbG93ZWQgc2luY2UgdGhlIG1vc3QgcmVjZW50IHN0YXJ0IG9mIGEgc3RhYmlsaXphdGlvbiAtLSB0aGVzZSBoYXZlXG4gICAgICAgW3N0YXRlXSBhcyBbSW5fdXNlXSBvciBbRGlzYWxsb3dlZF0uICopXG4gICAgbXV0YWJsZSBhbGxfb2JzZXJ2ZXJzIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgVW9wdC50XG4gIDsgKCogV2UgZW5xdWV1ZSBmaW5hbGl6ZWQgb2JzZXJ2ZXJzIGluIGEgdGhyZWFkLXNhZmUgcXVldWUsIGZvciBoYW5kbGluZyBkdXJpbmdcbiAgICAgICBzdGFiaWxpemF0aW9uLiAgV2UgdXNlIGEgdGhyZWFkLXNhZmUgcXVldWUgYmVjYXVzZSBPQ2FtbCBmaW5hbGl6ZXJzIGNhbiBydW4gaW4gYW55XG4gICAgICAgdGhyZWFkLiAqKVxuICAgIGZpbmFsaXplZF9vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gIDsgKCogW25ld19vYnNlcnZlcnNdIGhvbGRzIG9ic2VydmVycyBjcmVhdGVkIHNpbmNlIHRoZSBtb3N0IHJlY2VudCBzdGFydCBvZiBhXG4gICAgICAgc3RhYmlsaXphdGlvbiAtLSB0aGVzZSBoYXZlIFtzdGF0ZV0gYXMgW0NyZWF0ZWRdIG9yIFtVbmxpbmtlZF0uICBBdCB0aGUgc3RhcnQgb2ZcbiAgICAgICBzdGFiaWxpemF0aW9uLCB3ZSBsaW5rIGludG8gW2FsbF9vYnNlcnZlcnNdIGFsbCBvYnNlcnZlcnMgaW4gW25ld19vYnNlcnZlcnNdIHdob3NlXG4gICAgICAgc3RhdGUgaXMgW0NyZWF0ZWRdIGFuZCBhZGQgdGhlbSB0byB0aGUgW29ic2VydmVyc10gb2YgdGhlIG5vZGUgdGhleSBhcmUgb2JzZXJ2aW5nLlxuICAgICAgIFdlIHN0cnVjdHVyZSB0aGluZ3MgdGhpcyB3YXkgdG8gYWxsb3cgb2JzZXJ2ZXJzIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHN0YWJpbGl6YXRpb25cbiAgICAgICB3aGlsZSBydW5uaW5nIHVzZXIgY29kZSAoW21hcF0sIFtiaW5kXSwgZXRjKSwgYnV0IHRvIG5vdCBoYXZlIHRvIGRlYWwgd2l0aCBub2Rlc1xuICAgICAgIGJlY29taW5nIG5lY2Vzc2FyeSBhbmQgdGhlIHRoZSBncmFwaCBjaGFuZ2luZyBkdXJpbmcgc3VjaCBjb2RlLiAqKVxuICAgIG5ld19vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBTdGFjay50XG4gIDsgKCogW2Rpc2FsbG93ZWRfb2JzZXJ2ZXJzXSBob2xkcyBhbGwgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBiZWVuIGRpc2FsbG93ZWQgc2luY2UgdGhlIG1vc3RcbiAgICAgICByZWNlbnQgc3RhcnQgb2YgYSBzdGFiaWxpemF0aW9uIC0tIHRoZXNlIGhhdmUgW3N0YXRlID0gRGlzYWxsb3dlZF0uICBBdCB0aGUgc3RhcnRcbiAgICAgICBvZiBzdGFiaWxpemF0aW9uLCB0aGVzZSBhcmUgdW5saW5rZWQgZnJvbSBbYWxsX29ic2VydmVyc10gYW5kIHRoZWlyIHN0YXRlIGlzXG4gICAgICAgY2hhbmdlZCB0byBbVW5saW5rZWRdLiAgV2Ugc3RydWN0dXJlIHRoaW5ncyB0aGlzIHdheSB0byBhbGxvdyB1c2VyIGNvZGUgcnVubmluZ1xuICAgICAgIGR1cmluZyBzdGFiaWxpemF0aW9uIHRvIGNhbGwgW2Rpc2FsbG93X2Z1dHVyZV91c2VdLCBidXQgdG8gbm90IGhhdmUgdG8gZGVhbCB3aXRoXG4gICAgICAgbm9kZXMgYmVjb21pbmcgdW5uZWNlc3NhcnkgYW5kIHRoZSBncmFwaCBjaGFuZ2luZyBkdXJpbmcgc3VjaCBjb2RlLiAqKVxuICAgIGRpc2FsbG93ZWRfb2JzZXJ2ZXJzIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFdlIGRlbGF5IGFsbCBbVmFyLnNldF0gY2FsbHMgdGhhdCBoYXBwZW4gZHVyaW5nIHN0YWJpbGl6YXRpb24gc28gdGhhdCB0aGV5IHRha2VcbiAgICAgICBlZmZlY3QgYWZ0ZXIgc3RhYmlsaXphdGlvbi4gIEFsbCB2YXJpYWJsZXMgc2V0IGR1cmluZyBzdGFiaWxpemF0aW9uIGFyZSBwdXNoZWQgb25cbiAgICAgICBbc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uXSByYXRoZXIgdGhhbiBzZXR0aW5nIHRoZW0uICBUaGVuLCBhZnRlciB0aGUgZ3JhcGggaGFzXG4gICAgICAgc3RhYmlsaXplZCwgd2UgZG8gYWxsIHRoZSBzZXRzLCBzbyB0aGF0IHRoZXkgdGFrZSBlZmZlY3QgYXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgc3RhYmlsaXphdGlvbi4gKilcbiAgICBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gOiBWYXIuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFtoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0gaGFzIGFsbCBub2RlcyB3aXRoIGhhbmRsZXJzIHRvIGNvbnNpZGVyIHJ1bm5pbmcgYXQgdGhlXG4gICAgICAgZW5kIG9mIHRoZSBuZXh0IHN0YWJpbGl6YXRpb24uICBBdCB0aGUgZW5kIG9mIHN0YWJpbGl6YXRpb24sIHdlIGNvbnNpZGVyIGVhY2ggbm9kZVxuICAgICAgIGluIFtoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0sIGFuZCBpZiB3ZSBkZWNpZGUgdG8gcnVuIGl0cyBvbi11cGRhdGUgaGFuZGxlcnMsXG4gICAgICAgcHVzaCBpdCBvbiBbcnVuX29uX3VwZGF0ZV9oYW5kbGVyc10uICBUaGVuLCBvbmNlIHdlJ3ZlIGNvbnNpZGVyZWQgYWxsIG5vZGVzIGluXG4gICAgICAgW2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXSwgd2UgaXRlcmF0ZSB0aHJvdWdoIFtydW5fb25fdXBkYXRlX2hhbmRsZXJzXSBhbmRcbiAgICAgICBhY3R1YWxseSBydW4gdGhlIGhhbmRsZXJzLlxuXG4gICAgICAgVGhlc2UgdHdvIHBhc3NlcyBhcmUgZXNzZW50aWFsIGZvciBjb3JyZWN0bmVzcy4gIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UgaGF2ZW4ndFxuICAgICAgIHJ1biBhbnkgdXNlciBoYW5kbGVycywgc28gd2Uga25vdyB0aGF0IHRoZSBzdGF0ZSBpcyBleGFjdGx5IGFzIGl0IHdhcyB3aGVuXG4gICAgICAgc3RhYmlsaXphdGlvbiBmaW5pc2hlZC4gIEluIHBhcnRpY3VsYXIsIHdlIGtub3cgdGhhdCBpZiBhIG5vZGUgaXMgbmVjZXNzYXJ5LCB0aGVuXG4gICAgICAgaXQgaGFzIGEgc3RhYmxlIHZhbHVlOyBvbmNlIHVzZXIgaGFuZGxlcnMgcnVuLCB3ZSBkb24ndCBrbm93IHRoaXMuICBEdXJpbmcgdGhlXG4gICAgICAgc2Vjb25kIHBhc3MsIHVzZXIgaGFuZGxlcnMgY2FuIG1ha2UgY2FsbHMgdG8gYW55IGluY3JlbWVudGFsIGZ1bmN0aW9uIGV4Y2VwdCBmb3JcbiAgICAgICBbc3RhYmlsaXplXS4gIEluIHBhcnRpY3VsYXIsIHNvbWUgZnVuY3Rpb25zIHB1c2ggbm9kZXMgb25cbiAgICAgICBbaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25dLiAgQnV0IG5vIGZ1bmN0aW9ucyAoZXhjZXB0IGZvciBbc3RhYmlsaXplXSkgbW9kaWZ5XG4gICAgICAgW3J1bl9vbl91cGRhdGVfaGFuZGxlcnNdLiAqKVxuICAgIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIDogTm9kZS5QYWNrZWQudCBTdGFjay50XG4gIDsgcnVuX29uX3VwZGF0ZV9oYW5kbGVycyA6IFJ1bl9vbl91cGRhdGVfaGFuZGxlcnMudCBTdGFjay50XG4gIDsgbXV0YWJsZSBvbmx5X2luX2RlYnVnIDogT25seV9pbl9kZWJ1Zy50XG4gIDsgd2Vha19oYXNodGJscyA6IFBhY2tlZF93ZWFrX2hhc2h0YmwudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gIDsgbXV0YWJsZSBrZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYWNlIDogYm9vbFxuICA7ICgqIFN0YXRzLiAgVGhlc2UgYXJlIGFsbCBpbmNyZW1lbnRlZCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2UsIGFuZCBuZXZlciBkZWNyZW1lbnRlZC4gKilcbiAgICBtdXRhYmxlIG51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5IDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5IDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfY2hhbmdlZCA6IGludFxuICA7IG11dGFibGUgbnVtX25vZGVzX2NyZWF0ZWQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV9ub2Rlc19pbnZhbGlkYXRlZCA6IGludFxuICA7IG11dGFibGUgbnVtX25vZGVzX3JlY29tcHV0ZWQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2Vfb25lX2NoaWxkIDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX21pbl9oZWlnaHQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV92YXJfc2V0cyA6IGludFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbm1vZHVsZSBDbG9jayA9IHN0cnVjdFxuICB0eXBlIHQgPSBUeXBlcy5DbG9jay50ID1cbiAgICB7ICgqIFdlIHVzZSBbdGltaW5nX3doZWVsXSBmb3IgdGltZS1iYXNlZCBpbmNyZW1lbnRhbHMuICBbbm93XSBpcyBhIHZhcmlhYmxlIGhvbGRpbmdcbiAgICAgICAgIHRoZSBjdXJyZW50IHRpbWUuICBbaGFuZGxlX2ZpcmVkXSBpcyB0aGUgY2xvc3VyZSBwYXNzZWQgdG9cbiAgICAgICAgIFtUaW1pbmdfd2hlZWwuYWR2YW5jZV9jbG9ja10uICBJdCBsaW5rcyBhbGwgdGhlIGZpcmVkIGFsYXJtIHZhbHVlcyBpbnRvXG4gICAgICAgICBbZmlyZWRfYWxhcm1fdmFsdWVzXS4gIEFmdGVyIFtUaW1pbmdfd2hlZWwuYWR2YW5jZV9jbG9ja10gcmV0dXJucywgaXQgdGhlblxuICAgICAgICAgd2Fsa3MgdGhyb3VnaCB0aGUgbGlua2VkIGxpc3QgYW5kIGFjdHVhbGx5IGZpcmVzIHRoZW0uICBUaGlzIHR3by1wYXNzIGFwcHJvYWNoIGlzXG4gICAgICAgICBuZWNlc3NhcnkgYmVjYXVzZSBvbmUgaXMgbm90IGFsbG93ZWQgdG8gY2FsbCBbVGltaW5nX3doZWVsXSBmdW5jdGlvbnMgZnJvbSB0aGVcbiAgICAgICAgIFtoYW5kbGVfZmlyZWRdIHRoYXQgb25lIHBhc3NlcyB0byBbVGltaW5nX3doZWVsLmFkdmFuY2VfY2xvY2tdLiAqKVxuICAgICAgdGltaW5nX3doZWVsIDogQWxhcm1fdmFsdWUudCBUaW1pbmdfd2hlZWwudFxuICAgIDsgbm93IDogVGltZV9ucy50IFZhci50XG4gICAgOyBoYW5kbGVfZmlyZWQgOiBBbGFybS50IC0+IHVuaXRcbiAgICA7IG11dGFibGUgZmlyZWRfYWxhcm1fdmFsdWVzIDogQWxhcm1fdmFsdWUudCBVb3B0LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+bm93OlxuICAgICAgICAgIChjaGVjayAoZnVuIChub3cgOiBfIFZhci50KSAtPlxuICAgICAgICAgICAgIGFzc2VydCAoVGltZV9ucy5lcXVhbCBub3cudmFsdWUgKFRpbWluZ193aGVlbC5ub3cgdC50aW1pbmdfd2hlZWwpKSkpXG4gICAgICAgIH5oYW5kbGVfZmlyZWQ6aWdub3JlXG4gICAgICAgIH5maXJlZF9hbGFybV92YWx1ZXM6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZmlyZWRfYWxhcm1fdmFsdWVzIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIGZpcmVkX2FsYXJtX3ZhbHVlcykpKVxuICAgICAgICB+dGltaW5nX3doZWVsOihjaGVjayAoVGltaW5nX3doZWVsLmludmFyaWFudCBBbGFybV92YWx1ZS5pbnZhcmlhbnQpKSlcbiAgOztcblxuICBsZXQgaW5jcl9zdGF0ZSB0ID0gVmFyLmluY3Jfc3RhdGUgdC5ub3dcbmVuZFxuXG5sZXQgbm93IChjbG9jayA6IENsb2NrLnQpID0gY2xvY2subm93LnZhbHVlXG5sZXQgdGltaW5nX3doZWVsX2xlbmd0aCAoY2xvY2sgOiBDbG9jay50KSA9IFRpbWluZ193aGVlbC5sZW5ndGggY2xvY2sudGltaW5nX3doZWVsXG5sZXQgbnVtX3N0YWJpbGl6ZXMgdCA9IFN0YWJpbGl6YXRpb25fbnVtLnRvX2ludCB0LnN0YWJpbGl6YXRpb25fbnVtXG5sZXQgbWF4X2hlaWdodF9hbGxvd2VkIHQgPSBBZGp1c3RfaGVpZ2h0c19oZWFwLm1heF9oZWlnaHRfYWxsb3dlZCB0LmFkanVzdF9oZWlnaHRzX2hlYXBcbmxldCBtYXhfaGVpZ2h0X3NlZW4gdCA9IEFkanVzdF9oZWlnaHRzX2hlYXAubWF4X2hlaWdodF9zZWVuIHQuYWRqdXN0X2hlaWdodHNfaGVhcFxuXG5sZXQgaXRlcl9vYnNlcnZlcnMgdCB+ZiA9XG4gIGxldCByID0gcmVmIHQuYWxsX29ic2VydmVycyBpblxuICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICBsZXQgb2JzZXJ2ZXIgPSBVb3B0LnVuc2FmZV92YWx1ZSAhciBpblxuICAgIHIgOj0gSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLm5leHRfaW5fYWxsIG9ic2VydmVyO1xuICAgIGYgb2JzZXJ2ZXJcbiAgZG9uZVxuOztcblxubGV0IGRpcmVjdGx5X29ic2VydmVkIHQgPVxuICBsZXQgciA6IE5vZGUuUGFja2VkLnQgbGlzdCByZWYgPSByZWYgW10gaW5cbiAgaXRlcl9vYnNlcnZlcnMgdCB+ZjooZnVuIChUIGludGVybmFsX29ic2VydmVyKSAtPlxuICAgIHIgOj0gVCBpbnRlcm5hbF9vYnNlcnZlci5vYnNlcnZpbmcgOjogIXIpO1xuICAhclxuOztcblxubGV0IHNhdmVfZG90IHQgb3V0ID0gTm9kZS5QYWNrZWQuc2F2ZV9kb3Qgb3V0IChkaXJlY3RseV9vYnNlcnZlZCB0KVxubGV0IHNhdmVfZG90X3RvX2ZpbGUgdCBmaWxlID0gTm9kZS5QYWNrZWQuc2F2ZV9kb3RfdG9fZmlsZSBmaWxlIChkaXJlY3RseV9vYnNlcnZlZCB0KVxubGV0IGl0ZXJfb2JzZXJ2ZXJfZGVzY2VuZGFudHMgdCB+ZiA9IE5vZGUuUGFja2VkLml0ZXJfZGVzY2VuZGFudHMgKGRpcmVjdGx5X29ic2VydmVkIHQpIH5mXG5cbm1vZHVsZSBTdGF0cyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWF4X251bV9wYXJlbnRzIDogaW50XG4gICAgOyBwZXJjZW50YWdlX29mX25vZGVzX2J5X251bV9wYXJlbnRzIDogKGludCAqIFBlcmNlbnQudCkgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF1cbmVuZFxuXG5sZXQgc3RhdHMgdCA9XG4gIGxldCBtYXhfbnVtX3BhcmVudHMgPSByZWYgKC0xKSBpblxuICBsZXQgbnVtX25lY2Vzc2FyeV9ub2RlcyA9IHJlZiAwIGluXG4gIGl0ZXJfb2JzZXJ2ZXJfZGVzY2VuZGFudHMgdCB+ZjooZnVuIChUIG5vZGUpIC0+XG4gICAgaW5jciBudW1fbmVjZXNzYXJ5X25vZGVzO1xuICAgIG1heF9udW1fcGFyZW50cyA6PSBJbnQubWF4ICFtYXhfbnVtX3BhcmVudHMgbm9kZS5udW1fcGFyZW50cyk7XG4gIGxldCBtYXhfbnVtX3BhcmVudHMgPSAhbWF4X251bV9wYXJlbnRzIGluXG4gIGxldCBudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMgPSBBcnJheS5jcmVhdGUgfmxlbjoobWF4X251bV9wYXJlbnRzICsgMSkgMCBpblxuICBpdGVyX29ic2VydmVyX2Rlc2NlbmRhbnRzIHQgfmY6KGZ1biAoVCBub2RlKSAtPlxuICAgIGxldCBudW1fcGFyZW50cyA9IG5vZGUubnVtX3BhcmVudHMgaW5cbiAgICBudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMuKG51bV9wYXJlbnRzKSA8LSBudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMuKG51bV9wYXJlbnRzKSArIDEpO1xuICBsZXQgcGVyY2VudGFnZV9vZl9ub2Rlc19ieV9udW1fcGFyZW50cyA9XG4gICAgQXJyYXkuZm9sZGkgbnVtX25vZGVzX2J5X251bV9wYXJlbnRzIH5pbml0OltdIH5mOihmdW4gaSBhYyBudW1fbm9kZXMgLT5cbiAgICAgIGlmIG51bV9ub2RlcyA9IDBcbiAgICAgIHRoZW4gYWNcbiAgICAgIGVsc2UgKGksIFBlcmNlbnQub2ZfbXVsdCAoZmxvYXQgbnVtX25vZGVzIC8uIGZsb2F0ICFudW1fbmVjZXNzYXJ5X25vZGVzKSkgOjogYWMpXG4gICAgfD4gTGlzdC5yZXZcbiAgaW5cbiAgeyBTdGF0cy5tYXhfbnVtX3BhcmVudHM7IHBlcmNlbnRhZ2Vfb2Zfbm9kZXNfYnlfbnVtX3BhcmVudHMgfVxuOztcblxubGV0IGFtX3N0YWJpbGl6aW5nIHQgPVxuICBtYXRjaCB0LnN0YXR1cyB3aXRoXG4gIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgfCBTdGFiaWxpemluZyAtPiB0cnVlXG4gIHwgTm90X3N0YWJpbGl6aW5nIC0+IGZhbHNlXG4gIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIHJhaXNlZF9leG4gLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiY2Fubm90IGNhbGwgYW1fc3RhYmlsaXppbmcgLS0gc3RhYmlsaXplIHByZXZpb3VzbHkgcmFpc2VkXCJcbiAgICAgIHJhaXNlZF9leG5cbiAgICAgIFslc2V4cF9vZjogUmFpc2VkX2V4bi50XVxuOztcblxubGV0IGludmFyaWFudCB0ID1cbiAgbWF0Y2ggdC5zdGF0dXMgd2l0aFxuICB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCBfIC0+ICgpXG4gIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgfCBTdGFiaWxpemluZyB8IE5vdF9zdGFiaWxpemluZyAtPlxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBpdGVyX29ic2VydmVycyB0IH5mOihmdW4gKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpIC0+XG4gICAgICAgIChtYXRjaCBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSB3aXRoXG4gICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+XG4gICAgICAgICAgIGZhaWx3aXRoc1xuICAgICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICAgICBcIm1lbWJlciBvZiBhbGxfb2JzZXJ2ZXJzIHdpdGggdW5leHBlY3RlZCBzdGF0ZVwiXG4gICAgICAgICAgICAgaW50ZXJuYWxfb2JzZXJ2ZXJcbiAgICAgICAgICAgICBbJXNleHBfb2Y6IF8gSW50ZXJuYWxfb2JzZXJ2ZXIudF0pO1xuICAgICAgICBJbnRlcm5hbF9vYnNlcnZlci5pbnZhcmlhbnQgaWdub3JlIGludGVybmFsX29ic2VydmVyKTtcbiAgICAgIGl0ZXJfb2JzZXJ2ZXJfZGVzY2VuZGFudHMgdCB+ZjooZnVuIChUIG5vZGUpIC0+XG4gICAgICAgIE5vZGUuaW52YXJpYW50IGlnbm9yZSBub2RlO1xuICAgICAgICBpZiBub3QgKGFtX3N0YWJpbGl6aW5nIHQpIHRoZW4gYXNzZXJ0IChVb3B0LmlzX25vbmUgbm9kZS5vbGRfdmFsdWVfb3B0KTtcbiAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICBub2RlLmhlaWdodCA8PSBBZGp1c3RfaGVpZ2h0c19oZWFwLm1heF9oZWlnaHRfc2VlbiB0LmFkanVzdF9oZWlnaHRzX2hlYXApKTtcbiAgICAgIGFzc2VydCAoXG4gICAgICAgIEFkanVzdF9oZWlnaHRzX2hlYXAubWF4X2hlaWdodF9hbGxvd2VkIHQuYWRqdXN0X2hlaWdodHNfaGVhcFxuICAgICAgICA9IFJlY29tcHV0ZV9oZWFwLm1heF9oZWlnaHRfYWxsb3dlZCB0LnJlY29tcHV0ZV9oZWFwKTtcbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5zdGF0dXM6aWdub3JlXG4gICAgICAgIH5iaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWRhdGVfcmhzOmlnbm9yZVxuICAgICAgICB+c3RhYmlsaXphdGlvbl9udW06KGNoZWNrIFN0YWJpbGl6YXRpb25fbnVtLmludmFyaWFudClcbiAgICAgICAgfmN1cnJlbnRfc2NvcGU6XG4gICAgICAgICAgKGNoZWNrIChmdW4gY3VycmVudF9zY29wZSAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgY3VycmVudF9zY29wZSBTY29wZS50b3ApKSlcbiAgICAgICAgfnJlY29tcHV0ZV9oZWFwOihjaGVjayBSZWNvbXB1dGVfaGVhcC5pbnZhcmlhbnQpXG4gICAgICAgIH5hZGp1c3RfaGVpZ2h0c19oZWFwOlxuICAgICAgICAgIChjaGVjayAoZnVuIGFkanVzdF9oZWlnaHRzX2hlYXAgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKEFkanVzdF9oZWlnaHRzX2hlYXAubGVuZ3RoIGFkanVzdF9oZWlnaHRzX2hlYXAgPSAwKTtcbiAgICAgICAgICAgICBBZGp1c3RfaGVpZ2h0c19oZWFwLmludmFyaWFudCBhZGp1c3RfaGVpZ2h0c19oZWFwKSlcbiAgICAgICAgfnByb3BhZ2F0ZV9pbnZhbGlkaXR5OlxuICAgICAgICAgIChjaGVjayAoZnVuIHByb3BhZ2F0ZV9pbnZhbGlkaXR5IC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChTdGFjay5pc19lbXB0eSBwcm9wYWdhdGVfaW52YWxpZGl0eSkpKVxuICAgICAgICB+bnVtX2FjdGl2ZV9vYnNlcnZlcnM6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbnVtX2FjdGl2ZV9vYnNlcnZlcnMgLT4gYXNzZXJ0IChudW1fYWN0aXZlX29ic2VydmVycyA+PSAwKSkpXG4gICAgICAgIH5hbGxfb2JzZXJ2ZXJzOmlnbm9yZVxuICAgICAgICB+ZmluYWxpemVkX29ic2VydmVyczppZ25vcmVcbiAgICAgICAgfm5ld19vYnNlcnZlcnM6XG4gICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgKFN0YWNrLmludmFyaWFudCAoZnVuIHBhY2tlZCAtPlxuICAgICAgICAgICAgICAgIEludGVybmFsX29ic2VydmVyLlBhY2tlZC5pbnZhcmlhbnQgcGFja2VkO1xuICAgICAgICAgICAgICAgIGxldCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPSBwYWNrZWQgaW5cbiAgICAgICAgICAgICAgICAoKiBXaGVuIGFuIG9ic2VydmVyIGlzIGFkZGVkIHRvIFtuZXdfb2JzZXJ2ZXJzXSwgaXQgaGFzIFtzdGF0ZSA9IENyZWF0ZWRdLlxuICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHBvc3NpYmxlIHRyYW5zaXRpb25zIGZyb20gdGhlcmUgYXJlIHRvIFtVbmxpbmtlZF0gb3IgdG9cbiAgICAgICAgICAgICAgICAgICBbSW5fdXNlXSwgd2hpY2ggYWxzbyByZW1vdmVzIGl0IGZyb20gW25ld19vYnNlcnZlcnNdLCBuZXZlciB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgIGFnYWluLiAgVGh1cyBpdCBpcyBpbXBvc3NpYmxlIGZvciBhbiBvYnNlcnZlciBpbiBbbmV3X29ic2VydmVyc10gdG8gYmVcbiAgICAgICAgICAgICAgICAgICBbSW5fdXNlXSBvciBbRGlzYWxsb3dlZF0uICopXG4gICAgICAgICAgICAgICAgbWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+ICgpXG4gICAgICAgICAgICAgICAgfCBJbl91c2UgfCBEaXNhbGxvd2VkIC0+IGFzc2VydCBmYWxzZSkpKVxuICAgICAgICB+ZGlzYWxsb3dlZF9vYnNlcnZlcnM6XG4gICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgKFN0YWNrLmludmFyaWFudCAoZnVuIHBhY2tlZCAtPlxuICAgICAgICAgICAgICAgIEludGVybmFsX29ic2VydmVyLlBhY2tlZC5pbnZhcmlhbnQgcGFja2VkO1xuICAgICAgICAgICAgICAgIGxldCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPSBwYWNrZWQgaW5cbiAgICAgICAgICAgICAgICBtYXRjaCBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICAgfCBEaXNhbGxvd2VkIC0+ICgpXG4gICAgICAgICAgICAgICAgfCBDcmVhdGVkIHwgSW5fdXNlIHwgVW5saW5rZWQgLT4gYXNzZXJ0IGZhbHNlKSkpXG4gICAgICAgIH5zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb246XG4gICAgICAgICAgKGNoZWNrIChmdW4gc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIC0+XG4gICAgICAgICAgICAgbWF0Y2ggdC5zdGF0dXMgd2l0aFxuICAgICAgICAgICAgIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVycyB8IE5vdF9zdGFiaWxpemluZyAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChTdGFjay5pc19lbXB0eSBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pXG4gICAgICAgICAgICAgfCBTdGFiaWxpemluZyAtPlxuICAgICAgICAgICAgICAgU3RhY2suaW52YXJpYW50XG4gICAgICAgICAgICAgICAgIChmdW4gKFZhci5QYWNrZWQuVCB2YXIpIC0+XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19zb21lIHZhci52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pKVxuICAgICAgICAgICAgICAgICBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pKVxuICAgICAgICB+aGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb246KGNoZWNrIChTdGFjay5pbnZhcmlhbnQgTm9kZS5QYWNrZWQuaW52YXJpYW50KSlcbiAgICAgICAgfnJ1bl9vbl91cGRhdGVfaGFuZGxlcnM6XG4gICAgICAgICAgKGNoZWNrIChTdGFjay5pbnZhcmlhbnQgUnVuX29uX3VwZGF0ZV9oYW5kbGVycy5pbnZhcmlhbnQpKVxuICAgICAgICB+b25seV9pbl9kZWJ1ZzooY2hlY2sgT25seV9pbl9kZWJ1Zy5pbnZhcmlhbnQpXG4gICAgICAgIH53ZWFrX2hhc2h0YmxzOmlnbm9yZVxuICAgICAgICB+a2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZTppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5Omlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX2JlY2FtZV91bm5lY2Vzc2FyeTppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19jaGFuZ2VkOmlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX2NyZWF0ZWQ6aWdub3JlXG4gICAgICAgIH5udW1fbm9kZXNfaW52YWxpZGF0ZWQ6aWdub3JlXG4gICAgICAgIH5udW1fbm9kZXNfcmVjb21wdXRlZDppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2Vfb25lX2NoaWxkOmlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9taW5faGVpZ2h0Omlnbm9yZVxuICAgICAgICB+bnVtX3Zhcl9zZXRzOmlnbm9yZSlcbjs7XG5cbmxldCBlbnN1cmVfbm90X3N0YWJpbGl6aW5nIHQgfm5hbWUgfmFsbG93X2luX3VwZGF0ZV9oYW5kbGVyID1cbiAgbWF0Y2ggdC5zdGF0dXMgd2l0aFxuICB8IE5vdF9zdGFiaWxpemluZyAtPiAoKVxuICB8IFJ1bm5pbmdfb25fdXBkYXRlX2hhbmRsZXJzIC0+XG4gICAgaWYgbm90IGFsbG93X2luX3VwZGF0ZV9oYW5kbGVyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLmdldCAoKSBpblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgKHNwcmludGYgXCJjYW5ub3QgJXMgZHVyaW5nIG9uLXVwZGF0ZSBoYW5kbGVyc1wiIG5hbWUpXG4gICAgICAgIGJhY2t0cmFjZVxuICAgICAgICBbJXNleHBfb2Y6IEJhY2t0cmFjZS50XSlcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgcmFpc2VkX2V4biAtPlxuICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuZ2V0ICgpIGluXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAoc3ByaW50ZiBcImNhbm5vdCAlcyAtLSBzdGFiaWxpemUgcHJldmlvdXNseSByYWlzZWRcIiBuYW1lKVxuICAgICAgKHJhaXNlZF9leG4sIGJhY2t0cmFjZSlcbiAgICAgIFslc2V4cF9vZjogUmFpc2VkX2V4bi50ICogQmFja3RyYWNlLnRdXG4gIHwgU3RhYmlsaXppbmcgLT5cbiAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLmdldCAoKSBpblxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgKHNwcmludGYgXCJjYW5ub3QgJXMgZHVyaW5nIHN0YWJpbGl6YXRpb25cIiBuYW1lKVxuICAgICAgYmFja3RyYWNlXG4gICAgICBbJXNleHBfb2Y6IEJhY2t0cmFjZS50XVxuOztcblxubGV0IHNldF9oZWlnaHQgKG5vZGUgOiBfIE5vZGUudCkgaGVpZ2h0ID1cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIEFkanVzdF9oZWlnaHRzX2hlYXAuc2V0X2hlaWdodCB0LmFkanVzdF9oZWlnaHRzX2hlYXAgbm9kZSBoZWlnaHRcbjs7XG5cbmxldCBzZXRfbWF4X2hlaWdodF9hbGxvd2VkIHQgaGVpZ2h0ID1cbiAgZW5zdXJlX25vdF9zdGFiaWxpemluZyB0IH5uYW1lOlwic2V0X21heF9oZWlnaHRfYWxsb3dlZFwiIH5hbGxvd19pbl91cGRhdGVfaGFuZGxlcjp0cnVlO1xuICBBZGp1c3RfaGVpZ2h0c19oZWFwLnNldF9tYXhfaGVpZ2h0X2FsbG93ZWQgdC5hZGp1c3RfaGVpZ2h0c19oZWFwIGhlaWdodDtcbiAgUmVjb21wdXRlX2hlYXAuc2V0X21heF9oZWlnaHRfYWxsb3dlZCB0LnJlY29tcHV0ZV9oZWFwIGhlaWdodFxuOztcblxubGV0IGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIG5vZGUgLT5cbiAgaWYgbm90IG5vZGUuaXNfaW5faGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25cbiAgdGhlbiAoXG4gICAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gICAgbm9kZS5pc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiA8LSB0cnVlO1xuICAgIFN0YWNrLnB1c2ggdC5oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiAoVCBub2RlKSlcbjs7XG5cbmxldCByZWMgcmVtb3ZlX2NoaWxkcmVuIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIHBhcmVudCAtPlxuICBOb2RlLml0ZXJpX2NoaWxkcmVuIHBhcmVudCB+ZjooZnVuIGNoaWxkX2luZGV4IChUIGNoaWxkKSAtPlxuICAgIHJlbW92ZV9jaGlsZCB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXgpXG5cbmFuZCByZW1vdmVfY2hpbGQgOiB0eXBlIGEgYi4gY2hpbGQ6YiBOb2RlLnQgLT4gcGFyZW50OmEgTm9kZS50IC0+IGNoaWxkX2luZGV4OmludCAtPiB1bml0ID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCAtPlxuICBOb2RlLnJlbW92ZV9wYXJlbnQgfmNoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4O1xuICBjaGVja19pZl91bm5lY2Vzc2FyeSBjaGlsZFxuXG5hbmQgY2hlY2tfaWZfdW5uZWNlc3NhcnkgOiB0eXBlIGEuIGEgTm9kZS50IC0+IHVuaXQgPVxuICBmdW4gbm9kZSAtPiBpZiBub3QgKE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGUpIHRoZW4gYmVjYW1lX3VubmVjZXNzYXJ5IG5vZGVcblxuYW5kIGJlY2FtZV91bm5lY2Vzc2FyeSA6IHR5cGUgYS4gYSBOb2RlLnQgLT4gdW5pdCA9XG4gIGZ1biBub2RlIC0+XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICB0Lm51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnkgPC0gdC5udW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5ICsgMTtcbiAgaWYgbm9kZS5udW1fb25fdXBkYXRlX2hhbmRsZXJzID4gMCB0aGVuIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIG5vZGU7XG4gIG5vZGUuaGVpZ2h0IDwtIC0xO1xuICByZW1vdmVfY2hpbGRyZW4gbm9kZTtcbiAgKG1hdGNoIG5vZGUua2luZCB3aXRoXG4gICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHUgLT4gVW5vcmRlcmVkX2FycmF5X2ZvbGQuZm9yY2VfZnVsbF9jb21wdXRlIHVcbiAgIHwgRXhwZXJ0IHAgLT4gRXhwZXJ0Lm9ic2VydmFiaWxpdHlfY2hhbmdlIHAgfmlzX25vd19vYnNlcnZhYmxlOmZhbHNlXG4gICB8IF8gLT4gKCkpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAobm90IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpKTtcbiAgaWYgTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlIHRoZW4gUmVjb21wdXRlX2hlYXAucmVtb3ZlIHQucmVjb21wdXRlX2hlYXAgbm9kZVxuOztcblxubGV0IHJlbW92ZV9hbGFybSAoY2xvY2sgOiBDbG9jay50KSBhbGFybSA9XG4gIGlmIFRpbWluZ193aGVlbC5tZW0gY2xvY2sudGltaW5nX3doZWVsIGFsYXJtXG4gIHRoZW4gVGltaW5nX3doZWVsLnJlbW92ZSBjbG9jay50aW1pbmdfd2hlZWwgYWxhcm1cbjs7XG5cbigqIEFuIGludmFsaWQgbm9kZSBpcyBub2RlIHdob3NlIGtpbmQgaXMgW0ludmFsaWRdLiAgQSBub2RlJ3Mga2luZCBpcyBzZXQgdG8gW0ludmFsaWRdXG4gICB3aGVuIHRoZSBsaHMgb2YgaXRzIHNjb3BlIGNoYW5nZXMsIG9yIG9uZSBpZiBpdHMgY2hpbGRyZW4gcHJvcGFnYXRlIHRoZSBpbnZhbGlkaXR5XG4gICB1cHdhcmQgKHNlZSBbTm9kZS5zaG91bGRfYmVfaW52YWxpZGF0ZWRdIHRvIHNlZSBpbiB3aGljaCBjYXNlIGludmFsaWRpdHkgcHJvcGFnYXRpb25cbiAgIHN0b3BzKS4gIEludmFsaWRhdGluZyBhIG5vZGUgZGlzY29ubmVjdHMgaXQgZnJvbSBpdHMgY2hpbGRyZW4sIHdoaWNoIG1lYW5zOlxuXG4gICAxLiBhbiBpbnZhbGlkIG5vZGUgY2Fubm90IGVuZCB1cCBvbiB0aGUgc2NoZWR1bGVyIChpZiBpdCBpcyBvbiB0aGUgc2NoZWR1bGVyIHdoZW5cbiAgIGl0IGlzIGludmFsaWRhdGVkLCBpdCBpcyByZW1vdmVkKVxuICAgMi4gYW4gaW52YWxpZCBub2RlIGRvZXNuJ3QgbWFrZSBpdHMgY2hpbGRyZW4gbmVjZXNzYXJ5IGFueW1vcmUuXG5cbiAgIEludmFsaWQgbm9kZXMgdXN1YWxseSBoYXZlIG5vIHBhcmVudHMsIGJlY2F1c2UgdGhlIHVwd2FyZCBpbnZhbGlkaXR5IHByb3BhZ2F0aW9uIG1lYW5zXG4gICB0aGF0IHRoZWlyIHBhcmVudHMgd2lsbCB0aGVtc2VsdmVzIGJlY29tZSBpbnZhbGlkIGFuZCBkaXNjb25uZWN0IGZyb20gdGhlaXIgY2hpbGRyZW4uXG4gICBIb3dldmVyLCBbaWZdLCBbam9pbl0gb3IgW2JpbmRdIGFyZSBub3QgaW52YWxpZGF0ZWQgYnkgdGhlIHVwd2FyZCBwcm9wYWdhdGlvbiwgc28gYW5cbiAgIGludmFsaWQgbm9kZSBjYW4gc3RpbGwgaGF2ZSBwYXJlbnRzLiAgSW52YWxpZCBub2RlcyBjYW4gYmUgbmVjZXNzYXJ5LCBpbiB0aGUgY2FzZSB3aGVyZVxuICAgdGhleSBoYXZlIHBhcmVudHMsIGFuZCBhbHNvIHdoZW4gdGhleSBhcmUgb2JzZXJ2ZWQuXG5cbiAgIFRoZSB1cHdhcmQgcHJvcGFnYXRpb24gb2YgaW52YWxpZGl0eSBoYXBwZW5zIGJvdGggd2hlbiBhIG5vZGUgYmVjb21lcyBpbnZhbGlkLCBhbmQgd2hlblxuICAgdHJ5aW5nIHRvIGFkZCBhbiBlZGdlIGZyb20gYW4gaW52YWxpZCBjaGlsZCBub2RlIHRvIGFub3RoZXIgbm9kZS4gIEJlY2F1c2UgaW52YWxpZGl0eVxuICAgaXMgb25seSBwcm9wYWdhdGVkIHVwd2FyZCwgYW5kIGJlY2F1c2UgdGhlIHJocyBvZiBhIGJpbmQgaXMgaW52YWxpZGF0ZWQgYmVmb3JlIGl0XG4gICBleGVjdXRlcywgYSBub2RlIGNhbm5vdCBiZSBib3RoIGNvbXB1dGVkIGFuZCBpbnZhbGlkYXRlZCBpbiB0aGUgc2FtZSBzdGFiaWxpemF0aW9uLlxuXG4gICBXaGVuIGludmFsaWRhdGluZywgd2UgY2FuJ3QgYXNzdW1lIG11Y2ggYWJvdXQgdGhlIG5vZGVzIHdlIHZpc2l0LiAgV2UgY2Fubm90IGFzc3VtZVxuICAgdGhhdCBub2RlcyBhcmUgdmFsaWQgKHRoZSByaHMgY2FuIGNvbnRhaW4gcHJldmlvdXNseSBpbnZhbGlkYXRlZCBub2RlcyksIG9yIHRoYXQgbm9kZXNcbiAgIGFyZSB1bm5lY2Vzc2FyeSAobm9kZXMgY2FuIGJlIG1hZGUgbmVjZXNzYXJ5IHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGVpciBjb250YWluaW5nXG4gICBiaW5kcykuICopXG5cbmxldCByZWMgaW52YWxpZGF0ZV9ub2RlIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIG5vZGUgLT5cbiAgaWYgTm9kZS5pc192YWxpZCBub2RlXG4gIHRoZW4gKFxuICAgIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICAgIGlmIG5vZGUubnVtX29uX3VwZGF0ZV9oYW5kbGVycyA+IDAgdGhlbiBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBub2RlO1xuICAgIG5vZGUudmFsdWVfb3B0IDwtIFVvcHQubm9uZTtcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIG5vZGUub2xkX3ZhbHVlX29wdCk7XG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgbm9kZS5yZWNvbXB1dGVkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgdC5udW1fbm9kZXNfaW52YWxpZGF0ZWQgPC0gdC5udW1fbm9kZXNfaW52YWxpZGF0ZWQgKyAxO1xuICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZV9jaGlsZHJlbiBub2RlO1xuICAgICAgKCogVGhlIG5vZGUgZG9lc24ndCBoYXZlIGNoaWxkcmVuIGFueW1vcmUsIHNvIHdlIGNhbiBsb3dlciBpdHMgaGVpZ2h0IGFzIG11Y2ggYXNcbiAgICAgICAgIHBvc3NpYmxlLCB0byBvbmUgZ3JlYXRlciB0aGFuIHRoZSBzY29wZSBpdCB3YXMgY3JlYXRlZCBpbi4gIEFsc28sIGJlY2F1c2Ugd2VcbiAgICAgICAgIGFyZSBsb3dlcmluZyB0aGUgaGVpZ2h0LCB3ZSBkb24ndCBuZWVkIHRvIGFkanVzdCBhbnkgb2YgaXRzIGFuY2VzdG9ycycgaGVpZ2h0cy5cbiAgICAgICAgIFdlIGNvdWxkIGxlYXZlIHRoZSBoZWlnaHQgYWxvbmUsIGJ1dCB3ZSBtYXkgYXMgd2VsbCBsb3dlciBpdCBhcyBtdWNoIGFzXG4gICAgICAgICBwb3NzaWJsZSB0byBhdm9pZCBtYWtpbmcgdGhlIGhlaWdodHMgb2YgYW55IGZ1dHVyZSBhbmNlc3RvcnMgdW5uZWNlc3NhcmlseVxuICAgICAgICAgbGFyZ2UuICopXG4gICAgICBub2RlLmhlaWdodCA8LSBTY29wZS5oZWlnaHQgbm9kZS5jcmVhdGVkX2luICsgMSk7XG4gICAgKCogV2UgZG9uJ3Qgc2V0IFtub2RlLmNyZWF0ZWRfaW5dIG9yIFtub2RlLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXTsgd2UgbGVhdmUgW25vZGVdXG4gICAgICAgaW4gdGhlIHNjb3BlIGl0IHdhcyBjcmVhdGVkIGluLiAgSWYgdGhhdCBzY29wZSBpcyBldmVyIGludmFsaWRhdGVkLCB0aGVuIHRoYXRcbiAgICAgICB3aWxsIGNsZWFyIFtub2RlLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXSAqKVxuICAgIChtYXRjaCBub2RlLmtpbmQgd2l0aFxuICAgICB8IEF0IGF0IC0+IHJlbW92ZV9hbGFybSBhdC5jbG9jayBhdC5hbGFybVxuICAgICB8IEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMgLT4gcmVtb3ZlX2FsYXJtIGF0X2ludGVydmFscy5jbG9jayBhdF9pbnRlcnZhbHMuYWxhcm1cbiAgICAgfCBCaW5kX21haW4gYmluZCAtPiBpbnZhbGlkYXRlX25vZGVzX2NyZWF0ZWRfb25fcmhzIGJpbmQuYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzXG4gICAgIHwgU3RlcF9mdW5jdGlvbiB7IGFsYXJtOyBjbG9jazsgXyB9IC0+IHJlbW92ZV9hbGFybSBjbG9jayBhbGFybVxuICAgICB8IF8gLT4gKCkpO1xuICAgIE5vZGUuc2V0X2tpbmQgbm9kZSBJbnZhbGlkO1xuICAgICgqIElmIHdlIGNhbGxlZCBbcHJvcGFnYXRlX2ludmFsaWRpdHldIHJpZ2h0IGF3YXkgb24gdGhlIHBhcmVudHMsIHdlIHdvdWxkIGdldCBpbnRvXG4gICAgICAgdHJvdWJsZS4gIFRoZSBwYXJlbnQgd291bGQgZGlzY29ubmVjdCBpdHNlbGYgZnJvbSB0aGUgY3VycmVudCBub2RlLCB0aHVzXG4gICAgICAgbW9kaWZ5aW5nIHRoZSBsaXN0IG9mIHBhcmVudHMgd2UgaXRlcmF0ZSBvbi4gIEV2ZW4gaWYgd2UgbWFkZSBhIHNwZWNpYWwgY2FzZSwgaXRcbiAgICAgICBzdGlsbCB3b3VsZG4ndCBiZSBlbm91Z2ggdG8gaGFuZGxlIG90aGVyIGNhc2VzIHdoZXJlIHRoZSBsaXN0IG9mIHBhcmVudHMgaXNcbiAgICAgICBtb2RpZmllZCAoZS5nLiB3aGVuIFtsaHNdIGlzIGludmFsaWRhdGVkIGluIHRoZSBleGFtcGxlIGluIHRoZSBjb21tZW50IGFib3V0XG4gICAgICAgW2Nhbl9yZWNvbXB1dGVfbm93XSBmYXIgYmVsb3cpLiAqKVxuICAgIGZvciBpbmRleCA9IDAgdG8gbm9kZS5udW1fcGFyZW50cyAtIDEgZG9cbiAgICAgIFN0YWNrLnB1c2ggdC5wcm9wYWdhdGVfaW52YWxpZGl0eSAoTm9kZS5nZXRfcGFyZW50IG5vZGUgfmluZGV4KVxuICAgIGRvbmU7XG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKG5vdCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlKSk7XG4gICAgaWYgTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlIHRoZW4gUmVjb21wdXRlX2hlYXAucmVtb3ZlIHQucmVjb21wdXRlX2hlYXAgbm9kZSlcblxuYW5kIGludmFsaWRhdGVfbm9kZXNfY3JlYXRlZF9vbl9yaHMgbm9kZSA9XG4gIGxldCByID0gcmVmIG5vZGUgaW5cbiAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgbGV0IChUIG5vZGVfb25fcmhzKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgciA6PSBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZTtcbiAgICBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZSA8LSBVb3B0Lm5vbmU7XG4gICAgaW52YWxpZGF0ZV9ub2RlIG5vZGVfb25fcmhzXG4gIGRvbmVcbjs7XG5cbigqIFdoZW4gW25vdCB0LmJpbmRfbGhzX2NoYW5nZV9zaG91bGRfaW52YWxpZGF0ZV9yaHNdIGFuZCBhIGJpbmQncyBsaHMgY2hhbmdlcywgd2UgbW92ZVxuICAgbm9kZXMgY3JlYXRlZCBvbiB0aGUgYmluZCdzIHJocyB1cCB0byBpdHMgcGFyZW50IGJpbmQsIGFzIG9wcG9zZWQgdG8gW1Njb3BlLlRvcF0uICBUaGlzXG4gICBtYWludGFpbnMgdGhlaXIgZGVwZW5kZW5jZSBvbiB2YWxpZCBiaW5kIGxlZnQtaGFuZCBzaWRlcywgYW5kIGtlZXBzIHRoZW0gaGlnaGVyIGluIHRoZVxuICAgZ3JhcGguICBUaGlzIGluIHR1cm4gbWVhbnMgdGhhdCB3ZSB3aWxsIGNvbnRpbnVlIHRvIGNvbXB1dGUgdGhvc2Ugbm9kZXMgYWZ0ZXIgdGhlXG4gICBwYXJlbnQgYmluZCdzIGxocywgd2hpY2ggZ2l2ZXMgdGhlbSBtb3JlIG9mIGEgY2hhbmNlIHRvIGJlY29tZSB1bm5lY2Vzc2FyeSBhbmQgbm90IGJlXG4gICBjb21wdXRlZCBzaG91bGQgdGhlIHBhcmVudCBiaW5kJ3MgbGhzIGNoYW5nZS4gKilcbmxldCByZXNjb3BlX25vZGVzX2NyZWF0ZWRfb25fcmhzIF90IChmaXJzdF9ub2RlX29uX3JocyA6IE5vZGUuUGFja2VkLnQgVW9wdC50KSB+bmV3X3Njb3BlID1cbiAgbGV0IHIgPSByZWYgZmlyc3Rfbm9kZV9vbl9yaHMgaW5cbiAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgbGV0IChUIG5vZGVfb25fcmhzKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgciA6PSBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZTtcbiAgICBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZSA8LSBVb3B0Lm5vbmU7XG4gICAgbm9kZV9vbl9yaHMuY3JlYXRlZF9pbiA8LSBuZXdfc2NvcGU7XG4gICAgU2NvcGUuYWRkX25vZGUgbmV3X3Njb3BlIG5vZGVfb25fcmhzXG4gIGRvbmVcbjs7XG5cbmxldCBwcm9wYWdhdGVfaW52YWxpZGl0eSB0ID1cbiAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSB0LnByb3BhZ2F0ZV9pbnZhbGlkaXR5KSBkb1xuICAgIGxldCAoVCBub2RlKSA9IFN0YWNrLnBvcF9leG4gdC5wcm9wYWdhdGVfaW52YWxpZGl0eSBpblxuICAgIGlmIE5vZGUuaXNfdmFsaWQgbm9kZVxuICAgIHRoZW5cbiAgICAgIGlmIE5vZGUuc2hvdWxkX2JlX2ludmFsaWRhdGVkIG5vZGVcbiAgICAgIHRoZW4gaW52YWxpZGF0ZV9ub2RlIG5vZGVcbiAgICAgIGVsc2UgKFxuICAgICAgICAoKiBbTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlXSBpcyB0cnVlIGJlY2F1c2VcbiAgICAgICAgICAgLSBub2RlIGlzIG5lY2Vzc2FyeS4gVGhpcyBpcyBiZWNhdXNlIGNoaWxkcmVuIGNhbiBvbmx5IHBvaW50IHRvIG5lY2Vzc2FyeVxuICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgLSBub2RlIGlzIHN0YWxlLiBUaGlzIGlzIGJlY2F1c2U6IEZvciBiaW5kLCBpZiwgam9pbiwgdGhpcyBpcyB0cnVlIGJlY2F1c2VcbiAgICAgICAgICAgLSBlaXRoZXIgdGhlIGludmFsaWRhdGlvbiBpcyBjYXVzZWQgYnkgdGhlIGxocyBjaGFuZ2luZyAoaW4gd2hpY2ggY2FzZSB0aGVcbiAgICAgICAgICAgICBsaHMtY2hhbmdlIG5vZGUgYmVpbmcgbmV3ZXIgbWFrZXMgdXMgc3RhbGUpLlxuICAgICAgICAgICAtIG9yIGEgY2hpbGQgYmVjYW1lIGludmFsaWQgdGhpcyBzdGFiaWxpemF0aW9uIGN5Y2xlLCBpbiB3aGljaCBjYXNlIGl0IGhhc1xuICAgICAgICAgICAgIHQuY2hhbmdlZF9hdCBvZiBbdC5zdGFiaWxpemF0aW9uX251bV0sIGFuZCBzbyBbbm9kZV0gaXMgc3RhbGVcbiAgICAgICAgICAgLSBvciBbbm9kZV0ganVzdCBiZWNhbWUgbmVjZXNzYXJ5IGFuZCB0cmllZCBjb25uZWN0aW5nIHRvIGFuIGFscmVhZHkgaW52YWxpZFxuICAgICAgICAgICAgIGNoaWxkLiBJbiB0aGF0IGNhc2UsIFtjaGlsZC5jaGFuZ2VkX2F0ID4gbm9kZS5yZWNvbXB1dGVkX2F0XSBmb3IgdGhhdCBjaGlsZCxcbiAgICAgICAgICAgICBiZWNhdXNlIGlmIHdlIGhhZCBiZWVuIHJlY29tcHV0ZWQgd2hlbiB0aGF0IGNoaWxkIGNoYW5nZWQsIHdlIHdvdWxkIGhhdmUgYmVlblxuICAgICAgICAgICAgIG1hZGUgaW52YWxpZCBiYWNrIHRoZW4uICBGb3IgZXhwZXJ0IG5vZGVzLCB0aGUgYXJndW1lbnQgaXMgdGhlIHNhbWUsIGV4Y2VwdFxuICAgICAgICAgICAgIHRoYXQgaW5zdGVhZCBvZiBsaHMtY2hhbmdlIG5vZGVzIG1ha2UgdGhlIGV4cGVydCBub2RlcyBzdGFsZSwgaXQncyBtYWRlIHN0YWxlXG4gICAgICAgICAgICAgZXhwbGljaXRlbHkgd2hlbiBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4uICopXG4gICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpO1xuICAgICAgICAobWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgICAgICAgIHwgRXhwZXJ0IGV4cGVydCAtPlxuICAgICAgICAgICAoKiBJZiBtdWx0aXBsZSBjaGlsZHJlbiBhcmUgaW52YWxpZCwgdGhleSB3aWxsIHB1c2ggdXMgYXMgbWFueSB0aW1lcyBvbiB0aGVcbiAgICAgICAgICAgICAgcHJvcGFnYXRpb24gc3RhY2ssIHNvIHdlIGNvdW50IHRoZW0gcmlnaHQuICopXG4gICAgICAgICAgIEV4cGVydC5pbmNyX2ludmFsaWRfY2hpbGRyZW4gZXhwZXJ0XG4gICAgICAgICB8IGtpbmQgLT5cbiAgICAgICAgICAgaWYgZGVidWdcbiAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICAgICAgICAgfCBCaW5kX21haW4gXyB8IElmX3RoZW5fZWxzZSBfIHwgSm9pbl9tYWluIF8gLT4gKClcbiAgICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlICgqIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gYXJlIG5ldmVyIHB1c2hlZCBvbiB0aGUgc3RhY2sgKikpKTtcbiAgICAgICAgKCogV2UgZG8gbm90IGNoZWNrIFtOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGVdIGhlcmUsIGJlY2F1c2UgaXQgc2hvdWxkIGJlXG4gICAgICAgICAgIHRydWUsIGFuZCBiZWNhdXNlIGNvbXB1dGluZyBpdCB0YWtlcyBPKG51bWJlciBvZiBjaGlsZHJlbiksIG5vZGUgY2FuIGJlIHB1c2hlZFxuICAgICAgICAgICBvbiB0aGUgc3RhY2sgb25jZSBwZXIgY2hpbGQsIGFuZCBleHBlcnQgbm9kZXMgY2FuIGhhdmUgbG90cyBvZiBjaGlsZHJlbi4gKilcbiAgICAgICAgaWYgbm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGUpXG4gICAgICAgIHRoZW4gUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgZG9uZVxuOztcblxuKCogW2FkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaGVpZ2h0cyB0IH5jaGlsZCB+cGFyZW50XSBhZGRzIFtwYXJlbnRdIGFzIGEgcGFyZW50IG9mXG4gICBbY2hpbGRdLCBhbmQgbWFrZXMgW2NoaWxkXSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBuZWNlc3NhcnksIGVuc3VyaW5nIHRoZWlyIGhlaWdodHNcbiAgIGFyZSBhY2N1cmF0ZS4gIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSBhYm91dCB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiBbY2hpbGRdIGFuZCBbcGFyZW50XVxuICAgdGhvdWdoLiAqKVxubGV0IHJlYyBhZGRfcGFyZW50X3dpdGhvdXRfYWRqdXN0aW5nX2hlaWdodHNcbiAgOiB0eXBlIGEgYi4gY2hpbGQ6YSBOb2RlLnQgLT4gcGFyZW50OmIgTm9kZS50IC0+IGNoaWxkX2luZGV4OmludCAtPiB1bml0XG4gID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCAtPlxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19uZWNlc3NhcnkgcGFyZW50KTtcbiAgbGV0IHQgPSBjaGlsZC5zdGF0ZSBpblxuICBsZXQgd2FzX25lY2Vzc2FyeSA9IE5vZGUuaXNfbmVjZXNzYXJ5IGNoaWxkIGluXG4gIE5vZGUuYWRkX3BhcmVudCB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXg7XG4gIGlmIG5vdCAoTm9kZS5pc192YWxpZCBjaGlsZCkgdGhlbiBTdGFjay5wdXNoIHQucHJvcGFnYXRlX2ludmFsaWRpdHkgKFQgcGFyZW50KTtcbiAgaWYgbm90IHdhc19uZWNlc3NhcnkgdGhlbiBiZWNhbWVfbmVjZXNzYXJ5IGNoaWxkO1xuICBtYXRjaCBwYXJlbnQua2luZCB3aXRoXG4gIHwgRXhwZXJ0IGUgLT4gRXhwZXJ0LnJ1bl9lZGdlX2NhbGxiYWNrIGUgfmNoaWxkX2luZGV4XG4gIHwgXyAtPiAoKVxuXG5hbmQgYmVjYW1lX25lY2Vzc2FyeSA6IHR5cGUgYS4gYSBOb2RlLnQgLT4gdW5pdCA9XG4gIGZ1biBub2RlIC0+XG4gICgqIFtTY29wZS5pc19uZWNlc3Nhcnkgbm9kZS5jcmVhdGVkX2luXSBpcyB0cnVlIChhc3N1bWluZyB0aGUgc2NvcGUgaXRzZWxmIGlzIHZhbGlkKVxuICAgICBiZWNhdXNlIFtOb2RlLml0ZXJfY2hpbGRyZW5dIGJlbG93IGZpcnN0IHZpc2l0cyB0aGUgbGhzLWNoYW5nZSBvZiBiaW5kIG5vZGVzIGFuZFxuICAgICB0aGVuIHRoZSByaHMuICopXG4gIGlmIE5vZGUuaXNfdmFsaWQgbm9kZSAmJiBub3QgKFNjb3BlLmlzX25lY2Vzc2FyeSBub2RlLmNyZWF0ZWRfaW4pXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiVHJ5aW5nIHRvIG1ha2UgYSBub2RlIG5lY2Vzc2FyeSB3aG9zZSBkZWZpbmluZyBiaW5kIGlzIG5vdCBuZWNlc3NhcnlcIlxuICAgICAgbm9kZVxuICAgICAgWyVzZXhwX29mOiBfIE5vZGUudF07XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICB0Lm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5IDwtIHQubnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkgKyAxO1xuICBpZiBub2RlLm51bV9vbl91cGRhdGVfaGFuZGxlcnMgPiAwIHRoZW4gaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gbm9kZTtcbiAgKCogU2luY2UgW25vZGVdIGJlY2FtZSBuZWNlc3NhcnksIHRvIHJlc3RvcmUgdGhlIGludmFyaWFudCwgd2UgbmVlZCB0bzpcblxuICAgICAtIGFkZCBwYXJlbnQgcG9pbnRlcnMgdG8gW25vZGVdIGZyb20gaXRzIGNoaWxkcmVuLlxuICAgICAtIHNldCBbbm9kZV0ncyBoZWlnaHQuXG4gICAgIC0gYWRkIFtub2RlXSB0byB0aGUgcmVjb21wdXRlIGhlYXAsIGlmIG5lY2Vzc2FyeS4gKilcbiAgc2V0X2hlaWdodCBub2RlIChTY29wZS5oZWlnaHQgbm9kZS5jcmVhdGVkX2luICsgMSk7XG4gIE5vZGUuaXRlcmlfY2hpbGRyZW4gbm9kZSB+ZjooZnVuIGNoaWxkX2luZGV4IChUIGNoaWxkKSAtPlxuICAgIGFkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaGVpZ2h0cyB+Y2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDtcbiAgICAoKiBOb3cgdGhhdCBjaGlsZCBpcyBuZWNlc3NhcnksIGl0IHNob3VsZCBoYXZlIGEgdmFsaWQgaGVpZ2h0LiAqKVxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChjaGlsZC5oZWlnaHQgPj0gMCk7XG4gICAgaWYgY2hpbGQuaGVpZ2h0ID49IG5vZGUuaGVpZ2h0IHRoZW4gc2V0X2hlaWdodCBub2RlIChjaGlsZC5oZWlnaHQgKyAxKSk7XG4gICgqIE5vdyB0aGF0IHRoZSBoZWlnaHQgaXMgY29ycmVjdCwgbWF5YmUgYWRkIFtub2RlXSB0byB0aGUgcmVjb21wdXRlIGhlYXAuICBbbm9kZV1cbiAgICAganVzdCBiZWNhbWUgbmVjZXNzYXJ5LCBzbyBpdCBjYW4ndCBoYXZlIGJlZW4gaW4gdGhlIHJlY29tcHV0ZSBoZWFwLiAgU2luY2UgW25vZGVdXG4gICAgIGlzIG5lY2Vzc2FyeSwgd2Ugc2hvdWxkIGFkZCBpdCB0byB0aGUgcmVjb21wdXRlIGhlYXAgaWZmIGl0IGlzIHN0YWxlLiAqKVxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAobm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGUpKTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGUpO1xuICBpZiBOb2RlLmlzX3N0YWxlIG5vZGUgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgdC5yZWNvbXB1dGVfaGVhcCBub2RlO1xuICBtYXRjaCBub2RlLmtpbmQgd2l0aFxuICB8IEV4cGVydCBwIC0+IEV4cGVydC5vYnNlcnZhYmlsaXR5X2NoYW5nZSBwIH5pc19ub3dfb2JzZXJ2YWJsZTp0cnVlXG4gIHwgXyAtPiAoKVxuOztcblxubGV0IGJlY2FtZV9uZWNlc3Nhcnkgbm9kZSA9XG4gIGJlY2FtZV9uZWNlc3Nhcnkgbm9kZTtcbiAgcHJvcGFnYXRlX2ludmFsaWRpdHkgbm9kZS5zdGF0ZVxuOztcblxubGV0IGFkZF9wYXJlbnQgfmNoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4ID1cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUuaXNfbmVjZXNzYXJ5IHBhcmVudCk7XG4gIGxldCB0ID0gcGFyZW50LnN0YXRlIGluXG4gICgqIEluIHRoZSBjYXNlIHdoZW4gdGhlIGVkZ2UgYmVpbmcgYWRkZWQgY3JlYXRlcyBhIGN5Y2xlLCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlXG4gICAgIHJlY3Vyc2lvbiBpbiBbYWRkX3BhcmVudF93aXRob3V0X2FkanVzdGluZ19oZWlnaHRzXSB0byByZWFjaCBbcGFyZW50XSBhcyBhIGRlc2NlbmRhbnRcbiAgICAgb2YgW2NoaWxkXS4gIEluIHRoYXQgY2FzZSwgdGhlIHJlY3Vyc2lvbiB0ZXJtaW5hdGVzLCBiZWNhdXNlIFtOb2RlLmlzX25lY2Vzc2FyeVxuICAgICBwYXJlbnRdLiAgV2UgdGhlbiByZXR1cm4gaGVyZSBhbmQgc3Vic2VxdWVudGx5IGRldGVjdCB0aGUgY3ljbGUgaW5cbiAgICAgW2FkanVzdF9oZWlnaHRzXS4gKilcbiAgYWRkX3BhcmVudF93aXRob3V0X2FkanVzdGluZ19oZWlnaHRzIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleDtcbiAgKCogV2UgYWRqdXN0IGhlaWdodHMgc28gdGhhdCB3ZSBlbnN1cmUgdGhlcmUgYXJlIG5vIGN5Y2xlcyBiZWZvcmUgY2FsbGluZ1xuICAgICBbcHJvcGFnYXRlX2ludmFsaWRpdHldLiAqKVxuICBpZiBjaGlsZC5oZWlnaHQgPj0gcGFyZW50LmhlaWdodFxuICB0aGVuXG4gICAgQWRqdXN0X2hlaWdodHNfaGVhcC5hZGp1c3RfaGVpZ2h0c1xuICAgICAgdC5hZGp1c3RfaGVpZ2h0c19oZWFwXG4gICAgICB0LnJlY29tcHV0ZV9oZWFwXG4gICAgICB+Y2hpbGRcbiAgICAgIH5wYXJlbnQ7XG4gIHByb3BhZ2F0ZV9pbnZhbGlkaXR5IHQ7XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBwYXJlbnQpO1xuICAoKiB3ZSBvbmx5IGFkZCBuZWNlc3NhcnkgcGFyZW50cyAqKVxuICBpZiAobm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIHBhcmVudCkpXG4gICYmIChTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHBhcmVudC5yZWNvbXB1dGVkX2F0XG4gICAgICB8fCBOb2RlLmVkZ2VfaXNfc3RhbGUgfmNoaWxkIH5wYXJlbnQpXG4gIHRoZW4gUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgcGFyZW50XG47O1xuXG5sZXQgcnVuX3dpdGhfc2NvcGUgdCBzY29wZSB+ZiA9XG4gIGxldCBzYXZlZCA9IHQuY3VycmVudF9zY29wZSBpblxuICB0LmN1cnJlbnRfc2NvcGUgPC0gc2NvcGU7XG4gIHRyeVxuICAgIGxldCB2ID0gZiAoKSBpblxuICAgIHQuY3VycmVudF9zY29wZSA8LSBzYXZlZDtcbiAgICB2XG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICB0LmN1cnJlbnRfc2NvcGUgPC0gc2F2ZWQ7XG4gICAgcmFpc2UgZXhuXG47O1xuXG5sZXQgd2l0aGluX3Njb3BlIHQgc2NvcGUgfmYgPVxuICBpZiBub3QgKFNjb3BlLmlzX3ZhbGlkIHNjb3BlKVxuICB0aGVuIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiYXR0ZW1wdCB0byBydW4gd2l0aGluIGFuIGludmFsaWQgc2NvcGVcIiB0IFslc2V4cF9vZjogdF07XG4gIHJ1bl93aXRoX3Njb3BlIHQgc2NvcGUgfmZcbjs7XG5cbmxldCBjaGFuZ2VfY2hpbGRcbiAgOiB0eXBlIGEgYi5cbiAgICBwYXJlbnQ6YSBOb2RlLnRcbiAgICAtPiBvbGRfY2hpbGQ6YiBOb2RlLnQgVW9wdC50XG4gICAgLT4gbmV3X2NoaWxkOmIgTm9kZS50XG4gICAgLT4gY2hpbGRfaW5kZXg6aW50XG4gICAgLT4gdW5pdFxuICA9XG4gIGZ1biB+cGFyZW50IH5vbGRfY2hpbGQgfm5ld19jaGlsZCB+Y2hpbGRfaW5kZXggLT5cbiAgaWYgVW9wdC5pc19ub25lIG9sZF9jaGlsZFxuICB0aGVuIGFkZF9wYXJlbnQgfmNoaWxkOm5ld19jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleFxuICBlbHNlIChcbiAgICBsZXQgb2xkX2NoaWxkID0gVW9wdC51bnNhZmVfdmFsdWUgb2xkX2NoaWxkIGluXG4gICAgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9jaGlsZCBuZXdfY2hpbGQpXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSByZW1vdmUgW29sZF9jaGlsZF0gYmVmb3JlIGFkZGluZyBbbmV3X2NoaWxkXSwgYmVjYXVzZSB0aGV5IHNoYXJlIHRoZSBzYW1lXG4gICAgICAgICBjaGlsZCBpbmRleC4gKilcbiAgICAgIE5vZGUucmVtb3ZlX3BhcmVudCB+Y2hpbGQ6b2xkX2NoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4O1xuICAgICAgKCogV2UgZm9yY2UgW29sZF9jaGlsZF0gdG8gdGVtcG9yYXJpbHkgYmUgbmVjZXNzYXJ5IHNvIHRoYXQgW2FkZF9wYXJlbnRdIGNhbid0XG4gICAgICAgICBtaXN0YWtlbmx5IHRoaW5rIGl0IGlzIHVubmVjZXNzYXJ5IGFuZCB0cmFuc2l0aW9uIGl0IHRvIG5lY2Vzc2FyeSAod2hpY2ggd291bGRcbiAgICAgICAgIGFkZCBkdXBsaWNhdGUgZWRnZXMgYW5kIGJyZWFrIHRoaW5ncyBob3JyaWJseSkuICopXG4gICAgICBvbGRfY2hpbGQuZm9yY2VfbmVjZXNzYXJ5IDwtIHRydWU7XG4gICAgICBhZGRfcGFyZW50IH5jaGlsZDpuZXdfY2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXg7XG4gICAgICBvbGRfY2hpbGQuZm9yY2VfbmVjZXNzYXJ5IDwtIGZhbHNlO1xuICAgICAgKCogV2UgW2NoZWNrX2lmX3VubmVjZXNzYXJ5XSBhZnRlciBbYWRkX3BhcmVudF0sIHNvIHRoYXQgd2UgZG9uJ3QgdW5uZWNlc3NhcmlseVxuICAgICAgICAgdHJhbnNpdGlvbiBub2RlcyBmcm9tIG5lY2Vzc2FyeSB0byB1bm5lY2Vzc2FyeSBhbmQgdGhlbiBiYWNrIGFnYWluLiAqKVxuICAgICAgY2hlY2tfaWZfdW5uZWNlc3Nhcnkgb2xkX2NoaWxkKSlcbjs7XG5cbmxldCBhZGRfYWxhcm0gY2xvY2sgfmF0IGFsYXJtX3ZhbHVlID1cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKFRpbWVfbnMuKCA+ICkgYXQgKG5vdyBjbG9jaykpO1xuICBUaW1pbmdfd2hlZWwuYWRkIGNsb2NrLnRpbWluZ193aGVlbCB+YXQgYWxhcm1fdmFsdWVcbjs7XG5cbmxldCByZWMgcmVjb21wdXRlIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIG5vZGUgLT5cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIGlmIGRlYnVnXG4gIHRoZW4gKFxuICAgIHQub25seV9pbl9kZWJ1Zy5jdXJyZW50bHlfcnVubmluZ19ub2RlIDwtIFNvbWUgKFQgbm9kZSk7XG4gICAgdC5vbmx5X2luX2RlYnVnLmV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZSA8LSBbXSk7XG4gIHQubnVtX25vZGVzX3JlY29tcHV0ZWQgPC0gdC5udW1fbm9kZXNfcmVjb21wdXRlZCArIDE7XG4gIG5vZGUucmVjb21wdXRlZF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICBtYXRjaCBub2RlLmtpbmQgd2l0aFxuICB8IEFycmF5X2ZvbGQgYXJyYXlfZm9sZCAtPiBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoQXJyYXlfZm9sZC5jb21wdXRlIGFycmF5X2ZvbGQpXG4gIHwgQXQgeyBhdDsgY2xvY2s7IF8gfSAtPlxuICAgICgqIEl0IGlzIGEgYnVnIGlmIHdlIHRyeSB0byBjb21wdXRlIGFuIFtBdF0gbm9kZSBhZnRlciBbYXRdLiAgW2FkdmFuY2VfY2xvY2tdIHdhc1xuICAgICAgIHN1cHBvc2VkIHRvIGNvbnZlcnQgaXQgdG8gYSBbQ29uc3RdIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lLiAqKVxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChUaW1lX25zLiggPiApIGF0IChub3cgY2xvY2spKTtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSBCZWZvcmVcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoKVxuICB8IEJpbmRfbGhzX2NoYW5nZVxuICAgICAgKHsgbWFpblxuICAgICAgIDsgZlxuICAgICAgIDsgbGhzXG4gICAgICAgOyByaHNfc2NvcGVcbiAgICAgICA7IHJocyA9IG9sZF9yaHNcbiAgICAgICA7IGFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyA9IG9sZF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHNcbiAgICAgICA7IF9cbiAgICAgICB9IGFzIGJpbmQpIC0+XG4gICAgKCogV2UgY2xlYXIgW2FsbF9ub2Rlc19jcmVhdGVkX29uX3Joc10gc28gaXQgd2lsbCBob2xkIGp1c3QgdGhlIG5vZGVzIGNyZWF0ZWQgYnlcbiAgICAgICB0aGlzIGNhbGwgdG8gW2ZdLiAqKVxuICAgIGJpbmQuYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzIDwtIFVvcHQubm9uZTtcbiAgICBsZXQgcmhzID0gcnVuX3dpdGhfc2NvcGUgdCByaHNfc2NvcGUgfmY6KGZ1biAoKSAtPiBmIChOb2RlLnZhbHVlX2V4biBsaHMpKSBpblxuICAgIGJpbmQucmhzIDwtIFVvcHQuc29tZSByaHM7XG4gICAgKCogQW50aWNpcGF0ZSB3aGF0IFttYXliZV9jaGFuZ2VfdmFsdWVdIHdpbGwgZG8sIHRvIG1ha2Ugc3VyZSBCaW5kX21haW4gaXMgc3RhbGVcbiAgICAgICByaWdodCBhd2F5LiBUaGlzIHdheSwgaWYgdGhlIG5ldyBjaGlsZCBpcyBpbnZhbGlkLCB3ZSdsbCBzYXRpc2Z5IHRoZSBpbnZhcmlhbnRcbiAgICAgICBzYXlpbmcgdGhhdCBbbmVlZHNfdG9fYmVfY29tcHV0ZWQgYmluZF9tYWluXSBpbiBbcHJvcGFnYXRlX2ludmFsaWRpdHldICopXG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgY2hhbmdlX2NoaWxkXG4gICAgICB+cGFyZW50Om1haW5cbiAgICAgIH5vbGRfY2hpbGQ6b2xkX3Joc1xuICAgICAgfm5ld19jaGlsZDpyaHNcbiAgICAgIH5jaGlsZF9pbmRleDpLaW5kLmJpbmRfcmhzX2NoaWxkX2luZGV4O1xuICAgIGlmIFVvcHQuaXNfc29tZSBvbGRfcmhzXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBpbnZhbGlkYXRlIGFmdGVyIFtjaGFuZ2VfY2hpbGRdLCBiZWNhdXNlIGludmFsaWRhdGlvbiBjaGFuZ2VzIHRoZSBba2luZF0gb2ZcbiAgICAgICAgIG5vZGVzIHRvIFtJbnZhbGlkXSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBjYW4gbm8gbG9uZ2VyIHZpc2l0IHRoZWlyIGNoaWxkcmVuLlxuICAgICAgICAgQWxzbywgdGhlIFtvbGRfcmhzXSBub2RlcyBhcmUgdHlwaWNhbGx5IG1hZGUgdW5uZWNlc3NhcnkgYnkgW2NoYW5nZV9jaGlsZF0sIGFuZFxuICAgICAgICAgc28gYnkgaW52YWxpZGF0aW5nIGFmdGVyd2FyZHMsIHdlIHdpbGwgbm90IHdhc3RlIHRpbWUgYWRkaW5nIHRoZW0gdG8gdGhlXG4gICAgICAgICByZWNvbXB1dGUgaGVhcCBhbmQgdGhlbiByZW1vdmluZyB0aGVtLiAqKVxuICAgICAgaWYgdC5iaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWRhdGVfcmhzXG4gICAgICB0aGVuIGludmFsaWRhdGVfbm9kZXNfY3JlYXRlZF9vbl9yaHMgb2xkX2FsbF9ub2Rlc19jcmVhdGVkX29uX3Joc1xuICAgICAgZWxzZVxuICAgICAgICByZXNjb3BlX25vZGVzX2NyZWF0ZWRfb25fcmhzXG4gICAgICAgICAgdFxuICAgICAgICAgIG9sZF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHNcbiAgICAgICAgICB+bmV3X3Njb3BlOm1haW4uY3JlYXRlZF9pbjtcbiAgICAgIHByb3BhZ2F0ZV9pbnZhbGlkaXR5IHQpO1xuICAgICgqIFtub2RlXSB3YXMgdmFsaWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBbQmluZF9saHNfY2hhbmdlXSBicmFuY2gsIGFuZCBpbnZhbGlkYXRpb25cbiAgICAgICBvbmx5IHZpc2l0cyBoaWdoZXIgbm9kZXMsIHNvIFtub2RlXSBpcyBzdGlsbCB2YWxpZC4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc192YWxpZCBub2RlKTtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoKVxuICB8IEJpbmRfbWFpbiB7IHJoczsgXyB9IC0+IGNvcHlfY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZDooVW9wdC52YWx1ZV9leG4gcmhzKVxuICB8IENvbnN0IGEgLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgYVxuICB8IEZyZWV6ZSB7IGNoaWxkOyBvbmx5X2ZyZWV6ZV93aGVuOyBfIH0gLT5cbiAgICBsZXQgdmFsdWUgPSBOb2RlLnZhbHVlX2V4biBjaGlsZCBpblxuICAgIGlmIG9ubHlfZnJlZXplX3doZW4gdmFsdWVcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZV9jaGlsZHJlbiBub2RlO1xuICAgICAgTm9kZS5zZXRfa2luZCBub2RlIChDb25zdCB2YWx1ZSk7XG4gICAgICBpZiBOb2RlLmlzX25lY2Vzc2FyeSBub2RlIHRoZW4gc2V0X2hlaWdodCBub2RlIDAgZWxzZSBiZWNhbWVfdW5uZWNlc3Nhcnkgbm9kZSk7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgdmFsdWVcbiAgfCBJZl90ZXN0X2NoYW5nZSAoeyBtYWluOyBjdXJyZW50X2JyYW5jaDsgdGVzdDsgdGhlbl87IGVsc2VfOyBfIH0gYXMgaWZfdGhlbl9lbHNlKSAtPlxuICAgIGxldCBkZXNpcmVkX2JyYW5jaCA9IGlmIE5vZGUudmFsdWVfZXhuIHRlc3QgdGhlbiB0aGVuXyBlbHNlIGVsc2VfIGluXG4gICAgaWZfdGhlbl9lbHNlLmN1cnJlbnRfYnJhbmNoIDwtIFVvcHQuc29tZSBkZXNpcmVkX2JyYW5jaDtcbiAgICAoKiBzZWUgdGhlIGNvbW1lbnQgaW4gQmluZF9saHNfY2hhbmdlICopXG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgY2hhbmdlX2NoaWxkXG4gICAgICB+cGFyZW50Om1haW5cbiAgICAgIH5vbGRfY2hpbGQ6Y3VycmVudF9icmFuY2hcbiAgICAgIH5uZXdfY2hpbGQ6ZGVzaXJlZF9icmFuY2hcbiAgICAgIH5jaGlsZF9pbmRleDpLaW5kLmlmX2JyYW5jaF9jaGlsZF9pbmRleDtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoKVxuICB8IElmX3RoZW5fZWxzZSB7IGN1cnJlbnRfYnJhbmNoOyBfIH0gLT5cbiAgICBjb3B5X2NoaWxkIH5wYXJlbnQ6bm9kZSB+Y2hpbGQ6KFVvcHQudmFsdWVfZXhuIGN1cnJlbnRfYnJhbmNoKVxuICB8IEludmFsaWQgLT5cbiAgICAoKiBXZSBuZXZlciBoYXZlIGludmFsaWQgbm9kZXMgaW4gdGhlIHJlY29tcHV0ZSBoZWFwOyB0aGV5IGFyZSBuZXZlciBzdGFsZS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBKb2luX2xoc19jaGFuZ2UgKHsgbGhzOyBtYWluOyByaHMgPSBvbGRfcmhzOyBfIH0gYXMgam9pbikgLT5cbiAgICBsZXQgcmhzID0gTm9kZS52YWx1ZV9leG4gbGhzIGluXG4gICAgam9pbi5yaHMgPC0gVW9wdC5zb21lIHJocztcbiAgICAoKiBzZWUgdGhlIGNvbW1lbnQgaW4gQmluZF9saHNfY2hhbmdlICopXG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgY2hhbmdlX2NoaWxkXG4gICAgICB+cGFyZW50Om1haW5cbiAgICAgIH5vbGRfY2hpbGQ6b2xkX3Joc1xuICAgICAgfm5ld19jaGlsZDpyaHNcbiAgICAgIH5jaGlsZF9pbmRleDpLaW5kLmpvaW5fcmhzX2NoaWxkX2luZGV4O1xuICAgIG1heWJlX2NoYW5nZV92YWx1ZSBub2RlICgpXG4gIHwgSm9pbl9tYWluIHsgcmhzOyBfIH0gLT4gY29weV9jaGlsZCB+cGFyZW50Om5vZGUgfmNoaWxkOihVb3B0LnZhbHVlX2V4biByaHMpXG4gIHwgTWFwIChmLCBuMSkgLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKGYgKE5vZGUudmFsdWVfZXhuIG4xKSlcbiAgfCBTbmFwc2hvdCB7IGF0OyBiZWZvcmU7IGNsb2NrOyBfIH0gLT5cbiAgICAoKiBJdCBpcyBhIGJ1ZyBpZiB3ZSB0cnkgdG8gY29tcHV0ZSBhIFtTbmFwc2hvdF0gYW5kIHRoZSBhbGFybSBzaG91bGQgaGF2ZSBmaXJlZC5cbiAgICAgICBbYWR2YW5jZV9jbG9ja10gd2FzIHN1cHBvc2VkIHRvIGNvbnZlcnQgaXQgdG8gYSBbRnJlZXplXSBhdCB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICB0aW1lLiAqKVxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChUaW1lX25zLiggPiApIGF0IChub3cgY2xvY2spKTtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSBiZWZvcmVcbiAgfCBTdGVwX2Z1bmN0aW9uICh7IGNoaWxkOyBjbG9jazsgXyB9IGFzIHN0ZXBfZnVuY3Rpb25fbm9kZSkgLT5cbiAgICBpZiBVb3B0LmlzX3NvbWUgY2hpbGRcbiAgICB0aGVuIChcbiAgICAgIGxldCBjaGlsZCA9IFVvcHQudmFsdWVfZXhuIGNoaWxkIGluXG4gICAgICBpZiBTdGFiaWxpemF0aW9uX251bS5jb21wYXJlXG4gICAgICAgICAgIGNoaWxkLmNoYW5nZWRfYXRcbiAgICAgICAgICAgc3RlcF9mdW5jdGlvbl9ub2RlLmV4dHJhY3RlZF9zdGVwX2Z1bmN0aW9uX2Zyb21fY2hpbGRfYXRcbiAgICAgICAgID4gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHN0ZXBfZnVuY3Rpb25fbm9kZS5leHRyYWN0ZWRfc3RlcF9mdW5jdGlvbl9mcm9tX2NoaWxkX2F0IDwtIGNoaWxkLmNoYW5nZWRfYXQ7XG4gICAgICAgIHJlbW92ZV9hbGFybSBjbG9jayBzdGVwX2Z1bmN0aW9uX25vZGUuYWxhcm07XG4gICAgICAgIGxldCBzdGVwX2Z1bmN0aW9uID0gTm9kZS52YWx1ZV9leG4gY2hpbGQgaW5cbiAgICAgICAgc3RlcF9mdW5jdGlvbl9ub2RlLnZhbHVlIDwtIFVvcHQuc29tZSAoU3RlcF9mdW5jdGlvbi5pbml0IHN0ZXBfZnVuY3Rpb24pO1xuICAgICAgICBzdGVwX2Z1bmN0aW9uX25vZGUudXBjb21pbmdfc3RlcHMgPC0gU3RlcF9mdW5jdGlvbi5zdGVwcyBzdGVwX2Z1bmN0aW9uO1xuICAgICAgICAoKiBJZiB0aGUgY2hpbGQgaXMgYSBjb25zdGFudCwgd2UgZHJvcCBvdXIgcmVmZXJlbmNlIHRvIGl0LCB0byBhdm9pZCBob2xkaW5nIG9uIHRvXG4gICAgICAgICAgIHRoZSBlbnRpcmUgc3RlcCBmdW5jdGlvbi4gKilcbiAgICAgICAgaWYgTm9kZS5pc19jb25zdCBjaGlsZFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByZW1vdmVfY2hpbGRyZW4gbm9kZTtcbiAgICAgICAgICBzdGVwX2Z1bmN0aW9uX25vZGUuY2hpbGQgPC0gVW9wdC5ub25lO1xuICAgICAgICAgIHNldF9oZWlnaHQgbm9kZSAoU2NvcGUuaGVpZ2h0IG5vZGUuY3JlYXRlZF9pbiArIDEpKSkpO1xuICAgIFN0ZXBfZnVuY3Rpb25fbm9kZS5hZHZhbmNlIHN0ZXBfZnVuY3Rpb25fbm9kZSB+dG9fOihub3cgY2xvY2spO1xuICAgIGxldCBzdGVwX2Z1bmN0aW9uX3ZhbHVlID0gVW9wdC52YWx1ZV9leG4gc3RlcF9mdW5jdGlvbl9ub2RlLnZhbHVlIGluXG4gICAgKG1hdGNoIFNlcXVlbmNlLmhkIHN0ZXBfZnVuY3Rpb25fbm9kZS51cGNvbWluZ19zdGVwcyB3aXRoXG4gICAgIHwgTm9uZSAtPiBpZiBVb3B0LmlzX25vbmUgY2hpbGQgdGhlbiBOb2RlLnNldF9raW5kIG5vZGUgKENvbnN0IHN0ZXBfZnVuY3Rpb25fdmFsdWUpXG4gICAgIHwgU29tZSAoYXQsIF8pIC0+XG4gICAgICAgc3RlcF9mdW5jdGlvbl9ub2RlLmFsYXJtIDwtIGFkZF9hbGFybSBjbG9jayB+YXQgc3RlcF9mdW5jdGlvbl9ub2RlLmFsYXJtX3ZhbHVlKTtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSBzdGVwX2Z1bmN0aW9uX3ZhbHVlXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgdSAtPiBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoVW5vcmRlcmVkX2FycmF5X2ZvbGQuY29tcHV0ZSB1KVxuICB8IFVuaW5pdGlhbGl6ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgVmFyIHZhciAtPiBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSB2YXIudmFsdWVcbiAgfCBNYXAyIChmLCBuMSwgbjIpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKGYgKE5vZGUudmFsdWVfZXhuIG4xKSAoTm9kZS52YWx1ZV9leG4gbjIpKVxuICB8IE1hcDMgKGYsIG4xLCBuMiwgbjMpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZiAoTm9kZS52YWx1ZV9leG4gbjEpIChOb2RlLnZhbHVlX2V4biBuMikgKE5vZGUudmFsdWVfZXhuIG4zKSlcbiAgfCBNYXA0IChmLCBuMSwgbjIsIG4zLCBuNCkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmIChOb2RlLnZhbHVlX2V4biBuMSkgKE5vZGUudmFsdWVfZXhuIG4yKSAoTm9kZS52YWx1ZV9leG4gbjMpIChOb2RlLnZhbHVlX2V4biBuNCkpXG4gIHwgTWFwNSAoZiwgbjEsIG4yLCBuMywgbjQsIG41KSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSkpXG4gIHwgTWFwNiAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNikgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpKVxuICB8IE1hcDcgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43KSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNykpXG4gIHwgTWFwOCAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44KSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOCkpXG4gIHwgTWFwOSAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjkpKVxuICB8IE1hcDEwIChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTApIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG43KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG44KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG45KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMCkpXG4gIHwgTWFwMTEgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExKSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTApXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjExKSlcbiAgfCBNYXAxMiAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMikgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjkpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEwKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTIpKVxuICB8IE1hcDEzIChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTAsIG4xMSwgbjEyLCBuMTMpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG43KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG44KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG45KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEyKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMykpXG4gIHwgTWFwMTQgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIsIG4xMywgbjE0KSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTApXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjExKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjE0KSlcbiAgfCBNYXAxNSAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4xNSkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjkpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEwKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEzKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTUpKVxuICB8IEV4cGVydCBleHBlcnQgLT5cbiAgICAobWF0Y2ggRXhwZXJ0LmJlZm9yZV9tYWluX2NvbXB1dGF0aW9uIGV4cGVydCB3aXRoXG4gICAgIHwgYEludmFsaWQgLT5cbiAgICAgICBpbnZhbGlkYXRlX25vZGUgbm9kZTtcbiAgICAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSB0XG4gICAgIHwgYE9rIC0+IG1heWJlX2NoYW5nZV92YWx1ZSBub2RlIChleHBlcnQuZiAoKSkpXG5cbmFuZCBjb3B5X2NoaWxkIDogdHlwZSBhLiBwYXJlbnQ6YSBOb2RlLnQgLT4gY2hpbGQ6YSBOb2RlLnQgLT4gdW5pdCA9XG4gIGZ1biB+cGFyZW50IH5jaGlsZCAtPlxuICBpZiBOb2RlLmlzX3ZhbGlkIGNoaWxkXG4gIHRoZW4gbWF5YmVfY2hhbmdlX3ZhbHVlIHBhcmVudCAoTm9kZS52YWx1ZV9leG4gY2hpbGQpXG4gIGVsc2UgKFxuICAgIGludmFsaWRhdGVfbm9kZSBwYXJlbnQ7XG4gICAgcHJvcGFnYXRlX2ludmFsaWRpdHkgcGFyZW50LnN0YXRlKVxuXG5hbmQgbWF5YmVfY2hhbmdlX3ZhbHVlIDogdHlwZSBhLiBhIE5vZGUudCAtPiBhIC0+IHVuaXQgPVxuICBmdW4gbm9kZSBuZXdfdmFsdWUgLT5cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIGxldCBvbGRfdmFsdWVfb3B0ID0gbm9kZS52YWx1ZV9vcHQgaW5cbiAgaWYgVW9wdC5pc19ub25lIG9sZF92YWx1ZV9vcHRcbiAgfHwgbm90XG4gICAgICAgKEN1dG9mZi5zaG91bGRfY3V0b2ZmXG4gICAgICAgICAgbm9kZS5jdXRvZmZcbiAgICAgICAgICB+b2xkX3ZhbHVlOihVb3B0LnVuc2FmZV92YWx1ZSBvbGRfdmFsdWVfb3B0KVxuICAgICAgICAgIH5uZXdfdmFsdWUpXG4gIHRoZW4gKFxuICAgIG5vZGUudmFsdWVfb3B0IDwtIFVvcHQuc29tZSBuZXdfdmFsdWU7XG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgdC5udW1fbm9kZXNfY2hhbmdlZCA8LSB0Lm51bV9ub2Rlc19jaGFuZ2VkICsgMTtcbiAgICBpZiBub2RlLm51bV9vbl91cGRhdGVfaGFuZGxlcnMgPiAwXG4gICAgdGhlbiAoXG4gICAgICBub2RlLm9sZF92YWx1ZV9vcHQgPC0gb2xkX3ZhbHVlX29wdDtcbiAgICAgIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIG5vZGUpO1xuICAgIGlmIG5vZGUubnVtX3BhcmVudHMgPj0gMVxuICAgIHRoZW4gKFxuICAgICAgZm9yIHBhcmVudF9pbmRleCA9IDEgdG8gbm9kZS5udW1fcGFyZW50cyAtIDEgZG9cbiAgICAgICAgbGV0IChUIHBhcmVudCkgPVxuICAgICAgICAgIFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCBub2RlLnBhcmVudDFfYW5kX2JleW9uZCAocGFyZW50X2luZGV4IC0gMSkpXG4gICAgICAgIGluXG4gICAgICAgIChtYXRjaCBwYXJlbnQua2luZCB3aXRoXG4gICAgICAgICB8IEV4cGVydCBleHBlcnQgLT5cbiAgICAgICAgICAgbGV0IGNoaWxkX2luZGV4ID0gbm9kZS5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKHBhcmVudF9pbmRleCkgaW5cbiAgICAgICAgICAgRXhwZXJ0LnJ1bl9lZGdlX2NhbGxiYWNrIH5jaGlsZF9pbmRleCBleHBlcnRcbiAgICAgICAgIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgdSAtPlxuICAgICAgICAgICBVbm9yZGVyZWRfYXJyYXlfZm9sZC5jaGlsZF9jaGFuZ2VkXG4gICAgICAgICAgICAgdVxuICAgICAgICAgICAgIH5jaGlsZDpub2RlXG4gICAgICAgICAgICAgfmNoaWxkX2luZGV4Om5vZGUubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihwYXJlbnRfaW5kZXgpXG4gICAgICAgICAgICAgfm9sZF92YWx1ZV9vcHRcbiAgICAgICAgICAgICB+bmV3X3ZhbHVlXG4gICAgICAgICB8IF8gLT4gKCkpO1xuICAgICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBwYXJlbnQpO1xuICAgICAgICAoKiBXZSBkb24ndCBkbyB0aGUgW2Nhbl9yZWNvbXB1dGVfbm93XSBvcHRpbWl6YXRpb24uICBTaW5jZSBtb3N0IG5vZGVzIG9ubHkgaGF2ZVxuICAgICAgICAgICBvbmUgcGFyZW50LCBpdCBpcyBub3QgcHJvYmFibHkgbm90IGEgYmlnIGxvc3MuICBJZiB3ZSBkaWQgaXQgYW55d2F5LCB3ZSdkXG4gICAgICAgICAgIGhhdmUgdG8gYmUgY2FyZWZ1bCwgYmVjYXVzZSB3aGlsZSB3ZSBpdGVyYXRlIG92ZXIgdGhlIGxpc3Qgb2YgcGFyZW50cywgd2VcbiAgICAgICAgICAgd291bGQgZXhlY3V0ZSB0aGVtLCBhbmQgaW4gcGFydGljdWxhciB3ZSBjYW4gZXhlY3V0ZSBsaHMtY2hhbmdlIG5vZGVzIHdobyBjYW5cbiAgICAgICAgICAgY2hhbmdlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGxpc3Qgb2YgcGFyZW50cyB3ZSBpdGVyYXRlIG9uLiAgVGhpbmsgYWJvdXQ6XG5cbiAgICAgICAgICAge1tcbiAgICAgICAgICAgICBsaHMgPj49IGZ1biBiIC0+IGlmIGIgdGhlbiBsaHMgPj58IEZuLmlkIGVsc2UgY29uc3QgYlxuICAgICAgICAgICBdfVxuXG4gICAgICAgICAgIElmIHRoZSBvcHRpbWl6YXRpb24ga2lja3MgaW4gd2hlbiB3ZSBwcm9wYWdhdGUgY2hhbmdlIHRvIHRoZSBwYXJlbnRzIG9mIFtsaHNdXG4gICAgICAgICAgICh3aGljaCBjaGFuZ2VzIGZyb20gW3RydWVdIHRvIFtmYWxzZV0pLCB3ZSBjb3VsZCBleGVjdXRlIHRoZSBbbGhzLWNoYW5nZV1cbiAgICAgICAgICAgZmlyc3QsIHdoaWNoIHdvdWxkIG1ha2UgZGlzY29ubmVjdCB0aGUgW21hcF0gbm9kZSBmcm9tIFtsaHNdLiAgQW5kIHRoZW4gd2VcbiAgICAgICAgICAgd291bGQgZXhlY3V0ZSB0aGUgc2Vjb25kIGNoaWxkIG9mIHRoZSBbbGhzXSwgd2hpY2ggZG9lc24ndCBleGlzdCBhbnltb3JlIGFuZFxuICAgICAgICAgICBpbmNyZW1lbnRhbCB3b3VsZCBzZWdmYXVsdCAodGhlcmUgbWF5IGJlIGEgbGVzcyBuYWl2ZSB3YXkgb2YgbWFraW5nIHRoaXMgd29ya1xuICAgICAgICAgICB0aG91Z2gpLiAqKVxuICAgICAgICBpZiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgcGFyZW50KVxuICAgICAgICB0aGVuIFJlY29tcHV0ZV9oZWFwLmFkZCB0LnJlY29tcHV0ZV9oZWFwIHBhcmVudFxuICAgICAgZG9uZTtcbiAgICAgIGxldCAoVCBwYXJlbnQpID0gVW9wdC52YWx1ZV9leG4gbm9kZS5wYXJlbnQwIGluXG4gICAgICAobWF0Y2ggcGFyZW50LmtpbmQgd2l0aFxuICAgICAgIHwgRXhwZXJ0IHAgLT5cbiAgICAgICAgIGxldCBjaGlsZF9pbmRleCA9IG5vZGUubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LigwKSBpblxuICAgICAgICAgRXhwZXJ0LnJ1bl9lZGdlX2NhbGxiYWNrIH5jaGlsZF9pbmRleCBwXG4gICAgICAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCB1IC0+XG4gICAgICAgICBVbm9yZGVyZWRfYXJyYXlfZm9sZC5jaGlsZF9jaGFuZ2VkXG4gICAgICAgICAgIHVcbiAgICAgICAgICAgfmNoaWxkOm5vZGVcbiAgICAgICAgICAgfmNoaWxkX2luZGV4Om5vZGUubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LigwKVxuICAgICAgICAgICB+b2xkX3ZhbHVlX29wdFxuICAgICAgICAgICB+bmV3X3ZhbHVlXG4gICAgICAgfCBfIC0+ICgpKTtcbiAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIHBhcmVudCk7XG4gICAgICBpZiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgcGFyZW50KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBjYW5fcmVjb21wdXRlX25vdyA9XG4gICAgICAgICAgbWF0Y2ggcGFyZW50LmtpbmQgd2l0aFxuICAgICAgICAgIHwgVW5pbml0aWFsaXplZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAoKiBUaGVzZSBub2RlcyBhcmVuJ3QgcGFyZW50cy4gKilcbiAgICAgICAgICB8IEF0IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBBdF9pbnRlcnZhbHMgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IENvbnN0IF8gfCBJbnZhbGlkIHwgU25hcHNob3QgXyB8IFZhciBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICgqIFRoZXNlIG5vZGVzIGhhdmUgbW9yZSB0aGFuIG9uZSBjaGlsZC4gKilcbiAgICAgICAgICB8IEFycmF5X2ZvbGQgX1xuICAgICAgICAgIHwgTWFwMiBfXG4gICAgICAgICAgfCBNYXAzIF9cbiAgICAgICAgICB8IE1hcDQgX1xuICAgICAgICAgIHwgTWFwNSBfXG4gICAgICAgICAgfCBNYXA2IF9cbiAgICAgICAgICB8IE1hcDcgX1xuICAgICAgICAgIHwgTWFwOCBfXG4gICAgICAgICAgfCBNYXA5IF9cbiAgICAgICAgICB8IE1hcDEwIF9cbiAgICAgICAgICB8IE1hcDExIF9cbiAgICAgICAgICB8IE1hcDEyIF9cbiAgICAgICAgICB8IE1hcDEzIF9cbiAgICAgICAgICB8IE1hcDE0IF9cbiAgICAgICAgICB8IE1hcDE1IF9cbiAgICAgICAgICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIF9cbiAgICAgICAgICB8IEV4cGVydCBfIC0+IGZhbHNlXG4gICAgICAgICAgKCogV2UgY2FuIGltbWVkaWF0ZWx5IHJlY29tcHV0ZSBbcGFyZW50XSBpZiBubyBvdGhlciBub2RlIG5lZWRzIHRvIGJlIHN0YWJsZVxuICAgICAgICAgICAgIGJlZm9yZSBjb21wdXRpbmcgaXQuICBJZiBbcGFyZW50XSBoYXMgYSBzaW5nbGUgY2hpbGQgKGkuZS4gW25vZGVdKSwgdGhlblxuICAgICAgICAgICAgIHRoaXMgYW1vdW50cyB0byBjaGVja2luZyB0aGF0IFtwYXJlbnRdIHdvbid0IGJlIGludmFsaWRhdGVkLCBpLmUuIHRoYXRcbiAgICAgICAgICAgICBbcGFyZW50XSdzIHNjb3BlIGhhcyBhbHJlYWR5IHN0YWJpbGl6ZWQuICopXG4gICAgICAgICAgfCBCaW5kX2xoc19jaGFuZ2UgXyAtPiBub2RlLmhlaWdodCA+IFNjb3BlLmhlaWdodCBwYXJlbnQuY3JlYXRlZF9pblxuICAgICAgICAgIHwgRnJlZXplIF8gLT4gbm9kZS5oZWlnaHQgPiBTY29wZS5oZWlnaHQgcGFyZW50LmNyZWF0ZWRfaW5cbiAgICAgICAgICB8IElmX3Rlc3RfY2hhbmdlIF8gLT4gbm9kZS5oZWlnaHQgPiBTY29wZS5oZWlnaHQgcGFyZW50LmNyZWF0ZWRfaW5cbiAgICAgICAgICB8IEpvaW5fbGhzX2NoYW5nZSBfIC0+IG5vZGUuaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0IHBhcmVudC5jcmVhdGVkX2luXG4gICAgICAgICAgfCBNYXAgXyAtPiBub2RlLmhlaWdodCA+IFNjb3BlLmhlaWdodCBwYXJlbnQuY3JlYXRlZF9pblxuICAgICAgICAgIHwgU3RlcF9mdW5jdGlvbiBfIC0+IG5vZGUuaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0IHBhcmVudC5jcmVhdGVkX2luXG4gICAgICAgICAgKCogRm9yIHRoZXNlLCB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlIFwiX2NoYW5nZVwiIGNoaWxkIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgICBldmFsdWF0ZWQgKGlmIG5lZWRlZCkuICBJZiBzbywgdGhpcyBhbHNvIGltcGxpZXM6XG5cbiAgICAgICAgICAgICB7W1xuICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPiBTY29wZS5oZWlnaHQgcGFyZW50LmNyZWF0ZWRfaW5cbiAgICAgICAgICAgICBdfSAqKVxuICAgICAgICAgIHwgQmluZF9tYWluIGIgLT4gbm9kZS5oZWlnaHQgPiBiLmxoc19jaGFuZ2UuaGVpZ2h0XG4gICAgICAgICAgfCBJZl90aGVuX2Vsc2UgaSAtPiBub2RlLmhlaWdodCA+IGkudGVzdF9jaGFuZ2UuaGVpZ2h0XG4gICAgICAgICAgfCBKb2luX21haW4gaiAtPiBub2RlLmhlaWdodCA+IGoubGhzX2NoYW5nZS5oZWlnaHRcbiAgICAgICAgaW5cbiAgICAgICAgaWYgY2FuX3JlY29tcHV0ZV9ub3dcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgdC5udW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX29uZV9jaGlsZFxuICAgICAgICAgIDwtIHQubnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9vbmVfY2hpbGQgKyAxO1xuICAgICAgICAgIHJlY29tcHV0ZSBwYXJlbnQpXG4gICAgICAgIGVsc2UgaWYgcGFyZW50LmhlaWdodCA8PSBSZWNvbXB1dGVfaGVhcC5taW5faGVpZ2h0IHQucmVjb21wdXRlX2hlYXBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogSWYgW3BhcmVudC5oZWlnaHRdIGlzIFs8PV0gdGhlIGhlaWdodCBvZiBhbGwgbm9kZXMgaW4gdGhlIHJlY29tcHV0ZSBoZWFwXG4gICAgICAgICAgICAgKHBvc3NpYmx5IGJlY2F1c2UgdGhlIHJlY29tcHV0ZSBoZWFwIGlzIGVtcHR5KSwgdGhlbiB3ZSBjYW4gcmVjb21wdXRlXG4gICAgICAgICAgICAgW3BhcmVudF0gaW1tZWRpYXRlbHkgYW5kIHNhdmUgYWRkaW5nIGl0IHRvIGFuZCB0aGVuIHJlbW92aW5nIGl0IGZyb20gdGhlXG4gICAgICAgICAgICAgcmVjb21wdXRlIGhlYXAuICopXG4gICAgICAgICAgdC5udW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX21pbl9oZWlnaHRcbiAgICAgICAgICA8LSB0Lm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2VfbWluX2hlaWdodCArIDE7XG4gICAgICAgICAgcmVjb21wdXRlIHBhcmVudClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgcGFyZW50KTtcbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAobm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIHBhcmVudCkpO1xuICAgICAgICAgIFJlY29tcHV0ZV9oZWFwLmFkZCB0LnJlY29tcHV0ZV9oZWFwIHBhcmVudCkpKSk7XG4gIGlmIGRlYnVnIHRoZW4gaW52YXJpYW50IHRcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gcmVjb21wdXRlX2ZpcnN0X25vZGVfdGhhdF9pc19uZWNlc3NhcnkgciA9XG4gIGxldCAoVCBub2RlKSA9IFJlY29tcHV0ZV9oZWFwLnJlbW92ZV9taW4gciBpblxuICBpZiBkZWJ1ZyAmJiBub3QgKE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgbm9kZSlcbiAgdGhlblxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJub2RlIHVuZXhwZWN0ZWRseSBkb2VzIG5vdCBuZWVkIHRvIGJlIGNvbXB1dGVkXCJcbiAgICAgIG5vZGVcbiAgICAgIFslc2V4cF9vZjogXyBOb2RlLnRdO1xuICByZWNvbXB1dGUgbm9kZVxuOztcblxubGV0IHVubGlua19kaXNhbGxvd2VkX29ic2VydmVycyB0ID1cbiAgd2hpbGUgU3RhY2subGVuZ3RoIHQuZGlzYWxsb3dlZF9vYnNlcnZlcnMgPiAwIGRvXG4gICAgbGV0IHBhY2tlZCA9IFN0YWNrLnBvcF9leG4gdC5kaXNhbGxvd2VkX29ic2VydmVycyBpblxuICAgIGxldCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPSBwYWNrZWQgaW5cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIG1hdGNoIGludGVybmFsX29ic2VydmVyLnN0YXRlIHdpdGhcbiAgICAgICAgfCBEaXNhbGxvd2VkIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGZhbHNlKTtcbiAgICBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSA8LSBVbmxpbmtlZDtcbiAgICBsZXQgKFQgYWxsX29ic2VydmVycykgPSBVb3B0LnZhbHVlX2V4biB0LmFsbF9vYnNlcnZlcnMgaW5cbiAgICBpZiBJbnRlcm5hbF9vYnNlcnZlci5zYW1lIGludGVybmFsX29ic2VydmVyIGFsbF9vYnNlcnZlcnNcbiAgICB0aGVuIHQuYWxsX29ic2VydmVycyA8LSBpbnRlcm5hbF9vYnNlcnZlci5uZXh0X2luX2FsbDtcbiAgICBJbnRlcm5hbF9vYnNlcnZlci51bmxpbmsgaW50ZXJuYWxfb2JzZXJ2ZXI7XG4gICAgY2hlY2tfaWZfdW5uZWNlc3NhcnkgaW50ZXJuYWxfb2JzZXJ2ZXIub2JzZXJ2aW5nXG4gIGRvbmVcbjs7XG5cbmxldCBkaXNhbGxvd19mdXR1cmVfdXNlIGludGVybmFsX29ic2VydmVyID1cbiAgbGV0IHQgPSBJbnRlcm5hbF9vYnNlcnZlci5pbmNyX3N0YXRlIGludGVybmFsX29ic2VydmVyIGluXG4gIG1hdGNoIGludGVybmFsX29ic2VydmVyLnN0YXRlIHdpdGhcbiAgfCBEaXNhbGxvd2VkIHwgVW5saW5rZWQgLT4gKClcbiAgfCBDcmVhdGVkIC0+XG4gICAgdC5udW1fYWN0aXZlX29ic2VydmVycyA8LSB0Lm51bV9hY3RpdmVfb2JzZXJ2ZXJzIC0gMTtcbiAgICBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSA8LSBVbmxpbmtlZDtcbiAgICBpbnRlcm5hbF9vYnNlcnZlci5vbl91cGRhdGVfaGFuZGxlcnMgPC0gW11cbiAgfCBJbl91c2UgLT5cbiAgICB0Lm51bV9hY3RpdmVfb2JzZXJ2ZXJzIDwtIHQubnVtX2FjdGl2ZV9vYnNlcnZlcnMgLSAxO1xuICAgIGludGVybmFsX29ic2VydmVyLnN0YXRlIDwtIERpc2FsbG93ZWQ7XG4gICAgU3RhY2sucHVzaCB0LmRpc2FsbG93ZWRfb2JzZXJ2ZXJzIChUIGludGVybmFsX29ic2VydmVyKVxuOztcblxubGV0IGRpc2FsbG93X2ZpbmFsaXplZF9vYnNlcnZlcnMgdCA9XG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCB0LmZpbmFsaXplZF9vYnNlcnZlcnMgPiAwIGRvXG4gICAgbGV0IChUIGludGVybmFsX29ic2VydmVyKSA9IFRocmVhZF9zYWZlX3F1ZXVlLmRlcXVldWVfZXhuIHQuZmluYWxpemVkX29ic2VydmVycyBpblxuICAgIGlmIExpc3QuaXNfZW1wdHkgaW50ZXJuYWxfb2JzZXJ2ZXIub25fdXBkYXRlX2hhbmRsZXJzXG4gICAgdGhlbiBkaXNhbGxvd19mdXR1cmVfdXNlIGludGVybmFsX29ic2VydmVyXG4gIGRvbmVcbjs7XG5cbmxldCBvYnNlcnZlcl9maW5hbGl6ZXIgdCA9XG4gIHN0YWdlIChmdW4gb2JzZXJ2ZXIgLT5cbiAgICBsZXQgaW50ZXJuYWxfb2JzZXJ2ZXIgPSAhb2JzZXJ2ZXIgaW5cbiAgICBUaHJlYWRfc2FmZV9xdWV1ZS5lbnF1ZXVlIHQuZmluYWxpemVkX29ic2VydmVycyAoVCBpbnRlcm5hbF9vYnNlcnZlcikpXG47O1xuXG5sZXQgY3JlYXRlX29ic2VydmVyID8oc2hvdWxkX2ZpbmFsaXplID0gdHJ1ZSkgKG9ic2VydmluZyA6IF8gTm9kZS50KSA9XG4gIGxldCB0ID0gb2JzZXJ2aW5nLnN0YXRlIGluXG4gIGxldCBpbnRlcm5hbF9vYnNlcnZlciA6IF8gSW50ZXJuYWxfb2JzZXJ2ZXIudCA9XG4gICAgeyBzdGF0ZSA9IENyZWF0ZWRcbiAgICA7IG9ic2VydmluZ1xuICAgIDsgb25fdXBkYXRlX2hhbmRsZXJzID0gW11cbiAgICA7IHByZXZfaW5fYWxsID0gVW9wdC5ub25lXG4gICAgOyBuZXh0X2luX2FsbCA9IFVvcHQubm9uZVxuICAgIDsgcHJldl9pbl9vYnNlcnZpbmcgPSBVb3B0Lm5vbmVcbiAgICA7IG5leHRfaW5fb2JzZXJ2aW5nID0gVW9wdC5ub25lXG4gICAgfVxuICBpblxuICBTdGFjay5wdXNoIHQubmV3X29ic2VydmVycyAoVCBpbnRlcm5hbF9vYnNlcnZlcik7XG4gIGxldCBvYnNlcnZlciA9IHJlZiBpbnRlcm5hbF9vYnNlcnZlciBpblxuICBpZiBzaG91bGRfZmluYWxpemVcbiAgdGhlbiBHYy5FeHBlcnQuYWRkX2ZpbmFsaXplcl9leG4gb2JzZXJ2ZXIgKHVuc3RhZ2UgKG9ic2VydmVyX2ZpbmFsaXplciB0KSk7XG4gIHQubnVtX2FjdGl2ZV9vYnNlcnZlcnMgPC0gdC5udW1fYWN0aXZlX29ic2VydmVycyArIDE7XG4gIG9ic2VydmVyXG47O1xuXG5sZXQgYWRkX25ld19vYnNlcnZlcnMgdCA9XG4gIHdoaWxlIFN0YWNrLmxlbmd0aCB0Lm5ld19vYnNlcnZlcnMgPiAwIGRvXG4gICAgbGV0IHBhY2tlZCA9IFN0YWNrLnBvcF9leG4gdC5uZXdfb2JzZXJ2ZXJzIGluXG4gICAgbGV0IG1vZHVsZSBQYWNrZWQgPSBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQgaW5cbiAgICBsZXQgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpID0gcGFja2VkIGluXG4gICAgbWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgIHwgSW5fdXNlIHwgRGlzYWxsb3dlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFVubGlua2VkIC0+ICgpXG4gICAgfCBDcmVhdGVkIC0+XG4gICAgICBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSA8LSBJbl91c2U7XG4gICAgICBsZXQgb2xkX2FsbF9vYnNlcnZlcnMgPSB0LmFsbF9vYnNlcnZlcnMgaW5cbiAgICAgIGlmIFVvcHQuaXNfc29tZSBvbGRfYWxsX29ic2VydmVyc1xuICAgICAgdGhlbiAoXG4gICAgICAgIGludGVybmFsX29ic2VydmVyLm5leHRfaW5fYWxsIDwtIG9sZF9hbGxfb2JzZXJ2ZXJzO1xuICAgICAgICBQYWNrZWQuc2V0X3ByZXZfaW5fYWxsIChVb3B0LnVuc2FmZV92YWx1ZSBvbGRfYWxsX29ic2VydmVycykgKFVvcHQuc29tZSBwYWNrZWQpKTtcbiAgICAgIHQuYWxsX29ic2VydmVycyA8LSBVb3B0LnNvbWUgcGFja2VkO1xuICAgICAgbGV0IG9ic2VydmluZyA9IGludGVybmFsX29ic2VydmVyLm9ic2VydmluZyBpblxuICAgICAgbGV0IHdhc19uZWNlc3NhcnkgPSBOb2RlLmlzX25lY2Vzc2FyeSBvYnNlcnZpbmcgaW5cbiAgICAgIG9ic2VydmluZy5udW1fb25fdXBkYXRlX2hhbmRsZXJzXG4gICAgICA8LSBvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVyc1xuICAgICAgICAgKyBMaXN0Lmxlbmd0aCBpbnRlcm5hbF9vYnNlcnZlci5vbl91cGRhdGVfaGFuZGxlcnM7XG4gICAgICBsZXQgb2xkX29ic2VydmVycyA9IG9ic2VydmluZy5vYnNlcnZlcnMgaW5cbiAgICAgIGlmIFVvcHQuaXNfc29tZSBvbGRfb2JzZXJ2ZXJzXG4gICAgICB0aGVuIChcbiAgICAgICAgaW50ZXJuYWxfb2JzZXJ2ZXIubmV4dF9pbl9vYnNlcnZpbmcgPC0gb2xkX29ic2VydmVycztcbiAgICAgICAgKFVvcHQudW5zYWZlX3ZhbHVlIG9sZF9vYnNlcnZlcnMpLnByZXZfaW5fb2JzZXJ2aW5nIDwtIFVvcHQuc29tZSBpbnRlcm5hbF9vYnNlcnZlcik7XG4gICAgICBvYnNlcnZpbmcub2JzZXJ2ZXJzIDwtIFVvcHQuc29tZSBpbnRlcm5hbF9vYnNlcnZlcjtcbiAgICAgICgqIEJ5IGFkZGluZyBbaW50ZXJuYWxfb2JzZXJ2ZXJdIHRvIFtvYnNlcnZpbmcub2JzZXJ2ZXJzXSwgd2UgbWF5IGhhdmUgYWRkZWRcbiAgICAgICAgIG9uLXVwZGF0ZSBoYW5kbGVycyB0byBbb2JzZXJ2aW5nXS4gIFdlIG5lZWQgdG8gaGFuZGxlIFtvYnNlcnZpbmddIGFmdGVyIHRoaXNcbiAgICAgICAgIHN0YWJpbGl6YXRpb24gdG8gZ2l2ZSB0aG9zZSBoYW5kbGVycyBhIGNoYW5jZSB0byBydW4uICopXG4gICAgICBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBvYnNlcnZpbmc7XG4gICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19uZWNlc3Nhcnkgb2JzZXJ2aW5nKTtcbiAgICAgIGlmIG5vdCB3YXNfbmVjZXNzYXJ5IHRoZW4gYmVjYW1lX25lY2Vzc2FyeSBvYnNlcnZpbmdcbiAgZG9uZVxuOztcblxubGV0IG9ic2VydmVyX3ZhbHVlX2V4biBvYnNlcnZlciA9XG4gIGxldCB0ID0gT2JzZXJ2ZXIuaW5jcl9zdGF0ZSBvYnNlcnZlciBpblxuICBtYXRjaCB0LnN0YXR1cyB3aXRoXG4gIHwgTm90X3N0YWJpbGl6aW5nIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgLT4gT2JzZXJ2ZXIudmFsdWVfZXhuIG9ic2VydmVyXG4gIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIHJhaXNlZF9leG4gLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiT2JzZXJ2ZXIudmFsdWVfZXhuIGNhbGxlZCBhZnRlciBzdGFiaWxpemUgcHJldmlvdXNseSByYWlzZWRcIlxuICAgICAgcmFpc2VkX2V4blxuICAgICAgWyVzZXhwX29mOiBSYWlzZWRfZXhuLnRdXG4gIHwgU3RhYmlsaXppbmcgLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiT2JzZXJ2ZXIudmFsdWVfZXhuIGNhbGxlZCBkdXJpbmcgc3RhYmlsaXphdGlvblwiXG4gICAgICBvYnNlcnZlclxuICAgICAgWyVzZXhwX29mOiBfIE9ic2VydmVyLnRdXG47O1xuXG5sZXQgb2JzZXJ2ZXJfdmFsdWUgb2JzZXJ2ZXIgPVxuICB0cnkgT2sgKG9ic2VydmVyX3ZhbHVlX2V4biBvYnNlcnZlcikgd2l0aFxuICB8IGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4bilcbjs7XG5cbmxldCBub2RlX29uX3VwZGF0ZSAodHlwZSBhKSAobm9kZSA6IGEgTm9kZS50KSB+ZiA9XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICBOb2RlLm9uX3VwZGF0ZSBub2RlIChPbl91cGRhdGVfaGFuZGxlci5jcmVhdGUgZiB+YXQ6dC5zdGFiaWxpemF0aW9uX251bSk7XG4gIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIG5vZGVcbjs7XG5cbmxldCBvYnNlcnZlcl9vbl91cGRhdGVfZXhuIG9ic2VydmVyIH5mID1cbiAgbGV0IHQgPSBPYnNlcnZlci5pbmNyX3N0YXRlIG9ic2VydmVyIGluXG4gIE9ic2VydmVyLm9uX3VwZGF0ZV9leG4gb2JzZXJ2ZXIgKE9uX3VwZGF0ZV9oYW5kbGVyLmNyZWF0ZSBmIH5hdDp0LnN0YWJpbGl6YXRpb25fbnVtKTtcbiAgaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gKE9ic2VydmVyLm9ic2VydmluZyBvYnNlcnZlcilcbjs7XG5cbmxldCBzZXRfdmFyX3doaWxlX25vdF9zdGFiaWxpemluZyB2YXIgdmFsdWUgPVxuICBsZXQgdCA9IFZhci5pbmNyX3N0YXRlIHZhciBpblxuICB0Lm51bV92YXJfc2V0cyA8LSB0Lm51bV92YXJfc2V0cyArIDE7XG4gIHZhci52YWx1ZSA8LSB2YWx1ZTtcbiAgaWYgU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZSB2YXIuc2V0X2F0IHQuc3RhYmlsaXphdGlvbl9udW0gPCAwXG4gIHRoZW4gKFxuICAgIHZhci5zZXRfYXQgPC0gdC5zdGFiaWxpemF0aW9uX251bTtcbiAgICBsZXQgd2F0Y2ggPSB2YXIud2F0Y2ggaW5cbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19zdGFsZSB3YXRjaCk7XG4gICAgaWYgTm9kZS5pc19uZWNlc3Nhcnkgd2F0Y2ggJiYgbm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIHdhdGNoKVxuICAgIHRoZW4gUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgd2F0Y2gpXG47O1xuXG5sZXQgc2V0X3ZhciB2YXIgdmFsdWUgPVxuICBsZXQgdCA9IFZhci5pbmNyX3N0YXRlIHZhciBpblxuICBtYXRjaCB0LnN0YXR1cyB3aXRoXG4gIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgfCBOb3Rfc3RhYmlsaXppbmcgLT5cbiAgICBzZXRfdmFyX3doaWxlX25vdF9zdGFiaWxpemluZyB2YXIgdmFsdWVcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgcmFpc2VkX2V4biAtPlxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJjYW5ub3Qgc2V0IHZhciAtLSBzdGFiaWxpemF0aW9uIHByZXZpb3VzbHkgcmFpc2VkXCJcbiAgICAgIHJhaXNlZF9leG5cbiAgICAgIFslc2V4cF9vZjogUmFpc2VkX2V4bi50XVxuICB8IFN0YWJpbGl6aW5nIC0+XG4gICAgaWYgVW9wdC5pc19ub25lIHZhci52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb25cbiAgICB0aGVuIFN0YWNrLnB1c2ggdC5zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gKFQgdmFyKTtcbiAgICB2YXIudmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIDwtIFVvcHQuc29tZSB2YWx1ZVxuOztcblxubGV0IHJlY2xhaW1fc3BhY2VfaW5fd2Vha19oYXNodGJscyB0ID1cbiAgd2hpbGUgVGhyZWFkX3NhZmVfcXVldWUubGVuZ3RoIHQud2Vha19oYXNodGJscyA+IDAgZG9cbiAgICBsZXQgKFQgd2Vha19oYXNodGJsKSA9IFRocmVhZF9zYWZlX3F1ZXVlLmRlcXVldWVfZXhuIHQud2Vha19oYXNodGJscyBpblxuICAgIFdlYWtfaGFzaHRibC5yZWNsYWltX3NwYWNlX2Zvcl9rZXlzX3dpdGhfdW51c2VkX2RhdGEgd2Vha19oYXNodGJsXG4gIGRvbmVcbjs7XG5cbmxldCBzdGFiaWxpemVfc3RhcnQgdCA9XG4gIHQuc3RhdHVzIDwtIFN0YWJpbGl6aW5nO1xuICBkaXNhbGxvd19maW5hbGl6ZWRfb2JzZXJ2ZXJzIHQ7XG4gICgqIEp1c3QgbGlrZSBmb3IgYmluZHMsIHdlIGFkZCBuZXcgb2JzZXJ2ZXJzIGJlZm9yZSByZW1vdmluZyBkaXNhbGxvd2VkIG9ic2VydmVycyB0b1xuICAgICBwb3RlbnRpYWxseSBhdm9pZCBzd2l0Y2hpbmcgdGhlIG9ic2VydmFiaWxpdHkgb2Ygc29tZSBub2RlcyBiYWNrIGFuZCBmb3J0aC4gKilcbiAgYWRkX25ld19vYnNlcnZlcnMgdDtcbiAgdW5saW5rX2Rpc2FsbG93ZWRfb2JzZXJ2ZXJzIHQ7XG4gIGlmIGRlYnVnIHRoZW4gaW52YXJpYW50IHRcbjs7XG5cbmxldCBzdGFiaWxpemVfZW5kIHQgPVxuICBpZiBkZWJ1Z1xuICB0aGVuIChcbiAgICB0Lm9ubHlfaW5fZGVidWcuY3VycmVudGx5X3J1bm5pbmdfbm9kZSA8LSBOb25lO1xuICAgIHQub25seV9pbl9kZWJ1Zy5leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW50X25vZGUgPC0gW10pO1xuICAoKiBXZSBpbmNyZW1lbnQgW3Quc3RhYmlsaXphdGlvbl9udW1dIGJlZm9yZSBoYW5kbGluZyB2YXJpYWJsZXMgc2V0IGR1cmluZ1xuICAgICBzdGFiaWxpemF0aW9uLCBzbyB0aGF0IHRoZXkgYXJlIHRyZWF0ZWQgYXMgc2V0IGR1cmluZyB0aGUgbmV3IHN0YWJpbGl6YXRpb24gY3ljbGUuXG4gICAgIEFsc28sIHdlIGluY3JlbWVudCBiZWZvcmUgcnVubmluZyBvbi11cGRhdGUgaGFuZGxlcnMsIHRvIGF2b2lkIHJ1bm5pbmcgb24gdXBkYXRlXG4gICAgIGhhbmRsZXJzIGNyZWF0ZWQgZHVyaW5nIG9uIHVwZGF0ZSBoYW5kbGVycy4gKilcbiAgdC5zdGFiaWxpemF0aW9uX251bSA8LSBTdGFiaWxpemF0aW9uX251bS5hZGQxIHQuc3RhYmlsaXphdGlvbl9udW07XG4gIHdoaWxlIG5vdCAoU3RhY2suaXNfZW1wdHkgdC5zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pIGRvXG4gICAgbGV0IChUIHZhcikgPSBTdGFjay5wb3BfZXhuIHQuc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIGluXG4gICAgbGV0IHZhbHVlID0gVW9wdC52YWx1ZV9leG4gdmFyLnZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiBpblxuICAgIHZhci52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gPC0gVW9wdC5ub25lO1xuICAgIHNldF92YXJfd2hpbGVfbm90X3N0YWJpbGl6aW5nIHZhciB2YWx1ZVxuICBkb25lO1xuICB3aGlsZSBub3QgKFN0YWNrLmlzX2VtcHR5IHQuaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24pIGRvXG4gICAgbGV0IChUIG5vZGUpID0gU3RhY2sucG9wX2V4biB0LmhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIGluXG4gICAgbm9kZS5pc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiA8LSBmYWxzZTtcbiAgICBsZXQgb2xkX3ZhbHVlID0gbm9kZS5vbGRfdmFsdWVfb3B0IGluXG4gICAgbm9kZS5vbGRfdmFsdWVfb3B0IDwtIFVvcHQubm9uZTtcbiAgICBsZXQgbm9kZV91cGRhdGUgOiBfIE5vZGVfdXBkYXRlLnQgPVxuICAgICAgaWYgbm90IChOb2RlLmlzX3ZhbGlkIG5vZGUpXG4gICAgICB0aGVuIEludmFsaWRhdGVkXG4gICAgICBlbHNlIGlmIG5vdCAoTm9kZS5pc19uZWNlc3Nhcnkgbm9kZSlcbiAgICAgIHRoZW4gVW5uZWNlc3NhcnlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV3X3ZhbHVlID0gVW9wdC52YWx1ZV9leG4gbm9kZS52YWx1ZV9vcHQgaW5cbiAgICAgICAgaWYgVW9wdC5pc19ub25lIG9sZF92YWx1ZVxuICAgICAgICB0aGVuIE5lY2Vzc2FyeSBuZXdfdmFsdWVcbiAgICAgICAgZWxzZSBDaGFuZ2VkIChVb3B0LnVuc2FmZV92YWx1ZSBvbGRfdmFsdWUsIG5ld192YWx1ZSkpXG4gICAgaW5cbiAgICBTdGFjay5wdXNoIHQucnVuX29uX3VwZGF0ZV9oYW5kbGVycyAoVCAobm9kZSwgbm9kZV91cGRhdGUpKVxuICBkb25lO1xuICB0LnN0YXR1cyA8LSBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVycztcbiAgbGV0IG5vdyA9IHQuc3RhYmlsaXphdGlvbl9udW0gaW5cbiAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSB0LnJ1bl9vbl91cGRhdGVfaGFuZGxlcnMpIGRvXG4gICAgbGV0IChUIChub2RlLCBub2RlX3VwZGF0ZSkpID0gU3RhY2sucG9wX2V4biB0LnJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgaW5cbiAgICBOb2RlLnJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgbm9kZSBub2RlX3VwZGF0ZSB+bm93XG4gIGRvbmU7XG4gIHQuc3RhdHVzIDwtIE5vdF9zdGFiaWxpemluZztcbiAgcmVjbGFpbV9zcGFjZV9pbl93ZWFrX2hhc2h0YmxzIHRcbjs7XG5cbmxldCByYWlzZV9kdXJpbmdfc3RhYmlsaXphdGlvbiB0IGV4biA9XG4gIHQuc3RhdHVzIDwtIFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCAoUmFpc2VkX2V4bi5jcmVhdGUgZXhuKTtcbiAgcmFpc2UgZXhuXG47O1xuXG5sZXQgc3RhYmlsaXplIHQgPVxuICBlbnN1cmVfbm90X3N0YWJpbGl6aW5nIHQgfm5hbWU6XCJzdGFiaWxpemVcIiB+YWxsb3dfaW5fdXBkYXRlX2hhbmRsZXI6ZmFsc2U7XG4gIHRyeVxuICAgIHN0YWJpbGl6ZV9zdGFydCB0O1xuICAgIGxldCByID0gdC5yZWNvbXB1dGVfaGVhcCBpblxuICAgIHdoaWxlIFJlY29tcHV0ZV9oZWFwLmxlbmd0aCByID4gMCBkb1xuICAgICAgcmVjb21wdXRlX2ZpcnN0X25vZGVfdGhhdF9pc19uZWNlc3NhcnkgclxuICAgIGRvbmU7XG4gICAgc3RhYmlsaXplX2VuZCB0XG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb24gdCBleG5cbjs7XG5cbm1vZHVsZSBTdGVwX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgS2VlcF9nb2luZ1xuICAgIHwgRG9uZVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBkb19vbmVfc3RlcF9vZl9zdGFiaWxpemUgdCA6IFN0ZXBfcmVzdWx0LnQgPVxuICB0cnlcbiAgICBtYXRjaCB0LnN0YXR1cyB3aXRoXG4gICAgfCBOb3Rfc3RhYmlsaXppbmcgLT5cbiAgICAgIHN0YWJpbGl6ZV9zdGFydCB0O1xuICAgICAgS2VlcF9nb2luZ1xuICAgIHwgU3RhYmlsaXppbmcgLT5cbiAgICAgIGxldCByID0gdC5yZWNvbXB1dGVfaGVhcCBpblxuICAgICAgaWYgUmVjb21wdXRlX2hlYXAubGVuZ3RoIHIgPiAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVjb21wdXRlX2ZpcnN0X25vZGVfdGhhdF9pc19uZWNlc3NhcnkgcjtcbiAgICAgICAgS2VlcF9nb2luZylcbiAgICAgIGVsc2UgKFxuICAgICAgICBzdGFiaWxpemVfZW5kIHQ7XG4gICAgICAgIERvbmUpXG4gICAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVycyB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCBfIC0+XG4gICAgICBlbnN1cmVfbm90X3N0YWJpbGl6aW5nIHQgfm5hbWU6XCJzdGVwXCIgfmFsbG93X2luX3VwZGF0ZV9oYW5kbGVyOmZhbHNlO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICAobWF0Y2ggdC5zdGF0dXMgd2l0aFxuICAgICB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCBfIC0+XG4gICAgICAgKCogSWYgc3RhYmlsaXphdGlvbiBoYXMgYWxyZWFkeSByYWlzZWQsIHRoZW4gW2V4bl0gaXMgbWVyZWx5IGEgbm90aWZpY2F0aW9uIG9mIHRoaXNcbiAgICAgICAgICBmYWN0LCByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIGl0c2VsZi4gIFdlIHNob3VsZCBqdXN0IHByb3BhZ2F0ZSBbZXhuXVxuICAgICAgICAgIGZvcndhcmQ7IGNhbGxpbmcgW3JhaXNlX2R1cmluZ19zdGFiaWxpemF0aW9uXSB3b3VsZCBzdG9yZSBbZXhuXSBhcyB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgdGhhdCBpbml0aWFsbHkgcmFpc2VkIGR1cmluZyBzdGFiaWxpemF0aW9uLiAqKVxuICAgICAgIHJhaXNlIGV4blxuICAgICB8IF8gLT4gcmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb24gdCBleG4pXG47O1xuXG5sZXQgY3JlYXRlX25vZGVfaW4gdCBjcmVhdGVkX2luIGtpbmQgPVxuICB0Lm51bV9ub2Rlc19jcmVhdGVkIDwtIHQubnVtX25vZGVzX2NyZWF0ZWQgKyAxO1xuICBOb2RlLmNyZWF0ZSB0IGNyZWF0ZWRfaW4ga2luZFxuOztcblxubGV0IGNyZWF0ZV9ub2RlIHQga2luZCA9IGNyZWF0ZV9ub2RlX2luIHQgdC5jdXJyZW50X3Njb3BlIGtpbmRcbmxldCBjcmVhdGVfbm9kZV90b3AgdCBraW5kID0gY3JlYXRlX25vZGVfaW4gdCBTY29wZS50b3Aga2luZFxuXG5sZXQgY3JlYXRlX3ZhciB0ID8odXNlX2N1cnJlbnRfc2NvcGUgPSBmYWxzZSkgdmFsdWUgPVxuICBsZXQgc2NvcGUgPSBpZiB1c2VfY3VycmVudF9zY29wZSB0aGVuIHQuY3VycmVudF9zY29wZSBlbHNlIFNjb3BlLnRvcCBpblxuICBsZXQgd2F0Y2ggPSBjcmVhdGVfbm9kZV9pbiB0IHNjb3BlIFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IHZhciA9XG4gICAgeyBWYXIudmFsdWVcbiAgICA7IHZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiA9IFVvcHQubm9uZVxuICAgIDsgc2V0X2F0ID0gdC5zdGFiaWxpemF0aW9uX251bVxuICAgIDsgd2F0Y2hcbiAgICB9XG4gIGluXG4gIE5vZGUuc2V0X2tpbmQgd2F0Y2ggKFZhciB2YXIpO1xuICB2YXJcbjs7XG5cbigqIEEgW2NvbnN0XSB2YWx1ZSBjb3VsZCBjb21lIGZyb20gdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiBhbiBvdXRlciBiaW5kLiAgU28sIHdlIGNyZWF0ZSBhXG4gICBbY29uc3RdIG5vZGUgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIG5vdCBpbiBbU2NvcGUudG9wXS4gKilcbmxldCBjb25zdCB0IGEgPSBjcmVhdGVfbm9kZSB0IChDb25zdCBhKVxubGV0IG1hcCAobiA6IF8gTm9kZS50KSB+ZiA9IGNyZWF0ZV9ub2RlIG4uc3RhdGUgKE1hcCAoZiwgbikpXG5sZXQgbWFwMiAobjEgOiBfIE5vZGUudCkgbjIgfmYgPSBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwMiAoZiwgbjEsIG4yKSlcblxubGV0IGJvdGggKG4xIDogXyBOb2RlLnQpIChuMiA6IF8gTm9kZS50KSA9XG4gIG1hdGNoIG4xLCBuMiB3aXRoXG4gIHwgeyBraW5kID0gQ29uc3QgYTsgXyB9LCB7IGtpbmQgPSBDb25zdCBiOyBfIH0gLT4gY29uc3QgbjEuc3RhdGUgKGEsIGIpXG4gIHwgXyAtPiBtYXAyIG4xIG4yIH5mOlR1cGxlMi5jcmVhdGVcbjs7XG5cbmxldCBtYXAzIChuMSA6IF8gTm9kZS50KSBuMiBuMyB+ZiA9IGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAzIChmLCBuMSwgbjIsIG4zKSlcbmxldCBtYXA0IChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCB+ZiA9IGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXA0IChmLCBuMSwgbjIsIG4zLCBuNCkpXG5cbmxldCBtYXA1IChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCBuNSB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXA1IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUpKVxuOztcblxubGV0IG1hcDYgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IH5mID1cbiAgY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDYgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYpKVxuOztcblxubGV0IG1hcDcgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IH5mID1cbiAgY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDcgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43KSlcbjs7XG5cbmxldCBtYXA4IChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCBuNSBuNiBuNyBuOCB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXA4IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgpKVxuOztcblxubGV0IG1hcDkgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IH5mID1cbiAgY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDkgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjkpKVxuOztcblxubGV0IG1hcDEwIChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCBuNSBuNiBuNyBuOCBuOSBuMTAgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwMTAgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCkpXG47O1xuXG5sZXQgbWFwMTEgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IG4xMCBuMTEgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwMTEgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExKSlcbjs7XG5cbmxldCBtYXAxMiAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgbjggbjkgbjEwIG4xMSBuMTIgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwMTIgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIpKVxuOztcblxubGV0IG1hcDEzIChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCBuNSBuNiBuNyBuOCBuOSBuMTAgbjExIG4xMiBuMTMgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwMTMgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIsIG4xMykpXG47O1xuXG5sZXQgbWFwMTQgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IG4xMCBuMTEgbjEyIG4xMyBuMTQgfmYgPVxuICBjcmVhdGVfbm9kZVxuICAgIG4xLnN0YXRlXG4gICAgKE1hcDE0IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTAsIG4xMSwgbjEyLCBuMTMsIG4xNCkpXG47O1xuXG5sZXQgbWFwMTUgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IG4xMCBuMTEgbjEyIG4xMyBuMTQgbjE1IH5mID1cbiAgY3JlYXRlX25vZGVcbiAgICBuMS5zdGF0ZVxuICAgIChNYXAxNSAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4xNSkpXG47O1xuXG5sZXQgcHJlc2VydmVfY3V0b2ZmIH4oaW5wdXQgOiBfIE5vZGUudCkgfm91dHB1dCA9XG4gIE5vZGUuc2V0X2N1dG9mZlxuICAgIG91dHB1dFxuICAgIChDdXRvZmYuY3JlYXRlIChmdW4gfm9sZF92YWx1ZTpfIH5uZXdfdmFsdWU6XyAtPlxuICAgICAgIFN0YWJpbGl6YXRpb25fbnVtLmVxdWFsIGlucHV0LmNoYW5nZWRfYXQgb3V0cHV0LmNoYW5nZWRfYXQpKVxuOztcblxubGV0IGRlcGVuZF9vbiBpbnB1dCB+ZGVwZW5kX29uID1cbiAgbGV0IG91dHB1dCA9IG1hcDIgaW5wdXQgZGVwZW5kX29uIH5mOihmdW4gYSBfIC0+IGEpIGluXG4gIHByZXNlcnZlX2N1dG9mZiB+aW5wdXQgfm91dHB1dDtcbiAgb3V0cHV0XG47O1xuXG5sZXQgbmVjZXNzYXJ5X2lmX2FsaXZlIGlucHV0ID1cbiAgKCogSWYgW291dHB1dF0gaXMgYWxpdmUsIHRoZW4gW29ic2VydmVyXSBpcyBhbGl2ZSwgdGhlbiBbaW5wdXRdIGlzIG5lY2Vzc2FyeS4gIElmXG4gICAgIFtvdXRwdXRdIGlzIHVubmVjZXNzYXJ5LCB0aGVuIFtvdXRwdXRdIGlzIG5vdCBhIHBhcmVudCBvZiBbaW5wdXRdLCBhbmQgdGh1c1xuICAgICBbb3V0cHV0XSdzIGxpdmVuZXNzIGlzIGRlcGVuZGVudCBzb2xlbHkgb24gdXNlciBjb2RlLiAgQW5kIGluIHBhcnRpY3VsYXIsIGlmIFtvdXRwdXRdXG4gICAgIGRpZXMsIHRoZW4gW29ic2VydmVyXSB3aWxsIGJlIGZpbmFsaXplZCwgYW5kIHRoZW4gdXBvbiB0aGUgbmV4dCBzdGFiaWxpemF0aW9uLFxuICAgICBbaW5wdXRdIHdpbGwgYmVjb21lIHVubmVjZXNzYXJ5IChhdCBsZWFzdCB3aXRoIHJlc3BlY3QgdG8gW291dHB1dF0pLiAqKVxuICBsZXQgb2JzZXJ2ZXIgPSBjcmVhdGVfb2JzZXJ2ZXIgaW5wdXQgaW5cbiAgbGV0IG91dHB1dCA9XG4gICAgbWFwIGlucHV0IH5mOihmdW4gYSAtPlxuICAgICAgR2Mua2VlcF9hbGl2ZSBvYnNlcnZlcjtcbiAgICAgIGEpXG4gIGluXG4gIHByZXNlcnZlX2N1dG9mZiB+aW5wdXQgfm91dHB1dDtcbiAgb3V0cHV0XG47O1xuXG5sZXQgYmluZCAobGhzIDogXyBOb2RlLnQpIH5mID1cbiAgbGV0IHQgPSBsaHMuc3RhdGUgaW5cbiAgbGV0IGxoc19jaGFuZ2UgPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IGJpbmQgPVxuICAgIHsgQmluZC5tYWluXG4gICAgOyBmXG4gICAgOyBsaHNcbiAgICA7IGxoc19jaGFuZ2VcbiAgICA7IHJocyA9IFVvcHQubm9uZVxuICAgIDsgcmhzX3Njb3BlID0gU2NvcGUudG9wXG4gICAgOyBhbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMgPSBVb3B0Lm5vbmVcbiAgICB9XG4gIGluXG4gICgqIFdlIHNldCBbbGhzX2NoYW5nZV0gdG8gbmV2ZXIgY3V0b2ZmIHNvIHRoYXQgd2hlbmV2ZXIgW2xoc10gY2hhbmdlcywgW21haW5dIGlzXG4gICAgIHJlY29tcHV0ZWQuICBUaGlzIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgY2FzZXMgd2hlcmUgW2ZdIHJldHVybnMgYW4gZXhpc3Rpbmcgc3RhYmxlXG4gICAgIG5vZGUsIGluIHdoaWNoIGNhc2UgdGhlIFtsaHNfY2hhbmdlXSB3b3VsZCBiZSB0aGUgb25seSB0aGluZyBjYXVzaW5nIFttYWluXSB0byBiZVxuICAgICBzdGFsZS4gKilcbiAgTm9kZS5zZXRfY3V0b2ZmIGxoc19jaGFuZ2UgQ3V0b2ZmLm5ldmVyO1xuICBiaW5kLnJoc19zY29wZSA8LSBCaW5kIGJpbmQ7XG4gIE5vZGUuc2V0X2tpbmQgbGhzX2NoYW5nZSAoQmluZF9saHNfY2hhbmdlIGJpbmQpO1xuICBOb2RlLnNldF9raW5kIG1haW4gKEJpbmRfbWFpbiBiaW5kKTtcbiAgbWFpblxuOztcblxubGV0IGJpbmQyIG4xIG4yIH5mID1cbiAgYmluZCAobWFwMiBuMSBuMiB+ZjooZnVuIHYxIHYyIC0+IHYxLCB2MikpIH5mOihmdW4gKHYxLCB2MikgLT4gZiB2MSB2Milcbjs7XG5cbmxldCBiaW5kMyBuMSBuMiBuMyB+ZiA9XG4gIGJpbmQgKG1hcDMgbjEgbjIgbjMgfmY6KGZ1biB2MSB2MiB2MyAtPiB2MSwgdjIsIHYzKSkgfmY6KGZ1biAodjEsIHYyLCB2MykgLT4gZiB2MSB2MiB2Mylcbjs7XG5cbmxldCBiaW5kNCBuMSBuMiBuMyBuNCB+ZiA9XG4gIGJpbmRcbiAgICAobWFwNCBuMSBuMiBuMyBuNCB+ZjooZnVuIHYxIHYyIHYzIHY0IC0+IHYxLCB2MiwgdjMsIHY0KSlcbiAgICB+ZjooZnVuICh2MSwgdjIsIHYzLCB2NCkgLT4gZiB2MSB2MiB2MyB2NClcbjs7XG5cbmxldCBqb2luIChsaHMgOiBfIE5vZGUudCkgPVxuICBsZXQgdCA9IGxocy5zdGF0ZSBpblxuICBsZXQgbGhzX2NoYW5nZSA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgam9pbiA9IHsgSm9pbi5saHM7IGxoc19jaGFuZ2U7IHJocyA9IFVvcHQubm9uZTsgbWFpbiB9IGluXG4gIE5vZGUuc2V0X2N1dG9mZiBsaHNfY2hhbmdlIEN1dG9mZi5uZXZlcjtcbiAgTm9kZS5zZXRfa2luZCBsaHNfY2hhbmdlIChKb2luX2xoc19jaGFuZ2Ugam9pbik7XG4gIE5vZGUuc2V0X2tpbmQgbWFpbiAoSm9pbl9tYWluIGpvaW4pO1xuICBtYWluXG47O1xuXG5sZXQgaWZfICh0ZXN0IDogXyBOb2RlLnQpIH50aGVuXyB+ZWxzZV8gPVxuICBsZXQgdCA9IHRlc3Quc3RhdGUgaW5cbiAgbGV0IHRlc3RfY2hhbmdlID0gY3JlYXRlX25vZGUgdCBVbmluaXRpYWxpemVkIGluXG4gIGxldCBtYWluID0gY3JlYXRlX25vZGUgdCBVbmluaXRpYWxpemVkIGluXG4gIGxldCBpZl90aGVuX2Vsc2UgPVxuICAgIHsgSWZfdGhlbl9lbHNlLnRlc3Q7IHRoZW5fOyBlbHNlXzsgdGVzdF9jaGFuZ2U7IG1haW47IGN1cnJlbnRfYnJhbmNoID0gVW9wdC5ub25lIH1cbiAgaW5cbiAgTm9kZS5zZXRfY3V0b2ZmIHRlc3RfY2hhbmdlIEN1dG9mZi5uZXZlcjtcbiAgTm9kZS5zZXRfa2luZCB0ZXN0X2NoYW5nZSAoSWZfdGVzdF9jaGFuZ2UgaWZfdGhlbl9lbHNlKTtcbiAgTm9kZS5zZXRfa2luZCBtYWluIChJZl90aGVuX2Vsc2UgaWZfdGhlbl9lbHNlKTtcbiAgbWFpblxuOztcblxubGV0IGxhenlfZnJvbV9mdW4gdCB+ZiA9XG4gIGxldCBzY29wZSA9IHQuY3VycmVudF9zY29wZSBpblxuICBMYXp5LmZyb21fZnVuIChmdW4gKCkgLT4gd2l0aGluX3Njb3BlIHQgc2NvcGUgfmYpXG47O1xuXG5sZXQgZGVmYXVsdF9oYXNoX3RhYmxlX2luaXRpYWxfc2l6ZSA9IDRcblxubGV0IG1lbW9pemVfZnVuX2J5X2tleVxuICAgICAgPyhpbml0aWFsX3NpemUgPSBkZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplKVxuICAgICAgdFxuICAgICAgaGFzaGFibGVcbiAgICAgIHByb2plY3Rfa2V5XG4gICAgICBmXG4gID1cbiAgKCogSGVyZSdzIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB3ZSBnZXQgW3QuY3VycmVudF9zY29wZV0gaGVyZSwgYW5kIHRoZW4gY2FsbFxuICAgICBbd2l0aGluX3Njb3BlXSBiZWxvdy4gIENvbnNpZGVyIHRoaXMgKGltcG9zc2libGUpIGFsdGVybmF0ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICBbbWVtb2l6ZV9mdW5fYnlfa2V5XTpcblxuICAgICB7W1xuICAgICAgIGxldCB0YWJsZSA9XG4gICAgICAgICBIYXNodGJsLm9mX2FsaXN0X2V4biBoYXNoYWJsZVxuICAgICAgICAgICAoTGlzdC5tYXAgYWxsX3Bvc3NpYmxlX2FfdmFsdWVzIH5mOihmdW4gYSAtPiAocHJvamVjdF9rZXkgYSwgZiBhKSlcbiAgICAgICBpblxuICAgICAgIHN0YWdlIChmdW4ga2V5IC0+IEhhc2h0YmwuZmluZF9leG4gdGFibGUgKHByb2plY3Rfa2V5IGEpKVxuICAgICBdfVxuXG4gICAgIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgW2N1cnJlbnRfc2NvcGVdIG9yIFt3aXRoaW5fc2NvcGVdLiAgQWxsIGNhbGxzIHRvIFtmXVxuICAgICBuYXR1cmFsbHkgb2NjdXIgaW4gW3QuY3VycmVudF9zY29wZV0uXG5cbiAgICAgU3VjaCBhbiBpbXBsZW1lbnRhdGlvbiBpcyBpbXBvc3NpYmxlIGJlY2F1c2Ugd2UgZG8gbm90IGhhdmUgW2FsbF9wb3NzaWJsZV9hX3ZhbHVlc10uXG4gICAgIFRoZSBpbXBsZW1lbnRhdGlvbiBiZWxvdyB1c2VzIFt3aXRoaW5fc2NvcGVdIHRvIGNhbGwgW2YgYV0gaW4gdGhlIHNjb3BlIHRoYXQgd2FzXG4gICAgIGN1cnJlbnQgYXQgdGhlIHBvaW50IG9mIHRoZSBjYWxsIHRvIFttZW1vaXplX2Z1bl9ieV9rZXldIHNvIHRoYXQgd2UgY2FuIHRoaW5rIG9mIHRoZVxuICAgICBbdGFibGVdIGFzIGhhdmluZyBiZWVuIGNyZWF0ZWQgdGhlbiwgd2hlbiBpdCBpbiByZWFsaXR5IGlzIGNyZWF0ZWQgb24tZGVtYW5kLiAqKVxuICBsZXQgc2NvcGUgPSB0LmN1cnJlbnRfc2NvcGUgaW5cbiAgbGV0IHRhYmxlID0gSGFzaHRibC5jcmVhdGUgaGFzaGFibGUgfnNpemU6aW5pdGlhbF9zaXplIGluXG4gIHN0YWdlIChmdW4gYSAtPlxuICAgIGxldCBrZXkgPSBwcm9qZWN0X2tleSBhIGluXG4gICAgbWF0Y2ggSGFzaHRibC5maW5kIHRhYmxlIGtleSB3aXRoXG4gICAgfCBTb21lIGIgLT4gYlxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IGIgPSB3aXRoaW5fc2NvcGUgdCBzY29wZSB+ZjooZnVuICgpIC0+IGYgYSkgaW5cbiAgICAgIEhhc2h0YmwuYWRkX2V4biB0YWJsZSB+a2V5IH5kYXRhOmI7XG4gICAgICBiKVxuOztcblxubGV0IGFycmF5X2ZvbGQgdCBjaGlsZHJlbiB+aW5pdCB+ZiA9XG4gIGlmIEFycmF5Lmxlbmd0aCBjaGlsZHJlbiA9IDBcbiAgdGhlbiBjb25zdCB0IGluaXRcbiAgZWxzZSBjcmVhdGVfbm9kZSB0IChBcnJheV9mb2xkIHsgaW5pdDsgZjsgY2hpbGRyZW4gfSlcbjs7XG5cbmxldCBhbGwgdCB0cyA9IGFycmF5X2ZvbGQgdCAoQXJyYXkub2ZfbGlzdF9yZXYgdHMpIH5pbml0OltdIH5mOihmdW4gYWMgYSAtPiBhIDo6IGFjKVxuXG5tb2R1bGUgVW5vcmRlcmVkX2FycmF5X2ZvbGRfdXBkYXRlID0gVW5vcmRlcmVkX2FycmF5X2ZvbGQuVXBkYXRlXG5cbmxldCB1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgICAgdFxuICAgICAgPyhmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzID0gSW50Lm1heF92YWx1ZSlcbiAgICAgIGNoaWxkcmVuXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgICAgIH51cGRhdGVcbiAgPVxuICBpZiBBcnJheS5sZW5ndGggY2hpbGRyZW4gPSAwXG4gIHRoZW4gY29uc3QgdCBpbml0XG4gIGVsc2UgaWYgZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA8PSAwXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwidW5vcmRlcmVkX2FycmF5X2ZvbGQgZ290IG5vbi1wb3NpdGl2ZSBmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXCJcbiAgICAgIGZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbiAgICAgIFslc2V4cF9vZjogaW50XVxuICBlbHNlIChcbiAgICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICAgIE5vZGUuc2V0X2tpbmRcbiAgICAgIG1haW5cbiAgICAgIChVbm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgICAgICAgKFVub3JkZXJlZF9hcnJheV9mb2xkLmNyZWF0ZVxuICAgICAgICAgICAgfmluaXRcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+dXBkYXRlXG4gICAgICAgICAgICB+ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICAgICAgICAgICAgfmNoaWxkcmVuXG4gICAgICAgICAgICB+bWFpbikpO1xuICAgIG1haW4pXG47O1xuXG5sZXQgb3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkIHQgP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgdHMgfmluaXQgfmYgfmZfaW52ZXJzZSA9XG4gIGxldCBmIChhY2N1bSwgbnVtX2ludmFsaWQpIHggPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgTm9uZSAtPiBhY2N1bSwgbnVtX2ludmFsaWQgKyAxXG4gICAgfCBTb21lIHggLT4gZiBhY2N1bSB4LCBudW1faW52YWxpZFxuICBpblxuICBsZXQgZl9pbnZlcnNlIChhY2N1bSwgbnVtX2ludmFsaWQpIHggPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgTm9uZSAtPiBhY2N1bSwgbnVtX2ludmFsaWQgLSAxXG4gICAgfCBTb21lIHggLT4gZl9pbnZlcnNlIGFjY3VtIHgsIG51bV9pbnZhbGlkXG4gIGluXG4gIG1hcFxuICAgICh1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgICAgIHRcbiAgICAgICB0c1xuICAgICAgIH5pbml0Oihpbml0LCAwKVxuICAgICAgIH5mXG4gICAgICAgfnVwZGF0ZTooRl9pbnZlcnNlIGZfaW52ZXJzZSlcbiAgICAgICA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcylcbiAgICB+ZjooZnVuIChhY2N1bSwgbnVtX2ludmFsaWQpIC0+IGlmIG51bV9pbnZhbGlkID0gMCB0aGVuIFNvbWUgYWNjdW0gZWxzZSBOb25lKVxuOztcblxubGV0IGF0X2xlYXN0X2tfb2YgdCBub2RlcyB+ayA9XG4gIGxldCBib29sX3RvX2ludCBiID0gaWYgYiB0aGVuIDEgZWxzZSAwIGluXG4gIG1hcFxuICAgIH5mOihmdW4gaSAtPiBpID49IGspXG4gICAgKHVub3JkZXJlZF9hcnJheV9mb2xkXG4gICAgICAgdFxuICAgICAgIG5vZGVzXG4gICAgICAgfmluaXQ6MFxuICAgICAgIH5mOihmdW4gbnVtX3RydWUgYiAtPiBudW1fdHJ1ZSArIGJvb2xfdG9faW50IGIpXG4gICAgICAgfnVwZGF0ZTooRl9pbnZlcnNlIChmdW4gbnVtX3RydWUgYiAtPiBudW1fdHJ1ZSAtIGJvb2xfdG9faW50IGIpKSlcbjs7XG5cbmxldCBleGlzdHMgdCBub2RlcyA9IGF0X2xlYXN0X2tfb2YgdCBub2RlcyB+azoxXG5sZXQgZm9yX2FsbCB0IG5vZGVzID0gYXRfbGVhc3Rfa19vZiB0IG5vZGVzIH5rOihBcnJheS5sZW5ndGggbm9kZXMpXG5cbmxldCBzdW0gdCA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyBub2RlcyB+emVybyB+YWRkIH5zdWIgPVxuICB1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgIHRcbiAgICBub2Rlc1xuICAgIH5pbml0Onplcm9cbiAgICB+ZjphZGRcbiAgICB+dXBkYXRlOihGX2ludmVyc2Ugc3ViKVxuICAgID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG47O1xuXG5sZXQgb3B0X3N1bSB0ID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIG5vZGVzIH56ZXJvIH5hZGQgfnN1YiA9XG4gIG9wdF91bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgIHRcbiAgICBub2Rlc1xuICAgIH5pbml0Onplcm9cbiAgICB+ZjphZGRcbiAgICB+Zl9pbnZlcnNlOnN1YlxuICAgID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG47O1xuXG5sZXQgc3VtX2ludCB0IG5vZGVzID0gc3VtIHQgbm9kZXMgfnplcm86MCB+YWRkOiggKyApIH5zdWI6KCAtIClcblxubGV0IHN1bV9mbG9hdCB0IG5vZGVzID1cbiAgc3VtXG4gICAgdFxuICAgIG5vZGVzXG4gICAgfnplcm86MC5cbiAgICB+YWRkOiggKy4gKVxuICAgIH5zdWI6KCAtLiApXG4gICAgfmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXM6KEFycmF5Lmxlbmd0aCBub2Rlcylcbjs7XG5cbmxldCBzZXRfZnJlZXplIChub2RlIDogXyBOb2RlLnQpIH5jaGlsZCB+b25seV9mcmVlemVfd2hlbiA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChTY29wZS5pc190b3Agbm9kZS5jcmVhdGVkX2luKTtcbiAgKCogQnkgbWFraW5nIFtub2RlLmtpbmRdIGJlIFtGcmVlemVdLCB3ZSBhcmUgbWFraW5nIFtOb2RlLmlzX25lY2Vzc2FyeSBub2RlXS4gKilcbiAgbGV0IHdhc19uZWNlc3NhcnkgPSBOb2RlLmlzX25lY2Vzc2FyeSBub2RlIGluXG4gIE5vZGUuc2V0X2tpbmQgbm9kZSAoRnJlZXplIHsgbWFpbiA9IG5vZGU7IGNoaWxkOyBvbmx5X2ZyZWV6ZV93aGVuIH0pO1xuICBpZiB3YXNfbmVjZXNzYXJ5XG4gIHRoZW4gYWRkX3BhcmVudCB+Y2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpLaW5kLmZyZWV6ZV9jaGlsZF9pbmRleFxuICBlbHNlIGJlY2FtZV9uZWNlc3Nhcnkgbm9kZVxuOztcblxubGV0IGZyZWV6ZSAoY2hpbGQgOiBfIE5vZGUudCkgfm9ubHlfZnJlZXplX3doZW4gPVxuICBsZXQgdCA9IGNoaWxkLnN0YXRlIGluXG4gIGxldCBub2RlID0gY3JlYXRlX25vZGVfdG9wIHQgVW5pbml0aWFsaXplZCBpblxuICBzZXRfZnJlZXplIG5vZGUgfmNoaWxkIH5vbmx5X2ZyZWV6ZV93aGVuO1xuICBub2RlXG47O1xuXG5sZXQgYXQgY2xvY2sgdGltZSA9XG4gIGxldCB0ID0gQ2xvY2suaW5jcl9zdGF0ZSBjbG9jayBpblxuICBpZiBUaW1lX25zLiggPD0gKSB0aW1lIChub3cgY2xvY2spXG4gIHRoZW4gY29uc3QgdCBCZWZvcmVfb3JfYWZ0ZXIuQWZ0ZXJcbiAgZWxzZSAoXG4gICAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgICBsZXQgYXQgPSB7IEF0LmF0ID0gdGltZTsgbWFpbjsgYWxhcm0gPSBBbGFybS5udWxsOyBjbG9jayB9IGluXG4gICAgTm9kZS5zZXRfa2luZCBtYWluIChBdCBhdCk7XG4gICAgYXQuYWxhcm0gPC0gYWRkX2FsYXJtIGNsb2NrIH5hdDp0aW1lIChBbGFybV92YWx1ZS5jcmVhdGUgKEF0IGF0KSk7XG4gICAgbWFpbilcbjs7XG5cbmxldCBhZnRlciBjbG9jayBzcGFuID0gYXQgY2xvY2sgKFRpbWVfbnMuYWRkIChub3cgY2xvY2spIHNwYW4pXG5cbmxldCBuZXh0X2ludGVydmFsX2FsYXJtX3N0cmljdCAoY2xvY2sgOiBDbG9jay50KSB+YmFzZSB+aW50ZXJ2YWwgPVxuICBsZXQgYWZ0ZXIgPSBub3cgY2xvY2sgaW5cbiAgbGV0IGF0ID0gVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlIH5hZnRlciB+aW50ZXJ2YWwgfmNhbl9lcXVhbF9hZnRlcjpmYWxzZSAoKSBpblxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVGltZV9ucy4oID4gKSBhdCBhZnRlcik7XG4gIGF0XG47O1xuXG5sZXQgYXRfaW50ZXJ2YWxzIChjbG9jayA6IENsb2NrLnQpIGludGVydmFsID1cbiAgbGV0IHQgPSBDbG9jay5pbmNyX3N0YXRlIGNsb2NrIGluXG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDwgKSBpbnRlcnZhbCAoVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiBjbG9jay50aW1pbmdfd2hlZWwpXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiYXRfaW50ZXJ2YWxzIGdvdCB0b28gc21hbGwgaW50ZXJ2YWxcIlxuICAgICAgaW50ZXJ2YWxcbiAgICAgIFslc2V4cF9vZjogVGltZV9ucy5TcGFuLnRdO1xuICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgYmFzZSA9IG5vdyBjbG9jayBpblxuICBsZXQgYXRfaW50ZXJ2YWxzID0geyBBdF9pbnRlcnZhbHMubWFpbjsgYmFzZTsgaW50ZXJ2YWw7IGFsYXJtID0gQWxhcm0ubnVsbDsgY2xvY2sgfSBpblxuICBOb2RlLnNldF9raW5kIG1haW4gKEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMpO1xuICAoKiBbbWFpbiA6IHVuaXQgTm9kZS50XSwgc28gd2UgbWFrZSBpdCBuZXZlciBjdXRvZmYgc28gaXQgY2hhbmdlcyBlYWNoIHRpbWUgaXQgaXNcbiAgICAgcmVjb21wdXRlZC4gKilcbiAgTm9kZS5zZXRfY3V0b2ZmIG1haW4gQ3V0b2ZmLm5ldmVyO1xuICBhdF9pbnRlcnZhbHMuYWxhcm1cbiAgPC0gYWRkX2FsYXJtXG4gICAgICAgY2xvY2tcbiAgICAgICB+YXQ6KG5leHRfaW50ZXJ2YWxfYWxhcm1fc3RyaWN0IGNsb2NrIH5iYXNlIH5pbnRlcnZhbClcbiAgICAgICAoQWxhcm1fdmFsdWUuY3JlYXRlIChBdF9pbnRlcnZhbHMgYXRfaW50ZXJ2YWxzKSk7XG4gIG1haW5cbjs7XG5cbmxldCBzbmFwc2hvdCBjbG9jayB2YWx1ZV9hdCB+YXQgfmJlZm9yZSA9XG4gIGxldCB0ID0gQ2xvY2suaW5jcl9zdGF0ZSBjbG9jayBpblxuICBpZiBUaW1lX25zLiggPD0gKSBhdCAobm93IGNsb2NrKVxuICB0aGVuXG4gICAgaWYgVGltZV9ucy4oIDwgKSBhdCAobm93IGNsb2NrKVxuICAgIHRoZW4gT3JfZXJyb3IuZXJyb3IgXCJjYW5ub3QgdGFrZSBzbmFwc2hvdCBpbiB0aGUgcGFzdFwiIGF0IFslc2V4cF9vZjogVGltZV9ucy50XVxuICAgIGVsc2UgT2sgKGZyZWV6ZSB2YWx1ZV9hdCB+b25seV9mcmVlemVfd2hlbjooRm4uY29uc3QgdHJ1ZSkpXG4gIGVsc2UgKFxuICAgIGxldCBtYWluID0gY3JlYXRlX25vZGVfdG9wIHQgVW5pbml0aWFsaXplZCBpblxuICAgIGxldCBzbmFwc2hvdCA9IHsgU25hcHNob3QubWFpbjsgYXQ7IGJlZm9yZTsgdmFsdWVfYXQ7IGNsb2NrIH0gaW5cbiAgICBOb2RlLnNldF9raW5kIG1haW4gKFNuYXBzaG90IHNuYXBzaG90KTtcbiAgICAoKiBVbmxpa2Ugb3RoZXIgdGltZS1iYXNlZCBpbmNyZW1lbnRhbHMsIGEgc25hcHNob3QgaXMgY3JlYXRlZCBpbiBbU2NvcGUudG9wXSBhbmRcbiAgICAgICBjYW5ub3QgYmUgaW52YWxpZGF0ZWQgYnkgaXRzIHNjb3BlLiAgVGh1cywgdGhlcmUgaXMgbm8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICAgICAgIGFsYXJtIHRoYXQgaXMgYWRkZWQsIGJlY2F1c2UgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGJlIHJlbW92ZWQgZWFybHkuICopXG4gICAgaWdub3JlIChhZGRfYWxhcm0gY2xvY2sgfmF0IChBbGFybV92YWx1ZS5jcmVhdGUgKFNuYXBzaG90IHNuYXBzaG90KSkgOiBBbGFybS50KTtcbiAgICBPayBtYWluKVxuOztcblxubGV0IGluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb24gY2xvY2sgY2hpbGQgPVxuICBsZXQgdCA9IENsb2NrLmluY3Jfc3RhdGUgY2xvY2sgaW5cbiAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IHN0ZXBfZnVuY3Rpb25fbm9kZSA9XG4gICAgeyBTdGVwX2Z1bmN0aW9uX25vZGUubWFpblxuICAgIDsgdmFsdWUgPSBVb3B0Lm5vbmVcbiAgICA7IGNoaWxkID0gVW9wdC5zb21lIGNoaWxkXG4gICAgOyBleHRyYWN0ZWRfc3RlcF9mdW5jdGlvbl9mcm9tX2NoaWxkX2F0ID0gU3RhYmlsaXphdGlvbl9udW0ubm9uZVxuICAgIDsgdXBjb21pbmdfc3RlcHMgPSBTZXF1ZW5jZS5lbXB0eVxuICAgIDsgYWxhcm0gPSBBbGFybS5udWxsXG4gICAgOyBhbGFybV92YWx1ZSA9IE9iai5tYWdpYyBOb25lICgqIHNldCBiZWxvdyAqKVxuICAgIDsgY2xvY2tcbiAgICB9XG4gIGluXG4gIHN0ZXBfZnVuY3Rpb25fbm9kZS5hbGFybV92YWx1ZSA8LSBBbGFybV92YWx1ZS5jcmVhdGUgKFN0ZXBfZnVuY3Rpb24gc3RlcF9mdW5jdGlvbl9ub2RlKTtcbiAgTm9kZS5zZXRfa2luZCBtYWluIChTdGVwX2Z1bmN0aW9uIHN0ZXBfZnVuY3Rpb25fbm9kZSk7XG4gIG1haW5cbjs7XG5cbmxldCBtYWtlX3N0YWxlIChub2RlIDogXyBOb2RlLnQpID1cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIG5vZGUucmVjb21wdXRlZF9hdCA8LSBTdGFiaWxpemF0aW9uX251bS5ub25lO1xuICAoKiBmb3JjZSB0aGUgbm9kZSB0byBiZSBzdGFsZSAqKVxuICBpZiBOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUgJiYgbm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGUpXG4gIHRoZW4gUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgbm9kZVxuOztcblxubGV0IGFkdmFuY2VfY2xvY2sgKGNsb2NrIDogQ2xvY2sudCkgfnRvXyA9XG4gIGxldCB0ID0gQ2xvY2suaW5jcl9zdGF0ZSBjbG9jayBpblxuICBlbnN1cmVfbm90X3N0YWJpbGl6aW5nIHQgfm5hbWU6XCJhZHZhbmNlX2Nsb2NrXCIgfmFsbG93X2luX3VwZGF0ZV9oYW5kbGVyOnRydWU7XG4gIGlmIGRlYnVnIHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIFRpbWVfbnMuKCA+ICkgdG9fIChub3cgY2xvY2spXG4gIHRoZW4gKFxuICAgIHNldF92YXJfd2hpbGVfbm90X3N0YWJpbGl6aW5nIGNsb2NrLm5vdyB0b187XG4gICAgVGltaW5nX3doZWVsLmFkdmFuY2VfY2xvY2sgY2xvY2sudGltaW5nX3doZWVsIH50b18gfmhhbmRsZV9maXJlZDpjbG9jay5oYW5kbGVfZmlyZWQ7XG4gICAgVGltaW5nX3doZWVsLmZpcmVfcGFzdF9hbGFybXMgY2xvY2sudGltaW5nX3doZWVsIH5oYW5kbGVfZmlyZWQ6Y2xvY2suaGFuZGxlX2ZpcmVkO1xuICAgIHdoaWxlIFVvcHQuaXNfc29tZSBjbG9jay5maXJlZF9hbGFybV92YWx1ZXMgZG9cbiAgICAgIGxldCBhbGFybV92YWx1ZSA9IFVvcHQudW5zYWZlX3ZhbHVlIGNsb2NrLmZpcmVkX2FsYXJtX3ZhbHVlcyBpblxuICAgICAgY2xvY2suZmlyZWRfYWxhcm1fdmFsdWVzIDwtIGFsYXJtX3ZhbHVlLm5leHRfZmlyZWQ7XG4gICAgICBhbGFybV92YWx1ZS5uZXh0X2ZpcmVkIDwtIFVvcHQubm9uZTtcbiAgICAgIG1hdGNoIGFsYXJtX3ZhbHVlLmFjdGlvbiB3aXRoXG4gICAgICB8IEF0IHsgbWFpbjsgXyB9IC0+XG4gICAgICAgIGlmIE5vZGUuaXNfdmFsaWQgbWFpblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBOb2RlLnNldF9raW5kIG1haW4gKENvbnN0IEFmdGVyKTtcbiAgICAgICAgICBtYWtlX3N0YWxlIG1haW4pXG4gICAgICB8IEF0X2ludGVydmFscyAoeyBtYWluOyBiYXNlOyBpbnRlcnZhbDsgXyB9IGFzIGF0X2ludGVydmFscykgLT5cbiAgICAgICAgaWYgTm9kZS5pc192YWxpZCBtYWluXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGF0X2ludGVydmFscy5hbGFybVxuICAgICAgICAgIDwtIGFkZF9hbGFybVxuICAgICAgICAgICAgICAgY2xvY2tcbiAgICAgICAgICAgICAgIH5hdDoobmV4dF9pbnRlcnZhbF9hbGFybV9zdHJpY3QgY2xvY2sgfmJhc2UgfmludGVydmFsKVxuICAgICAgICAgICAgICAgYWxhcm1fdmFsdWU7XG4gICAgICAgICAgbWFrZV9zdGFsZSBtYWluKVxuICAgICAgfCBTbmFwc2hvdCB7IG1haW47IHZhbHVlX2F0OyBfIH0gLT5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUuaXNfdmFsaWQgbWFpbik7XG4gICAgICAgIHNldF9mcmVlemUgbWFpbiB+Y2hpbGQ6dmFsdWVfYXQgfm9ubHlfZnJlZXplX3doZW46KGZ1biBfIC0+IHRydWUpO1xuICAgICAgICBtYWtlX3N0YWxlIG1haW5cbiAgICAgIHwgU3RlcF9mdW5jdGlvbiB7IG1haW47IF8gfSAtPiBpZiBOb2RlLmlzX3ZhbGlkIG1haW4gdGhlbiBtYWtlX3N0YWxlIG1haW5cbiAgICBkb25lO1xuICAgIGlmIGRlYnVnIHRoZW4gaW52YXJpYW50IHQpXG47O1xuXG5sZXQgY3JlYXRlX2Nsb2NrIHQgfnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0ID1cbiAgbGV0IHRpbWluZ193aGVlbCA9IFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzp0aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydCBpblxuICBsZXQgcmVjIGNsb2NrIDogQ2xvY2sudCA9XG4gICAgeyBub3cgPSBjcmVhdGVfdmFyIHQgc3RhcnRcbiAgICA7IGhhbmRsZV9maXJlZFxuICAgIDsgZmlyZWRfYWxhcm1fdmFsdWVzID0gVW9wdC5ub25lXG4gICAgOyB0aW1pbmdfd2hlZWxcbiAgICB9XG4gIGFuZCBoYW5kbGVfZmlyZWQgYWxhcm0gPVxuICAgIGxldCBhbGFybV92YWx1ZSA9IFRpbWluZ193aGVlbC5BbGFybS52YWx1ZSBjbG9jay50aW1pbmdfd2hlZWwgYWxhcm0gaW5cbiAgICBhbGFybV92YWx1ZS5uZXh0X2ZpcmVkIDwtIGNsb2NrLmZpcmVkX2FsYXJtX3ZhbHVlcztcbiAgICBjbG9jay5maXJlZF9hbGFybV92YWx1ZXMgPC0gVW9wdC5zb21lIGFsYXJtX3ZhbHVlXG4gIGluXG4gIGNsb2NrXG47O1xuXG5sZXQgY3JlYXRlIChtb2R1bGUgQ29uZmlnIDogQ29uZmlnLkluY3JlbWVudGFsX2NvbmZpZykgfm1heF9oZWlnaHRfYWxsb3dlZCA9XG4gIGxldCBhZGp1c3RfaGVpZ2h0c19oZWFwID0gQWRqdXN0X2hlaWdodHNfaGVhcC5jcmVhdGUgfm1heF9oZWlnaHRfYWxsb3dlZCBpblxuICBsZXQgcmVjb21wdXRlX2hlYXAgPSBSZWNvbXB1dGVfaGVhcC5jcmVhdGUgfm1heF9oZWlnaHRfYWxsb3dlZCBpblxuICBsZXQgdCA9XG4gICAgeyBzdGF0dXMgPSBOb3Rfc3RhYmlsaXppbmdcbiAgICA7IGJpbmRfbGhzX2NoYW5nZV9zaG91bGRfaW52YWxpZGF0ZV9yaHMgPSBDb25maWcuYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3Joc1xuICAgIDsgc3RhYmlsaXphdGlvbl9udW0gPSBTdGFiaWxpemF0aW9uX251bS56ZXJvXG4gICAgOyBjdXJyZW50X3Njb3BlID0gU2NvcGUudG9wXG4gICAgOyBhZGp1c3RfaGVpZ2h0c19oZWFwXG4gICAgOyByZWNvbXB1dGVfaGVhcFxuICAgIDsgcHJvcGFnYXRlX2ludmFsaWRpdHkgPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IG51bV9hY3RpdmVfb2JzZXJ2ZXJzID0gMFxuICAgIDsgYWxsX29ic2VydmVycyA9IFVvcHQubm9uZVxuICAgIDsgZmluYWxpemVkX29ic2VydmVycyA9IFRocmVhZF9zYWZlX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgZGlzYWxsb3dlZF9vYnNlcnZlcnMgPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IG5ld19vYnNlcnZlcnMgPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IHNldF9kdXJpbmdfc3RhYmlsaXphdGlvbiA9IFN0YWNrLmNyZWF0ZSAoKVxuICAgIDsgaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IHJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IG9ubHlfaW5fZGVidWcgPSBPbmx5X2luX2RlYnVnLmNyZWF0ZSAoKVxuICAgIDsgd2Vha19oYXNodGJscyA9IFRocmVhZF9zYWZlX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsga2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZSA9IGZhbHNlXG4gICAgOyBudW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeSA9IDBcbiAgICA7IG51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnkgPSAwXG4gICAgOyBudW1fbm9kZXNfY2hhbmdlZCA9IDBcbiAgICA7IG51bV9ub2Rlc19pbnZhbGlkYXRlZCA9IDBcbiAgICA7IG51bV9ub2Rlc19jcmVhdGVkID0gMFxuICAgIDsgbnVtX25vZGVzX3JlY29tcHV0ZWQgPSAwXG4gICAgOyBudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX29uZV9jaGlsZCA9IDBcbiAgICA7IG51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2VfbWluX2hlaWdodCA9IDBcbiAgICA7IG51bV92YXJfc2V0cyA9IDBcbiAgICB9XG4gIGluXG4gIHRcbjs7XG5cbmxldCB3ZWFrX21lbW9pemVfZnVuX2J5X2tleVxuICAgICAgPyhpbml0aWFsX3NpemUgPSBkZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplKVxuICAgICAgdFxuICAgICAgaGFzaGFibGVcbiAgICAgIHByb2plY3Rfa2V5XG4gICAgICBmXG4gID1cbiAgbGV0IHNjb3BlID0gdC5jdXJyZW50X3Njb3BlIGluXG4gIGxldCB0YWJsZSA9IFdlYWtfaGFzaHRibC5jcmVhdGUgfnNpemU6aW5pdGlhbF9zaXplIGhhc2hhYmxlIGluXG4gIGxldCBwYWNrZWQgPSBQYWNrZWRfd2Vha19oYXNodGJsLlQgdGFibGUgaW5cbiAgV2Vha19oYXNodGJsLnNldF9ydW5fd2hlbl91bnVzZWRfZGF0YSB0YWJsZSB+dGhyZWFkX3NhZmVfZjooZnVuICgpIC0+XG4gICAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LndlYWtfaGFzaHRibHMgcGFja2VkKTtcbiAgc3RhZ2UgKGZ1biBhIC0+XG4gICAgbGV0IGtleSA9IHByb2plY3Rfa2V5IGEgaW5cbiAgICBtYXRjaCBXZWFrX2hhc2h0YmwuZmluZCB0YWJsZSBrZXkgd2l0aFxuICAgIHwgU29tZSBiIC0+IGJcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBiID0gd2l0aGluX3Njb3BlIHQgc2NvcGUgfmY6KGZ1biAoKSAtPiBmIGEpIGluXG4gICAgICBXZWFrX2hhc2h0YmwuYWRkX2V4biB0YWJsZSB+a2V5IH5kYXRhOmI7XG4gICAgICBiKVxuOztcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICAoKiBHaXZlbiB0aGF0IGludmFsaWQgbm9kZSBhcmUgYXQgYXR0ZW1wdCBhdCBhdm9pZGluZyBicmVha2luZyB0aGUgZW50aXJlIGluY3JlbWVudGFsXG4gICAgIGNvbXB1dGF0aW9uIG9uIHByb2JsZW1zLCBsZXQncyBqdXN0IGlnbm9yZSBhbnkgb3BlcmF0aW9uIG9uIGFuIGludmFsaWQgaW5jcmVtZW50YWxcbiAgICAgcmF0aGVyIHRoYW4gcmFpc2luZy4gKilcbiAgbGV0IGV4cGVydF9raW5kX29mX25vZGUgKG5vZGUgOiBfIE5vZGUudCkgPVxuICAgIG1hdGNoIG5vZGUua2luZCB3aXRoXG4gICAgfCBFeHBlcnQgZSAtPiBVb3B0LnNvbWUgZVxuICAgIHwgSW52YWxpZCAtPiBVb3B0Lm5vbmVcbiAgICB8IGtpbmQgLT4gcmFpc2VfcyBbJXNleHAgXCJ1bmV4cGVjdGVkIGtpbmQgZm9yIGV4cGVydCBub2RlXCIsIChraW5kIDogXyBLaW5kLnQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgc3RhdGUgfm9uX29ic2VydmFiaWxpdHlfY2hhbmdlIGYgPVxuICAgIGxldCBlID0gRXhwZXJ0LmNyZWF0ZSB+ZiB+b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgaW5cbiAgICBsZXQgbm9kZSA9IGNyZWF0ZV9ub2RlIHN0YXRlIChFeHBlcnQgZSkgaW5cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIGlmIE9wdGlvbi5pc19zb21lIHN0YXRlLm9ubHlfaW5fZGVidWcuY3VycmVudGx5X3J1bm5pbmdfbm9kZVxuICAgICAgdGhlblxuICAgICAgICBzdGF0ZS5vbmx5X2luX2RlYnVnLmV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZVxuICAgICAgICA8LSBUIG5vZGUgOjogc3RhdGUub25seV9pbl9kZWJ1Zy5leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW50X25vZGU7XG4gICAgbm9kZVxuICA7O1xuXG4gIGxldCBjdXJyZW50bHlfcnVubmluZ19ub2RlX2V4biBzdGF0ZSBuYW1lID1cbiAgICBtYXRjaCBzdGF0ZS5vbmx5X2luX2RlYnVnLmN1cnJlbnRseV9ydW5uaW5nX25vZGUgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZV9zIFslc2V4cCAoXCJjYW4gb25seSBjYWxsIFwiIF4gbmFtZSBeIFwiIGR1cmluZyBzdGFiaWxpemF0aW9uXCIgOiBzdHJpbmcpXVxuICAgIHwgU29tZSBjdXJyZW50IC0+IGN1cnJlbnRcbiAgOztcblxuICAoKiBOb3RlIHRoYXQgdGhlIHR3byBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBub3Qgc3ltbWV0cmljIG9mIG9uZSBhbm90aGVyOiBpbiBbbGV0IHkgPVxuICAgICBtYXAgeF0sIFt4XSBpcyBhbHdheXMgYSBjaGlsZCBvZiBbeV0gKGFzc3VtaW5nIFt4XSBkb2Vzbid0IGJlY29tZSBpbnZhbGlkKSBidXQgW3ldIGluXG4gICAgIG9ubHkgYSBwYXJlbnQgb2YgW3hdIGlmIHkgaXMgbmVjZXNzYXJ5LiAqKVxuICBsZXQgYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBuYW1lID1cbiAgICBsZXQgKFQgY3VycmVudCkgPSBjdXJyZW50bHlfcnVubmluZ19ub2RlX2V4biBzdGF0ZSBuYW1lIGluXG4gICAgaWYgbm90IChOb2RlLmhhc19jaGlsZCBub2RlIH5jaGlsZDpjdXJyZW50KVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgKFwiY2FuIG9ubHkgY2FsbCBcIiBeIG5hbWUgXiBcIiBvbiBwYXJlbnQgbm9kZXNcIiA6IHN0cmluZylcbiAgICAgICAgLCB+fihub2RlLmtpbmQgOiBfIEtpbmQudClcbiAgICAgICAgLCB+fihjdXJyZW50LmtpbmQgOiBfIEtpbmQudCldXG4gIDs7XG5cbiAgbGV0IGFzc2VydF9jdXJyZW50bHlfcnVubmluZ19ub2RlX2lzX3BhcmVudCBzdGF0ZSBub2RlIG5hbWUgPVxuICAgIGxldCAoVCBjdXJyZW50KSA9IGN1cnJlbnRseV9ydW5uaW5nX25vZGVfZXhuIHN0YXRlIG5hbWUgaW5cbiAgICBpZiBub3QgKE5vZGUuaGFzX3BhcmVudCB+cGFyZW50OmN1cnJlbnQgbm9kZSlcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslc2V4cFxuICAgICAgICAgIChcImNhbiBvbmx5IGNhbGwgXCIgXiBuYW1lIF4gXCIgb24gY2hpbGRyZW4gbm9kZXNcIiA6IHN0cmluZylcbiAgICAgICAgLCB+fihub2RlLmtpbmQgOiBfIEtpbmQudClcbiAgICAgICAgLCB+fihjdXJyZW50LmtpbmQgOiBfIEtpbmQudCldXG4gIDs7XG5cbiAgbGV0IG1ha2Vfc3RhbGUgKG5vZGUgOiBfIE5vZGUudCkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcIm1ha2Vfc3RhbGVcIjtcbiAgICAgIGxldCBlID0gVW9wdC51bnNhZmVfdmFsdWUgZV9vcHQgaW5cbiAgICAgIG1hdGNoIEV4cGVydC5tYWtlX3N0YWxlIGUgd2l0aFxuICAgICAgfCBgQWxyZWFkeV9zdGFsZSAtPiAoKVxuICAgICAgfCBgT2sgLT5cbiAgICAgICAgaWYgTm9kZS5pc19uZWNlc3Nhcnkgbm9kZSAmJiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgICAgICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgc3RhdGUucmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgOztcblxuICBsZXQgaW52YWxpZGF0ZSAobm9kZSA6IF8gTm9kZS50KSA9XG4gICAgbGV0IHN0YXRlID0gbm9kZS5zdGF0ZSBpblxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcImludmFsaWRhdGVcIjtcbiAgICBpbnZhbGlkYXRlX25vZGUgbm9kZTtcbiAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSBzdGF0ZVxuICA7O1xuXG4gIGxldCBhZGRfZGVwZW5kZW5jeSAobm9kZSA6IF8gTm9kZS50KSAoZGVwIDogXyBFeHBlcnQuZWRnZSkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFtX3N0YWJpbGl6aW5nIHN0YXRlXG4gICAgICAgICYmIG5vdFxuICAgICAgICAgICAgIChMaXN0Lm1lbVxuICAgICAgICAgICAgICAgIH5lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAgICAgc3RhdGUub25seV9pbl9kZWJ1Zy5leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW50X25vZGVcbiAgICAgICAgICAgICAgICAoVCBub2RlKSlcbiAgICAgICAgdGhlbiBhc3NlcnRfY3VycmVudGx5X3J1bm5pbmdfbm9kZV9pc19jaGlsZCBzdGF0ZSBub2RlIFwiYWRkX2RlcGVuZGVuY3lcIjtcbiAgICAgIGxldCBlID0gVW9wdC51bnNhZmVfdmFsdWUgZV9vcHQgaW5cbiAgICAgIGxldCBuZXdfY2hpbGRfaW5kZXggPSBFeHBlcnQuYWRkX2NoaWxkX2VkZ2UgZSAoRSBkZXApIGluXG4gICAgICAoKiBbbm9kZV0gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgbmVjZXNzYXJ5LCBldmVuIGlmIHdlIGFyZSBydW5uaW5nIGluIGEgY2hpbGQgb2ZcbiAgICAgICAgIFtub2RlXSwgYmVjYXVzZSB3ZSBjb3VsZCBiZSBydW5uaW5nIGR1ZSB0byBhIHBhcmVudCBvdGhlciB0aGFuIFtub2RlXSBtYWtpbmcgdXNcbiAgICAgICAgIG5lY2Vzc2FyeS4gKilcbiAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRfcGFyZW50IH5jaGlsZDpkZXAuY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpuZXdfY2hpbGRfaW5kZXg7XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpO1xuICAgICAgICBpZiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgICAgICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgc3RhdGUucmVjb21wdXRlX2hlYXAgbm9kZSkpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9kZXBlbmRlbmN5IChub2RlIDogXyBOb2RlLnQpIChlZGdlIDogXyBFeHBlcnQuZWRnZSkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcInJlbW92ZV9kZXBlbmRlbmN5XCI7XG4gICAgICBsZXQgZSA9IFVvcHQudW5zYWZlX3ZhbHVlIGVfb3B0IGluXG4gICAgICAoKiBbbm9kZV0gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgbmVjZXNzYXJ5LCBmb3IgdGhlIHJlYXNvbiBzdGF0ZWQgaW5cbiAgICAgICAgIFthZGRfZGVwZW5kZW5jeV0gKilcbiAgICAgIGxldCBlZGdlX2luZGV4ID0gVW9wdC52YWx1ZV9leG4gZWRnZS5pbmRleCBpblxuICAgICAgbGV0IChFIGxhc3RfZWRnZSkgPSBFeHBlcnQubGFzdF9jaGlsZF9lZGdlX2V4biBlIGluXG4gICAgICBsZXQgbGFzdF9lZGdlX2luZGV4ID0gVW9wdC52YWx1ZV9leG4gbGFzdF9lZGdlLmluZGV4IGluXG4gICAgICBpZiBlZGdlX2luZGV4IDw+IGxhc3RfZWRnZV9pbmRleFxuICAgICAgdGhlbiAoXG4gICAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgICAgdGhlblxuICAgICAgICAgIE5vZGUuc3dhcF9jaGlsZHJlbl9leGNlcHRfaW5fa2luZFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgfmNoaWxkMTplZGdlLmNoaWxkXG4gICAgICAgICAgICB+Y2hpbGRfaW5kZXgxOmVkZ2VfaW5kZXhcbiAgICAgICAgICAgIH5jaGlsZDI6bGFzdF9lZGdlLmNoaWxkXG4gICAgICAgICAgICB+Y2hpbGRfaW5kZXgyOmxhc3RfZWRnZV9pbmRleDtcbiAgICAgICAgRXhwZXJ0LnN3YXBfY2hpbGRyZW4gZSB+Y2hpbGRfaW5kZXgxOmVkZ2VfaW5kZXggfmNoaWxkX2luZGV4MjpsYXN0X2VkZ2VfaW5kZXg7XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gTm9kZS5pbnZhcmlhbnQgaWdub3JlIG5vZGUpO1xuICAgICAgRXhwZXJ0LnJlbW92ZV9sYXN0X2NoaWxkX2VkZ2VfZXhuIGU7XG4gICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19zdGFsZSBub2RlKTtcbiAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVfY2hpbGQgfmNoaWxkOmVkZ2UuY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpsYXN0X2VkZ2VfaW5kZXg7XG4gICAgICAgIGlmIG5vdCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlKVxuICAgICAgICB0aGVuIFJlY29tcHV0ZV9oZWFwLmFkZCBzdGF0ZS5yZWNvbXB1dGVfaGVhcCBub2RlO1xuICAgICAgICBpZiBub3QgKE5vZGUuaXNfdmFsaWQgZWRnZS5jaGlsZCkgdGhlbiBFeHBlcnQuZGVjcl9pbnZhbGlkX2NoaWxkcmVuIGUpKVxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIERlcGVuZGVuY3kgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRXhwZXJ0LmVkZ2UgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID8ob25fY2hhbmdlID0gaWdub3JlKSBjaGlsZCA6IF8gdCA9IHsgY2hpbGQ7IG9uX2NoYW5nZTsgaW5kZXggPSBVb3B0Lm5vbmUgfVxuXG4gIGxldCB2YWx1ZSAodCA6IF8gdCkgPVxuICAgIGxldCBzdGF0ZSA9IHQuY2hpbGQuc3RhdGUgaW5cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIFN0YXRlLkV4cGVydC5hc3NlcnRfY3VycmVudGx5X3J1bm5pbmdfbm9kZV9pc19wYXJlbnRcbiAgICAgICAgc3RhdGVcbiAgICAgICAgdC5jaGlsZFxuICAgICAgICBcIkRlcGVuZGVuY3kudmFsdWVcIjtcbiAgICAoKiBOb3QgZXhwb3NpbmcgdGhlIF9leG4sIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhZHZlcnRpc2VkIGFzIGJlaW5nIHVzYWJsZSBvbmx5XG4gICAgICAgaW5zaWRlIHRoZSBjYWxsYmFja3Mgb2YgcGFyZW50cywgd2hlcmUgaXQgd2lsbCBub3QgcmFpc2UuICopXG4gICAgTm9kZS52YWx1ZV9leG4gdC5jaGlsZFxuICA7O1xuZW5kXG5cbm1vZHVsZSBOb2RlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBOb2RlLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlIHN0YXRlID8ob25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgPSBmdW4gfmlzX25vd19vYnNlcnZhYmxlOl8gLT4gKCkpIGYgPVxuICAgIFN0YXRlLkV4cGVydC5jcmVhdGUgc3RhdGUgfm9uX29ic2VydmFiaWxpdHlfY2hhbmdlIGZcbiAgOztcblxuICBsZXQgbWFrZV9zdGFsZSA9IFN0YXRlLkV4cGVydC5tYWtlX3N0YWxlXG4gIGxldCB3YXRjaCA9IEZuLmlkXG4gIGxldCBpbnZhbGlkYXRlID0gU3RhdGUuRXhwZXJ0LmludmFsaWRhdGVcbiAgbGV0IGFkZF9kZXBlbmRlbmN5ID0gU3RhdGUuRXhwZXJ0LmFkZF9kZXBlbmRlbmN5XG4gIGxldCByZW1vdmVfZGVwZW5kZW5jeSA9IFN0YXRlLkV4cGVydC5yZW1vdmVfZGVwZW5kZW5jeVxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubGV0IGNyZWF0ZSBzdGF0ZSBjaGlsZHJlbiB+ZiB+cmVkdWNlID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBjaGlsZHJlbiBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVkdWNlciA9IEJhbGFuY2VkX3JlZHVjZXIuY3JlYXRlX2V4biAoKSB+bGVuIH5yZWR1Y2UgaW5cbiAgICBpZiBkZWJ1ZyB0aGVuIEJhbGFuY2VkX3JlZHVjZXIuaW52YXJpYW50IChjb25zdCAoKSkgcmVkdWNlcjtcbiAgICBsZXQgbm9kZSA9XG4gICAgICBFeHBlcnQxLk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGEgPSBCYWxhbmNlZF9yZWR1Y2VyLmNvbXB1dGVfZXhuIHJlZHVjZXIgaW5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBCYWxhbmNlZF9yZWR1Y2VyLmludmFyaWFudCAoY29uc3QgKCkpIHJlZHVjZXI7XG4gICAgICAgIGEpXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgRXhwZXJ0MS5Ob2RlLmFkZF9kZXBlbmRlbmN5XG4gICAgICAgIG5vZGVcbiAgICAgICAgKEV4cGVydDEuRGVwZW5kZW5jeS5jcmVhdGUgY2hpbGRyZW4uKGkpIH5vbl9jaGFuZ2U6KGZ1biBhIC0+XG4gICAgICAgICAgIEJhbGFuY2VkX3JlZHVjZXIuc2V0X2V4biByZWR1Y2VyIGkgKGYgYSk7XG4gICAgICAgICAgIGlmIGRlYnVnIHRoZW4gQmFsYW5jZWRfcmVkdWNlci5pbnZhcmlhbnQgKGNvbnN0ICgpKSByZWR1Y2VyKSlcbiAgICBkb25lO1xuICAgIFNvbWUgKEV4cGVydDEuTm9kZS53YXRjaCBub2RlKSlcbjs7XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBtb3N0bHkgYSB3cmFwcGVyIGFyb3VuZCBbU3RhdGVdIGZ1bmN0aW9ucy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluY3JlbWVudGFsX2ludGZcblxubW9kdWxlIHR5cGUgSW5jcmVtZW50YWxfY29uZmlnID0gQ29uZmlnLkluY3JlbWVudGFsX2NvbmZpZ1xuXG5tb2R1bGUgQ29uZmlnID0gQ29uZmlnXG5cbmxldCBkZWZhdWx0X21heF9oZWlnaHRfYWxsb3dlZCA9IDEyOFxuXG5tb2R1bGUgR2VuZXJpYyA9IHN0cnVjdFxuICBtb2R1bGUgQ3V0b2ZmID0gQ3V0b2ZmXG4gIG1vZHVsZSBTdGVwX2Z1bmN0aW9uID0gU3RlcF9mdW5jdGlvblxuXG4gIG1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU3RhdGVcblxuICAgIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICAgIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICB2YWwgdCA6IHRcbiAgICBlbmRcblxuICAgIGxldCBjcmVhdGVfaW50ZXJuYWwgPSBjcmVhdGVcblxuICAgIGxldCBjcmVhdGUgPyhtYXhfaGVpZ2h0X2FsbG93ZWQgPSBkZWZhdWx0X21heF9oZWlnaHRfYWxsb3dlZCkgKCkgOiAobW9kdWxlIFMpID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICAgIGxldCB0ID0gY3JlYXRlIChtb2R1bGUgQ29uZmlnLkRlZmF1bHQgKCkpIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgU2NvcGUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNjb3BlXG5cbiAgICBsZXQgY3VycmVudCAoc3RhdGUgOiBTdGF0ZS50KSAoKSA9IHN0YXRlLmN1cnJlbnRfc2NvcGVcbiAgICBsZXQgd2l0aGluIHN0YXRlIHQgfmYgPSBTdGF0ZS53aXRoaW5fc2NvcGUgc3RhdGUgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE5vZGVcblxuICBsZXQgc3RhdGUgdCA9IHQuc3RhdGVcbiAgbGV0IHBhY2sgdCA9IFBhY2tlZC5UIHRcbiAgbGV0IGNvbnN0IHN0YXRlIGEgPSBTdGF0ZS5jb25zdCBzdGF0ZSBhXG4gIGxldCByZXR1cm4gPSBjb25zdFxuICBsZXQgb2JzZXJ2ZSA9IFN0YXRlLmNyZWF0ZV9vYnNlcnZlclxuICBsZXQgbWFwID0gU3RhdGUubWFwXG4gIGxldCBiaW5kID0gU3RhdGUuYmluZFxuXG4gIG1vZHVsZSBOX2FyeV9tYXBfYW5kX2JpbmQgPSBzdHJ1Y3RcbiAgICBsZXQgbWFwMiA9IFN0YXRlLm1hcDJcbiAgICBsZXQgbWFwMyA9IFN0YXRlLm1hcDNcbiAgICBsZXQgbWFwNCA9IFN0YXRlLm1hcDRcbiAgICBsZXQgbWFwNSA9IFN0YXRlLm1hcDVcbiAgICBsZXQgbWFwNiA9IFN0YXRlLm1hcDZcbiAgICBsZXQgbWFwNyA9IFN0YXRlLm1hcDdcbiAgICBsZXQgbWFwOCA9IFN0YXRlLm1hcDhcbiAgICBsZXQgbWFwOSA9IFN0YXRlLm1hcDlcbiAgICBsZXQgbWFwMTAgPSBTdGF0ZS5tYXAxMFxuICAgIGxldCBtYXAxMSA9IFN0YXRlLm1hcDExXG4gICAgbGV0IG1hcDEyID0gU3RhdGUubWFwMTJcbiAgICBsZXQgbWFwMTMgPSBTdGF0ZS5tYXAxM1xuICAgIGxldCBtYXAxNCA9IFN0YXRlLm1hcDE0XG4gICAgbGV0IG1hcDE1ID0gU3RhdGUubWFwMTVcbiAgICBsZXQgYmluZDIgPSBTdGF0ZS5iaW5kMlxuICAgIGxldCBiaW5kMyA9IFN0YXRlLmJpbmQzXG4gICAgbGV0IGJpbmQ0ID0gU3RhdGUuYmluZDRcbiAgZW5kXG5cbiAgaW5jbHVkZSBOX2FyeV9tYXBfYW5kX2JpbmRcblxuICBtb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIEluZml4XG5cbiAgbGV0IGpvaW4gPSBTdGF0ZS5qb2luXG4gIGxldCBpZl8gPSBTdGF0ZS5pZl9cbiAgbGV0IGxhenlfZnJvbV9mdW4gc3RhdGUgZiA9IFN0YXRlLmxhenlfZnJvbV9mdW4gc3RhdGUgfmZcbiAgbGV0IGRlZmF1bHRfaGFzaF90YWJsZV9pbml0aWFsX3NpemUgPSBTdGF0ZS5kZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplXG4gIGxldCBtZW1vaXplX2Z1bl9ieV9rZXkgPSBTdGF0ZS5tZW1vaXplX2Z1bl9ieV9rZXlcblxuICBsZXQgbWVtb2l6ZV9mdW4gP2luaXRpYWxfc2l6ZSBzdGF0ZSBoYXNoYWJsZSBmID1cbiAgICBtZW1vaXplX2Z1bl9ieV9rZXkgc3RhdGUgP2luaXRpYWxfc2l6ZSBoYXNoYWJsZSBGbi5pZCBmXG4gIDs7XG5cbiAgbGV0IGFycmF5X2ZvbGQgc3RhdGUgdHMgfmluaXQgfmYgPSBTdGF0ZS5hcnJheV9mb2xkIHN0YXRlIHRzIH5pbml0IH5mXG4gIGxldCByZWR1Y2VfYmFsYW5jZWQgc3RhdGUgdHMgfmYgfnJlZHVjZSA9IFJlZHVjZV9iYWxhbmNlZC5jcmVhdGUgc3RhdGUgdHMgfmYgfnJlZHVjZVxuXG4gIG1vZHVsZSBVbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGUgPSBTdGF0ZS5Vbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGVcblxuICBsZXQgdW5vcmRlcmVkX2FycmF5X2ZvbGQgPSBTdGF0ZS51bm9yZGVyZWRfYXJyYXlfZm9sZFxuICBsZXQgb3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkID0gU3RhdGUub3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkXG4gIGxldCBhbGwgPSBTdGF0ZS5hbGxcbiAgbGV0IGV4aXN0cyA9IFN0YXRlLmV4aXN0c1xuICBsZXQgZm9yX2FsbCA9IFN0YXRlLmZvcl9hbGxcbiAgbGV0IGJvdGggPSBTdGF0ZS5ib3RoXG4gIGxldCBzdW0gPSBTdGF0ZS5zdW1cbiAgbGV0IG9wdF9zdW0gPSBTdGF0ZS5vcHRfc3VtXG4gIGxldCBzdW1faW50ID0gU3RhdGUuc3VtX2ludFxuICBsZXQgc3VtX2Zsb2F0ID0gU3RhdGUuc3VtX2Zsb2F0XG5cbiAgbW9kdWxlIFZhciA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVmFyXG5cbiAgICBsZXQgY3JlYXRlID0gU3RhdGUuY3JlYXRlX3ZhclxuICAgIGxldCBzZXQgPSBTdGF0ZS5zZXRfdmFyXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IHdhdGNoIHQgPSB0LndhdGNoXG5cbiAgICAoKiBXZSBvdmVycmlkZSBbc2V4cF9vZl90XSB0byBqdXN0IHNob3cgdGhlIHZhbHVlLCByYXRoZXIgdGhhbiB0aGUgaW50ZXJuYWxcbiAgICAgICByZXByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gdC52YWx1ZSB8PiBbJXNleHBfb2Y6IGFdXG4gICAgbGV0IHJlcGxhY2UgdCB+ZiA9IHNldCB0IChmIChsYXRlc3RfdmFsdWUgdCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBPYnNlcnZlciA9IHN0cnVjdFxuICAgIGluY2x1ZGUgT2JzZXJ2ZXJcblxuICAgIG1vZHVsZSBVcGRhdGUgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIHwgSW5pdGlhbGl6ZWQgb2YgJ2FcbiAgICAgICAgfCBDaGFuZ2VkIG9mICdhICogJ2FcbiAgICAgICAgfCBJbnZhbGlkYXRlZFxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIGxldCBvbl91cGRhdGVfZXhuIHQgfihmIDogXyBVcGRhdGUudCAtPiB1bml0KSA9XG4gICAgICBTdGF0ZS5vYnNlcnZlcl9vbl91cGRhdGVfZXhuIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTmVjZXNzYXJ5IGEgLT4gZiAoSW5pdGlhbGl6ZWQgYSlcbiAgICAgICAgfCBDaGFuZ2VkIChhMSwgYTIpIC0+IGYgKENoYW5nZWQgKGExLCBhMikpXG4gICAgICAgIHwgSW52YWxpZGF0ZWQgLT4gZiBJbnZhbGlkYXRlZFxuICAgICAgICB8IFVubmVjZXNzYXJ5IC0+XG4gICAgICAgICAgZmFpbHdpdGhzXG4gICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICBcIkluY3JlbWVudGFsIGJ1ZyAtLSBPYnNlcnZlci5vbl91cGRhdGVfZXhuIGdvdCB1bmV4cGVjdGVkIHVwZGF0ZSBcXFxuICAgICAgICAgICAgIFVubmVjZXNzYXJ5XCJcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIFslc2V4cF9vZjogXyB0XSlcbiAgICA7O1xuXG4gICAgbGV0IGRpc2FsbG93X2Z1dHVyZV91c2UgdCA9IFN0YXRlLmRpc2FsbG93X2Z1dHVyZV91c2UgIXRcbiAgICBsZXQgdmFsdWUgPSBTdGF0ZS5vYnNlcnZlcl92YWx1ZVxuICAgIGxldCB2YWx1ZV9leG4gPSBTdGF0ZS5vYnNlcnZlcl92YWx1ZV9leG5cblxuICAgICgqIFdlIG92ZXJyaWRlIFtzZXhwX29mX3RdIHRvIGp1c3Qgc2hvdyB0aGUgdmFsdWUsIHJhdGhlciB0aGFuIHRoZSBpbnRlcm5hbFxuICAgICAgIHJlcHJlc2VudGF0aW9uLiAqKVxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hICh0IDogXyB0KSA9XG4gICAgICBtYXRjaCAhdC5zdGF0ZSB3aXRoXG4gICAgICB8IENyZWF0ZWQgLT4gWyVtZXNzYWdlIFwiPHVuc3RhYmlsaXplZD5cIl1cbiAgICAgIHwgRGlzYWxsb3dlZCB8IFVubGlua2VkIC0+IFslbWVzc2FnZSBcIjxkaXNhbGxvd2VkPlwiXVxuICAgICAgfCBJbl91c2UgLT5cbiAgICAgICAgbGV0IHVvcHQgPSAhdC5vYnNlcnZpbmcudmFsdWVfb3B0IGluXG4gICAgICAgIGlmIFVvcHQuaXNfbm9uZSB1b3B0XG4gICAgICAgIHRoZW4gWyVtZXNzYWdlIFwiPGludmFsaWQ+XCJdXG4gICAgICAgIGVsc2UgWyVzZXhwIChVb3B0LnVuc2FmZV92YWx1ZSB1b3B0IDogYSldXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEJlZm9yZV9vcl9hZnRlciA9IEJlZm9yZV9vcl9hZnRlclxuXG4gIG1vZHVsZSBDbG9jayA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU3RhdGUuQ2xvY2tcblxuICAgIGxldCBzdGF0ZSA9IGluY3Jfc3RhdGVcblxuICAgIGxldCBkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWcgPVxuICAgICAgbGV0IGFsYXJtX3ByZWNpc2lvbiA9IEFsYXJtX3ByZWNpc2lvbi5hYm91dF9vbmVfbWlsbGlzZWNvbmQgaW5cbiAgICAgIGxldCBsZXZlbF9iaXRzID0gWyAxNDsgMTM7IDUgXSBpblxuICAgICAgVGltaW5nX3doZWVsLkNvbmZpZy5jcmVhdGVcbiAgICAgICAgfmFsYXJtX3ByZWNpc2lvblxuICAgICAgICB+bGV2ZWxfYml0czpcbiAgICAgICAgICAoVGltaW5nX3doZWVsLkxldmVsX2JpdHMuY3JlYXRlX2V4biBsZXZlbF9iaXRzIH5leHRlbmRfdG9fbWF4X251bV9iaXRzOnRydWUpXG4gICAgICAgICgpXG4gICAgOztcblxuICAgIGxldCBjcmVhdGUgc3RhdGUgPyh0aW1pbmdfd2hlZWxfY29uZmlnID0gZGVmYXVsdF90aW1pbmdfd2hlZWxfY29uZmlnKSB+c3RhcnQgKCkgPVxuICAgICAgKCogTWFrZSBzdXJlIFtzdGFydF0gaXMgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBtaWNyb3NlY29uZC4gIE90aGVyd2lzZSwgaWYgeW91XG4gICAgICAgICBmZWVkIFtDbG9jay5ub3cgKCldIHRvIGEgdGltZSBmdW5jdGlvbiwgaXQgY2FuIGJlIHJvdW5kZWQgZG93biB0byBhIHRpbWUgaW5cbiAgICAgICAgIHRoZSBwYXN0LCBjYXVzaW5nIGVycm9ycy4gKilcbiAgICAgIGxldCBzdGFydCA9XG4gICAgICAgIFRpbWVfbnMub2ZfdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0X21pY3Jvc2Vjb25kXG4gICAgICAgICAgKFRpbWVfbnMudG9fdGltZV9mbG9hdF9yb3VuZF9uZWFyZXN0X21pY3Jvc2Vjb25kIHN0YXJ0KVxuICAgICAgaW5cbiAgICAgIFN0YXRlLmNyZWF0ZV9jbG9jayBzdGF0ZSB+dGltaW5nX3doZWVsX2NvbmZpZyB+c3RhcnRcbiAgICA7O1xuXG4gICAgbGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiB0LnRpbWluZ193aGVlbFxuICAgIGxldCB0aW1pbmdfd2hlZWxfbGVuZ3RoID0gU3RhdGUudGltaW5nX3doZWVsX2xlbmd0aFxuICAgIGxldCBub3cgPSBTdGF0ZS5ub3dcbiAgICBsZXQgd2F0Y2hfbm93IHQgPSB0Lm5vdy53YXRjaFxuICAgIGxldCBhdCA9IFN0YXRlLmF0XG4gICAgbGV0IGFmdGVyID0gU3RhdGUuYWZ0ZXJcbiAgICBsZXQgYXRfaW50ZXJ2YWxzID0gU3RhdGUuYXRfaW50ZXJ2YWxzXG4gICAgbGV0IGFkdmFuY2VfY2xvY2sgPSBTdGF0ZS5hZHZhbmNlX2Nsb2NrXG4gICAgbGV0IGFkdmFuY2VfY2xvY2tfYnkgdCBzcGFuID0gYWR2YW5jZV9jbG9jayB0IH50b186KFRpbWVfbnMuYWRkIChub3cgdCkgc3BhbilcbiAgICBsZXQgaW5jcmVtZW50YWxfc3RlcF9mdW5jdGlvbiA9IFN0YXRlLmluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb25cblxuICAgIGxldCBzdGVwX2Z1bmN0aW9uIHQgfmluaXQgc3RlcHMgPVxuICAgICAgaW5jcmVtZW50YWxfc3RlcF9mdW5jdGlvblxuICAgICAgICB0XG4gICAgICAgIChjb25zdCAoaW5jcl9zdGF0ZSB0KSAoU3RlcF9mdW5jdGlvbi5jcmVhdGVfZXhuIH5pbml0IH5zdGVwcykpXG4gICAgOztcblxuICAgIGxldCBzbmFwc2hvdCA9IFN0YXRlLnNuYXBzaG90XG4gIGVuZFxuXG4gIGxldCBmcmVlemUgPyh3aGVuXyA9IGZ1biBfIC0+IHRydWUpIHQgPSBTdGF0ZS5mcmVlemUgdCB+b25seV9mcmVlemVfd2hlbjp3aGVuX1xuICBsZXQgZGVwZW5kX29uIHQgfmRlcGVuZF9vbiA9IFN0YXRlLmRlcGVuZF9vbiB0IH5kZXBlbmRfb25cbiAgbGV0IG5lY2Vzc2FyeV9pZl9hbGl2ZSA9IFN0YXRlLm5lY2Vzc2FyeV9pZl9hbGl2ZVxuXG4gIG1vZHVsZSBVcGRhdGUgPSBPbl91cGRhdGVfaGFuZGxlci5Ob2RlX3VwZGF0ZVxuXG4gIGxldCBvbl91cGRhdGUgPSBTdGF0ZS5ub2RlX29uX3VwZGF0ZVxuICBsZXQgc3RhYmlsaXplIHN0YXRlID0gU3RhdGUuc3RhYmlsaXplIHN0YXRlXG4gIGxldCBhbV9zdGFiaWxpemluZyBzdGF0ZSA9IFN0YXRlLmFtX3N0YWJpbGl6aW5nIHN0YXRlXG4gIGxldCBzYXZlX2RvdCA9IFN0YXRlLnNhdmVfZG90XG4gIGxldCBzYXZlX2RvdF90b19maWxlID0gU3RhdGUuc2F2ZV9kb3RfdG9fZmlsZVxuXG4gIG1vZHVsZSBOb2RlX3ZhbHVlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHwgSW52YWxpZFxuICAgICAgfCBOZWNlc3NhcnlfbWF5YmVfc3RhbGUgb2YgJ2Egb3B0aW9uXG4gICAgICB8IFVubmVjZXNzYXJ5X21heWJlX3N0YWxlIG9mICdhIG9wdGlvblxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBub2RlX3ZhbHVlIHQgOiBfIE5vZGVfdmFsdWUudCA9XG4gICAgaWYgbm90IChpc192YWxpZCB0KVxuICAgIHRoZW4gSW52YWxpZFxuICAgIGVsc2UgaWYgaXNfbmVjZXNzYXJ5IHRcbiAgICB0aGVuIE5lY2Vzc2FyeV9tYXliZV9zdGFsZSAoVW9wdC50b19vcHRpb24gdC52YWx1ZV9vcHQpXG4gICAgZWxzZSBVbm5lY2Vzc2FyeV9tYXliZV9zdGFsZSAoVW9wdC50b19vcHRpb24gdC52YWx1ZV9vcHQpXG4gIDs7XG5cbiAgKCogV2Ugb3ZlcnJpZGUgW3NleHBfb2ZfdF0gdG8gc2hvdyBqdXN0IHRoZSB2YWx1ZSwgcmF0aGVyIHRoYW4gdGhlIGludGVybmFsXG4gICAgIHJlcHJlc2VudGF0aW9uLiAgV2Ugb25seSBzaG93IHRoZSB2YWx1ZSBpZiBpdCBpcyBuZWNlc3NhcnkgYW5kIHZhbGlkLiAqKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBpZiBub3QgKGlzX3ZhbGlkIHQpXG4gICAgdGhlbiBcIjxpbnZhbGlkPlwiIHw+IFslc2V4cF9vZjogc3RyaW5nXVxuICAgIGVsc2UgaWYgbm90IChpc19uZWNlc3NhcnkgdClcbiAgICB0aGVuIFwiPHVubmVjZXNzYXJ5PlwiIHw+IFslc2V4cF9vZjogc3RyaW5nXVxuICAgIGVsc2UgaWYgVW9wdC5pc19ub25lIHQudmFsdWVfb3B0XG4gICAgdGhlbiBcIjx1bmNvbXB1dGVkPlwiIHw+IFslc2V4cF9vZjogc3RyaW5nXVxuICAgIGVsc2UgdW5zYWZlX3ZhbHVlIHQgfD4gWyVzZXhwX29mOiBhXVxuICA7O1xuXG4gIG1vZHVsZSBFeHBlcnQgPSBFeHBlcnQxXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCB0MSB0MiA9IG1hcDIgdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpXG5cbiAgICAgIGluY2x1ZGUgTl9hcnlfbWFwX2FuZF9iaW5kXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdFxuICAgICAgICBsZXQgd2F0Y2ggPSBWYXIud2F0Y2hcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBsZXQgd2Vha19tZW1vaXplX2Z1bl9ieV9rZXkgPSBTdGF0ZS53ZWFrX21lbW9pemVfZnVuX2J5X2tleVxuXG4gIGxldCB3ZWFrX21lbW9pemVfZnVuID9pbml0aWFsX3NpemUgc3RhdGUgaGFzaGFibGUgZiA9XG4gICAgd2Vha19tZW1vaXplX2Z1bl9ieV9rZXkgP2luaXRpYWxfc2l6ZSBzdGF0ZSBoYXNoYWJsZSBGbi5pZCBmXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2Vfd2l0aF9jb25maWcgKEluY3JlbWVudGFsX2NvbmZpZyA6IEluY3JlbWVudGFsX2NvbmZpZykgKCkgPSBzdHJ1Y3RcbiAgdHlwZSBzdGF0ZV93aXRuZXNzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbW9kdWxlIFN0YXRlID0gc3RydWN0XG4gICAgaW5jbHVkZSBTdGF0ZVxuXG4gICAgbGV0IHQgPSBjcmVhdGVfaW50ZXJuYWwgKG1vZHVsZSBJbmNyZW1lbnRhbF9jb25maWcpIH5tYXhfaGVpZ2h0X2FsbG93ZWQ6MTI4XG4gIGVuZFxuXG4gIG1vZHVsZSBDbG9jayA9IHN0cnVjdFxuICAgIGluY2x1ZGUgQ2xvY2tcblxuICAgIGxldCBjcmVhdGUgP3RpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0ICgpID1cbiAgICAgIGNyZWF0ZSA/dGltaW5nX3doZWVsX2NvbmZpZyBTdGF0ZS50IH5zdGFydCAoKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEV4cGVydFxuXG4gICAgbW9kdWxlIE5vZGUgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTm9kZVxuXG4gICAgICBsZXQgY3JlYXRlID9vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZSBmID0gY3JlYXRlIFN0YXRlLnQgP29uX29ic2VydmFiaWxpdHlfY2hhbmdlIGZcbiAgICBlbmRcblxuICAgIG1vZHVsZSBTdGVwX3Jlc3VsdCA9IFN0YXRlLlN0ZXBfcmVzdWx0XG5cbiAgICBsZXQgZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplICgpID0gU3RhdGUuZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplIFN0YXRlLnRcbiAgZW5kXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIExldF9zeW50YXhcblxuICAgIGxldCByZXR1cm4gYSA9IHJldHVybiBTdGF0ZS50IGFcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBpbmNsdWRlIExldF9zeW50YXhcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGVuZFxuICBlbmRcblxuICBtb2R1bGUgU2NvcGUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNjb3BlXG5cbiAgICBsZXQgY3VycmVudCAoKSA9IGN1cnJlbnQgU3RhdGUudCAoKVxuICAgIGxldCB3aXRoaW4gdCB+ZiA9IHdpdGhpbiBTdGF0ZS50IHQgfmZcbiAgZW5kXG5cbiAgbW9kdWxlIFZhciA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVmFyXG5cbiAgICBsZXQgY3JlYXRlID91c2VfY3VycmVudF9zY29wZSB2YWx1ZSA9IGNyZWF0ZSA/dXNlX2N1cnJlbnRfc2NvcGUgU3RhdGUudCB2YWx1ZVxuICBlbmRcblxuICBsZXQgY29uc3QgYSA9IGNvbnN0IFN0YXRlLnQgYVxuICBsZXQgcmV0dXJuIGEgPSByZXR1cm4gU3RhdGUudCBhXG4gIGxldCBhbGwgdHMgPSBhbGwgU3RhdGUudCB0c1xuICBsZXQgZXhpc3RzIHRzID0gZXhpc3RzIFN0YXRlLnQgdHNcbiAgbGV0IGZvcl9hbGwgdHMgPSBmb3JfYWxsIFN0YXRlLnQgdHNcbiAgbGV0IGxhenlfZnJvbV9mdW4gc3RhdGUgZiA9IFN0YXRlLmxhenlfZnJvbV9mdW4gc3RhdGUgfmZcblxuICBsZXQgbWVtb2l6ZV9mdW5fYnlfa2V5ID9pbml0aWFsX3NpemUgaGFzaGFibGUgcHJvamVjdF9rZXkgZiA9XG4gICAgbWVtb2l6ZV9mdW5fYnlfa2V5ID9pbml0aWFsX3NpemUgU3RhdGUudCBoYXNoYWJsZSBwcm9qZWN0X2tleSBmXG4gIDs7XG5cbiAgbGV0IG1lbW9pemVfZnVuID9pbml0aWFsX3NpemUgaGFzaGFibGUgZiA9IG1lbW9pemVfZnVuID9pbml0aWFsX3NpemUgU3RhdGUudCBoYXNoYWJsZSBmXG4gIGxldCBhcnJheV9mb2xkIHRzIH5pbml0IH5mID0gYXJyYXlfZm9sZCBTdGF0ZS50IHRzIH5pbml0IH5mXG4gIGxldCByZWR1Y2VfYmFsYW5jZWQgdHMgfmYgfnJlZHVjZSA9IHJlZHVjZV9iYWxhbmNlZCBTdGF0ZS50IHRzIH5mIH5yZWR1Y2VcblxuICBsZXQgdW5vcmRlcmVkX2FycmF5X2ZvbGQgP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgdHMgfmluaXQgfmYgfnVwZGF0ZSA9XG4gICAgdW5vcmRlcmVkX2FycmF5X2ZvbGQgU3RhdGUudCB0cyB+aW5pdCB+ZiB+dXBkYXRlID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG4gIDs7XG5cbiAgbGV0IG9wdF91bm9yZGVyZWRfYXJyYXlfZm9sZCA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyB0cyB+aW5pdCB+ZiB+Zl9pbnZlcnNlID1cbiAgICBvcHRfdW5vcmRlcmVkX2FycmF5X2ZvbGQgP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgU3RhdGUudCB0cyB+aW5pdCB+ZiB+Zl9pbnZlcnNlXG4gIDs7XG5cbiAgbGV0IHN1bSA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyB0cyB+emVybyB+YWRkIH5zdWIgPVxuICAgIHN1bSA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyBTdGF0ZS50IHRzIH56ZXJvIH5hZGQgfnN1YlxuICA7O1xuXG4gIGxldCBvcHRfc3VtID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIHRzIH56ZXJvIH5hZGQgfnN1YiA9XG4gICAgb3B0X3N1bSA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyBTdGF0ZS50IHRzIH56ZXJvIH5hZGQgfnN1YlxuICA7O1xuXG4gIGxldCBzdW1faW50IHRzID0gc3VtX2ludCBTdGF0ZS50IHRzXG4gIGxldCBzdW1fZmxvYXQgdHMgPSBzdW1fZmxvYXQgU3RhdGUudCB0c1xuICBsZXQgc3RhYmlsaXplICgpID0gc3RhYmlsaXplIFN0YXRlLnRcbiAgbGV0IGFtX3N0YWJpbGl6aW5nICgpID0gYW1fc3RhYmlsaXppbmcgU3RhdGUudFxuICBsZXQgc2F2ZV9kb3Qgb3V0ID0gc2F2ZV9kb3QgU3RhdGUudCBvdXRcbiAgbGV0IHNhdmVfZG90X3RvX2ZpbGUgZmlsZSA9IE91dF9jaGFubmVsLndpdGhfZmlsZSBmaWxlIH5mOnNhdmVfZG90XG4gIGxldCBsYXp5X2Zyb21fZnVuIGYgPSBsYXp5X2Zyb21fZnVuIFN0YXRlLnQgZlxuXG4gIGxldCB3ZWFrX21lbW9pemVfZnVuX2J5X2tleSA/aW5pdGlhbF9zaXplIGhhc2hhYmxlIHByb2plY3Rfa2V5IGYgPVxuICAgIHdlYWtfbWVtb2l6ZV9mdW5fYnlfa2V5ID9pbml0aWFsX3NpemUgU3RhdGUudCBoYXNoYWJsZSBwcm9qZWN0X2tleSBmXG4gIDs7XG5cbiAgbGV0IHdlYWtfbWVtb2l6ZV9mdW4gP2luaXRpYWxfc2l6ZSBoYXNoYWJsZSBmID1cbiAgICB3ZWFrX21lbW9pemVfZnVuID9pbml0aWFsX3NpemUgU3RhdGUudCBoYXNoYWJsZSBmXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKCkgPSBNYWtlX3dpdGhfY29uZmlnIChDb25maWcuRGVmYXVsdCAoKSkgKClcbmluY2x1ZGUgR2VuZXJpY1xuXG5tb2R1bGUgQWRkX3dpdG5lc3MwIChNIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIEludmFyaWFudC5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kKSA6IHNpZ1xuICB0eXBlICd3IHQgPSBNLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAndyB0ID0gTS50XG5cbiAgbGV0IGludmFyaWFudCBfIHQgPSBNLmludmFyaWFudCB0XG4gIGxldCBzZXhwX29mX3QgXyB0ID0gTS5zZXhwX29mX3QgdFxuZW5kXG5cbm1vZHVsZSBBZGRfd2l0bmVzczEgKE0gOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgZW5kKSA6IHNpZ1xuICB0eXBlICgnYSwgJ3cpIHQgPSAnYSBNLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICd3KSB0ID0gJ2EgTS50XG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPSBNLmludmFyaWFudCBpbnZhcmlhbnRfYSB0XG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IE0uc2V4cF9vZl90IHNleHBfb2ZfYSB0XG5lbmRcblxubW9kdWxlIENsb2NrID0gc3RydWN0XG4gIGluY2x1ZGUgQ2xvY2tcbiAgaW5jbHVkZSBBZGRfd2l0bmVzczAgKENsb2NrKVxuZW5kXG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBFeHBlcnRcblxuICBtb2R1bGUgRGVwZW5kZW5jeSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRGVwZW5kZW5jeVxuXG4gICAgaW5jbHVkZSBBZGRfd2l0bmVzczEgKHN0cnVjdFxuICAgICAgICBpbmNsdWRlIERlcGVuZGVuY3lcblxuICAgICAgICBsZXQgaW52YXJpYW50IF8gXyA9ICgpXG4gICAgICBlbmQpXG4gIGVuZFxuXG4gIG1vZHVsZSBOb2RlID0gc3RydWN0XG4gICAgaW5jbHVkZSBOb2RlXG5cbiAgICBpbmNsdWRlIEFkZF93aXRuZXNzMSAoc3RydWN0XG4gICAgICAgIGluY2x1ZGUgTm9kZVxuXG4gICAgICAgIGxldCBpbnZhcmlhbnQgXyBfID0gKClcbiAgICAgIGVuZClcbiAgZW5kXG5cbiAgbW9kdWxlIFN0ZXBfcmVzdWx0ID0gU3RhdGUuU3RlcF9yZXN1bHRcblxuICBsZXQgZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplIHN0YXRlID0gU3RhdGUuZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplIHN0YXRlXG5lbmRcblxubW9kdWxlIE5vZGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBOb2RlXG4gIGluY2x1ZGUgQWRkX3dpdG5lc3MxIChOb2RlKVxuZW5kXG5cbnR5cGUgKCdhLCAndykgdCA9ICgnYSwgJ3cpIE5vZGUudCBbQEBkZXJpdmluZyBzZXhwX29mXVxudHlwZSAoJ2EsICd3KSBpbmNyZW1lbnRhbCA9ICgnYSwgJ3cpIHRcblxubGV0IGludmFyaWFudCA9IE5vZGUuaW52YXJpYW50XG5cbm1vZHVsZSBPYnNlcnZlciA9IHN0cnVjdFxuICBpbmNsdWRlIE9ic2VydmVyXG4gIGluY2x1ZGUgQWRkX3dpdG5lc3MxIChPYnNlcnZlcilcbmVuZFxuXG5tb2R1bGUgU2NvcGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTY29wZVxuICBpbmNsdWRlIEFkZF93aXRuZXNzMCAoU2NvcGUpXG5lbmRcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIGluY2x1ZGUgU3RhdGVcbiAgaW5jbHVkZSBBZGRfd2l0bmVzczAgKFN0YXRlKVxuZW5kXG5cbm1vZHVsZSBWYXIgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBWYXJcbiAgaW5jbHVkZSBBZGRfd2l0bmVzczEgKFZhcilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGVcbiAgICBTX2dlblxuICAgIHdpdGggdHlwZSAnYSB0ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBpbmNyZW1lbnRhbFxuICAgIHdpdGggdHlwZSBCZWZvcmVfb3JfYWZ0ZXIudCA9IEJlZm9yZV9vcl9hZnRlci50XG4gICAgd2l0aCB0eXBlIENsb2NrLnQgPSBzdGF0ZV93aXRuZXNzIENsb2NrLnRcbiAgICB3aXRoIHR5cGUgJ2EgQ3V0b2ZmLnQgPSAnYSBDdXRvZmYudFxuICAgIHdpdGggdHlwZSAnYSBFeHBlcnQuRGVwZW5kZW5jeS50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBFeHBlcnQuRGVwZW5kZW5jeS50XG4gICAgd2l0aCB0eXBlICdhIEV4cGVydC5Ob2RlLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEV4cGVydC5Ob2RlLnRcbiAgICB3aXRoIHR5cGUgRXhwZXJ0LlN0ZXBfcmVzdWx0LnQgPSBFeHBlcnQuU3RlcF9yZXN1bHQudFxuICAgIHdpdGggdHlwZSAnYSBPYnNlcnZlci50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBPYnNlcnZlci50XG4gICAgd2l0aCB0eXBlICdhIE9ic2VydmVyLlVwZGF0ZS50ID0gJ2EgT2JzZXJ2ZXIuVXBkYXRlLnRcbiAgICB3aXRoIHR5cGUgUGFja2VkLnQgPSBQYWNrZWQudFxuICAgIHdpdGggdHlwZSBTY29wZS50ID0gc3RhdGVfd2l0bmVzcyBTY29wZS50XG4gICAgd2l0aCB0eXBlIFN0YXRlLnQgPSBzdGF0ZV93aXRuZXNzIFN0YXRlLnRcbiAgICB3aXRoIHR5cGUgU3RhdGUuU3RhdHMudCA9IFN0YXRlLlN0YXRzLnRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgVW5vcmRlcmVkX2FycmF5X2ZvbGRfdXBkYXRlLnQgPVxuICAgICAgICAgICAoJ2EsICdiKSBVbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGUudFxuICAgIHdpdGggdHlwZSAnYSBVcGRhdGUudCA9ICdhIFVwZGF0ZS50XG4gICAgd2l0aCB0eXBlICdhIFZhci50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBWYXIudFxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBkZWJ1ZyA9IGRlYnVnXG5lbmRcbiJdfQ==
