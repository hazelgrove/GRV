// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _b_ = [0, [15, [17, 2, 0]], "%a@?"],
    _a_ = [0, 0, 0],
    cst_n = "\\n",
    cst_Sexplib0_Sexp_Not_found_s = "Sexplib0__Sexp.Not_found_s",
    cst_Sexplib0_Sexp_Of_sexp_erro = "Sexplib0__Sexp.Of_sexp_error";
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[9], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     var a = xs, b = ys;
    }
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Not_found_s = [248, cst_Sexplib0_Sexp_Not_found_s, caml_fresh_oo_id(0)],
    Of_sexp_error = [248, cst_Sexplib0_Sexp_Of_sexp_erro, caml_fresh_oo_id(0)],
    default_indent = [0, 1];
   function must_escape(str){
    var len = caml_ml_string_length(str), _x_ = 0 === len ? 1 : 0;
    if(_x_) return _x_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _y_ = 0 < ix ? 1 : 0;
         if(_y_){
          var
           next = ix - 1 | 0,
           _z_ = caml_string_get(str, next),
           _A_ = caml_call2(Stdlib_Char[6], _z_, 35);
          if(! _A_){var ix = next; continue;}
          var _B_ = _A_;
         }
         else
          var _B_ = _y_;
         return _B_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _D_ = 0 < ix ? 1 : 0;
            if(_D_){
             var
              next$0 = ix - 1 | 0,
              _E_ = caml_string_get(str, next$0),
              _F_ = caml_call2(Stdlib_Char[6], _E_, 124);
             if(! _F_){var ix = next$0; continue;}
             var _G_ = _F_;
            }
            else
             var _G_ = _D_;
            return _G_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _C_ = 0 < ix ? 1 : 0;
       if(! _C_) return _C_;
       var ix$0 = ix - 1 | 0, ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _n_ = caml_ml_string_length(s) - 1 | 0, _m_ = 0;
    if(_n_ >= 0){
     var i$0 = _m_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _u_ = match - 34 | 0;
          if(58 < _u_ >>> 0){
           if(93 <= _u_) break c;
          }
          else if(56 < _u_ - 1 >>> 0) break b;
          var _v_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _v_ = 4;
        break a;
       }
       var _v_ = 2;
      }
      n[1] = n[1] + _v_ | 0;
      var _w_ = i$0 + 1 | 0;
      if(_n_ === i$0) break;
      var i$0 = _w_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _p_ = caml_ml_string_length(s) - 1 | 0, _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _r_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _r_);
        n[1]++;
        var
         _s_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _s_);
        n[1]++;
        var _t_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _t_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[44], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[44], res);
   }
   function index_of_newline(str, start){
    try{
     var _k_ = [0, caml_call3(Stdlib_StringLabels[31], str, start, 10)];
     return _k_;
    }
    catch(_l_){
     var _j_ = caml_wrap_exception(_l_);
     if(_j_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_j_, 0);
    }
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _g_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _g_ = 1;
     if(_g_){
      var _h_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _h_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[15], str, index$0, end_pos$0 - index$0 | 0),
       _i_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _i_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[34], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0, index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      var param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0),
      may_need_space$1 = may_need_space$2,
      param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[25], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[114], buf);
    function _d_(_e_, _f_){return pp_hum_indent(indent, _e_, _f_);}
    return caml_call4(Stdlib_Format[135], ppf, _b_, _d_, sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return runtime.caml_string_notequal(fname, "")
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(26, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment";
   function coerce(t){return t;}
   var Sexplib0_Sexp_grammar = [0, coerce, doc_comment_tag];
   runtime.caml_register_global
    (1, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    bool_sexp_grammar = 0,
    string_sexp_grammar = 4,
    bytes_sexp_grammar = 4,
    char_sexp_grammar = 1,
    int_sexp_grammar = 2,
    float_sexp_grammar = 3,
    int32_sexp_grammar = 2,
    int64_sexp_grammar = 2,
    nativeint_sexp_grammar = 2;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (4, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    _aF_ = [0, 0],
    _aG_ = [0, 1],
    _aB_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _aC_ = [0, cst_src_sexp_conv_ml, 410, 15],
    _ay_ = [0, 0],
    _az_ = [0, 0],
    cst_Assert_failure = cst_Assert_failure$0,
    _av_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _ar_ = [0, "Exit"],
    _as_ = [0, cst_src_sexp_conv_ml, 338, 15],
    _an_ = [0, "End_of_file"],
    _ao_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _aj_ = [0, "Failure"],
    _ak_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _af_ = [0, "Not_found"],
    _ag_ = [0, cst_src_sexp_conv_ml, 350, 15],
    _ab_ = [0, "Invalid_argument"],
    _ac_ = [0, cst_src_sexp_conv_ml, 354, 15],
    cst_Match_failure = "Match_failure",
    ___ = [0, cst_src_sexp_conv_ml, 358, 15],
    _W_ = [0, "Not_found_s"],
    _X_ = [0, cst_src_sexp_conv_ml, 362, 15],
    _S_ = [0, "Sys_error"],
    _T_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _O_ = [0, "Arg.Help"],
    _P_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _K_ = [0, "Arg.Bad"],
    _L_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _G_ = [0, "Lazy.Undefined"],
    _H_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _C_ = [0, "Parsing.Parse_error"],
    _D_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _y_ = [0, "Queue.Empty"],
    _z_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _u_ = [0, "Scanf.Scan_failure"],
    _v_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _q_ = [0, "Stack.Empty"],
    _r_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _m_ = [0, "Sys.Break"],
    _n_ = [0, cst_src_sexp_conv_ml, 398, 15],
    _j_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"],
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    _i_ = [0, 2],
    _h_ = [0, 2],
    _f_ = [0, "<fun>"],
    _e_ = [0, "<opaque>"],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _a_ = [1, 0],
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1];
   function list_map(f, l){
    var _bo_ = caml_call2(Stdlib_ListLabels[21], f, l);
    return caml_call1(Stdlib_ListLabels[9], _bo_);
   }
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var _bm_ = runtime.caml_obj_tag(lv);
    a:
    if(250 === _bm_)
     var _bn_ = lv[1];
    else{
     if(246 !== _bm_ && 244 !== _bm_){var _bn_ = lv; break a;}
     var _bn_ = caml_call1(CamlinternalLazy[2], lv);
    }
    return caml_call1(sexp_of_a, _bn_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _bl_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _bl_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _bj_ = [0, caml_call1(sexp_of_c, c), 0],
     _bk_ = [0, caml_call1(sexp_of_b, b), _bj_];
    return [1, [0, caml_call1(sexp_of_a, a), _bk_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    var _bi_ = caml_call2(Stdlib_ListLabels[21], sexp_of_a, lst);
    return [1, caml_call1(Stdlib_ListLabels[9], _bi_)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _bf_ = ar.length - 1 - 1 | 0;
    if(_bf_ >= 0){
     var i = _bf_;
     for(;;){
      var _bg_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _bg_];
      var _bh_ = i - 1 | 0;
      if(0 === i) break;
      var i = _bh_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _be_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _be_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[23][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][3], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[23][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[18], the_exn_table)[1];}
   var For_unit_tests_only = [0, size];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _bb_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _bb_);
   }
   function _g_(exn){
    var match = find_auto(1, exn);
    if(! match) return 0;
    var sexp = match[1];
    return [0, caml_call2(Sexplib0_Sexp[13], _h_, sexp)];
   }
   caml_call1(Stdlib_Printexc[9], _g_);
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _i_, sexp);
   }
   var Of_sexp_error = Sexplib0_Sexp[6], record_check_extra_fields = [0, 1];
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ba_ = sexp[1];
    a:
    if(caml_string_notequal(_ba_, "False")){
     if(caml_string_notequal(_ba_, "True")){
      if(! caml_string_notequal(_ba_, "false")) break a;
      if(caml_string_notequal(_ba_, "true"))
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a$_ = caml_int_of_string(str); return _a$_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a__ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _a__), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a9_ = caml_float_of_string(str); return _a9_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a8_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _a8_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a7_ = caml_int_of_string(str); return _a7_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a6_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _a6_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a5_ = runtime.caml_int64_of_string(str); return _a5_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a4_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _a4_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _a3_ = caml_int_of_string(str); return _a3_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a2_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _a2_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _a1_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _a1_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _aW_ = sexp[1];
      if
       (caml_string_notequal(_aW_, cst_None)
        && caml_string_notequal(_aW_, cst_none))
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aX_ = sexp[1];
     a:
     if(_aX_){
      var _aY_ = _aX_[1];
      if(0 === _aY_[0]){
       var _aZ_ = _aY_[1];
       if
        (caml_string_notequal(_aZ_, cst_Some)
         && caml_string_notequal(_aZ_, cst_some))
        break a;
       var _a0_ = _aX_[2];
       if(_a0_ && ! _a0_[2]){
        var el$0 = _a0_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _aR_ = sexp[1];
     if
      (caml_string_notequal(_aR_, cst_None)
       && caml_string_notequal(_aR_, cst_none))
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _aS_ = sexp[1];
     if(_aS_){
      var _aT_ = _aS_[1];
      a:
      {
       if(_aS_[2]){
        b:
        if(0 === _aT_[0]){
         var _aU_ = _aT_[1];
         if
          (caml_string_notequal(_aU_, cst_Some)
           && caml_string_notequal(_aU_, cst_some))
          break b;
         var _aV_ = _aS_[2];
         if(! _aV_[2]){var el = _aV_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _aT_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _aP_ = sexp[1];
    if(_aP_){
     var _aQ_ = _aP_[2];
     if(_aQ_ && ! _aQ_[2]){
      var
       b_sexp = _aQ_[1],
       a_sexp = _aP_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var _aM_ = sexp[1];
    if(_aM_){
     var _aN_ = _aM_[2];
     if(_aN_){
      var _aO_ = _aN_[2];
      if(_aO_ && ! _aO_[2]){
       var
        c_sexp = _aO_[1],
        b_sexp = _aN_[1],
        a_sexp = _aM_[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     rev_lst = caml_call2(Stdlib_ListLabels[21], a_of_sexp, lst);
    return caml_call1(Stdlib_ListLabels[9], rev_lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _aL_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _aL_;
     var i$0 = i + 1 | 0, i = i$0, param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _aH_ = param[1];
      if(_aH_){
       var _aI_ = _aH_[2];
       if(_aI_ && ! _aI_[2]){
        var
         v_sexp = _aI_[1],
         k_sexp = _aH_[1],
         _aJ_ = caml_call1(val_of_sexp, v_sexp),
         _aK_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _aK_, _aJ_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[17], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[1],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[2],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[18];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _j_, name, file, line, chr)];
   }
   var _k_ = 0;
   function _l_(param){
    if(param === Stdlib_Sys[44]) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   var _o_ = [0, [0, Stdlib_Sys[44], _l_], _k_];
   function _p_(param){
    if(param === Stdlib_Stack[1]) return _q_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   var _s_ = [0, [0, Stdlib_Stack[1], _p_], _o_];
   function _t_(param){
    if(param[1] !== Stdlib_Scanf[2])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
    var arg = param[2];
    return [1, [0, _u_, [0, [0, arg], 0]]];
   }
   var _w_ = [0, [0, Stdlib_Scanf[2], _t_], _s_];
   function _x_(param){
    if(param === Stdlib_Queue[1]) return _y_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
   }
   var _A_ = [0, [0, Stdlib_Queue[1], _x_], _w_];
   function _B_(param){
    if(param === Stdlib_Parsing[10]) return _C_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   var _E_ = [0, [0, Stdlib_Parsing[10], _B_], _A_];
   function _F_(param){
    if(param === Stdlib_Lazy[1]) return _G_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   var _I_ = [0, [0, Stdlib_Lazy[1], _F_], _E_];
   function _J_(param){
    if(param[1] !== Stdlib_Arg[8])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    var arg = param[2];
    return [1, [0, _K_, [0, [0, arg], 0]]];
   }
   var _M_ = [0, [0, Stdlib_Arg[8], _J_], _I_];
   function _N_(param){
    if(param[1] !== Stdlib_Arg[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    var arg = param[2];
    return [1, [0, _O_, [0, [0, arg], 0]]];
   }
   var _Q_ = [0, [0, Stdlib_Arg[7], _N_], _M_];
   function _R_(param){
    if(param[1] !== Stdlib[11])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    var arg = param[2];
    return [1, [0, _S_, [0, [0, arg], 0]]];
   }
   var _U_ = [0, [0, Stdlib[11], _R_], _Q_];
   function _V_(param){
    if(param[1] !== Sexplib0_Sexp[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
    var arg = param[2];
    return [1, [0, _W_, [0, arg, 0]]];
   }
   var _Y_ = [0, [0, Sexplib0_Sexp[5], _V_], _U_];
   function _Z_(param){
    if(param[1] !== Stdlib[4])
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var arg = param[2];
    return get_flc_error(cst_Match_failure, arg);
   }
   var _$_ = [0, [0, Stdlib[4], _Z_], _Y_];
   function _aa_(param){
    if(param[1] !== Stdlib[6])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    var arg = param[2];
    return [1, [0, _ab_, [0, [0, arg], 0]]];
   }
   var _ad_ = [0, [0, Stdlib[6], _aa_], _$_];
   function _ae_(param){
    if(param === Stdlib[8]) return _af_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   var _ah_ = [0, [0, Stdlib[8], _ae_], _ad_];
   function _ai_(param){
    if(param[1] !== Stdlib[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
    var arg = param[2];
    return [1, [0, _aj_, [0, [0, arg], 0]]];
   }
   var _al_ = [0, [0, Stdlib[7], _ai_], _ah_];
   function _am_(param){
    if(param === Stdlib[12]) return _an_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
   }
   var _ap_ = [0, [0, Stdlib[12], _am_], _al_];
   function _aq_(param){
    if(param === Stdlib[3]) return _ar_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
   }
   var _at_ = [0, [0, Stdlib[3], _aq_], _ap_];
   function _au_(param){
    if(param[1] !== Stdlib[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var arg = param[2];
    return get_flc_error(cst_Assert_failure, arg);
   }
   var _aw_ = [0, [0, Stdlib[5], _au_], _at_];
   function _ax_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_az_, _ay_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _ax_, _aw_);
   var
    _aA_ = 0,
    _aD_ =
      [0,
       [0,
        Of_sexp_error,
        function(param){
         if(param[1] !== Of_sexp_error)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
         var sexp = param[3], exc = param[2];
         return [1, [0, _aB_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
        }],
       _aA_];
   function _aE_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_aG_, _aF_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _aE_, _aD_);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    cst_of_sexp_trying_to_convert_ =
      "_of_sexp: trying to convert an empty type",
    cst_of_sexp_the_empty_list_is_ =
      "_of_sexp: the empty list is an invalid polymorphic variant",
    cst_of_sexp_a_nested_list_is_a =
      "_of_sexp: a nested list is an invalid polymorphic variant",
    cst_of_sexp_polymorphic_varian$0 =
      "_of_sexp: polymorphic variant tag takes an argument",
    _e_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: polymorphic variant tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"],
    cst_of_sexp_polymorphic_varian =
      "_of_sexp: polymorphic variant does not take arguments",
    cst_of_sexp_no_matching_varian = "_of_sexp: no matching variant found",
    cst_of_sexp_cannot_convert_val =
      "_of_sexp: cannot convert values of types resulting from polymorphic record fields",
    cst_of_sexp_list_instead_of_at =
      "_of_sexp: list instead of atom for record expected",
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: the following record elements were undefined: ",
         [2, 0, 0]]],
       "%s_of_sexp: the following record elements were undefined: %s"],
    cst_extra_fields = "extra fields",
    cst_duplicate_fields = "duplicate fields",
    _c_ =
      [0,
       [2, 0, [11, "_of_sexp: ", [2, 0, [11, ": ", [2, 0, 0]]]]],
       "%s_of_sexp: %s: %s"],
    cst_of_sexp_record_conversion_$0 =
      "_of_sexp: record conversion: only pairs expected, their first element must be an atom",
    cst_of_sexp_record_conversion_ =
      "_of_sexp: record conversion: a [sexp.bool] field was given a payload.",
    cst_of_sexp_unexpected_variant =
      "_of_sexp: unexpected variant constructor",
    cst_of_sexp_expected_a_variant$0 =
      "_of_sexp: expected a variant type, saw an empty list",
    cst_of_sexp_expected_a_variant =
      "_of_sexp: expected a variant type, saw a nested list",
    cst_of_sexp_this_constructor_r =
      "_of_sexp: this constructor requires arguments",
    _b_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: sum tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: sum tag %S has incorrect number of arguments"],
    cst_of_sexp_this_constructor_d =
      "_of_sexp: this constructor does not take arguments",
    _a_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]]],
       "%s_of_sexp: tuple of size %d expected"],
    cst_Sexplib0_Sexp_conv_error_N =
      "Sexplib0__Sexp_conv_error.No_variant_match";
   function tuple_of_size_n_expected(loc, n, sexp){
    var _t_ = caml_call3(Stdlib_Printf[4], _a_, loc, n);
    return caml_call2(Sexplib0_Sexp_conv[27], _t_, sexp);
   }
   function stag_no_args(loc, sexp){
    var _s_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_d);
    return caml_call2(Sexplib0_Sexp_conv[27], _s_, sexp);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _b_, loc, tag);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_takes_args(loc, sexp){
    var _r_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_r);
    return caml_call2(Sexplib0_Sexp_conv[27], _r_, sexp);
   }
   function nested_list_invalid_sum(loc, sexp){
    var _q_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _q_, sexp);
   }
   function empty_list_invalid_sum(loc, sexp){
    var _p_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _p_, sexp);
   }
   function unexpected_stag(loc, sexp){
    var _o_ = caml_call2(Stdlib[28], loc, cst_of_sexp_unexpected_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _o_, sexp);
   }
   function record_sexp_bool_with_payload(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_only_pairs_expected(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_superfluous_fields(what, loc, rev_fld_names, sexp){
    var
     _n_ = caml_call1(Stdlib_ListLabels[9], rev_fld_names),
     fld_names_str = caml_call2(Stdlib_StringLabels[6], cst, _n_),
     msg = caml_call4(Stdlib_Printf[4], _c_, loc, what, fld_names_str);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_duplicate_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_duplicate_fields, loc, rev_fld_names, sexp);
   }
   function record_extra_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_extra_fields, loc, rev_fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _m_ = caml_call1(Stdlib_ListLabels[9], fields$0);
      return caml_call2(Stdlib_StringLabels[6], cst$0, _m_);
     }
     var _l_ = param$0[1];
     if(_l_[1])
      var
       rest = param$0[2],
       field = _l_[2],
       fields$1 = [0, field, fields$0],
       fields$0 = fields$1,
       param$0 = rest;
     else
      var rest$0 = param$0[2], param$0 = rest$0;
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call3(Stdlib_Printf[4], _d_, loc, undefined$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_list_instead_atom(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_list_instead_of_at);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_poly_field_value(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_cannot_convert_val);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   var
    No_variant_match =
      [248, cst_Sexplib0_Sexp_conv_error_N, runtime.caml_fresh_oo_id(0)];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){
    var _k_ = caml_call2(Stdlib[28], loc, cst_of_sexp_no_matching_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _k_, sexp);
   }
   function ptag_no_args(loc, sexp){
    var _j_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _j_, sexp);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _e_, loc, cnstr);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function ptag_takes_args(loc, sexp){
    var _i_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _i_, sexp);
   }
   function nested_list_invalid_poly_var(loc, sexp){
    var _h_ = caml_call2(Stdlib[28], loc, cst_of_sexp_a_nested_list_is_a);
    return caml_call2(Sexplib0_Sexp_conv[27], _h_, sexp);
   }
   function empty_list_invalid_poly_var(loc, sexp){
    var _g_ = caml_call2(Stdlib[28], loc, cst_of_sexp_the_empty_list_is_);
    return caml_call2(Sexplib0_Sexp_conv[27], _g_, sexp);
   }
   function empty_type(loc, sexp){
    var _f_ = caml_call2(Stdlib[28], loc, cst_of_sexp_trying_to_convert_);
    return caml_call2(Sexplib0_Sexp_conv[27], _f_, sexp);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (30, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsImNvZXJjZSIsInVuaXRfc2V4cF9ncmFtbWFyIiwic2V4cF90X3NleHBfZ3JhbW1hciIsImVtcHR5X3NleHBfZ3JhbW1hciIsImJvb2xfc2V4cF9ncmFtbWFyIiwic3RyaW5nX3NleHBfZ3JhbW1hciIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImNoYXJfc2V4cF9ncmFtbWFyIiwiaW50X3NleHBfZ3JhbW1hciIsImZsb2F0X3NleHBfZ3JhbW1hciIsImludDMyX3NleHBfZ3JhbW1hciIsImludDY0X3NleHBfZ3JhbW1hciIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJyZWZfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicGFyYW0iLCJsaXN0X3NleHBfZ3JhbW1hciIsImFycmF5X3NleHBfZ3JhbW1hciIsImRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0IiwicmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCIsIndyaXRlX29sZF9vcHRpb25fZm9ybWF0IiwibGlzdF9tYXAiLCJmIiwibCIsInNleHBfb2ZfdW5pdCIsInNleHBfb2ZfYm9vbCIsInNleHBfb2Zfc3RyaW5nIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzIiwic2V4cF9vZl9jaGFyIiwic2V4cF9vZl9pbnQiLCJzZXhwX29mX2Zsb2F0Iiwic2V4cF9vZl9pbnQzMiIsInNleHBfb2ZfaW50NjQiLCJzZXhwX29mX25hdGl2ZWludCIsInNleHBfb2ZfcmVmIiwic2V4cF9vZl9hIiwicmYiLCJzZXhwX29mX2xhenlfdCIsImx2Iiwic2V4cF9vZl9vcHRpb24iLCJzZXhwX29mX3BhaXIiLCJzZXhwX29mX2IiLCJzZXhwX29mX3RyaXBsZSIsInNleHBfb2ZfYyIsInNleHBfb2ZfbGlzdCIsInNleHBfb2ZfYXJyYXkiLCJhciIsImxzdF9yZWYiLCJzZXhwX29mX2hhc2h0YmwiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsIiwiaHRibCIsImNvbGwiLCJrIiwic2V4cF9vZl9vcGFxdWUiLCJzZXhwX29mX2Z1biIsImhhc2giLCJ0aGVfZXhuX3RhYmxlIiwiYWRkIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2V4cF9vZl9leG4iLCJwcmludGV4YyIsImZpbmRfYXV0byIsImZvcl9wcmludGV4YyIsImV4biIsInNleHBfb2ZfZXhuX29wdCIsImV4bl90b19zdHJpbmciLCJlIiwicHJpbnRleGNfcHJlZmVyX3NleHAiLCJyZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzIiwib2Zfc2V4cF9lcnJvcl9leG4iLCJleGMiLCJvZl9zZXhwX2Vycm9yIiwid2hhdCIsInVuaXRfb2Zfc2V4cCIsImJvb2xfb2Zfc2V4cCIsInN0cmluZ19vZl9zZXhwIiwiYnl0ZXNfb2Zfc2V4cCIsImNoYXJfb2Zfc2V4cCIsImludF9vZl9zZXhwIiwiZXhjJDAiLCJmbG9hdF9vZl9zZXhwIiwiaW50MzJfb2Zfc2V4cCIsImludDY0X29mX3NleHAiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInJlZl9vZl9zZXhwIiwiYV9vZl9zZXhwIiwibGF6eV90X29mX3NleHAiLCJvcHRpb25fb2Zfc2V4cCIsImVsJDAiLCJlbCIsInBhaXJfb2Zfc2V4cCIsImJfb2Zfc2V4cCIsImJfc2V4cCIsImFfc2V4cCIsInRyaXBsZV9vZl9zZXhwIiwiY19vZl9zZXhwIiwiY19zZXhwIiwibGlzdF9vZl9zZXhwIiwicmV2X2xzdCIsImFycmF5X29mX3NleHAiLCJoYXNodGJsX29mX3NleHAiLCJrZXlfb2Zfc2V4cCIsInZhbF9vZl9zZXhwIiwiYWN0Iiwidl9zZXhwIiwia19zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsImdldF9mbGNfZXJyb3IiLCJjaHIiLCJsaW5lIiwiZmlsZSIsImFyZyIsImhhbmRsZXIiLCJ0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQiLCJsb2MiLCJzdGFnX25vX2FyZ3MiLCJzdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJ0YWciLCJtc2ciLCJzdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSIsImVtcHR5X2xpc3RfaW52YWxpZF9zdW0iLCJ1bmV4cGVjdGVkX3N0YWciLCJyZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCIsInJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIiwicmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyIsInJldl9mbGRfbmFtZXMiLCJmbGRfbmFtZXNfc3RyIiwicmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMiLCJyZWNvcmRfZXh0cmFfZmllbGRzIiwicmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCIsImZpZWxkcyQwIiwiZmllbGQiLCJyZXN0JDAiLCJyZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIiwidW5kZWZpbmVkJDAiLCJyZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20iLCJyZWNvcmRfcG9seV9maWVsZF92YWx1ZSIsIm5vX3ZhcmlhbnRfbWF0Y2giLCJub19tYXRjaGluZ192YXJpYW50X2ZvdW5kIiwicHRhZ19ub19hcmdzIiwicHRhZ19pbmNvcnJlY3Rfbl9hcmdzIiwiY25zdHIiLCJwdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfdHlwZSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvc2V4cGxpYjAvc2V4cC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvc2V4cGxpYjAvc2V4cF9ncmFtbWFyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZ3JhbW1hci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvc2V4cGxpYjAvc2V4cF9jb252Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFt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aEw7SUFFaEMsSUFERXdKLE1BQ0Ysa0NBRnNCSixLQUFJNEI7SUFPNUIsT0FBQSxtQ0FOSXhCLEtBRDhCeEo7R0FPWjtZQUdwQmlMLGdCQUFnQjdCLEtBQUlwSjtJQUNSLFVBQUEsdUJBRElvSjtJQUNsQixPQUFBLHdDQURzQnBKO0dBQzBEO1lBRzlFa0wsNkJBQTZCOUIsS0FBSXBKO0lBQ3JCLFVBQUEsdUJBRGlCb0o7SUFDL0IsT0FBQSx3Q0FEbUNwSjtHQUNtRDtZQUdwRm1MLDRCQUE0Qi9CLEtBQUlwSjtJQUNwQixVQUFBLHVCQURnQm9KO0lBQzlCLE9BQUEsd0NBRGtDcEo7R0FDcUQ7WUFHckZvTCxXQUFXaEMsS0FBSXBKO0lBQ0gsVUFBQSx1QkFERG9KO0lBQ2IsT0FBQSx3Q0FEaUJwSjtHQUNxRDs7Ozs7T0EvSHBFbUo7T0FNQUU7T0FJQUM7T0FLQUc7T0FJQUM7T0FJQUM7T0FJQUM7T0FNQUM7T0FPQUM7T0FTQUM7T0FNQUc7T0FJQUM7T0FJSUM7T0FNSkk7T0FRQUU7T0FLQUM7O09BWUFDO09BRUFDO09BSUFDO09BSUFDO09BVUFFO09BSUFDO09BSUFDO09BSUFDOzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuKCogYmxpdF9zdHJpbmcgZG9lc24ndCBleGlzdCBpbiBbU3RkTGFiZWxzLkJ5dGVzXS4uLiAgKilcbmxldCBieXRlc19ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuOztcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gRm9ybWF0XG5cbigqKiBUeXBlIG9mIFMtZXhwcmVzc2lvbnMgKilcbnR5cGUgdCA9XG4gIHwgQXRvbSBvZiBzdHJpbmdcbiAgfCBMaXN0IG9mIHQgbGlzdFxuXG5sZXQgc2V4cF9vZl90IHQgPSB0XG5sZXQgdF9vZl9zZXhwIHQgPSB0XG5cbmxldCByZWMgY29tcGFyZV9saXN0IGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCByZXMgPSBjb21wYXJlIHggeSBpblxuICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0IHhzIHlzXG5cbmFuZCBjb21wYXJlIGEgYiA9XG4gIGlmIGEgPT0gYlxuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBBdG9tIGEsIEF0b20gYiAtPiBTdHJpbmcuY29tcGFyZSBhIGJcbiAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICB8IExpc3QgYSwgTGlzdCBiIC0+IGNvbXBhcmVfbGlzdCBhIGIpXG47O1xuXG5sZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyBvZiB0XG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciBvZiBleG4gKiB0XG5cbm1vZHVsZSBQcmludGluZyA9IHN0cnVjdFxuICAoKiBEZWZhdWx0IGluZGVudGF0aW9uIGxldmVsIGZvciBodW1hbi1yZWFkYWJsZSBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCBkZWZhdWx0X2luZGVudCA9IHJlZiAxXG5cbiAgKCogRXNjYXBpbmcgb2Ygc3RyaW5ncyB1c2VkIGFzIGF0b21zIGluIFMtZXhwcmVzc2lvbnMgKilcblxuICBsZXQgbXVzdF9lc2NhcGUgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZW4gPSAwXG4gICAgfHxcbiAgICBsZXQgcmVjIGxvb3Agc3RyIGl4ID1cbiAgICAgIG1hdGNoIHN0ci5baXhdIHdpdGhcbiAgICAgIHwgJ1wiJyB8ICcoJyB8ICcpJyB8ICc7JyB8ICdcXFxcJyAtPiB0cnVlXG4gICAgICB8ICd8JyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICcjJyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICcjJyAtPlxuICAgICAgICBpeCA+IDBcbiAgICAgICAgJiZcbiAgICAgICAgbGV0IG5leHQgPSBpeCAtIDEgaW5cbiAgICAgICAgQ2hhci5lcXVhbCBzdHIuW25leHRdICd8JyB8fCBsb29wIHN0ciBuZXh0XG4gICAgICB8ICdcXDAwMCcgLi4gJ1xcMDMyJyB8ICdcXDEyNycgLi4gJ1xcMjU1JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gaXggPiAwICYmIGxvb3Agc3RyIChpeCAtIDEpXG4gICAgaW5cbiAgICBsb29wIHN0ciAobGVuIC0gMSlcbiAgOztcblxuICBsZXQgZXNjYXBlZCBzID1cbiAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG5cbiAgICAgIDo9ICFuXG4gICAgICAgICArXG4gICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgICAgfCBfIC0+IDRcbiAgICBkb25lO1xuICAgIGlmICFuID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcycgPSBCeXRlcy5jcmVhdGUgIW4gaW5cbiAgICAgIG4gOj0gMDtcbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIChtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgICAgfCAnICcgLi4gJ34nIGFzIGMgLT4gQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8IGMgLT5cbiAgICAgICAgICAgbGV0IGEgPSBDaGFyLmNvZGUgYyBpblxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSAvIDEwIG1vZCAxMCkpKTtcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIChDaGFyLmNociAoNDggKyAoYSBtb2QgMTApKSkpO1xuICAgICAgICBpbmNyIG5cbiAgICAgIGRvbmU7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMnKVxuICA7O1xuXG4gIGxldCBlc2Nfc3RyIHN0ciA9XG4gICAgbGV0IGVzdHIgPSBlc2NhcGVkIHN0ciBpblxuICAgIGxldCBlbGVuID0gU3RyaW5nLmxlbmd0aCBlc3RyIGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSAoZWxlbiArIDIpIGluXG4gICAgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYzplc3RyIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6MSB+bGVuOmVsZW47XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgMCAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIChlbGVuICsgMSkgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICA7O1xuXG4gIGxldCBpbmRleF9vZl9uZXdsaW5lIHN0ciBzdGFydCA9XG4gICAgdHJ5IFNvbWUgKFN0cmluZy5pbmRleF9mcm9tIHN0ciBzdGFydCAnXFxuJykgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IE5vbmVcbiAgOztcblxuICBsZXQgZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggZW5kX3Bvc19vcHQgPVxuICAgIGxldCBlbmRfcG9zID1cbiAgICAgIG1hdGNoIGVuZF9wb3Nfb3B0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgfCBTb21lIGVuZF9wb3MgLT4gZW5kX3Bvc1xuICAgIGluXG4gICAgU3RyaW5nLnN1YiBzdHIgfnBvczppbmRleCB+bGVuOihlbmRfcG9zIC0gaW5kZXgpXG4gIDs7XG5cbiAgbGV0IGlzX29uZV9saW5lIHN0ciA9XG4gICAgbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgfCBOb25lIC0+IHRydWVcbiAgICB8IFNvbWUgaW5kZXggLT4gaW5kZXggKyAxID0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgOztcblxuICBsZXQgcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0ciA9XG4gICAgaWYgbm90IChtdXN0X2VzY2FwZSBzdHIpXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIHN0clxuICAgIGVsc2UgaWYgaXNfb25lX2xpbmUgc3RyXG4gICAgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIChlc2Nfc3RyIHN0cilcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpbmRleCA9XG4gICAgICAgIGxldCBuZXh0X25ld2xpbmUgPSBpbmRleF9vZl9uZXdsaW5lIHN0ciBpbmRleCBpblxuICAgICAgICBsZXQgbmV4dF9saW5lID0gZ2V0X3N1YnN0cmluZyBzdHIgaW5kZXggbmV4dF9uZXdsaW5lIGluXG4gICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY2FwZWQgbmV4dF9saW5lKTtcbiAgICAgICAgbWF0Y2ggbmV4dF9uZXdsaW5lIHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBuZXdsaW5lX2luZGV4IC0+XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxcIjtcbiAgICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKTtcbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXG5cIjtcbiAgICAgICAgICBsb29wIChuZXdsaW5lX2luZGV4ICsgMSlcbiAgICAgIGluXG4gICAgICBwcF9vcGVuX2JveCBwcGYgMDtcbiAgICAgICgqIHRoZSBsZWFkaW5nIHNwYWNlIGlzIHRvIGxpbmUgdXAgdGhlIGxpbmVzICopXG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFxcXCJcIjtcbiAgICAgIGxvb3AgMDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFwiXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpKVxuICA7O1xuXG4gIGxldCBtYWNoX21heWJlX2VzY19zdHIgc3RyID0gaWYgbXVzdF9lc2NhcGUgc3RyIHRoZW4gZXNjX3N0ciBzdHIgZWxzZSBzdHJcblxuICAoKiBPdXRwdXQgb2YgUy1leHByZXNzaW9ucyB0byBmb3JtYXR0ZXJzICopXG5cbiAgbGV0IHJlYyBwcF9odW1faW5kZW50IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gcHBfaHVtX21heWJlX2VzY19zdHIgcHBmIHN0clxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfb3Blbl9ib3ggcHBmIGluZGVudDtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgTGlzdCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIlxuXG4gIGFuZCBwcF9odW1fcmVzdCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgcHBfcHJpbnRfc3BhY2UgcHBmICgpO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKVxuICA7O1xuXG4gIGxldCByZWMgcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBwcF9wcmludF9zdHJpbmcgcHBmIFwiIFwiO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHInO1xuICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0O1xuICAgICAgZmFsc2VcbiAgICB8IExpc3QgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiO1xuICAgICAgZmFsc2VcblxuICBhbmQgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdFxuICAgIHwgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIlxuICA7O1xuXG4gIGxldCBwcF9odW0gcHBmIHNleHAgPSBwcF9odW1faW5kZW50ICFkZWZhdWx0X2luZGVudCBwcGYgc2V4cFxuICBsZXQgcHBfbWFjaCBwcGYgc2V4cCA9IGlnbm9yZSAocHBfbWFjaF9pbnRlcm5hbCBmYWxzZSBwcGYgc2V4cClcbiAgbGV0IHBwID0gcHBfbWFjaFxuXG4gICgqIFNleHAgc2l6ZSAqKVxuXG4gIGxldCByZWMgc2l6ZV9sb29wICgodiwgYykgYXMgYWNjKSA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiB2ICsgMSwgYyArIFN0cmluZy5sZW5ndGggc3RyXG4gICAgfCBMaXN0IGxzdCAtPiBMaXN0LmZvbGRfbGVmdCBsc3QgfmluaXQ6YWNjIH5mOnNpemVfbG9vcFxuICA7O1xuXG4gIGxldCBzaXplIHNleHAgPSBzaXplX2xvb3AgKDAsIDApIHNleHBcblxuICAoKiBCdWZmZXIgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fYnVmZmVyX2h1bSB+YnVmID8oaW5kZW50ID0gIWRlZmF1bHRfaW5kZW50KSBzZXhwID1cbiAgICBsZXQgcHBmID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gICAgRm9ybWF0LmZwcmludGYgcHBmIFwiJWFAP1wiIChwcF9odW1faW5kZW50IGluZGVudCkgc2V4cFxuICA7O1xuXG4gIGxldCB0b19idWZmZXJfbWFjaCB+YnVmIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gIGxldCB0b19idWZmZXIgPSB0b19idWZmZXJfbWFjaFxuXG4gIGxldCB0b19idWZmZXJfZ2VuIH5idWYgfmFkZF9jaGFyIH5hZGRfc3RyaW5nIHNleHAgPVxuICAgIGxldCByZWMgbG9vcCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IEF0b20gc3RyIC0+XG4gICAgICAgIGxldCBzdHInID0gbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciBpblxuICAgICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgYWRkX2NoYXIgYnVmICcoJztcbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBmYWxzZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0O1xuICAgICAgICBmYWxzZVxuICAgICAgfCBMaXN0IFtdIC0+XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBhZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICAoKiBUaGUgbWF4aW11bSBzaXplIG9mIGEgdGhpbmcgb24gdGhlIG1pbm9yIGhlYXAgaXMgMjU2IHdvcmRzLlxuICAgICBQcmV2aW91c2x5LCB0aGlzIHNpemUgb2YgdGhlIHJldHVybmVkIGJ1ZmZlciBoZXJlIHdhcyA0MDk2IGJ5dGVzLCB3aGljaFxuICAgICBjYXVzZWQgdGhlIEJ1ZmZlciB0byBiZSBhbGxvY2F0ZWQgb24gdGhlICptYWpvciogaGVhcCBldmVyeSB0aW1lLlxuXG4gICAgIEFjY29yZGluZyB0byBhIHNpbXBsZSBiZW5jaG1hcmsgYnkgUm9uLCB3ZSBjYW4gaW1wcm92ZSBwZXJmb3JtYW5jZSBmb3JcbiAgICAgc21hbGwgcy1leHByZXNzaW9ucyBieSBhIGZhY3RvciBvZiB+NCBpZiB3ZSBvbmx5IGFsbG9jYXRlIDEwMjQgYnl0ZXNcbiAgICAgKDEyOCB3b3JkcyArIHNvbWUgc21hbGwgb3ZlcmhlYWQpIHdvcnRoIG9mIGJ1ZmZlciBpbml0aWFsbHkuICBBbmQgb25lXG4gICAgIGNhbiBhcmd1ZSB0aGF0IGlmIGl0J3MgZnJlZSB0byBhbGxvY2F0ZSBzdHJpbmdzIHNtYWxsZXIgdGhhbiAyNTYgd29yZHMsXG4gICAgIGxhcmdlIHMtZXhwcmVzc2lvbnMgcmVxdWlyaW5nIGxhcmdlciBleHBlbnNpdmUgYnVmZmVycyB3b24ndCBub3RpY2VcbiAgICAgdGhlIGV4dHJhIHR3byBkb3VibGluZ3MgZnJvbSAxMDI0IGJ5dGVzIHRvIDIwNDggYW5kIDQwOTYuIEFuZCBlc3BlY2lhbGx5XG4gICAgIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgdG8gYWx3YXlzIHBhc3MgaW4gYSBsYXJnZXIgYnVmZmVyIHRvXG4gICAgIHVzZS4gKilcbiAgbGV0IGJ1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgMTAyNFxuXG4gICgqIFN0cmluZyBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19zdHJpbmdfaHVtID9pbmRlbnQgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHJcbiAgICAgIHdoZW4gbWF0Y2ggaW5kZXhfb2ZfbmV3bGluZSBzdHIgMCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgIHwgU29tZSBfIC0+IGZhbHNlIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9odW0gP2luZGVudCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ19tYWNoID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHJcbiAgICB8IHNleHAgLT5cbiAgICAgIGxldCBidWYgPSBidWZmZXIgKCkgaW5cbiAgICAgIHRvX2J1ZmZlcl9tYWNoIHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nX21hY2hcbmVuZFxuXG5pbmNsdWRlIFByaW50aW5nXG5cbmxldCBvZl9mbG9hdF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xubGV0IG9mX2ludF9zdHlsZSA6IFsgYFVuZGVyc2NvcmVzIHwgYE5vX3VuZGVyc2NvcmVzIF0gcmVmID0gcmVmIGBOb191bmRlcnNjb3Jlc1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBpbmNsdWRlIFByaW50aW5nXG5lbmRcblxubGV0IG1lc3NhZ2UgbmFtZSBmaWVsZHMgPVxuICBsZXQgcmVjIGNvbnZfZmllbGRzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCAoZm5hbWUsIGZzZXhwKSA6OiByZXN0IC0+XG4gICAgICAobWF0Y2ggZm5hbWUgd2l0aFxuICAgICAgIHwgXCJcIiAtPiBmc2V4cCA6OiBjb252X2ZpZWxkcyByZXN0XG4gICAgICAgfCBfIC0+IExpc3QgWyBBdG9tIGZuYW1lOyBmc2V4cCBdIDo6IGNvbnZfZmllbGRzIHJlc3QpXG4gIGluXG4gIExpc3QgKEF0b20gbmFtZSA6OiBjb252X2ZpZWxkcyBmaWVsZHMpXG47O1xuIiwiKCoqIFJlcHJlc2VudGF0aW9uIG9mIFMtZXhwcmVzc2lvbiBncmFtbWFycyAqKVxuXG4oKiogVGhpcyBtb2R1bGUgZGVmaW5lcyBhIHJlcHJlc2VudGF0aW9uIGZvciBzLWV4cHJlc3Npb24gZ3JhbW1hcnMuIFVzaW5nIHBweF9zZXhwX2NvbnZcbiAgICBhbmQgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHByb2R1Y2VzIGEgZ3JhbW1hciB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZGVyaXZlZFxuICAgIFtvZl9zZXhwXSBmb3IgYSBnaXZlbiB0eXBlLlxuXG4gICAgQXMgd2l0aCBvdGhlciBkZXJpdmVkIGRlZmluaXRpb25zLCBwb2x5bW9ycGhpYyB0eXBlcyBkZXJpdmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFcbiAgICBncmFtbWFyIGZvciBlYWNoIHR5cGUgYXJndW1lbnQgYW5kIHByb2R1Y2VzIGEgZ3JhbW1hciBmb3IgdGhlIG1vbm9tb3JwaGl6ZWQgdHlwZS5cblxuICAgIE1vbm9tb3JwaGljIHR5cGVzIGRlcml2ZSBhIGdyYW1tYXIgZGlyZWN0bHkuIFRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMsXG4gICAgW1tAQGRlcml2aW5nIHNleHBfZ3JhbW1hcl1dIHdyYXBzIGdyYW1tYXJzIGluIHRoZSBbTGF6eV0gY29uc3RydWN0b3IgYXMgbmVlZGVkLlxuXG4gICAgVGhpcyB0eXBlIG1heSBjaGFuZ2Ugb3ZlciB0aW1lIGFzIG91ciBuZWVkcyBmb3IgZXhwcmVzc2l2ZSBncmFtbWFycyBjaGFuZ2UuIFdlIHdpbGxcbiAgICBhdHRlbXB0IHRvIG1ha2UgY2hhbmdlcyBiYWNrd2FyZC1jb21wYXRpYmxlLCBvciBhdCBsZWFzdCBwcm92aWRlIGEgcmVhc29uYWJsZSB1cGdyYWRlXG4gICAgcGF0aC4gKilcblxuW0BAQHdhcm5pbmcgXCItMzBcIl0gKCogYWxsb3cgZHVwbGljYXRlIGZpZWxkIG5hbWVzICopXG5cbigqKiBHcmFtbWFyIG9mIGEgc2V4cC4gKilcbnR5cGUgZ3JhbW1hciA9XG4gIHwgQW55IG9mIHN0cmluZyAoKiogYWNjZXB0cyBhbnkgc2V4cDsgc3RyaW5nIGlzIGEgdHlwZSBuYW1lIGZvciBodW1hbiByZWFkYWJpbGl0eSAqKVxuICB8IEJvb2wgKCoqIGFjY2VwdHMgdGhlIGF0b21zIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIiwgbW9kdWxvIGNhcGl0YWxpemF0aW9uICopXG4gIHwgQ2hhciAoKiogYWNjZXB0cyBhbnkgc2luZ2xlLWNoYXJhY3RlciBhdG9tICopXG4gIHwgSW50ZWdlciAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBpbnRlZ2VyIHN5bnRheCwgcmVnYXJkbGVzcyBvZiBiaXQgd2lkdGggKilcbiAgfCBGbG9hdCAoKiogYWNjZXB0cyBhbnkgYXRvbSBtYXRjaGluZyBvY2FtbCBmbG9hdCBzeW50YXggKilcbiAgfCBTdHJpbmcgKCoqIGFjY2VwdHMgYW55IGF0b20gKilcbiAgfCBPcHRpb24gb2YgZ3JhbW1hciAoKiogYWNjZXB0cyBhbiBvcHRpb24sIGJvdGggW05vbmVdIHZzIFtTb21lIF9dIGFuZCBbKCldIHZzIFsoXyldLiAqKVxuICB8IExpc3Qgb2YgbGlzdF9ncmFtbWFyICgqKiBhY2NlcHRzIGEgbGlzdCAqKVxuICB8IFZhcmlhbnQgb2YgdmFyaWFudCAoKiogYWNjZXB0cyBjbGF1c2VzIGtleWVkIGJ5IGEgbGVhZGluZyBvciBzb2xlIGF0b20gKilcbiAgfCBVbmlvbiBvZiBncmFtbWFyIGxpc3QgKCoqIGFjY2VwdHMgYSBzZXhwIGlmIGFueSBvZiB0aGUgbGlzdGVkIGdyYW1tYXJzIGFjY2VwdHMgaXQgKilcbiAgfCBUYWdnZWQgb2YgZ3JhbW1hciB3aXRoX3RhZ1xuICAoKiogYW5ub3RhdGVzIGEgZ3JhbW1hciB3aXRoIGEgY2xpZW50LXNwZWNpZmljIGtleS92YWx1ZSBwYWlyICopXG4gIHwgVHl2YXIgb2Ygc3RyaW5nXG4gICgqKiBOYW1lIG9mIGEgdHlwZSB2YXJpYWJsZSwgZS5nLiBbVHl2YXIgXCJhXCJdIGZvciBbJ2FdLiBPbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgYm9keSBvZlxuICAgICAgdGhlIGlubmVybW9zdCBlbmNsb3NpbmcgW2RlZm5dIGRlZmluZXMgYSBjb3JyZXNwb25kaW5nIHR5cGUgdmFyaWFibGUuICopXG4gIHwgVHljb24gb2Ygc3RyaW5nICogZ3JhbW1hciBsaXN0XG4gICgqKiBUeXBlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdG8gYXJndW1lbnRzLiBGb3IgZXhhbXBsZSwgW1R5Y29uIChcImxpc3RcIiwgWyBJbnRlZ2VyIF0pXVxuICAgICAgcmVwcmVzZW50cyBbaW50IGxpc3RdLiBPbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbUmVjdXJzaXZlXVxuICAgICAgZ3JhbW1hciBkZWZpbmVzIGEgY29ycmVzcG9uZGluZyB0eXBlIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlY3Vyc2l2ZSBvZiBncmFtbWFyICogZGVmbiBsaXN0XG4gICgqKiBbUmVjdXJzaXZlIChncmFtbWFyLCBkZWZpbml0aW9ucyldIGFsbG93cyBbZ3JhbW1hcl0gdG8gcmVmZXIgdG8gdHlwZSBjb25zdHJ1Y3RvcnNcbiAgICAgIGZyb20gdGhlIG11dHVhbGx5IHJlY3Vyc2l2ZSBbZGVmaW5pdGlvbnNdLiBUaGUgZGVmaW5pdGlvbnMgbWF5IGFsc28gcmVmZXIgdG8gZWFjaFxuICAgICAgb3RoZXJzJyB0eXBlIGNvbnN0cnVjdG9ycy5cblxuICAgICAgT3JkaW5hcmlseSwgW2dyYW1tYXJdIGl0c2VsZiBpcyBqdXN0IGEgW1R5Y29uXSBhcmd1bWVudCwgYWx0aG91Z2ggdGVjaG5pY2FsbHkgaXQgY2FuXG4gICAgICBiZSBhbnkgZ3JhbW1hci5cblxuICAgICAgRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgZGVmaW5pdGlvbnMgZGVmaW5lIGEgYmluYXJ5IHRyZWUgcGFyYW1ldGVyaXplZCBieSBhIHR5cGVcbiAgICAgIHN0b3JlZCBhdCBpdHMgbGVhdmVzLlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgZGVmbnMgPVxuICAgICAgICAgIFsgeyB0eWNvbiA9IFwidHJlZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICAgICAgVmFyaWFudFxuICAgICAgICAgICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICBbIHsgbmFtZSA9IFwiTm9kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiVHJlZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJub2RlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gTGlzdCAoTWFueSAoVHljb24gXCJ0cmVlXCIsIFtUeXZhciBcImFcIl0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibGVhZlwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IFtUeXZhciBcImFcIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIDs7XG4gICAgICBdfVxuXG4gICAgICBOb3JtYWxseSwgdGhlIHR5cGUgb2YgYSB0cmVlIHN0b3JpbmcgaW50ZWdlcnMgd291bGQgYmUgd3JpdHRlbiBsaWtlIHRoaXM6XG5cbiAgICAgIHtbXG4gICAgICAgIFJlY3Vyc2l2ZSAoVHljb24gKFwidHJlZVwiLCBbIEludGVnZXIgXSksIGRlZm5zKVxuICAgICAgXX1cblxuICAgICAgSXQgaXMgZXF1aXZhbGVudCwgdGhvdWdoIG5lZWRsZXNzbHkgdmVyYm9zZSwgdG8gcmVwbGFjZSB0aGUgW1R5Y29uXSByZWZlcmVuY2Ugd2l0aFxuICAgICAgdGhlIGdyYW1tYXIgb2YgW1widHJlZVwiXSwgc3Vic3RpdHV0aW5nIFtJbnRlZ2VyXSBmb3IgW1R5dmFyIFwiYVwiXTpcblxuICAgICAge1tcbiAgICAgICAgUmVjdXJzaXZlXG4gICAgICAgICAgKCBWYXJpYW50XG4gICAgICAgICAgICAgIHsgbmFtZV9raW5kID0gQ2FwaXRhbGl6ZWRcbiAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibm9kZVwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJUcmVlXCJcbiAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICwgZGVmbnMgKVxuICAgICAgXX1cbiAgKilcbiAgfCBMYXp5IG9mIGdyYW1tYXIgbGF6eV90XG4gICgqKiBMYXppbHkgY29tcHV0ZWQgZ3JhbW1hci4gVXNlIFtMYXp5XSB0byBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLiBUbyBkZWZpbmVcbiAgICAgIHJlY3Vyc2l2ZSBncmFtbWFycywgdXNlIFtSZWN1cnNpdmVdIGluc3RlYWQuICopXG5cbigqKiBHcmFtbWFyIG9mIGEgbGlzdCBvZiBzZXhwcy4gKilcbmFuZCBsaXN0X2dyYW1tYXIgPVxuICB8IEVtcHR5ICgqKiBhY2NlcHRzIGFuIGVtcHR5IGxpc3Qgb2Ygc2V4cHMgKilcbiAgfCBDb25zIG9mIGdyYW1tYXIgKiBsaXN0X2dyYW1tYXJcbiAgKCoqIGFjY2VwdHMgYSBub24tZW1wdHkgbGlzdCB3aXRoIGhlYWQgYW5kIHRhaWwgbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXJzICopXG4gIHwgTWFueSBvZiBncmFtbWFyICgqKiBhY2NlcHRzIHplcm8gb3IgbW9yZSBzZXhwcywgZWFjaCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hciAqKVxuICB8IEZpZWxkcyBvZiByZWNvcmQgKCoqIGFjY2VwdHMgc2V4cHMgcmVwcmVzZW50aW5nIGZpZWxkcyBvZiBhIHJlY29yZCAqKVxuXG4oKiogQ2FzZSBzZW5zaXRpdml0eSBvcHRpb25zIGZvciBuYW1lcyBvZiB2YXJpYW50IGNvbnN0cnVjdG9ycy4gKilcbmFuZCBjYXNlX3NlbnNpdGl2aXR5ID1cbiAgfCBDYXNlX2luc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUuIFVzZWQgZm9yIGN1c3RvbSBwYXJzZXJzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLiBVc2VkIGZvciBwb2x5bW9ycGhpYyB2YXJpYW50cy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGNhc2Ugc2Vuc2l0aXZlIGFmdGVyd2FyZC5cbiAgICAgIFVzZWQgZm9yIHJlZ3VsYXIgdmFyaWFudHMuICopXG5cbigqKiBHcmFtbWFyIG9mIHZhcmlhbnRzLiBBY2NlcHRzIGFueSBzZXhwIG1hdGNoaW5nIG9uZSBvZiB0aGUgY2xhdXNlcy4gKilcbmFuZCB2YXJpYW50ID1cbiAgeyBjYXNlX3NlbnNpdGl2aXR5IDogY2FzZV9zZW5zaXRpdml0eVxuICA7IGNsYXVzZXMgOiBjbGF1c2Ugd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UuIEFjY2VwdHMgc2V4cHMgYmFzZWQgb24gdGhlIFtjbGF1c2Vfa2luZF0uICopXG5hbmQgY2xhdXNlID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgY2xhdXNlX2tpbmQgOiBjbGF1c2Vfa2luZFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlJ3MgY29udGVudHMuIFtBdG9tX2NsYXVzZV0gYWNjZXB0cyBhbiBhdG9tIG1hdGNoaW5nXG4gICAgdGhlIGNsYXVzZSdzIG5hbWUuIFtMaXN0X2NsYXVzZV0gYWNjZXB0cyBhIGxpc3Qgd2hvc2UgaGVhZCBpcyBhbiBhdG9tIG1hdGNoaW5nIHRoZVxuICAgIGNsYXVzZSdzIG5hbWUgYW5kIHdob3NlIHRhaWwgbWF0Y2hlcyBbYXJnc10uIFRoZSBjbGF1c2UncyBuYW1lIGlzIG1hdGNoZWQgbW9kdWxvIHRoZVxuICAgIHZhcmlhbnQncyBbbmFtZV9raW5kXS4gKilcbmFuZCBjbGF1c2Vfa2luZCA9XG4gIHwgQXRvbV9jbGF1c2VcbiAgfCBMaXN0X2NsYXVzZSBvZiB7IGFyZ3MgOiBsaXN0X2dyYW1tYXIgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZC4gQWNjZXB0cyBhbnkgbGlzdCBvZiBzZXhwcyBzcGVjaWZ5aW5nIGVhY2ggb2YgdGhlIGZpZWxkcyxcbiAgICByZWdhcmRsZXNzIG9mIG9yZGVyLiBJZiBbYWxsb3dfZXh0cmFfZmllbGRzXSBpcyBzcGVjaWZpZWQsIGlnbm9yZXMgc2V4cHMgd2l0aCBuYW1lc1xuICAgIG5vdCBmb3VuZCBpbiBbZmllbGRzXS4gKilcbmFuZCByZWNvcmQgPVxuICB7IGFsbG93X2V4dHJhX2ZpZWxkcyA6IGJvb2xcbiAgOyBmaWVsZHMgOiBmaWVsZCB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZCBmaWVsZC4gQSBmaWVsZCBtdXN0IHNob3cgdXAgZXhhY3RseSBvbmNlIGluIGEgcmVjb3JkIGlmXG4gICAgW3JlcXVpcmVkXSwgb3IgYXQgbW9zdCBvbmNlIG90aGVyd2lzZS4gQWNjZXB0cyBhIGxpc3QgaGVhZGVkIGJ5IFtuYW1lXSBhcyBhbiBhdG9tLFxuICAgIGZvbGxvd2VkIGJ5IHNleHBzIG1hdGNoaW5nIFthcmdzXS4gKilcbmFuZCBmaWVsZCA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IHJlcXVpcmVkIDogYm9vbFxuICA7IGFyZ3MgOiBsaXN0X2dyYW1tYXJcbiAgfVxuXG4oKiogR3JhbW1hciB0YWdnZWQgd2l0aCBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIuICopXG5hbmQgJ2Egd2l0aF90YWcgPVxuICB7IGtleSA6IHN0cmluZ1xuICA7IHZhbHVlIDogU2V4cC50XG4gIDsgZ3JhbW1hciA6ICdhXG4gIH1cblxuYW5kICdhIHdpdGhfdGFnX2xpc3QgPVxuICB8IFRhZyBvZiAnYSB3aXRoX3RhZ19saXN0IHdpdGhfdGFnXG4gIHwgTm9fdGFnIG9mICdhXG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbi4gTmFtZXMgdGhlIFt0eWNvbl0gYmVpbmcgZGVmaW5lZCwgYW5kIHRoZVxuICAgIFt0eXZhcnNdIGl0IHRha2VzIGFzIHBhcmFtZXRlcnMuIFNwZWNpZmllcyB0aGUgW2dyYW1tYXJdIG9mIHRoZSBbdHljb25dLiBUaGUgZ3JhbW1hclxuICAgIG1heSByZWZlciB0byBhbnkgb2YgdGhlIFt0eXZhcnNdLCBhbmQgdG8gYW55IG9mIHRoZSBbdHljb25dcyBmcm9tIHRoZSBzYW1lIHNldCBvZlxuICAgIFtSZWN1cnNpdmVdIGRlZmluaXRpb25zLiAqKVxuYW5kIGRlZm4gPVxuICB7IHR5Y29uIDogc3RyaW5nXG4gIDsgdHl2YXJzIDogc3RyaW5nIGxpc3RcbiAgOyBncmFtbWFyIDogZ3JhbW1hclxuICB9XG5cbigqKiBUb3AtbGV2ZWwgZ3JhbW1hciB0eXBlLiBIYXMgYSBwaGFudG9tIHR5cGUgcGFyYW1ldGVyIHRvIGFzc29jaWF0ZSBlYWNoIGdyYW1tYXIgd2l0aFxuICAgIHRoZSB0eXBlIGl0cyBzZXhwcyByZXByZXNlbnQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGFwcGx5IGdyYW1tYXJzIHRvIHRoZSB3cm9uZ1xuICAgIHR5cGUsIHdoaWxlIGdyYW1tYXJzIGNhbiBzdGlsbCBiZSBlYXNpbHkgY29lcmNlZCB0byBhIG5ldyB0eXBlIGlmIG5lZWRlZC4gKilcbnR5cGUgXyB0ID0geyB1bnR5cGVkIDogZ3JhbW1hciB9IFtAQHVuYm94ZWRdXG5cbmxldCBjb2VyY2UgKHR5cGUgYSBiKSAoeyB1bnR5cGVkID0gXyB9IGFzIHQgOiBhIHQpIDogYiB0ID0gdFxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaXMgdXNlZCBmb3IgYWxsIHRhZ3MgZ2VuZXJhdGVkIGZyb20gZG9jIGNvbW1lbnRzLiAqKVxubGV0IGRvY19jb21tZW50X3RhZyA9IFwic2V4cF9ncmFtbWFyLmRvY19jb21tZW50XCJcbiIsImxldCB1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBMaXN0IEVtcHR5IH1cbmxldCBib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBCb29sIH1cbmxldCBzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQ2hhciB9XG5sZXQgaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gRmxvYXQgfVxubGV0IGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgc2V4cF90X3NleHBfZ3JhbW1hciA6IFNleHAudCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIlNleHAudFwiIH1cbmxldCByZWZfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcbmxldCBsYXp5X3Rfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcblxubGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIG9wdGlvbiBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IE9wdGlvbiB1bnR5cGVkIH1cbjs7XG5cbmxldCBsaXN0X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gbGlzdCBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGFycmF5X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gYXJyYXkgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBlbXB0eV9zZXhwX2dyYW1tYXIgOiBfIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxubGV0IG9wYXF1ZV9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbmxldCBmdW5fc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG4iLCIoKiBVdGlsaXR5IE1vZHVsZSBmb3IgUy1leHByZXNzaW9uIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIE1vcmVMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBcblxuKCogQ29udmVyc2lvbiBvZiBPQ2FtbC12YWx1ZXMgdG8gUy1leHByZXNzaW9ucyAqKVxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiAnJS4xN2cnIGlzIGd1YXJhbnRlZWQgdG8gYmUgcm91bmQtdHJpcHBhYmxlLlxuXG4gICAnJS4xNWcnIHdpbGwgYmUgcm91bmQtdHJpcHBhYmxlIGFuZCBub3QgaGF2ZSBub2lzZSBhdCB0aGUgbGFzdCBkaWdpdCBvciB0d28gZm9yIGEgZmxvYXRcbiAgIHdoaWNoIHdhcyBjb252ZXJ0ZWQgZnJvbSBhIGRlY2ltYWwgKHN0cmluZykgd2l0aCA8PSAxNSBzaWduaWZpY2FudCBkaWdpdHMuICBTbyBpdCdzXG4gICB3b3J0aCB0cnlpbmcgZmlyc3QgdG8gYXZvaWQgdGhpbmdzIGxpa2UgXCIzLjE0MDAwMDAwMDAwMDAwMDFcIi5cblxuICAgU2VlIGNvbW1lbnQgYWJvdmUgW3RvX3N0cmluZ19yb3VuZF90cmlwcGFibGVdIGluIHshQ29yZS5GbG9hdH0gZm9yXG4gICBkZXRhaWxlZCBleHBsYW5hdGlvbiBhbmQgZXhhbXBsZXMuICopXG5sZXQgZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgPVxuICByZWYgKGZ1biB4IC0+XG4gICAgbGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1R1wiIHggaW5cbiAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN0dcIiB4KVxuOztcblxubGV0IHJlYWRfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IHdyaXRlX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCBsaXN0X21hcCBmIGwgPSBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGwgfmYpXG5sZXQgc2V4cF9vZl91bml0ICgpID0gTGlzdCBbXVxubGV0IHNleHBfb2ZfYm9vbCBiID0gQXRvbSAoc3RyaW5nX29mX2Jvb2wgYilcbmxldCBzZXhwX29mX3N0cmluZyBzdHIgPSBBdG9tIHN0clxubGV0IHNleHBfb2ZfYnl0ZXMgYnl0ZXMgPSBBdG9tIChCeXRlcy50b19zdHJpbmcgYnl0ZXMpXG5sZXQgc2V4cF9vZl9jaGFyIGMgPSBBdG9tIChTdHJpbmcubWFrZSAxIGMpXG5sZXQgc2V4cF9vZl9pbnQgbiA9IEF0b20gKHN0cmluZ19vZl9pbnQgbilcbmxldCBzZXhwX29mX2Zsb2F0IG4gPSBBdG9tICghZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgbilcbmxldCBzZXhwX29mX2ludDMyIG4gPSBBdG9tIChJbnQzMi50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX2ludDY0IG4gPSBBdG9tIChJbnQ2NC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX25hdGl2ZWludCBuID0gQXRvbSAoTmF0aXZlaW50LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfcmVmIHNleHBfb2ZfX2EgcmYgPSBzZXhwX29mX19hICFyZlxubGV0IHNleHBfb2ZfbGF6eV90IHNleHBfb2ZfX2EgbHYgPSBzZXhwX29mX19hIChMYXp5LmZvcmNlIGx2KVxuXG5sZXQgc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9fYSA9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgWyBzZXhwX29mX19hIHggXVxuICB8IFNvbWUgeCAtPiBMaXN0IFsgQXRvbSBcInNvbWVcIjsgc2V4cF9vZl9fYSB4IF1cbiAgfCBOb25lIHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgW11cbiAgfCBOb25lIC0+IEF0b20gXCJub25lXCJcbjs7XG5cbmxldCBzZXhwX29mX3BhaXIgc2V4cF9vZl9fYSBzZXhwX29mX19iIChhLCBiKSA9IExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYiBdXG5cbmxldCBzZXhwX29mX3RyaXBsZSBzZXhwX29mX19hIHNleHBfb2ZfX2Igc2V4cF9vZl9fYyAoYSwgYiwgYykgPVxuICBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGI7IHNleHBfb2ZfX2MgYyBdXG47O1xuXG4oKiBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIC4uLikgaXMgdGFpbCByZWN1cnNpdmUsIHRoZSBPQ2FtbCBzdGFuZGFyZFxuICAgbGlicmFyeSBMaXN0Lm1hcCBpcyBOT1QuICopXG5sZXQgc2V4cF9vZl9saXN0IHNleHBfb2ZfX2EgbHN0ID0gTGlzdCAoTGlzdC5yZXYgKExpc3QucmV2X21hcCBsc3QgfmY6c2V4cF9vZl9fYSkpXG5cbmxldCBzZXhwX29mX2FycmF5IHNleHBfb2ZfX2EgYXIgPVxuICBsZXQgbHN0X3JlZiA9IHJlZiBbXSBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhciAtIDEgZG93bnRvIDAgZG9cbiAgICBsc3RfcmVmIDo9IHNleHBfb2ZfX2EgYXIuKGkpIDo6ICFsc3RfcmVmXG4gIGRvbmU7XG4gIExpc3QgIWxzdF9yZWZcbjs7XG5cbmxldCBzZXhwX29mX2hhc2h0Ymwgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWwgaHRibCA9XG4gIGxldCBjb2xsIH5rZXk6ayB+ZGF0YTp2IGFjYyA9IExpc3QgWyBzZXhwX29mX2tleSBrOyBzZXhwX29mX3ZhbCB2IF0gOjogYWNjIGluXG4gIExpc3QgKEhhc2h0YmwuZm9sZCBodGJsIH5pbml0OltdIH5mOmNvbGwpXG47O1xuXG5sZXQgc2V4cF9vZl9vcGFxdWUgXyA9IEF0b20gXCI8b3BhcXVlPlwiXG5sZXQgc2V4cF9vZl9mdW4gXyA9IEF0b20gXCI8ZnVuPlwiXG5cbigqIEV4Y2VwdGlvbiBjb252ZXJ0ZXIgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgKilcblxubW9kdWxlIEV4bl9jb252ZXJ0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhlc2UgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgY29udGV4dC1zd2l0Y2hlc1xuICAgICBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGVyZSBpcyBhbiBhbGxvY2F0aW9uLiAgSXQgaXMgcmVhc29uYWJsZSB0byBleHBlY3RcbiAgICAgdGhhdCB0aGlzIHdpbGwgcmVtYWluIHRydWUgZm9yIHRoZSBmb3Jlc2VlYWJsZSBmdXR1cmUuICBUaGF0IHdheSB3ZVxuICAgICBhdm9pZCB1c2luZyBtdXRleGVzIGFuZCB0aHVzIGEgZGVwZW5kZW5jeSBvbiB0aGUgdGhyZWFkcyBsaWJyYXJ5LiAqKVxuXG4gICgqIEZhc3QgYW5kIGF1dG9tYXRpYyBleGNlcHRpb24gcmVnaXN0cmF0aW9uICopXG5cbiAgbW9kdWxlIFJlZ2lzdHJhdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IHNleHBfb2ZfZXhuIDogZXhuIC0+IFNleHAudFxuICAgICAgOyAoKiBJZiBbcHJpbnRleGMgPSB0cnVlXSB0aGVuIHRoaXMgc2V4cCBjb252ZXJ0ZXIgaXMgdXNlZCBmb3IgUHJpbnRleGMudG9fc3RyaW5nICopXG4gICAgICAgIHByaW50ZXhjIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgRXhuX3RhYmxlID0gRXBoZW1lcm9uLksxLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG5cbiAgICAgIGxldCBlcXVhbCA9ICggPT0gKVxuICAgICAgbGV0IGhhc2ggPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gICAgZW5kKVxuXG4gIGxldCB0aGVfZXhuX3RhYmxlIDogUmVnaXN0cmF0aW9uLnQgRXhuX3RhYmxlLnQgPSBFeG5fdGFibGUuY3JlYXRlIDE3XG5cbiAgKCogRXBoZW1lcm9ucyBhcmUgdXNlZCBzbyB0aGF0IFtzZXhwX29mX2V4bl0gY2xvc3VyZSBkb24ndCBrZWVwIHRoZVxuICAgICBleHRlbnNpb25fY29uc3RydWN0b3IgbGl2ZS4gKilcbiAgbGV0IGFkZCA/KHByaW50ZXhjID0gdHJ1ZSkgP2ZpbmFsaXNlOl8gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHNleHBfb2ZfZXhuID1cbiAgICBFeG5fdGFibGUuYWRkIHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH1cbiAgOztcblxuICBsZXQgZmluZF9hdXRvIH5mb3JfcHJpbnRleGMgZXhuID1cbiAgICBsZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuIGluXG4gICAgbWF0Y2ggRXhuX3RhYmxlLmZpbmRfb3B0IHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9IC0+XG4gICAgICAobWF0Y2ggZm9yX3ByaW50ZXhjLCBwcmludGV4YyB3aXRoXG4gICAgICAgfCBmYWxzZSwgXyB8IF8sIHRydWUgLT4gU29tZSAoc2V4cF9vZl9leG4gZXhuKVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gTm9uZSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3VuaXRfdGVzdHNfb25seSA9IHN0cnVjdFxuICAgIGxldCBzaXplICgpID0gKEV4bl90YWJsZS5zdGF0c19hbGl2ZSB0aGVfZXhuX3RhYmxlKS5udW1fYmluZGluZ3NcbiAgZW5kXG5lbmRcblxubGV0IHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4Yzp0cnVlIGV4blxubGV0IHNleHBfb2ZfZXhuX29wdCBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOmZhbHNlIGV4blxuXG5sZXQgc2V4cF9vZl9leG4gZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBMaXN0IFsgQXRvbSAoUHJpbnRleGMudG9fc3RyaW5nIGV4bikgXVxuICB8IFNvbWUgc2V4cCAtPiBzZXhwXG47O1xuXG5sZXQgZXhuX3RvX3N0cmluZyBlID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX2V4biBlKVxuXG4oKiB7W2V4Y2VwdGlvbiBCbGFoIFtAQGRlcml2aW5nIHNleHBdXX0gZ2VuZXJhdGVzIGEgY2FsbCB0byB0aGUgZnVuY3Rpb25cbiAgIFtFeG5fY29udmVydGVyLmFkZF0gZGVmaW5lZCBpbiB0aGlzIGZpbGUuICBTbyB3ZSBhcmUgZ3VhcmFudGVkIHRoYXQgYXMgc29vbiBhcyB3ZVxuICAgbWFyayBhbiBleGNlcHRpb24gYXMgc2V4cGFibGUsIHRoaXMgbW9kdWxlIHdpbGwgYmUgbGlua2VkIGluIGFuZCB0aGlzIHByaW50ZXIgd2lsbCBiZVxuICAgcmVnaXN0ZXJlZCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LiAqKVxubGV0ICgpID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuIGV4biAtPlxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBzZXhwIC0+IFNvbWUgKFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cCkpXG47O1xuXG5sZXQgcHJpbnRleGNfcHJlZmVyX3NleHAgZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBQcmludGV4Yy50b19zdHJpbmcgZXhuXG4gIHwgU29tZSBzZXhwIC0+IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cFxuOztcblxuKCogQ29udmVyc2lvbiBvZiBTLWV4cHJlc3Npb25zIHRvIE9DYW1sLXZhbHVlcyAqKVxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IFNleHAuT2Zfc2V4cF9lcnJvclxuXG5sZXQgcmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyA9IHJlZiB0cnVlXG5sZXQgb2Zfc2V4cF9lcnJvcl9leG4gZXhjIHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSlcbmxldCBvZl9zZXhwX2Vycm9yIHdoYXQgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChGYWlsdXJlIHdoYXQsIHNleHApKVxuXG5sZXQgdW5pdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+ICgpXG4gIHwgQXRvbSBfIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJ1bml0X29mX3NleHA6IGVtcHR5IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJvb2xfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSAoXCJ0cnVlXCIgfCBcIlRydWVcIikgLT4gdHJ1ZVxuICB8IEF0b20gKFwiZmFsc2VcIiB8IFwiRmFsc2VcIikgLT4gZmFsc2VcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogdW5rbm93biBzdHJpbmdcIiBzZXhwXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHN0cmluZ19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInN0cmluZ19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBieXRlc19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBCeXRlcy5vZl9zdHJpbmcgc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJieXRlc19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBjaGFyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzdHIgPD4gMVxuICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBzdHJpbmcgbXVzdCBjb250YWluIG9uZSBjaGFyYWN0ZXIgb25seVwiIHNleHA7XG4gICAgc3RyLlswXVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGludF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBmbG9hdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgZmxvYXRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiZmxvYXRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImZsb2F0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDMyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQzMi5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQzMl9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50MzJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50NjRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDY0Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDY0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQ2NF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBuYXRpdmVpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IE5hdGl2ZWludC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJuYXRpdmVpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm5hdGl2ZWludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCByZWZfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSByZWYgKGFfX29mX3NleHAgc2V4cClcbmxldCBsYXp5X3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSBMYXp5LmZyb21fdmFsIChhX19vZl9zZXhwIHNleHApXG5cbmxldCBvcHRpb25fb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBpZiAhcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdFxuICB0aGVuIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IExpc3QgW10gfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgZWwgXSB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IHJlcHJlc2VudCBvcHRpb25hbCB2YWx1ZVwiIHNleHBcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHApXG4gIGVsc2UgKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgYmUgKHNvbWUgZWwpXCIgc2V4cClcbjs7XG5cbmxldCBwYWlyX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgYSwgYlxuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdHdvIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHRyaXBsZV9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBjX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHA7IGNfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBsZXQgYyA9IGNfX29mX3NleHAgY19zZXhwIGluXG4gICAgYSwgYiwgY1xuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0aHJlZSBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGxpc3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCByZXZfbHN0ID0gTGlzdC5yZXZfbWFwIGxzdCB+ZjphX19vZl9zZXhwIGluXG4gICAgTGlzdC5yZXYgcmV2X2xzdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwibGlzdF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBhcnJheV9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gW3x8XVxuICB8IExpc3QgKGggOjogdCkgLT5cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggdCArIDEgaW5cbiAgICBsZXQgcmVzID0gQXJyYXkubWFrZSBsZW4gKGFfX29mX3NleHAgaCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJlc1xuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgcmVzLihpKSA8LSBhX19vZl9zZXhwIGg7XG4gICAgICAgIGxvb3AgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBsb29wIDEgdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYXJyYXlfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaGFzaHRibF9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCBodGJsID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIGxldCBhY3QgPSBmdW5jdGlvblxuICAgICAgfCBMaXN0IFsga19zZXhwOyB2X3NleHAgXSAtPlxuICAgICAgICBIYXNodGJsLmFkZCBodGJsIH5rZXk6KGtleV9vZl9zZXhwIGtfc2V4cCkgfmRhdGE6KHZhbF9vZl9zZXhwIHZfc2V4cClcbiAgICAgIHwgTGlzdCBfIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IHR1cGxlIGxpc3QgbmVlZGVkXCIgc2V4cFxuICAgIGluXG4gICAgTGlzdC5pdGVyIGxzdCB+ZjphY3Q7XG4gICAgaHRibFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBvcGFxdWVfb2Zfc2V4cCBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciBcIm9wYXF1ZV9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBvcGFxdWUgdmFsdWVzXCIgc2V4cFxuOztcblxubGV0IGZ1bl9vZl9zZXhwIHNleHAgPSBvZl9zZXhwX2Vycm9yIFwiZnVuX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IGZ1bmN0aW9uIHZhbHVlc1wiIHNleHBcblxuKCogU2V4cCBHcmFtbWFycyAqKVxuXG5pbmNsdWRlIFNleHBfY29udl9ncmFtbWFyXG5cbigqIFJlZ2lzdGVyaW5nIGRlZmF1bHQgZXhjZXB0aW9uIHByaW50ZXJzICopXG5cbmxldCBnZXRfZmxjX2Vycm9yIG5hbWUgKGZpbGUsIGxpbmUsIGNocikgPSBBdG9tIChzcHJpbnRmIFwiJXMgJXM6JWQ6JWRcIiBuYW1lIGZpbGUgbGluZSBjaHIpXG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4YzpmYWxzZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFzc2VydF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiQXNzZXJ0X2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEV4aXRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRXhpdCAtPiBBdG9tIFwiRXhpdFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFbmRfb2ZfZmlsZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFbmRfb2ZfZmlsZSAtPiBBdG9tIFwiRW5kX29mX2ZpbGVcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBGYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZCAtPiBBdG9tIFwiTm90X2ZvdW5kXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEludmFsaWRfYXJndW1lbnRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBhcmcgLT4gTGlzdCBbIEF0b20gXCJJbnZhbGlkX2FyZ3VtZW50XCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hdGNoX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTWF0Y2hfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIk1hdGNoX2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF9zXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZF9zIGFyZyAtPiBMaXN0IFsgQXRvbSBcIk5vdF9mb3VuZF9zXCI7IGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXNfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzX2Vycm9yIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlN5c19lcnJvclwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuSGVscF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuSGVscCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuSGVscFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuQmFkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5CYWQgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkJhZFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBMYXp5LlVuZGVmaW5lZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBMYXp5LlVuZGVmaW5lZCAtPiBBdG9tIFwiTGF6eS5VbmRlZmluZWRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUGFyc2luZy5QYXJzZV9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBQYXJzaW5nLlBhcnNlX2Vycm9yIC0+IEF0b20gXCJQYXJzaW5nLlBhcnNlX2Vycm9yXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFF1ZXVlLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFF1ZXVlLkVtcHR5IC0+IEF0b20gXCJRdWV1ZS5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTY2FuZi5TY2FuX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU2NhbmYuU2Nhbl9mYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlNjYW5mLlNjYW5fZmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTdGFjay5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTdGFjay5FbXB0eSAtPiBBdG9tIFwiU3RhY2suRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzLkJyZWFrXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5cy5CcmVhayAtPiBBdG9tIFwiU3lzLkJyZWFrXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOnRydWUgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBPZl9zZXhwX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkgLT5cbiAgICAgICAgICBMaXN0IFsgQXRvbSBcIlNleHBsaWIuQ29udi5PZl9zZXhwX2Vycm9yXCI7IHNleHBfb2ZfZXhuIGV4Yzsgc2V4cCBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4iLCIoKiBDb252X2Vycm9yOiBNb2R1bGUgZm9yIEhhbmRsaW5nIEVycm9ycyBkdXJpbmcgQXV0b21hdGVkIFMtZXhwcmVzc2lvblxuICAgQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBfY29udlxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IE9mX3NleHBfZXJyb3JcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgdHVwbGVzICopXG5cbmxldCB0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgbG9jIG4gc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCIlc19vZl9zZXhwOiB0dXBsZSBvZiBzaXplICVkIGV4cGVjdGVkXCIgbG9jIG4pIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHN1bSB0eXBlcyAqKVxuXG5sZXQgc3RhZ19ub19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhpcyBjb25zdHJ1Y3RvciBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgc3RhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyB0YWcgc2V4cCA9XG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogc3VtIHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIiBsb2MgdGFnIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBzdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGlzIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGEgbmVzdGVkIGxpc3RcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGFuIGVtcHR5IGxpc3RcIikgc2V4cFxuOztcblxubGV0IHVuZXhwZWN0ZWRfc3RhZyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHVuZXhwZWN0ZWQgdmFyaWFudCBjb25zdHJ1Y3RvclwiKSBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyByZWNvcmRzICopXG5cbmxldCByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvYyBeIFwiX29mX3NleHA6IHJlY29yZCBjb252ZXJzaW9uOiBhIFtzZXhwLmJvb2xdIGZpZWxkIHdhcyBnaXZlbiBhIHBheWxvYWQuXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jXG4gICAgXiBcIl9vZl9zZXhwOiByZWNvcmQgY29udmVyc2lvbjogb25seSBwYWlycyBleHBlY3RlZCwgdGhlaXIgZmlyc3QgZWxlbWVudCBtdXN0IGJlIGFuIFxcXG4gICAgICAgYXRvbVwiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0IH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgbGV0IGZsZF9uYW1lc19zdHIgPSBTdHJpbmcuY29uY2F0IChMaXN0LnJldiByZXZfZmxkX25hbWVzKSB+c2VwOlwiIFwiIGluXG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogJXM6ICVzXCIgbG9jIHdoYXQgZmxkX25hbWVzX3N0ciBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMgbG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQ6XCJkdXBsaWNhdGUgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWNvcmRfZXh0cmFfZmllbGRzIGxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0OlwiZXh0cmEgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWMgcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IFN0cmluZy5jb25jYXQgKExpc3QucmV2IGZpZWxkcykgfnNlcDpcIiBcIlxuICB8ICh0cnVlLCBmaWVsZCkgOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIChmaWVsZCA6OiBmaWVsZHMpIHJlc3RcbiAgfCBfIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgcmVzdFxuOztcblxubGV0IHJlY29yZF91bmRlZmluZWRfZWxlbWVudHMgbG9jIHNleHAgbHN0ID1cbiAgbGV0IHVuZGVmaW5lZCA9IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgW10gbHN0IGluXG4gIGxldCBtc2cgPVxuICAgIHNwcmludGYgXCIlc19vZl9zZXhwOiB0aGUgZm9sbG93aW5nIHJlY29yZCBlbGVtZW50cyB3ZXJlIHVuZGVmaW5lZDogJXNcIiBsb2MgdW5kZWZpbmVkXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gbG9jIHNleHAgPVxuICBsZXQgbXNnID0gbG9jIF4gXCJfb2Zfc2V4cDogbGlzdCBpbnN0ZWFkIG9mIGF0b20gZm9yIHJlY29yZCBleHBlY3RlZFwiIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfcG9seV9maWVsZF92YWx1ZSBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvY1xuICAgIF4gXCJfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgdmFsdWVzIG9mIHR5cGVzIHJlc3VsdGluZyBmcm9tIHBvbHltb3JwaGljIHJlY29yZCBmaWVsZHNcIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBwb2x5bW9ycGhpYyB2YXJpYW50cyAqKVxuXG5leGNlcHRpb24gTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fdmFyaWFudF9tYXRjaCAoKSA9IHJhaXNlIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBubyBtYXRjaGluZyB2YXJpYW50IGZvdW5kXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX25vX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIGNuc3RyIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmXG4gICAgICBcIiVzX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiXG4gICAgICBsb2NcbiAgICAgIGNuc3RyXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBwdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IHRhZyB0YWtlcyBhbiBhcmd1bWVudFwiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGEgbmVzdGVkIGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGUgZW1wdHkgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X3R5cGUgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0cnlpbmcgdG8gY29udmVydCBhbiBlbXB0eSB0eXBlXCIpIHNleHBcbjs7XG4iXX0=
