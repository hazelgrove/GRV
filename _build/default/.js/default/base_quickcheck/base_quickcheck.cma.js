// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck = [0];
   runtime.caml_register_global(0, Base_quickcheck, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _v_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _v_),
     _x_ = caml_ba_dim_1(t) - 1 | 0,
     _w_ = 0;
    if(_x_ >= 0){
     var i = _w_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      var i = _y_;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[19][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _u_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _u_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var _r_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _r_);
    function _s_(i){return caml_ba_get_1(t, i + offset | 0);}
    var _t_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[27], _t_, _s_);
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[91], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _q_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[117], state, _q_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _j_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _j_),
     _l_ = caml_ba_dim_1(t) - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var _n_ = caml_ba_dim_2(t) - 1 | 0, _m_ = 0;
      if(_n_ >= 0){
       var j = _m_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _p_ = j + 1 | 0;
        if(_n_ === j) break;
        var j = _p_;
       }
      }
      var _o_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _o_;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[20][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(param, _i_, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var _d_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _d_);
    function _e_(i){
     function _g_(j){return caml_ba_get_2(t, i + offset | 0, j + offset | 0);}
     var _h_ = caml_ba_dim_2(t);
     return caml_call2(Base_Array[27], _h_, _g_);
    }
    var _f_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[27], _f_, _e_);
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[91], sexp_of_elt);
    return caml_call2(Base[91], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[117], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[117], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[120], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[203], _d_);
   }
   function opaque(param, _b_, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Assert_failure, Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _az_ = [0, 0, 0],
    _au_ = [0, cst_upper_bound],
    _av_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _aw_ = [0, cst_upper_bound],
    _ax_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty",
    _h_ = [0, 0],
    _g_ = [0, 1],
    _f_ = [0, cst_src_generator_ml, 198, 4],
    _e_ = [0, cst_src_generator_ml, 225, 6],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _dv_ = [0, [1, [0, _a_, [0, caml_call1(Base[120], size), 0]]], 0],
     _dw_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _dv_]];
    return caml_call1(Base[203], _dw_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[1][5], random);
              return function(x){
               var
                _dt_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _dt_),
                random = caml_call1(Splittable_random[1][4], random$0),
                _du_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[1][3], random, _du_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[1][3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0, size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(param, _ds_){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              function _dq_(_dr_){return generate(_dr_, size, random);}
              return caml_call2(Base_List[76], list, _dq_);
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              function _do_(_dp_){return generate(_dp_, size, random);}
              return caml_call2(Base_List[9], list, _do_);
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[5], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2];
   function of_list(list){
    if(caml_call1(Base_List[8], list)){
     var
      _dn_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[30], _dn_);
    }
    var
     array = caml_call1(Base_Array[39], list),
     hi = array.length - 1 - 1 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[3], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[8], alist)){
     var
      _df_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[30], _df_);
    }
    var
     match = caml_call1(Base_List[92], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[39], values);
    function _dg_(param){return 0.;}
    var array = caml_call2(Base_Array[27], value_array.length - 1, _dg_);
    function _dh_(index, acc, weight){
     if(1 - caml_call1(Base_Float[84], weight)){
      var
       _dj_ = [0, [1, [0, _b_, [0, caml_call1(Base[113], weight), 0]]], 0],
       _dk_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
           _dj_]];
      caml_call1(Base_Error[30], _dk_);
     }
     if(caml_call2(Base_Float[13], weight, 0.)){
      var
       _dl_ = [0, [1, [0, _c_, [0, caml_call1(Base[113], weight), 0]]], 0],
       _dm_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
           _dl_]];
      caml_call1(Base_Error[30], _dm_);
     }
     var cumulative = caml_call2(Base[191], acc, weight);
     runtime.caml_array_set(array, index, cumulative);
     return cumulative;
    }
    var sum = caml_call3(Base_List[99], weights, 0., _dh_);
    if(caml_call2(Base_Float[10], sum, 0.)){
     var
      _di_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[30], _di_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[8], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[5],
                   0,
                   0,
                   array,
                   Base_Float[16],
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var _dd_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _dd_)
               var _de_ = lazy_t[1];
              else{
               if(246 !== _dd_ && 244 !== _dd_){var _de_ = lazy_t; break a;}
               var _de_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return generate(_de_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _dc_ = caml_obj_tag(lazy_t);
    if(250 === _dc_) return lazy_t[1];
    if(246 !== _dc_ && 244 !== _dc_) return lazy_t;
    return caml_call1(CamlinternalLazy[2], lazy_t);
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              function _c7_(param){
               var t = param[2], w = param[1];
               function _db_(n){return with_size(t, n - 1 | 0);}
               return [0, w, caml_call2(For_monad[11][4][2], size, _db_)];
              }
              var
               _c8_ = caml_call1(f, self),
               rec_list = caml_call2(Base_List[76], _c8_, _c7_),
               _c9_ = caml_call1(Base_List[8], nonrec_list),
               _c__ = _c9_ || caml_call1(Base_List[8], rec_list);
              if(_c__){
               var
                _c$_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[203], _c$_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[179], nonrec_list, rec_list));
              function _da_(param){return 0 === param ? nonrec_gen : rec_gen;}
              return caml_call2(For_monad[11][4][2], size, _da_);
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     function _c6_(t){return [0, 1., t];}
     return caml_call2(Base_List[76], list, _c6_);
    }
    function _c5_(self){return weighted(caml_call1(f, self));}
    return weighted_recursive_union(weighted(nonrec_list), _c5_);
   }
   function sizes(opt, _cS_, param){
    if(opt) var sth = opt[1], min_length = sth; else var min_length = 0;
    if(_cS_)
     var sth$0 = _cS_[1], max_length = sth$0;
    else
     var max_length = Base_Int[60];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[190], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[10][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              function _cT_(param){return 0;}
              var
               sizes = caml_call2(Base_Array[27], len, _cT_),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _cU_ = 1;
              if(remaining >= 1){
               var for$0 = _cU_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[10][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _c1_ = for$0 + 1 | 0;
                if(remaining === for$0) break;
                var for$0 = _c1_;
               }
              }
              var _cW_ = max_index - 1 | 0, _cV_ = 0;
              if(_cW_ >= 0){
               var i = _cV_;
               for(;;){
                var
                 j = caml_call3(Splittable_random[3], random, i, max_index);
                caml_call3(Base_Array[74], sizes, i, j);
                var _c0_ = i + 1 | 0;
                if(_cW_ === i) break;
                var i = _c0_;
               }
              }
              var _cX_ = len - min_length | 0;
              function _cY_(_c4_){return _c4_;}
              function _cZ_(_c3_, _c2_){return _c3_ + _c2_ | 0;}
              if
               ((caml_call3
                 (Base_Array[16], [0, Base_Int[74], _cZ_], sizes, _cY_)
                + _cX_
                | 0)
                === size)
               return caml_call1(Base_Array[19], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[2], random);
        });
   function option(value_t){
    var _cR_ = [0, map(value_t, Base_Option[20]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _cR_]);
   }
   function either(fst_t, snd_t){
    var _cQ_ = [0, map(snd_t, Base_Either[18]), 0];
    return union([0, map(fst_t, Base_Either[17]), _cQ_]);
   }
   function result(ok_t, err_t){
    function _cP_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _cP_);
   }
   function list_generic(min_length, max_length, elt_gen){
    function _cM_(sizes){
     function _cO_(size){return with_size(elt_gen, size);}
     return all(caml_call2(Base_List[76], sizes, _cO_));
    }
    var _cN_ = sizes(min_length, max_length, 0);
    return caml_call2(For_monad[11][4][2], _cN_, _cM_);
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[39], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[3], random, 0, length_of_input);
              function _cF_(_cL_){return _cL_;}
              var
               indices = caml_call2(Base_Array[27], length_of_input, _cF_),
               _cH_ = length_of_output - 1 | 0,
               _cG_ = 0;
              if(_cH_ >= 0){
               var i = _cG_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[3], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[74], indices, i, j);
                var _cJ_ = i + 1 | 0;
                if(_cH_ === i) break;
                var i = _cJ_;
               }
              }
              caml_call4
               (Base_Array[49],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[13]);
              function _cI_(i){
               var _cK_ = caml_check_bound(indices, i)[1 + i];
               return caml_check_bound(elts$0, _cK_)[1 + _cK_];
              }
              return caml_call2(Base_List[123], length_of_output, _cI_);
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[39], list),
               _cD_ = array.length - 1 - 1 | 0,
               _cC_ = 1;
              if(_cD_ >= 1){
               var i = _cC_;
               for(;;){
                var j = caml_call3(Splittable_random[3], random, 0, i);
                caml_call3(Base_Array[74], array, i, j);
                var _cE_ = i + 1 | 0;
                if(_cD_ === i) break;
                var i = _cE_;
               }
              }
              return caml_call1(Base_Array[19], array);
             });
   }
   function array(t){var _cB_ = Base_Array[39]; return map(list(t), _cB_);}
   function ref(t){return map(t, function(_cA_){return [0, _cA_];});}
   function lazy_t(t){return map(t, Base_Lazy[21]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _cx_ = caml_call1(Base_Char[29], hi),
               _cy_ = caml_call1(Base_Char[29], lo),
               _cz_ = caml_call3(Splittable_random[3], random, _cy_, _cx_);
              return caml_call1(Base_Char[32], _cz_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[50], Base_Char[51]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[54], Base_Char[1], Base_Char[42])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[51])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[50])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[10][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0);
   function For_integer(Integer){
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[96], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[97], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _cv_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _cw_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _cv_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _cw_]);
    }
    function inclusive(_ct_, _cu_){
     return non_uniform(uniform_inclusive, _ct_, _cu_);
    }
    function log_inclusive(_cr_, _cs_){
     return non_uniform(log_uniform_inclusive, _cr_, _cs_);
    }
    var
     uniform_all = uniform_inclusive(Integer[85], Integer[84]),
     let_syntax_004 = log_inclusive(Integer[38], Integer[84]);
    function _cp_(param){
     var magnitude = param[2], negative = param[1];
     return negative ? caml_call1(Integer[70], magnitude) : magnitude;
    }
    var
     _cq_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all = caml_call2(For_monad[11][4][3], _cq_, _cp_);
    return [0,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol$2 = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$3 = Base_Int[75],
    symbol$4 = Base_Int[76],
    symbol$5 = Base_Int[77],
    uniform = Splittable_random[3],
    log_uniform = Splittable_random[10][1];
   function _j_(_co_, _cn_){return _co_ >>> _cn_ | 0;}
   function _k_(_cm_, _cl_){return _cm_ >> _cl_;}
   function _l_(_ck_, _cj_){return _ck_ << _cj_;}
   var _m_ = O[2];
   function _n_(_ci_, _ch_){return _ci_ ^ _ch_;}
   function _o_(_cg_, _cf_){return _cg_ | _cf_;}
   function _p_(_ce_, _cd_){return _ce_ & _cd_;}
   var _q_ = O[7], _r_ = O[6], _s_ = O[5], _t_ = O[4];
   function _u_(_cc_){return - _cc_ | 0;}
   var _v_ = O[3];
   function _w_(_cb_, _ca_){return _cb_ !== _ca_ ? 1 : 0;}
   function _x_(_b$_, _b__){return _b$_ < _b__ ? 1 : 0;}
   function _y_(_b9_, _b8_){return _b8_ < _b9_ ? 1 : 0;}
   function _z_(_b7_, _b6_){return _b7_ === _b6_ ? 1 : 0;}
   function _A_(_b5_, _b4_){return _b5_ <= _b4_ ? 1 : 0;}
   function _B_(_b3_, _b2_){return _b2_ <= _b3_ ? 1 : 0;}
   var _C_ = O[1];
   function _D_(_b1_){return - _b1_ | 0;}
   var _E_ = caml_div, _F_ = caml_mul;
   function _G_(_b0_, _bZ_){return _b0_ - _bZ_ | 0;}
   var
    _H_ =
      [0,
       function(_bY_, _bX_){return _bY_ + _bX_ | 0;},
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_];
   function _I_(_bW_, _bV_){return _bW_ >>> _bV_ | 0;}
   function _J_(_bU_, _bT_){return _bU_ >> _bT_;}
   function _K_(_bS_, _bR_){return _bS_ << _bR_;}
   function _L_(_bQ_, _bP_){return _bQ_ ^ _bP_;}
   function _M_(_bO_, _bN_){return _bO_ | _bN_;}
   function _N_(_bM_, _bL_){return _bM_ & _bL_;}
   var _O_ = caml_div;
   function _P_(_bK_){return - _bK_ | 0;}
   function _Q_(_bJ_){return - _bJ_ | 0;}
   var _R_ = caml_mul;
   function _S_(_bI_, _bH_){return _bI_ - _bH_ | 0;}
   function _T_(_bG_, _bF_){return _bG_ + _bF_ | 0;}
   function _U_(_bE_, _bD_){return _bE_ !== _bD_ ? 1 : 0;}
   function _V_(_bC_, _bB_){return _bC_ < _bB_ ? 1 : 0;}
   function _W_(_bA_, _bz_){return _bz_ < _bA_ ? 1 : 0;}
   function _X_(_by_, _bx_){return _by_ === _bx_ ? 1 : 0;}
   function _Y_(_bw_, _bv_){return _bw_ <= _bv_ ? 1 : 0;}
   var
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_bu_, _bt_){return _bt_ <= _bu_ ? 1 : 0;},
         _Y_,
         _X_,
         _W_,
         _V_,
         _U_,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         _T_,
         _S_,
         _R_,
         symbol$2,
         _Q_,
         _P_,
         symbol$4,
         symbol$3,
         _O_,
         rem,
         symbol$5,
         _N_,
         _M_,
         _L_,
         lnot,
         _K_,
         _J_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _I_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _H_,
         uniform,
         log_uniform]),
    int$0 = For_int[7],
    int_uniform = For_int[6],
    int_inclusive = For_int[4],
    int_uniform_inclusive = For_int[1],
    int_log_inclusive = For_int[5],
    int_log_uniform_inclusive = For_int[2],
    t_sexp_grammar$0 = Base_Int32[1],
    of_float$0 = Base_Int32[2],
    to_float$0 = Base_Int32[3],
    of_int_exn$0 = Base_Int32[4],
    to_int_exn$0 = Base_Int32[5],
    hash_fold_t$0 = Base_Int32[6],
    hash$0 = Base_Int32[7],
    t_of_sexp$0 = Base_Int32[8],
    sexp_of_t$0 = Base_Int32[9],
    of_string$0 = Base_Int32[10],
    to_string$0 = Base_Int32[11],
    symbol$6 = Base_Int32[12],
    symbol$7 = Base_Int32[13],
    symbol$8 = Base_Int32[14],
    symbol$9 = Base_Int32[15],
    symbol$10 = Base_Int32[16],
    symbol$11 = Base_Int32[17],
    equal$0 = Base_Int32[18],
    compare$0 = Base_Int32[19],
    min$0 = Base_Int32[20],
    max$0 = Base_Int32[21],
    ascending$0 = Base_Int32[22],
    descending$0 = Base_Int32[23],
    between$0 = Base_Int32[24],
    clamp_exn$0 = Base_Int32[25],
    clamp$0 = Base_Int32[26],
    comparator$0 = Base_Int32[27],
    pp$0 = Base_Int32[28],
    hashable$0 = Base_Int32[29],
    is_positive$0 = Base_Int32[30],
    is_non_negative$0 = Base_Int32[31],
    is_negative$0 = Base_Int32[32],
    is_non_positive$0 = Base_Int32[33],
    sign$0 = Base_Int32[34],
    invariant$0 = Base_Int32[35],
    Hex$0 = Base_Int32[36],
    to_string_hum$0 = Base_Int32[37],
    zero$0 = Base_Int32[38],
    one$0 = Base_Int32[39],
    minus_one$0 = Base_Int32[40],
    symbol$12 = Base_Int32[41],
    symbol$13 = Base_Int32[42],
    symbol$14 = Base_Int32[43],
    symbol$15 = Base_Int32[44],
    neg = Base_Int32[45],
    symbol$16 = Base_Int32[46],
    symbol$17 = Base_Int32[47],
    symbol$18 = Base_Int32[48],
    symbol$19 = Base_Int32[49],
    rem$0 = Base_Int32[50],
    symbol$20 = Base_Int32[51],
    land = Base_Int32[52],
    lor = Base_Int32[53],
    lxor = Base_Int32[54],
    lnot$0 = Base_Int32[55],
    lsl = Base_Int32[56],
    asr = Base_Int32[57],
    round$0 = Base_Int32[58],
    round_towards_zero$0 = Base_Int32[59],
    round_down$0 = Base_Int32[60],
    round_up$0 = Base_Int32[61],
    round_nearest$0 = Base_Int32[62],
    abs$0 = Base_Int32[63],
    succ$0 = Base_Int32[64],
    pred$0 = Base_Int32[65],
    pow$0 = Base_Int32[66],
    bit_and$0 = Base_Int32[67],
    bit_or$0 = Base_Int32[68],
    bit_xor$0 = Base_Int32[69],
    bit_not$0 = Base_Int32[70],
    popcount$0 = Base_Int32[71],
    shift_left$0 = Base_Int32[72],
    shift_right$0 = Base_Int32[73],
    decr$0 = Base_Int32[74],
    incr$0 = Base_Int32[75],
    of_int32_exn$0 = Base_Int32[76],
    to_int32_exn$0 = Base_Int32[77],
    of_int64_exn$0 = Base_Int32[78],
    to_int64$0 = Base_Int32[79],
    of_nativeint_exn$0 = Base_Int32[80],
    to_nativeint_exn$0 = Base_Int32[81],
    of_float_unchecked$0 = Base_Int32[82],
    num_bits$0 = Base_Int32[83],
    max_value$0 = Base_Int32[84],
    min_value$0 = Base_Int32[85],
    lsr = Base_Int32[86],
    shift_right_logical$0 = Base_Int32[87],
    ceil_pow2$0 = Base_Int32[88],
    floor_pow2$0 = Base_Int32[89],
    ceil_log2$0 = Base_Int32[90],
    floor_log2$0 = Base_Int32[91],
    is_pow2$0 = Base_Int32[92],
    clz$0 = Base_Int32[93],
    ctz$0 = Base_Int32[94],
    O$0 = Base_Int32[95],
    uniform$0 = Splittable_random[4],
    log_uniform$0 = Splittable_random[10][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[7],
    int32_uniform = For_int32[6],
    int32_inclusive = For_int32[4],
    int32_uniform_inclusive = For_int32[1],
    int32_log_inclusive = For_int32[5],
    int32_log_uniform_inclusive = For_int32[2],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    to_string_hum$1 = Base_Int63[37],
    zero$1 = Base_Int63[38],
    one$1 = Base_Int63[39],
    minus_one$1 = Base_Int63[40],
    symbol$27 = Base_Int63[41],
    symbol$28 = Base_Int63[42],
    symbol$29 = Base_Int63[43],
    symbol$30 = Base_Int63[44],
    neg$0 = Base_Int63[45],
    symbol$31 = Base_Int63[46],
    symbol$32 = Base_Int63[47],
    symbol$33 = Base_Int63[48],
    symbol$34 = Base_Int63[49],
    rem$1 = Base_Int63[50],
    symbol$35 = Base_Int63[51],
    land$0 = Base_Int63[52],
    lor$0 = Base_Int63[53],
    lxor$0 = Base_Int63[54],
    lnot$1 = Base_Int63[55],
    lsl$0 = Base_Int63[56],
    asr$0 = Base_Int63[57],
    round$1 = Base_Int63[58],
    round_towards_zero$1 = Base_Int63[59],
    round_down$1 = Base_Int63[60],
    round_up$1 = Base_Int63[61],
    round_nearest$1 = Base_Int63[62],
    abs$1 = Base_Int63[63],
    succ$1 = Base_Int63[64],
    pred$1 = Base_Int63[65],
    pow$1 = Base_Int63[66],
    bit_and$1 = Base_Int63[67],
    bit_or$1 = Base_Int63[68],
    bit_xor$1 = Base_Int63[69],
    bit_not$1 = Base_Int63[70],
    popcount$1 = Base_Int63[71],
    shift_left$1 = Base_Int63[72],
    shift_right$1 = Base_Int63[73],
    decr$1 = Base_Int63[74],
    incr$1 = Base_Int63[75],
    of_int32_exn$1 = Base_Int63[76],
    to_int32_exn$1 = Base_Int63[77],
    of_int64_exn$1 = Base_Int63[78],
    to_int64$1 = Base_Int63[79],
    of_nativeint_exn$1 = Base_Int63[80],
    to_nativeint_exn$1 = Base_Int63[81],
    of_float_unchecked$1 = Base_Int63[82],
    num_bits$1 = Base_Int63[83],
    max_value$1 = Base_Int63[84],
    min_value$1 = Base_Int63[85],
    lsr$0 = Base_Int63[86],
    shift_right_logical$1 = Base_Int63[87],
    ceil_pow2$1 = Base_Int63[88],
    floor_pow2$1 = Base_Int63[89],
    ceil_log2$1 = Base_Int63[90],
    is_pow2$1 = Base_Int63[91],
    clz$1 = Base_Int63[92],
    ctz$1 = Base_Int63[93],
    O$1 = Base_Int63[94],
    floor_log2$1 = Base_Int63[113],
    uniform$1 = Splittable_random[5],
    log_uniform$1 = Splittable_random[10][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[7],
    int63_uniform = For_int63[6],
    int63_inclusive = For_int63[4],
    int63_uniform_inclusive = For_int63[1],
    int63_log_inclusive = For_int63[5],
    int63_log_uniform_inclusive = For_int63[2],
    t_sexp_grammar$2 = Base_Int64[1],
    of_float$2 = Base_Int64[2],
    to_float$2 = Base_Int64[3],
    of_int_exn$2 = Base_Int64[4],
    to_int_exn$2 = Base_Int64[5],
    hash_fold_t$2 = Base_Int64[6],
    hash$2 = Base_Int64[7],
    t_of_sexp$2 = Base_Int64[8],
    sexp_of_t$2 = Base_Int64[9],
    of_string$2 = Base_Int64[10],
    to_string$2 = Base_Int64[11],
    equal$2 = Base_Int64[12],
    compare$2 = Base_Int64[13],
    min$2 = Base_Int64[14],
    max$2 = Base_Int64[15],
    ascending$2 = Base_Int64[16],
    descending$2 = Base_Int64[17],
    between$2 = Base_Int64[18],
    clamp_exn$2 = Base_Int64[19],
    clamp$2 = Base_Int64[20],
    comparator$2 = Base_Int64[21],
    pp$2 = Base_Int64[22],
    hashable$2 = Base_Int64[23],
    is_positive$2 = Base_Int64[24],
    is_non_negative$2 = Base_Int64[25],
    is_negative$2 = Base_Int64[26],
    is_non_positive$2 = Base_Int64[27],
    sign$2 = Base_Int64[28],
    invariant$2 = Base_Int64[29],
    Hex$2 = Base_Int64[30],
    to_string_hum$2 = Base_Int64[31],
    one$2 = Base_Int64[32],
    minus_one$2 = Base_Int64[33],
    rem$2 = Base_Int64[34],
    round$2 = Base_Int64[35],
    round_towards_zero$2 = Base_Int64[36],
    round_down$2 = Base_Int64[37],
    round_up$2 = Base_Int64[38],
    round_nearest$2 = Base_Int64[39],
    succ$2 = Base_Int64[40],
    pred$2 = Base_Int64[41],
    pow$2 = Base_Int64[42],
    bit_and$2 = Base_Int64[43],
    bit_or$2 = Base_Int64[44],
    bit_xor$2 = Base_Int64[45],
    bit_not$2 = Base_Int64[46],
    popcount$2 = Base_Int64[47],
    shift_left$2 = Base_Int64[48],
    shift_right$2 = Base_Int64[49],
    decr$2 = Base_Int64[50],
    incr$2 = Base_Int64[51],
    of_int32_exn$2 = Base_Int64[52],
    to_int32_exn$2 = Base_Int64[53],
    of_int64_exn$2 = Base_Int64[54],
    to_int64$2 = Base_Int64[55],
    of_nativeint_exn$2 = Base_Int64[56],
    to_nativeint_exn$2 = Base_Int64[57],
    of_float_unchecked$2 = Base_Int64[58],
    num_bits$2 = Base_Int64[59],
    max_value$2 = Base_Int64[60],
    min_value$2 = Base_Int64[61],
    shift_right_logical$2 = Base_Int64[62],
    ceil_pow2$2 = Base_Int64[63],
    floor_pow2$2 = Base_Int64[64],
    ceil_log2$2 = Base_Int64[65],
    floor_log2$2 = Base_Int64[66],
    is_pow2$2 = Base_Int64[67],
    clz$2 = Base_Int64[68],
    ctz$2 = Base_Int64[69],
    O$2 = Base_Int64[70],
    symbol$36 = Base_Int64[71],
    lnot$2 = Base_Int64[72],
    abs$2 = Base_Int64[73],
    zero$2 = Base_Int64[74],
    symbol$37 = Base_Int64[75],
    symbol$38 = Base_Int64[76],
    symbol$39 = Base_Int64[77],
    uniform$2 = Splittable_random[6],
    log_uniform$2 = Splittable_random[10][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[7],
    int64_uniform = For_int64[6],
    int64_inclusive = For_int64[4],
    int64_uniform_inclusive = For_int64[1],
    int64_log_inclusive = For_int64[5],
    int64_log_uniform_inclusive = For_int64[2],
    t_sexp_grammar$3 = Base_Nativeint[1],
    of_float$3 = Base_Nativeint[2],
    to_float$3 = Base_Nativeint[3],
    of_int_exn$3 = Base_Nativeint[4],
    to_int_exn$3 = Base_Nativeint[5],
    hash_fold_t$3 = Base_Nativeint[6],
    hash$3 = Base_Nativeint[7],
    t_of_sexp$3 = Base_Nativeint[8],
    sexp_of_t$3 = Base_Nativeint[9],
    of_string$3 = Base_Nativeint[10],
    to_string$3 = Base_Nativeint[11],
    symbol$40 = Base_Nativeint[12],
    symbol$41 = Base_Nativeint[13],
    symbol$42 = Base_Nativeint[14],
    symbol$43 = Base_Nativeint[15],
    symbol$44 = Base_Nativeint[16],
    symbol$45 = Base_Nativeint[17],
    equal$3 = Base_Nativeint[18],
    compare$3 = Base_Nativeint[19],
    min$3 = Base_Nativeint[20],
    max$3 = Base_Nativeint[21],
    ascending$3 = Base_Nativeint[22],
    descending$3 = Base_Nativeint[23],
    between$3 = Base_Nativeint[24],
    clamp_exn$3 = Base_Nativeint[25],
    clamp$3 = Base_Nativeint[26],
    comparator$3 = Base_Nativeint[27],
    pp$3 = Base_Nativeint[28],
    hashable$3 = Base_Nativeint[29],
    is_positive$3 = Base_Nativeint[30],
    is_non_negative$3 = Base_Nativeint[31],
    is_negative$3 = Base_Nativeint[32],
    is_non_positive$3 = Base_Nativeint[33],
    sign$3 = Base_Nativeint[34],
    invariant$3 = Base_Nativeint[35],
    Hex$3 = Base_Nativeint[36],
    to_string_hum$3 = Base_Nativeint[37],
    zero$3 = Base_Nativeint[38],
    one$3 = Base_Nativeint[39],
    minus_one$3 = Base_Nativeint[40],
    symbol$46 = Base_Nativeint[41],
    symbol$47 = Base_Nativeint[42],
    symbol$48 = Base_Nativeint[43],
    symbol$49 = Base_Nativeint[44],
    neg$1 = Base_Nativeint[45],
    symbol$50 = Base_Nativeint[46],
    symbol$51 = Base_Nativeint[47],
    symbol$52 = Base_Nativeint[48],
    symbol$53 = Base_Nativeint[49],
    rem$3 = Base_Nativeint[50],
    symbol$54 = Base_Nativeint[51],
    land$1 = Base_Nativeint[52],
    lor$1 = Base_Nativeint[53],
    lxor$1 = Base_Nativeint[54],
    lnot$3 = Base_Nativeint[55],
    lsl$1 = Base_Nativeint[56],
    asr$1 = Base_Nativeint[57],
    round$3 = Base_Nativeint[58],
    round_towards_zero$3 = Base_Nativeint[59],
    round_down$3 = Base_Nativeint[60],
    round_up$3 = Base_Nativeint[61],
    round_nearest$3 = Base_Nativeint[62],
    abs$3 = Base_Nativeint[63],
    succ$3 = Base_Nativeint[64],
    pred$3 = Base_Nativeint[65],
    pow$3 = Base_Nativeint[66],
    bit_and$3 = Base_Nativeint[67],
    bit_or$3 = Base_Nativeint[68],
    bit_xor$3 = Base_Nativeint[69],
    bit_not$3 = Base_Nativeint[70],
    popcount$3 = Base_Nativeint[71],
    shift_left$3 = Base_Nativeint[72],
    shift_right$3 = Base_Nativeint[73],
    decr$3 = Base_Nativeint[74],
    incr$3 = Base_Nativeint[75],
    of_int32_exn$3 = Base_Nativeint[76],
    to_int32_exn$3 = Base_Nativeint[77],
    of_int64_exn$3 = Base_Nativeint[78],
    to_int64$3 = Base_Nativeint[79],
    of_nativeint_exn$3 = Base_Nativeint[80],
    to_nativeint_exn$3 = Base_Nativeint[81],
    of_float_unchecked$3 = Base_Nativeint[82],
    num_bits$3 = Base_Nativeint[83],
    max_value$3 = Base_Nativeint[84],
    min_value$3 = Base_Nativeint[85],
    lsr$1 = Base_Nativeint[86],
    shift_right_logical$3 = Base_Nativeint[87],
    ceil_pow2$3 = Base_Nativeint[88],
    floor_pow2$3 = Base_Nativeint[89],
    ceil_log2$3 = Base_Nativeint[90],
    floor_log2$3 = Base_Nativeint[91],
    is_pow2$3 = Base_Nativeint[92],
    clz$3 = Base_Nativeint[93],
    ctz$3 = Base_Nativeint[94],
    O$3 = Base_Nativeint[95],
    uniform$3 = Splittable_random[7],
    log_uniform$3 = Splittable_random[10][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[7],
    nativeint_uniform = For_nativeint[6],
    nativeint_inclusive = For_nativeint[4],
    nativeint_uniform_inclusive = For_nativeint[1],
    nativeint_log_inclusive = For_nativeint[5],
    nativeint_log_uniform_inclusiv = For_nativeint[2],
    float_zero_exponent = caml_call1(Base_Float[121], 0.),
    float_zero_mantissa = caml_call1(Base_Float[122], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[51], 759637122, Base_Float[47]),
    float_subnormal_exponent = caml_call1(Base_Float[121], Base_Float[46]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[122], Base_Float[46]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[45],
    float_min_normal_exponent = caml_call1(Base_Float[121], Base_Float[47]),
    float_max_normal_exponent =
      caml_call1(Base_Float[121], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[121], Base_Float[33]),
    float_inf_mantissa = caml_call1(Base_Float[122], Base_Float[33]),
    float_nan_exponent = caml_call1(Base_Float[121], Base_Float[32]),
    float_min_nan_mantissa = caml_call1(Base_Int63[64], float_inf_mantissa),
    float_num_mantissa_bits = 52;
   function _Z_(num_bits){
    function _bp_(bits){
     return caml_call2(Base_Int63[72], bits, 52 - num_bits | 0);
    }
    var
     _bq_ = caml_call2(Base_Int63[72], Base_Int63[39], num_bits),
     _br_ = caml_call1(Base_Int63[65], _bq_),
     _bs_ = For_int63[4].call(null, Base_Int63[38], _br_);
    return caml_call2(For_monad[11][4][3], _bs_, _bp_);
   }
   var
    ___ = For_int[1].call(null, 0, float_num_mantissa_bits),
    float_normal_mantissa = caml_call2(For_monad[11][4][2], ___, _Z_),
    lower_bound = caml_call1(Base_Float[121], 1.),
    _ad_ = 0;
   function _$_(offset){return lower_bound + offset | 0;}
   var
    _aa_ =
      For_int[5].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    _ae_ = [0, caml_call2(For_monad[11][4][3], _aa_, _$_), _ad_];
   function _ab_(offset){return lower_bound - offset | 0;}
   var
    _ac_ =
      For_int[5].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union([0, caml_call2(For_monad[11][4][3], _ac_, _ab_), _ae_]);
   function _af_(negative){
    return caml_call3
            (Base_Float[119],
             negative,
             float_zero_exponent,
             float_zero_mantissa);
   }
   var
    float_zero = caml_call2(For_monad[11][4][3], bool, _af_),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[5].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa);
   function _ag_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ah_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _ai_ = caml_call2(For_monad[11][4][4], bool, _ah_),
    float_subnormal = caml_call2(For_monad[11][4][3], _ai_, _ag_);
   function _aj_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ak_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _al_ = caml_call2(For_monad[11][4][4], bool, _ak_),
    float_normal = caml_call2(For_monad[11][4][3], _al_, _aj_);
   function _am_(negative){
    return caml_call3
            (Base_Float[119],
             negative,
             float_inf_exponent,
             float_inf_mantissa);
   }
   var
    float_infinite = caml_call2(For_monad[11][4][3], bool, _am_),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[4].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa);
   function _an_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ao_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _ap_ = caml_call2(For_monad[11][4][4], bool, _ao_),
    float_nan = caml_call2(For_monad[11][4][3], _ap_, _an_);
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    function _bm_(c){
     if(! caml_call1(filter, c)) return 0;
     var _bn_ = float_of_class(c);
     switch(c){
       case 0:
        var _bo_ = 1.; break;
       case 1:
        var _bo_ = 1.; break;
       case 2:
        var _bo_ = 100.; break;
       case 3:
        var _bo_ = 10.; break;
       default: var _bo_ = 1.;
     }
     return [0, [0, _bo_, _bn_]];
    }
    return weighted_union
            (caml_call2(Base_List[126], Base_Float[113][2], _bm_));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;});
   function _aq_(t){return caml_call1(Base_Float[102], t);}
   var
    float_strictly_positive =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _aq_);
   function _ar_(t){
    var _bl_ = caml_call1(Base_Float[102], t);
    return caml_call1(Base[197], _bl_);
   }
   var
    float_strictly_negative =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _ar_);
   function _as_(t){return caml_call1(Base_Float[102], t);}
   var
    float_positive_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _as_);
   function _at_(t){
    var _bk_ = caml_call1(Base_Float[102], t);
    return caml_call1(Base[197], _bk_);
   }
   var
    float_negative_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _at_);
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _bc_ = 1 - caml_call1(Base_Float[84], lower_bound),
     _bd_ = _bc_ || 1 - caml_call1(Base_Float[84], upper_bound);
    if(_bd_){
     var
      _be_ =
        [0, [1, [0, _au_, [0, caml_call1(Base[113], upper_bound), 0]]], 0],
      _bf_ =
        [0, [1, [0, _av_, [0, caml_call1(Base[113], lower_bound), 0]]], _be_],
      _bg_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _bf_]];
     caml_call1(Base[203], _bg_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[51], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[51], 759637122, upper_bound);
    if(caml_call2(Base_Float[103][11], lower_inclusive, upper_inclusive)){
     var
      _bh_ =
        [0, [1, [0, _aw_, [0, caml_call1(Base[113], upper_bound), 0]]], 0],
      _bi_ =
        [0, [1, [0, _ax_, [0, caml_call1(Base[113], lower_bound), 0]]], _bh_],
      _bj_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _bi_]];
     caml_call1(Base[203], _bj_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[8],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(caml_call2(Base_Float[15], lower_bound, upper_bound))
     return caml_call1(For_monad[11][1], lower_bound);
    var _a__ = caml_call2(Base_Float[51], 19067, lower_bound);
    if(caml_call2(Base_Float[11], _a__, upper_bound)){
     var _a$_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _a$_]);
    }
    var
     _ba_ =
       [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _bb_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _ba_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _bb_]);
   }
   function string_with_length_of(char_gen, length){
    var _a9_ = list_with_length(char_gen, length);
    return map(_a9_, Base_String[123]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   var bytes = map(string, Base_Bytes[25]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              function _a3_(size){
               function _a4_(param){
                if(0 === param){
                 var _a6_ = function(atom){return [0, atom];};
                 return caml_call2(For_monad[11][4][3], atom, _a6_);
                }
                function _a7_(list){return [1, list];}
                var _a8_ = list(self);
                return caml_call2(For_monad[11][4][3], _a8_, _a7_);
               }
               var _a5_ = For_int[2].call(null, 0, size + 1 | 0);
               return caml_call2(For_monad[11][4][2], _a5_, _a4_);
              }
              return caml_call2(For_monad[11][4][2], size, _a3_);
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    function _aX_(keys){
     var keys$0 = caml_call2(Base_List[114], keys, comparator[1]);
     function _aZ_(data){
      var
       _a1_ = caml_call2(Base_List[95], keys$0, data),
       _a2_ = caml_call2(Base_Map[104][3][9], comparator, _a1_);
      return caml_call1(For_monad[11][1], _a2_);
     }
     var _a0_ = list_with_length(data_gen, caml_call1(Base_List[7], keys$0));
     return caml_call2(For_monad[11][4][2], _a0_, _aZ_);
    }
    var _aY_ = list(key_gen);
    return caml_call2(For_monad[11][4][2], _aY_, _aX_);
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _aW_ = caml_call1(Base_Set[74][3][54], comparator);
    return map(list(elt_gen), _aW_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _aV_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_aV_, caml_call1(Base_Map[104][95], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _aU_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_aU_, caml_call1(Base_Set[74][64], comparator));
   }
   function bigarray1(t, kind, layout){
    function _aQ_(elts){
     var
      elts$0 = caml_call1(Base_Array[39], elts),
      dim = elts$0.length - 1,
      offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
     function _aS_(i){
      var _aT_ = i - offset | 0;
      return caml_check_bound(elts$0, _aT_)[1 + _aT_];
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2], kind, layout, dim, _aS_);
    }
    var _aR_ = list(t);
    return caml_call2(For_monad[11][4][3], _aR_, _aQ_);
   }
   var
    bigstring = bigarray1(char$0, 12, 0),
    float32_vec = bigarray1(float$0, 0, 1),
    float64_vec = bigarray1(float$0, 1, 1);
   function _ay_(max_total_size){
    if(0 === max_total_size) return caml_call1(For_monad[11][1], _az_);
    function _aJ_(a){
     function _aL_(b){
      function _aP_(param){return param ? [0, a, b] : [0, b, a];}
      return caml_call2(For_monad[11][4][3], bool, _aP_);
     }
     var max_b = caml_div(max_total_size, a);
     function _aM_(b_weighted_low){return max_b - b_weighted_low | 0;}
     var
      _aN_ = int_log_uniform_inclusive(0, max_b),
      _aO_ = caml_call2(For_monad[11][4][3], _aN_, _aM_);
     return caml_call2(For_monad[11][4][2], _aO_, _aL_);
    }
    var _aK_ = int_log_uniform_inclusive(1, max_total_size);
    return caml_call2(For_monad[11][4][2], _aK_, _aJ_);
   }
   var bigarray2_dim = caml_call2(For_monad[11][4][2], size, _ay_);
   function bigarray2(t, kind, layout){
    function _aD_(param){
     var dim2 = param[2], dim1 = param[1];
     function _aE_(elts){
      var
       elts$0 = caml_call2(Base_Array[78], elts, Base_Array[39]),
       offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
      function _aG_(i, j){
       var _aH_ = j - offset | 0, _aI_ = i - offset | 0;
       return caml_check_bound(caml_check_bound(elts$0, _aI_)[1 + _aI_], _aH_)
               [1 + _aH_];
      }
      return caml_call5
              (Base_quickcheck_Bigarray_helpe[3][2],
               kind,
               layout,
               dim1,
               dim2,
               _aG_);
     }
     var _aF_ = list_with_length(list_with_length(t, dim2), dim1);
     return caml_call2(For_monad[11][4][3], _aF_, _aE_);
    }
    return caml_call2(For_monad[11][4][2], bigarray2_dim, _aD_);
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp){
    return function(sample){
     function _aA_(counts, value){
      function _aC_(param){
       if(! param) return 1;
       var prev = param[1];
       return prev + 1 | 0;
      }
      return caml_call3(Base_Map[35], counts, value, _aC_);
     }
     var _aB_ = caml_call1(Base_Map[6], Cmp);
     return caml_call3(Base_Sequence[8], sample, _aB_, _aA_);};
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (79, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    cst_dim2 = "dim2",
    cst_dim1 = "dim1";
   function atomic(param){return Base_Sequence[38];}
   function create(_ax_){return _ax_;}
   function shrink(_aw_){return _aw_;}
   function map(t, f, f_inverse){
    return function(x){
     var _av_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[32], _av_, f);};
   }
   function filter(t, f){
    return function(x){
     var _au_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[51], _au_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _at_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[78], _at_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     var
      _ap_ =
        [246,
         function(_aq_){
          var _ar_ = caml_obj_tag(lazy_t);
          a:
          if(250 === _ar_)
           var _as_ = lazy_t[1];
          else{
           if(246 !== _ar_ && 244 !== _ar_){var _as_ = lazy_t; break a;}
           var _as_ = caml_call1(CamlinternalLazy[2], lazy_t);
          }
          return caml_call1(_as_, x);
         }];
     return caml_call1(Base_Sequence[105], _ap_);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var snd = param[2], fst = param[1], _ai_ = 0;
     function _aj_(snd){return [0, fst, snd];}
     var
      _ak_ = caml_call1(snd_t, snd),
      _al_ = [0, caml_call2(Base_Sequence[32], _ak_, _aj_), _ai_];
     function _am_(fst){return [0, fst, snd];}
     var
      _an_ = caml_call1(fst_t, fst),
      _ao_ = [0, caml_call2(Base_Sequence[32], _an_, _am_), _al_];
     return caml_call1(Base_Sequence[68], _ao_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    function _ag_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function _ah_(i){
      var i$0 = i < to_skip$0 ? i : i + 1 | 0;
      return runtime.caml_ba_get_1(src, i$0);
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2],
              kind,
              layout,
              dim - 1 | 0,
              _ah_);
    }
    return caml_call2(Base_Sequence[77], dim, _ag_);
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = 0,
    dim2$0 = [0, function(param){return 0;}, cst_dim2, _b_, dim2, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = 0,
    dim1$0 = [0, function(param){return 0;}, cst_dim1, _d_, dim1, _c_];
   function shrink$0(field, src){
    var
     _ac_ = runtime.caml_ba_dim_2(src),
     dims = [0, caml_ba_dim_1(src), _ac_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[41]),
     dim2 = match[2],
     dim1 = match[1];
    function _ad_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
     function _af_(dim1, dim2){
      var
       match = caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
       dim2$0 = match[2],
       dim1$0 = match[1];
      return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
     }
     return caml_call5
             (Base_quickcheck_Bigarray_helpe[3][2],
              kind,
              layout,
              dim1,
              dim2,
              _af_);
    }
    var _ae_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2(Base_Sequence[77], _ae_, _ad_);
   }
   function float32_mat(src){
    var
     _aa_ = [0, shrink$0(dim2$0, src), 0],
     _ab_ = [0, shrink$0(dim1$0, src), _aa_];
    return caml_call1(Base_Sequence[68], _ab_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[38];
     var
      value = param[1],
      _Y_ = Base_Option[20],
      _Z_ = caml_call1(value_t, value),
      ___ = caml_call2(Base_Sequence[32], _Z_, _Y_),
      _$_ = caml_call1(Base_Sequence[99], 0);
     return caml_call2(Base_Sequence[63], _$_, ___);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[38];
               var tail = param[2], head = param[1], _Q_ = 0;
               function _R_(tail){return [0, head, tail];}
               var
                _S_ = caml_call1(list_t, tail),
                _T_ = [0, caml_call2(Base_Sequence[32], _S_, _R_), _Q_];
               function _U_(head){return [0, head, tail];}
               var
                _V_ = caml_call1(elt_t, head),
                _W_ = [0, caml_call2(Base_Sequence[32], _V_, _U_), _T_],
                _X_ = [0, caml_call1(Base_Sequence[99], tail), _W_];
               return caml_call1(Base_Sequence[68], _X_);};
             });
   }
   var
    _e_ = Base_String[16],
    _f_ = Base_String[123],
    string = map(list(atomic), _f_, _e_),
    bytes = map(string, Base_Bytes[25], Base_Bytes[26]);
   function array(t){
    var _O_ = Base_Array[19], _P_ = Base_Array[39];
    return map(list(t), _P_, _O_);
   }
   function ref(t){
    function _L_(_N_){return _N_[1];}
    return map(t, function(_M_){return [0, _M_];}, _L_);
   }
   function lazy_t(t){
    function _I_(_J_){
     var _K_ = caml_obj_tag(_J_);
     if(250 === _K_) return _J_[1];
     if(246 !== _K_ && 244 !== _K_) return _J_;
     return caml_call1(CamlinternalLazy[2], _J_);
    }
    return map(t, Base_Lazy[21], _I_);
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[38];
          var
           l = param[1],
           _G_ = list(shrinker)(l),
           _H_ = Base_Sequence[32],
           shrink_list = caml_call2(_H_, _G_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[104], l);
          return caml_call1
                  (Base_Sequence[68], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _C_ = Base_Either[17],
       _D_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[32], _D_, _C_);
     }
     var snd = either[1], _E_ = Base_Either[18], _F_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[32], _F_, _E_);};
   }
   function result(ok_t, err_t){
    function _A_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    function _B_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _B_, _A_);
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var alist = caml_call2(Base_Map[104][3][66], 0, tree);
     function _q_(param){
      var k = param[1];
      return caml_call3(Base_Map[104][3][39], comparator, tree, k);
     }
     var
      _r_ = caml_call1(Base_Sequence[104], alist),
      drop_keys = caml_call2(Base_Sequence[32], _r_, _q_);
     function _s_(param){
      var
       data = param[2],
       key = param[1],
       tree$0 = caml_call3(Base_Map[104][3][39], comparator, tree, key);
      function _y_(smaller_key){
       var
        match =
          caml_call4
           (Base_Map[104][3][29], comparator, tree$0, smaller_key, data);
       if(typeof match === "number") return 0;
       var tree = match[2];
       return [0, tree];
      }
      var _z_ = caml_call1(key_t, key);
      return caml_call2(Base_Sequence[78], _z_, _y_);
     }
     var
      _t_ = caml_call2(Base_List[76], alist, _s_),
      shrink_keys = caml_call1(Base_Sequence[68], _t_);
     function _u_(param){
      var data = param[2], key = param[1];
      function _w_(smaller_data){
       return caml_call4
               (Base_Map[104][3][31], comparator, tree, key, smaller_data);
      }
      var _x_ = caml_call1(data_t, data);
      return caml_call2(Base_Sequence[32], _x_, _w_);
     }
     var
      _v_ = caml_call2(Base_List[76], alist, _u_),
      shrink_data = caml_call1(Base_Sequence[68], _v_);
     return caml_call1
             (Base_Sequence[68],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var list = caml_call1(Base_Set[74][3][15], tree);
     function _k_(elt){
      return caml_call3(Base_Set[74][3][20], comparator, tree, elt);
     }
     var
      _l_ = caml_call1(Base_Sequence[104], list),
      drop_elts = caml_call2(Base_Sequence[32], _l_, _k_);
     function _m_(elt){
      var tree$0 = caml_call3(Base_Set[74][3][20], comparator, tree, elt);
      function _o_(smaller_elt){
       return caml_call3(Base_Set[74][3][18], comparator, tree$0, smaller_elt)
               ? 0
               : [0,
                 caml_call3
                  (Base_Set[74][3][19], comparator, tree$0, smaller_elt)];
      }
      var _p_ = caml_call1(elt_t, elt);
      return caml_call2(Base_Sequence[78], _p_, _o_);
     }
     var
      _n_ = caml_call2(Base_List[76], list, _m_),
      shrink_elts = caml_call1(Base_Sequence[68], _n_);
     return caml_call1(Base_Sequence[68], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _i_ = Base_Map[104][68],
      _j_ = caml_call1(Base_Map[104][95], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _j_, _i_);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _g_ = Base_Set[74][47],
      _h_ = caml_call1(Base_Set[74][64], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _h_, _g_);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (17, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__Field, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_seed$0 = "seed",
    cst_shrink_count$0 = "shrink_count",
    cst_sizes$0 = "sizes",
    cst_test_count$0 = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    names =
      [0,
       cst_seed$0,
       [0, cst_test_count$0, [0, cst_shrink_count$0, [0, cst_sizes$0, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_Field = global_data.Base__Field,
    Base_List = global_data.Base__List,
    _w_ = [0, 0],
    _x_ = [0, "error"],
    _y_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed",
    _u_ = [0, 0],
    _v_ = [0, 0],
    _s_ = [0, "number_of_size_values"],
    _t_ = [0, cst_test_count$0],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _k_ = [0, cst_sizes$0],
    _l_ = [0, cst_shrink_count$0],
    _m_ = [0, cst_test_count$0],
    _n_ = [0, cst_seed$0],
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"],
    cst_sizes = cst_sizes$0,
    cst_shrink_count = cst_shrink_count$0,
    cst_test_count = cst_test_count$0,
    cst_seed = cst_seed$0,
    _o_ = [0, 104758188],
    _p_ = [0, 104758188],
    _r_ = [0, "an arbitrary but deterministic string"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[165], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sizes(r){return r[4];}
   function shrink_count(r){return r[3];}
   function test_count(r){return r[2];}
   function seed(r){return r[1];}
   function _c_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _d_ = 0,
    sizes$0 = [0, function(param){return 0;}, cst_sizes, _d_, sizes, _c_];
   function _e_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _f_ = 0,
    shrink_count$0 =
      [0,
       function(param){return 0;},
       cst_shrink_count,
       _f_,
       shrink_count,
       _e_];
   function _g_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _h_ = 0,
    test_count$0 =
      [0, function(param){return 0;}, cst_test_count, _h_, test_count, _g_];
   function _i_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _j_ = 0,
    seed$0 = [0, function(param){return 0;}, cst_seed, _j_, seed, _i_];
   function make_creator
   (seed_fun, test_count_fun, shrink_count_fun, sizes_fun, compile_acc){
    var
     match = caml_call2(seed_fun, seed$0, compile_acc),
     compile_acc$0 = match[2],
     seed_gen = match[1],
     match$0 = caml_call2(test_count_fun, test_count$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     test_count_gen = match$0[1],
     match$1 = caml_call2(shrink_count_fun, shrink_count$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     shrink_count_gen = match$1[1],
     match$2 = caml_call2(sizes_fun, sizes$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     sizes_gen = match$2[1];
    return [0,
            function(acc){
             var
              seed = caml_call1(seed_gen, acc),
              test_count = caml_call1(test_count_gen, acc),
              shrink_count = caml_call1(shrink_count_gen, acc),
              sizes = caml_call1(sizes_gen, acc);
             return [0, seed, test_count, shrink_count, sizes];
            },
            compile_acc$3];
   }
   function create(seed, test_count, shrink_count, sizes){return [0, seed, test_count, shrink_count, sizes];
   }
   function map(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _aA_ = caml_call1(sizes_fun, sizes$0),
     _aB_ = caml_call1(shrink_count_fun, shrink_count$0),
     _aC_ = caml_call1(test_count_fun, test_count$0);
    return [0, caml_call1(seed_fun, seed$0), _aC_, _aB_, _aA_];
   }
   function iter(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call1(seed_fun, seed$0);
    caml_call1(test_count_fun, test_count$0);
    caml_call1(shrink_count_fun, shrink_count$0);
    return caml_call1(sizes_fun, sizes$0);
   }
   function fold(init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    return caml_call2
            (sizes_fun,
             caml_call2
              (shrink_count_fun,
               caml_call2
                (test_count_fun,
                 caml_call2(seed_fun, init, seed$0),
                 test_count$0),
               shrink_count$0),
             sizes$0);
   }
   function map_poly(record){
    var
     _ax_ = [0, caml_call1(record[1], sizes$0), 0],
     _ay_ = [0, caml_call1(record[1], shrink_count$0), _ax_],
     _az_ = [0, caml_call1(record[1], test_count$0), _ay_];
    return [0, caml_call1(record[1], seed$0), _az_];
   }
   function for_all(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _au_ = caml_call1(seed_fun, seed$0),
     _av_ = _au_ ? caml_call1(test_count_fun, test_count$0) : _au_,
     _aw_ = _av_ ? caml_call1(shrink_count_fun, shrink_count$0) : _av_;
    return _aw_ ? caml_call1(sizes_fun, sizes$0) : _aw_;
   }
   function exists(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _at_ = caml_call1(seed_fun, seed$0),
     _ar_ = _at_ || caml_call1(test_count_fun, test_count$0),
     _as_ = _ar_ || caml_call1(shrink_count_fun, shrink_count$0);
    return _as_ ? _as_ : caml_call1(sizes_fun, sizes$0);
   }
   function to_list(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ao_ = [0, caml_call1(sizes_fun, sizes$0), 0],
     _ap_ = [0, caml_call1(shrink_count_fun, shrink_count$0), _ao_],
     _aq_ = [0, caml_call1(test_count_fun, test_count$0), _ap_];
    return [0, caml_call1(seed_fun, seed$0), _aq_];
   }
   function iter$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call3(seed_fun, seed$0, record, record[1]);
    caml_call3(test_count_fun, test_count$0, record, record[2]);
    caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function fold$0
   (record, init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var _al_ = record[4], _am_ = record[3], _an_ = record[2];
    return caml_call4
            (sizes_fun,
             caml_call4
              (shrink_count_fun,
               caml_call4
                (test_count_fun,
                 caml_call4(seed_fun, init, seed$0, record, record[1]),
                 test_count$0,
                 record,
                 _an_),
               shrink_count$0,
               record,
               _am_),
             sizes$0,
             record,
             _al_);
   }
   function for_all$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ai_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _aj_ =
       _ai_
        ? caml_call3(test_count_fun, test_count$0, record, record[2])
        : _ai_,
     _ak_ =
       _aj_
        ? caml_call3(shrink_count_fun, shrink_count$0, record, record[3])
        : _aj_;
    return _ak_ ? caml_call3(sizes_fun, sizes$0, record, record[4]) : _ak_;
   }
   function exists$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ah_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _af_ =
       _ah_ || caml_call3(test_count_fun, test_count$0, record, record[2]),
     _ag_ =
       _af_ || caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return _ag_ ? _ag_ : caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function to_list$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ac_ = [0, caml_call3(sizes_fun, sizes$0, record, record[4]), 0],
     _ad_ =
       [0,
        caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
        _ac_],
     _ae_ =
       [0, caml_call3(test_count_fun, test_count$0, record, record[2]), _ad_];
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _ae_];
   }
   function map$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _$_ = caml_call3(sizes_fun, sizes$0, record, record[4]),
     _aa_ = caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
     _ab_ = caml_call3(test_count_fun, test_count$0, record, record[2]);
    return [0,
            caml_call3(seed_fun, seed$0, record, record[1]),
            _ab_,
            _aa_,
            _$_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[120],
     match = caml_call2(Base_Sequence[88], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[76], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[6], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[179], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _k_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[120], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _l_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[120], test_count_006),
     bnds_003$2 = [0, [1, [0, _m_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _n_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _q_ = caml_call5(Base_List[121], 0, _p_, _o_, 0, 30),
    default_config =
      [0, _r_, 10000, 10000, caml_call1(Base_Sequence[97], _q_)],
    lazy_nondeterministic_state =
      [246, function(___){return caml_call2(Base_Random[18][3], 0, 0);}];
   function with_sample(f, opt, _W_, generator){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_W_) var sth$0 = _W_[1], examples = sth$0; else var examples = 0;
    var match = config[1];
    if(match)
     var
      string = match[1],
      _O_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[1][2], _O_);
    else{
     var _P_ = runtime.caml_obj_tag(lazy_nondeterministic_state);
     a:
     if(250 === _P_)
      var _Q_ = lazy_nondeterministic_state[1];
     else{
      if(246 !== _P_ && 244 !== _P_){
       var _Q_ = lazy_nondeterministic_state;
       break a;
      }
      var _Q_ = caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state);
     }
     var random = caml_call1(Splittable_random[1][1], _Q_);
    }
    function _R_(param){
     var number_of_size_values = param[2], sizes = param[1];
     if(config[2] <= number_of_size_values) return 0;
     var match = caml_call1(Base_Sequence[39], sizes);
     if(match){
      var match$0 = match[1], remaining_sizes = match$0[2], size = match$0[1];
      return [0,
              [0, size, [0, remaining_sizes, number_of_size_values + 1 | 0]]];
     }
     var
      _X_ =
        [0,
         [1, [0, _s_, [0, caml_call1(Base[120], number_of_size_values), 0]]],
         0],
      _Y_ = [0, [1, [0, _t_, [0, caml_call1(Base[120], config[2]), 0]]], _X_],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
          _Y_]];
     return caml_call1(Base[203], _Z_);
    }
    var
     _S_ = caml_call2(Base_Sequence[42], [0, config[4], 0], _R_),
     _T_ = Base_Sequence[32],
     _U_ =
       caml_call2
        (_T_,
         _S_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[118], generator, size, random);
         }),
     _V_ = caml_call1(Base_Sequence[104], examples),
     sequence = caml_call2(Base_Sequence[63], _V_, _U_);
    return caml_call1(f, sequence);
   }
   function result(f, opt, _J_, m){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_J_) var sth$0 = _J_[1], examples = sth$0; else var examples = 0;
    var _K_ = m[2], _L_ = [0, examples], _M_ = [0, config];
    return with_sample
            (function(sequence){
              function _N_(param, input){
               var match = caml_call1(f, input);
               if(0 === match[0]) return _u_;
               var error = match[1];
               return [1, [0, input, error]];
              }
              var match$2 = caml_call3(Base_Sequence[9], sequence, 0, _N_);
              if(0 === match$2[0]) return _v_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[39], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  var
                   shrink_count = shrink_count$0,
                   alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate),
                  shrink_count = shrink_count$0,
                  alternates = alternates$1,
                  input = alternate,
                  error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             _M_,
             _L_,
             _K_);
   }
   function run(f, config, examples, M){
    function f$0(x){
     function _H_(param){return caml_call1(f, x);}
     var _I_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[29], _I_, _H_);
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _w_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _E_ = [0, [1, [0, _x_, [0, caml_call1(Base_Error[6], error), 0]]], 0],
     _F_ = [0, [1, [0, _y_, [0, caml_call1(M[1], input), 0]]], _E_],
     _G_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _F_]];
    return caml_call1(Base_Or_error[35], _G_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     function _D_(param){return caml_call1(f, x);}
     return caml_call2(Base_Or_error[28], 0, _D_);
    }
    var _C_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[31], _C_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     function _A_(param){return caml_call1(f, x);}
     var _B_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[28], _B_, _A_);
    }
    var _z_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[31], _z_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0,
        Seed,
        sizes,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$0,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold,
         make_creator,
         create,
         map,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (37, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3],
    _a_ = [0, 0];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var _s_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _s_)
               var _t_ = lazy_t[1];
              else{
               if(246 !== _s_ && 244 !== _s_){var _t_ = lazy_t; break a;}
               var _t_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return caml_call4(observe, _t_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[3]),
    char$0 = of_hash_fold(Base_Char[3]),
    int$0 = of_hash_fold(Base_Int[6]),
    int32 = of_hash_fold(Base_Int32[6]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[6]),
    nativeint = of_hash_fold(Base_Nativeint[6]),
    float$0 = of_hash_fold(Base_Float[4]),
    string = of_hash_fold(Base_String[26]),
    sexp = of_hash_fold(Base[85][1]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[102])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[110])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[110])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[110])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[110])),
    bytes = unmap(string, Base_Bytes[26]);
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[117], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[117], hash, 2));
             });
   }
   function result(ok_t, err_t){
    function _r_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return unmap(either(ok_t, err_t), _r_);
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    function _q_(param){
     if(! param) return _a_;
     var value = param[1];
     return [1, value];
    }
    return unmap(either(opaque, value_t), _q_);
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _m_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _m_),
               length = caml_call1(Base_List[7], list),
               _n_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[118], _n_, size, random);
              function _o_(hash, elt, size){
               return caml_call4
                       (observe, elt_t, elt, size, caml_call2(Base[117], hash, 1));
              }
              var _p_ = caml_call2(Base[117], hash, 0);
              return caml_call4(Base_List[46], list, sizes, _p_, _o_);
             });
   }
   function array(t){var _l_ = Base_Array[19]; return unmap(list(t), _l_);}
   function ref(t){return unmap(t, function(_k_){return _k_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_i_){
              var _j_ = caml_obj_tag(_i_);
              if(250 === _j_) return _i_[1];
              if(246 !== _j_ && 244 !== _j_) return _i_;
              return caml_call1(CamlinternalLazy[2], _i_);
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _f_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _f_),
               _g_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[118], _g_, size * 2 | 0, random);
              function _h_(hash, size){
               var
                x =
                  caml_call3
                   (Base_quickcheck_Generator[118], dom, size, random);
               return caml_call4(observe, rng, caml_call1(f, x), size, hash);
              }
              return caml_call3(Base_List[10], sizes, hash, _h_);
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[104][3][66];
    function _e_(eta){return caml_call2(arg, 0, eta);}
    return unmap(list(both(key_obs, data_obs)), _e_);
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[74][3][15];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[104][68];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[74][47];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm9mZnNldCIsIml0ZXJpIiwidCIsImYiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwiaW5pdCQwIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJzdGF0ZSQwIiwiaXRlcmkkMCIsImoiLCJkaW0xIiwiZGltMiIsImZvbGQkMCIsImVsdCIsInRvX2FycmF5JDAiLCJzZXhwX29mX3QkMCIsInhfMDAyIiwiaGFzaF9mb2xkJDAiLCJzdGF0ZSQxIiwiY3JlYXRlIiwib2JzZXJ2ZSIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsImlnbm9yZV9tIiwiam9pbiIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5IiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsInN1bSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwidyIsIm4iLCJyZWNfbGlzdCIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInVuaXQiLCJib29sIiwib3B0aW9uIiwidmFsdWVfdCIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImxpc3RfZ2VuZXJpYyIsImVsdF9nZW4iLCJsaXN0X25vbl9lbXB0eSIsImxpc3Rfd2l0aF9sZW5ndGgiLCJsZW5ndGgiLCJsaXN0X2ZpbHRlcmVkIiwiZWx0cyIsImVsdHMkMCIsImxlbmd0aF9vZl9pbnB1dCIsImxlbmd0aF9vZl9vdXRwdXQiLCJpbmRpY2VzIiwibGlzdF9wZXJtdXRhdGlvbnMiLCJyZWYiLCJjaGFyX3VuaWZvcm1faW5jbHVzaXZlIiwiY2hhcl91cHBlcmNhc2UiLCJjaGFyX2xvd2VyY2FzZSIsImNoYXJfZGlnaXQiLCJjaGFyX3ByaW50X3VuaWZvcm0iLCJjaGFyX3VuaWZvcm0iLCJjaGFyX2FscGhhIiwiY2hhcl9hbHBoYW51bSIsImNoYXJfd2hpdGVzcGFjZSIsImNoYXJfcHJpbnQiLCJjaGFyJDAiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJ1bmlmb3JtX2luY2x1c2l2ZSIsImxvZ191bmlmb3JtX2luY2x1c2l2ZSIsIm5vbl91bmlmb3JtIiwiaW5jbHVzaXZlIiwibG9nX2luY2x1c2l2ZSIsInVuaWZvcm1fYWxsIiwibGV0X3N5bnRheF8wMDQiLCJtYWduaXR1ZGUiLCJuZWdhdGl2ZSIsInVuaWZvcm0iLCJsb2dfdW5pZm9ybSIsImludCQwIiwiaW50X3VuaWZvcm0iLCJpbnRfaW5jbHVzaXZlIiwiaW50X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50X2xvZ19pbmNsdXNpdmUiLCJpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIiwidW5pZm9ybSQwIiwibG9nX3VuaWZvcm0kMCIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJzeW1ib2wkMzYiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInVuaWZvcm0kMiIsImxvZ191bmlmb3JtJDIiLCJpbnQ2NCIsImludDY0X3VuaWZvcm0iLCJpbnQ2NF9pbmNsdXNpdmUiLCJpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2xvZ19pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJ1bmlmb3JtJDMiLCJsb2dfdW5pZm9ybSQzIiwibmF0aXZlaW50IiwibmF0aXZlaW50X3VuaWZvcm0iLCJuYXRpdmVpbnRfaW5jbHVzaXZlIiwibmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlIiwibmF0aXZlaW50X2xvZ19pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXYiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X251bV9tYW50aXNzYV9iaXRzIiwibnVtX2JpdHMiLCJiaXRzIiwiZmxvYXRfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfZXhwb25lbnQiLCJmbG9hdF96ZXJvIiwibGV0X3N5bnRheF8wMTIiLCJsZXRfc3ludGF4XzAxMyIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJmbG9hdF9zdWJub3JtYWwiLCJmbG9hdF9ub3JtYWwiLCJmbG9hdF9pbmZpbml0ZSIsImxldF9zeW50YXhfMDIxIiwibGV0X3N5bnRheF8wMjIiLCJmbG9hdF9uYW4iLCJmbG9hdF9vZl9jbGFzcyIsImMiLCJmbG9hdF9tYXRjaGluZ19jbGFzc2VzIiwiZmxvYXRfZmluaXRlIiwiZmxvYXRfd2l0aG91dF9uYW4iLCJmbG9hdCQwIiwiZmxvYXRfZmluaXRlX25vbl96ZXJvIiwiZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUiLCJmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSIsImZsb2F0X3Bvc2l0aXZlX29yX3plcm8iLCJmbG9hdF9uZWdhdGl2ZV9vcl96ZXJvIiwiZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUiLCJsb3dlcl9pbmNsdXNpdmUiLCJ1cHBlcl9pbmNsdXNpdmUiLCJmbG9hdF9pbmNsdXNpdmUiLCJzdHJpbmdfd2l0aF9sZW5ndGhfb2YiLCJjaGFyX2dlbiIsInN0cmluZ19vZiIsInN0cmluZ19ub25fZW1wdHlfb2YiLCJzdHJpbmciLCJzdHJpbmdfbm9uX2VtcHR5Iiwic3RyaW5nX3dpdGhfbGVuZ3RoIiwiYnl0ZXMiLCJzZXhwX29mIiwiYXRvbSIsInNleHAiLCJtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIiwiY29tcGFyYXRvciIsImtleV9nZW4iLCJkYXRhX2dlbiIsImtleXMiLCJrZXlzJDAiLCJkYXRhIiwic2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciIsIm1hcF90X20iLCJtIiwic2V0X3RfbSIsImJpZ2FycmF5MSIsImJpZ3N0cmluZyIsImZsb2F0MzJfdmVjIiwiZmxvYXQ2NF92ZWMiLCJtYXhfdG90YWxfc2l6ZSIsImEiLCJiIiwibWF4X2IiLCJiX3dlaWdodGVkX2xvdyIsImJpZ2FycmF5Ml9kaW0iLCJiaWdhcnJheTIiLCJmbG9hdDMyX21hdCIsImZsb2F0NjRfbWF0IiwiY292ZXJhZ2UiLCJDbXAiLCJzYW1wbGUiLCJjb3VudHMiLCJ2YWx1ZSIsInByZXYiLCJtb25pdG9yIiwiYXRvbWljIiwic2hyaW5rIiwiZl9pbnZlcnNlIiwib2Zfc2hyaW5rZXIiLCJzbmQiLCJmc3QiLCJzcmMiLCJ0b19za2lwIiwidG9fc2tpcCQwIiwiaSQwIiwiciIsInYiLCJkaW0yJDAiLCJkaW0xJDAiLCJzaHJpbmskMCIsImZpZWxkIiwiZGltcyIsInNraXAiLCJlbHRfdCIsImxpc3RfdCIsInRhaWwiLCJoZWFkIiwic2hyaW5rZXIiLCJsIiwic2hyaW5rX2xpc3QiLCJzaHJpbmtfdHJlZSIsImtleV90IiwiZGF0YV90IiwidHJlZSIsImsiLCJkcm9wX2tleXMiLCJrZXkiLCJ0cmVlJDAiLCJzbWFsbGVyX2tleSIsInNocmlua19rZXlzIiwic21hbGxlcl9kYXRhIiwic2hyaW5rX2RhdGEiLCJkcm9wX2VsdHMiLCJzbWFsbGVyX2VsdCIsInNocmlua19lbHRzIiwibWFwX3QiLCJzZXRfdCIsIm5hbWVzIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsInNocmlua19jb3VudCIsInRlc3RfY291bnQiLCJzZWVkIiwic2l6ZXMkMCIsInNocmlua19jb3VudCQwIiwidGVzdF9jb3VudCQwIiwic2VlZCQwIiwibWFrZV9jcmVhdG9yIiwic2VlZF9mdW4iLCJ0ZXN0X2NvdW50X2Z1biIsInNocmlua19jb3VudF9mdW4iLCJzaXplc19mdW4iLCJjb21waWxlX2FjYyIsImNvbXBpbGVfYWNjJDAiLCJzZWVkX2dlbiIsImNvbXBpbGVfYWNjJDEiLCJ0ZXN0X2NvdW50X2dlbiIsImNvbXBpbGVfYWNjJDIiLCJzaHJpbmtfY291bnRfZ2VuIiwiY29tcGlsZV9hY2MkMyIsInNpemVzX2dlbiIsIml0ZXIiLCJtYXBfcG9seSIsInJlY29yZCIsImZvcl9hbGwiLCJleGlzdHMiLCJ0b19saXN0IiwiaXRlciQwIiwiZm9yX2FsbCQwIiwiZXhpc3RzJDAiLCJ0b19saXN0JDAiLCJzZXRfYWxsX211dGFibGVfZmllbGRzIiwic2l6ZXNfMDEwIiwic2hyaW5rX2NvdW50XzAwOCIsInRlc3RfY291bnRfMDA2Iiwic2VlZF8wMDQiLCJzdWZmaXgiLCJwcmVmaXgiLCJwcmVmaXgkMCIsImJuZHNfMDAzIiwic3VmZml4JDAiLCJhcmdfMDExIiwiYm5kc18wMDMkMCIsImFyZ18wMDkiLCJibmRzXzAwMyQxIiwiYXJnXzAwNyIsImJuZHNfMDAzJDIiLCJhcmdfMDA1IiwiYm5kc18wMDMkMyIsImRlZmF1bHRfY29uZmlnIiwibGF6eV9ub25kZXRlcm1pbmlzdGljX3N0YXRlIiwid2l0aF9zYW1wbGUiLCJnZW5lcmF0b3IiLCJjb25maWciLCJleGFtcGxlcyIsIm51bWJlcl9vZl9zaXplX3ZhbHVlcyIsInJlbWFpbmluZ19zaXplcyIsInNlcXVlbmNlIiwiaW5wdXQiLCJlcnJvciIsImVycm9yJDEiLCJpbnB1dCQwIiwic2hyaW5rX2NvdW50JDEiLCJhbHRlcm5hdGVzJDIiLCJhbHRlcm5hdGVzIiwiYWx0ZXJuYXRlcyQwIiwiYWx0ZXJuYXRlIiwiZXJyb3IkMCIsImFsdGVybmF0ZXMkMSIsInJ1biIsIk0iLCJmJDAiLCJ3aXRoX3NhbXBsZV9leG4iLCJydW5fZXhuIiwidGVzdGFibGUiLCJ1bm1hcCIsIm9mX2hhc2hfZm9sZCIsIndyYXAiLCJoYXNoJDAiLCJoYXNoJDEiLCJtYXBfdHJlZSIsImtleV9vYnMiLCJkYXRhX29icyIsInNldF90cmVlIiwiZWx0X29icyJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZV9xdWlja2NoZWNrL2JpZ2FycmF5X2hlbHBlcnMubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlcjAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2VfcXVpY2tjaGVjay9nZW5lcmF0b3IubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL29jYW1sL2ludDY0Lm1saSIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZV9xdWlja2NoZWNrL3Nocmlua2VyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlX3F1aWNrY2hlY2svdGVzdC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlX3F1aWNrY2hlY2svYmFzZV9xdWlja2NoZWNrLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7WUFLTUEsY0FBQSxxQkFFc0I7R0FMWixpQkFHVkE7WUFTQUMsTUFBTUMsR0FBR0M7SUFDWDtLQUEyQixNQUFBLGVBRG5CRDtLQUNKRixTQUFTO0tBQ0EsTUFBQSxjQUZMRTtLQUNLOztTQUNiRTs7TUFDRSxXQUhTRCxHQUVYQyxJQURJSixZ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RDtPQVlBVTtPQUNBaUU7T0FDQWhEO09BM0JBeEI7T0FiQW9EO09BT0FHO09BZEFnSztPQUNBQztPQUNBQztPQUNBUTtPQUNBQztPQTZDQXpQO09BbUJBeVM7T0FJQUM7T0FWQW9GO09BSUFHO09BckZBUDtPQURBRDtPQUlBelU7T0FGQUY7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7O0dDT2E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5cbm1vZHVsZSBMYXlvdXQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgQmlnYXJyYXkubGF5b3V0XG5cbiAgbGV0IG9mZnNldCA6IHR5cGUgYS4gYSB0IC0+IGludCA9IGZ1bmN0aW9uXG4gICAgfCBCaWdhcnJheS5Gb3J0cmFuX2xheW91dCAtPiAxXG4gICAgfCBCaWdhcnJheS5DX2xheW91dCAtPiAwXG4gIDs7XG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEJpZ2FycmF5LkFycmF5MS50XG5cbiAgbGV0IGl0ZXJpIHQgfmYgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgZm9yIGkgPSAwIHRvIEJpZ2FycmF5LkFycmF5MS5kaW0gdCAtIDEgZG9cbiAgICAgIGYgKGkgKyBvZmZzZXQpIHQue2kgKyBvZmZzZXR9XG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBpbml0ICh0eXBlIGVsdCkgKGtpbmQgOiAoZWx0LCBfKSBCaWdhcnJheS5raW5kKSBsYXlvdXQgZGltIH5mID1cbiAgICBsZXQgdCA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IHQue2l9IDwtIGYgaSk7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIChfIDogZWx0KSAtPiBpbml0IDo9IGYgIWluaXQgdC57aX0pO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkxLmRpbSB0KSB+ZjooZnVuIGkgLT4gdC57aSArIG9mZnNldH0pXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBfc2V4cF9vZl9wYWNrIF9zZXhwX29mX2xheW91dCB0ID1cbiAgICBbJXNleHAgKHRvX2FycmF5IHQgOiBlbHQgYXJyYXkpXVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGQgaGFzaF9mb2xkX2VsdCBzdGF0ZSB0ID1cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTEuZGltIHQpIGluXG4gICAgZm9sZCB0IH5pbml0OnN0YXRlIH5mOmhhc2hfZm9sZF9lbHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkyLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5Mi5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCAtIDEgZG9cbiAgICAgIGZvciBqID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMiB0IC0gMSBkb1xuICAgICAgICBmIChpICsgb2Zmc2V0KSAoaiArIG9mZnNldCkgdC57aSArIG9mZnNldCwgaiArIG9mZnNldH1cbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0xIGRpbTIgfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkyLmNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSBqIChfIDogZWx0KSAtPiB0LntpLCBqfSA8LSBmIGkgaik7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biAoXyA6IGludCkgKF8gOiBpbnQpIGVsdCAtPiBpbml0IDo9IGYgIWluaXQgZWx0KTtcbiAgICAhaW5pdFxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIEFycmF5LmluaXQgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIH5mOihmdW4gaSAtPlxuICAgICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgfmY6KGZ1biBqIC0+IHQue2kgKyBvZmZzZXQsIGogKyBvZmZzZXR9KSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIGluXG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgJ2EgdCA9ICdhIC0+IHNpemU6aW50IC0+IGhhc2g6SGFzaC5zdGF0ZSAtPiBIYXNoLnN0YXRlXG5cbmxldCBjcmVhdGUgZiA6IF8gdCA9IGZcblxubGV0IG9ic2VydmUgKHQgOiBfIHQpIHggfnNpemUgfmhhc2ggPVxuICBpZiBzaXplIDwgMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLk9ic2VydmVyLm9ic2VydmU6IHNpemUgPCAwXCIgKHNpemUgOiBpbnQpXVxuICBlbHNlIHQgeCB+c2l6ZSB+aGFzaFxuOztcblxubGV0IG9wYXF1ZSBfIH5zaXplOl8gfmhhc2ggPSBoYXNoXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgKydhIHRcblxuICB2YWwgY3JlYXRlIDogKHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBnZW5lcmF0ZSA6ICdhIHQgLT4gc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAoc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gJ2EpIFN0YWdlZC50XG5cbiAgbGV0IGNyZWF0ZSBmIDogXyB0ID0gU3RhZ2VkLnN0YWdlIGZcblxuICBsZXQgZ2VuZXJhdGUgKHQgOiBfIHQpIH5zaXplIH5yYW5kb20gPVxuICAgIGlmIHNpemUgPCAwXG4gICAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3IuZ2VuZXJhdGU6IHNpemUgPCAwXCIgKHNpemUgOiBpbnQpXVxuICAgIGVsc2UgU3RhZ2VkLnVuc3RhZ2UgdCB+c2l6ZSB+cmFuZG9tXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBzaXplID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbTpfIC0+IHNpemUpXG5cbmxldCBmbiBkb20gcm5nID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5zcGxpdCByYW5kb20gaW5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IGhhc2ggPSBPYnNlcnZlcjAub2JzZXJ2ZSBkb20geCB+c2l6ZSB+aGFzaDooSGFzaC5hbGxvYyAoKSkgaW5cbiAgICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5jb3B5IHJhbmRvbSBpblxuICAgICAgU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUucGVydHVyYiByYW5kb20gKEhhc2guZ2V0X2hhc2hfdmFsdWUgaGFzaCk7XG4gICAgICBnZW5lcmF0ZSBybmcgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCB3aXRoX3NpemUgdCB+c2l6ZSA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pXG5cbmxldCBwZXJ0dXJiIHQgc2FsdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5wZXJ0dXJiIHJhbmRvbSBzYWx0O1xuICAgIGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgfnNpemUgfnJhbmRvbSA9XG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20gaW5cbiAgICBtYXRjaCBmIHggd2l0aFxuICAgIHwgU29tZSB5IC0+IHlcbiAgICB8IE5vbmUgLT4gbG9vcCB+c2l6ZTooc2l6ZSArIDEpIH5yYW5kb21cbiAgaW5cbiAgY3JlYXRlIGxvb3Bcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbmxldCByZXR1cm4geCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbTpfIC0+IHgpXG5sZXQgbWFwIHQgfmYgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IGYgKGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSkpXG5cbmxldCBhcHBseSB0ZiB0eCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgZiA9IGdlbmVyYXRlIHRmIH5zaXplIH5yYW5kb20gaW5cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHR4IH5zaXplIH5yYW5kb20gaW5cbiAgICBmIHgpXG47O1xuXG5sZXQgYmluZCB0IH5mID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgZ2VuZXJhdGUgKGYgeCkgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCBhbGwgbGlzdCA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gTGlzdC5tYXAgbGlzdCB+ZjooZ2VuZXJhdGUgfnNpemUgfnJhbmRvbSkpXG5cbmxldCBhbGxfdW5pdCBsaXN0ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBMaXN0Lml0ZXIgbGlzdCB+ZjooZ2VuZXJhdGUgfnNpemUgfnJhbmRvbSkpXG47O1xuXG5tb2R1bGUgRm9yX2FwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgYXBwbHkgPSBhcHBseVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbmxldCBib3RoID0gRm9yX2FwcGxpY2F0aXZlLmJvdGhcbmxldCBtYXAyID0gRm9yX2FwcGxpY2F0aXZlLm1hcDJcbmxldCBtYXAzID0gRm9yX2FwcGxpY2F0aXZlLm1hcDNcblxubW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gRm9yX2FwcGxpY2F0aXZlLkFwcGxpY2F0aXZlX2luZml4XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2luZml4XG5cbm1vZHVsZSBGb3JfbW9uYWQgPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbmxldCBpZ25vcmVfbSA9IEZvcl9tb25hZC5pZ25vcmVfbVxubGV0IGpvaW4gPSBGb3JfbW9uYWQuam9pblxuXG5tb2R1bGUgTW9uYWRfaW5maXggPSBGb3JfbW9uYWQuTW9uYWRfaW5maXhcbmluY2x1ZGUgTW9uYWRfaW5maXhcbm1vZHVsZSBMZXRfc3ludGF4ID0gRm9yX21vbmFkLkxldF9zeW50YXhcbm9wZW4gTGV0X3N5bnRheFxuXG5sZXQgb2ZfbGlzdCBsaXN0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSBsaXN0XG4gIHRoZW4gRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX2xpc3Q6IGVtcHR5IGxpc3RcIl07XG4gIGxldCBhcnJheSA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICBsZXQgbG8gPSAwIGluXG4gIGxldCBoaSA9IEFycmF5Lmxlbmd0aCBhcnJheSAtIDEgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGluZGV4ID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG8gfmhpIGluXG4gICAgYXJyYXkuKGluZGV4KSlcbjs7XG5cbmxldCB1bmlvbiBsaXN0ID0gam9pbiAob2ZfbGlzdCBsaXN0KVxuXG5sZXQgb2Zfd2VpZ2h0ZWRfbGlzdCBhbGlzdCA9XG4gIGlmIExpc3QuaXNfZW1wdHkgYWxpc3RcbiAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogZW1wdHkgbGlzdFwiXTtcbiAgbGV0IHdlaWdodHMsIHZhbHVlcyA9IExpc3QudW56aXAgYWxpc3QgaW5cbiAgbGV0IHZhbHVlX2FycmF5ID0gQXJyYXkub2ZfbGlzdCB2YWx1ZXMgaW5cbiAgbGV0IHRvdGFsX3dlaWdodCwgY3VtdWxhdGl2ZV93ZWlnaHRfYXJyYXkgPVxuICAgIGxldCBhcnJheSA9IEFycmF5LmluaXQgKEFycmF5Lmxlbmd0aCB2YWx1ZV9hcnJheSkgfmY6KGZ1biBfIC0+IDAuKSBpblxuICAgIGxldCBzdW0gPVxuICAgICAgTGlzdC5mb2xkaSB3ZWlnaHRzIH5pbml0OjAuIH5mOihmdW4gaW5kZXggYWNjIHdlaWdodCAtPlxuICAgICAgICBpZiBub3QgKEZsb2F0LmlzX2Zpbml0ZSB3ZWlnaHQpXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IHdlaWdodCBpcyBub3QgZmluaXRlXCJcbiAgICAgICAgICAgICAgICAod2VpZ2h0IDogZmxvYXQpXTtcbiAgICAgICAgaWYgRmxvYXQuKCA8ICkgd2VpZ2h0IDAuXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IHdlaWdodCBpcyBuZWdhdGl2ZVwiXG4gICAgICAgICAgICAgICAgKHdlaWdodCA6IGZsb2F0KV07XG4gICAgICAgIGxldCBjdW11bGF0aXZlID0gYWNjICsuIHdlaWdodCBpblxuICAgICAgICBhcnJheS4oaW5kZXgpIDwtIGN1bXVsYXRpdmU7XG4gICAgICAgIGN1bXVsYXRpdmUpXG4gICAgaW5cbiAgICBpZiBGbG9hdC4oIDw9ICkgc3VtIDAuXG4gICAgdGhlblxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IHRvdGFsIHdlaWdodCBpcyB6ZXJvXCJdO1xuICAgIHN1bSwgYXJyYXlcbiAgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGNob2ljZSA9IFNwbGl0dGFibGVfcmFuZG9tLmZsb2F0IHJhbmRvbSB+bG86MC4gfmhpOnRvdGFsX3dlaWdodCBpblxuICAgIG1hdGNoXG4gICAgICBBcnJheS5iaW5hcnlfc2VhcmNoXG4gICAgICAgIGN1bXVsYXRpdmVfd2VpZ2h0X2FycmF5XG4gICAgICAgIH5jb21wYXJlOkZsb2F0LmNvbXBhcmVcbiAgICAgICAgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgICAgICBjaG9pY2VcbiAgICB3aXRoXG4gICAgfCBTb21lIGluZGV4IC0+IHZhbHVlX2FycmF5LihpbmRleClcbiAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IHdlaWdodGVkX3VuaW9uIGFsaXN0ID0gam9pbiAob2Zfd2VpZ2h0ZWRfbGlzdCBhbGlzdClcbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gZ2VuZXJhdGUgKGZvcmNlIGxhenlfdCkgfnNpemUgfnJhbmRvbSlcblxubGV0IGZpeGVkX3BvaW50IG9mX2dlbmVyYXRvciA9XG4gIGxldCByZWMgbGF6eV90ID0gbGF6eSAob2ZfZ2VuZXJhdG9yIChvZl9sYXp5IGxhenlfdCkpIGluXG4gIGZvcmNlIGxhenlfdFxuOztcblxubGV0IHdlaWdodGVkX3JlY3Vyc2l2ZV91bmlvbiBub25yZWNfbGlzdCB+ZiA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCByZWNfbGlzdCA9XG4gICAgICBMaXN0Lm1hcCAoZiBzZWxmKSB+ZjooZnVuICh3LCB0KSAtPlxuICAgICAgICAoIHdcbiAgICAgICAgLCBsZXQlYmluZCBuID0gc2l6ZSBpblxuICAgICAgICAgIHdpdGhfc2l6ZSB+c2l6ZToobiAtIDEpIHQgKSlcbiAgICBpblxuICAgIGlmIExpc3QuaXNfZW1wdHkgbm9ucmVjX2xpc3QgfHwgTGlzdC5pc19lbXB0eSByZWNfbGlzdFxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLndlaWdodGVkX3JlY3Vyc2l2ZV91bmlvbjogbGlzdHMgbXVzdCBiZSBub24tZW1wdHlcIl07XG4gICAgbGV0IG5vbnJlY19nZW4gPSB3ZWlnaHRlZF91bmlvbiBub25yZWNfbGlzdCBpblxuICAgIGxldCByZWNfZ2VuID0gd2VpZ2h0ZWRfdW5pb24gKG5vbnJlY19saXN0IEAgcmVjX2xpc3QpIGluXG4gICAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgICB8IDAgLT4gbm9ucmVjX2dlblxuICAgIHwgXyAtPiByZWNfZ2VuKVxuOztcblxubGV0IHJlY3Vyc2l2ZV91bmlvbiBub25yZWNfbGlzdCB+ZiA9XG4gIGxldCB3ZWlnaHRlZCBsaXN0ID0gTGlzdC5tYXAgbGlzdCB+ZjooZnVuIHQgLT4gMS4sIHQpIGluXG4gIHdlaWdodGVkX3JlY3Vyc2l2ZV91bmlvbiAod2VpZ2h0ZWQgbm9ucmVjX2xpc3QpIH5mOihmdW4gc2VsZiAtPiB3ZWlnaHRlZCAoZiBzZWxmKSlcbjs7XG5cbmxldCBzaXplcyA/KG1pbl9sZW5ndGggPSAwKSA/KG1heF9sZW5ndGggPSBJbnQubWF4X3ZhbHVlKSAoKSA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBhc3NlcnQgKG1pbl9sZW5ndGggPD0gbWF4X2xlbmd0aCk7XG4gICAgbGV0IHVwcGVyX2JvdW5kID0gbWluX2xlbmd0aCArIHNpemUgaW5cbiAgICBsZXQgbWF4X2xlbmd0aCA9XG4gICAgICBpZiB1cHBlcl9ib3VuZCA+PSBtaW5fbGVuZ3RoICgqIGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cgKilcbiAgICAgIHRoZW4gbWluIG1heF9sZW5ndGggdXBwZXJfYm91bmRcbiAgICAgIGVsc2UgbWF4X2xlbmd0aFxuICAgIGluXG4gICAgKCogcGljayBhIGxlbmd0aCwgd2VpZ2h0ZWQgbG93IHNvIHRoYXQgbW9zdCBvZiB0aGUgc2l6ZSBpcyBzcGVudCBvbiBlbGVtZW50cyAqKVxuICAgIGxldCBsZW4gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzptaW5fbGVuZ3RoIH5oaTptYXhfbGVuZ3RoIGluXG4gICAgKCogaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHJldHVybiBhbiBlbXB0eSBhcnJheSwgb3RoZXJ3aXNlIHJldHVybiBhIG5vbi1lbXB0eSBhcnJheVxuICAgICAgIHdpdGggdGhlIHNpemUgZGlzdHJpYnV0ZWQgYW1vbmcgdGhlIGVsZW1lbnRzICopXG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgIGxldCBzaXplcyA9IEFycmF5LmluaXQgbGVuIH5mOihmdW4gXyAtPiAwKSBpblxuICAgICAgbGV0IHJlbWFpbmluZyA9IHNpemUgLSAobGVuIC0gbWluX2xlbmd0aCkgaW5cbiAgICAgIGxldCBtYXhfaW5kZXggPSBsZW4gLSAxIGluXG4gICAgICBmb3IgXyA9IDEgdG8gcmVtYWluaW5nIGRvXG4gICAgICAgICgqIHBpY2sgYW4gaW5kZXgsIHdlaWdodGVkIGxvdyBzbyB0aGF0IHdlIHNlZSB1bmJhbGFuY2VkIGRpc3RyaWJ1dGlvbnMgb2Z0ZW4gKilcbiAgICAgICAgbGV0IGluZGV4ID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86MCB+aGk6bWF4X2luZGV4IGluXG4gICAgICAgIHNpemVzLihpbmRleCkgPC0gc2l6ZXMuKGluZGV4KSArIDFcbiAgICAgIGRvbmU7XG4gICAgICAoKiBwZXJtdXRlIHRoZSBhcnJheSBzbyB0aGF0IG5vIGluZGV4IGlzIGZhdm9yZWQgb3ZlciBhbm90aGVyICopXG4gICAgICBmb3IgaSA9IDAgdG8gbWF4X2luZGV4IC0gMSBkb1xuICAgICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOmkgfmhpOm1heF9pbmRleCBpblxuICAgICAgICBBcnJheS5zd2FwIHNpemVzIGkgalxuICAgICAgZG9uZTtcbiAgICAgIGFzc2VydCAoQXJyYXkuc3VtIChtb2R1bGUgSW50KSBzaXplcyB+ZjpGbi5pZCArIChsZW4gLSBtaW5fbGVuZ3RoKSA9IHNpemUpO1xuICAgICAgQXJyYXkudG9fbGlzdCBzaXplcykpXG47O1xuXG5sZXQgdW5pdCA9IHJldHVybiAoKVxubGV0IGJvb2wgPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gU3BsaXR0YWJsZV9yYW5kb20uYm9vbCByYW5kb20pXG5sZXQgb3B0aW9uIHZhbHVlX3QgPSB1bmlvbiBbIHJldHVybiBOb25lOyBtYXAgdmFsdWVfdCB+ZjpPcHRpb24ucmV0dXJuIF1cbmxldCBlaXRoZXIgZnN0X3Qgc25kX3QgPSB1bmlvbiBbIG1hcCBmc3RfdCB+ZjpFaXRoZXIuZmlyc3Q7IG1hcCBzbmRfdCB+ZjpFaXRoZXIuc2Vjb25kIF1cblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgbWFwIChlaXRoZXIgb2tfdCBlcnJfdCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBGaXJzdCBvayAtPiBPayBva1xuICAgIHwgU2Vjb25kIGVyciAtPiBFcnJvciBlcnIpXG47O1xuXG5sZXQgbGlzdF9nZW5lcmljID9taW5fbGVuZ3RoID9tYXhfbGVuZ3RoIGVsdF9nZW4gPVxuICBsZXQlYmluZCBzaXplcyA9IHNpemVzID9taW5fbGVuZ3RoID9tYXhfbGVuZ3RoICgpIGluXG4gIExpc3QubWFwIHNpemVzIH5mOihmdW4gc2l6ZSAtPiB3aXRoX3NpemUgfnNpemUgZWx0X2dlbikgfD4gYWxsXG47O1xuXG5sZXQgbGlzdCBlbHRfZ2VuID0gbGlzdF9nZW5lcmljIGVsdF9nZW5cbmxldCBsaXN0X25vbl9lbXB0eSBlbHRfZ2VuID0gbGlzdF9nZW5lcmljIH5taW5fbGVuZ3RoOjEgZWx0X2dlblxuXG5sZXQgbGlzdF93aXRoX2xlbmd0aCBlbHRfZ2VuIH5sZW5ndGggPVxuICBsaXN0X2dlbmVyaWMgfm1pbl9sZW5ndGg6bGVuZ3RoIH5tYXhfbGVuZ3RoOmxlbmd0aCBlbHRfZ2VuXG47O1xuXG5sZXQgbGlzdF9maWx0ZXJlZCBlbHRzID1cbiAgbGV0IGVsdHMgPSBBcnJheS5vZl9saXN0IGVsdHMgaW5cbiAgbGV0IGxlbmd0aF9vZl9pbnB1dCA9IEFycmF5Lmxlbmd0aCBlbHRzIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBsZW5ndGhfb2Zfb3V0cHV0ID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86MCB+aGk6bGVuZ3RoX29mX2lucHV0IGluXG4gICAgbGV0IGluZGljZXMgPSBBcnJheS5pbml0IGxlbmd0aF9vZl9pbnB1dCB+ZjpGbi5pZCBpblxuICAgICgqIENob29zZSBbbGVuZ3RoX29mX291dHB1dF0gcmFuZG9tIHZhbHVlcyBpbiB0aGUgcHJlZml4IG9mIFtpbmRpY2VzXS4gKilcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoX29mX291dHB1dCAtIDEgZG9cbiAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86aSB+aGk6KGxlbmd0aF9vZl9pbnB1dCAtIDEpIGluXG4gICAgICBBcnJheS5zd2FwIGluZGljZXMgaSBqXG4gICAgZG9uZTtcbiAgICAoKiBTb3J0IHRoZSBjaG9zZW4gaW5kaWNlcyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gcmVvcmRlciB0aGVtLiAqKVxuICAgIEFycmF5LnNvcnQgaW5kaWNlcyB+cG9zOjAgfmxlbjpsZW5ndGhfb2Zfb3V0cHV0IH5jb21wYXJlOkludC5jb21wYXJlO1xuICAgICgqIFJldHVybiB0aGUgY2hvc2VuIGVsZW1lbnRzLiAqKVxuICAgIExpc3QuaW5pdCBsZW5ndGhfb2Zfb3V0cHV0IH5mOihmdW4gaSAtPiBlbHRzLihpbmRpY2VzLihpKSkpKVxuOztcblxubGV0IGxpc3RfcGVybXV0YXRpb25zIGxpc3QgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIGFycmF5IC0gMSBkb1xuICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzowIH5oaTppIGluXG4gICAgICBBcnJheS5zd2FwIGFycmF5IGkgalxuICAgIGRvbmU7XG4gICAgQXJyYXkudG9fbGlzdCBhcnJheSlcbjs7XG5cbmxldCBhcnJheSB0ID0gbWFwIChsaXN0IHQpIH5mOkFycmF5Lm9mX2xpc3RcbmxldCByZWYgdCA9IG1hcCB0IH5mOlJlZi5jcmVhdGVcbmxldCBsYXp5X3QgdCA9IG1hcCB0IH5mOkxhenkuZnJvbV92YWxcblxubGV0IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzooQ2hhci50b19pbnQgbG8pIH5oaTooQ2hhci50b19pbnQgaGkpXG4gICAgfD4gQ2hhci51bnNhZmVfb2ZfaW50KVxuOztcblxubGV0IGNoYXJfdXBwZXJjYXNlID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnQScgJ1onXG5sZXQgY2hhcl9sb3dlcmNhc2UgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICdhJyAneidcbmxldCBjaGFyX2RpZ2l0ID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnMCcgJzknXG5sZXQgY2hhcl9wcmludF91bmlmb3JtID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnICcgJ34nXG5sZXQgY2hhcl91bmlmb3JtID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSBDaGFyLm1pbl92YWx1ZSBDaGFyLm1heF92YWx1ZVxubGV0IGNoYXJfYWxwaGEgPSB1bmlvbiBbIGNoYXJfbG93ZXJjYXNlOyBjaGFyX3VwcGVyY2FzZSBdXG5cbmxldCBjaGFyX2FscGhhbnVtID1cbiAgd2VpZ2h0ZWRfdW5pb25cbiAgICAoKiBNb3N0IHBlb3BsZSBwcm9iYWJseSBleHBlY3QgdGhpcyB0byBiZSBhIHVuaWZvcm0gZGlzdHJpYnV0aW9uLCBub3Qgd2VpZ2h0ZWRcbiAgICAgICB0b3dhcmQgZGlnaXRzIGxpa2Ugd2Ugd291bGQgZ2V0IHdpdGggW3VuaW9uXSAoc2luY2UgdGhlcmUgYXJlIGZld2VyIGRpZ2l0cyB0aGFuXG4gICAgICAgbGV0dGVycykuICopXG4gICAgWyA1Mi4sIGNoYXJfYWxwaGE7IDEwLiwgY2hhcl9kaWdpdCBdXG47O1xuXG5sZXQgY2hhcl93aGl0ZXNwYWNlID0gb2ZfbGlzdCAoTGlzdC5maWx0ZXIgQ2hhci5hbGwgfmY6Q2hhci5pc193aGl0ZXNwYWNlKVxubGV0IGNoYXJfcHJpbnQgPSB3ZWlnaHRlZF91bmlvbiBbIDEwLiwgY2hhcl9hbHBoYW51bTsgMS4sIGNoYXJfcHJpbnRfdW5pZm9ybSBdXG5cbmxldCBjaGFyID1cbiAgd2VpZ2h0ZWRfdW5pb25cbiAgICBbIDEwMC4sIGNoYXJfcHJpbnRcbiAgICA7IDEwLiwgY2hhcl91bmlmb3JtXG4gICAgOyAxLiwgcmV0dXJuIENoYXIubWluX3ZhbHVlXG4gICAgOyAxLiwgcmV0dXJuIENoYXIubWF4X3ZhbHVlXG4gICAgXVxuOztcblxuKCogUHJvZHVjZXMgYSBudW1iZXIgZnJvbSAwIG9yIDEgdG8gc2l6ZSArIDEsIHdlaWdodGVkIGhpZ2guIFdlIGhhdmUgZm91bmQgdGhpc1xuICAgZGlzdHJpYnV0aW9uIGVtcGlyaWNhbGx5IHVzZWZ1bCBmb3Igc3RyaW5nIGxlbmd0aHMuICopXG5sZXQgc21hbGxfaW50IH5hbGxvd196ZXJvID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCBsb3dlcl9ib3VuZCA9IGlmIGFsbG93X3plcm8gdGhlbiAwIGVsc2UgMSBpblxuICAgIGxldCB1cHBlcl9ib3VuZCA9IHNpemUgKyAxIGluXG4gICAgbGV0IHdlaWdodGVkX2xvdyA9XG4gICAgICBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzowIH5oaToodXBwZXJfYm91bmQgLSBsb3dlcl9ib3VuZClcbiAgICBpblxuICAgIGxldCB3ZWlnaHRlZF9oaWdoID0gdXBwZXJfYm91bmQgLSB3ZWlnaHRlZF9sb3cgaW5cbiAgICB3ZWlnaHRlZF9oaWdoKVxuOztcblxubGV0IHNtYWxsX3Bvc2l0aXZlX29yX3plcm9faW50ID0gc21hbGxfaW50IH5hbGxvd196ZXJvOnRydWVcbmxldCBzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQgPSBzbWFsbF9pbnQgfmFsbG93X3plcm86ZmFsc2VcblxubW9kdWxlIHR5cGUgSW50X3dpdGhfcmFuZG9tID0gc2lnXG4gIGluY2x1ZGUgSW50LlNcblxuICB2YWwgdW5pZm9ybSA6IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gbG86dCAtPiBoaTp0IC0+IHRcbiAgdmFsIGxvZ191bmlmb3JtIDogU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiBsbzp0IC0+IGhpOnQgLT4gdFxuZW5kXG5cbm1vZHVsZSBGb3JfaW50ZWdlciAoSW50ZWdlciA6IEludF93aXRoX3JhbmRvbSkgPSBzdHJ1Y3RcbiAgbGV0IHVuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gSW50ZWdlci51bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBsb2dfdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLmxvZ191bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBub25fdW5pZm9ybSBmIGxvIGhpID1cbiAgICB3ZWlnaHRlZF91bmlvbiBbIDAuMDUsIHJldHVybiBsbzsgMC4wNSwgcmV0dXJuIGhpOyAwLjksIGYgbG8gaGkgXVxuICA7O1xuXG4gIGxldCBpbmNsdXNpdmUgPSBub25fdW5pZm9ybSB1bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgbG9nX2luY2x1c2l2ZSA9IG5vbl91bmlmb3JtIGxvZ191bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgdW5pZm9ybV9hbGwgPSB1bmlmb3JtX2luY2x1c2l2ZSBJbnRlZ2VyLm1pbl92YWx1ZSBJbnRlZ2VyLm1heF92YWx1ZVxuXG4gIGxldCBhbGwgPVxuICAgIFslbWFwXG4gICAgICBsZXQgbmVnYXRpdmUgPSBib29sXG4gICAgICBhbmQgbWFnbml0dWRlID0gbG9nX2luY2x1c2l2ZSBJbnRlZ2VyLnplcm8gSW50ZWdlci5tYXhfdmFsdWUgaW5cbiAgICAgIGlmIG5lZ2F0aXZlIHRoZW4gSW50ZWdlci5iaXRfbm90IG1hZ25pdHVkZSBlbHNlIG1hZ25pdHVkZV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX2ludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnRcbiAgZW5kKVxuXG5sZXQgaW50ID0gRm9yX2ludC5hbGxcbmxldCBpbnRfdW5pZm9ybSA9IEZvcl9pbnQudW5pZm9ybV9hbGxcbmxldCBpbnRfaW5jbHVzaXZlID0gRm9yX2ludC5pbmNsdXNpdmVcbmxldCBpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmVcbmxldCBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcblxubW9kdWxlIEZvcl9pbnQzMiA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludDMyXG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDMyXG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50MzJcbiAgZW5kKVxuXG5sZXQgaW50MzIgPSBGb3JfaW50MzIuYWxsXG5sZXQgaW50MzJfdW5pZm9ybSA9IEZvcl9pbnQzMi51bmlmb3JtX2FsbFxubGV0IGludDMyX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5pbmNsdXNpdmVcbmxldCBpbnQzMl91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50MzIubG9nX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcblxubW9kdWxlIEZvcl9pbnQ2MyA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludDYzXG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDYzXG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50NjNcbiAgZW5kKVxuXG5sZXQgaW50NjMgPSBGb3JfaW50NjMuYWxsXG5sZXQgaW50NjNfdW5pZm9ybSA9IEZvcl9pbnQ2My51bmlmb3JtX2FsbFxubGV0IGludDYzX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5pbmNsdXNpdmVcbmxldCBpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDYzX2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50NjMubG9nX2luY2x1c2l2ZVxubGV0IGludDYzX2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcblxubW9kdWxlIEZvcl9pbnQ2NCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludDY0XG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDY0XG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50NjRcbiAgZW5kKVxuXG5sZXQgaW50NjQgPSBGb3JfaW50NjQuYWxsXG5sZXQgaW50NjRfdW5pZm9ybSA9IEZvcl9pbnQ2NC51bmlmb3JtX2FsbFxubGV0IGludDY0X2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5pbmNsdXNpdmVcbmxldCBpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDY0X2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50NjQubG9nX2luY2x1c2l2ZVxubGV0IGludDY0X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcblxubW9kdWxlIEZvcl9uYXRpdmVpbnQgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBOYXRpdmVpbnRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20ubmF0aXZlaW50XG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0ubmF0aXZlaW50XG4gIGVuZClcblxubGV0IG5hdGl2ZWludCA9IEZvcl9uYXRpdmVpbnQuYWxsXG5sZXQgbmF0aXZlaW50X3VuaWZvcm0gPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1fYWxsXG5sZXQgbmF0aXZlaW50X2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQuaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IG5hdGl2ZWludF9sb2dfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgZmxvYXRfemVyb19leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMC5cbmxldCBmbG9hdF96ZXJvX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSAwLlxuXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9XG4gIEZsb2F0Lm9uZV91bHAgYERvd24gRmxvYXQubWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxuOztcblxubGV0IGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0Lm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZSA9IEZsb2F0Lm1heF9maW5pdGVfdmFsdWVcbmxldCBmbG9hdF9taW5fbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9pbmZfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfaW5mX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBGbG9hdC5pbmZpbml0eVxubGV0IGZsb2F0X25hbl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubmFuXG5sZXQgZmxvYXRfbWluX25hbl9tYW50aXNzYSA9IEludDYzLnN1Y2MgZmxvYXRfaW5mX21hbnRpc3NhXG5sZXQgZmxvYXRfbWF4X25hbl9tYW50aXNzYSA9IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2FcbmxldCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyA9IDUyXG5cbigqIFdlIHdlaWdodCBtYW50aXNzYXMgc28gdGhhdCBcImludGVnZXItbGlrZVwiIHZhbHVlcywgYW5kIHZhbHVlcyB3aXRoIG9ubHkgYSBmZXcgZGlnaXRzXG4gICBwYXN0IHRoZSBkZWNpbWFsLCBhcmUgcmVhc29uYWJseSBjb21tb24uICopXG5sZXQgZmxvYXRfbm9ybWFsX21hbnRpc3NhID1cbiAgbGV0JWJpbmQgbnVtX2JpdHMgPSBGb3JfaW50LnVuaWZvcm1faW5jbHVzaXZlIDAgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgaW5cbiAgbGV0JW1hcCBiaXRzID1cbiAgICBGb3JfaW50NjMuaW5jbHVzaXZlIEludDYzLnplcm8gKEludDYzLnByZWQgKEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG51bV9iaXRzKSlcbiAgaW5cbiAgSW50NjMuc2hpZnRfbGVmdCBiaXRzIChJbnQuKCAtICkgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgbnVtX2JpdHMpXG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCArICkgbG93ZXJfYm91bmQgb2Zmc2V0XG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfaGlnaCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGxldCVtYXAgb2Zmc2V0ID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlIDAgKEludC4oIC0gKSB1cHBlcl9ib3VuZCBsb3dlcl9ib3VuZCkgaW5cbiAgSW50LiggLSApIHVwcGVyX2JvdW5kIG9mZnNldFxuOztcblxuKCogV2Ugd2VpZ2h0IGV4cG9uZW50cyBzdWNoIHRoYXQgdmFsdWVzIG5lYXIgMSBhcmUgbW9yZSBsaWtlbHkuICopXG5sZXQgZmxvYXRfZXhwb25lbnQgPVxuICBsZXQgbWlkcG9pbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IDEuIGluXG4gIHVuaW9uXG4gICAgWyBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgbWlkcG9pbnRcbiAgICA7IGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2xvdyBtaWRwb2ludCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50XG4gICAgXVxuOztcblxubGV0IGZsb2F0X3plcm8gPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfemVyb19leHBvbmVudFxuICAgIH5tYW50aXNzYTpmbG9hdF96ZXJvX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPVxuICAgIEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlIGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgZmxvYXRfbWF4X3N1Ym5vcm1hbF9tYW50aXNzYVxuICBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9ub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSBmbG9hdF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBmbG9hdF9ub3JtYWxfbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfaW5maW5pdGUgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfaW5mX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X2luZl9tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25hbiA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IHJldHVybiBmbG9hdF9uYW5fZXhwb25lbnRcbiAgYW5kIG1hbnRpc3NhID0gRm9yX2ludDYzLmluY2x1c2l2ZSBmbG9hdF9taW5fbmFuX21hbnRpc3NhIGZsb2F0X21heF9uYW5fbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gZmxvYXRfemVyb1xuICB8IFN1Ym5vcm1hbCAtPiBmbG9hdF9zdWJub3JtYWxcbiAgfCBOb3JtYWwgLT4gZmxvYXRfbm9ybWFsXG4gIHwgSW5maW5pdGUgLT4gZmxvYXRfaW5maW5pdGVcbiAgfCBOYW4gLT4gZmxvYXRfbmFuXG47O1xuXG5sZXQgZmxvYXRfd2VpZ2h0X29mX2NsYXNzIGMgPVxuICBtYXRjaCAoYyA6IEZsb2F0LkNsYXNzLnQpIHdpdGhcbiAgfCBaZXJvIC0+IDEuXG4gIHwgU3Vibm9ybWFsIC0+IDEwLlxuICB8IE5vcm1hbCAtPiAxMDAuXG4gIHwgSW5maW5pdGUgLT4gMS5cbiAgfCBOYW4gLT4gMS5cbjs7XG5cbmxldCBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIGZpbHRlciA9XG4gIExpc3QuZmlsdGVyX21hcCBGbG9hdC5DbGFzcy5hbGwgfmY6KGZ1biBjIC0+XG4gICAgaWYgZmlsdGVyIGMgdGhlbiBTb21lIChmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYywgZmxvYXRfb2ZfY2xhc3MgYykgZWxzZSBOb25lKVxuICB8PiB3ZWlnaHRlZF91bmlvblxuOztcblxubGV0IGZsb2F0X2Zpbml0ZSA9XG4gIGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1bmN0aW9uXG4gICAgfCBaZXJvIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IEluZmluaXRlIHwgTmFuIC0+IGZhbHNlKVxuOztcblxubGV0IGZsb2F0X3dpdGhvdXRfbmFuID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgfCBJbmZpbml0ZSAtPiB0cnVlXG4gICAgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXQgPSBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW4gXyAtPiB0cnVlKVxuXG5sZXQgZmxvYXRfZmluaXRlX25vbl96ZXJvID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFN1Ym5vcm1hbCB8IE5vcm1hbCAtPiB0cnVlXG4gICAgfCBaZXJvIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUgPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGVfbm9uX3plcm8gaW5cbiAgRmxvYXQuYWJzIHRcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfcG9zaXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X25lZ2F0aXZlX29yX3plcm8gPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGUgaW5cbiAgfi0uKEZsb2F0LmFicyB0KVxuOztcblxubGV0IGZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0IG9wZW4gRmxvYXQuTyBpblxuICBpZiAobm90IChGbG9hdC5pc19maW5pdGUgbG93ZXJfYm91bmQpKSB8fCBub3QgKEZsb2F0LmlzX2Zpbml0ZSB1cHBlcl9ib3VuZClcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiBib3VuZHMgYXJlIG5vdCBmaW5pdGVcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGxldCBsb3dlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCBpblxuICBsZXQgdXBwZXJfaW5jbHVzaXZlID0gRmxvYXQub25lX3VscCBgRG93biB1cHBlcl9ib3VuZCBpblxuICBpZiBsb3dlcl9pbmNsdXNpdmUgPiB1cHBlcl9pbmNsdXNpdmVcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiByZXF1ZXN0ZWQgcmFuZ2UgaXMgZW1wdHlcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmZsb2F0IHJhbmRvbSB+bG86bG93ZXJfaW5jbHVzaXZlIH5oaTp1cHBlcl9pbmNsdXNpdmUpXG47O1xuXG5sZXQgZmxvYXRfaW5jbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgaWYgRmxvYXQuZXF1YWwgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgdGhlbiByZXR1cm4gbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBGbG9hdC4oID0gKSAoRmxvYXQub25lX3VscCBgVXAgbG93ZXJfYm91bmQpIHVwcGVyX2JvdW5kXG4gIHRoZW4gdW5pb24gWyByZXR1cm4gbG93ZXJfYm91bmQ7IHJldHVybiB1cHBlcl9ib3VuZCBdXG4gIGVsc2VcbiAgICB3ZWlnaHRlZF91bmlvblxuICAgICAgWyAwLjA1LCByZXR1cm4gbG93ZXJfYm91bmRcbiAgICAgIDsgMC4wNSwgcmV0dXJuIHVwcGVyX2JvdW5kXG4gICAgICA7IDAuOSwgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgICAgIF1cbjs7XG5cbmxldCBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aCA9XG4gIGxpc3Rfd2l0aF9sZW5ndGggY2hhcl9nZW4gfmxlbmd0aCB8PiBtYXAgfmY6U3RyaW5nLm9mX2NoYXJfbGlzdFxuOztcblxubGV0IHN0cmluZ19vZiBjaGFyX2dlbiA9XG4gIGJpbmQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmcgPSBzdHJpbmdfb2YgY2hhclxubGV0IHN0cmluZ19ub25fZW1wdHkgPSBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJcbmxldCBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aCA9IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyIH5sZW5ndGhcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nXG5cbmxldCBzZXhwX29mIGF0b20gPVxuICBmaXhlZF9wb2ludCAoZnVuIHNlbGYgLT5cbiAgICBsZXQlYmluZCBzaXplID0gc2l6ZSBpblxuICAgICgqIGNob29zZSBhIG51bWJlciB3ZWlnaHRlZCBsb3cgc28gd2UgaGF2ZSBhIGRlY3JlYXNpbmcsIGJ1dCBub3QgdmFuaXNoaW5nLCBjaGFuY2VcbiAgICAgICB0byBnZW5lcmF0ZSBhdG9tcyBhcyBzaXplIGdyb3dzICopXG4gICAgbWF0Y2glYmluZCBGb3JfaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZSAwIChzaXplICsgMSkgd2l0aFxuICAgICgqIGdlbmVyYXRlIGFuIGF0b20gdXNpbmcgdGhlIGdpdmVuIHNpemUgKilcbiAgICB8IDAgLT5cbiAgICAgIGxldCVtYXAgYXRvbSA9IGF0b20gaW5cbiAgICAgIFNleHAuQXRvbSBhdG9tXG4gICAgKCogcmVseWluZyBvbiBbTGlzdC5nZW5dIHRvIGRpc3RyaWJ1dGUgW3NpemVdIG92ZXIgc3ViLXNleHBzICopXG4gICAgfCBfIC0+XG4gICAgICBsZXQlbWFwIGxpc3QgPSBsaXN0IHNlbGYgaW5cbiAgICAgIFNleHAuTGlzdCBsaXN0KVxuOztcblxubGV0IHNleHAgPSBzZXhwX29mIHN0cmluZ1xuXG5sZXQgbWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0JWJpbmQga2V5cyA9IGxpc3Qga2V5X2dlbiBpblxuICBsZXQga2V5cyA9IExpc3QuZGVkdXBfYW5kX3NvcnQga2V5cyB+Y29tcGFyZTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICBsZXQlYmluZCBkYXRhID0gbGlzdF93aXRoX2xlbmd0aCBkYXRhX2dlbiB+bGVuZ3RoOihMaXN0Lmxlbmd0aCBrZXlzKSBpblxuICByZXR1cm4gKE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIChMaXN0LnppcF9leG4ga2V5cyBkYXRhKSlcbjs7XG5cbmxldCBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW4gPVxuICBtYXAgKGxpc3QgZWx0X2dlbikgfmY6KFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUub2ZfbGlzdCB+Y29tcGFyYXRvcilcbjs7XG5cbmxldCBjb21wYXJhdG9yX29mX21cbiAgICAgICh0eXBlIGEgYylcbiAgICAgIChtb2R1bGUgTSA6IENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGEgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gYylcbiAgPVxuICBNLmNvbXBhcmF0b3Jcbjs7XG5cbmxldCBtYXBfdF9tIG0ga2V5X2dlbiBkYXRhX2dlbiA9XG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvcl9vZl9tIG0gaW5cbiAgbWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfZ2VuIGRhdGFfZ2VuXG4gIHw+IG1hcCB+ZjooTWFwLlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbjs7XG5cbmxldCBzZXRfdF9tIG0gZWx0X2dlbiA9XG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvcl9vZl9tIG0gaW5cbiAgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfZ2VuXG4gIHw+IG1hcCB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbjs7XG5cbmxldCBiaWdhcnJheTEgdCBraW5kIGxheW91dCA9XG4gIGxldCVtYXAgZWx0cyA9IGxpc3QgdCBpblxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgZGltID0gQXJyYXkubGVuZ3RoIGVsdHMgaW5cbiAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaW5pdCBraW5kIGxheW91dCBkaW0gfmY6KGZ1biBpIC0+IGVsdHMuKGkgLSBvZmZzZXQpKVxuOztcblxubGV0IGJpZ3N0cmluZyA9IGJpZ2FycmF5MSBjaGFyIENoYXIgQ19sYXlvdXRcbmxldCBmbG9hdDMyX3ZlYyA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDMyIEZvcnRyYW5fbGF5b3V0XG5sZXQgZmxvYXQ2NF92ZWMgPSBiaWdhcnJheTEgZmxvYXQgRmxvYXQ2NCBGb3J0cmFuX2xheW91dFxuXG5sZXQgYmlnYXJyYXkyX2RpbSA9XG4gIG1hdGNoJWJpbmQgc2l6ZSB3aXRoXG4gIHwgMCAtPiByZXR1cm4gKDAsIDApXG4gIHwgbWF4X3RvdGFsX3NpemUgLT5cbiAgICBsZXQlYmluZCBhID1cbiAgICAgICgqIGNob29zZSBhIGRpbWVuc2lvbiB1cCB0byBbbWF4X3RvdGFsX3NpemVdLCB3ZWlnaHRlZCBsb3cgdG8gZ2l2ZSB0aGUgb3RoZXJcbiAgICAgICAgIGRpbWVuc2lvbiBhIGdvb2QgY2hhbmNlIG9mIGJlaW5nIGNvbXBhcmF0aXZlbHkgaGlnaCAqKVxuICAgICAgaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSAxIG1heF90b3RhbF9zaXplXG4gICAgaW5cbiAgICBsZXQlYmluZCBiID1cbiAgICAgICgqIGNob29zZSBhIGRpbWVuc2lvbiB1cCB0byBbbWF4X3RvdGFsX3NpemUgLyBhXSwgd2VpZ2h0ZWQgaGlnaCB0byByZWFjaCBjbG9zZSB0b1xuICAgICAgICAgW21heF90b3RhbF9zaXplXSBtb3N0IG9mIHRoZSB0aW1lICopXG4gICAgICBsZXQgbWF4X2IgPSBtYXhfdG90YWxfc2l6ZSAvIGEgaW5cbiAgICAgIGxldCVtYXAgYl93ZWlnaHRlZF9sb3cgPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgbWF4X2IgaW5cbiAgICAgIG1heF9iIC0gYl93ZWlnaHRlZF9sb3dcbiAgICBpblxuICAgICgqIGF2b2lkIGFueSBza2V3IG9mIGEgdnMgYiBieSByYW5kb21seSBzd2FwcGluZyAqKVxuICAgIGlmJW1hcCBib29sIHRoZW4gYSwgYiBlbHNlIGIsIGFcbjs7XG5cbmxldCBiaWdhcnJheTIgdCBraW5kIGxheW91dCA9XG4gIGxldCViaW5kIGRpbTEsIGRpbTIgPSBiaWdhcnJheTJfZGltIGluXG4gIGxldCVtYXAgZWx0cyA9IGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0xIChsaXN0X3dpdGhfbGVuZ3RoIH5sZW5ndGg6ZGltMiB0KSBpblxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3RfbWFwIH5mOkFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5pbml0IGtpbmQgbGF5b3V0IGRpbTEgZGltMiB+ZjooZnVuIGkgaiAtPlxuICAgIGVsdHMuKGkgLSBvZmZzZXQpLihqIC0gb2Zmc2V0KSlcbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDMyIEZvcnRyYW5fbGF5b3V0XG5sZXQgZmxvYXQ2NF9tYXQgPSBiaWdhcnJheTIgZmxvYXQgRmxvYXQ2NCBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgRGVidWcgPSBzdHJ1Y3RcbiAgbGV0IGNvdmVyYWdlXG4gICAgICAgICh0eXBlIGsgY21wKVxuICAgICAgICAobW9kdWxlIENtcCA6IENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGsgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgICBzYW1wbGVcbiAgICA9XG4gICAgU2VxdWVuY2UuZm9sZFxuICAgICAgc2FtcGxlXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IChtb2R1bGUgQ21wKSlcbiAgICAgIH5mOihmdW4gY291bnRzIHZhbHVlIC0+XG4gICAgICAgIE1hcC51cGRhdGUgY291bnRzIHZhbHVlIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiAxXG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldiArIDEpKVxuICA7O1xuXG4gIGxldCBtb25pdG9yIHQgfmYgPVxuICAgIG1hcCB0IH5mOihmdW4gdmFsdWUgLT5cbiAgICAgIGYgdmFsdWU7XG4gICAgICB2YWx1ZSlcbiAgOztcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogNjQtYml0IGludGVnZXJzLlxuXG4gICBUaGlzIG1vZHVsZSBwcm92aWRlcyBvcGVyYXRpb25zIG9uIHRoZSB0eXBlIFtpbnQ2NF0gb2ZcbiAgIHNpZ25lZCA2NC1iaXQgaW50ZWdlcnMuICBVbmxpa2UgdGhlIGJ1aWx0LWluIFtpbnRdIHR5cGUsXG4gICB0aGUgdHlwZSBbaW50NjRdIGlzIGd1YXJhbnRlZWQgdG8gYmUgZXhhY3RseSA2NC1iaXQgd2lkZSBvbiBhbGxcbiAgIHBsYXRmb3Jtcy4gIEFsbCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb3ZlciBbaW50NjRdIGFyZSB0YWtlblxuICAgbW9kdWxvIDJ7XjY0fVxuXG4gICBQZXJmb3JtYW5jZSBub3RpY2U6IHZhbHVlcyBvZiB0eXBlIFtpbnQ2NF0gb2NjdXB5IG1vcmUgbWVtb3J5XG4gICBzcGFjZSB0aGFuIHZhbHVlcyBvZiB0eXBlIFtpbnRdLCBhbmQgYXJpdGhtZXRpYyBvcGVyYXRpb25zIG9uXG4gICBbaW50NjRdIGFyZSBnZW5lcmFsbHkgc2xvd2VyIHRoYW4gdGhvc2Ugb24gW2ludF0uICBVc2UgW2ludDY0XVxuICAgb25seSB3aGVuIHRoZSBhcHBsaWNhdGlvbiByZXF1aXJlcyBleGFjdCA2NC1iaXQgYXJpdGhtZXRpYy5cblxuICAgIExpdGVyYWxzIGZvciA2NC1iaXQgaW50ZWdlcnMgYXJlIHN1ZmZpeGVkIGJ5IEw6XG4gICAge1tcbiAgICAgIGxldCB6ZXJvOiBpbnQ2NCA9IDBMXG4gICAgICBsZXQgb25lOiBpbnQ2NCA9IDFMXG4gICAgICBsZXQgbV9vbmU6IGludDY0ID0gLTFMXG4gICAgXX1cbiopXG5cbnZhbCB6ZXJvIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMC4gKilcblxudmFsIG9uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIDEuICopXG5cbnZhbCBtaW51c19vbmUgOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAtMS4gKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuKCoqIFVuYXJ5IG5lZ2F0aW9uLiAqKVxuXG5leHRlcm5hbCBhZGQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FkZFwiXG4oKiogQWRkaXRpb24uICopXG5cbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbigqKiBTdWJ0cmFjdGlvbi4gKilcblxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuKCoqIE11bHRpcGxpY2F0aW9uLiAqKVxuXG5leHRlcm5hbCBkaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2RpdlwiXG4oKiogSW50ZWdlciBkaXZpc2lvbi5cbiAgIEByYWlzZSBEaXZpc2lvbl9ieV96ZXJvIGlmIHRoZSBzZWNvbmRcbiAgIGFyZ3VtZW50IGlzIHplcm8uICBUaGlzIGRpdmlzaW9uIHJvdW5kcyB0aGUgcmVhbCBxdW90aWVudCBvZlxuICAgaXRzIGFyZ3VtZW50cyB0b3dhcmRzIHplcm8sIGFzIHNwZWNpZmllZCBmb3IgeyFTdGRsaWIuKC8pfS4gKilcblxudmFsIHVuc2lnbmVkX2RpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0XG4oKiogU2FtZSBhcyB7IWRpdn0sIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhbmQgcmVzdWx0IGFyZSBpbnRlcnByZXRlZCBhcyB7ZVxuICAgIHVuc2lnbmVkfSA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbigqKiBJbnRlZ2VyIHJlbWFpbmRlci4gIElmIFt5XSBpcyBub3QgemVybywgdGhlIHJlc3VsdFxuICAgb2YgW0ludDY0LnJlbSB4IHldIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIHByb3BlcnR5OlxuICAgW3ggPSBJbnQ2NC5hZGQgKEludDY0Lm11bCAoSW50NjQuZGl2IHggeSkgeSkgKEludDY0LnJlbSB4IHkpXS5cbiAgIElmIFt5ID0gMF0sIFtJbnQ2NC5yZW0geCB5XSByYWlzZXMgW0RpdmlzaW9uX2J5X3plcm9dLiAqKVxuXG52YWwgdW5zaWduZWRfcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshcmVtfSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIHN1Y2MgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFN1Y2Nlc3Nvci4gIFtJbnQ2NC5zdWNjIHhdIGlzIFtJbnQ2NC5hZGQgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgcHJlZCA6IGludDY0IC0+IGludDY0XG4oKiogUHJlZGVjZXNzb3IuICBbSW50NjQucHJlZCB4XSBpcyBbSW50NjQuc3ViIHggSW50NjQub25lXS4gKilcblxudmFsIGFicyA6IGludDY0IC0+IGludDY0XG4oKiogW2FicyB4XSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgW3hdLiBPbiBbbWluX2ludF0gdGhpc1xuICAgaXMgW21pbl9pbnRdIGl0c2VsZiBhbmQgdGh1cyByZW1haW5zIG5lZ2F0aXZlLiAqKVxuXG52YWwgbWF4X2ludCA6IGludDY0XG4oKiogVGhlIGdyZWF0ZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIDJ7XjYzfSAtIDEuICopXG5cbnZhbCBtaW5faW50IDogaW50NjRcbigqKiBUaGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSA2NC1iaXQgaW50ZWdlciwgLTJ7XjYzfS4gKilcblxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBhbmQuICopXG5cbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIG9yLiAqKVxuXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIGV4Y2x1c2l2ZSBvci4gKilcblxudmFsIGxvZ25vdCA6IGludDY0IC0+IGludDY0XG4oKiogQml0d2lzZSBsb2dpY2FsIG5lZ2F0aW9uLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbigqKiBbSW50NjQuc2hpZnRfbGVmdCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIGxlZnQgYnkgW3ldIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0IHggeV0gc2hpZnRzIFt4XSB0byB0aGUgcmlnaHQgYnkgW3ldIGJpdHMuXG4gICBUaGlzIGlzIGFuIGFyaXRobWV0aWMgc2hpZnQ6IHRoZSBzaWduIGJpdCBvZiBbeF0gaXMgcmVwbGljYXRlZFxuICAgYW5kIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbigqKiBbSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhIGxvZ2ljYWwgc2hpZnQ6IHplcm9lcyBhcmUgaW5zZXJ0ZWQgaW4gdGhlIHZhY2F0ZWQgYml0c1xuICAgcmVnYXJkbGVzcyBvZiB0aGUgc2lnbiBvZiBbeF0uXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGludGVnZXIgKHR5cGUgW2ludF0pIHRvIGEgNjQtYml0IGludGVnZXJcbiAgICAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhblxuICAgaW50ZWdlciAodHlwZSBbaW50XSkuICBPbiA2NC1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye142M30sIGkuZS4gdGhlIGhpZ2gtb3JkZXIgYml0IGlzIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMxfSwgaS5lLiB0aGUgdG9wIDMzIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gKilcblxudmFsIHVuc2lnbmVkX3RvX2ludCA6IGludDY0IC0+IGludCBvcHRpb25cbigqKiBTYW1lIGFzIHshdG9faW50fSwgYnV0IGludGVycHJldHMgdGhlIGFyZ3VtZW50IGFzIGFuIHtlIHVuc2lnbmVkfSBpbnRlZ2VyLlxuICAgIFJldHVybnMgW05vbmVdIGlmIHRoZSB1bnNpZ25lZCB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgY2Fubm90IGZpdCBpbnRvIGFuXG4gICAgW2ludF0uXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvIGEgNjQtYml0IGludGVnZXIsXG4gICBkaXNjYXJkaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgKHRydW5jYXRlIHRvd2FyZHMgMCkuXG4gICBJZiB0aGUgdHJ1bmNhdGVkIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyBvdXRzaWRlIHRoZSByYW5nZVxuICAgXFxbeyFJbnQ2NC5taW5faW50fSwgeyFJbnQ2NC5tYXhfaW50fVxcXSwgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZCwgYW5kXG4gICBhbiB1bnNwZWNpZmllZCwgcGxhdGZvcm0tZGVwZW5kZW50IGludGVnZXIgaXMgcmV0dXJuZWQuICopXG5cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuICopXG5cblxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKS4gVGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LCBpLmUuIHRoZSB0b3AgMzIgYml0cyBhcmUgbG9zdFxuICAgZHVyaW5nIHRoZSBjb252ZXJzaW9uLiAgKilcblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBuYXRpdmUgaW50ZWdlciAodHlwZSBbbmF0aXZlaW50XSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgbmF0aXZlIGludGVnZXIuICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0uICBPbiA2NC1iaXQgcGxhdGZvcm1zLFxuICAgdGhlIGNvbnZlcnNpb24gaXMgZXhhY3QuICopXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBhIDY0LWJpdCBpbnRlZ2VyLlxuICAgVGhlIHN0cmluZyBpcyByZWFkIGluIGRlY2ltYWwgKGJ5IGRlZmF1bHQsIG9yIGlmIHRoZSBzdHJpbmdcbiAgIGJlZ2lucyB3aXRoIFswdV0pIG9yIGluIGhleGFkZWNpbWFsLCBvY3RhbCBvciBiaW5hcnkgaWYgdGhlXG4gICBzdHJpbmcgYmVnaW5zIHdpdGggWzB4XSwgWzBvXSBvciBbMGJdIHJlc3BlY3RpdmVseS5cblxuICAgVGhlIFswdV0gcHJlZml4IHJlYWRzIHRoZSBpbnB1dCBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgW1swLCAyKkludDY0Lm1heF9pbnQrMV1dLiAgSWYgdGhlIGlucHV0IGV4Y2VlZHMgeyFJbnQ2NC5tYXhfaW50fVxuICAgaXQgaXMgY29udmVydGVkIHRvIHRoZSBzaWduZWQgaW50ZWdlclxuICAgW0ludDY0Lm1pbl9pbnQgKyBpbnB1dCAtIEludDY0Lm1heF9pbnQgLSAxXS5cblxuICAgVGhlIFtfXSAodW5kZXJzY29yZSkgY2hhcmFjdGVyIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgYW5kIGlzIGlnbm9yZWQuXG4gICBAcmFpc2UgRmFpbHVyZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdFxuICAgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCBvciBpZiB0aGUgaW50ZWdlciByZXByZXNlbnRlZFxuICAgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgcmVwcmVzZW50YWJsZSBpbiB0eXBlIFtpbnQ2NF0uICopXG5cbnZhbCBvZl9zdHJpbmdfb3B0OiBzdHJpbmcgLT4gaW50NjQgb3B0aW9uXG4oKiogU2FtZSBhcyBbb2Zfc3RyaW5nXSwgYnV0IHJldHVybiBbTm9uZV0gaW5zdGVhZCBvZiByYWlzaW5nLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCB0b19zdHJpbmcgOiBpbnQ2NCAtPiBzdHJpbmdcbigqKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQsIGluIGRlY2ltYWwuICopXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXQgYWNjb3JkaW5nXG4gICB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQuXG4gICBCaXQgNjMgb2YgdGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzaWduIG9mIHRoZSBmbG9hdDtcbiAgIGJpdHMgNjIgdG8gNTIgcmVwcmVzZW50IHRoZSAoYmlhc2VkKSBleHBvbmVudDsgYml0cyA1MSB0byAwXG4gICByZXByZXNlbnQgdGhlIG1hbnRpc3NhLiAqKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdob3NlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLFxuICAgYWNjb3JkaW5nIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dCxcbiAgIGlzIHRoZSBnaXZlbiBbaW50NjRdLiAqKVxuXG50eXBlIHQgPSBpbnQ2NFxuKCoqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiA2NC1iaXQgaW50ZWdlcnMuICopXG5cbnZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRlZ2Vycywgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uIGFzXG4gICAgeyFTdGRsaWIuY29tcGFyZX0uICBBbG9uZyB3aXRoIHRoZSB0eXBlIFt0XSwgdGhpcyBmdW5jdGlvbiBbY29tcGFyZV1cbiAgICBhbGxvd3MgdGhlIG1vZHVsZSBbSW50NjRdIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgZnVuY3RvcnNcbiAgICB7IVNldC5NYWtlfSBhbmQgeyFNYXAuTWFrZX0uICopXG5cbnZhbCB1bnNpZ25lZF9jb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogU2FtZSBhcyB7IWNvbXBhcmV9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGludGVycHJldGVkIGFzIHtlIHVuc2lnbmVkfVxuICAgIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzLjAgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIG1heDogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuICopXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBhdG9taWMgOiBfIHRcbiAgdmFsIGNyZWF0ZSA6ICgnYSAtPiAnYSBTZXF1ZW5jZS50KSAtPiAnYSB0XG4gIHZhbCBzaHJpbmsgOiAnYSB0IC0+ICdhIC0+ICdhIFNlcXVlbmNlLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgbGV0IGF0b21pYyBfID0gU2VxdWVuY2UuZW1wdHlcbiAgbGV0IGNyZWF0ZSA9IEZuLmlkXG4gIGxldCBzaHJpbmsgPSBGbi5pZFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbWFwIHQgfmYgfmZfaW52ZXJzZSA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UubWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbmxldCBmaWx0ZXIgdCB+ZiA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyIH5mIChzaHJpbmsgdCB4KSlcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiB+Zl9pbnZlcnNlID1cbiAgY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXJfbWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbjs7XG5cbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2Uub2ZfbGF6eSAobGF6eSAoc2hyaW5rIChmb3JjZSBsYXp5X3QpIHgpKSlcblxubGV0IGZpeGVkX3BvaW50IG9mX3Nocmlua2VyID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9zaHJpbmtlciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBvZl9sYXp5IGxhenlfdFxuOztcblxubGV0IGJvdGggZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biAoZnN0LCBzbmQpIC0+XG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgIFsgU2VxdWVuY2UubWFwIChzaHJpbmsgZnN0X3QgZnN0KSB+ZjooZnVuIGZzdCAtPiBmc3QsIHNuZClcbiAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgc25kX3Qgc25kKSB+ZjooZnVuIHNuZCAtPiBmc3QsIHNuZClcbiAgICAgIF0pXG47O1xuXG5sZXQgdW5pdCA9IGF0b21pY1xubGV0IGJvb2wgPSBhdG9taWNcbmxldCBjaGFyID0gYXRvbWljXG5sZXQgaW50ID0gYXRvbWljXG5sZXQgaW50MzIgPSBhdG9taWNcbmxldCBpbnQ2MyA9IGF0b21pY1xubGV0IGludDY0ID0gYXRvbWljXG5sZXQgbmF0aXZlaW50ID0gYXRvbWljXG5sZXQgZmxvYXQgPSBhdG9taWNcblxubGV0IGJpZ2FycmF5MSBzcmMgPVxuICBsZXQgZGltID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBzcmMgaW5cbiAgbWF0Y2ggZGltIHdpdGhcbiAgfCAwIC0+IFNlcXVlbmNlLmVtcHR5XG4gIHwgXyAtPlxuICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkxLmtpbmQgc3JjIGluXG4gICAgbGV0IGxheW91dCA9IEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgc3JjIGluXG4gICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICBTZXF1ZW5jZS5pbml0IGRpbSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaW5pdCBraW5kIGxheW91dCAoZGltIC0gMSkgfmY6KGZ1biBpIC0+XG4gICAgICAgIHNyYy57aWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDF9KSlcbjs7XG5cbmxldCBiaWdzdHJpbmcgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQzMl92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQ2NF92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5cbmxldCBiaWdhcnJheTIgPVxuICBsZXQgbW9kdWxlIERpbXMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBkaW0xIDogaW50XG4gICAgICA7IGRpbTIgOiBpbnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgICAgU29tZSAoU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5hZGQgdHJlZSB+Y29tcGFyYXRvciBzbWFsbGVyX2VsdCkpKSlcbiAgICBpblxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluIFsgZHJvcF9lbHRzOyBzaHJpbmtfZWx0cyBdKVxuOztcblxubGV0IG1hcF90IGtleV90IGRhdGFfdCA9XG4gIGNyZWF0ZSAoZnVuIG1hcF90IC0+XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBtYXBfdCBpblxuICAgIGxldCB0ID1cbiAgICAgIG1hcFxuICAgICAgICAobWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfdCBkYXRhX3QpXG4gICAgICAgIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOk1hcC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IG1hcF90KVxuOztcblxubGV0IHNldF90IGVsdF90ID1cbiAgY3JlYXRlIChmdW4gc2V0X3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IFNldC5jb21wYXJhdG9yIHNldF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF90KVxuICAgICAgICB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbiAgICAgICAgfmZfaW52ZXJzZTpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4gICAgaW5cbiAgICBzaHJpbmsgdCBzZXRfdClcbjs7XG4iLCJvcGVuISBCYXNlXG5pbmNsdWRlIFRlc3RfaW50ZlxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIG1vZHVsZSBTZWVkID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTm9uZGV0ZXJtaW5pc3RpY1xuICAgICAgfCBEZXRlcm1pbmlzdGljIG9mIHN0cmluZ1xuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIG1vZHVsZSBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgc2VxdWVuY2UgPVxuICAgICAgbGV0IHByZWZpeCwgc3VmZml4ID0gU2VxdWVuY2Uuc3BsaXRfbiBzZXF1ZW5jZSAxMDAgaW5cbiAgICAgIGxldCBwcmVmaXggPSBMaXN0Lm1hcCBwcmVmaXggfmY6c2V4cF9vZl9lbHQgaW5cbiAgICAgIGxldCBzdWZmaXggPVxuICAgICAgICBtYXRjaCBTZXF1ZW5jZS5pc19lbXB0eSBzdWZmaXggd2l0aFxuICAgICAgICB8IHRydWUgLT4gW11cbiAgICAgICAgfCBmYWxzZSAtPiBbIFslbWVzc2FnZSBcIi4uLlwiXSBdXG4gICAgICBpblxuICAgICAgU2V4cC5MaXN0IChwcmVmaXggQCBzdWZmaXgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IHNlZWQgOiBTZWVkLnRcbiAgICA7IHRlc3RfY291bnQgOiBpbnRcbiAgICA7IHNocmlua19jb3VudCA6IGludFxuICAgIDsgc2l6ZXMgOiBpbnQgUG90ZW50aWFsbHlfaW5maW5pdGVfc2VxdWVuY2UudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuZW5kXG5cbmxldCBkZWZhdWx0X2NvbmZpZyA6IENvbmZpZy50ID1cbiAgeyBzZWVkID0gRGV0ZXJtaW5pc3RpYyBcImFuIGFyYml0cmFyeSBidXQgZGV0ZXJtaW5pc3RpYyBzdHJpbmdcIlxuICA7IHRlc3RfY291bnQgPSAxMF8wMDBcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iLCJtb2R1bGUgR2VuZXJhdG9yID0gR2VuZXJhdG9yXG5tb2R1bGUgT2JzZXJ2ZXIgPSBPYnNlcnZlclxubW9kdWxlIFNocmlua2VyID0gU2hyaW5rZXJcbm1vZHVsZSBUZXN0ID0gVGVzdFxubW9kdWxlIEV4cG9ydCA9IEV4cG9ydFxuaW5jbHVkZSBFeHBvcnRcblxuKCoqLyoqKVxuXG4oKl8gVGhpcyBtb2R1bGUgaXMgZXhwb3NlZCBvbmx5IHRvIG1ha2Ugb2NhbWxkb2Mgb3V0cHV0IG1vcmUgcmVhZGFibGUuICopXG5tb2R1bGUgV2l0aF9iYXNpY190eXBlcyA9IFdpdGhfYmFzaWNfdHlwZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEJpZ2FycmF5X2hlbHBlcnMgPSBCaWdhcnJheV9oZWxwZXJzXG5lbmRcbiJdfQ==
