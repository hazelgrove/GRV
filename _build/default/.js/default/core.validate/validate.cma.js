// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Validate
//# unitInfo: Requires: Assert_failure, Base, Base__Error, Base__Field, Base__Int, Base__List, Base__Maybe_bound, Base__Or_error, Base__Printf, Base__Staged, Base__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Validate$0 = "Validate",
    cst_validate$0 = "validate",
    cst_validate_src_validate_ml = "validate/src/validate.ml",
    cst_value = "value ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_List = global_data.Base__List,
    Base_Int = global_data.Base__Int,
    Base_Staged = global_data.Base__Staged,
    Base_Field = global_data.Base__Field,
    Base_Or_error = global_data.Base__Or_error,
    Base = global_data.Base,
    Base_Error = global_data.Base__Error,
    Base_String = global_data.Base__String,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Validate$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_validate$0);
   caml_call1(Expect_test_collector[5][1], cst_validate_src_validate_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_validate$0, cst);
   var
    _c_ = [0, cst_validate_src_validate_ml, 154, 20],
    _d_ =
      [0,
       [11, cst_value, [2, 0, [11, " < bound ", [2, 0, 0]]]],
       "value %s < bound %s"],
    _e_ =
      [0,
       [11, cst_value, [2, 0, [11, " <= bound ", [2, 0, 0]]]],
       "value %s <= bound %s"],
    _f_ = [0, cst_validate_src_validate_ml, 159, 20],
    _g_ =
      [0,
       [11, cst_value, [2, 0, [11, " > bound ", [2, 0, 0]]]],
       "value %s > bound %s"],
    _h_ =
      [0,
       [11, cst_value, [2, 0, [11, " >= bound ", [2, 0, 0]]]],
       "value %s >= bound %s"],
    cst_snd = "snd",
    cst_fst = "fst",
    _b_ = [0, 0],
    cst_validation_errors = "validation errors",
    _a_ = [0, "."],
    cst_Exception_raised_during_va = "Exception raised during validation",
    cst_validate = cst_validate$0,
    cst_Validate = cst_Validate$0,
    pass = 0;
   function fails(message, a, sexp_of_a){
    return [0,
            [0, 0, caml_call5(Base_Error[17], 0, 0, message, a, sexp_of_a)],
            0];
   }
   function fail(message){
    return [0, [0, 0, caml_call1(Base_Error[12], message)], 0];
   }
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function fail_s(sexp){
    return [0, [0, 0, caml_call1(Base_Error[18], sexp)], 0];
   }
   function combine(t1, t2){return caml_call2(Base[179], t1, t2);}
   var of_list = Base_List[138];
   function name(name, t){
    if(! t) return 0;
    function _P_(param){
     var error = param[2], path = param[1];
     return [0, [0, name, path], error];
    }
    return caml_call2(Base_List[76], t, _P_);
   }
   function name_list(n, l){return name(n, caml_call1(of_list, l));}
   function fail_fn(message, param){return fail(message);}
   function pass_bool(param){return pass;}
   function pass_unit(param){return pass;}
   function protect(f, v){
    try{var _O_ = caml_call1(f, v); return _O_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _N_ = [0, [0, cst$0, caml_call1(Base[107], exn)], 0];
     return fail_s
             (caml_call2(Base[85][7], cst_Exception_raised_during_va, _N_));
    }
   }
   function try_with(f){
    var _M_ = 0;
    return protect(function(param){caml_call1(f, 0); return pass;}, _M_);
   }
   function path_string(path){return caml_call2(Base_String[54], _a_, path);}
   function errors(t){
    function _J_(param){
     var
      error = param[2],
      path = param[1],
      _K_ = path_string(path),
      _L_ = caml_call2(Base_Error[20], error, _K_);
     return caml_call1(Base_Error[9], _L_);
    }
    return caml_call2(Base_List[76], t, _J_);
   }
   function result(t){
    if(caml_call1(Base_List[8], t)) return _b_;
    function _F_(x_005){
     function _I_(param){
      var
       arg1_002 = param[2],
       arg0_001 = param[1],
       res0_003 = caml_call1(Base[165], arg0_001),
       res1_004 = caml_call1(Base_Error[6], arg1_002);
      return [1, [0, res0_003, [0, res1_004, 0]]];
     }
     return caml_call2(Base_List[4], _I_, x_005);
    }
    function _G_(param){
     var error = param[2], path = param[1];
     return [0, path_string(path), error];
    }
    var _H_ = caml_call2(Base_List[76], t, _G_);
    return caml_call5
            (Base_Or_error[34], 0, 0, cst_validation_errors, _H_, _F_);
   }
   function maybe_raise(t){
    var _E_ = result(t);
    return caml_call1(Base_Or_error[31], _E_);
   }
   function valid_or_error(check, x){
    function _C_(param){return x;}
    var _D_ = result(protect(check, x));
    return caml_call2(Base_Or_error[43], _D_, _C_);
   }
   function field_direct(check, fld, record, v){
    var result = protect(check, v);
    return name(caml_call1(Base_Field[2], fld), result);
   }
   function field(check, record, fld){
    var v = caml_call2(Base_Field[3], fld, record);
    return field_direct(check, fld, record, v);
   }
   function field_folder(check, record){
    return function(acc, fld){return [0, field(check, record, fld), acc];};
   }
   function field_direct_folder(check){
    function _B_(acc, fld, record, v){
     var result = field_direct(check, fld, record, v);
     return result ? [0, result, acc] : acc;
    }
    return caml_call1(Base_Staged[1], _B_);
   }
   function all(checks, v){
    var checks$0 = checks, errs = 0;
    for(;;){
     if(! checks$0)
      return caml_call1(of_list, caml_call1(Base_List[38], errs));
     var checks$1 = checks$0[2], check = checks$0[1], err = protect(check, v);
     if(err)
      var errs$0 = [0, err, errs], checks$0 = checks$1, errs = errs$0;
     else
      var checks$0 = checks$1;
    }
   }
   function of_result(f){
    function _z_(v){
     var match = caml_call1(f, v);
     if(0 === match[0]) return pass;
     var error = match[1];
     return fail(error);
    }
    return function(_A_){return protect(_z_, _A_);};
   }
   function of_error(f){
    function _x_(v){
     var match = caml_call1(f, v);
     if(0 === match[0]) return pass;
     var error = match[1];
     return [0, [0, 0, error], 0];
    }
    return function(_y_){return protect(_x_, _y_);};
   }
   function booltest(f, if_false){
    function _v_(v){return caml_call1(f, v) ? pass : fail(if_false);}
    return function(_w_){return protect(_v_, _w_);};
   }
   function pair(fst, snd, param){
    var
     snd_value = param[2],
     fst_value = param[1],
     _u_ = [0, name(cst_snd, protect(snd, snd_value)), 0];
    return caml_call1
            (of_list, [0, name(cst_fst, protect(fst, fst_value)), _u_]);
   }
   function list_indexed(check, list){
    function _s_(i, el){
     var _t_ = protect(check, el);
     return name(caml_call1(Base_Int[11], i + 1 | 0), _t_);
    }
    return caml_call1(of_list, caml_call2(Base_List[96], list, _s_));
   }
   function list(extract_name, check, list){
    function _r_(el){
     var t = protect(check, el);
     return t
             ? protect
               (function(t){return name(caml_call1(extract_name, el), t);}, t)
             : 0;
    }
    return caml_call1(of_list, caml_call2(Base_List[76], list, _r_));
   }
   function alist(name, f, list$0){
    function _q_(param){var x = param[2]; return caml_call1(f, x);}
    return list
            (function(param){
              var key = param[1];
              return caml_call1(name, key);
             },
             _q_,
             list$0);
   }
   function first_failure(t1, t2){
    return caml_call1(Base_List[8], t1) ? t2 : t1;
   }
   function of_error_opt(param){
    if(! param) return pass;
    var error = param[1];
    return fail(error);
   }
   function bounded(name, lower, upper, compare, x){
    switch(caml_call4(Base_Maybe_bound[16], lower, upper, x, compare)){
      case 0:
       if(typeof lower === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(0 === lower[0]){
        var
         incl = lower[1],
         _i_ = caml_call1(name, incl),
         _j_ = caml_call1(name, x);
        return fail(caml_call3(Base_Printf[2], _d_, _j_, _i_));
       }
       var
        excl = lower[1],
        _k_ = caml_call1(name, excl),
        _l_ = caml_call1(name, x);
       return fail(caml_call3(Base_Printf[2], _e_, _l_, _k_));
      case 1:
       return pass;
      default:
       if(typeof upper === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
       if(0 === upper[0]){
        var
         incl$0 = upper[1],
         _m_ = caml_call1(name, incl$0),
         _n_ = caml_call1(name, x);
        return fail(caml_call3(Base_Printf[2], _g_, _n_, _m_));
       }
       var
        excl$0 = upper[1],
        _o_ = caml_call1(name, excl$0),
        _p_ = caml_call1(name, x);
       return fail(caml_call3(Base_Printf[2], _h_, _p_, _o_));
    }
   }
   function symbol(t1, t2){return combine(t1, t2);}
   var Infix = [0, symbol];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_validate);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Validate);
   var
    Validate =
      [0,
       pass,
       fail,
       fails,
       fail_s,
       failf,
       combine,
       of_list,
       name,
       name_list,
       fail_fn,
       pass_bool,
       pass_unit,
       protect,
       try_with,
       result,
       errors,
       maybe_raise,
       valid_or_error,
       field,
       field_direct,
       field_folder,
       field_direct_folder,
       all,
       of_result,
       of_error,
       booltest,
       pair,
       list_indexed,
       list,
       first_failure,
       of_error_opt,
       alist,
       bounded,
       Infix];
   runtime.caml_register_global(35, Validate, cst_Validate$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ2YWxpZGF0ZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicGFzcyIsImZhaWxzIiwibWVzc2FnZSIsImEiLCJzZXhwX29mX2EiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJmYWlsX3MiLCJzZXhwIiwiY29tYmluZSIsInQxIiwidDIiLCJvZl9saXN0IiwibmFtZSIsInQiLCJlcnJvciIsInBhdGgiLCJuYW1lX2xpc3QiLCJuIiwibCIsImZhaWxfZm4iLCJwYXNzX2Jvb2wiLCJwYXNzX3VuaXQiLCJwcm90ZWN0IiwiZiIsInYiLCJleG4kMCIsImV4biIsInRyeV93aXRoIiwicGF0aF9zdHJpbmciLCJlcnJvcnMiLCJyZXN1bHQiLCJ4XzAwNSIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwibWF5YmVfcmFpc2UiLCJ2YWxpZF9vcl9lcnJvciIsImNoZWNrIiwieCIsImZpZWxkX2RpcmVjdCIsImZsZCIsInJlY29yZCIsImZpZWxkIiwiZmllbGRfZm9sZGVyIiwiYWNjIiwiZmllbGRfZGlyZWN0X2ZvbGRlciIsImFsbCIsImNoZWNrcyIsImNoZWNrcyQwIiwiZXJycyIsImNoZWNrcyQxIiwiZXJyIiwiZXJycyQwIiwib2ZfcmVzdWx0Iiwib2ZfZXJyb3IiLCJib29sdGVzdCIsImlmX2ZhbHNlIiwicGFpciIsImZzdCIsInNuZCIsInNuZF92YWx1ZSIsImZzdF92YWx1ZSIsImxpc3RfaW5kZXhlZCIsImxpc3QiLCJpIiwiZWwiLCJleHRyYWN0X25hbWUiLCJhbGlzdCIsImxpc3QkMCIsImtleSIsImZpcnN0X2ZhaWx1cmUiLCJvZl9lcnJvcl9vcHQiLCJib3VuZGVkIiwibG93ZXIiLCJ1cHBlciIsImNvbXBhcmUiLCJpbmNsIiwiZXhjbCIsImluY2wkMCIsImV4Y2wkMCIsInN5bWJvbCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvY29yZS92YWxpZGF0ZS92YWxpZGF0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QztPQU1BSTtPQUNBRztPQUNBQztPQUNBQztPQUVBQztPQU1BSztPQXlCQUc7T0FmQUQ7T0FpQkFPO09BQ0FDO09BT0FNO09BTEFIO09BVUFJO09BS0FFO09BT0FDO09BWUFPO09BT0FDO09BT0FDO09BRUFFO09BSUFLO09BS0FDO09BV0FPO09BRUFDO09BSEFKO09BUUFLOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuIEJhc2VcblxuKCoqIEVhY2ggc2luZ2xlX2Vycm9yIGlzIGEgcGF0aCBpbmRpY2F0aW5nIHRoZSBsb2NhdGlvbiB3aXRoaW4gdGhlIGRhdGFzdHJ1Y3R1cmUgaW5cbiAgICBxdWVzdGlvbiB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZCwgYWxvbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlLiAqKVxudHlwZSBzaW5nbGVfZXJyb3IgPVxuICB7IHBhdGggOiBzdHJpbmcgbGlzdFxuICA7IGVycm9yIDogRXJyb3IudFxuICB9XG5cbnR5cGUgdCA9IHNpbmdsZV9lcnJvciBsaXN0XG50eXBlICdhIGNoZWNrID0gJ2EgLT4gdFxuXG5sZXQgcGFzcyA6IHQgPSBbXVxuXG5sZXQgZmFpbHMgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFsgeyBwYXRoID0gW107IGVycm9yID0gRXJyb3IuY3JlYXRlIG1lc3NhZ2UgYSBzZXhwX29mX2EgfSBdXG47O1xuXG5sZXQgZmFpbCBtZXNzYWdlID0gWyB7IHBhdGggPSBbXTsgZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgbWVzc2FnZSB9IF1cbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcbmxldCBmYWlsX3Mgc2V4cCA9IFsgeyBwYXRoID0gW107IGVycm9yID0gRXJyb3IuY3JlYXRlX3Mgc2V4cCB9IF1cbmxldCBjb21iaW5lIHQxIHQyID0gdDEgQCB0MlxubGV0IG9mX2xpc3QgPSBMaXN0LmNvbmNhdFxuXG5sZXQgbmFtZSBuYW1lIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXSAoKiB3aGVuIHN1Y2Nlc3NmdWwsIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIGEgY2xvc3VyZSBmb3IgW35mXSwgYmVsb3cgKilcbiAgfCBfIC0+IExpc3QubWFwIHQgfmY6KGZ1biB7IHBhdGg7IGVycm9yIH0gLT4geyBwYXRoID0gbmFtZSA6OiBwYXRoOyBlcnJvciB9KVxuOztcblxubGV0IG5hbWVfbGlzdCBuIGwgPSBuYW1lIG4gKG9mX2xpc3QgbClcbmxldCBmYWlsX2ZuIG1lc3NhZ2UgXyA9IGZhaWwgbWVzc2FnZVxubGV0IHBhc3NfYm9vbCAoXyA6IGJvb2wpID0gcGFzc1xubGV0IHBhc3NfdW5pdCAoXyA6IHVuaXQpID0gcGFzc1xuXG5sZXQgcHJvdGVjdCBmIHYgPVxuICB0cnkgZiB2IHdpdGhcbiAgfCBleG4gLT5cbiAgICBmYWlsX3MgKFNleHAubWVzc2FnZSBcIkV4Y2VwdGlvbiByYWlzZWQgZHVyaW5nIHZhbGlkYXRpb25cIiBbIFwiXCIsIHNleHBfb2ZfZXhuIGV4biBdKVxuOztcblxubGV0IHRyeV93aXRoIGYgPVxuICBwcm90ZWN0XG4gICAgKGZ1biAoKSAtPlxuICAgICAgIGYgKCk7XG4gICAgICAgcGFzcylcbiAgICAoKVxuOztcblxubGV0IHBhdGhfc3RyaW5nIHBhdGggPSBTdHJpbmcuY29uY2F0IH5zZXA6XCIuXCIgcGF0aFxuXG5sZXQgZXJyb3JzIHQgPVxuICBMaXN0Lm1hcCB0IH5mOihmdW4geyBwYXRoOyBlcnJvciB9IC0+XG4gICAgRXJyb3IudG9fc3RyaW5nX2h1bSAoRXJyb3IudGFnIGVycm9yIH50YWc6KHBhdGhfc3RyaW5nIHBhdGgpKSlcbjs7XG5cbmxldCByZXN1bHRfZmFpbCB0ID1cbiAgT3JfZXJyb3IuZXJyb3JcbiAgICBcInZhbGlkYXRpb24gZXJyb3JzXCJcbiAgICAoTGlzdC5tYXAgdCB+ZjooZnVuIHsgcGF0aDsgZXJyb3IgfSAtPiBwYXRoX3N0cmluZyBwYXRoLCBlcnJvcikpXG4gICAgWyVzZXhwX29mOiAoc3RyaW5nICogRXJyb3IudCkgTGlzdC50XVxuW0BAY29sZF1cbjs7XG5cbigqKiBbcmVzdWx0XSBpcyBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5saW5lZCAtLSBjYWxsaW5nIFtyZXN1bHRfZmFpbF0sXG4gICAgd2hpY2ggaXMgbm90IGlubGluZWFibGUsIGlzIGtleSB0byB0aGlzLiAqKVxubGV0IHJlc3VsdCB0ID0gaWYgTGlzdC5pc19lbXB0eSB0IHRoZW4gT2sgKCkgZWxzZSByZXN1bHRfZmFpbCB0XG5cbmxldCBtYXliZV9yYWlzZSB0ID0gT3JfZXJyb3Iub2tfZXhuIChyZXN1bHQgdClcbmxldCB2YWxpZF9vcl9lcnJvciBjaGVjayB4ID0gT3JfZXJyb3IubWFwIChyZXN1bHQgKHByb3RlY3QgY2hlY2sgeCkpIH5mOihmdW4gKCkgLT4geClcblxubGV0IGZpZWxkX2RpcmVjdCBjaGVjayBmbGQgX3JlY29yZCB2ID1cbiAgbGV0IHJlc3VsdCA9IHByb3RlY3QgY2hlY2sgdiBpblxuICBuYW1lIChGaWVsZC5uYW1lIGZsZCkgcmVzdWx0XG47O1xuXG5sZXQgZmllbGQgY2hlY2sgcmVjb3JkIGZsZCA9XG4gIGxldCB2ID0gRmllbGQuZ2V0IGZsZCByZWNvcmQgaW5cbiAgZmllbGRfZGlyZWN0IGNoZWNrIGZsZCByZWNvcmQgdlxuOztcblxubGV0IGZpZWxkX2ZvbGRlciBjaGVjayByZWNvcmQgPVxuICAoKTtcbiAgZnVuIGFjYyBmbGQgLT4gZmllbGQgY2hlY2sgcmVjb3JkIGZsZCA6OiBhY2Ncbjs7XG5cbmxldCBmaWVsZF9kaXJlY3RfZm9sZGVyIGNoZWNrID1cbiAgU3RhZ2VkLnN0YWdlIChmdW4gYWNjIGZsZCByZWNvcmQgdiAtPlxuICAgIG1hdGNoIGZpZWxkX2RpcmVjdCBjaGVjayBmbGQgcmVjb3JkIHYgd2l0aFxuICAgIHwgW10gLT4gYWNjICgqIEF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgbGlzdCBpbiB0aGUgc3VjY2VzcyBjYXNlICopXG4gICAgfCByZXN1bHQgLT4gcmVzdWx0IDo6IGFjYylcbjs7XG5cbmxldCBhbGwgY2hlY2tzIHYgPVxuICBsZXQgcmVjIGxvb3AgY2hlY2tzIHYgZXJycyA9XG4gICAgbWF0Y2ggY2hlY2tzIHdpdGhcbiAgICB8IFtdIC0+IGVycnNcbiAgICB8IGNoZWNrIDo6IGNoZWNrcyAtPlxuICAgICAgKG1hdGNoIHByb3RlY3QgY2hlY2sgdiB3aXRoXG4gICAgICAgfCBbXSAtPiBsb29wIGNoZWNrcyB2IGVycnNcbiAgICAgICB8IGVyciAtPiBsb29wIGNoZWNrcyB2IChlcnIgOjogZXJycykpXG4gIGluXG4gIG9mX2xpc3QgKExpc3QucmV2IChsb29wIGNoZWNrcyB2IFtdKSlcbjs7XG5cbmxldCBvZl9yZXN1bHQgZiA9XG4gIHByb3RlY3QgKGZ1biB2IC0+XG4gICAgbWF0Y2ggZiB2IHdpdGhcbiAgICB8IE9rICgpIC0+IHBhc3NcbiAgICB8IEVycm9yIGVycm9yIC0+IGZhaWwgZXJyb3IpXG47O1xuXG5sZXQgb2ZfZXJyb3IgZiA9XG4gIHByb3RlY3QgKGZ1biB2IC0+XG4gICAgbWF0Y2ggZiB2IHdpdGhcbiAgICB8IE9rICgpIC0+IHBhc3NcbiAgICB8IEVycm9yIGVycm9yIC0+IFsgeyBwYXRoID0gW107IGVycm9yIH0gXSlcbjs7XG5cbmxldCBib29sdGVzdCBmIH5pZl9mYWxzZSA9IHByb3RlY3QgKGZ1biB2IC0+IGlmIGYgdiB0aGVuIHBhc3MgZWxzZSBmYWlsIGlmX2ZhbHNlKVxuXG5sZXQgcGFpciB+ZnN0IH5zbmQgKGZzdF92YWx1ZSwgc25kX3ZhbHVlKSA9XG4gIG9mX2xpc3QgWyBuYW1lIFwiZnN0XCIgKHByb3RlY3QgZnN0IGZzdF92YWx1ZSk7IG5hbWUgXCJzbmRcIiAocHJvdGVjdCBzbmQgc25kX3ZhbHVlKSBdXG47O1xuXG5sZXQgbGlzdF9pbmRleGVkIGNoZWNrIGxpc3QgPVxuICBMaXN0Lm1hcGkgbGlzdCB+ZjooZnVuIGkgZWwgLT4gbmFtZSAoSW50LnRvX3N0cmluZyAoaSArIDEpKSAocHJvdGVjdCBjaGVjayBlbCkpXG4gIHw+IG9mX2xpc3Rcbjs7XG5cbmxldCBsaXN0IH5uYW1lOmV4dHJhY3RfbmFtZSBjaGVjayBsaXN0ID1cbiAgTGlzdC5tYXAgbGlzdCB+ZjooZnVuIGVsIC0+XG4gICAgbWF0Y2ggcHJvdGVjdCBjaGVjayBlbCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgdCAtPlxuICAgICAgKCogZXh0cmEgbGV2ZWwgb2YgcHJvdGVjdGlvbiBpbiBjYXNlIGV4dHJhY3RfbmFtZSB0aHJvd3MgYW4gZXhjZXB0aW9uICopXG4gICAgICBwcm90ZWN0IChmdW4gdCAtPiBuYW1lIChleHRyYWN0X25hbWUgZWwpIHQpIHQpXG4gIHw+IG9mX2xpc3Rcbjs7XG5cbmxldCBhbGlzdCB+bmFtZSBmIGxpc3QnID0gbGlzdCAoZnVuIChfLCB4KSAtPiBmIHgpIGxpc3QnIH5uYW1lOihmdW4gKGtleSwgXykgLT4gbmFtZSBrZXkpXG5sZXQgZmlyc3RfZmFpbHVyZSB0MSB0MiA9IGlmIExpc3QuaXNfZW1wdHkgdDEgdGhlbiB0MiBlbHNlIHQxXG5cbmxldCBvZl9lcnJvcl9vcHQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gcGFzc1xuICB8IFNvbWUgZXJyb3IgLT4gZmFpbCBlcnJvclxuOztcblxubGV0IGJvdW5kZWQgfm5hbWUgfmxvd2VyIH51cHBlciB+Y29tcGFyZSB4ID1cbiAgbWF0Y2ggTWF5YmVfYm91bmQuY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSB4IHdpdGhcbiAgfCBJbl9yYW5nZSAtPiBwYXNzXG4gIHwgQmVsb3dfbG93ZXJfYm91bmQgLT5cbiAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgfCBJbmNsIGluY2wgLT4gZmFpbCAoUHJpbnRmLnNwcmludGYgXCJ2YWx1ZSAlcyA8IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgaW5jbCkpXG4gICAgIHwgRXhjbCBleGNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPD0gYm91bmQgJXNcIiAobmFtZSB4KSAobmFtZSBleGNsKSkpXG4gIHwgQWJvdmVfdXBwZXJfYm91bmQgLT5cbiAgICAobWF0Y2ggdXBwZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgfCBJbmNsIGluY2wgLT4gZmFpbCAoUHJpbnRmLnNwcmludGYgXCJ2YWx1ZSAlcyA+IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgaW5jbCkpXG4gICAgIHwgRXhjbCBleGNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPj0gYm91bmQgJXNcIiAobmFtZSB4KSAobmFtZSBleGNsKSkpXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggKysgKSB0MSB0MiA9IGNvbWJpbmUgdDEgdDJcbmVuZFxuIl19
