// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http$0 = "http",
    cst_https$0 = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result,
    _aS_ = [0, 0],
    _aN_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _aP_ = [0, -1042355253],
    _aQ_ = [0, 804243368],
    _aO_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _aR_ = [1, [0, 3854881, "No scheme present in URI"]],
    cst_http = cst_http$0,
    cst_https = cst_https$0,
    _aM_ = [0, cst$34],
    _aL_ = [0, 0],
    _C_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _B_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _ak_ = [0, 0, 0, 0];
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     var param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     var t$2 = xs, t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _d3_ = i + 1 | 0;
     if(10 === i) return a;
     var i = _d3_;
    }
   }
   var safe_chars = caml_make_vect(256, 0), i = 0;
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _aT_ = i + 1 | 0;
    if(65 === i) break;
    var i = _aT_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[6], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[6], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[6], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[6], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[6], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[6], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[6], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _dW_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[6], _dW_),
      _dY_ = caml_ml_string_length(safe) - 1 | 0,
      _dX_ = 0;
     if(_dY_ >= 0){
      var i$0 = _dX_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _d2_ = i$0 + 1 | 0;
       if(_dY_ === i$0) break;
       var i$0 = _d2_;
      }
     }
     var _d0_ = caml_ml_string_length(unsafe) - 1 | 0, _dZ_ = 0;
     if(_d0_ >= 0){
      var i = _dZ_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _d1_ = i + 1 | 0;
       if(_d0_ === i) break;
       var i = _d1_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[26], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[26], hs);
    return caml_string_equal(hs$0, cst_localhost$0) ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[26], s);
    return caml_string_notequal(match, "file")
            ? caml_string_notequal
               (match, cst_http$0)
              ? caml_string_notequal
                 (match, cst_https$0)
                ? caml_string_notequal(match, "urn") ? Generic : Urn
                : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c])
      var cur$0 = cur + 1 | 0, cur = cur$0;
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _dV_ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _dV_);
      var
       cur$1 = cur + 1 | 0,
       start$0 = cur + 1 | 0,
       start = start$0,
       cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[4], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0, cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_dU_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        var start = start$0, cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_dT_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _dR_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _dR_);
          var start_at = cur$0;
          break a;
         }
         var _dS_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _dS_);
         var start_at = cur$0 + 1 | 0;
        }
        var start = start_at, cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _dQ_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _dQ_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    return encode(scheme, [0, component], s);
   }
   function pct_encoder(opt, _dP_, _dO_, _dN_, _dM_, _dL_, _dK_, param){
    if(opt) var sth = opt[1], scheme = sth; else var scheme = -178940859;
    if(_dP_)
     var sth$0 = _dP_[1], userinfo = sth$0;
    else
     var userinfo = -145160103;
    if(_dO_) var sth$1 = _dO_[1], host = sth$1; else var host = 803994504;
    if(_dN_) var sth$2 = _dN_[1], path = sth$2; else var path = 892015045;
    if(_dM_)
     var sth$3 = _dM_[1], query_key = sth$3;
    else
     var query_key = -911188600;
    if(_dL_)
     var sth$4 = _dL_[1], query_value = sth$4;
    else
     var query_value = 795008922;
    if(_dK_)
     var sth$5 = _dK_[1], fragment = sth$5;
    else
     var fragment = 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){return decode(s);}
   function compare(param, _dJ_){
    var
     p = _dJ_[2],
     u = _dJ_[1],
     p$0 = param[2],
     u$0 = param[1],
     c = caml_call2(Stdlib_String[9], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[9], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(! match$0) return [0, pct_decode(u), 0];
    var p = match$0[1], _dI_ = [0, pct_decode(p)];
    return [0, pct_decode(u), _dI_];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _dF_ = caml_ml_string_length(p); else var _dF_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _dF_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _dG_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _dG_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _dH_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _dH_);
     }
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   var _e_ = Stdlib_String[9];
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[19], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[9], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _dB_ = param$0[1];
       c:
       {
        if(caml_string_notequal(_dB_, cst$36)){
         if(caml_string_notequal(_dB_, cst$39)){
          if(caml_string_notequal(_dB_, cst$33)) break a;
          var _dD_ = param$0[2];
          if(! _dD_) break b;
          var _dE_ = _dD_[1];
          if(! caml_string_notequal(_dE_, cst$36)){var r$3 = _dD_[2]; break c;}
          if(caml_string_notequal(_dE_, cst$39)){
           if(! caml_string_notequal(_dE_, cst$33)){
            var r$1 = _dD_[2];
            if(0 < ascension){
             var
              ascension$1 = ascension - 1 | 0,
              ascension = ascension$1,
              param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _dD_[2];
           if(0 >= ascension) break a;
           var
            ascension$0 = ascension - 1 | 0,
            ascension = ascension$0,
            param$0 = r$0;
           continue;
          }
          var r$2 = _dD_[2];
         }
         else
          var r$2 = param$0[2];
         var
          ascension$2 = ascension + 1 | 0,
          ascension = ascension$2,
          param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       var param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_string_equal(caml_call1(Stdlib_List[5], p), cst$33))
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var
      r = param$0[2],
      s = param$0[1],
      outp$0 = [0, s, outp],
      ascension = 0,
      outp = outp$0,
      param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_string_equal(caml_call1(Stdlib_List[5], outp), cst$33))
      return caml_call1(Stdlib_List[6], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[9], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _dC_ = acc; break;}
      var
       xs = param[2],
       x = param[1],
       acc$0 = [0, x, [0, cst$0, acc]],
       acc = acc$0,
       param = xs;
     }
    }
    else
     var _dC_ = 0;
    return caml_call2(Stdlib_List[12], [0, cst$1, _dC_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var _dy_ = 0;
     function _dz_(c, tok){return caml_ml_string_length(tok) + c | 0;}
     var
      len = caml_call3(Stdlib_List[25], _dz_, _dy_, p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(! caml_string_notequal(seg, cst$33))
         return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _dA_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _dA_);
       },
       cst$4,
       buf,
       p);
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[45], s),
      _dw_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _dv_ = 0;
     if(_dw_ >= 0){
      var i = _dv_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _dx_ = i + 1 | 0;
       if(_dw_ === i) break;
       var i = _dx_;
      }
     }
     return caml_call1(Stdlib_Bytes[44], s$0);
    }
    if(els){
     var
      _dr_ = function(el){return caml_call3(Stringext[3], _h_, el, 61);},
      acc = 0,
      param = caml_call2(Stdlib_List[21], _dr_, els);
     for(;;){
      if(! param){var _ds_ = acc; break;}
      var _dp_ = param[1];
      if(_dp_){
       var match = _dp_[2], k = _dp_[1];
       if(match)
        var
         tl = param[2],
         v = match[1],
         _dq_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _dq_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc],
         acc = acc$0,
         param = tl;
       else
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc],
         acc = acc$1,
         param = tl$0;
      }
      else
       var tl$1 = param[2], acc$2 = [0, _g_, acc], acc = acc$2, param = tl$1;
     }
    }
    else
     var _ds_ = _i_;
    function _dt_(param){
     var
      v = param[2],
      k = param[1],
      _du_ = caml_call2(Stdlib_List[19], pct_decode, v);
     return [0, pct_decode(k), _du_];
    }
    return caml_call2(Stdlib_List[19], _dt_, _ds_);
   }
   function encoded_of_query(scheme, opt, l){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var _di_ = -1;
    function _dj_(a, param){
     var v = param[2], k = param[1], _dn_ = 0;
     function _do_(a, s){return (a + caml_ml_string_length(s) | 0) + 1 | 0;}
     return ((a + caml_ml_string_length(k) | 0)
            + caml_call3(Stdlib_List[25], _do_, _dn_, v)
            | 0)
            + 2
            | 0;
    }
    var
     len = caml_call3(Stdlib_List[25], _dj_, _di_, l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _dk_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _dk_);
       var _dl_ = 0 !== v ? 1 : 0;
       return _dl_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _dm_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _dm_);
                   },
                   cst$8,
                   buf,
                   v))
               : _dl_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    function _dh_(param){return query_of_encoded(qs);}
    var lazy_query = caml_call1(Stdlib_Lazy[6], _dh_);
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else{
     var _de_ = param[2], _df_ = caml_obj_tag(_de_);
     a:
     if(250 === _df_)
      var _dg_ = _de_[1];
     else{
      if(246 !== _df_ && 244 !== _df_){var _dg_ = _de_; break a;}
      var _dg_ = caml_call1(CamlinternalLazy[2], _de_);
     }
     var kv = _dg_;
    }
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_dc_, _dd_){return encoded_of_query(scheme, _dc_, _dd_);};
   }
   var
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[9];
   function compare_decoded_opt(_da_, _db_){
    return compare_opt(compare_decoded, _da_, _db_);
   }
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _c$_ = h1[1];
     if(-367671627 === _c$_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[9], ip1, ip2);
      }
     }
     else
      if(267950263 === _c$_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[9], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _c$_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$3 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$3) return c$3;
    var c = compare_decoded_opt(t$0[1], t[1]);
    if(0 !== c) return c;
    var
     _c8_ = t[4],
     _c9_ = t$0[4],
     c$0 =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;}, _c9_, _c8_);
    if(0 !== c$0) return c$0;
    var c$1 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$1) return c$1;
    var c$4 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$4) return c$4;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _c1_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _c1_;
      else{
       var _c2_ = y[2], _c3_ = caml_obj_tag(_c2_);
       b:
       if(250 === _c3_)
        var _c4_ = _c2_[1];
       else{
        if(246 !== _c3_ && 244 !== _c3_){var _c4_ = _c2_; break b;}
        var _c4_ = caml_call1(CamlinternalLazy[2], _c2_);
       }
       var kvl$0 = _c4_, kvl = _c1_;
      }
     }
     else{
      var _c5_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$2 = compare_opt(Stdlib_String[9], raw, raw$0);
       break a;
      }
      var _c6_ = caml_obj_tag(_c5_);
      b:
      if(250 === _c6_)
       var _c7_ = _c5_[1];
      else{
       if(246 !== _c6_ && 244 !== _c6_){var _c7_ = _c5_; break b;}
       var _c7_ = caml_call1(CamlinternalLazy[2], _c5_);
      }
      var kvl$0 = y[1], kvl = _c7_;
     }
     var
      c$2 =
        compare_list
         (function(param, _c__){
           var
            vl = _c__[2],
            k = _c__[1],
            vl$0 = param[2],
            k$0 = param[1],
            c = caml_call2(Stdlib_String[9], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[9], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$2 ? compare_decoded_opt(t$0[7], t[7]) : c$2;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cV_ = init[3],
     _cR_ = init[7],
     _cS_ = init[6],
     _cT_ = init[5],
     _cU_ = init[4];
    if(_cV_){
     var match = _cV_[1], _cW_ = match[1];
     if(267950263 === _cW_)
      var
       host = match[2],
       _cX_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cW_)
      var
       host$0 = match[2],
       _cX_ = [0, [0, 803994504, Scheme[2].call(null, host$0)]];
     else
      var
       host$1 = match[2],
       _cX_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cY_ = _cX_;
    }
    else
     var _cY_ = 0;
    var param = init[1], f = Stdlib_String[26], _cZ_ = init[2];
    if(param)
     var x = param[1], _c0_ = [0, caml_call1(f, x)];
    else
     var _c0_ = 0;
    return [0, _c0_, _cZ_, _cY_, _cU_, _cT_, _cS_, _cR_];
   }
   function to_string(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     if(opt)
      var sth = opt[1], component = sth;
     else
      var component = 892015045;
     var _cQ_ = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _cy_ = uri[3], _cz_ = uri[4];
     if(! uri[2] && ! _cy_ && ! _cz_){var _cA_ = 0; break a;}
     var _cA_ = 1;
    }
    if(_cA_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      _cB_ = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, _cB_);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _cC_ = uri[3];
    if(_cC_){
     var match$2 = _cC_[1], _cD_ = match$2[1];
     if(267950263 === _cD_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _cD_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _cE_ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _cE_);
    }
    var _cF_ = uri[5];
    if(_cF_){
     var first_segment = _cF_[1];
     if(caml_string_notequal(first_segment, cst$33)){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _cG_ = uri[5],
       _cH_ = encoded_of_path(scheme, pct_encoder$0[4])(_cG_);
      caml_call2(Stdlib_Buffer[16], buf, _cH_);
     }
     else{
      var
       _cO_ = uri[5],
       _cP_ = encoded_of_path(scheme, pct_encoder$0[4])(_cO_);
      caml_call2(Stdlib_Buffer[16], buf, _cP_);
     }
    }
    var _cI_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cI_[0]){
       var _cJ_ = _cI_[1];
       if(_cJ_){var q = _cJ_; break b;}
      }
      else if(_cI_[1]){
       var _cL_ = _cI_[2], _cM_ = caml_obj_tag(_cL_);
       c:
       if(250 === _cM_)
        var _cN_ = _cL_[1];
       else{
        if(246 !== _cM_ && 244 !== _cM_){var _cN_ = _cL_; break c;}
        var _cN_ = caml_call1(CamlinternalLazy[2], _cL_);
       }
       var q = _cN_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cK_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cK_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _cx_ = uri[3];
    if(! _cx_) return 0;
    var match = _cx_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    if(opt)
     var sth = opt[1], default$0 = sth;
    else
     var default$0 = cst_localhost;
    var match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      _cw_ = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var _cw_ = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, _cw_];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _cv_ = uri[2];
    if(! _cv_) return 0;
    var user = _cv_[1][1];
    return [0, user];
   }
   function password(uri){
    var _cu_ = uri[2];
    if(_cu_){
     var match = _cu_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _ct_ = uri[2];
    if(! _ct_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _ct_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match)
     var
      s = match[1],
      _cq_ = uri[5],
      _cr_ = encoded_of_path([0, s], pct_encoder$0[4])(_cq_);
    else
     var _cs_ = uri[5], _cr_ = encoded_of_path(0, pct_encoder$0[4])(_cs_);
    return _cr_;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && caml_string_notequal(path$0[1], cst$33))
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _co_ = [0, caml_call2(Stdlib_List[46], k, q)]; return _co_;}
    catch(_cp_){
     var _cn_ = caml_wrap_exception(_cp_);
     if(_cn_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_cn_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[6], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    function _cm_(param){
     var v = param[2], k = param[1];
     return [0, k, [0, v, 0]];
    }
    return caml_call2(Stdlib_List[19], _cm_, q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _ck_ = uri[7], _cl_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cl_, _ck_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _ci_ = uri[7],
     _cj_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cj_, _ci_];
   }
   function add_query_params(uri, ps){
    var
     _cf_ = uri[7],
     _cg_ = kv(uri[6]),
     _ch_ = [0, caml_call2(Stdlib[37], ps, _cg_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ch_, _cf_];
   }
   function add_query_params$0(uri, ps){
    var
     _cb_ = uri[7],
     _cc_ = kv(uri[6]),
     _cd_ = q_s(ps),
     _ce_ = [0, caml_call2(Stdlib[37], _cd_, _cc_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ce_, _cb_];
   }
   function remove_query_param(uri, k){
    var _b9_ = uri[7], _b__ = kv(uri[6]);
    function _b$_(param){
     var k$0 = param[1];
     return caml_string_notequal(k, k$0);
    }
    var _ca_ = [0, caml_call2(Stdlib_List[41], _b$_, _b__)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ca_, _b9_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(caml_string_notequal(p, cst$34)){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _b7_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _b7_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _b8_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _b8_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bQ_ = uri[7],
       _bR_ = uri[6],
       _bS_ = remove_dot_segments(uri[5]),
       _bT_ = [0, uri[1], uri[2], uri[3], uri[4], _bS_, _bR_, _bQ_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(caml_string_equal(path_str, cst$34))
        var
         _bX_ = init[7],
         _bY_ = init[6][1] ? init[6] : base[6],
         _bZ_ = [0, init[1], init[2], init[3], init[4], base[5], _bY_, _bX_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _b0_ = init[7],
         _b1_ = init[6],
         _b2_ = remove_dot_segments(init[5]),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b2_, _b1_, _b0_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _b3_ = init[7],
         _b4_ = init[6],
         match = caml_call1(Stdlib_List[9], bpath);
        b:
        {
         if(bhost && ! match){var _b5_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(caml_string_notequal(match[1], cst$33)){
           var _bP_ = match[2];
           if(! _bP_) break c;
           if(caml_string_notequal(_bP_[1], cst$33)) break c;
           var rbpath = _bP_[2];
          }
          else
           var rbpath = match[2];
          var _b5_ = caml_call2(Stdlib_List[12], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _b5_ = relpath;
        }
        var
         _b6_ = remove_dot_segments(_b5_),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b6_, _b4_, _b3_];
       }
       var _bT_ = _bZ_;
       break a;
      }
      var
       _bU_ = uri[7],
       _bV_ = uri[6],
       _bW_ = remove_dot_segments(uri[5]),
       _bT_ = [0, base[1], uri[2], uri[3], uri[4], _bW_, _bV_, _bU_];
     }
    }
    return normalize(schem$0, _bT_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bL_ = uri$0[7],
     _bM_ = uri$0[6],
     _bN_ = Scheme[4].call(null, uri$0[5]),
     _bO_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bO_, _bN_, _bM_, _bL_];
   }
   function pp(ppf, uri){
    var _bK_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bK_);
   }
   function pp_hum(ppf, uri){
    var _bJ_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bJ_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bI_ = caml_call2(Stdlib_List[19], string_of_char, chars);
    return caml_call2(Stdlib_String[6], cst$20, _bI_);
   }
   var _l_ = caml_call1(Angstrom[51], 0), _m_ = caml_call1(Angstrom[4], 58);
   function _n_(c){
    var _bE_ = 58 !== c ? 1 : 0;
    if(_bE_){
     var _bF_ = 47 !== c ? 1 : 0;
     if(_bF_)
      var _bG_ = 63 !== c ? 1 : 0, _bH_ = _bG_ ? 35 !== c ? 1 : 0 : _bG_;
     else
      var _bH_ = _bF_;
    }
    else
     var _bH_ = _bE_;
    return _bH_;
   }
   var
    _o_ = caml_call1(Angstrom[13], _n_),
    _p_ = caml_call2(Angstrom[59], _o_, _m_);
   function _q_(s){return [0, decode(s)];}
   var
    _r_ = caml_call2(Angstrom[60], _q_, _p_),
    scheme$0 = caml_call2(Angstrom[47], _r_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function _s_(param){
    var _bD_ = param - 48 | 0;
    a:
    {
     if(22 < _bD_ >>> 0){
      if(5 < _bD_ - 49 >>> 0) break a;
     }
     else if(6 >= _bD_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   var
    hex_digit = caml_call1(Angstrom[7], _s_),
    _t_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _t_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58);
   function _u_(num){
    return 256 <= caml_int_of_string(num)
            ? caml_call1(Angstrom[52], cst_invalid_octect)
            : caml_call1(Angstrom[51], num);
   }
   function _v_(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    _w_ = caml_call1(Angstrom[14], _v_),
    dec_octet = caml_call2(Angstrom[53], _w_, _u_),
    _x_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _y_ = caml_call2(Angstrom[37], 3, _x_);
   function _z_(three, one){
    var
     _bB_ = caml_call2(Stdlib[28], cst$21, one),
     _bC_ = caml_call2(Stdlib_String[6], cst$22, three);
    return caml_call2(Stdlib[28], _bC_, _bB_);
   }
   var ipv4_address = caml_call3(Angstrom[61], _z_, _y_, dec_octet);
   function _A_(f){
    var
     _bv_ = caml_call1(Angstrom[51], 0),
     _bw_ = caml_call2(Angstrom[58], c_colon, f),
     _bx_ = caml_call2(Angstrom[47], _bw_, _bv_);
    function _by_(x, y){return [0, x, y];}
    var
     _bz_ = caml_call3(Angstrom[61], _by_, hexadecimal, _bx_),
     _bA_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _bA_, _bz_);
   }
   var after_double_colon = caml_call1(Angstrom[45], _A_);
   function double_colon(count){
    var _bs_ = caml_call1(Angstrom[51], _B_);
    function _bt_(rest){
     var
      filler_length = (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
     return 0 < filler_length
             ? caml_call1(Angstrom[51], [0, cst$23, rest])
             : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
    }
    var _bu_ = caml_call2(Angstrom[53], after_double_colon, _bt_);
    return caml_call2(Angstrom[47], _bu_, _bs_);
   }
   function part(n){
    if(6 === n){
     var
      _bp_ = hex_part(6),
      _bq_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
     return caml_call2(Angstrom[47], _bq_, _bp_);
    }
    if(7 !== n) return hex_part(n);
    function _br_(x){return [0, x, 0];}
    return caml_call2(Angstrom[60], _br_, hexadecimal);
   }
   function hex_part(n){
    var
     _bj_ = part(n + 1 | 0),
     _bk_ = double_colon(n + 1 | 0),
     _bl_ = caml_call2(Angstrom[58], c_colon, _bk_),
     _bm_ = caml_call2(Angstrom[47], _bl_, _bj_),
     _bn_ = caml_call2(Angstrom[58], c_colon, _bm_);
    function _bo_(x, y){return [0, x, y];}
    return caml_call3(Angstrom[61], _bo_, hexadecimal, _bn_);
   }
   function split_with(f, xs){
    if(! xs) return _C_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return caml_string_notequal(segment, cst$34);},
         segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[6], cst$24, before_double_colon);
    a:
    {
     if
      (after_double_colon
       && ! caml_string_notequal(after_double_colon[1], cst$34)){
      var
       xs = after_double_colon[2],
       _bh_ = caml_call2(Stdlib_String[6], cst$25, xs),
       _bi_ = caml_call2(Stdlib[28], cst$26, _bh_),
       res = caml_call2(Stdlib[28], before, _bi_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _D_ = part(0),
    _E_ = double_colon(0),
    _F_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _G_ = caml_call2(Angstrom[58], _F_, _E_),
    _H_ = caml_call2(Angstrom[47], _G_, _D_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _H_),
    _I_ = caml_call1(Angstrom[4], 93),
    _J_ = caml_call1(Angstrom[4], 91),
    _K_ = caml_call2(Angstrom[58], _J_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _K_, _I_),
    _L_ = caml_call2(Angstrom[37], 2, hex_digit),
    _M_ = caml_call1(Angstrom[4], 37);
   function _N_(pct, digits){return string_of_char_list([0, pct, digits]);}
   var pct_encoded = caml_call3(Angstrom[61], _N_, _M_, _L_);
   function _O_(param){
    var _bf_ = param - 59 | 0;
    a:
    {
     if(2 < _bf_ >>> 0){
      var _bg_ = _bf_ + 26 | 0;
      if(11 < _bg_ >>> 0) break a;
      switch(_bg_){case 1:case 2:case 4: break a;
      }
     }
     else if(1 === _bf_) break a;
     return 1;
    }
    return 0;
   }
   var sub_delims$0 = caml_call1(Angstrom[7], _O_);
   function _P_(param){
    a:
    {
     if(91 <= param){
      var _bd_ = param - 95 | 0;
      if(27 < _bd_ >>> 0){
       if(31 !== _bd_) break a;
      }
      else if(1 === _bd_) break a;
     }
     else{
      var _be_ = param - 45 | 0;
      if(12 < _be_ >>> 0){if(20 > _be_) break a;} else if(2 === _be_) break a;
     }
     return 1;
    }
    return 0;
   }
   var
    unreserved = caml_call1(Angstrom[7], _P_),
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call1(Stdlib_String[6], cst$27),
    reg_name = caml_call2(Angstrom[60], _U_, _T_),
    _V_ = 0;
   function _W_(s){return [0, 803994504, decode(s)];}
   var _X_ = [0, caml_call2(Angstrom[55], reg_name, _W_), _V_];
   function _Y_(h){return [0, 267950263, h];}
   var _Z_ = [0, caml_call2(Angstrom[55], ipv6_address, _Y_), _X_];
   function ___(h){return [0, -367671627, h];}
   var
    _$_ = [0, caml_call2(Angstrom[55], ipv4_address, ___), _Z_],
    host$0 = caml_call2(Angstrom[48], 0, _$_),
    _aa_ = caml_call1(Angstrom[51], 0),
    _ab_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _ac_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _ab_]],
    _ad_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _ac_],
    _ae_ = caml_call2(Angstrom[48], 0, _ad_),
    _af_ = caml_call1(Angstrom[38], _ae_),
    _ag_ = caml_call2(Angstrom[59], _af_, c_at);
   function _ah_(x){
    var s = caml_call2(Stdlib_String[6], cst$28, x);
    return [0, userinfo_of_encoded(s)];
   }
   var
    _ai_ = caml_call2(Angstrom[60], _ah_, _ag_),
    userinfo$0 = caml_call2(Angstrom[47], _ai_, _aa_);
   function _aj_(param){
    if(param && 58 === param[1]){
     var
      _a__ =
        function(port){
         var decoded = decode(port);
         try{var _bb_ = [0, caml_int_of_string(decoded)]; return _bb_;}
         catch(_bc_){return 0;}
        },
      _a$_ = caml_call1(Angstrom[13], is_digit),
      _ba_ = caml_call2(Angstrom[58], c_colon, _a$_);
     return caml_call2(Angstrom[55], _ba_, _a__);
    }
    return caml_call1(Angstrom[51], 0);
   }
   var
    port$0 = caml_call2(Angstrom[53], Angstrom[1], _aj_),
    _al_ = caml_call1(Angstrom[51], _ak_);
   function _am_(userinfo, host, port){return [0, userinfo, [0, host], port];}
   var
    _an_ = caml_call4(Angstrom[62], _am_, userinfo$0, host$0, port$0),
    _ao_ = caml_call1(Angstrom[8], cst$29),
    _ap_ = caml_call2(Angstrom[58], _ao_, _an_),
    authority = caml_call2(Angstrom[47], _ap_, _al_);
   function _aq_(param){if(35 !== param && 63 !== param) return 1; return 0;}
   var
    _ar_ = caml_call1(Angstrom[13], _aq_),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _ar_),
    _as_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _at_ = caml_call1(Angstrom[51], _as_);
   function _au_(param){return 35 === param ? 1 : 0;}
   var
    _av_ = caml_call1(Angstrom[15], _au_),
    _aw_ = caml_call1(Angstrom[4], 63),
    _ax_ = caml_call2(Angstrom[58], _aw_, _av_),
    _ay_ = caml_call2(Angstrom[60], of_raw, _ax_),
    query$0 = caml_call2(Angstrom[47], _ay_, _at_),
    _az_ = caml_call1(Angstrom[51], 0);
   function _aA_(param){return 1;}
   var
    _aB_ = caml_call1(Angstrom[13], _aA_),
    _aC_ = caml_call1(Angstrom[4], 35),
    _aD_ = caml_call2(Angstrom[58], _aC_, _aB_);
   function _aE_(s){return [0, decode(s)];}
   var
    _aF_ = caml_call2(Angstrom[60], _aE_, _aD_),
    fragment$0 = caml_call2(Angstrom[47], _aF_, _az_);
   function _aG_(scheme, param, path, query, fragment){
    var port = param[3], host = param[2], userinfo = param[1];
    return normalize
            (scheme, [0, scheme, userinfo, host, port, path, query, fragment]);
   }
   var
    _aH_ =
      caml_call5(Angstrom[63], _aG_, scheme$0, authority, path$0, query$0),
    uri_reference = caml_call2(Angstrom[56], _aH_, fragment$0);
   function _aI_(s){
    var match = caml_call3(Angstrom[75], 1, uri_reference, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   function _aJ_(param){return 10 === param ? 0 : 1;}
   var
    _aK_ = caml_call1(Angstrom[13], _aJ_),
    uri_reference$0 = caml_call2(Angstrom[55], _aK_, _aI_);
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _aM_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && caml_string_notequal(path$0[1], cst$33)){var _a7_ = [0, cst$30, path$0]; break a;}
      var _a7_ = path$0;
     }
     var path$1 = _a7_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aL_;
    var scheme$0 = decode(scheme), _a8_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _a9_ = [0, decode_host(host$1)];
    else
     var _a9_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _a9_, port, path$1, query$0, _a8_]);
   }
   function with_host(init, host){
    var _a2_ = init[7], _a3_ = init[6], _a4_ = init[5], _a5_ = init[4];
    if(host)
     var host$0 = host[1], _a6_ = [0, decode_host(host$0)];
    else
     var _a6_ = 0;
    return [0, init[1], init[2], _a6_, _a5_, _a4_, _a3_, _a2_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with_path_opt(u, o){
     if(! o) return with_path(u, cst$31);
     var p = o[1];
     return with_path(u, p);
    }
    function with_query_opt(u, o){
     if(! o) return with_query(u, 0);
     var q = o[1];
     return with_query(u, q);
    }
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    return with$0
            (with_fragment,
             fragment,
             with$0
              (with_query_opt,
               query,
               with$0
                (with_path_opt,
                 path,
                 with$0
                  (with_port,
                   port,
                   with$0
                    (with_host,
                     host,
                     with$0
                      (with_userinfo, userinfo, with$0(with_scheme, scheme, uri)))))));
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? cst_http : cst_https;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aY_(scheme){
     function _a1_(host){
      return [0, [0, scheme, userinfo, host, port, path, query, fragment]];
     }
     return caml_call2(let$0, caml_call2(Stdlib_Option[14], _aN_, host), _a1_);
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aZ_ =
        caml_string_notequal(unsupported_scheme, cst_http$0)
         ? caml_string_notequal
            (unsupported_scheme, cst_https$0)
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aO_, unsupported_scheme)]]
           : _aP_
         : _aQ_,
      _a0_ = _aZ_;
    else
     var _a0_ = _aR_;
    return caml_call2(let$0, _a0_, _aY_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && caml_string_notequal(path$0[1], cst$33)){var _aW_ = [0, cst$32, path$0]; break a;}
      var _aW_ = path$0;
     }
     var path$1 = _aW_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aS_;
    if(fragment) var x = fragment[1], _aX_ = [0, x]; else var _aX_ = 0;
    var match = decode_host(host$2), _aU_ = match[1];
    if(267950263 === _aU_)
     var
      host = match[2],
      _aV_ = [0, 267950263, caml_call1(Stdlib_String[26], host)];
    else if(803994504 <= _aU_)
     var
      host$0 = match[2],
      _aV_ = [0, 803994504, caml_call1(Stdlib_String[26], host$0)];
    else
     var
      host$1 = match[2],
      _aV_ = [0, -367671627, caml_call1(Stdlib_String[26], host$1)];
    return [0, scheme, userinfo$0, _aV_, port, path$1, query$0, _aX_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImNzdCQwIiwiaXRlcl9jb25jYXQiLCJmbiIsInNlcCIsImJ1ZiIsImxhc3QiLCJyZXN0IiwiY29tcGFyZV9vcHQiLCJjIiwidCQwIiwidCIsImEiLCJiIiwiY29tcGFyZV9saXN0IiwiZiIsInQkMiIsInQkMSIsInhzIiwieCIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJpIiwic2FmZV9jaGFycyIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJzYWZlX2NoYXJzJDAiLCJpJDAiLCJjJDAiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQwIiwibm9ybWFsaXplX2hvc3QkMCIsImhzIiwiY2Fub25pY2FsaXplX3BvcnQkMCIsImNhbm9uaWNhbGl6ZV9wYXRoJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJzdGgkMCIsInVzZXJpbmZvIiwic3RoJDEiLCJob3N0Iiwic3RoJDIiLCJzdGgkMyIsInF1ZXJ5X2tleSIsInN0aCQ0IiwicXVlcnlfdmFsdWUiLCJzdGgkNSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInAkMCIsInUkMCIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIkMyIsInIkMSIsInIkMCIsInIkMiIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsInMkMCIsImVsIiwiayIsInRsIiwidiIsImwiLCJsJDAiLCJuIiwidGwkMCIsIm4kMCIsInRsJDEiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9kZWNvZGVkX29wdCIsImNvbXBhcmVfaG9zdCIsImgxIiwiaDIiLCJpcDIiLCJpcDEiLCJpcDIkMCIsImlwMSQwIiwiaDIkMCIsImgxJDAiLCJjb21wYXJlJDAiLCJjJDMiLCJjJDEiLCJjJDQiLCJrdmwkMCIsImt2bCIsInJhdyIsInJhdyQwIiwiYyQyIiwidmwiLCJ2bCQwIiwiayQwIiwiZXF1YWwiLCJ1bmNhc3Rfb3B0Iiwibm9ybWFsaXplIiwic2NoZW0iLCJpbml0IiwiaG9zdCQwIiwiaG9zdCQxIiwidG9fc3RyaW5nIiwidXJpIiwiYWRkX3BjdF9zdHJpbmciLCJmaXJzdF9zZWdtZW50IiwicSIsImdldF9kZWNvZGVkX29wdCIsIndpdGhfc2NoZW1lIiwiaCQwIiwiaG9zdF93aXRoX2RlZmF1bHQiLCJkZWZhdWx0JDAiLCJ3aXRoX3VzZXJpbmZvIiwidXNlcmluZm8kMCIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ3aXRoX3Bhc3N3b3JkIiwicmVzdWx0Iiwid2l0aF9wb3J0Iiwid2l0aF9wYXRoIiwicGF0aCQwIiwid2l0aF9mcmFnbWVudCIsImZyYWciLCJxdWVyeSIsInZlcmJhdGltX3F1ZXJ5IiwiZ2V0X3F1ZXJ5X3BhcmFtIiwiZ2V0X3F1ZXJ5X3BhcmFtJDAiLCJ3aXRoX3F1ZXJ5IiwicV9zIiwid2l0aF9xdWVyeSQwIiwiYWRkX3F1ZXJ5X3BhcmFtIiwiYWRkX3F1ZXJ5X3BhcmFtJDAiLCJhZGRfcXVlcnlfcGFyYW1zIiwiYWRkX3F1ZXJ5X3BhcmFtcyQwIiwicmVtb3ZlX3F1ZXJ5X3BhcmFtIiwicGF0aF9hbmRfcXVlcnkiLCJtYXRjaCIsInNjaGVtZSQwIiwicmVzb2x2ZSIsImJhc2UiLCJzY2hlbWUkMSIsInNjaGVtJDAiLCJwYXRoX3N0ciIsInJlbHBhdGgiLCJicGF0aCIsImJob3N0IiwicmJwYXRoIiwiY2Fub25pY2FsaXplIiwidXJpJDAiLCJwcCIsInBwZiIsInBwX2h1bSIsInN0cmluZ19vZl9jaGFyIiwic3RyaW5nX29mX2NoYXJfbGlzdCIsImNoYXJzIiwiaXNfZGlnaXQiLCJoZXhfZGlnaXQiLCJoZXhhZGVjaW1hbCIsImNfZG90IiwiY19hdCIsImNfY29sb24iLCJudW0iLCJkZWNfb2N0ZXQiLCJ0aHJlZSIsIm9uZSIsImlwdjRfYWRkcmVzcyIsImFmdGVyX2RvdWJsZV9jb2xvbiIsImRvdWJsZV9jb2xvbiIsImNvdW50IiwiZmlsbGVyX2xlbmd0aCIsInBhcnQiLCJoZXhfcGFydCIsInNwbGl0X3dpdGgiLCJ0cyIsInpzIiwiZm9ybWF0X2FkZHIiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJiZWZvcmVfZG91YmxlX2NvbG9uIiwiYmVmb3JlIiwicmVzIiwiaXB2NiIsImlwdjZfYWRkcmVzcyIsInBjdCIsImRpZ2l0cyIsInBjdF9lbmNvZGVkIiwic3ViX2RlbGltcyQwIiwidW5yZXNlcnZlZCIsInJlZ19uYW1lIiwiZGVjb2RlZCIsInBvcnQkMCIsImF1dGhvcml0eSIsInF1ZXJ5JDAiLCJmcmFnbWVudCQwIiwidXJpX3JlZmVyZW5jZSIsInVyaV9yZWZlcmVuY2UkMCIsImRlY29kZV9ob3N0IiwicGFyc2VkIiwicGFyc2VkJDAiLCJtYWtlIiwicGF0aCQxIiwid2l0aF9ob3N0Iiwid2l0aF91cmkiLCJ3aXRoX3BhdGhfb3B0IiwibyIsIndpdGhfcXVlcnlfb3B0Iiwid2l0aCQwIiwib2Zfc3RyaW5nIiwibGV0JDAiLCJ0b191cmkiLCJvZl91cmkiLCJ1bnN1cHBvcnRlZF9zY2hlbWUiLCJvZl9zdHJpbmckMCIsImVycm9yIiwidG9fc3RyaW5nJDAiLCJtYWtlJDAiLCJob3N0JDIiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL3VyaS91cmkubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0RrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBUlZDLFlBQVlDLElBQUdDLEtBQUlDOzs7bUJBTWpCO1NBTE5DO3NCQUFZLE9BQUEsV0FESUgsSUFBT0UsS0FDdkJDO1NBQ0lDO0tBQ0osV0FIZ0JKLElBQU9FLEtBQ3ZCQztLQUdB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O1NBQUFBO0lBT0osR0FaNEM3RSxXQWNuQ2xHLE1BZG1Da0csVUFZeENxRSxjQUVLdkssZUFGTHVLO09BWitDNUssY0FFM0N6RSxJQUYyQ3lFLHdCQUUzQ3pFO0lBaUJFLElBQUEsUUF2S1Z5UCxZQW9KZ0JvQjs7O01BTkkzTTs0QkFDQSw4QkFEQUE7OztNQUVSc0Y7NEJBQ2tCLDhCQURsQkE7OztNQUpRQzs2QkFDQSw4QkFEQUE7SUFGcEIsV0FVUTFHLFFBR0pzSCxrQkFINEI5SSxNQUs1QnNPLFFBT0FSO0dBT3FFO1lBRXZFNUYsT0FBS2pLO0lBQ1AsWUFET0E7a0NBR0V5RyxjQUFNLE9BQU5BO1FBRFFnRTtJQUF3QixPQUF4QkE7R0FDb0I7WUFFbkNnQyxTQUFPek0sR0FBSSxPQUFKQSxLQUFZOzs7O09BenJCckJtSTtPQW9CQVk7T0FpQkFZO09BMU9BdEY7T0FHQUM7T0FZQVk7T0F5d0JBMEw7T0FuaEJBMUc7T0E2TEFxQztPQThCQVM7T0E0UEFvRDtPQW9DQUc7T0F0V0EvRTtPQUNBQztPQXJPQXZEO09BREFwQjtPQWlQQThFO09BRUFFO09BUkFKO09BQ0FDO09BUUFJO09BQ0FDO09BRUFDO09BQ0FDO09BRUFDO09BcENBbEs7T0F5Q0FtSztPQXRDQWhCO09BOURBN0g7T0FDQWlIO09BZ0JBaEc7T0FLQW9HO09BU0FFO09BSUFDO09BR0FFO09BaENBdkc7T0FtYUE0TDtPQTdaQTVGO09Bb0NBM0k7T0FDQW9KO09BbUJBbEc7T0FDQXFHO09Bb0ZBNEI7T0FDQUU7V0F5RkU4QixNQW9JQWM7V0F5SEFlLFFBZkFELFFBa0NBRyxhQUlBRSxhQWFBQyxRQXFCQW5ILFFBS0F3Qzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IERhdmlkIFNoZWV0cyA8c2hlZXRzQGFsdW0ubWl0LmVkdT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuXG50eXBlIGNvbXBvbmVudCA9IFtcbiAgfCBgU2NoZW1lXG4gIHwgYEF1dGhvcml0eVxuICB8IGBVc2VyaW5mbyAoKiBzdWJjb21wb25lbnQgb2YgYXV0aG9yaXR5IGluIHNvbWUgc2NoZW1lcyAqKVxuICB8IGBIb3N0ICgqIHN1YmNvbXBvbmVudCBvZiBhdXRob3JpdHkgaW4gc29tZSBzY2hlbWVzICopXG4gIHwgYFBhdGhcbiAgfCBgUXVlcnlcbiAgfCBgUXVlcnlfa2V5XG4gIHwgYFF1ZXJ5X3ZhbHVlXG4gIHwgYEZyYWdtZW50XG4gIHwgYEdlbmVyaWNcbiAgfCBgQ3VzdG9tIG9mIChjb21wb25lbnQgKiBzdHJpbmcgKiBzdHJpbmcpICgqIChjb21wb25lbnQgKiBzYWZlIGNoYXJzICogdW5zYWZlIGNoYXJzKSAqKVxuXVxuXG50eXBlIHBjdF9lbmNvZGVyID0ge1xuICAgIHNjaGVtZTogY29tcG9uZW50O1xuICAgIHVzZXJpbmZvOiBjb21wb25lbnQ7XG4gICAgaG9zdDogY29tcG9uZW50O1xuICAgIHBhdGg6IGNvbXBvbmVudDtcbiAgICBxdWVyeV9rZXk6IGNvbXBvbmVudDtcbiAgICBxdWVyeV92YWx1ZTogY29tcG9uZW50O1xuICAgIGZyYWdtZW50OiBjb21wb25lbnQ7XG4gIH1cblxubGV0IHJlYyBpdGVyX2NvbmNhdCBmbiBzZXAgYnVmID0gZnVuY3Rpb25cbiAgfCBsYXN0OjpbXSAtPiBmbiBidWYgbGFzdFxuICB8IGVsOjpyZXN0IC0+XG4gICAgZm4gYnVmIGVsO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzZXA7XG4gICAgaXRlcl9jb25jYXQgZm4gc2VwIGJ1ZiByZXN0XG4gIHwgW10gLT4gKClcblxubGV0IHJldl9pbnRlcmplY3QgZSBsc3QgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gIC0+IGFjY1xuICAgIHwgeDo6eHMgLT4gYXV4ICh4OjplOjphY2MpIHhzXG4gIGluIG1hdGNoIGxzdCB3aXRoXG4gIHwgW10gIC0+IFtdXG4gIHwgaDo6dCAtPiBhdXggW2hdIHRcblxubGV0IGNvbXBhcmVfb3B0IGMgdCB0JyA9IG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCAgIE5vbmUgICAtPiAwXG4gIHwgU29tZSBfLCBOb25lICAgLT4gMVxuICB8IE5vbmUsICAgU29tZSBfIC0+IC0xXG4gIHwgU29tZSBhLCBTb21lIGIgLT4gYyBhIGJcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgZiB0IHQnID0gbWF0Y2ggdCwgdCcgd2l0aFxuICB8IFtdLCAgICBbXSAgICAtPiAgMFxuICB8IF86Ol8sICBbXSAgICAtPiAgMVxuICB8IFtdLCAgICBfOjpfICAtPiAtMVxuICB8IHg6OnhzLCB5Ojp5cyAtPlxuICAgIG1hdGNoIGYgeCB5IHdpdGggMCAtPiBjb21wYXJlX2xpc3QgZiB4cyB5cyB8IGMgLT4gY1xuXG4oKiogU2FmZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBhbGxvd2VkIGluIGEgVVJJXG4gICogVW5mb3J0dW5hdGVseSwgdGhpcyB2YXJpZXMgZGVwZW5kaW5nIG9uIHdoaWNoIGJpdCBvZiB0aGUgVVJJXG4gICogaXMgYmVpbmcgcGFyc2VkLCBzbyB0aGVyZSBhcmUgbXVsdGlwbGUgdmFyaWFudHMgKGFuZCB0aGlzXG4gICogc2V0IGlzIHByb2JhYmx5IG5vdCBleGhhdXN0aXZlLiBUT0RPOiBjaGVjay5cbiopXG50eXBlIHNhZmVfY2hhcnMgPSBib29sIGFycmF5XG5cbm1vZHVsZSB0eXBlIFNjaGVtZSA9IHNpZ1xuICB2YWwgc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IDogY29tcG9uZW50IC0+IHNhZmVfY2hhcnNcbiAgdmFsIG5vcm1hbGl6ZV9ob3N0IDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgY2Fub25pY2FsaXplX3BvcnQgOiBpbnQgb3B0aW9uIC0+IGludCBvcHRpb25cbiAgdmFsIGNhbm9uaWNhbGl6ZV9wYXRoIDogc3RyaW5nIGxpc3QgLT4gc3RyaW5nIGxpc3RcbmVuZFxuXG5tb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSA9IHN0cnVjdFxuICBsZXQgc3ViX2RlbGltcyBhID1cbiAgICBsZXQgc3ViZCA9IFwiISQmJygpKissOz1cIiBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN1YmQgLSAxIGRvXG4gICAgICBsZXQgYyA9IENoYXIuY29kZSBzdWJkLltpXSBpblxuICAgICAgYS4oYykgPC0gdHJ1ZVxuICAgIGRvbmU7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5tYWtlIDI1NiBmYWxzZSBpblxuICAgIGxldCBhbHdheXNfc2FmZSA9XG4gICAgICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy4tflwiIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggYWx3YXlzX3NhZmUgLSAxIGRvXG4gICAgICBsZXQgYyA9IENoYXIuY29kZSBhbHdheXNfc2FmZS5baV0gaW5cbiAgICAgIGEuKGMpIDwtIHRydWVcbiAgICBkb25lO1xuICAgIGFcblxuICBsZXQgcGNoYXIgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IHN1Yl9kZWxpbXMgKEFycmF5LmNvcHkgc2FmZV9jaGFycykgaW5cbiAgICBhLihDaGFyLmNvZGUgJzonKSA8LSB0cnVlO1xuICAgIGEuKENoYXIuY29kZSAnQCcpIDwtIHRydWU7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9zY2hlbWUgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFycyBpblxuICAgIGEuKENoYXIuY29kZSAnKycpIDwtIHRydWU7XG4gICAgYVxuXG4gICgqKiBTYWZlIGNoYXJhY3RlcnMgZm9yIHRoZSBwYXRoIGNvbXBvbmVudCBvZiBhIFVSSSAqKVxuICBsZXQgc2FmZV9jaGFyc19mb3JfcGF0aCA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gc3ViX2RlbGltcyAoQXJyYXkuY29weSBwY2hhcikgaW5cbiAgICAoKiBkZWxpbWl0ZXI6IG5vbi1zZWdtZW50IGRlbGltaXRpbmcgdXNlcyBzaG91bGQgYmUgcGN0IGVuY29kZWQgKilcbiAgICBhLihDaGFyLmNvZGUgJy8nKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IDogc2FmZV9jaGFycyA9XG4gICAgKCogVE9ETzogV2hhdCBhYm91dCB7XCIhXCIsXCIkXCIsXCIsXCJ9PyBTZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9hdnNtL29jYW1sLXVyaS9jb21taXQvMWVmM2YxZGZiNDFiZGI0ZjMzZjIyM2ZmZTE2ZTYyYTMzOTc1NjYxYSNkaWZmLTc0MGYyZGU1M2M5ZWIzNmU5NjcwZGRmYmRiOWJhOTE0UjE3MT4gKilcbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgcGNoYXIgaW5cbiAgICBhLihDaGFyLmNvZGUgJy8nKSA8LSB0cnVlO1xuICAgIGEuKENoYXIuY29kZSAnPycpIDwtIHRydWU7XG4gICAgKCogJyYnIGlzIHNhZmUgYnV0IHdlIHNob3VsZCBlbmNvZGUgbGl0ZXJhbHMgdG8gYXZvaWQgYW1iaWd1aXR5XG4gICAgICAgd2l0aCB0aGUgYWxyZWFkeSBwYXJzZWQgcXMgcGFyYW1zICopXG4gICAgYS4oQ2hhci5jb2RlICcmJykgPC0gZmFsc2U7XG4gICAgKCogJzsnIGlzIHNhZmUgYnV0IHNvbWUgc3lzdGVtcyB0cmVhdCBpdCBsaWtlICcmJy4gKilcbiAgICBhLihDaGFyLmNvZGUgJzsnKSA8LSBmYWxzZTtcbiAgICBhLihDaGFyLmNvZGUgJysnKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X2tleSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzX2Zvcl9xdWVyeSBpblxuICAgIGEuKENoYXIuY29kZSAnPScpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFyc19mb3JfcXVlcnkgaW5cbiAgICBhLihDaGFyLmNvZGUgJywnKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX2ZyYWdtZW50IDogc2FmZV9jaGFycyA9IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5XG5cbiAgKCoqIFNhZmUgY2hhcmFjdGVycyBmb3IgdGhlIHVzZXJpbmZvIHN1YmNvbXBvbmVudCBvZiBhIFVSSS5cbiAgICAgIFRPRE86IHRoaXMgbmVlZHMgbW9yZSByZXNlcnZlZCBjaGFyYWN0ZXJzIGFkZGVkICopXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzIGluXG4gICAgKCogZGVsaW1pdGVyOiBub24tc2VnbWVudCBkZWxpbWl0aW5nIHVzZXMgc2hvdWxkIGJlIHBjdCBlbmNvZGVkICopXG4gICAgYS4oQ2hhci5jb2RlICc6JykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCByZWMgc2FmZV9jaGFyc19mb3JfY29tcG9uZW50ID0gZnVuY3Rpb25cbiAgICB8IGBQYXRoIC0+IHNhZmVfY2hhcnNfZm9yX3BhdGhcbiAgICB8IGBVc2VyaW5mbyAtPiBzYWZlX2NoYXJzX2Zvcl91c2VyaW5mb1xuICAgIHwgYFF1ZXJ5IC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5XG4gICAgfCBgUXVlcnlfa2V5IC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X2tleVxuICAgIHwgYFF1ZXJ5X3ZhbHVlIC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X3ZhbHVlXG4gICAgfCBgRnJhZ21lbnQgLT4gc2FmZV9jaGFyc19mb3JfZnJhZ21lbnRcbiAgICB8IGBTY2hlbWUgLT4gc2FmZV9jaGFyc19mb3Jfc2NoZW1lXG4gICAgfCBgQ3VzdG9tICgoY29tcG9uZW50IDogY29tcG9uZW50KSwgc2FmZSwgdW5zYWZlKSAtPlxuICAgICAgIGxldCBzYWZlX2NoYXJzID0gQXJyYXkuY29weSAoc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IGNvbXBvbmVudCkgaW5cbiAgICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzYWZlIC0gMSBkb1xuICAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgc2FmZS5baV0gaW5cbiAgICAgICAgIHNhZmVfY2hhcnMuKGMpIDwtIHRydWVcbiAgICAgICBkb25lO1xuICAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHVuc2FmZSAtIDEgZG9cbiAgICAgICAgIGxldCBjID0gQ2hhci5jb2RlIHVuc2FmZS5baV0gaW5cbiAgICAgICAgIHNhZmVfY2hhcnMuKGMpIDwtIGZhbHNlXG4gICAgICAgZG9uZTtcbiAgICAgICBzYWZlX2NoYXJzXG4gICAgfCBgR2VuZXJpY1xuICAgIHwgXyAtPiBzYWZlX2NoYXJzXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzbyA9IGhzb1xuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCBwb3J0ID0gcG9ydFxuICBsZXQgY2Fub25pY2FsaXplX3BhdGggcGF0aCA9IHBhdGhcbmVuZFxuXG5tb2R1bGUgSHR0cCA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhzXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSA4MCAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSB4XG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wYXRoID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtcIi9cIl1cbiAgICB8IHggIC0+IHhcbmVuZFxuXG5tb2R1bGUgSHR0cHMgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIdHRwXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSA0NDMgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgeFxuZW5kXG5cbm1vZHVsZSBGaWxlIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBocyA9XG4gICAgbGV0IGhzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBocyBpblxuICAgIGlmIGhzPVwibG9jYWxob3N0XCIgdGhlbiBcIlwiIGVsc2UgaHNcbmVuZFxuXG5tb2R1bGUgVXJuIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG5lbmRcblxubGV0IG1vZHVsZV9vZl9zY2hlbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgcyAtPiBiZWdpbiBtYXRjaCBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgd2l0aFxuICAgICAgfCBcImh0dHBcIiAtPiAobW9kdWxlIEh0dHAgOiBTY2hlbWUpXG4gICAgICB8IFwiaHR0cHNcIiAgLT4gKG1vZHVsZSBIdHRwcyA6IFNjaGVtZSlcbiAgICAgIHwgXCJmaWxlXCIgLT4gKG1vZHVsZSBGaWxlIDogU2NoZW1lKVxuICAgICAgfCBcInVyblwiICAtPiAobW9kdWxlIFVybiA6IFNjaGVtZSlcbiAgICAgIHwgXyAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG4gICAgZW5kXG4gIHwgTm9uZSAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG5cbigqKiBQb3J0aW9ucyBvZiB0aGUgVVJMIG11c3QgYmUgY29udmVydGVkIHRvLWFuZC1mcm9tIHBlcmNlbnQtZW5jb2RpbmdcbiAgKiBhbmQgdGhpcyByZWFsbHksIHJlYWxseSBzaG91bGRuJ3QgYmUgbWl4ZWQgdXAuIFNvIHRoaXMgUGN0IG1vZHVsZVxuICAqIGRlZmluZXMgYWJzdHJhY3QgUGN0LmVuY29kZWQgYW5kIFBjdC5kZWNvZGVkIHR5cGVzIHdoaWNoIHNldHMgdGhlXG4gICogc3RhdGUgb2YgdGhlIHVuZGVybHlpbmcgc3RyaW5nLiAgVGhlcmUgYXJlIGZ1bmN0aW9ucyB0byBcImNhc3RcIiB0b1xuICAqIGFuZCBmcm9tIHRoZXNlIGFuZCBub3JtYWwgc3RyaW5ncywgYW5kIHRoaXMgcHJvbW90ZXMgYSBiaXQgb2ZcbiAgKiBpbnRlcm5hbCBzYWZldHkuICBUaGVzZSB0eXBlcyBhcmUgbm90IGV4cG9zZWQgdG8gdGhlIGV4dGVybmFsXG4gICogaW50ZXJmYWNlLCBhcyBjYXN0aW5nIHRvLWFuZC1mcm9tIGlzIHF1aXRlIGEgYml0IG9mIGhhc3NsZSBhbmRcbiAgKiBwcm9iYWJseSBub3QgYSBsb3Qgb2YgdXNlIHRvIHRoZSBhdmVyYWdlIGNvbnN1bWVyIG9mIHRoaXMgbGlicmFyeVxuKilcbm1vZHVsZSBQY3QgOiBzaWdcbiAgdHlwZSBlbmNvZGVkXG4gIHR5cGUgZGVjb2RlZFxuXG4gIHZhbCBlbmNvZGUgOiA/c2NoZW1lOnN0cmluZyAtPiA/Y29tcG9uZW50OmNvbXBvbmVudCAtPiBkZWNvZGVkIC0+IGVuY29kZWRcbiAgdmFsIGRlY29kZSA6IGVuY29kZWQgLT4gZGVjb2RlZFxuXG4gICgqIFRoZSBlbXB0eSBkZWNvZGVkIHN0cmluZyAqKVxuICB2YWwgZW1wdHlfZGVjb2RlZCA6IGRlY29kZWRcbiAgKCogSWRlbnRpdHkgZnVuY3Rpb25zIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSBjYXN0IHdoZW4gdXNpbmcgdGhlbSBiZWxvdyAqKVxuICB2YWwgY2FzdF9lbmNvZGVkIDogc3RyaW5nIC0+IGVuY29kZWRcbiAgdmFsIGNhc3RfZGVjb2RlZCA6IHN0cmluZyAtPiBkZWNvZGVkXG4gIHZhbCB1bmNhc3RfZW5jb2RlZCA6IGVuY29kZWQgLT4gc3RyaW5nXG4gIHZhbCB1bmNhc3RfZGVjb2RlZCA6IGRlY29kZWQgLT4gc3RyaW5nXG4gICgqIExpZnQgSE9GcyBmb3IgbWFwcyBvdmVyIGVuY29kaW5ncywgZGVjb2RpbmdzLCBhbmQgc3RyaW5ncyAqKVxuICB2YWwgbGlmdF9lbmNvZGVkIDogKGVuY29kZWQgLT4gZW5jb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgbGlmdF9kZWNvZGVkIDogKGRlY29kZWQgLT4gZGVjb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgdW5saWZ0X2VuY29kZWQgOiAoc3RyaW5nIC0+IHN0cmluZykgLT4gZW5jb2RlZCAtPiBlbmNvZGVkXG4gIHZhbCB1bmxpZnRfZGVjb2RlZCA6IChzdHJpbmcgLT4gc3RyaW5nKSAtPiBkZWNvZGVkIC0+IGRlY29kZWRcbiAgdmFsIHVubGlmdF9kZWNvZGVkMiA6IChzdHJpbmcgLT4gc3RyaW5nIC0+ICdhKSAtPiBkZWNvZGVkIC0+IGRlY29kZWQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlIGVuY29kZWQgPSBzdHJpbmdcbiAgdHlwZSBkZWNvZGVkID0gc3RyaW5nXG4gIGxldCBjYXN0X2VuY29kZWQgeCA9IHhcbiAgbGV0IGNhc3RfZGVjb2RlZCB4ID0geFxuICBsZXQgZW1wdHlfZGVjb2RlZCA9IFwiXCJcbiAgbGV0IHVuY2FzdF9kZWNvZGVkIHggPSB4XG4gIGxldCB1bmNhc3RfZW5jb2RlZCB4ID0geFxuXG4gIGxldCBsaWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IGxpZnRfZGVjb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9kZWNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZGVjb2RlZDIgZiA9IGZcblxuICAoKiogU2NhbiBmb3IgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgcmVwbGFjZSB0aGVtIHdpdGhcbiAgICAgIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50cy5cbiAgICAgIEByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBlbmNvZGUgP3NjaGVtZSA/KGNvbXBvbmVudD1gUGF0aCkgYiA9XG4gICAgbGV0IG1vZHVsZSBTY2hlbWUgPSAodmFsIChtb2R1bGVfb2Zfc2NoZW1lIHNjaGVtZSkgOiBTY2hlbWUpIGluXG4gICAgbGV0IHNhZmVfY2hhcnMgPSBTY2hlbWUuc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IGNvbXBvbmVudCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBjID0gQ2hhci5jb2RlIGIuW2N1cl0gaW5cbiAgICAgICAgaWYgc2FmZV9jaGFycy4oYykgdGhlblxuICAgICAgICAgIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgaWYgY3VyID4gc3RhcnQgdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFByaW50Zi5zcHJpbnRmIFwiJSUlMDJYXCIgYyk7XG4gICAgICAgICAgc2NhbiAoY3VyKzEpIChjdXIrMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBpblxuICAgIHNjYW4gMCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgaW50X29mX2hleF9jaGFyIGMgPVxuICAgIGxldCBjID0gaW50X29mX2NoYXIgKENoYXIudXBwZXJjYXNlX2FzY2lpIGMpIC0gNDggaW5cbiAgICBpZiBjID4gOVxuICAgIHRoZW4gaWYgYyA+IDE2ICYmIGMgPCAyM1xuICAgICAgdGhlbiBjIC0gN1xuICAgICAgZWxzZSBmYWlsd2l0aCBcImludF9vZl9oZXhfY2hhclwiXG4gICAgZWxzZSBpZiBjID49IDBcbiAgICB0aGVuIGNcbiAgICBlbHNlIGZhaWx3aXRoIFwiaW50X29mX2hleF9jaGFyXCJcblxuICAoKiogU2NhbiBmb3IgcGVyY2VudC1lbmNvZGluZyBhbmQgY29udmVydCB0aGVtIGludG8gQVNDSUkuXG4gICAgICBAcmV0dXJuIGEgcGVyY2VudC1kZWNvZGVkIHN0cmluZyAqKVxuICBsZXQgZGVjb2RlIGIgPVxuICAgICgqIFRPRE86IFNob3VsZCBib3RoIHN0cmljdCBhbmQgbm9uLXN0cmljdCB2ZXJzaW9ucyBiZSBleHBvc2VkPyAqKVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KVxuICAgICAgZWxzZSBpZiBiLltjdXJdID0gJyUnIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICAgIGxldCBjdXIgPSBjdXIgKyAxIGluXG4gICAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICclJ1xuICAgICAgICBlbHNlIG1hdGNoIGludF9vZl9oZXhfY2hhciBiLltjdXJdIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgIHNjYW4gY3VyIGN1clxuICAgICAgICB8IGhpZ2hiaXRzIC0+IGJlZ2luXG4gICAgICAgICAgbGV0IGN1ciA9IGN1ciArIDEgaW5cbiAgICAgICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBiLltjdXItMV1cbiAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgbGV0IHN0YXJ0X2F0ID1cbiAgICAgICAgICAgICAgbWF0Y2ggaW50X29mX2hleF9jaGFyIGIuW2N1cl0gd2l0aFxuICAgICAgICAgICAgICB8IGxvd2JpdHMgLT5cbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIChDaGFyLmNociAoaGlnaGJpdHMgbHNsIDQgKyBsb3diaXRzKSk7XG4gICAgICAgICAgICAgICAgY3VyKzFcbiAgICAgICAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYi5bY3VyLTFdO1xuICAgICAgICAgICAgICAgIGN1clxuICAgICAgICAgICAgaW4gc2NhbiBzdGFydF9hdCBzdGFydF9hdFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgIGluXG4gICAgc2NhbiAwIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuZW5kXG5cbigqIFBlcmNlbnQgZW5jb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2VuY29kZSA/c2NoZW1lID8oY29tcG9uZW50PWBQYXRoKSBzID1cbiAgUGN0Lih1bmNhc3RfZW5jb2RlZCAoZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCAoY2FzdF9kZWNvZGVkIHMpKSlcblxubGV0IHBjdF9lbmNvZGVyXG4gICAgICA/KHNjaGVtZT1gU2NoZW1lKVxuICAgICAgPyh1c2VyaW5mbz1gVXNlcmluZm8pXG4gICAgICA/KGhvc3Q9YEhvc3QpXG4gICAgICA/KHBhdGg9YFBhdGgpXG4gICAgICA/KHF1ZXJ5X2tleT1gUXVlcnlfa2V5KVxuICAgICAgPyhxdWVyeV92YWx1ZT1gUXVlcnlfdmFsdWUpXG4gICAgICA/KGZyYWdtZW50PWBGcmFnbWVudClcbiAgICAgICgpID1cbiAgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwYXRoOyBxdWVyeV9rZXk7IHF1ZXJ5X3ZhbHVlOyBmcmFnbWVudCB9XG5cbigqIFBlcmNlbnQgZGVjb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2RlY29kZSBzID0gUGN0Lih1bmNhc3RfZGVjb2RlZCAoZGVjb2RlIChjYXN0X2VuY29kZWQgcykpKVxuXG4oKiBVc2VyaW5mbyBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGFuIGlkICogY3JlZGVudGlhbCBwYWlyICopXG5tb2R1bGUgVXNlcmluZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nICogc3RyaW5nIG9wdGlvblxuXG4gIGxldCBjb21wYXJlICh1LHApICh1JyxwJykgPVxuICAgIG1hdGNoIFN0cmluZy5jb21wYXJlIHUgdScgd2l0aFxuICAgIHwgMCAtPiBjb21wYXJlX29wdCBTdHJpbmcuY29tcGFyZSBwIHAnXG4gICAgfCBjIC0+IGNcblxuICBsZXQgdXNlcmluZm9fb2ZfZW5jb2RlZCB1cyA9XG4gICAgbWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5tYXg6MiB+b246JzonIHVzIHdpdGhcbiAgICB8IFtdIC0+IChcIlwiLE5vbmUpXG4gICAgfCBbdV0gLT4gKHBjdF9kZWNvZGUgdSxOb25lKVxuICAgIHwgdTo6cDo6XyAtPiAocGN0X2RlY29kZSB1LFNvbWUgKHBjdF9kZWNvZGUgcCkpXG5cbiAgbGV0IGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50ICh1LHBvKSA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy4oXG4gICAgICAxICsgKGxlbmd0aCB1KSArIChtYXRjaCBwbyB3aXRoIE5vbmUgLT4gMCB8IFNvbWUgcCAtPiBsZW5ndGggcCkpXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHUpO1xuICAgIGJlZ2luIG1hdGNoIHBvIHdpdGggTm9uZSAtPiAoKTtcbiAgICB8IFNvbWUgcCAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOic7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHApXG4gICAgZW5kO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5lbmRcblxubGV0IHVzZXJpbmZvX29mX2VuY29kZWQgPSBVc2VyaW5mby51c2VyaW5mb19vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQgPSBVc2VyaW5mby5lbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudFxuXG4oKiBQYXRoIHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYSBsaXN0IG9mIHBhdGggdG9rZW5zICopXG5tb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAoKiBJbnZhcmlhbnQ6IGV2ZXJ5IGVsZW1lbnQgaXMgbm9uLXplcm8sIHNsYXNoZXMgKC8pIG9ubHkgb2NjdXIgYWxvbmUuICopXG4gICgqIFllcywgaXQncyBiZXR0ZXIgdGhpcyB3YXkuIFRoaXMgbWVhbnMgeW91IGNhbiByZXRhaW4gc2VwYXJhdG9yXG4gICAgIGNvbnRleHQgaW4gcmVjdXJzaW9uIChlLmcuIHJlbW92ZV9kb3Rfc2VnbWVudHMgZm9yIHJlbGF0aXZlIHJlc29sdXRpb24pLiAqKVxuXG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0XG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlX2xpc3QgU3RyaW5nLmNvbXBhcmVcblxuICAoKiBNYWtlIGEgcGF0aCB0b2tlbiBsaXN0IGZyb20gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBwYXRoX29mX2VuY29kZWQgcHMgPVxuICAgIGxldCB0b2tsID0gU3RyaW5nZXh0LmZ1bGxfc3BsaXQgcHMgfm9uOicvJyBpblxuICAgIExpc3QubWFwIHBjdF9kZWNvZGUgdG9rbFxuXG4gICgqIFN1YnJvdXRpbmUgZm9yIHJlc29sdmUgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuND4gKilcbiAgbGV0IHJlbW92ZV9kb3Rfc2VnbWVudHMgcCA9XG4gICAgbGV0IHJldnAgPSBMaXN0LnJldiBwIGluXG4gICAgbGV0IHJlYyBsb29wIGFzY2Vuc2lvbiBvdXRwID0gZnVuY3Rpb25cbiAgICAgIHwgXCIvXCI6OlwiLi5cIjo6ciB8IFwiLi5cIjo6ciAtPiBsb29wIChhc2NlbnNpb24gKyAxKSBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OlwiLlwiOjpyICB8IFwiLlwiOjpyICAtPiBsb29wIGFzY2Vuc2lvbiBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OltdIHwgW10gd2hlbiBMaXN0LihsZW5ndGggcCA+IDAgJiYgaGQgcCA9IFwiL1wiKSAtPiBcIi9cIjo6b3V0cFxuICAgICAgfCBbXSB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gTGlzdC5yZXZfYXBwZW5kXG4gICAgICAgIChcIi9cIjo6KHJldl9pbnRlcmplY3QgXCIvXCIgQXJyYXkuKHRvX2xpc3QgKG1ha2UgYXNjZW5zaW9uIFwiLi5cIikpKSkgb3V0cFxuICAgICAgfCBbXSAtPiBMaXN0LihpZiBsZW5ndGggb3V0cCA+IDAgJiYgaGQgb3V0cCA9IFwiL1wiIHRoZW4gdGwgb3V0cCBlbHNlIG91dHApXG4gICAgICB8IFwiL1wiOjpcIi9cIjo6ciB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gbG9vcCAoYXNjZW5zaW9uIC0gMSkgb3V0cCAoXCIvXCI6OnIpXG4gICAgICB8IFwiL1wiOjpfOjpyIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBsb29wIChhc2NlbnNpb24gLSAxKSBvdXRwIHJcbiAgICAgIHwgczo6ciAtPiBsb29wIDAgKHM6Om91dHApIHJcbiAgICBpbiBsb29wIDAgW10gcmV2cFxuXG4gIGxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50IHAgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGMgdG9rIC0+IFN0cmluZy5sZW5ndGggdG9rICsgYykgMCBwIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgaXRlcl9jb25jYXQgKGZ1biBidWYgLT4gZnVuY3Rpb25cbiAgICB8IFwiL1wiIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nXG4gICAgfCBzZWcgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCBzZWcpXG4gICAgKSBcIlwiIGJ1ZiBwO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5cbiAgKCogU3Vicm91dGluZSBmb3IgcmVzb2x2ZSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi4zPiAqKVxuICBsZXQgbWVyZ2UgYmhvc3QgYnBhdGggcmVscGF0aCA9XG4gICAgbWF0Y2ggYmhvc3QsIExpc3QucmV2IGJwYXRoIHdpdGhcbiAgICB8IFNvbWUgXywgW10gLT4gXCIvXCI6OnJlbHBhdGhcbiAgICB8IF8sIChcIi9cIjo6cmJwYXRoIHwgXzo6XCIvXCI6OnJicGF0aCkgLT4gTGlzdC5yZXZfYXBwZW5kIChcIi9cIjo6cmJwYXRoKSByZWxwYXRoXG4gICAgfCBfLCBfIC0+IHJlbHBhdGhcbmVuZFxuXG5sZXQgcGF0aF9vZl9lbmNvZGVkID0gUGF0aC5wYXRoX29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50ID0gUGF0aC5lbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50XG5cbigqIFF1ZXJ5IHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYW4gYXNzb2MgbGlzdCBvZiBrZXkvdmFsdWVzICopXG5tb2R1bGUgUXVlcnkgPSBzdHJ1Y3RcblxuICB0eXBlIGt2ID0gKHN0cmluZyAqIHN0cmluZyBsaXN0KSBsaXN0XG5cbiAgdHlwZSB0ID1cbiAgICB8IEtWIG9mIGt2XG4gICAgfCBSYXcgb2Ygc3RyaW5nIG9wdGlvbiAqIGt2IExhenkudFxuXG4gIGxldCBjb21wYXJlIHggeSA9IG1hdGNoIHgsIHkgd2l0aFxuICAgIHwgS1Yga3ZsLCBLViBrdmwnXG4gICAgfCBSYXcgKF8sIGxhenkga3ZsKSwgS1Yga3ZsJ1xuICAgIHwgS1Yga3ZsLCBSYXcgKF8sIGxhenkga3ZsJykgLT5cbiAgICAgIGNvbXBhcmVfbGlzdCAoZnVuIChrLHZsKSAoaycsdmwnKSAtPlxuICAgICAgICBtYXRjaCBTdHJpbmcuY29tcGFyZSBrIGsnIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbGlzdCBTdHJpbmcuY29tcGFyZSB2bCB2bCdcbiAgICAgICAgfCBjIC0+IGNcbiAgICAgICkga3ZsIGt2bCdcbiAgICB8IFJhdyAocmF3LF8pLCBSYXcgKHJhdycsXykgLT4gY29tcGFyZV9vcHQgU3RyaW5nLmNvbXBhcmUgcmF3IHJhdydcblxuICBsZXQgZmluZCBxIGsgPSB0cnkgU29tZSAoTGlzdC5hc3NvYyBrIHEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuICBsZXQgc3BsaXRfcXVlcnkgcXMgPVxuICAgIGxldCBlbHMgPSBTdHJpbmdleHQuc3BsaXQgfm9uOicmJyBxcyBpblxuICAgICgqIFJlcGxhY2UgYSArIGluIGEgcXVlcnkgc3RyaW5nIHdpdGggYSBzcGFjZSBpbi1wbGFjZSAqKVxuICAgIGxldCBwbHVzX3RvX3NwYWNlIHMgPVxuICAgICAgbGV0IHMgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIHMgaW5cbiAgICAgIGZvciBpID0gMCB0byBCeXRlcy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgaWYgQnl0ZXMuZ2V0IHMgaSA9ICcrJyB0aGVuIEJ5dGVzLnNldCBzIGkgJyAnXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgKGs6OnY6Ol8pOjp0bCAtPlxuICAgICAgICBsZXQgbiA9IHBsdXNfdG9fc3BhY2UgayxcbiAgICAgICAgICAgICAgICAobWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5vbjonLCcgKHBsdXNfdG9fc3BhY2Ugdikgd2l0aFxuICAgICAgICAgICAgICAgICB8IFtdIC0+IFtcIlwiXSB8IGwgLT4gbCkgaW5cbiAgICAgICAgbG9vcCAobjo6YWNjKSB0bFxuICAgICAgfCBba106OnRsIC0+XG4gICAgICAgIGxldCBuID0gcGx1c190b19zcGFjZSBrLCBbXSBpblxuICAgICAgICBsb29wIChuOjphY2MpIHRsXG4gICAgICB8IFtdOjp0bCAtPiBsb29wICgoXCJcIiwgW10pOjphY2MpIHRsXG4gICAgICB8IFtdIC0+IGFjY1xuICAgIGluXG4gICAgbWF0Y2ggZWxzIHdpdGhcbiAgICB8IFtdICAtPiBbXCJcIixbXV1cbiAgICB8IGVscyAtPiBsb29wIFtdXG4gICAgICAoTGlzdC5yZXZfbWFwIChmdW4gZWwgLT4gU3RyaW5nZXh0LnNwbGl0IH5vbjonPScgZWwgfm1heDoyKSBlbHMpXG5cbiAgKCogTWFrZSBhIHF1ZXJ5IHR1cGxlIGxpc3QgZnJvbSBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IHF1ZXJ5X29mX2VuY29kZWQgcXMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChrLCB2KSAtPiAocGN0X2RlY29kZSBrLCBMaXN0Lm1hcCBwY3RfZGVjb2RlIHYpKVxuICAgICAgKHNwbGl0X3F1ZXJ5IHFzKVxuXG4gICgqIEFzc2VtYmxlIGEgcXVlcnkgc3RyaW5nIHN1aXRhYmxlIGZvciBwdXR0aW5nIGludG8gYSBVUkkuXG4gICAqIFR1cGxlIGlucHV0cyBhcmUgcGVyY2VudCBkZWNvZGVkIGFuZCB3aWxsIGJlIGVuY29kZWQgYnlcbiAgICogdGhpcyBmdW5jdGlvbi5cbiAgKilcbiAgbGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBhIChrLHYpIC0+XG4gICAgICAgIGEgKyAoU3RyaW5nLmxlbmd0aCBrKVxuICAgICAgICArIChMaXN0LmZvbGRfbGVmdCAoZnVuIGEgcyAtPiBhKyhTdHJpbmcubGVuZ3RoIHMpKzEpIDAgdikgKyAyKSAoLTEpIGwgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiAoayx2KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnF1ZXJ5X2tleSBrKTtcbiAgICAgICAgaWYgdiA8PiBbXSB0aGVuIChcbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc9JztcbiAgICAgICAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiBzIC0+XG4gICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgICAgICAgICAgIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5xdWVyeV92YWx1ZSBzKVxuICAgICAgICAgICAgKSBcIixcIiBidWYgdilcbiAgICAgICkgXCImXCIgYnVmIGw7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4gIGxldCBvZl9yYXcgcXMgPVxuICAgIGxldCBsYXp5X3F1ZXJ5ID0gTGF6eS5mcm9tX2Z1biAoZnVuICgpIC0+IHF1ZXJ5X29mX2VuY29kZWQgcXMpIGluXG4gICAgUmF3IChTb21lIHFzLCBsYXp5X3F1ZXJ5KVxuXG4gIGxldCBrdiA9IGZ1bmN0aW9uIFJhdyAoXywgbGF6eSBrdikgfCBLViBrdiAtPiBrdlxuZW5kXG5cbmxldCBxdWVyeV9vZl9lbmNvZGVkID0gUXVlcnkucXVlcnlfb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA9IFF1ZXJ5LmVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZVxuXG4oKiBUeXBlIG9mIHRoZSBVUkksIHdpdGggbW9zdCBiaXRzIGJlaW5nIG9wdGlvbmFsICopXG50eXBlIHQgPSB7XG4gIHNjaGVtZTogUGN0LmRlY29kZWQgb3B0aW9uO1xuICB1c2VyaW5mbzogVXNlcmluZm8udCBvcHRpb247XG4gIGhvc3Q6IFsgYElwdjRfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgfCBgSXB2Nl9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICB8IGBIb3N0IG9mIFBjdC5kZWNvZGVkXSBvcHRpb24gO1xuICBwb3J0OiBpbnQgb3B0aW9uO1xuICBwYXRoOiBQYXRoLnQ7XG4gIHF1ZXJ5OiBRdWVyeS50O1xuICBmcmFnbWVudDogUGN0LmRlY29kZWQgb3B0aW9uO1xufVxuXG5sZXQgZW1wdHkgPSB7XG4gIHNjaGVtZSA9IE5vbmU7XG4gIHVzZXJpbmZvID0gTm9uZTtcbiAgaG9zdCA9IE5vbmU7XG4gIHBvcnQgPSBOb25lO1xuICBwYXRoID0gW107XG4gIHF1ZXJ5ID0gUXVlcnkuUmF3IChOb25lLCBMYXp5LmZyb21fdmFsIFtdKTtcbiAgZnJhZ21lbnQgPSBOb25lO1xufVxuXG5sZXQgY29tcGFyZV9kZWNvZGVkID0gUGN0LnVubGlmdF9kZWNvZGVkMiBTdHJpbmcuY29tcGFyZVxubGV0IGNvbXBhcmVfZGVjb2RlZF9vcHQgPSBjb21wYXJlX29wdCBjb21wYXJlX2RlY29kZWRcbmxldCBjb21wYXJlX2hvc3QgaDEgaDIgPVxuICBtYXRjaCBoMSwgaDIgd2l0aFxuICB8IGBJcHY0X2xpdGVyYWwgaXAxLCBgSXB2NF9saXRlcmFsIGlwMiAtPiBTdHJpbmcuY29tcGFyZSBpcDEgaXAyXG4gIHwgYElwdjZfbGl0ZXJhbCBpcDEsIGBJcHY2X2xpdGVyYWwgaXAyIC0+IFN0cmluZy5jb21wYXJlIGlwMSBpcDJcbiAgfCBgSG9zdCBoMSwgYEhvc3QgaDIgLT4gY29tcGFyZV9kZWNvZGVkIGgxIGgyXG4gIHwgXyAtPiAtMVxubGV0IGNvbXBhcmVfaG9zdF9vcHQgPSBjb21wYXJlX29wdCBjb21wYXJlX2hvc3RcblxubGV0IGNvbXBhcmUgdCB0JyA9XG4gIChtYXRjaCBjb21wYXJlX2hvc3Rfb3B0IHQuaG9zdCB0Jy5ob3N0IHdpdGhcbiAgfCAwIC0+IChtYXRjaCBjb21wYXJlX2RlY29kZWRfb3B0IHQuc2NoZW1lIHQnLnNjaGVtZSB3aXRoXG4gICAgfCAwIC0+IChtYXRjaCBjb21wYXJlX29wdCAoZnVuIHAgcCcgLT5cbiAgICAgIGlmIHAgPCBwJyB0aGVuIC0xIGVsc2UgaWYgcCA+IHAnIHRoZW4gMSBlbHNlIDBcbiAgICApIHQucG9ydCB0Jy5wb3J0IHdpdGhcbiAgICAgIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9vcHQgVXNlcmluZm8uY29tcGFyZSB0LnVzZXJpbmZvIHQnLnVzZXJpbmZvIHdpdGhcbiAgICAgICAgfCAwIC0+IChtYXRjaCBQYXRoLmNvbXBhcmUgdC5wYXRoIHQnLnBhdGggd2l0aFxuICAgICAgICAgIHwgMCAtPiAobWF0Y2ggUXVlcnkuY29tcGFyZSB0LnF1ZXJ5IHQnLnF1ZXJ5IHdpdGhcbiAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2RlY29kZWRfb3B0IHQuZnJhZ21lbnQgdCcuZnJhZ21lbnRcbiAgICAgICAgICAgIHwgYyAtPiBjKVxuICAgICAgICAgIHwgYyAtPiBjKVxuICAgICAgICB8IGMgLT4gYylcbiAgICAgIHwgYyAtPiBjKVxuICAgIHwgYyAtPiBjKVxuICB8IGMgLT4gYylcblxubGV0IGVxdWFsIHQgdCcgPSBjb21wYXJlIHQgdCcgPSAwXG5cbmxldCB1bmNhc3Rfb3B0ID0gZnVuY3Rpb25cbiAgfCBTb21lIGggLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG4gIHwgTm9uZSAtPiBOb25lXG5cbmxldCBub3JtYWxpemUgc2NoZW0gdXJpID1cbiAgbGV0IG1vZHVsZSBTY2hlbWUgPVxuICAgICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgKHVuY2FzdF9vcHQgc2NoZW0pKSA6IFNjaGVtZSkgaW5cbiAgbGV0IGRvYiBmID0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPiBTb21lIChQY3QudW5saWZ0X2RlY29kZWQgZiB4KVxuICAgIHwgTm9uZSAtPiBOb25lXG4gIGluIHt1cmkgd2l0aFxuICAgICAgc2NoZW1lPWRvYiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHVyaS5zY2hlbWU7XG4gICAgICBob3N0PSBtYXRjaCB1cmkuaG9zdCB3aXRoXG4gICAgICAgfCBTb21lIChgSXB2NF9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSXB2NF9saXRlcmFsIChTY2hlbWUubm9ybWFsaXplX2hvc3QgaG9zdCkpXG4gICAgICAgfCBTb21lIChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSXB2Nl9saXRlcmFsIChTY2hlbWUubm9ybWFsaXplX2hvc3QgaG9zdCkpXG4gICAgICAgfCBTb21lIChgSG9zdCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCAoUGN0LnVuY2FzdF9kZWNvZGVkIGhvc3QpKSkpXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfVxuXG4oKiogQ29udmVydCBhIFVSSSBzdHJ1Y3R1cmUgaW50byBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmdcbiAgICA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMz5cbiopXG5sZXQgdG9fc3RyaW5nID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9XG4gIGxldCBzY2hlbWUgPSBtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgcylcbiAgICB8IE5vbmUgLT4gTm9uZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMjggaW5cbiAgKCogUGVyY2VudCBlbmNvZGUgYSBkZWNvZGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBidWZmZXIgKilcbiAgbGV0IGFkZF9wY3Rfc3RyaW5nID8oY29tcG9uZW50PWBQYXRoKSB4ID1cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFBjdC51bmNhc3RfZW5jb2RlZCAoUGN0LmVuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgeCkpXG4gIGluXG4gIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgIHxOb25lIC0+ICgpXG4gICB8U29tZSB4IC0+XG4gICAgIGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuc2NoZW1lIHg7XG4gICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonXG4gICk7XG4gICgqIFVSSSBoYXMgYSBob3N0IGlmIGFueSBob3N0LXJlbGF0ZWQgY29tcG9uZW50IGlzIHNldC4gRGVmYXVsdHMgdG8gXCJcIi4gKilcbiAgaWYgKG1hdGNoIHVyaS51c2VyaW5mbywgdXJpLmhvc3QsIHVyaS5wb3J0IHdpdGhcbiAgfCBTb21lIF8sIF8sIF8gfCBfLCBTb21lIF8sIF8gfCBfLCBfLCBTb21lIF8gLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpXG4gIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLy9cIjtcbiAgKG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIHVzZXJpbmZvIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mbykpO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ0AnXG4gICk7XG4gIChtYXRjaCB1cmkuaG9zdCB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIChgSG9zdCBob3N0KSAtPlxuICAgIGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuaG9zdCBob3N0O1xuICB8U29tZSAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgaG9zdFxuICB8U29tZSAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnWyc7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgaG9zdDtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ10nXG4gICk7XG4gIChtYXRjaCB1cmkucG9ydCB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIHBvcnQgLT5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6JztcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgcG9ydClcbiAgKTtcbiAgKG1hdGNoIHVyaS5wYXRoIHdpdGggKCogSGFuZGxlIHJlbGF0aXZlIHBhdGhzIGNvcnJlY3RseSAqKVxuICB8IFtdIC0+ICgpXG4gIHwgXCIvXCI6Ol8gLT5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFBjdC51bmNhc3RfZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aCkpXG4gIHwgZmlyc3Rfc2VnbWVudDo6XyAtPlxuICAgIChtYXRjaCB1cmkuaG9zdCB3aXRoXG4gICAgIHwgU29tZSBfIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nXG4gICAgIHwgTm9uZSAtPlxuICAgICAgICgqIGVuc3VyZSByb3VuZHRyaXAgYnkgZm9yY2luZyByZWxhdGl2ZSBwYXRoIGludGVycHJldGF0aW9uIG5vdCBzY2hlbWUgKilcbiAgICAgICBtYXRjaCBTdHJpbmdleHQuZmluZF9mcm9tIGZpcnN0X3NlZ21lbnQgfnBhdHRlcm46XCI6XCIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgIHwgU29tZSBfIC0+IG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICAgfCBOb25lIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIi4vXCJcbiAgICApO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgKFBjdC51bmNhc3RfZW5jb2RlZCAoZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKSlcbiAgKTtcbiAgUXVlcnkuKG1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gICAgfCBSYXcgKE5vbmUsXykgfCBLViBbXSAtPiAoKVxuICAgIHwgUmF3IChfLGxhenkgcSkgfCBLViBxIC0+ICgqIG5vcm1hbGl6ZSBlLmcuIHBlcmNlbnQgY2FwaXRhbGl6YXRpb24gKilcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJz8nO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgfnBjdF9lbmNvZGVyIHEpXG4gICk7XG4gIChtYXRjaCB1cmkuZnJhZ21lbnQgd2l0aFxuICAgfE5vbmUgLT4gKClcbiAgIHxTb21lIGYgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnIyc7IGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuZnJhZ21lbnQgZlxuICApO1xuICBCdWZmZXIuY29udGVudHMgYnVmXG5cbigqIFZhcmlvdXMgYWNjZXNzb3IgZnVuY3Rpb25zLCBhcyB0aGUgZXh0ZXJuYWwgdXJpIHR5cGUgaXMgYWJzdHJhY3QgICopXG5sZXQgZ2V0X2RlY29kZWRfb3B0ID0gZnVuY3Rpb24gTm9uZSAtPiBOb25lIHxTb21lIHggLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIHgpXG5sZXQgc2NoZW1lIHVyaSA9IGdldF9kZWNvZGVkX29wdCB1cmkuc2NoZW1lXG5sZXQgd2l0aF9zY2hlbWUgdXJpID1cbiAgZnVuY3Rpb25cbiAgfFNvbWUgc2NoZW1lIC0+IHsgdXJpIHdpdGggc2NoZW1lPVNvbWUgKFBjdC5jYXN0X2RlY29kZWQgc2NoZW1lKSB9XG4gIHxOb25lIC0+IHsgdXJpIHdpdGggc2NoZW1lPU5vbmUgfVxuXG5sZXQgaG9zdCB1cmkgPVxuICBtYXRjaCB1cmkuaG9zdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoYElwdjRfbGl0ZXJhbCBoIHwgYElwdjZfbGl0ZXJhbCBoKSAtPiBTb21lIGhcbiAgfCBTb21lIChgSG9zdCBoKSAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgaClcblxubGV0IGhvc3Rfd2l0aF9kZWZhdWx0ID8oZGVmYXVsdD1cImxvY2FsaG9zdFwiKSB1cmkgPVxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHxOb25lIC0+IGRlZmF1bHRcbiAgfFNvbWUgaCAtPiBoXG5cbmxldCB1c2VyaW5mbyA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgdXNlcmluZm8gLT4gU29tZSAoUGN0LnVuY2FzdF9lbmNvZGVkIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgICB8IE5vbmUgLT4gZW5jb2RlZF9vZl91c2VyaW5mbyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvXG4gICAgfCBTb21lIHMgLT4gZW5jb2RlZF9vZl91c2VyaW5mbyB+c2NoZW1lOihQY3QudW5jYXN0X2RlY29kZWQgcykgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mbykpXG5sZXQgd2l0aF91c2VyaW5mbyB1cmkgdXNlcmluZm8gPVxuICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KVxuICAgIHwgTm9uZSAtPiBOb25lXG4gIGluXG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG5cbmxldCB1c2VyIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAodXNlciwgXykgLT4gU29tZSB1c2VyXG5cbmxldCBwYXNzd29yZCB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgfCBTb21lIChfLCBOb25lKSAtPiBOb25lXG4gIHwgU29tZSAoXywgU29tZSBwYXNzKSAtPiBTb21lIHBhc3NcbmxldCB3aXRoX3Bhc3N3b3JkIHVyaSBwYXNzd29yZCA9XG4gIGxldCByZXN1bHQgdXNlcmluZm8gPSBtYXRjaCBob3N0IHVyaSB3aXRoXG4gICAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgaW5cbiAgbWF0Y2ggdXJpLnVzZXJpbmZvLCBwYXNzd29yZCB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiB1cmlcbiAgfCBOb25lLCBTb21lIF8gLT4gcmVzdWx0IChTb21lIChcIlwiLHBhc3N3b3JkKSlcbiAgfCBTb21lICh1c2VyLF8pLCBfIC0+IHJlc3VsdCAoU29tZSAodXNlciwgcGFzc3dvcmQpKVxuXG5sZXQgcG9ydCB1cmkgPSB1cmkucG9ydFxubGV0IHdpdGhfcG9ydCB1cmkgcG9ydCA9XG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCBwb3J0PXBvcnQgfVxuICB8IE5vbmUgLT4gYmVnaW5cbiAgICAgbWF0Y2ggcG9ydCB3aXRoXG4gICAgIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9Tm9uZTsgcG9ydD1Ob25lIH1cbiAgICAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgcG9ydD1wb3J0IH1cbiAgZW5kXG5cbigqIFJldHVybiB0aGUgcGF0aCBjb21wb25lbnQgKilcbmxldCBwYXRoID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IFBjdC51bmNhc3RfZW5jb2RlZCAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gIHwgTm9uZSAtPiBlbmNvZGVkX29mX3BhdGggfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoXG4gIHwgU29tZSBzIC0+IGVuY29kZWRfb2ZfcGF0aCB+c2NoZW1lOihQY3QudW5jYXN0X2RlY29kZWQgcykgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKVxubGV0IHdpdGhfcGF0aCB1cmkgcGF0aCA9XG4gIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHBhdGggaW5cbiAgbWF0Y2ggaG9zdCB1cmksIHBhdGggd2l0aFxuICB8IE5vbmUsIF8gfCBTb21lIF8sIFwiL1wiOjpfIHwgU29tZSBfLCBbXSAtPiB7IHVyaSB3aXRoIHBhdGg9cGF0aCB9XG4gIHwgU29tZSBfLCBfICAtPiB7IHVyaSB3aXRoIHBhdGg9XCIvXCI6OnBhdGggfVxuXG5sZXQgZnJhZ21lbnQgdXJpID0gZ2V0X2RlY29kZWRfb3B0IHVyaS5mcmFnbWVudFxubGV0IHdpdGhfZnJhZ21lbnQgdXJpID1cbiAgZnVuY3Rpb25cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBmcmFnbWVudD1Ob25lIH1cbiAgfFNvbWUgZnJhZyAtPiB7IHVyaSB3aXRoIGZyYWdtZW50PVNvbWUgKFBjdC5jYXN0X2RlY29kZWQgZnJhZykgfVxuXG5sZXQgcXVlcnkgdXJpID0gUXVlcnkua3YgdXJpLnF1ZXJ5XG5sZXQgdmVyYmF0aW1fcXVlcnkgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gUXVlcnkuKG1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gIHwgUmF3IChxcyxfKSAtPiBxc1xuICB8IEtWIFtdIC0+IE5vbmVcbiAgfCBLViBrdiAtPiBTb21lIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWU6KHNjaGVtZSB1cmkpIH5wY3RfZW5jb2RlciBrdilcbilcbmxldCBnZXRfcXVlcnlfcGFyYW0nIHVyaSBrID0gUXVlcnkuKGZpbmQgKGt2IHVyaS5xdWVyeSkgaylcbmxldCBnZXRfcXVlcnlfcGFyYW0gdXJpIGsgPVxuICBtYXRjaCBnZXRfcXVlcnlfcGFyYW0nIHVyaSBrIHdpdGhcbiAgfE5vbmUgLT4gTm9uZVxuICB8U29tZSB2IC0+IFNvbWUgKFN0cmluZy5jb25jYXQgXCIsXCIgdilcblxubGV0IHdpdGhfcXVlcnkgdXJpIHF1ZXJ5ID0geyB1cmkgd2l0aCBxdWVyeT1RdWVyeS5LViBxdWVyeSB9XG5sZXQgcV9zIHEgPSBMaXN0Lm1hcCAoZnVuIChrLHYpIC0+IGssW3ZdKSBxXG5sZXQgd2l0aF9xdWVyeScgdXJpIHF1ZXJ5ID0gd2l0aF9xdWVyeSB1cmkgKHFfcyBxdWVyeSlcbmxldCBhZGRfcXVlcnlfcGFyYW0gdXJpIHAgPSBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAocDo6KGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtJyB1cmkgKGssdikgPVxuICBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAoKGssW3ZdKTo6KGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtcyB1cmkgcHMgPSBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAocHNAKGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtcycgdXJpIHBzID1cbiAgUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKChxX3MgcHMpQChrdiB1cmkucXVlcnkpKSB9KVxubGV0IHJlbW92ZV9xdWVyeV9wYXJhbSB1cmkgayA9IFF1ZXJ5LihcbiAgeyB1cmkgd2l0aCBxdWVyeT1LViAoTGlzdC5maWx0ZXIgKGZ1biAoaycsXykgLT4gazw+aycpIChrdiB1cmkucXVlcnkpKSB9XG4pXG5cbigqIENvbnN0cnVjdCBlbmNvZGVkIHBhdGggYW5kIHF1ZXJ5IGNvbXBvbmVudHMgKilcbmxldCBwYXRoX2FuZF9xdWVyeSB1cmkgPVxuICBtYXRjaCAocGF0aCB1cmkpLCAocXVlcnkgdXJpKSB3aXRoXG4gIHxcIlwiLCBbXSAtPiBcIi9cIiAoKiBUT0RPOiBXaGF0IGFib3V0IHNhbWUgZG9jdW1lbnQ/ICgvKSAqKVxuICB8XCJcIiwgcSAtPiAoKiBUT0RPOiBXaGF0IGFib3V0IHNhbWUgZG9jdW1lbnQ/ICgvKSAqKVxuICAgIGxldCBzY2hlbWUgPSB1bmNhc3Rfb3B0IHVyaS5zY2hlbWUgaW5cbiAgICBQcmludGYuc3ByaW50ZiBcIi8/JXNcIiAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIHEpXG4gIHxwLCBbXSAtPiBwXG4gIHxwLCBxIC0+XG4gICAgbGV0IHNjaGVtZSA9IHVuY2FzdF9vcHQgdXJpLnNjaGVtZSBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiJXM/JXNcIiBwIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgcSlcblxuKCogVE9ETzogZnVuY3Rpb25zIHRvIGFkZCBhbmQgcmVtb3ZlIGZyb20gYSBVUkkgKilcblxuKCogUmVzb2x2ZSBhIFVSSSB3cnQgYSBiYXNlIFVSSSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMj4gKilcbmxldCByZXNvbHZlIHNjaGVtIGJhc2UgdXJpID1cbiAgbGV0IHNjaGVtID0gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCAobWF0Y2ggc2NoZW1lIGJhc2Ugd2l0aFxuICAgICAgfCBOb25lIC0+ICBzY2hlbVxuICAgICAgfCBTb21lIHNjaGVtZSAtPiBzY2hlbWVcbiAgICApKSBpblxuICBub3JtYWxpemUgc2NoZW1cbiAgICBQYXRoLihtYXRjaCBzY2hlbWUgdXJpLCB1c2VyaW5mbyB1cmksIGhvc3QgdXJpIHdpdGhcbiAgICB8IFNvbWUgXywgXywgXyAtPlxuICAgICAge3VyaSB3aXRoIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICB8IE5vbmUsIFNvbWUgXywgX1xuICAgIHwgTm9uZSwgXywgU29tZSBfIC0+XG4gICAgICB7dXJpIHdpdGggc2NoZW1lPWJhc2Uuc2NoZW1lOyBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgfCBOb25lLCBOb25lLCBOb25lIC0+XG4gICAgICBsZXQgdXJpID0ge3VyaSB3aXRoIHNjaGVtZT1iYXNlLnNjaGVtZTsgdXNlcmluZm89YmFzZS51c2VyaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdD1iYXNlLmhvc3Q7IHBvcnQ9YmFzZS5wb3J0fSBpblxuICAgICAgbGV0IHBhdGhfc3RyID0gcGF0aCB1cmkgaW5cbiAgICAgIGlmIHBhdGhfc3RyPVwiXCJcbiAgICAgIHRoZW4geyB1cmkgd2l0aFxuICAgICAgICAgICAgIHBhdGg9YmFzZS5wYXRoO1xuICAgICAgICAgICAgIHF1ZXJ5PW1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gICAgICAgICAgICAgICB8IFF1ZXJ5LlJhdyAoTm9uZSxfKSB8IFF1ZXJ5LktWIFtdIC0+IGJhc2UucXVlcnlcbiAgICAgICAgICAgICAgIHwgXyAtPiB1cmkucXVlcnlcbiAgICAgICAgICAgfVxuICAgICAgZWxzZSBpZiBwYXRoX3N0ci5bMF09Jy8nXG4gICAgICB0aGVuIHt1cmkgd2l0aCBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgICBlbHNlIHt1cmkgd2l0aFxuICAgICAgICBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgKG1lcmdlIGJhc2UuaG9zdCBiYXNlLnBhdGggdXJpLnBhdGgpO1xuICAgICAgfVxuICAgIClcblxubGV0IGNhbm9uaWNhbGl6ZSB1cmkgPVxuICBsZXQgdXJpID0gcmVzb2x2ZSBcIlwiIGVtcHR5IHVyaSBpblxuICBsZXQgbW9kdWxlIFNjaGVtZSA9XG4gICAgKHZhbCAobW9kdWxlX29mX3NjaGVtZSAodW5jYXN0X29wdCB1cmkuc2NoZW1lKSkgOiBTY2hlbWUpIGluXG4gIHsgdXJpIHdpdGhcbiAgICBwb3J0PVNjaGVtZS5jYW5vbmljYWxpemVfcG9ydCB1cmkucG9ydDtcbiAgICBwYXRoPVNjaGVtZS5jYW5vbmljYWxpemVfcGF0aCB1cmkucGF0aDtcbiAgfVxuXG5sZXQgcHAgcHBmIHVyaSA9IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmcgdXJpKVxubGV0IHBwX2h1bSBwcGYgdXJpID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyB1cmkpXG5cbm1vZHVsZSBQYXJzZXIgPSBzdHJ1Y3RcbiAgb3BlbiBBbmdzdHJvbVxuXG4gIGxldCBzdHJpbmdfb2ZfY2hhciA9IFN0cmluZy5tYWtlIDFcblxuICBsZXQgc3RyaW5nX29mX2NoYXJfbGlzdCBjaGFycyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCBzdHJpbmdfb2ZfY2hhciBjaGFycylcblxuICBsZXQgc2NoZW1lID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHMgLT4gU29tZSAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAodGFrZV93aGlsZSAoZnVuIGMgLT4gYyA8PiAnOicgJiYgYyA8PiAnLycgJiYgYyA8PiAnPycgJiYgYyA8PiAnIycpXG4gICAgICA8KiBjaGFyICc6JylcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgaXNfZGlnaXQgPSBmdW5jdGlvbiAnMCcgLi4gJzknIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGhleF9kaWdpdCA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCBoZXhhZGVjaW1hbCA9IGxpZnQgc3RyaW5nX29mX2NoYXJfbGlzdCAobWFueSBoZXhfZGlnaXQpXG5cbiAgbGV0IGNfZG90ID0gY2hhciAnLidcblxuICBsZXQgY19hdCA9IGNoYXIgJ0AnXG5cbiAgbGV0IGNfY29sb24gPSBjaGFyICc6J1xuXG4gIGxldCBkZWNfb2N0ZXQgPVxuICAgIHRha2Vfd2hpbGUxIChmdW5jdGlvbiAnMCcgLi4gJzknIC0+IHRydWUgfCBfIC0+IGZhbHNlKSA+Pj0gZnVuIG51bSAtPlxuICAgIGlmIGludF9vZl9zdHJpbmcgbnVtIDwgMjU2IHRoZW5cbiAgICAgIHJldHVybiBudW1cbiAgICBlbHNlXG4gICAgICBmYWlsIFwiaW52YWxpZCBvY3RlY3RcIlxuXG4gIGxldCBpcHY0X2FkZHJlc3MgPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHRocmVlIG9uZSAtPiBTdHJpbmcuY29uY2F0IFwiLlwiIHRocmVlIF4gXCIuXCIgXiBvbmUpXG4gICAgICAoY291bnQgMyAoZGVjX29jdGV0IDwqIGNfZG90KSlcbiAgICAgIGRlY19vY3RldFxuXG4gICgqIC0tIGFmdGVyIGRvdWJsZSBjb2xvbiwgSVB2NCBkb3R0ZWQgbm90YXRpb24gY291bGQgYXBwZWFyIGFueXdoZXJlICopXG4gIGxldCBhZnRlcl9kb3VibGVfY29sb24gPVxuICAgIGZpeCAoZnVuIGYgLT5cbiAgICAgICAgbGlzdCBbIGlwdjRfYWRkcmVzcyBdXG4gICAgICAgIDx8PiBsaWZ0MiAoZnVuIHggeSAtPiB4IDo6IHkpIGhleGFkZWNpbWFsIChjX2NvbG9uICo+IGYgPHw+IHJldHVybiBbXSkpXG5cbiAgbGV0IGRvdWJsZV9jb2xvbiBjb3VudCA9XG4gICAgYWZ0ZXJfZG91YmxlX2NvbG9uID4+PSAoZnVuIHJlc3QgLT5cbiAgICBsZXQgZmlsbGVyX2xlbmd0aCA9IDggLSBjb3VudCAtIExpc3QubGVuZ3RoIHJlc3QgaW5cbiAgICBpZiBmaWxsZXJfbGVuZ3RoIDw9IDAgdGhlblxuICAgICAgZmFpbCBcInRvbyBtYW55IHBhcnRzIGluIElQdjYgYWRkcmVzc1wiXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIChcIlwiIDo6IHJlc3QpKVxuICAgIDx8PiByZXR1cm4gW1wiXCJdXG5cbiAgbGV0IHJlYyBwYXJ0ID0gZnVuY3Rpb25cbiAgICB8IDcgLT5cbiAgICAgICgqIG1heCA4IHBhcnRzIGluIGFuIElQdjYgYWRkcmVzcyAqKVxuICAgICAgbGlmdCAoZnVuIHggLT4gWyB4IF0pIGhleGFkZWNpbWFsXG4gICAgfCA2IC0+XG4gICAgICAoKiBhZnRlciA2IHBhcnRzIGl0IGNvdWxkIGVuZCBpbiBJUHY0IGRvdHRlZCBub3RhdGlvbiAqKVxuICAgICAgbGlzdCBbIGlwdjRfYWRkcmVzcyBdIDx8PiBoZXhfcGFydCA2XG4gICAgfCBuIC0+XG4gICAgICBoZXhfcGFydCBuXG5cbiAgYW5kIGhleF9wYXJ0IG4gPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHggeSAtPiB4IDo6IHkpXG4gICAgICBoZXhhZGVjaW1hbFxuICAgICAgKGNfY29sb24gKj4gKGNfY29sb24gKj4gZG91YmxlX2NvbG9uIChuICsgMSkgPHw+IHBhcnQgKG4gKyAxKSkpXG5cbiAgbGV0IHJlYyBzcGxpdF93aXRoIGYgeHMgPVxuICAgIG1hdGNoIHhzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBbXSwgW11cbiAgICB8IHkgOjogeXMgLT5cbiAgICAgIGlmIGYgeSB0aGVuXG4gICAgICAgIGxldCB6cywgdHMgPSBzcGxpdF93aXRoIGYgeXMgaW5cbiAgICAgICAgeSA6OiB6cywgdHNcbiAgICAgIGVsc2VcbiAgICAgICAgW10sIHhzXG5cbiAgbGV0IGlwdjYgPVxuICAgIGxldCBmb3JtYXRfYWRkciBzZWdtZW50cyA9XG4gICAgICBsZXQgYmVmb3JlX2RvdWJsZV9jb2xvbiwgYWZ0ZXJfZG91YmxlX2NvbG9uID1cbiAgICAgICAgc3BsaXRfd2l0aCAoZnVuIHNlZ21lbnQgLT4gc2VnbWVudCA8PiBcIlwiKSBzZWdtZW50c1xuICAgICAgaW5cbiAgICAgIGxldCBiZWZvcmUgPSBTdHJpbmcuY29uY2F0IFwiOlwiIGJlZm9yZV9kb3VibGVfY29sb24gaW5cbiAgICAgIGxldCByZXMgPVxuICAgICAgICBtYXRjaCBhZnRlcl9kb3VibGVfY29sb24gd2l0aFxuICAgICAgICB8IFwiXCIgOjogeHMgLT5cbiAgICAgICAgICBiZWZvcmUgXiBcIjo6XCIgXiBTdHJpbmcuY29uY2F0IFwiOlwiIHhzXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGJlZm9yZVxuICAgICAgaW5cbiAgICAgIHJlc1xuICAgIGluXG4gICAgbGlmdCBmb3JtYXRfYWRkciAoY19jb2xvbiAqPiBjX2NvbG9uICo+IGRvdWJsZV9jb2xvbiAwIDx8PiBwYXJ0IDApXG5cbiAgbGV0IGlwdjZfYWRkcmVzcyA9XG4gICAgKGNoYXIgJ1snKSAqPiBpcHY2IDwqIChjaGFyICddJylcblxuICBsZXQgcGN0X2VuY29kZWQgPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHBjdCBkaWdpdHMgLT4gc3RyaW5nX29mX2NoYXJfbGlzdCAocGN0IDo6IGRpZ2l0cykpXG4gICAgICAoY2hhciAnJScpXG4gICAgICAoY291bnQgMiBoZXhfZGlnaXQpXG5cbiAgbGV0IHN1Yl9kZWxpbXMgPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJyEnIHwgJyQnIHwgJyYnIHwgJ1xcJycgfCAnKCcgfCAnKScgfCAnKicgfCAnKycgfCAnLCcgfCAnOycgfCAnPScgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCB1bnJlc2VydmVkID1cbiAgICAoKiBcIltBLVphLXowLTktLl9+XVwiICopXG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyB8ICcwJyAuLiAnOScgfCAnLScgfCAnLicgfCAnXycgfCAnficgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCByZWdfbmFtZSA9XG4gICAgbGlmdFxuICAgICAgKFN0cmluZy5jb25jYXQgXCJcIilcbiAgICAgIChtYW55XG4gICAgICAgICAoY2hvaWNlXG4gICAgICAgICAgICBbIHN0cmluZ19vZl9jaGFyIDwkPiB1bnJlc2VydmVkXG4gICAgICAgICAgICA7IHBjdF9lbmNvZGVkXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBzdWJfZGVsaW1zXG4gICAgICAgICAgICBdKSlcblxuICBsZXQgaG9zdCA9XG4gICAgY2hvaWNlXG4gICAgICBbIGlwdjRfYWRkcmVzcyA+PnwgKGZ1biBoIC0+IGBJcHY0X2xpdGVyYWwgaClcbiAgICAgIDsgaXB2Nl9hZGRyZXNzID4+fCAoZnVuIGggLT4gYElwdjZfbGl0ZXJhbCBoKVxuICAgICAgOyByZWdfbmFtZSA+PnwgKGZ1biBzIC0+IGBIb3N0IChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgICgqIFRPRE8oZGlub3NhdXJlKTogQWNjb3JkaW5nIHRvIFJGQzM5ODY6XG5cbiAgICAgICAgIGhvc3QgICAgICAgID0gSVAtbGl0ZXJhbCAvIElQdjRhZGRyZXNzIC8gcmVnLW5hbWVcbiAgICAgICAgIElQLWxpdGVyYWwgID0gXCJbXCIgKCBJUHY2YWRkcmVzcyAvIElQdkZ1dHVyZSAgKSBcIl1cIlxuICAgICAgICAgSVB2RnV0dXJlICAgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG5cbiAgICAgICAgIElQdkZ1dHVyZSBpcyBub3QgaW1wbGVtZW50ZWQuIFdlIHNob3VsZCBoYW5kbGUgaXQ6XG5cbiAgICAgICAgIElQdkZ1dHVyZSAgID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgICAgICopXG4gICAgICBdXG5cbiAgbGV0IHVzZXJpbmZvID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHggLT5cbiAgICAgICAgbGV0IHMgPSBTdHJpbmcuY29uY2F0IFwiXCIgeCBpblxuICAgICAgICBTb21lIChVc2VyaW5mby51c2VyaW5mb19vZl9lbmNvZGVkIHMpKVxuICAgICAgKG1hbnlcbiAgICAgICAgIChjaG9pY2VcbiAgICAgICAgICAgIFsgc3RyaW5nX29mX2NoYXIgPCQ+IHVucmVzZXJ2ZWRcbiAgICAgICAgICAgIDsgcGN0X2VuY29kZWRcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IHN1Yl9kZWxpbXNcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IGNfY29sb25cbiAgICAgICAgICAgIF0pXG4gICAgICA8KiBjX2F0KVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBwb3J0ID1cbiAgICBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lICc6JyAtPlxuICAgICAgY19jb2xvbiAqPiB0YWtlX3doaWxlIGlzX2RpZ2l0ID4+fCBmdW4gcG9ydCAtPlxuICAgICAgbGV0IGRlY29kZWQgPSBQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHBvcnQpIGluXG4gICAgICAodHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgKFBjdC51bmNhc3RfZGVjb2RlZCBkZWNvZGVkKSkgd2l0aCBfIC0+IE5vbmUpXG4gICAgfCBTb21lIF8gfCBOb25lIC0+XG4gICAgICByZXR1cm4gTm9uZVxuXG4gIGxldCBhdXRob3JpdHkgPVxuICAgIHN0cmluZyBcIi8vXCJcbiAgICAqPiBsaWZ0M1xuICAgICAgICAgKGZ1biB1c2VyaW5mbyBob3N0IHBvcnQgLT5cbiAgICAgICAgICAgdXNlcmluZm8sIFNvbWUgaG9zdCwgcG9ydClcbiAgICAgICAgIHVzZXJpbmZvXG4gICAgICAgICBob3N0XG4gICAgICAgICBwb3J0XG4gICAgPHw+IHJldHVybiAoTm9uZSwgTm9uZSwgTm9uZSlcblxuICBsZXQgcGF0aCA9XG4gICAgbGlmdFxuICAgICAgUGF0aC5wYXRoX29mX2VuY29kZWRcbiAgICAgICh0YWtlX3doaWxlIChmdW5jdGlvbiAnPycgfCAnIycgLT4gZmFsc2UgfCBfIC0+IHRydWUpKVxuXG4gIGxldCBxdWVyeSA9XG4gICAgbGlmdFxuICAgICAgUXVlcnkub2ZfcmF3XG4gICAgICAoY2hhciAnPycgKj4gdGFrZV90aWxsIChmdW5jdGlvbiAnIycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpKVxuICAgIDx8PiByZXR1cm4gKFF1ZXJ5LlJhdyAoTm9uZSwgTGF6eS5mcm9tX3ZhbCBbXSkpXG5cbiAgbGV0IGZyYWdtZW50ID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHMgLT4gU29tZSAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAoY2hhciAnIycgKj4gdGFrZV93aGlsZSAoZnVuIF8gLT4gdHJ1ZSkpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IF91cmlfcmVmZXJlbmNlID1cbiAgICBsaWZ0NFxuICAgICAgKGZ1biBzY2hlbWUgKHVzZXJpbmZvLCBob3N0LCBwb3J0KSBwYXRoIHF1ZXJ5IGZyYWdtZW50IC0+XG4gICAgICAgIG5vcm1hbGl6ZSBzY2hlbWUgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfSlcbiAgICAgIHNjaGVtZVxuICAgICAgYXV0aG9yaXR5XG4gICAgICBwYXRoXG4gICAgICBxdWVyeVxuICAgIDwqPiBmcmFnbWVudFxuXG4gICgqIFhYWChhbm1vbnRlaXJvKTogRm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucyB3aXRoIHRoZSBvbGQgcmVnZXggcGFyc2VyLCB3ZVxuICAgKiBvbmx5IHBhcnNlIHVudGlsIHRoZSBmaXJzdCBuZXdsaW5lIGNoYXJhY3RlciBhbmQgZHJvcCBldmVyeXRoaW5nIGVsc2VcbiAgICogYWZ0ZXIgdGhhdCAqKVxuICBsZXQgdXJpX3JlZmVyZW5jZSA9XG4gICAgdGFrZV93aGlsZSAoZnVuY3Rpb24gfCAnXFxuJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZSkgPj58IGZ1biBzIC0+XG4gICAgICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIF91cmlfcmVmZXJlbmNlIHMgd2l0aFxuICAgICAgfCBPayB0IC0+IHRcbiAgICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAoKiBTaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBpZiB0aGUgcGFyc2VyIGlzIGZvcmdpdmluZy4gKilcbiAgICAgICAgZW1wdHlcbmVuZFxuXG5sZXQgZGVjb2RlX2hvc3QgaG9zdCA9XG4gIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgUGFyc2VyLmhvc3QgaG9zdCB3aXRoXG4gIHwgT2sgcGFyc2VkIC0+IHBhcnNlZFxuICB8IEVycm9yIF8gLT5cbiAgICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIFBhcnNlci5pcHY2IGhvc3Qgd2l0aFxuICAgIHwgT2sgcGFyc2VkIC0+IChgSXB2Nl9saXRlcmFsIHBhcnNlZClcbiAgICB8IEVycm9yIF8gLT4gKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIGhvc3QpKVxuXG4oKiBNYWtlIGEgVVJJIHJlY29yZC4gVGhpcyBpcyBhIGJpdCBtb3JlIGluZWZmaWNpZW50IHRoYW4gaXQgbmVlZHMgdG8gYmUgZHVlIHRvIHRoZVxuICogY2FzdGluZy91bmNhc3RpbmcgKHdoaWNoIGlzbid0IGZ1bGx5IGlkZW50aXR5IGR1ZSB0byB0aGUgb3B0aW9uIGJveCksIGJ1dCBpdCBpc1xuICogbm8gYmlnIGRlYWwgZm9yIG5vdy5cbiopXG5sZXQgbWFrZSA/c2NoZW1lID91c2VyaW5mbyA/aG9zdCA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50ICgpID1cbiAgbGV0IGRlY29kZSA9IGZ1bmN0aW9uXG4gICAgfFNvbWUgeCAtPiBTb21lIChQY3QuY2FzdF9kZWNvZGVkIHgpIHxOb25lIC0+IE5vbmUgaW5cbiAgbGV0IGhvc3QgPSBtYXRjaCB1c2VyaW5mbywgaG9zdCwgcG9ydCB3aXRoXG4gICAgfCBfLCBTb21lIF8sIF8gfCBOb25lLCBOb25lLCBOb25lIC0+IGhvc3RcbiAgICB8IFNvbWUgXywgTm9uZSwgXyB8IF8sIE5vbmUsIFNvbWUgXyAtPiBTb21lIFwiXCJcbiAgaW5cbiAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSkgaW5cbiAgbGV0IHBhdGggPSBtYXRjaCBwYXRoIHdpdGhcbiAgICB8Tm9uZSAtPiBbXSB8IFNvbWUgcCAtPlxuICAgICAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcCBpblxuICAgICAgbWF0Y2ggaG9zdCwgcGF0aCB3aXRoXG4gICAgICB8IE5vbmUsIF8gfCBTb21lIF8sIFwiL1wiOjpfIHwgU29tZSBfLCBbXSAtPiBwYXRoXG4gICAgICB8IFNvbWUgXywgXyAgLT4gXCIvXCI6OnBhdGhcbiAgaW5cbiAgbGV0IHF1ZXJ5ID0gbWF0Y2ggcXVlcnkgd2l0aFxuICAgIHwgTm9uZSAtPiBRdWVyeS5LViBbXVxuICAgIHwgU29tZSBwIC0+IFF1ZXJ5LktWIHBcbiAgaW5cbiAgbGV0IHNjaGVtZSA9IGRlY29kZSBzY2hlbWUgaW5cbiAgbm9ybWFsaXplIHNjaGVtZVxuICAgIHsgc2NoZW1lOyB1c2VyaW5mbztcbiAgICAgIGhvc3QgPVxuICAgICAgICAobWF0Y2ggaG9zdCB3aXRoXG4gICAgICAgIHwgU29tZSBob3N0IC0+IFNvbWUgKGRlY29kZV9ob3N0IGhvc3QpXG4gICAgICAgIHwgTm9uZSAtPiBOb25lKTtcbiAgICAgIHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudD1kZWNvZGUgZnJhZ21lbnQgfVxuXG5sZXQgd2l0aF9ob3N0IHVyaSBob3N0ID1cbiAgeyB1cmkgd2l0aFxuICAgIGhvc3QgPSAobWF0Y2ggaG9zdCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgaG9zdCAtPiBTb21lIChkZWNvZGVfaG9zdCBob3N0KVxuICAgICAgICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIH1cblxubGV0IHdpdGhfdXJpID9zY2hlbWUgP3VzZXJpbmZvID9ob3N0ID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgdXJpID1cbiAgbGV0IHdpdGhfcGF0aF9vcHQgdSBvID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gd2l0aF9wYXRoIHUgXCJcIlxuICAgIHwgU29tZSBwIC0+IHdpdGhfcGF0aCB1IHBcbiAgaW5cbiAgbGV0IHdpdGhfcXVlcnlfb3B0IHUgbyA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHdpdGhfcXVlcnkgdSBbXVxuICAgIHwgU29tZSBxIC0+IHdpdGhfcXVlcnkgdSBxXG4gIGluXG4gIGxldCB3aXRoXyBmIG8gdSA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHVcbiAgICB8IFNvbWUgeCAtPiBmIHUgeFxuICBpblxuICB3aXRoXyB3aXRoX3NjaGVtZSBzY2hlbWUgdXJpXG4gIHw+IHdpdGhfIHdpdGhfdXNlcmluZm8gdXNlcmluZm9cbiAgfD4gd2l0aF8gd2l0aF9ob3N0IGhvc3RcbiAgfD4gd2l0aF8gd2l0aF9wb3J0IHBvcnRcbiAgfD4gd2l0aF8gd2l0aF9wYXRoX29wdCBwYXRoXG4gIHw+IHdpdGhfIHdpdGhfcXVlcnlfb3B0IHF1ZXJ5XG4gIHw+IHdpdGhfIHdpdGhfZnJhZ21lbnQgZnJhZ21lbnRcblxubGV0IG9mX3N0cmluZyBzID1cbiAgKCogVG8gcHJlc2VydmUgdGhlIG9sZCByZWdleCBwYXJzZXIncyBiZWhhdmlvciwgd2Ugb25seSBwYXJzZSBhIHByZWZpeCwgYW5kXG4gICAqIHN0b3Agd2hlbmV2ZXIgd2UgY2FuJ3QgcGFyc2UgbW9yZS4gKilcbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOlByZWZpeCBQYXJzZXIudXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgfCBPayB0IC0+IHRcbiAgfCBFcnJvciBfIC0+XG4gICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgZW1wdHlcblxubW9kdWxlIEFic29sdXRlX2h0dHAgPSBzdHJ1Y3RcbiAgdHlwZSB1cmkgPSB0XG4gIHR5cGUgdCA9XG4gICAgeyBzY2hlbWUgOiBbIGBIdHRwIHwgYEh0dHBzIF07XG4gICAgICB1c2VyaW5mbzogVXNlcmluZm8udCBvcHRpb247XG4gICAgICBob3N0OiBbIGBJcHY0X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgICAgICB8IGBJcHY2X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgICAgICB8IGBIb3N0IG9mIFBjdC5kZWNvZGVkXTtcbiAgICAgIHBvcnQgOiBpbnQgb3B0aW9uO1xuICAgICAgcGF0aCA6IFBhdGgudDtcbiAgICAgIHF1ZXJ5IDogUXVlcnkudDtcbiAgICAgIGZyYWdtZW50IDogUGN0LmRlY29kZWQgb3B0aW9uXG4gICAgfVxuXG4gIGxldCAoIGxldCogKSA9IFJlc3VsdC5iaW5kXG5cbiAgbGV0IHRvX3VyaSB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9ID1cbiAgICBsZXQgc2NoZW1lID1cbiAgICAgIG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICB8IGBIdHRwIC0+IFBjdC5jYXN0X2RlY29kZWQgXCJodHRwXCJcbiAgICAgIHwgYEh0dHBzIC0+IFBjdC5jYXN0X2RlY29kZWQgXCJodHRwc1wiXG4gICAgaW5cbiAgICAoeyBzY2hlbWUgPSBTb21lIHNjaGVtZTtcbiAgICAgICB1c2VyaW5mbztcbiAgICAgICBob3N0ID0gU29tZSBob3N0O1xuICAgICAgIHBvcnQ7XG4gICAgICAgcGF0aDtcbiAgICAgICBxdWVyeTtcbiAgICAgICBmcmFnbWVudCB9IDogdXJpKVxuICA7O1xuXG4gIGxldCBvZl91cmkgKHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH06IHVyaSkgPVxuICAgIGxldCogc2NoZW1lID1cbiAgICAgIG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRXJyb3IgKGBNc2cgXCJObyBzY2hlbWUgcHJlc2VudCBpbiBVUklcIilcbiAgICAgIHwgU29tZSBzY2hlbWUgLT5cbiAgICAgICAgKG1hdGNoIFBjdC51bmNhc3RfZGVjb2RlZCBzY2hlbWUgd2l0aFxuICAgICAgICAgfCBcImh0dHBcIiAtPiBPayBgSHR0cFxuICAgICAgICAgfCBcImh0dHBzXCIgLT4gT2sgYEh0dHBzXG4gICAgICAgICB8IHVuc3VwcG9ydGVkX3NjaGVtZSAtPlxuICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgIChgTXNnXG4gICAgICAgICAgICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgXCJPbmx5IGh0dHAgYW5kIGh0dHBzIFVSSXMgYXJlIHN1cHBvcnRlZC4gJXMgaXMgaW52YWxpZC5cIlxuICAgICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkX3NjaGVtZSkpKVxuICAgIGluXG4gICAgbGV0KiBob3N0ID0gT3B0aW9uLnRvX3Jlc3VsdCB+bm9uZTooYE1zZyBcImhvc3QgaXMgcmVxdWlyZWQgZm9yIEhUVFAoUykgdXJpc1wiKSBob3N0IGluXG4gICAgT2sgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfVxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmcgcyA9IG1hdGNoIG9mX3N0cmluZyBzIHw+IG9mX3VyaSB3aXRoXG4gICAgfCBPayB0IC0+IHRcbiAgICB8IEVycm9yIChgTXNnIGVycm9yKSAtPiBmYWlsd2l0aCBlcnJvclxuXG4gIGxldCB0b19zdHJpbmcgP3BjdF9lbmNvZGVyIHQgPSB0b191cmkgdCB8PiB0b19zdHJpbmcgP3BjdF9lbmNvZGVyXG5cbiAgbGV0IG5vcm1hbGl6ZSB0ID1cbiAgICB7IHQgd2l0aFxuICAgICAgaG9zdCA9IG1hdGNoIHQuaG9zdCB3aXRoXG4gICAgICAgfCAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgKGBJcHY0X2xpdGVyYWwgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaG9zdCkpXG4gICAgICAgfCAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgKGBJcHY2X2xpdGVyYWwgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaG9zdCkpXG4gICAgICAgfCAoYEhvc3QgaG9zdCkgLT5cbiAgICAgICAgIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSAoUGN0LnVuY2FzdF9kZWNvZGVkIGhvc3QpKSkpXG4gICAgfVxuXG4gIGxldCBtYWtlIH5zY2hlbWUgfmhvc3QgP3VzZXJpbmZvID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgKCkgPVxuICAgIGxldCBkZWNvZGUgPSBmdW5jdGlvblxuICAgICAgfFNvbWUgeCAtPiBTb21lIChQY3QuY2FzdF9kZWNvZGVkIHgpIHxOb25lIC0+IE5vbmUgaW5cbiAgICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZSB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpIGluXG4gICAgbGV0IHBhdGggPSBtYXRjaCBwYXRoIHdpdGhcbiAgICAgIHxOb25lIC0+IFtdIHwgU29tZSBwIC0+XG4gICAgICAgIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHAgaW5cbiAgICAgICAgbWF0Y2ggcGF0aCB3aXRoXG4gICAgICAgIHwgIFwiL1wiOjpfIHwgIFtdIC0+IHBhdGhcbiAgICAgICAgfCBfICAtPiBcIi9cIjo6cGF0aFxuICAgIGluXG4gICAgbGV0IHF1ZXJ5ID0gbWF0Y2ggcXVlcnkgd2l0aFxuICAgICAgfCBOb25lIC0+IFF1ZXJ5LktWIFtdXG4gICAgICB8IFNvbWUgcCAtPiBRdWVyeS5LViBwXG4gICAgaW5cbiAgICBub3JtYWxpemVcbiAgICAgIHsgc2NoZW1lO1xuICAgICAgICB1c2VyaW5mbztcbiAgICAgICAgaG9zdD0gZGVjb2RlX2hvc3QgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50PWRlY29kZSBmcmFnbWVudCB9XG5cbiAgbGV0IGhvc3QgdCA9XG4gICAgbWF0Y2ggdC5ob3N0IHdpdGhcbiAgICB8IChgSXB2NF9saXRlcmFsIGggfCBgSXB2Nl9saXRlcmFsIGgpIC0+IGhcbiAgICB8IChgSG9zdCBoKSAtPiAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG5cbiAgbGV0IHNjaGVtZSB0ID0gdC5zY2hlbWVcbmVuZFxuIl19
