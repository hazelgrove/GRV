// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_module_timer_runtime
//# unitInfo: Requires: Assert_failure, Base, Base__Int, Base__Int63, Base__List, Base__Option, Base__Printf, Base__String, CamlinternalLazy, Stdio, Stdlib, Stdlib__Gc, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_PPX_MODULE_TIMER = "PPX_MODULE_TIMER",
    cst_ns$1 = "ns",
    cst_runtime_ppx_module_timer_r = "runtime/ppx_module_timer_runtime.ml",
    caml_gc_quick_stat = runtime.caml_gc_quick_stat,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = "\n",
    cst$1 = " ",
    cst$2 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    am_recording_environment_varia = cst_PPX_MODULE_TIMER,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Int63 = global_data.Base__Int63,
    Stdio = global_data.Stdio,
    Base_Option = global_data.Base__Option,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Int = global_data.Base__Int,
    Time_now = global_data.Time_now,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib;
   a:
   {
    var
     cst_ppx_module_timer_overridin =
       "ppx_module_timer: overriding time measurements for testing",
     _e_ = [0, [11, "Line ", [4, 0, 0, 0, 0]], "Line %d"],
     _f_ =
       [0, [11, "Fake__Dependency_", [4, 0, 0, 0, 0]], "Fake__Dependency_%d"],
     _d_ = [0, [2, [1, 1], [12, 32, [2, 0, 0]]], "%*s %s"],
     cst_compactions = "compactions",
     cst_major_collections = "major collections",
     cst_minor_collections = "minor collections",
     _c_ = [0, ", "],
     cst_GC = "; GC: ",
     _b_ = [0, cst_runtime_ppx_module_timer_r, 110, 6],
     _a_ = [0, cst_runtime_ppx_module_timer_r, 94, 6],
     cst_ns$0 = cst_ns$1,
     cst_ns = cst_ns$1;
    try{var value = runtime.caml_sys_getenv(cst_PPX_MODULE_TIMER);}
    catch(_X_){var am_recording_value = 0; break a;}
    var am_recording_value = [0, value];
   }
   var am_recording = caml_call1(Base_Option[50], am_recording_value);
   function to_nanoseconds(t){return t;}
   function of_nanoseconds(t){return t;}
   function of_string(string){
    var _W_ = caml_call2(Base_String[102], string, cst_ns);
    return caml_call1(Base_Int63[10], _W_);
   }
   function to_string(nanos){
    var _V_ = caml_call1(Base_Int63[11], nanos);
    return caml_call2(Base[198], _V_, cst_ns$0);
   }
   function to_string_with_same_unit(list){
    return caml_call2(Base_List[76], list, to_string);
   }
   var format = [0, [0, of_string, to_string_with_same_unit]];
   function create(nested_timer, param){
    var _U_ = caml_gc_quick_stat(0);
    return [0, cst, Base_Int63[38], _U_, nested_timer, 0];
   }
   function record_start(t, description){
    if(am_recording){
     if(! caml_call1(Base_String[5], t[1]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     t[1] = description;
     t[3] = caml_gc_quick_stat(0);
     t[2] = caml_call1(Time_now[1], 0);
     var _T_ = 0;
    }
    else
     var _T_ = am_recording;
    return _T_;
   }
   function record_until(t, description){
    if(! am_recording) return am_recording;
    var
     until = caml_call1(Time_now[1], 0),
     start = t[2],
     gc_stats_after = caml_gc_quick_stat(0),
     gc_stats_before = t[3],
     runtime = caml_call2(Base_Int63[42], until, start);
    if(! caml_call2(Base_String[121], t[1], description))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     gc_events =
       [0,
        gc_stats_after[4] - gc_stats_before[4] | 0,
        gc_stats_after[5] - gc_stats_before[5] | 0,
        gc_stats_after[14] - gc_stats_before[14] | 0],
     match$0 = t[4];
    if(match$0)
     var
      nested$0 = match$0[1],
      nested_timing_events = caml_call1(Base_List[38], nested$0[5]);
    else
     var nested_timing_events = 0;
    var
     timing_event = [0, description, runtime, gc_events, nested_timing_events];
    t[5] = [0, timing_event, t[5]];
    t[1] = cst$0;
    t[2] = Base_Int63[38];
    var match = t[4];
    if(! match) return 0;
    var nested = match[1];
    nested[5] = 0;
    return 0;
   }
   var
    definition_timer = create(0, 0),
    module_timer = create([0, definition_timer], 0);
   function record_start$0(module_name){
    return record_start(module_timer, module_name);
   }
   function record_until$0(module_name){
    return record_until(module_timer, module_name);
   }
   function record_definition_start(loc){
    return record_start(definition_timer, loc);
   }
   function record_definition_until(loc){
    return record_until(definition_timer, loc);
   }
   function timing_events_to_strings(list, indent){
    function _D_(timing_event){return timing_event[2];}
    var
     string = caml_call2(Base_List[76], list, _D_),
     Format = format[1],
     duration_strings = caml_call1(Format[2], string),
     prefix = caml_call2(Base_String[50], indent, 32);
    function _E_(duration_string, param){
     var
      nested_timing_events = param[4],
      gc_events = param[3],
      description = param[1];
     function _L_(line){return caml_call2(Base[198], cst$3, line);}
     var
      _M_ = timing_events_to_strings(nested_timing_events, indent + 4 | 0),
      _N_ = caml_call2(Base_List[76], _M_, _L_),
      _O_ = caml_call2(Base_String[54], 0, _N_),
      compactions = gc_events[3],
      major_collections = gc_events[2],
      minor_collections = gc_events[1];
     function to_list(description, count){
      if(0 === count) return 0;
      var
       _R_ = caml_call2(Base[198], cst$1, description),
       _S_ = caml_call1(Base_Int[11], count);
      return [0, caml_call2(Base[198], _S_, _R_), 0];
     }
     var
      _G_ = to_list(cst_compactions, compactions),
      _H_ = to_list(cst_major_collections, major_collections),
      _I_ = caml_call2(Base[179], _H_, _G_),
      _J_ = to_list(cst_minor_collections, minor_collections),
      strings = caml_call2(Base[179], _J_, _I_);
     if(caml_call1(Base_List[8], strings))
      var _P_ = cst$2;
     else
      var
       _K_ = caml_call2(Base_String[54], _c_, strings),
       _P_ = caml_call2(Base[198], cst_GC, _K_);
     var _Q_ = caml_call2(Base[198], _P_, _O_);
     return [0, duration_string, caml_call2(Base[198], description, _Q_)];
    }
    var list$0 = caml_call3(Base_List[83], duration_strings, list, _E_);
    function _A_(width, param){
     var left = param[1];
     return caml_call2
             (Base_Int[15], width, runtime.caml_ml_string_length(left));
    }
    var left_column_width = caml_call3(Base_List[10], list$0, 0, _A_);
    function _B_(param){
     var right = param[2], left = param[1];
     return caml_call4(Base_Printf[2], _d_, left_column_width, left, right);
    }
    var _C_ = caml_call2(Base_List[76], list$0, _B_), _F_ = Base_List[76];
    return caml_call2
            (_F_,
             _C_,
             function(line){return caml_call2(Base[198], prefix, line);});
   }
   function gc_events(i){
    var
     _x_ = 7 === caml_call2(Base[184], i, 8) ? 1 : 0,
     _y_ = 3 === caml_call2(Base[184], i, 4) ? 1 : 0,
     _z_ = 1 === caml_call2(Base[184], i, 2) ? 1 : 0;
    return [0, _z_, _y_, _x_];
   }
   var
    fake_timing_events =
      [246,
       function(_p_){
        function _q_(i){
         if(0 === caml_call2(Base[184], i + 1 | 0, 4))
          var
           _r_ =
             function(j){
              var
               _v_ = gc_events(j),
               _w_ = caml_call1(Base_Int63[96], 900 * (j + 1 | 0) | 0);
              return [0,
                      caml_call2(Base_Printf[2], _e_, j + 1 | 0),
                      _w_,
                      _v_,
                      0];
             },
           _s_ = caml_call2(Base_List[123], i + 1 | 0, _r_);
         else
          var _s_ = 0;
         var
          _t_ = gc_events(i),
          _u_ = caml_call1(Base_Int63[96], 900 * (i + 1 | 0) | 0);
         return [0, caml_call2(Base_Printf[2], _f_, i + 1 | 0), _u_, _t_, _s_];
        }
        return caml_call2(Base_List[123], 12, _q_);
       }];
   if(am_recording){
    var
     _g_ =
       function(param){
        var timing_events$0 = caml_call1(Base_List[38], module_timer[5]);
        function notify_of_overriding(param){
         return caml_call1(Stdio[9], cst_ppx_module_timer_overridin);
        }
        var string = caml_call4(Base_Option[28], 0, 0, 0, am_recording_value);
        a:
        if(runtime.caml_string_notequal(string, "FAKE_MODULES")){
         try{var Format = format[1], override = caml_call1(Format[1], string);
         }
         catch(_o_){var timing_events = timing_events$0; break a;}
         notify_of_overriding(0);
         var
          _i_ =
            function(index, timing_event){
             var
              _l_ = caml_call1(Base_Int63[96], index + 1 | 0),
              runtime = caml_call2(Base_Int63[43], override, _l_);
             function _m_(index, nested_timing_event){
              var
               _n_ = caml_call1(Base_Int63[96], index + 1 | 0),
               runtime = caml_call2(Base_Int63[43], override, _n_);
              return [0,
                      nested_timing_event[1],
                      runtime,
                      nested_timing_event[3],
                      nested_timing_event[4]];
             }
             var
              nested_timing_events =
                caml_call2(Base_List[96], timing_event[4], _m_);
             return [0,
                     timing_event[1],
                     runtime,
                     timing_event[3],
                     nested_timing_events];
            },
          timing_events = caml_call2(Base_List[96], timing_events$0, _i_);
        }
        else{
         notify_of_overriding(0);
         var _j_ = runtime.caml_obj_tag(fake_timing_events);
         b:
         if(250 === _j_)
          var _k_ = fake_timing_events[1];
         else{
          if(246 !== _j_ && 244 !== _j_){
           var _k_ = fake_timing_events;
           break b;
          }
          var _k_ = caml_call1(CamlinternalLazy[2], fake_timing_events);
         }
         var timing_events = _k_;
        }
        var _h_ = timing_events_to_strings(timing_events, 0);
        return caml_call2(Base_List[9], _h_, Stdio[9]);
       };
    caml_call1(Stdlib[100], _g_);
   }
   var
    Ppx_module_timer_runtime =
      [0,
       am_recording,
       am_recording_environment_varia,
       [0, to_nanoseconds, of_nanoseconds, format],
       record_start$0,
       record_until$0,
       record_definition_start,
       record_definition_until];
   runtime.caml_register_global
    (32, Ppx_module_timer_runtime, "Ppx_module_timer_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYSIsInZhbHVlIiwiYW1fcmVjb3JkaW5nX3ZhbHVlIiwiYW1fcmVjb3JkaW5nIiwidG9fbmFub3NlY29uZHMiLCJ0Iiwib2ZfbmFub3NlY29uZHMiLCJvZl9zdHJpbmciLCJzdHJpbmciLCJ0b19zdHJpbmciLCJuYW5vcyIsInRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCIsImxpc3QiLCJmb3JtYXQiLCJjcmVhdGUiLCJuZXN0ZWRfdGltZXIiLCJyZWNvcmRfc3RhcnQiLCJkZXNjcmlwdGlvbiIsInJlY29yZF91bnRpbCIsInVudGlsIiwic3RhcnQiLCJnY19zdGF0c19hZnRlciIsImdjX3N0YXRzX2JlZm9yZSIsInJ1bnRpbWUiLCJnY19ldmVudHMiLCJuZXN0ZWQkMCIsIm5lc3RlZF90aW1pbmdfZXZlbnRzIiwidGltaW5nX2V2ZW50IiwibmVzdGVkIiwiZGVmaW5pdGlvbl90aW1lciIsIm1vZHVsZV90aW1lciIsInJlY29yZF9zdGFydCQwIiwibW9kdWxlX25hbWUiLCJyZWNvcmRfdW50aWwkMCIsInJlY29yZF9kZWZpbml0aW9uX3N0YXJ0IiwibG9jIiwicmVjb3JkX2RlZmluaXRpb25fdW50aWwiLCJ0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MiLCJpbmRlbnQiLCJGb3JtYXQiLCJkdXJhdGlvbl9zdHJpbmdzIiwicHJlZml4IiwiZHVyYXRpb25fc3RyaW5nIiwibGluZSIsImNvbXBhY3Rpb25zIiwibWFqb3JfY29sbGVjdGlvbnMiLCJtaW5vcl9jb2xsZWN0aW9ucyIsInRvX2xpc3QiLCJjb3VudCIsInN0cmluZ3MiLCJsaXN0JDAiLCJ3aWR0aCIsImxlZnQiLCJsZWZ0X2NvbHVtbl93aWR0aCIsInJpZ2h0IiwiaSIsImZha2VfdGltaW5nX2V2ZW50cyIsImoiLCJ0aW1pbmdfZXZlbnRzJDAiLCJub3RpZnlfb2Zfb3ZlcnJpZGluZyIsIm92ZXJyaWRlIiwidGltaW5nX2V2ZW50cyIsImluZGV4IiwibmVzdGVkX3RpbWluZ19ldmVudCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvcHB4X21vZHVsZV90aW1lci9ydW50aW1lL3BweF9tb2R1bGVfdGltZXJfcnVudGltZS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7SUFLSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFJRixJQUFNLElBQ0pDLFFBREk7bUJBS0pDO1FBQUFBLHlCQUpBRDs7R0FLZSxJQUFmRSxlQUFlLDRCQURmRDtZQU1FRSxlQUFlQyxHQUFJLE9BQUpBLEVBQUs7WUFDcEJDLGVBQWVELEdBQUksT0FBSkEsRUFBSztZQVFsQkUsVUFBVUM7SUFBUyxVQUFBLDZCQUFUQTtJQUFTLE9BQUE7R0FBNkQ7WUFDaEZDLFVBQVVDO0lBQVEsVUFBQSwyQkFBUkE7SUFBUSxPQUFBO0dBQTRCO1lBQzlDQyx5QkFBeUJDO0lBQU8saUNBQVBBLE1BRHpCSDtHQUMwRDtHQUduRCxJQUFUSSxpQkFMRU4sV0FFQUk7WUEwQ0ZHLE9BQVFDO0lBR3FCLFVBQUE7SUFGL0IscUNBRFVBO0dBTVQ7WUFXQ0MsYUFBYVgsR0FBRVk7SUFDakIsR0E1RUFkO0tBOEVTLEtBQUEsMkJBSE1FO01BR2IsTUFBQTtLQUhhQSxPQUFFWTtLQUFGWixPQUttQjtLQUxuQkEsT0FPcUI7Ozs7ZUFsRnBDRjs7R0FrRjZFO1lBRzNFZSxhQUFhYixHQUFFWTtJQUNqQixLQXRGQWQsY0FBZSxPQUFmQTtJQXlGYztLQUFSZ0IsUUFBUTtLQUNSQyxRQUxTZjtLQU1UZ0IsaUJBQWlCO0tBQ2pCQyxrQkFQU2pCO0tBUVRrQixVQUFVLDJCQUpWSixPQUNBQztJQUlHLEtBQUEsNkJBVE1mLE1BQUVZO0tBU2YsTUFBQTtJQUVFO0tBREVPOztRQUpBSCxvQkFDQUM7UUFE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TUFBQSwyQkFETG1DO2NBQzFCdkMsVUFBVSwyQkFIaEJxQzthQUlFLGFBR1lFLE9BQU1DO2NBQ1o7ZUFBbUMsTUFBQSwyQkFEN0JEO2VBQ0Z2QyxVQUFVLDJCQVJ0QnFDO2NBU1E7c0JBRllHO3NCQUNSeEM7c0JBRFF3QztzQkFBQUE7YUFFd0I7YUFKeEM7Y0FERXJDO2dCQUNGLDBCQUhtQ0M7YUFTckM7cUJBVHFDQTtxQkFDakNKO3FCQURpQ0k7cUJBRWpDRDtZQU8rQztVQWxCeERtQyxnQkFTRywwQkFid0JIOzs7U0FDM0JDO3dDQTFCRkg7OztvQkFBQUE7OztxQkFBQUE7OztvREFBQUE7O2FBNkJFSzs7a0JBbkRFeEIseUJBbURGd0I7UUFxQkosT0FBQTtPQVEwRTtJQUZ4RTs7Ozs7T0FoT0ExRDtPQVZBSDtXQWVFSSxnQkFDQUUsZ0JBYUFPO09Bb0dGa0I7T0FDQUU7T0FDQUM7T0FDQUU7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2Vcbm1vZHVsZSBHYyA9IFN0ZGxpYi5HY1xuXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5cbmxldCBhbV9yZWNvcmRpbmdfZW52aXJvbm1lbnRfdmFyaWFibGUgPSBcIlBQWF9NT0RVTEVfVElNRVJcIlxuXG5sZXQgZ2V0X2FtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYWJsZSAoKSA9XG4gICgqIGF2b2lkIFN0ZGxpYi5TeXMuZ2V0ZW52X29wdCB0byBwcmVzZXJ2ZSA0LjA0LnggY29tcGF0aWJpbGl0eSAqKVxuICBtYXRjaCBTdGRsaWIuU3lzLmdldGVudiBhbV9yZWNvcmRpbmdfZW52aXJvbm1lbnRfdmFyaWFibGUgd2l0aFxuICB8IHZhbHVlIC0+IFNvbWUgdmFsdWVcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgYW1fcmVjb3JkaW5nX3ZhbHVlID0gZ2V0X2FtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYWJsZSAoKVxubGV0IGFtX3JlY29yZGluZyA9IE9wdGlvbi5pc19zb21lIGFtX3JlY29yZGluZ192YWx1ZVxuXG5tb2R1bGUgRHVyYXRpb24gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gSW50NjMudFxuXG4gIGxldCB0b19uYW5vc2Vjb25kcyB0ID0gdFxuICBsZXQgb2ZfbmFub3NlY29uZHMgdCA9IHRcblxuICBtb2R1bGUgdHlwZSBGb3JtYXQgPSBzaWdcbiAgICB2YWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgICB2YWwgdG9fc3RyaW5nX3dpdGhfc2FtZV91bml0IDogdCBsaXN0IC0+IHN0cmluZyBsaXN0XG4gIGVuZFxuXG4gIG1vZHVsZSBEZWZhdWx0X2Zvcm1hdCA9IHN0cnVjdFxuICAgIGxldCBvZl9zdHJpbmcgc3RyaW5nID0gU3RyaW5nLmNob3Bfc3VmZml4X2V4biBzdHJpbmcgfnN1ZmZpeDpcIm5zXCIgfD4gSW50NjMub2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyBuYW5vcyA9IEludDYzLnRvX3N0cmluZyBuYW5vcyBeIFwibnNcIlxuICAgIGxldCB0b19zdHJpbmdfd2l0aF9zYW1lX3VuaXQgbGlzdCA9IExpc3QubWFwIGxpc3QgfmY6dG9fc3RyaW5nXG4gIGVuZFxuXG4gIGxldCBmb3JtYXQgPSByZWYgKG1vZHVsZSBEZWZhdWx0X2Zvcm1hdCA6IEZvcm1hdClcblxuICBsZXQgb2Zfc3RyaW5nIHN0cmluZyA9XG4gICAgbGV0IChtb2R1bGUgRm9ybWF0KSA9ICFmb3JtYXQgaW5cbiAgICBGb3JtYXQub2Zfc3RyaW5nIHN0cmluZ1xuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfd2l0aF9zYW1lX3VuaXQgc3RyaW5nID1cbiAgICBsZXQgKG1vZHVsZSBGb3JtYXQpID0gIWZvcm1hdCBpblxuICAgIEZvcm1hdC50b19zdHJpbmdfd2l0aF9zYW1lX3VuaXQgc3RyaW5nXG4gIDs7XG5lbmRcblxubW9kdWxlIEdjX2V2ZW50cyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWlub3JfY29sbGVjdGlvbnMgOiBpbnRcbiAgICA7IG1ham9yX2NvbGxlY3Rpb25zIDogaW50XG4gICAgOyBjb21wYWN0aW9ucyA6IGludFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgVGltaW5nX2V2ZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBkZXNjcmlwdGlvbiA6IHN0cmluZ1xuICAgIDsgcnVudGltZSA6IER1cmF0aW9uLnRcbiAgICA7IGdjX2V2ZW50cyA6IEdjX2V2ZW50cy50XG4gICAgOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyA6IHQgbGlzdFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgVGltZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gOiBzdHJpbmdcbiAgICA7IG11dGFibGUgY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSA6IER1cmF0aW9uLnRcbiAgICA7IG11dGFibGUgY3VycmVudGx5X3J1bm5pbmdfZ2Nfc3RhdHMgOiBHYy5zdGF0XG4gICAgOyBtdXRhYmxlIG5lc3RlZF90aW1lciA6IHQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIHRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyIDogVGltaW5nX2V2ZW50LnQgbGlzdFxuICAgIH1cblxuICBsZXQgY3JlYXRlID9uZXN0ZWRfdGltZXIgKCkgPVxuICAgIHsgY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gPSBcIlwiXG4gICAgOyBjdXJyZW50bHlfcnVubmluZ19zdGFydF90aW1lID0gSW50NjMuemVyb1xuICAgIDsgY3VycmVudGx5X3J1bm5pbmdfZ2Nfc3RhdHMgPSBHYy5xdWlja19zdGF0ICgpXG4gICAgOyBuZXN0ZWRfdGltZXJcbiAgICA7IHRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyID0gW11cbiAgICB9XG4gIDs7XG5cbiAgbGV0IHJlc2V0IHQgPVxuICAgIHQuY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gPC0gXCJcIjtcbiAgICB0LmN1cnJlbnRseV9ydW5uaW5nX3N0YXJ0X3RpbWUgPC0gSW50NjMuemVybztcbiAgICBtYXRjaCB0Lm5lc3RlZF90aW1lciB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIG5lc3RlZCAtPiBuZXN0ZWQudGltaW5nX2V2ZW50c19pbl9yZXZlcnNlX2Nocm9ub2xvZ2ljYWxfb3JkZXIgPC0gW11cbiAgOztcblxuICBsZXQgcmVjb3JkX3N0YXJ0IHQgZGVzY3JpcHRpb24gPVxuICAgIGlmIGFtX3JlY29yZGluZ1xuICAgIHRoZW4gKFxuICAgICAgYXNzZXJ0IChTdHJpbmcuaXNfZW1wdHkgdC5jdXJyZW50bHlfcnVubmluZ19kZXNjcmlwdGlvbik7XG4gICAgICB0LmN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uIDwtIGRlc2NyaXB0aW9uO1xuICAgICAgdC5jdXJyZW50bHlfcnVubmluZ19nY19zdGF0cyA8LSBHYy5xdWlja19zdGF0ICgpO1xuICAgICAgKCogY2FsbCBbVGltZV9ub3ddIGFzIGxhdGUgYXMgcG9zc2libGUgYmVmb3JlIHJ1bm5pbmcgdGhlIG1vZHVsZSBib2R5ICopXG4gICAgICB0LmN1cnJlbnRseV9ydW5uaW5nX3N0YXJ0X3RpbWUgPC0gVGltZV9ub3cubmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaCAoKSlcbiAgOztcblxuICBsZXQgcmVjb3JkX3VudGlsIHQgZGVzY3JpcHRpb24gPVxuICAgIGlmIGFtX3JlY29yZGluZ1xuICAgIHRoZW4gKFxuICAgICAgKCogY29tcHV0ZSBbVGltZV9ub3ddIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcnVubmluZyB0aGUgbW9kdWxlIGJvZHkgKilcbiAgICAgIGxldCB1bnRpbCA9IFRpbWVfbm93Lm5hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2ggKCkgaW5cbiAgICAgIGxldCBzdGFydCA9IHQuY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSBpblxuICAgICAgbGV0IGdjX3N0YXRzX2FmdGVyID0gR2MucXVpY2tfc3RhdCAoKSBpblxuICAgICAgbGV0IGdjX3N0YXRzX2JlZm9yZSA9IHQuY3VycmVudGx5X3J1bm5pbmdfZ2Nfc3RhdHMgaW5cbiAgICAgIGxldCBydW50aW1lID0gSW50NjMuKCAtICkgdW50aWwgc3RhcnQgaW5cbiAgICAgIGFzc2VydCAoU3RyaW5nLmVxdWFsIHQuY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gZGVzY3JpcHRpb24pO1xuICAgICAgbGV0IGdjX2V2ZW50cyA6IEdjX2V2ZW50cy50ID1cbiAgICAgICAgeyBtaW5vcl9jb2xsZWN0aW9ucyA9XG4gICAgICAgICAgICBnY19zdGF0c19hZnRlci5taW5vcl9jb2xsZWN0aW9ucyAtIGdjX3N0YXRzX2JlZm9yZS5taW5vcl9jb2xsZWN0aW9uc1xuICAgICAgICA7IG1ham9yX2NvbGxlY3Rpb25zID1cbiAgICAgICAgICAgIGdjX3N0YXRzX2FmdGVyLm1ham9yX2NvbGxlY3Rpb25zIC0gZ2Nfc3RhdHNfYmVmb3JlLm1ham9yX2NvbGxlY3Rpb25zXG4gICAgICAgIDsgY29tcGFjdGlvbnMgPSBnY19zdGF0c19hZnRlci5jb21wYWN0aW9ucyAtIGdjX3N0YXRzX2JlZm9yZS5jb21wYWN0aW9uc1xuICAgICAgICB9XG4gICAgICBpblxuICAgICAgbGV0IG5lc3RlZF90aW1pbmdfZXZlbnRzID1cbiAgICAgICAgbWF0Y2ggdC5uZXN0ZWRfdGltZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIG5lc3RlZCAtPiBMaXN0LnJldiBuZXN0ZWQudGltaW5nX2V2ZW50c19pbl9yZXZlcnNlX2Nocm9ub2xvZ2ljYWxfb3JkZXJcbiAgICAgIGluXG4gICAgICBsZXQgdGltaW5nX2V2ZW50IDogVGltaW5nX2V2ZW50LnQgPVxuICAgICAgICB7IGRlc2NyaXB0aW9uOyBydW50aW1lOyBnY19ldmVudHM7IG5lc3RlZF90aW1pbmdfZXZlbnRzIH1cbiAgICAgIGluXG4gICAgICB0LnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyXG4gICAgICA8LSB0aW1pbmdfZXZlbnQgOjogdC50aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlcjtcbiAgICAgIHJlc2V0IHQpXG4gIDs7XG5lbmRcblxubGV0IGRlZmluaXRpb25fdGltZXIgPSBUaW1lci5jcmVhdGUgKClcbmxldCBtb2R1bGVfdGltZXIgPSBUaW1lci5jcmVhdGUgfm5lc3RlZF90aW1lcjpkZWZpbml0aW9uX3RpbWVyICgpXG5sZXQgcmVjb3JkX3N0YXJ0IG1vZHVsZV9uYW1lID0gVGltZXIucmVjb3JkX3N0YXJ0IG1vZHVsZV90aW1lciBtb2R1bGVfbmFtZVxubGV0IHJlY29yZF91bnRpbCBtb2R1bGVfbmFtZSA9IFRpbWVyLnJlY29yZF91bnRpbCBtb2R1bGVfdGltZXIgbW9kdWxlX25hbWVcbmxldCByZWNvcmRfZGVmaW5pdGlvbl9zdGFydCBsb2MgPSBUaW1lci5yZWNvcmRfc3RhcnQgZGVmaW5pdGlvbl90aW1lciBsb2NcbmxldCByZWNvcmRfZGVmaW5pdGlvbl91bnRpbCBsb2MgPSBUaW1lci5yZWNvcmRfdW50aWwgZGVmaW5pdGlvbl90aW1lciBsb2NcblxubGV0IGdjX2V2ZW50c19zdWZmaXhfc3RyaW5nXG4gICAgICAoeyBtaW5vcl9jb2xsZWN0aW9uczsgbWFqb3JfY29sbGVjdGlvbnM7IGNvbXBhY3Rpb25zIH0gOiBHY19ldmVudHMudClcbiAgPVxuICBsZXQgdG9fbGlzdCBkZXNjcmlwdGlvbiBjb3VudCA9XG4gICAgaWYgY291bnQgPSAwIHRoZW4gW10gZWxzZSBbIEludC50b19zdHJpbmcgY291bnQgXiBcIiBcIiBeIGRlc2NyaXB0aW9uIF1cbiAgaW5cbiAgbGV0IHN0cmluZ3MgPVxuICAgIHRvX2xpc3QgXCJtaW5vciBjb2xsZWN0aW9uc1wiIG1pbm9yX2NvbGxlY3Rpb25zXG4gICAgQCB0b19saXN0IFwibWFqb3IgY29sbGVjdGlvbnNcIiBtYWpvcl9jb2xsZWN0aW9uc1xuICAgIEAgdG9fbGlzdCBcImNvbXBhY3Rpb25zXCIgY29tcGFjdGlvbnNcbiAgaW5cbiAgaWYgTGlzdC5pc19lbXB0eSBzdHJpbmdzIHRoZW4gXCJcIiBlbHNlIFwiOyBHQzogXCIgXiBTdHJpbmcuY29uY2F0IHN0cmluZ3MgfnNlcDpcIiwgXCJcbjs7XG5cbmxldCB3aXRoX2xlZnRfY29sdW1uX3JpZ2h0X2p1c3RpZmllZCBsaXN0ID1cbiAgbGV0IGxlZnRfY29sdW1uX3dpZHRoID1cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDowIH5mOihmdW4gd2lkdGggKGxlZnQsIF8pIC0+IEludC5tYXggd2lkdGggKFN0cmluZy5sZW5ndGggbGVmdCkpXG4gIGluXG4gIExpc3QubWFwIGxpc3QgfmY6KGZ1biAobGVmdCwgcmlnaHQpIC0+XG4gICAgUHJpbnRmLnNwcmludGYgXCIlKnMgJXNcIiBsZWZ0X2NvbHVtbl93aWR0aCBsZWZ0IHJpZ2h0KVxuOztcblxubGV0IHJlYyB0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MgbGlzdCB+aW5kZW50ID1cbiAgbGV0IGR1cmF0aW9uX3N0cmluZ3MgPVxuICAgIExpc3QubWFwIGxpc3QgfmY6KGZ1biAodGltaW5nX2V2ZW50IDogVGltaW5nX2V2ZW50LnQpIC0+IHRpbWluZ19ldmVudC5ydW50aW1lKVxuICAgIHw+IER1cmF0aW9uLnRvX3N0cmluZ193aXRoX3NhbWVfdW5pdFxuICBpblxuICBsZXQgcHJlZml4ID0gU3RyaW5nLm1ha2UgaW5kZW50ICcgJyBpblxuICBMaXN0Lm1hcDJfZXhuXG4gICAgZHVyYXRpb25fc3RyaW5nc1xuICAgIGxpc3RcbiAgICB+ZjooZnVuIGR1cmF0aW9uX3N0cmluZyB7IHJ1bnRpbWUgPSBfOyBkZXNjcmlwdGlvbjsgZ2NfZXZlbnRzOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyB9XG4gICAgICAgICAtPlxuICAgICAgICAgICAoIGR1cmF0aW9uX3N0cmluZ1xuICAgICAgICAgICAsIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgXiBnY19ldmVudHNfc3VmZml4X3N0cmluZyBnY19ldmVudHNcbiAgICAgICAgICAgICBeIFN0cmluZy5jb25jYXRcbiAgICAgICAgICAgICAgICAgKExpc3QubWFwXG4gICAgICAgICAgICAgICAgICAgICh0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MgbmVzdGVkX3RpbWluZ19ldmVudHMgfmluZGVudDooaW5kZW50ICsgNCkpXG4gICAgICAgICAgICAgICAgICAgIH5mOihmdW4gbGluZSAtPiBcIlxcblwiIF4gbGluZSkpICkpXG4gIHw+IHdpdGhfbGVmdF9jb2x1bW5fcmlnaHRfanVzdGlmaWVkXG4gIHw+IExpc3QubWFwIH5mOihmdW4gbGluZSAtPiBwcmVmaXggXiBsaW5lKVxuOztcblxubGV0IGZha2VfdGltaW5nX2V2ZW50cyA9XG4gIGxldCBnY19ldmVudHMgaSA6IEdjX2V2ZW50cy50ID1cbiAgICB7IG1pbm9yX2NvbGxlY3Rpb25zID0gKGlmIGkgJSAyID0gMSB0aGVuIDEgZWxzZSAwKVxuICAgIDsgbWFqb3JfY29sbGVjdGlvbnMgPSAoaWYgaSAlIDQgPSAzIHRoZW4gMSBlbHNlIDApXG4gICAgOyBjb21wYWN0aW9ucyA9IChpZiBpICUgOCA9IDcgdGhlbiAxIGVsc2UgMClcbiAgICB9XG4gIGluXG4gIGxhenlcbiAgICAoTGlzdC5pbml0IDEyIH5mOihmdW4gaSA6IFRpbWluZ19ldmVudC50IC0+XG4gICAgICAgeyBkZXNjcmlwdGlvbiA9IFByaW50Zi5zcHJpbnRmIFwiRmFrZV9fRGVwZW5kZW5jeV8lZFwiIChpICsgMSlcbiAgICAgICA7IHJ1bnRpbWUgPSBJbnQ2My5vZl9pbnQgKDkwMCAqIChpICsgMSkpXG4gICAgICAgOyBnY19ldmVudHMgPSBnY19ldmVudHMgaVxuICAgICAgIDsgbmVzdGVkX3RpbWluZ19ldmVudHMgPVxuICAgICAgICAgICAoaWYgKGkgKyAxKSAlIDQgPSAwXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgIExpc3QuaW5pdCAoaSArIDEpIH5mOihmdW4gaiA6IFRpbWluZ19ldmVudC50IC0+XG4gICAgICAgICAgICAgICAgeyBkZXNjcmlwdGlvbiA9IFByaW50Zi5zcHJpbnRmIFwiTGluZSAlZFwiIChqICsgMSlcbiAgICAgICAgICAgICAgICA7IHJ1bnRpbWUgPSBJbnQ2My5vZl9pbnQgKDkwMCAqIChqICsgMSkpXG4gICAgICAgICAgICAgICAgOyBnY19ldmVudHMgPSBnY19ldmVudHMgalxuICAgICAgICAgICAgICAgIDsgbmVzdGVkX3RpbWluZ19ldmVudHMgPSBbXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBlbHNlIFtdKVxuICAgICAgIH0pKVxuOztcblxubGV0IHByaW50X3JlY29yZGVkX3RpbWluZ19ldmVudHMgdGltaW5nX2V2ZW50cyA9XG4gIGxldCBub3RpZnlfb2Zfb3ZlcnJpZGluZyAoKSA9XG4gICAgU3RkaW8ucHJpbnRfZW5kbGluZSBcInBweF9tb2R1bGVfdGltZXI6IG92ZXJyaWRpbmcgdGltZSBtZWFzdXJlbWVudHMgZm9yIHRlc3RpbmdcIlxuICBpblxuICBsZXQgdGltaW5nX2V2ZW50cyA9XG4gICAgbWF0Y2ggT3B0aW9uLnZhbHVlX2V4biBhbV9yZWNvcmRpbmdfdmFsdWUgd2l0aFxuICAgIHwgXCJGQUtFX01PRFVMRVNcIiAtPlxuICAgICAgbm90aWZ5X29mX292ZXJyaWRpbmcgKCk7XG4gICAgICBmb3JjZSBmYWtlX3RpbWluZ19ldmVudHNcbiAgICB8IHN0cmluZyAtPlxuICAgICAgKG1hdGNoIER1cmF0aW9uLm9mX3N0cmluZyBzdHJpbmcgd2l0aFxuICAgICAgIHwgb3ZlcnJpZGUgLT5cbiAgICAgICAgIG5vdGlmeV9vZl9vdmVycmlkaW5nICgpO1xuICAgICAgICAgTGlzdC5tYXBpIHRpbWluZ19ldmVudHMgfmY6KGZ1biBpbmRleCAodGltaW5nX2V2ZW50IDogVGltaW5nX2V2ZW50LnQpIC0+XG4gICAgICAgICAgIGxldCBydW50aW1lID0gSW50NjMuKCAqICkgb3ZlcnJpZGUgKEludDYzLm9mX2ludCAoaW5kZXggKyAxKSkgaW5cbiAgICAgICAgICAgbGV0IG5lc3RlZF90aW1pbmdfZXZlbnRzID1cbiAgICAgICAgICAgICBMaXN0Lm1hcGlcbiAgICAgICAgICAgICAgIHRpbWluZ19ldmVudC5uZXN0ZWRfdGltaW5nX2V2ZW50c1xuICAgICAgICAgICAgICAgfmY6KGZ1biBpbmRleCBuZXN0ZWRfdGltaW5nX2V2ZW50IC0+XG4gICAgICAgICAgICAgICAgIGxldCBydW50aW1lID0gSW50NjMuKCAqICkgb3ZlcnJpZGUgKEludDYzLm9mX2ludCAoaW5kZXggKyAxKSkgaW5cbiAgICAgICAgICAgICAgICAgeyBuZXN0ZWRfdGltaW5nX2V2ZW50IHdpdGggcnVudGltZSB9KVxuICAgICAgICAgICBpblxuICAgICAgICAgICB7IHRpbWluZ19ldmVudCB3aXRoIHJ1bnRpbWU7IG5lc3RlZF90aW1pbmdfZXZlbnRzIH0pXG4gICAgICAgfCBleGNlcHRpb24gXyAtPiB0aW1pbmdfZXZlbnRzKVxuICBpblxuICB0aW1pbmdfZXZlbnRzIHw+IHRpbWluZ19ldmVudHNfdG9fc3RyaW5ncyB+aW5kZW50OjAgfD4gTGlzdC5pdGVyIH5mOlN0ZGlvLnByaW50X2VuZGxpbmVcbjs7XG5cbmxldCAoKSA9XG4gIGlmIGFtX3JlY29yZGluZ1xuICB0aGVuXG4gICAgU3RkbGliLmF0X2V4aXQgKGZ1biAoKSAtPlxuICAgICAgcHJpbnRfcmVjb3JkZWRfdGltaW5nX2V2ZW50c1xuICAgICAgICAoTGlzdC5yZXYgbW9kdWxlX3RpbWVyLnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyKSlcbjs7XG4iXX0=
