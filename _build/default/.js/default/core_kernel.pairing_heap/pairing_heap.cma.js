// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Pairing_heap
//# unitInfo: Requires: Assert_failure, Base__Container, Core, Core__Array, Core__Int, Core__List, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Pairing_heap$0 = "Pairing_heap",
    cst_pairing_heap$0 = "pairing_heap",
    cst_pairing_heap_src_pairing_h = "pairing_heap/src/pairing_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Base_Container = global_data.Base__Container;
   caml_call1(Ppx_module_timer_runtime[4], cst_Pairing_heap$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_pairing_heap$0);
   caml_call1(Expect_test_collector[5][1], cst_pairing_heap_src_pairing_h);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_pairing_heap$0, cst);
   var
    empty = Tuple_pool[3][4],
    is_empty = Tuple_pool[3][5],
    equal = Tuple_pool[3][7],
    cst_cannot_remove_from_a_diffe = "cannot remove from a different heap",
    cst_Heap_value_exn_node_was_re =
      "Heap.value_exn: node was removed from the heap",
    cst_Heap_top_exn_called_on_an_ = "Heap.top_exn called on an empty heap",
    _d_ = [0, cst_pairing_heap_src_pairing_h, 239, 10],
    _e_ = [0, cst_pairing_heap_src_pairing_h, 237, 8],
    _f_ = [0, cst_pairing_heap_src_pairing_h, 246, 2],
    _a_ = [0, cst_pairing_heap_src_pairing_h, 110, 4],
    cst_pairing_heap = cst_pairing_heap$0,
    cst_Pairing_heap = cst_Pairing_heap$0,
    dummy_id = -1;
   function child(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][4]);
   }
   function sibling(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][5]);
   }
   function prev(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][6]);
   }
   function id(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][7]);
   }
   function set_child(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][4], v);
   }
   function set_sibling(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][5], v);
   }
   function set_prev(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][6], v);
   }
   function value_exn(t, pool){
    if(caml_call1(is_empty, t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][3]);
   }
   function allocate(value, pool, id){
    var
     _H_ = caml_call1(empty, 0),
     _I_ = caml_call1(empty, 0),
     _J_ = caml_call1(empty, 0);
    return caml_call6(Tuple_pool[21], pool, value, _J_, _I_, _H_, id);
   }
   function free(t, pool){return caml_call2(Tuple_pool[16], pool, t);}
   function disconnect_sibling(t, pool){
    var sibling$0 = sibling(t, pool);
    if(1 - caml_call1(is_empty, sibling$0)){
     set_sibling(t, caml_call1(empty, 0), pool);
     set_prev(sibling$0, caml_call1(empty, 0), pool);
    }
    return sibling$0;
   }
   function disconnect_child(t, pool){
    var child$0 = child(t, pool);
    if(1 - caml_call1(is_empty, child$0)){
     set_child(t, caml_call1(empty, 0), pool);
     set_prev(child$0, caml_call1(empty, 0), pool);
    }
    return child$0;
   }
   function detach(t, pool){
    if(1 - caml_call1(is_empty, t)){
     var prev$0 = prev(t, pool);
     if(1 - caml_call1(is_empty, prev$0)){
      var
       relation_to_prev =
         caml_call2(equal, t, child(prev$0, pool)) ? -977688164 : -560648958;
      set_prev(t, caml_call1(empty, 0), pool);
      var sibling = disconnect_sibling(t, pool);
      if(-560648958 <= relation_to_prev)
       set_sibling(prev$0, sibling, pool);
      else
       set_child(prev$0, sibling, pool);
      if(1 - caml_call1(is_empty, sibling))
       return set_prev(sibling, prev$0, pool);
     }
    }
    return;
   }
   function create(capacity){
    var
     _E_ = caml_call1(Tuple_pool[3][4], 0),
     _F_ = caml_call1(Tuple_pool[3][4], 0),
     _G_ = [0, 0, caml_call1(Tuple_pool[3][4], 0), _F_, _E_, dummy_id];
    return caml_call3(Tuple_pool[9], Tuple_pool[1][21], capacity, _G_);
   }
   var _b_ = Core_Int[90], _c_ = Core_Int[60];
   function invariant(param, t){
    if
     (!
      caml_call1(is_empty, t[3])
      && ! caml_call1(is_empty, sibling(t[3], t[2])))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     _C_ = caml_call1(empty, 0),
     to_visit$2 = [0, [0, t[3], _C_, 0], 0],
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var
      to_visit$0 = to_visit[2],
      match = to_visit[1],
      maybe_parent_value = match[3],
      expected_prev = match[2],
      node = match[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      var this_value = value_exn(node, t[2]);
      if(! caml_call2(equal, prev(node, t[2]), expected_prev))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var
       _A_ =
         function(this_value){
           return function(parent_value){
            var _D_ = caml_call2(t[1], parent_value, this_value);
            if(caml_call2(Core[89], _D_, 0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);};
          }
          (this_value);
      caml_call2(Core_Option[41], maybe_parent_value, _A_);
      var
       _B_ =
         [0, [0, sibling(node, t[2]), node, maybe_parent_value], to_visit$0],
       to_visit$1 = [0, [0, child(node, t[2]), node, [0, this_value]], _B_],
       to_visit = to_visit$1;
     }
    }
   }
   function create$0(opt, cmp, param){
    if(opt) var sth = opt[1], min_size = sth; else var min_size = 1;
    var _z_ = caml_call1(empty, 0);
    return [0, cmp, create(min_size), _z_, 0];
   }
   function copy(param){
    var
     cmp = param[1],
     pool$0 = param[2],
     start = param[3],
     num_of_allocated_nodes = param[4],
     pool = create(caml_call1(Tuple_pool[11], pool$0));
    function copy_node(node, to_visit){
     if(caml_call1(is_empty, node))
      return [0, caml_call1(empty, 0), to_visit];
     var
      _x_ = id(node, pool$0),
      new_node = allocate(value_exn(node, pool$0), pool, _x_),
      _y_ = [0, [0, new_node, -560648958, sibling(node, pool$0)], to_visit],
      to_visit$0 = [0, [0, new_node, -977688164, child(node, pool$0)], _y_];
     return [0, new_node, to_visit$0];
    }
    var
     match$1 = copy_node(start, 0),
     to_visit$1 = match$1[2],
     new_start = match$1[1],
     to_visit = to_visit$1;
    for(;;){
     if(! to_visit) return [0, cmp, pool, new_start, num_of_allocated_nodes];
     var
      rest = to_visit[2],
      match = to_visit[1],
      node_to_copy = match[3],
      slot = match[2],
      node_to_update = match[1],
      match$0 = copy_node(node_to_copy, rest),
      to_visit$0 = match$0[2],
      new_node = match$0[1];
     if(-560648958 <= slot)
      set_sibling(node_to_update, new_node, pool);
     else
      set_child(node_to_update, new_node, pool);
     if(1 - caml_call1(is_empty, new_node))
      set_prev(new_node, node_to_update, pool);
     var to_visit = to_visit$0;
    }
   }
   function merge(t, root1, root2){
    if(caml_call1(is_empty, root1)) return root2;
    if(caml_call1(is_empty, root2)) return root1;
    function add_child(t, node, new_child){
     var pool = t[2], current_child = disconnect_child(node, pool);
     set_sibling(new_child, current_child, pool);
     if(1 - caml_call1(is_empty, current_child))
      set_prev(current_child, new_child, pool);
     set_child(node, new_child, pool);
     set_prev(new_child, node, pool);
     return node;
    }
    var
     v1 = value_exn(root1, t[2]),
     v2 = value_exn(root2, t[2]),
     _w_ = caml_call2(t[1], v1, v2);
    return caml_call2(Core[92], _w_, 0)
            ? add_child(t, root1, root2)
            : add_child(t, root2, root1);
   }
   function top_exn(t){
    return caml_call1(is_empty, t[3])
            ? caml_call1(Core[6], cst_Heap_top_exn_called_on_an_)
            : value_exn(t[3], t[2]);
   }
   function top(t){return caml_call1(is_empty, t[3]) ? 0 : [0, top_exn(t)];}
   function add_node(t$1, v){
    var t = t$1[2];
    if(caml_call1(Tuple_pool[14], t)){
     var t$0 = t$1[2];
     t$1[2] = caml_call2(Tuple_pool[13], 0, t$0);
    }
    t$1[4] = t$1[4] + 1 | 0;
    var _v_ = caml_call1(_c_, t$1[4]), node = allocate(v, t$1[2], _v_);
    t$1[3] = merge(t$1, t$1[3], node);
    return node;
   }
   function add(t, v){add_node(t, v); return 0;}
   var max_stack_depth = 1000;
   function loop(t, depth, head$0){
    if(! caml_call2(Core[88], depth, max_stack_depth)){
     if(caml_call1(is_empty, head$0)) return head$0;
     var next1$0 = disconnect_sibling(head$0, t[2]);
     if(caml_call1(is_empty, next1$0)) return head$0;
     var
      next2$0 = disconnect_sibling(next1$0, t[2]),
      _u_ = loop(t, depth + 1 | 0, next2$0);
     return merge(t, merge(t, head$0, next1$0), _u_);
    }
    var acc = 0, head = head$0;
    for(;;){
     if(caml_call1(is_empty, head))
      var match = acc;
     else{
      var next1 = disconnect_sibling(head, t[2]);
      if(! caml_call1(is_empty, next1)){
       var
        next2 = disconnect_sibling(next1, t[2]),
        acc$0 = [0, merge(t, head, next1), acc],
        acc = acc$0,
        head = next2;
       continue;
      }
      var match = [0, head, acc];
     }
     if(! match) return caml_call1(empty, 0);
     var h = match[1];
     if(! match[2]) return h;
     var
      xs = match[2],
      _t_ = function(acc, heap){return merge(t, acc, heap);};
     return caml_call3(Core_List[10], xs, h, _t_);
    }
   }
   function remove_non_empty(t, node){
    var pool = t[2];
    detach(node, pool);
    var
     head = disconnect_child(node, pool),
     merged_children = loop(t, 0, head),
     new_root =
       caml_call2(equal, t[3], node)
        ? merged_children
        : merge(t, t[3], merged_children);
    free(node, pool);
    t[3] = new_root;
    return 0;
   }
   function remove_top(t){
    var _s_ = 1 - caml_call1(is_empty, t[3]);
    return _s_ ? remove_non_empty(t, t[3]) : _s_;
   }
   function clear(t){
    var _q_ = 1 - caml_call1(is_empty, t[3]);
    if(_q_){
     var pool = t[2], node$0 = t[3], node = node$0;
     for(;;){
      var child$0 = child(node, pool), sibling$0 = sibling(node, pool);
      if(caml_call1(is_empty, child$0))
       if(caml_call1(is_empty, sibling$0)){
        var prev$0 = prev(node, pool);
        detach(node, pool);
        free(node, pool);
        if(! (1 - caml_call1(is_empty, prev$0))){
         t[3] = caml_call1(empty, 0);
         var _r_ = 0;
         break;
        }
        var node = prev$0;
       }
       else
        var node = sibling$0;
      else
       var node = child$0;
     }
    }
    else
     var _r_ = _q_;
    return _r_;
   }
   function pop_exn(t){var r = top_exn(t); remove_top(t); return r;}
   function pop(t){return caml_call1(is_empty, t[3]) ? 0 : [0, pop_exn(t)];}
   function pop_if(t, f){
    var match = top(t);
    if(! match) return 0;
    var v = match[1];
    return caml_call1(f, v) ? (remove_top(t), [0, v]) : 0;
   }
   function fold(t, init, f){
    var
     pool = t[2],
     to_visit$2 = [0, t[3], 0],
     acc = init,
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return acc;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else
      var
       _p_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _p_],
       acc$0 = caml_call2(f, acc, value_exn(node, pool)),
       acc = acc$0,
       to_visit = to_visit$1;
    }
   }
   function iter(t, f){
    var pool = t[2], to_visit$2 = [0, t[3], 0], to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      caml_call1(f, value_exn(node, pool));
      var
       _o_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _o_],
       to_visit = to_visit$1;
     }
    }
   }
   function length(t){var t$0 = t[2]; return caml_call1(Tuple_pool[12], t$0);}
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]);
   function is_empty$0(t){return caml_call1(is_empty, t[3]);}
   var
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_array(arr, cmp){
    var t = create$0([0, arr.length - 1], cmp, 0);
    function _n_(v){return add(t, v);}
    caml_call2(Core_Array[22], arr, _n_);
    return t;
   }
   function of_list(l, cmp){
    return of_array(caml_call1(Core_Array[52], l), cmp);
   }
   function sexp_of_t(f, t){
    var
     _k_ = t[1],
     _l_ = caml_call1(to_array, t),
     _m_ = caml_call2(Core_Array[111], _l_, _k_);
    return caml_call2(Core_Array[16], f, _m_);
   }
   function is_node_valid(t){
    var _j_ = t[2];
    return caml_call2(_b_, id(t[1], t[3][2]), _j_);
   }
   function value_exn$0(t){
    return is_node_valid(t)
            ? value_exn(t[1], t[3][2])
            : caml_call1(Core[6], cst_Heap_value_exn_node_was_re);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var x_001 = is_node_valid(t) ? [0, value_exn(t[1], t[3][2])] : 0;
    return caml_call2(Core[454], sexp_of_a, x_001);
   }
   function remove(t, token){
    if(! caml_call2(Core[246], t, token[3]))
     return caml_call1(Core[6], cst_cannot_remove_from_a_diffe);
    var _h_ = 1 - caml_call1(is_empty, token[1]);
    if(_h_){
     if(is_node_valid(token)) remove_non_empty(t, token[1]);
     token[1] = caml_call1(empty, 0);
     var _i_ = 0;
    }
    else
     var _i_ = _h_;
    return _i_;
   }
   function add_removable(t, v){
    var node = add_node(t, v);
    return [0, node, id(node, t[2]), t];
   }
   function update(t, token, v){remove(t, token); return add_removable(t, v);}
   function find_elt(t, f){
    var nodes$2 = [0, t[3], 0], nodes = nodes$2;
    for(;;){
     if(! nodes) return 0;
     var nodes$0 = nodes[2], node = nodes[1];
     if(caml_call1(is_empty, node))
      var nodes = nodes$0;
     else{
      if(caml_call1(f, value_exn(node, t[2])))
       return [0, [0, node, id(node, t[2]), t]];
      var
       _g_ = [0, child(node, t[2]), nodes$0],
       nodes$1 = [0, sibling(node, t[2]), _g_],
       nodes = nodes$1;
     }
    }
   }
   function value(t, heap){return value_exn(t, heap[2]);}
   var Elt = [0, value];
   function update$0(t, elt, v){
    remove_non_empty(t, elt);
    return add_node(t, v);
   }
   var Unsafe = [0, Elt, add_node, remove_non_empty, update$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_pairing_heap);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Pairing_heap);
   var
    Pairing_heap =
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       copy,
       [0, sexp_of_t$0, value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
   runtime.caml_register_global(26, Pairing_heap, cst_Pairing_heap$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVtcHR5IiwiaXNfZW1wdHkiLCJlcXVhbCIsImR1bW15X2lkIiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwic2libGluZyQwIiwiZGlzY29ubmVjdF9jaGlsZCIsImNoaWxkJDAiLCJkZXRhY2giLCJwcmV2JDAiLCJyZWxhdGlvbl90b19wcmV2IiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJpbnZhcmlhbnQiLCJ0b192aXNpdCQyIiwidG9fdmlzaXQiLCJ0b192aXNpdCQwIiwibWF5YmVfcGFyZW50X3ZhbHVlIiwiZXhwZWN0ZWRfcHJldiIsIm5vZGUiLCJ0aGlzX3ZhbHVlIiwicGFyZW50X3ZhbHVlIiwidG9fdmlzaXQkMSIsImNyZWF0ZSQwIiwib3B0IiwiY21wIiwic3RoIiwibWluX3NpemUiLCJjb3B5IiwicG9vbCQwIiwic3RhcnQiLCJudW1fb2ZfYWxsb2NhdGVkX25vZGVzIiwiY29weV9ub2RlIiwibmV3X25vZGUiLCJuZXdfc3RhcnQiLCJyZXN0Iiwibm9kZV90b19jb3B5Iiwic2xvdCIsIm5vZGVfdG9fdXBkYXRlIiwibWVyZ2UiLCJyb290MSIsInJvb3QyIiwiYWRkX2NoaWxkIiwibmV3X2NoaWxkIiwiY3VycmVudF9jaGlsZCIsInYxIiwidjIiLCJ0b3BfZXhuIiwidG9wIiwiYWRkX25vZGUiLCJ0JDEiLCJ0JDAiLCJhZGQiLCJtYXhfc3RhY2tfZGVwdGgiLCJsb29wIiwiZGVwdGgiLCJoZWFkJDAiLCJuZXh0MSQwIiwibmV4dDIkMCIsImFjYyIsImhlYWQiLCJuZXh0MSIsIm5leHQyIiwiYWNjJDAiLCJoIiwieHMiLCJoZWFwIiwicmVtb3ZlX25vbl9lbXB0eSIsIm1lcmdlZF9jaGlsZHJlbiIsIm5ld19yb290IiwicmVtb3ZlX3RvcCIsImNsZWFyIiwibm9kZSQwIiwicG9wX2V4biIsInIiLCJwb3AiLCJwb3BfaWYiLCJmIiwiZm9sZCIsImluaXQiLCJpdGVyIiwibGVuZ3RoIiwiaXRlciQwIiwibGVuZ3RoJDAiLCJpc19lbXB0eSQwIiwibWVtIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJvZl9hcnJheSIsImFyciIsIm9mX2xpc3QiLCJsIiwic2V4cF9vZl90IiwiaXNfbm9kZV92YWxpZCIsInZhbHVlX2V4biQwIiwic2V4cF9vZl90JDAiLCJzZXhwX29mX2EiLCJ4XzAwMSIsInJlbW92ZSIsInRva2VuIiwiYWRkX3JlbW92YWJsZSIsInVwZGF0ZSIsImZpbmRfZWx0Iiwibm9kZXMkMiIsIm5vZGVzIiwibm9kZXMkMCIsIm5vZGVzJDEiLCJ1cGRhdGUkMCIsImVsdCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvY29yZV9rZXJuZWwvcGFpcmluZ19oZWFwL3BhaXJpbmdfaGVhcC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBOEZNQTtJQUNBQztJQUNBQzs7Ozs7Ozs7Ozs7SUFUQUM7WUFXQUMsTUFBTUMsR0FBR0M7SUFBTyxrQ0FBUEEsTUFBSEQ7R0FBc0M7WUFDNUNFLFFBQVFGLEdBQUdDO0lBQU8sa0NBQVBBLE1BQUhEO0dBQXNDO1lBQzlDRyxLQUFLSCxHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUMzQ0ksR0FBR0osR0FBR0M7SUFBTyxrQ0FBUEEsTUFBSEQ7R0FBc0M7WUFHekNLLFVBQVVMLEdBQUVNLEdBQUdMO0lB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QVVBRztPQTFCQUo7T0FoQkFGO09Bc0RBa0I7T0FDQUM7T0FYQVg7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0F0UkFoRjtPQXVSQWlGO09BQ0FDO09BblFBeEU7T0F1UUEyRTtPQU1BRTtPQXZOQXBEO09BTkFEO09BY0FLO09Ba0dBa0I7T0FrQkFDO09BYUFJO09BTkFGO09BUUFHO09BekxBaEQ7V0E2UkU2RSxhQU5BRDtPQWtCRk07T0FUQUY7T0FjQUc7T0FLQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxubW9kdWxlIFBvaW50ZXIgPSBQb29sLlBvaW50ZXJcblxuKCogVGhpcyBwb29sIGhvbGRzIG5vZGVzIHRoYXQgd291bGQgYmUgcmVwcmVzZW50ZWQgbW9yZSB0cmFkaXRpb25hbGx5IGFzOlxuXG4gICB7W1xuICAgICB0eXBlICdhIHQgPVxuICAgICAgIHwgRW1wdHlcbiAgICAgICB8IEhlYXAgb2YgJ2EgKiAnYSB0IGxpc3QgXX1cblxuICAgV2Ugd2lsbCByZXByZXNlbnQgdGhlbSBhcyBhIGxlZnQtY2hpbGQsIHJpZ2h0LXNpYmxpbmcgdHJlZSBpbiBhIHRyaXBsZXRcbiAgICh2YWx1ZSAqIGxlZnRfY2hpbGQgKiByaWdodF9zaWJsaW5nKS4gIFRoZSBsZWZ0IGNoaWxkIGFuZCBhbGwgcmlnaHQgc2libGluZ3NcbiAgIG9mIHRoZSBsZWZ0IGNoaWxkIGZvcm0gYSBsaW5rZWQgbGlzdCByZXByZXNlbnRpbmcgdGhlIHN1YmhlYXBzIG9mIGEgZ2l2ZW4gaGVhcDpcblxuICAge3ZcbiAgICAgICAgIEFcbiAgICAgICAgL1xuICAgICAgIEIgLT4gQyAtPiBEIC0+IEUgLT4gRlxuICAgICAgLyAgICAgICAgIC8gICAgICAgICAvXG4gICAgIEcgICAgICAgICBILT5JLT5KICAgSy0+TFxuICAgdn0gKilcblxubW9kdWxlIE5vZGUgOiBzaWdcbiAgKCogRXhwb3NpbmcgW3ByaXZhdGUgaW50XSBpcyBhIHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LCBiZWNhdXNlIGl0IGFsbG93c1xuICAgICB0aGUgY29tcGlsZXIgdG8gc2tpcCB0aGUgd3JpdGUgYmFycmllci4gKilcblxuICB0eXBlICdhIHQgPSBwcml2YXRlIGludFxuXG4gIG1vZHVsZSBJZCA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgZW5kXG5cbiAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICB0eXBlICdhIG5vZGUgPSAnYSB0XG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY3JlYXRlIDogbWluX3NpemU6aW50IC0+ICdhIHRcbiAgICB2YWwgaXNfZnVsbCA6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBncm93IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIG5vZGUgLT4gJ2Egbm9kZSAqICdhIHRcbiAgZW5kXG5cbiAgKCoqIFthbGxvY2F0ZSB2IH5wb29sXSBhbGxvY2F0ZXMgYSBuZXcgbm9kZSBmcm9tIHRoZSBwb29sIHdpdGggbm8gY2hpbGQgb3Igc2libGluZyAqKVxuICB2YWwgYWxsb2NhdGUgOiAnYSAtPiBwb29sOidhIFBvb2wudCAtPiBpZDpJZC50IC0+ICdhIHRcblxuICAoKiogW2ZyZWUgdCB+cG9vbF0gZnJlZXMgW3RdIGZvciByZXVzZS4gIEl0IGlzIGFuIGVycm9yIHRvIGFjY2VzcyBbdF0gYWZ0ZXIgdGhpcy4gKilcbiAgdmFsIGZyZWUgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcblxuICAoKiogYSBzcGVjaWFsIFt0XSB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IG5vZGUgKilcbiAgdmFsIGVtcHR5IDogdW5pdCAtPiAnYSB0XG5cbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgKCoqIFt2YWx1ZV9leG4gdCB+cG9vbF0gcmV0dXJuIHRoZSB2YWx1ZSBvZiBbdF0sIHJhaXNlIGlmIFtpc19lbXB0eSB0XSAqKVxuICB2YWwgdmFsdWVfZXhuIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYVxuXG4gIHZhbCBpZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gSWQudFxuICB2YWwgY2hpbGQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcbiAgdmFsIHNpYmxpbmcgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW3ByZXYgdF0gaXMgZWl0aGVyIHRoZSBwYXJlbnQgb2YgW3RdIG9yIHRoZSBzaWJsaW5nIGltbWVkaWF0ZWx5IGxlZnQgb2YgW3RdICopXG4gIHZhbCBwcmV2IDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFthZGRfY2hpbGQgdCB+Y2hpbGQgfnBvb2xdIEFkZCBhIGNoaWxkIHRvIFt0XSwgcHJlc2VydmluZyBleGlzdGluZyBjaGlsZHJlbiBhc1xuICAgICAgc2libGluZ3Mgb2YgW2NoaWxkXS4gW3RdIGFuZCBbY2hpbGRdIHNob3VsZCBub3QgYmUgZW1wdHkgYW5kIFtjaGlsZF0gc2hvdWxkIGhhdmUgbm9cbiAgICAgIHNpYmxpbmcgYW5kIGhhdmUgbm8gcHJldiBub2RlLiAqKVxuICB2YWwgYWRkX2NoaWxkIDogJ2EgdCAtPiBjaGlsZDonYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcblxuICAoKiogZGlzY29ubmVjdCBhbmQgcmV0dXJuIHRoZSBzaWJsaW5nICopXG4gIHZhbCBkaXNjb25uZWN0X3NpYmxpbmcgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogZGlzY29ubmVjdCBhbmQgcmV0dXJuIHRoZSBjaGlsZCAqKVxuICB2YWwgZGlzY29ubmVjdF9jaGlsZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbZGV0YWNoIHQgfnBvb2xdIHJlbW92ZXMgW3RdIGZyb20gdGhlIHRyZWUsIGFkanVzdGluZyBwb2ludGVycyBhcm91bmQgaXQuIEFmdGVyXG4gICAgICBbZGV0YWNoXSwgW3RdIGlzIHRoZSByb290IG9mIGEgc3RhbmRhbG9uZSBoZWFwLCB3aGljaCBpcyBkZXRhY2hlZCBmcm9tIHRoZSBvcmlnaW5hbFxuICAgICAgaGVhcC4gKilcbiAgdmFsIGRldGFjaCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBJZCA9IEludFxuXG4gIGxldCBkdW1teV9pZCA6IElkLnQgPSAtMVxuXG4gIHR5cGUgJ2Egbm9kZSA9XG4gICAgKCdhLCAnYSBub2RlIFBvaW50ZXIudCwgJ2Egbm9kZSBQb2ludGVyLnQsICdhIG5vZGUgUG9pbnRlci50LCBJZC50KSBQb29sLlNsb3RzLnQ1XG5cbiAgdHlwZSAnYSB0ID0gJ2Egbm9kZSBQb2ludGVyLnRcblxuICBsZXQgZW1wdHkgPSBQb2ludGVyLm51bGxcbiAgbGV0IGlzX2VtcHR5ID0gUG9pbnRlci5pc19udWxsXG4gIGxldCBlcXVhbCA9IFBvaW50ZXIucGh5c19lcXVhbFxuICBsZXQgdmFsdWUgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDBcbiAgbGV0IGNoaWxkIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQxXG4gIGxldCBzaWJsaW5nIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQyXG4gIGxldCBwcmV2IHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQzXG4gIGxldCBpZCB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50NFxuXG4gICgqIGxldCBzZXRfdmFsdWUgICB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQwIHYgKilcbiAgbGV0IHNldF9jaGlsZCB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQxIHZcbiAgbGV0IHNldF9zaWJsaW5nIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDIgdlxuICBsZXQgc2V0X3ByZXYgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MyB2XG5cbiAgbGV0IHZhbHVlX2V4biB0IH5wb29sID1cbiAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICAgIHZhbHVlIHQgfnBvb2xcbiAgOztcblxuICBsZXQgYWxsb2NhdGUgdmFsdWUgfnBvb2wgfmlkID0gUG9vbC5uZXc1IHBvb2wgdmFsdWUgKGVtcHR5ICgpKSAoZW1wdHkgKCkpIChlbXB0eSAoKSkgaWRcbiAgbGV0IGZyZWUgdCB+cG9vbCA9IFBvb2wudW5zYWZlX2ZyZWUgcG9vbCB0XG5cbiAgbGV0IGRpc2Nvbm5lY3Rfc2libGluZyB0IH5wb29sID1cbiAgICBsZXQgc2libGluZyA9IHNpYmxpbmcgdCB+cG9vbCBpblxuICAgIGlmIG5vdCAoaXNfZW1wdHkgc2libGluZylcbiAgICB0aGVuIChcbiAgICAgIHNldF9zaWJsaW5nIHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgIHNldF9wcmV2IHNpYmxpbmcgKGVtcHR5ICgpKSB+cG9vbCk7XG4gICAgc2libGluZ1xuICA7O1xuXG4gIGxldCBkaXNjb25uZWN0X2NoaWxkIHQgfnBvb2wgPVxuICAgIGxldCBjaGlsZCA9IGNoaWxkIHQgfnBvb2wgaW5cbiAgICBpZiBub3QgKGlzX2VtcHR5IGNoaWxkKVxuICAgIHRoZW4gKFxuICAgICAgc2V0X2NoaWxkIHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgIHNldF9wcmV2IGNoaWxkIChlbXB0eSAoKSkgfnBvb2wpO1xuICAgIGNoaWxkXG4gIDs7XG5cbiAgbGV0IGFkZF9jaGlsZCB0IH5jaGlsZDpuZXdfY2hpbGQgfnBvb2wgPVxuICAgICgqIGFzc2VydGlvbnMgd2Ugd291bGQgbWFrZSwgYnV0IGZvciBzcGVlZDpcbiAgICAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICAgICAgIGFzc2VydCAobm90IChpc19lbXB0eSBuZXdfY2hpbGQpKTtcbiAgICAgICBhc3NlcnQgKGlzX2VtcHR5IChzaWJsaW5nIG5ld19jaGlsZCB+cG9vbCkpO1xuICAgICAgIGFzc2VydCAoaXNfZW1wdHkgKHByZXYgbmV3X2NoaWxkIH5wb29sKSk7XG4gICAgKilcbiAgICBsZXQgY3VycmVudF9jaGlsZCA9IGRpc2Nvbm5lY3RfY2hpbGQgdCB+cG9vbCBpblxuICAgICgqIGFkZCBbbmV3X2NoaWxkXSB0byB0aGUgbGlzdCBvZiBbdF0ncyBjaGlsZHJlbiAod2hpY2ggbWF5IGJlIGVtcHR5KSAqKVxuICAgIHNldF9zaWJsaW5nIG5ld19jaGlsZCBjdXJyZW50X2NoaWxkIH5wb29sO1xuICAgIGlmIG5vdCAoaXNfZW1wdHkgY3VycmVudF9jaGlsZCkgdGhlbiBzZXRfcHJldiBjdXJyZW50X2NoaWxkIG5ld19jaGlsZCB+cG9vbDtcbiAgICBzZXRfY2hpbGQgdCBuZXdfY2hpbGQgfnBvb2w7XG4gICAgc2V0X3ByZXYgbmV3X2NoaWxkIHQgfnBvb2xcbiAgOztcblxuICBsZXQgZGV0YWNoIHQgfnBvb2wgPVxuICAgIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgICB0aGVuIChcbiAgICAgIGxldCBwcmV2ID0gcHJldiB0IH5wb29sIGluXG4gICAgICBpZiBub3QgKGlzX2VtcHR5IHByZXYpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHJlbGF0aW9uX3RvX3ByZXYgPSBpZiBlcXVhbCB0IChjaGlsZCBwcmV2IH5wb29sKSB0aGVuIGBjaGlsZCBlbHNlIGBzaWJsaW5nIGluXG4gICAgICAgIHNldF9wcmV2IHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgICAgbGV0IHNpYmxpbmcgPSBkaXNjb25uZWN0X3NpYmxpbmcgdCB+cG9vbCBpblxuICAgICAgICAobWF0Y2ggcmVsYXRpb25fdG9fcHJldiB3aXRoXG4gICAgICAgICB8IGBjaGlsZCAtPiBzZXRfY2hpbGQgcHJldiBzaWJsaW5nIH5wb29sXG4gICAgICAgICB8IGBzaWJsaW5nIC0+IHNldF9zaWJsaW5nIHByZXYgc2libGluZyB+cG9vbCk7XG4gICAgICAgIGlmIG5vdCAoaXNfZW1wdHkgc2libGluZykgdGhlbiBzZXRfcHJldiBzaWJsaW5nIHByZXYgfnBvb2wpKVxuICA7O1xuXG4gIG1vZHVsZSBQb29sID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2Egbm9kZSBQb29sLnRcbiAgICB0eXBlIG5vbnJlYyAnYSBub2RlID0gJ2Egbm9kZSBQb2ludGVyLnRcblxuICAgIGxldCBjcmVhdGUgKHR5cGUgYSkgfm1pbl9zaXplOmNhcGFjaXR5IDogYSB0ID1cbiAgICAgIFBvb2wuY3JlYXRlXG4gICAgICAgIFBvb2wuU2xvdHMudDVcbiAgICAgICAgfmNhcGFjaXR5XG4gICAgICAgIH5kdW1teTpcbiAgICAgICAgICAoIChPYmoubWFnaWMgTm9uZSA6IGEpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBkdW1teV9pZCApXG4gICAgOztcblxuICAgIGxldCBpc19mdWxsIHQgPSBQb29sLmlzX2Z1bGwgdFxuICAgIGxldCBsZW5ndGggdCA9IFBvb2wubGVuZ3RoIHRcbiAgICBsZXQgZ3JvdyB0ID0gUG9vbC5ncm93IHRcblxuICAgIGxldCBjb3B5IHQgc3RhcnQgPVxuICAgICAgbGV0IHQnID0gY3JlYXRlIH5taW5fc2l6ZTooUG9vbC5jYXBhY2l0eSB0KSBpblxuICAgICAgbGV0IGNvcHlfbm9kZSBub2RlIHRvX3Zpc2l0ID1cbiAgICAgICAgaWYgaXNfZW1wdHkgbm9kZVxuICAgICAgICB0aGVuIGVtcHR5ICgpLCB0b192aXNpdFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiB3ZSB1c2UgdGhlIHNhbWUgaWQsIGJ1dCB0aGF0J3Mgb2sgc2luY2UgaWRzIHNob3VsZCBiZSB1bmlxdWUgcGVyIGhlYXAgKilcbiAgICAgICAgICBsZXQgbmV3X25vZGUgPVxuICAgICAgICAgICAgYWxsb2NhdGUgKHZhbHVlX2V4biBub2RlIH5wb29sOnQpIH5wb29sOnQnIH5pZDooaWQgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHRvX3Zpc2l0ID1cbiAgICAgICAgICAgIChuZXdfbm9kZSwgYGNoaWxkLCBjaGlsZCBub2RlIH5wb29sOnQpXG4gICAgICAgICAgICA6OiAobmV3X25vZGUsIGBzaWJsaW5nLCBzaWJsaW5nIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICAgIDo6IHRvX3Zpc2l0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBuZXdfbm9kZSwgdG9fdmlzaXQpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBsb29wIHRvX3Zpc2l0ID1cbiAgICAgICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgKG5vZGVfdG9fdXBkYXRlLCBzbG90LCBub2RlX3RvX2NvcHkpIDo6IHJlc3QgLT5cbiAgICAgICAgICBsZXQgbmV3X25vZGUsIHRvX3Zpc2l0ID0gY29weV9ub2RlIG5vZGVfdG9fY29weSByZXN0IGluXG4gICAgICAgICAgKG1hdGNoIHNsb3Qgd2l0aFxuICAgICAgICAgICB8IGBjaGlsZCAtPiBzZXRfY2hpbGQgbm9kZV90b191cGRhdGUgbmV3X25vZGUgfnBvb2w6dCdcbiAgICAgICAgICAgfCBgc2libGluZyAtPiBzZXRfc2libGluZyBub2RlX3RvX3VwZGF0ZSBuZXdfbm9kZSB+cG9vbDp0Jyk7XG4gICAgICAgICAgaWYgbm90IChpc19lbXB0eSBuZXdfbm9kZSkgdGhlbiBzZXRfcHJldiBuZXdfbm9kZSBub2RlX3RvX3VwZGF0ZSB+cG9vbDp0JztcbiAgICAgICAgICBsb29wIHRvX3Zpc2l0XG4gICAgICBpblxuICAgICAgbGV0IG5ld19zdGFydCwgdG9fdmlzaXQgPSBjb3B5X25vZGUgc3RhcnQgW10gaW5cbiAgICAgIGxvb3AgdG9fdmlzaXQ7XG4gICAgICBuZXdfc3RhcnQsIHQnXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAnYSB0ID1cbiAgeyAoKiBjbXAgaXMgcGxhY2VkIGZpcnN0IHRvIHNob3J0LWNpcmN1aXQgcG9seW1vcnBoaWMgY29tcGFyZSAqKVxuICAgIGNtcCA6ICdhIC0+ICdhIC0+IGludFxuICA7IG11dGFibGUgcG9vbCA6ICdhIE5vZGUuUG9vbC50XG4gIDsgKCogaW52YXJpYW50OiAgW3Jvb3RdIG5ldmVyIGhhcyBhIHNpYmxpbmcgKilcbiAgICBtdXRhYmxlIHJvb3QgOiAnYSBOb2RlLnRcbiAgOyBtdXRhYmxlIG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgOiBpbnRcbiAgfVxuXG5sZXQgaW52YXJpYW50IF8gdCA9XG4gIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IChub2RlLCBleHBlY3RlZF9wcmV2LCBtYXliZV9wYXJlbnRfdmFsdWUpIDo6IHJlc3QgLT5cbiAgICAgIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBub2RlKVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0aGlzX3ZhbHVlID0gTm9kZS52YWx1ZV9leG4gbm9kZSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgYXNzZXJ0IChOb2RlLmVxdWFsIChOb2RlLnByZXYgbm9kZSB+cG9vbDp0LnBvb2wpIGV4cGVjdGVkX3ByZXYpO1xuICAgICAgICBPcHRpb24uaXRlciBtYXliZV9wYXJlbnRfdmFsdWUgfmY6KGZ1biBwYXJlbnRfdmFsdWUgLT5cbiAgICAgICAgICBhc3NlcnQgKHQuY21wIHBhcmVudF92YWx1ZSB0aGlzX3ZhbHVlIDw9IDApKTtcbiAgICAgICAgbG9vcFxuICAgICAgICAgICgoTm9kZS5jaGlsZCBub2RlIH5wb29sOnQucG9vbCwgbm9kZSwgU29tZSB0aGlzX3ZhbHVlKVxuICAgICAgICAgICA6OiAoTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2w6dC5wb29sLCBub2RlLCBtYXliZV9wYXJlbnRfdmFsdWUpXG4gICAgICAgICAgIDo6IHJlc3QpKVxuICAgICAgZWxzZSBsb29wIHJlc3RcbiAgaW5cbiAgYXNzZXJ0IChOb2RlLmlzX2VtcHR5IHQucm9vdCB8fCBOb2RlLmlzX2VtcHR5IChOb2RlLnNpYmxpbmcgdC5yb290IH5wb29sOnQucG9vbCkpO1xuICBsb29wIFsgdC5yb290LCBOb2RlLmVtcHR5ICgpLCBOb25lIF1cbjs7XG5cbmxldCBjcmVhdGUgPyhtaW5fc2l6ZSA9IDEpIH5jbXAgKCkgPVxuICB7IGNtcFxuICA7IHBvb2wgPSBOb2RlLlBvb2wuY3JlYXRlIH5taW5fc2l6ZVxuICA7IHJvb3QgPSBOb2RlLmVtcHR5ICgpXG4gIDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyA9IDBcbiAgfVxuOztcblxubGV0IGNvcHkgeyBjbXA7IHBvb2w7IHJvb3Q7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgfSA9XG4gIGxldCByb290LCBwb29sID0gTm9kZS5Qb29sLmNvcHkgcG9vbCByb290IGluXG4gIHsgY21wOyBwb29sOyByb290OyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIH1cbjs7XG5cbmxldCBhbGxvY2F0ZSB0IHYgPVxuICBpZiBOb2RlLlBvb2wuaXNfZnVsbCB0LnBvb2wgdGhlbiB0LnBvb2wgPC0gTm9kZS5Qb29sLmdyb3cgdC5wb29sO1xuICB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgPC0gdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzICsgMTtcbiAgTm9kZS5hbGxvY2F0ZSB2IH5wb29sOnQucG9vbCB+aWQ6KE5vZGUuSWQub2ZfaW50IHQubnVtX29mX2FsbG9jYXRlZF9ub2Rlcylcbjs7XG5cbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbWF0Y2ggcm9vdDEsIHJvb3QyIHdpdGhcbiAgICAgfCBOb25lLCBoIHwgaCwgTm9uZSAtPiBoXG4gICAgIHwgU29tZSAoTm9kZSAodjEsIGNoaWxkcmVuMSkpLCBTb21lIChOb2RlICh2MiwgY2hpbGRyZW4yKSkgLT5cbiAgICAgICBpZiB2MSA8IHYyXG4gICAgICAgdGhlbiBTb21lIChOb2RlICh2MSwgcm9vdDIgOjogY2hpbGRyZW4xKSlcbiAgICAgICBlbHNlIFNvbWUgKE5vZGUgKHYyLCByb290MSA6OiBjaGlsZHJlbjIpKVxuICAgXX1cblxuICAgVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG5laXRoZXIgcm9vdCBoYXMgYSBwcmV2IG5vZGUgKHVzdWFsbHkgYmVjYXVzZSB0aGUgaW5wdXRzIGNvbWVcbiAgIGZyb20gW2Rpc2Nvbm5lY3RfKl0gb3IgYXJlIHRoZSB0b3Agb2YgdGhlIGhlYXAgb3IgYXJlIHRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbikuICopXG5sZXQgbWVyZ2UgdCByb290MSByb290MiA9XG4gIGlmIE5vZGUuaXNfZW1wdHkgcm9vdDFcbiAgdGhlbiByb290MlxuICBlbHNlIGlmIE5vZGUuaXNfZW1wdHkgcm9vdDJcbiAgdGhlbiByb290MVxuICBlbHNlIChcbiAgICBsZXQgYWRkX2NoaWxkIHQgbm9kZSB+Y2hpbGQgPVxuICAgICAgTm9kZS5hZGRfY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wgfmNoaWxkO1xuICAgICAgbm9kZVxuICAgIGluXG4gICAgbGV0IHYxID0gTm9kZS52YWx1ZV9leG4gcm9vdDEgfnBvb2w6dC5wb29sIGluXG4gICAgbGV0IHYyID0gTm9kZS52YWx1ZV9leG4gcm9vdDIgfnBvb2w6dC5wb29sIGluXG4gICAgaWYgdC5jbXAgdjEgdjIgPCAwXG4gICAgdGhlbiBhZGRfY2hpbGQgdCByb290MSB+Y2hpbGQ6cm9vdDJcbiAgICBlbHNlIGFkZF9jaGlsZCB0IHJvb3QyIH5jaGlsZDpyb290MSlcbjs7XG5cbmxldCB0b3BfZXhuIHQgPVxuICBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdFxuICB0aGVuIGZhaWx3aXRoIFwiSGVhcC50b3BfZXhuIGNhbGxlZCBvbiBhbiBlbXB0eSBoZWFwXCJcbiAgZWxzZSBOb2RlLnZhbHVlX2V4biB0LnJvb3QgfnBvb2w6dC5wb29sXG47O1xuXG5sZXQgdG9wIHQgPSBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3BfZXhuIHQpXG5cbmxldCBhZGRfbm9kZSB0IHYgPVxuICBsZXQgbm9kZSA9IGFsbG9jYXRlIHQgdiBpblxuICB0LnJvb3QgPC0gbWVyZ2UgdCB0LnJvb3Qgbm9kZTtcbiAgbm9kZVxuOztcblxubGV0IGFkZCB0IHYgPSBpZ25vcmUgKGFkZF9ub2RlIHQgdiA6IF8gTm9kZS50KVxuXG4oKiBbbWVyZ2VfcGFpcnNdIHRha2VzIGEgbGlzdCBvZiBoZWFwIHJvb3RzIGFuZCBtZXJnZXMgY29uc2VjdXRpdmUgcGFpcnMsIHJlZHVjaW5nIHRoZVxuICAgbGlzdCBvZiBsZW5ndGggbiB0byBuLzIuICBUaGVuIGl0IG1lcmdlcyB0aGUgbWVyZ2VkIHBhaXJzIGludG8gYSBzaW5nbGUgaGVhcC4gIE9uZVxuICAgaW50dWl0aW9uIGlzIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBsaWtlIGJ1aWxkaW5nIGEgc2luZ2xlIGxldmVsIG9mIGEgYmluYXJ5IHRyZWUuXG5cbiAgIFRoZSBvdXRwdXQgaGVhcCBkb2VzIG5vdCBjb250YWluIHRoZSB2YWx1ZSB0aGF0IHdhcyBhdCB0aGUgcm9vdCBvZiB0aGUgaW5wdXQgaGVhcC5cblxuICAgV2UgYnJlYWsgdGhlIGZ1bmN0aW9uIGludG8gdHdvIHBhcnRzLiAgQSBmaXJzdCBzdGFnZSB0aGF0IGlzIHdpbGxpbmcgdG8gdXNlIGxpbWl0ZWRcbiAgIHN0YWNrIGluc3RlYWQgb2YgaGVhcCBhbGxvY2F0aW9uIGZvciBib29ra2VlcGluZywgYW5kIGEgc2Vjb25kIHN0YWdlIHRoYXQgc2hpZnRzIHRvXG4gICB1c2luZyBhIGxpc3QgYXMgYW4gYWNjdW11bGF0b3IgaWYgd2UgZ28gdG9vIGRlZXAuXG5cbiAgIFRoaXMgY2FuIGJlIG1hZGUgdGFpbCByZWN1cnNpdmUgYW5kIG5vbi1hbGxvY2F0aW5nIGJ5IHN0YXJ0aW5nIHdpdGggYW4gZW1wdHkgaGVhcCBhbmRcbiAgIG1lcmdpbmcgbWVyZ2VkIHBhaXJzIGludG8gaXQuIFVuZm9ydHVuYXRlbHkgdGhpcyBcImxlZnQgZm9sZFwiIHZlcnNpb24gaXMgbm90IHdoYXQgaXNcbiAgIGRlc2NyaWJlZCBpbiB0aGUgb3JpZ2luYWwgcGFwZXIgYnkgRnJlZG1hbiBldCBhbC47IHRoZXkgc3BlY2lmaWNhbGx5IHNheSB0aGF0XG4gICBjaGlsZHJlbiBzaG91bGQgYmUgbWVyZ2VkIHRvZ2V0aGVyIGZyb20gdGhlIGVuZCBvZiB0aGUgbGlzdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgbGlzdC4gKFttZXJnZV0gaXMgbm90IGFzc29jaWF0aXZlLCBzbyBvcmRlciBtYXR0ZXJzLilcbiopXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgICAgIHwgW10gLT4gYWNjXG4gICAgICAgfCBbaGVhZF0gLT4gaGVhZCA6OiBhY2NcbiAgICAgICB8IGhlYWQgOjogbmV4dDEgOjogbmV4dDIgLT4gbG9vcCAobWVyZ2UgaGVhZCBuZXh0MSA6OiBhY2MpIG5leHQyXG4gICAgIGluXG4gICAgIG1hdGNoIGxvb3AgW10gY2hpbGRyZW4gd2l0aFxuICAgICB8IFtdIC0+IE5vbmVcbiAgICAgfCBbaF0gLT4gU29tZSBoXG4gICAgIHwgeCA6OiB4cyAtPiBTb21lIChMaXN0LmZvbGQgeHMgfmluaXQ6eCB+ZjptZXJnZSlcbiAgIF19XG4qKVxubGV0IGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBoZWFkID1cbiAgbGV0IHJlYyBsb29wIGFjYyBoZWFkID1cbiAgICBpZiBOb2RlLmlzX2VtcHR5IGhlYWRcbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgKFxuICAgICAgbGV0IG5leHQxID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgaGVhZCB+cG9vbDp0LnBvb2wgaW5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbmV4dDFcbiAgICAgIHRoZW4gaGVhZCA6OiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV4dDIgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBuZXh0MSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgbG9vcCAobWVyZ2UgdCBoZWFkIG5leHQxIDo6IGFjYykgbmV4dDIpKVxuICBpblxuICBtYXRjaCBsb29wIFtdIGhlYWQgd2l0aFxuICB8IFtdIC0+IE5vZGUuZW1wdHkgKClcbiAgfCBbIGggXSAtPiBoXG4gIHwgeCA6OiB4cyAtPiBMaXN0LmZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIGFjYyBoZWFwIC0+IG1lcmdlIHQgYWNjIGhlYXApXG47O1xuXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIG1hdGNoIHQucm9vdCB3aXRoXG4gICAgIHwgTm9kZSAoXywgY2hpbGRyZW4pIC0+XG4gICAgICAgbGV0IHJlYyBsb29wIGRlcHRoIGNoaWxkcmVuID1cbiAgICAgICAgIGlmIGRlcHRoID49IG1heF9zdGFja19kZXB0aFxuICAgICAgICAgdGhlbiBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgY2hpbGRlblxuICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICBtYXRjaCBjaGlsZHJlbiB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgICAgICB8IFtoZWFkXSAtPiBTb21lIGhlYWRcbiAgICAgICAgICAgfCBoZWFkIDo6IG5leHQxIDo6IG5leHQyIC0+XG4gICAgICAgICAgICAgbWVyZ2UgKG1lcmdlIGhlYWQgbmV4dDEpIChsb29wIChkZXB0aCArIDEpIG5leHQyKVxuICAgICAgICAgZW5kXG4gICAgICAgaW5cbiAgICAgICBsb29wIDAgY2hpbGRyZW5cbiAgIF19XG4qKVxubGV0IG1lcmdlX3BhaXJzID1cbiAgbGV0IG1heF9zdGFja19kZXB0aCA9IDFfMDAwIGluXG4gIGxldCByZWMgbG9vcCB0IGRlcHRoIGhlYWQgPVxuICAgIGlmIGRlcHRoID49IG1heF9zdGFja19kZXB0aFxuICAgIHRoZW4gYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGhlYWRcbiAgICBlbHNlIGlmIE5vZGUuaXNfZW1wdHkgaGVhZFxuICAgIHRoZW4gaGVhZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IG5leHQxID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgaGVhZCB+cG9vbDp0LnBvb2wgaW5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbmV4dDFcbiAgICAgIHRoZW4gaGVhZFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0MiA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIG5leHQxIH5wb29sOnQucG9vbCBpblxuICAgICAgICAoKiBtZXJnZSB0aGUgZmlyc3QgdHdvIG5vZGVzIGluIG91ciBsaXN0LCBhbmQgdGhlbiBtZXJnZSB0aGUgcmVzdWx0IHdpdGggdGhlXG4gICAgICAgICAgIHJlc3VsdCBvZiByZWN1cnNpdmVseSBjYWxsaW5nIG1lcmdlX3BhaXJzIG9uIHRoZSB0YWlsICopXG4gICAgICAgIG1lcmdlIHQgKG1lcmdlIHQgaGVhZCBuZXh0MSkgKGxvb3AgdCAoZGVwdGggKyAxKSBuZXh0MikpKVxuICBpblxuICBmdW4gdCBoZWFkIC0+IGxvb3AgdCAwIGhlYWRcbjs7XG5cbmxldCByZW1vdmVfbm9uX2VtcHR5IHQgbm9kZSA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIE5vZGUuZGV0YWNoIG5vZGUgfnBvb2w7XG4gIGxldCBtZXJnZWRfY2hpbGRyZW4gPSBtZXJnZV9wYWlycyB0IChOb2RlLmRpc2Nvbm5lY3RfY2hpbGQgbm9kZSB+cG9vbCkgaW5cbiAgbGV0IG5ld19yb290ID1cbiAgICBpZiBOb2RlLmVxdWFsIHQucm9vdCBub2RlIHRoZW4gbWVyZ2VkX2NoaWxkcmVuIGVsc2UgbWVyZ2UgdCB0LnJvb3QgbWVyZ2VkX2NoaWxkcmVuXG4gIGluXG4gIE5vZGUuZnJlZSBub2RlIH5wb29sO1xuICB0LnJvb3QgPC0gbmV3X3Jvb3Rcbjs7XG5cbmxldCByZW1vdmVfdG9wIHQgPSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdC5yb290KSB0aGVuIHJlbW92ZV9ub25fZW1wdHkgdCB0LnJvb3RcblxuKCogTm90ZSB0aGF0IHRoaXMgaXMgdGFpbC1yZWN1cnNpdmUgYW5kIHRoYXQgZWFjaCBub2RlIGlzIHZpc2l0ZWQgYXQgbW9zdCAzIHRpbWVzIChvbmNlXG4gICBmb3IgZWFjaCBicmFuY2ggb2YgdGhlIFwiaWZcIiksIHNvIGl0IHRha2VzIGxpbmVhciB0aW1lIGFuZCBjb25zdGFudCBzcGFjZS4gKilcbmxldCByZWMgcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgbm9kZSB+cG9vbCA9XG4gIGxldCBjaGlsZCA9IE5vZGUuY2hpbGQgbm9kZSB+cG9vbCBpblxuICBsZXQgc2libGluZyA9IE5vZGUuc2libGluZyBub2RlIH5wb29sIGluXG4gIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBjaGlsZClcbiAgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBjaGlsZCB+cG9vbFxuICBlbHNlIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBzaWJsaW5nKVxuICB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHNpYmxpbmcgfnBvb2xcbiAgZWxzZSAoXG4gICAgbGV0IHByZXYgPSBOb2RlLnByZXYgbm9kZSB+cG9vbCBpblxuICAgIE5vZGUuZGV0YWNoIG5vZGUgfnBvb2w7XG4gICAgTm9kZS5mcmVlIG5vZGUgfnBvb2w7XG4gICAgaWYgbm90IChOb2RlLmlzX2VtcHR5IHByZXYpIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgcHJldiB+cG9vbClcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgaWYgbm90IChOb2RlLmlzX2VtcHR5IHQucm9vdClcbiAgdGhlbiAoXG4gICAgcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgdC5yb290IH5wb29sOnQucG9vbDtcbiAgICB0LnJvb3QgPC0gTm9kZS5lbXB0eSAoKSlcbjs7XG5cbmxldCBwb3BfZXhuIHQgPVxuICBsZXQgciA9IHRvcF9leG4gdCBpblxuICByZW1vdmVfdG9wIHQ7XG4gIHJcbjs7XG5cbmxldCBwb3AgdCA9IGlmIE5vZGUuaXNfZW1wdHkgdC5yb290IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9leG4gdClcblxubGV0IHBvcF9pZiB0IGYgPVxuICBtYXRjaCB0b3AgdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB2IC0+XG4gICAgaWYgZiB2XG4gICAgdGhlbiAoXG4gICAgICByZW1vdmVfdG9wIHQ7XG4gICAgICBTb21lIHYpXG4gICAgZWxzZSBOb25lXG47O1xuXG4oKiBwYWlyaW5nIGhlYXBzIGFyZSBub3QgYmFsYW5jZWQgdHJlZXMsIGFuZCB0aGVyZWZvcmUgd2UgY2FuJ3QgcmVseSBvbiBhIGJhbGFuY2VcbiAgIHByb3BlcnR5IHRvIHN0b3Agb3Vyc2VsdmVzIGZyb20gb3ZlcmZsb3dpbmcgdGhlIHN0YWNrLiAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIGxldCByZWMgbG9vcCBhY2MgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgbm9kZSA6OiByZXN0IC0+XG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5vZGVcbiAgICAgIHRoZW4gbG9vcCBhY2MgcmVzdFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB0b192aXNpdCA9IE5vZGUuc2libGluZyB+cG9vbCBub2RlIDo6IE5vZGUuY2hpbGQgfnBvb2wgbm9kZSA6OiByZXN0IGluXG4gICAgICAgIGxvb3AgKGYgYWNjIChOb2RlLnZhbHVlX2V4biB+cG9vbCBub2RlKSkgdG9fdmlzaXQpXG4gIGluXG4gIGxvb3AgaW5pdCBbIHQucm9vdCBdXG47O1xuXG4oKiBhbG1vc3QgaWRlbnRpY2FsIHRvIGZvbGQsIGNvcGllZCBmb3Igc3BlZWQgcHVycG9zZXMgKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBmIChOb2RlLnZhbHVlX2V4biB+cG9vbCBub2RlKTtcbiAgICAgICAgbGV0IHRvX3Zpc2l0ID0gTm9kZS5zaWJsaW5nIH5wb29sIG5vZGUgOjogTm9kZS5jaGlsZCB+cG9vbCBub2RlIDo6IHJlc3QgaW5cbiAgICAgICAgbG9vcCB0b192aXNpdClcbiAgaW5cbiAgbG9vcCBbIHQucm9vdCBdXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBOb2RlLlBvb2wubGVuZ3RoIHQucG9vbFxuXG5tb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgZW5kKVxuXG5sZXQgaXNfZW1wdHkgdCA9IE5vZGUuaXNfZW1wdHkgdC5yb290XG5sZXQgbWVtID0gQy5tZW1cbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBDLnRvX2FycmF5XG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5cbmxldCBvZl9hcnJheSBhcnIgfmNtcCA9XG4gIGxldCB0ID0gY3JlYXRlIH5taW5fc2l6ZTooQXJyYXkubGVuZ3RoIGFycikgfmNtcCAoKSBpblxuICBBcnJheS5pdGVyIGFyciB+ZjooZnVuIHYgLT4gYWRkIHQgdik7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0IGwgfmNtcCA9IG9mX2FycmF5IChBcnJheS5vZl9saXN0IGwpIH5jbXBcbmxldCBzZXhwX29mX3QgZiB0ID0gQXJyYXkuc2V4cF9vZl90IGYgKHRvX2FycmF5IHQgfD4gQXJyYXkuc29ydGVkX2NvcHkgfmNvbXBhcmU6dC5jbXApXG5cbm1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9XG4gICAgeyBtdXRhYmxlIG5vZGUgOiAnYSBOb2RlLnRcbiAgICA7IG5vZGVfaWQgOiBOb2RlLklkLnRcbiAgICA7IGhlYXAgOiAnYSB0XG4gICAgfVxuXG4gICgqIElmIGlkcyBhcmUgZGlmZmVyZW50LCBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBieSBzb21lXG4gICAgIG90aGVyIG1lYW5zIChhbmQgcG9zc2libHkgcmV1c2VkKS4gKilcbiAgbGV0IGlzX25vZGVfdmFsaWQgdCA9IE5vZGUuSWQuZXF1YWwgKE5vZGUuaWQgfnBvb2w6dC5oZWFwLnBvb2wgdC5ub2RlKSB0Lm5vZGVfaWRcblxuICBsZXQgdmFsdWUgdCA9XG4gICAgaWYgaXNfbm9kZV92YWxpZCB0IHRoZW4gU29tZSAoTm9kZS52YWx1ZV9leG4gdC5ub2RlIH5wb29sOnQuaGVhcC5wb29sKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgdmFsdWVfZXhuIHQgPVxuICAgIGlmIGlzX25vZGVfdmFsaWQgdFxuICAgIHRoZW4gTm9kZS52YWx1ZV9leG4gdC5ub2RlIH5wb29sOnQuaGVhcC5wb29sXG4gICAgZWxzZSBmYWlsd2l0aCBcIkhlYXAudmFsdWVfZXhuOiBub2RlIHdhcyByZW1vdmVkIGZyb20gdGhlIGhlYXBcIlxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBbJXNleHAgKHZhbHVlIHQgOiBhIG9wdGlvbildXG5lbmRcblxubGV0IHJlbW92ZSB0ICh0b2tlbiA6IF8gRWx0LnQpID1cbiAgaWYgbm90IChwaHlzX2VxdWFsIHQgdG9rZW4uaGVhcClcbiAgdGhlbiBmYWlsd2l0aCBcImNhbm5vdCByZW1vdmUgZnJvbSBhIGRpZmZlcmVudCBoZWFwXCJcbiAgZWxzZSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdG9rZW4ubm9kZSlcbiAgdGhlbiAoXG4gICAgaWYgRWx0LmlzX25vZGVfdmFsaWQgdG9rZW4gdGhlbiByZW1vdmVfbm9uX2VtcHR5IHQgdG9rZW4ubm9kZTtcbiAgICB0b2tlbi5ub2RlIDwtIE5vZGUuZW1wdHkgKCkpXG47O1xuXG5sZXQgYWRkX3JlbW92YWJsZSB0IHYgPVxuICBsZXQgbm9kZSA9IGFkZF9ub2RlIHQgdiBpblxuICB7IEVsdC5ub2RlOyBoZWFwID0gdDsgbm9kZV9pZCA9IE5vZGUuaWQgfnBvb2w6dC5wb29sIG5vZGUgfVxuOztcblxubGV0IHVwZGF0ZSB0IHRva2VuIHYgPVxuICByZW1vdmUgdCB0b2tlbjtcbiAgYWRkX3JlbW92YWJsZSB0IHZcbjs7XG5cbmxldCBmaW5kX2VsdCA9XG4gIGxldCByZWMgbG9vcCB0IGYgbm9kZXMgPVxuICAgIG1hdGNoIG5vZGVzIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgdCBmIHJlc3RcbiAgICAgIGVsc2UgaWYgZiAoTm9kZS52YWx1ZV9leG4gbm9kZSB+cG9vbDp0LnBvb2wpXG4gICAgICB0aGVuIFNvbWUgeyBFbHQubm9kZTsgaGVhcCA9IHQ7IG5vZGVfaWQgPSBOb2RlLmlkIH5wb29sOnQucG9vbCBub2RlIH1cbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCB0IGYgKE5vZGUuc2libGluZyBub2RlIH5wb29sOnQucG9vbCA6OiBOb2RlLmNoaWxkIG5vZGUgfnBvb2w6dC5wb29sIDo6IHJlc3QpXG4gIGluXG4gIGZ1biB0IH5mIC0+IGxvb3AgdCBmIFsgdC5yb290IF1cbjs7XG5cbm1vZHVsZSBVbnNhZmUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgaGVhcCA9ICdhIHRcbiAgICB0eXBlICdhIHQgPSAnYSBOb2RlLnRcblxuICAgIGxldCB2YWx1ZSB0IGhlYXAgPSBOb2RlLnZhbHVlX2V4biB+cG9vbDpoZWFwLnBvb2wgdFxuICBlbmRcblxuICBsZXQgYWRkX3JlbW92YWJsZSA9IGFkZF9ub2RlXG4gIGxldCByZW1vdmUgPSByZW1vdmVfbm9uX2VtcHR5XG5cbiAgbGV0IHVwZGF0ZSB0IGVsdCB2ID1cbiAgICByZW1vdmUgdCBlbHQ7XG4gICAgYWRkX3JlbW92YWJsZSB0IHZcbiAgOztcbmVuZFxuIl19
