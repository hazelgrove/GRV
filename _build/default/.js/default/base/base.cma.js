// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0];
   runtime.caml_register_global(0, Base, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml;
   function descending(x, y){return caml_compare(y, x);}
   var
    max = Caml[17],
    min = Caml[16],
    Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(1, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Poly0, Caml, Shadow_stdlib, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Caml = global_data.Caml,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    invalid_arg = Caml[1],
    failwith = Caml[2],
    Exit$0 = Caml[3],
    Match_failure = Caml[4],
    Assert_failure = Caml[5],
    Invalid_argument = Caml[6],
    Failure = Caml[7],
    Out_of_memory = Caml[9],
    Stack_overflow = Caml[10],
    Sys_error = Caml[11],
    End_of_file = Caml[12],
    Division_by_zero = Caml[13],
    Sys_blocked_io = Caml[14],
    Undefined_recursive_module = Caml[15],
    min = Caml[16],
    max = Caml[17],
    abs = Caml[18],
    max_int$0 = Caml[19],
    min_int$0 = Caml[20],
    lnot = Caml[21],
    infinity$0 = Caml[22],
    neg_infinity$0 = Caml[23],
    nan$0 = Caml[24],
    max_float$0 = Caml[25],
    min_float$0 = Caml[26],
    epsilon_float$0 = Caml[27],
    symbol$0 = Caml[28],
    char_of_int$0 = Caml[29],
    string_of_bool$0 = Caml[30],
    bool_of_string_opt$0 = Caml[31],
    bool_of_string$0 = Caml[32],
    string_of_int$0 = Caml[33],
    int_of_string_opt$0 = Caml[34],
    string_of_float$0 = Caml[35],
    float_of_string_opt$0 = Caml[36],
    symbol$1 = Caml[37],
    stdin$0 = Caml[38],
    stdout$0 = Caml[39],
    stderr$0 = Caml[40],
    print_char$0 = Caml[41],
    print_string$0 = Caml[42],
    print_bytes$0 = Caml[43],
    print_int$0 = Caml[44],
    print_float$0 = Caml[45],
    print_endline$0 = Caml[46],
    print_newline$0 = Caml[47],
    prerr_char$0 = Caml[48],
    prerr_string$0 = Caml[49],
    prerr_bytes$0 = Caml[50],
    prerr_int$0 = Caml[51],
    prerr_float$0 = Caml[52],
    prerr_endline$0 = Caml[53],
    prerr_newline$0 = Caml[54],
    read_line$0 = Caml[55],
    read_int_opt$0 = Caml[56],
    read_int$0 = Caml[57],
    read_float_opt$0 = Caml[58],
    read_float$0 = Caml[59],
    open_out$0 = Caml[60],
    open_out_bin$0 = Caml[61],
    open_out_gen$0 = Caml[62],
    flush$0 = Caml[63],
    flush_all$0 = Caml[64],
    output_char$0 = Caml[65],
    output_string$0 = Caml[66],
    output_bytes$0 = Caml[67],
    output$0 = Caml[68],
    output_substring$0 = Caml[69],
    output_byte$0 = Caml[70],
    output_binary_int$0 = Caml[71],
    output_value$0 = Caml[72],
    seek_out$0 = Caml[73],
    pos_out$0 = Caml[74],
    out_channel_length$0 = Caml[75],
    close_out$0 = Caml[76],
    close_out_noerr$0 = Caml[77],
    set_binary_mode_out$0 = Caml[78],
    open_in$0 = Caml[79],
    open_in_bin$0 = Caml[80],
    open_in_gen$0 = Caml[81],
    input_char$0 = Caml[82],
    input_line$0 = Caml[83],
    input$0 = Caml[84],
    really_input$0 = Caml[85],
    really_input_string$0 = Caml[86],
    input_byte$0 = Caml[87],
    input_binary_int$0 = Caml[88],
    input_value$0 = Caml[89],
    seek_in$0 = Caml[90],
    pos_in$0 = Caml[91],
    in_channel_length$0 = Caml[92],
    close_in$0 = Caml[93],
    close_in_noerr$0 = Caml[94],
    set_binary_mode_in$0 = Caml[95],
    LargeFile = Caml[96],
    string_of_format$0 = Caml[97],
    symbol$2 = Caml[98],
    exit$0 = Caml[99],
    at_exit$0 = Caml[100],
    valid_float_lexem$0 = Caml[101],
    unsafe_really_input$0 = Caml[102],
    do_at_exit$0 = Caml[103],
    do_domain_local_at_exit$0 = Caml[104],
    Not_found$0 = Caml[8],
    Caml$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       do_domain_local_at_exit$0,
       Not_found$0];
   function bool_to_int(x){return x;}
   function symbol$3(_V_, _U_){return _V_ !== _U_ ? 1 : 0;}
   var symbol$4 = runtime.caml_mul;
   function symbol$5(_T_, _S_){return Math.pow(_T_, _S_);}
   function symbol$6(_R_, _Q_){return _R_ * _Q_;}
   function symbol$7(_P_, _O_){return _P_ + _O_ | 0;}
   function symbol$8(_N_, _M_){return _N_ + _M_;}
   function symbol$9(_L_, _K_){return _L_ - _K_ | 0;}
   function symbol$10(_J_, _I_){return _J_ - _I_;}
   var symbol$11 = runtime.caml_div;
   function symbol$12(_H_, _G_){return _H_ / _G_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return y <= x ? x : y;}
   function min$0(x, y){return x <= y ? x : y;}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$13 = caml_lessthan,
    symbol$14 = caml_lessequal,
    symbol$15 = caml_notequal,
    symbol$16 = caml_equal,
    symbol$17 = caml_greaterthan,
    symbol$18 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare = caml_int_compare, equal = caml_equal;
   function max$2(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$2(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$3(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$19 = caml_lessthan,
    symbol$20 = caml_lessequal,
    symbol$21 = caml_notequal,
    symbol$22 = caml_equal,
    symbol$23 = caml_greaterthan,
    symbol$24 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, equal$0 = caml_equal;
   function max$4(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$4(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       symbol$24,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$4,
       min$4];
   function symbol$25(x, y){return x < y ? 1 : 0;}
   function symbol$26(x, y){return x <= y ? 1 : 0;}
   function symbol$27(x, y){return x !== y ? 1 : 0;}
   function symbol$28(x, y){return x === y ? 1 : 0;}
   function symbol$29(x, y){return y < x ? 1 : 0;}
   function symbol$30(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return y <= x ? x : y;}
   function min$5(x, y){return x <= y ? x : y;}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$5,
       min$5];
   function symbol$31(x, y){return x < y ? 1 : 0;}
   function symbol$32(x, y){return x <= y ? 1 : 0;}
   function symbol$33(x, y){return x !== y ? 1 : 0;}
   function symbol$34(x, y){return x === y ? 1 : 0;}
   function symbol$35(x, y){return y < x ? 1 : 0;}
   function symbol$36(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return y <= x ? x : y;}
   function min$6(x, y){return x <= y ? x : y;}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       symbol$36,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$6,
       min$6];
   function i(x){return caml_call1(Stdlib_Uchar[10], x);}
   function symbol$37(x, y){var _F_ = i(y); return i(x) < _F_ ? 1 : 0;}
   function symbol$38(x, y){var _E_ = i(y); return i(x) <= _E_ ? 1 : 0;}
   function symbol$39(x, y){var _D_ = i(y); return i(x) !== _D_ ? 1 : 0;}
   function symbol$40(x, y){var _C_ = i(y); return i(x) === _C_ ? 1 : 0;}
   function symbol$41(x, y){var _B_ = i(y); return _B_ < i(x) ? 1 : 0;}
   function symbol$42(x, y){var _A_ = i(y); return _A_ <= i(x) ? 1 : 0;}
   function ascending$6(x, y){
    var _y_ = i(y), _z_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[1], _z_, _y_);
   }
   function descending$6(x, y){
    var _w_ = i(y), _x_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[2], _x_, _w_);
   }
   function compare$3(x, y){
    var _v_ = i(y);
    return caml_int_compare(i(x), _v_);
   }
   function equal$3(x, y){var _u_ = i(y); return i(x) === _u_ ? 1 : 0;}
   function max$7(x, y){return symbol$42(x, y) ? x : y;}
   function min$7(x, y){return symbol$38(x, y) ? x : y;}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       i,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       symbol$42,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$7,
       min$7];
   function symbol$43(x, y){return x < y ? 1 : 0;}
   function symbol$44(x, y){return x <= y ? 1 : 0;}
   function symbol$45(x, y){return x != y ? 1 : 0;}
   function symbol$46(x, y){return x == y ? 1 : 0;}
   function symbol$47(x, y){return y < x ? 1 : 0;}
   function symbol$48(x, y){return y <= x ? 1 : 0;}
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$4 = runtime.caml_float_compare;
   function equal$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return y <= x ? x : y;}
   function min$8(x, y){return x <= y ? x : y;}
   var
    Float_replace_polymorphic_comp =
      [0,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       symbol$48,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$8,
       min$8],
    symbol$49 = runtime.caml_string_lessthan,
    symbol$50 = caml_string_lessequal,
    symbol$51 = runtime.caml_string_notequal,
    symbol$52 = caml_string_equal,
    symbol$53 = runtime.caml_string_greaterthan,
    symbol$54 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$5 = runtime.caml_string_compare, equal$5 = caml_string_equal;
   function max$9(x, y){return caml_string_greaterequal(x, y) ? x : y;}
   function min$9(x, y){return caml_string_lessequal(x, y) ? x : y;}
   var
    String_replace_polymorphic_com =
      [0,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       symbol$54,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$9,
       min$9],
    symbol$55 = runtime.caml_bytes_lessthan,
    symbol$56 = caml_bytes_lessequal,
    symbol$57 = runtime.caml_bytes_notequal,
    symbol$58 = caml_bytes_equal,
    symbol$59 = runtime.caml_bytes_greaterthan,
    symbol$60 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$6 = runtime.caml_bytes_compare, equal$6 = caml_bytes_equal;
   function max$10(x, y){return caml_bytes_greaterequal(x, y) ? x : y;}
   function min$10(x, y){return caml_bytes_lessequal(x, y) ? x : y;}
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       symbol$59,
       symbol$60,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$10,
       min$10],
    symbol$61 = Caml$0[36],
    symbol$62 = Caml$0[27];
   function symbol$63(_t_){return - _t_ | 0;}
   function symbol$64(_s_){return - _s_;}
   function asr(_r_, _q_){return _r_ >> _q_;}
   function land(_p_, _o_){return _p_ & _o_;}
   var lnot$0 = Caml$0[20];
   function lor(_n_, _m_){return _n_ | _m_;}
   function lsl(_l_, _k_){return _l_ << _k_;}
   function lsr(_j_, _i_){return _j_ >>> _i_ | 0;}
   function lxor(_h_, _g_){return _h_ ^ _g_;}
   var mod = runtime.caml_mod, abs$0 = Caml$0[17], failwith$0 = Caml$0[2];
   function fst(_f_){return _f_[1];}
   var invalid_arg$0 = Caml$0[1];
   function snd(_e_){return _e_[2];}
   function phys_equal(_d_, _c_){return _d_ === _c_ ? 1 : 0;}
   function decr(_b_){_b_[1] += -1; return 0;}
   function incr(_a_){_a_[1]++; return 0;}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$61,
       symbol$62,
       symbol$63,
       symbol$64,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[124], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[126], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0),
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[49],
    runtime_warnings_enabled = Stdlib_Sys[50];
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[85][104])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[85][104]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11];
   function create(len, x){return runtime.caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[3],
    blit = Stdlib_ArrayLabels[8],
    concat = Stdlib_ArrayLabels[4],
    copy = Stdlib_ArrayLabels[6],
    fill = Stdlib_ArrayLabels[7],
    init = Stdlib_ArrayLabels[1],
    make_matrix = Stdlib_ArrayLabels[2],
    of_list = Stdlib_ArrayLabels[10],
    sub = Stdlib_ArrayLabels[5],
    to_list = Stdlib_ArrayLabels[9];
   function fold(t, init, f){
    return caml_call3(Stdlib_ArrayLabels[15], f, init, t);
   }
   function fold_right(t, f, init){
    return caml_call3(Stdlib_ArrayLabels[17], f, t, init);
   }
   function iter(t, f){return caml_call2(Stdlib_ArrayLabels[11], f, t);}
   function iteri(t, f){return caml_call2(Stdlib_ArrayLabels[12], f, t);}
   function map(t, f){return caml_call2(Stdlib_ArrayLabels[13], f, t);}
   function mapi(t, f){return caml_call2(Stdlib_ArrayLabels[14], f, t);}
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[31], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(6, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[3],
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[4];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var min_value = 0, max_value = 255;
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml,
    to_string = Caml[33],
    of_string = runtime.caml_int_of_string;
   function to_float(_c_){return _c_;}
   function of_float(_b_){return _b_ | 0;}
   var max_value = Caml[19], min_value = Caml[20];
   function succ(_a_){return _a_ + 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       to_float,
       of_float,
       max_value,
       min_value,
       succ];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[5],
    length = Stdlib_ListLabels[1],
    rev_append = Stdlib_ListLabels[12],
    tl_exn = Stdlib_ListLabels[6],
    unzip = Stdlib_ListLabels[54];
   function exists(t, f){return caml_call2(Stdlib_ListLabels[33], f, t);}
   function exists2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[35], f, l1, l2);
   }
   function fold(t, init, f){
    return caml_call3(Stdlib_ListLabels[25], f, init, t);
   }
   function fold2_ok(l1, l2, init, f){
    return caml_call4(Stdlib_ListLabels[30], f, init, l1, l2);
   }
   function for_all(t, f){return caml_call2(Stdlib_ListLabels[32], f, t);}
   function for_all2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[34], f, l1, l2);
   }
   function iter(t, f){return caml_call2(Stdlib_ListLabels[17], f, t);}
   function iter2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[27], f, l1, l2);
   }
   function nontail_map(t, f){return caml_call2(Stdlib_ListLabels[19], f, t);}
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[20], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[44], f, t);}
   function rev_map(t, f){return caml_call2(Stdlib_ListLabels[21], f, t);}
   function rev_map2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[29], f, l1, l2);
   }
   function sort(l, compare){
    return caml_call2(Stdlib_ListLabels[56], compare, l);
   }
   function stable_sort(l, compare){
    return caml_call2(Stdlib_ListLabels[57], compare, l);
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    if(! l) return init;
    function _a_(a, b){return caml_call2(f, b, a);}
    return fold(rev(l), init, _a_);
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right];
   runtime.caml_register_global(1, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _Q_(_ar_){return _ar_;}
    function hash_fold_int32(_ap_, _aq_){return as_int(_Q_, _ap_, _aq_);}
    var _R_ = Base_Char0[4];
    function hash_fold_char(_an_, _ao_){return as_int(_R_, _an_, _ao_);}
    function _S_(param){return param ? 1 : 0;}
    function hash_fold_bool(_al_, _am_){return as_int(_S_, _al_, _am_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[2], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x),
       s = s$0,
       list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var _aj_ = runtime.caml_obj_tag(x);
     a:
     if(250 === _aj_)
      var _ak_ = x[1];
     else{
      if(246 !== _aj_ && 244 !== _aj_){var _ak_ = x; break a;}
      var _ak_ = caml_call1(CamlinternalLazy[2], x);
     }
     return caml_call2(hash_fold_elem, s, _ak_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[91], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e),
       s = s$0,
       i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _ah_ = caml_call1(Hash[6], 0),
      _ai_ = hash_fold_nativeint(caml_call2(Hash[7], 0, _ah_), x);
     return caml_call1(Hash[8], _ai_);
    }
    function hash_int64(x){
     var
      _af_ = caml_call1(Hash[6], 0),
      _ag_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _af_), x);
     return caml_call1(Hash[8], _ag_);
    }
    function hash_int32(x){
     var
      _ad_ = caml_call1(Hash[6], 0),
      _ae_ = hash_fold_int32(caml_call2(Hash[7], 0, _ad_), x);
     return caml_call1(Hash[8], _ae_);
    }
    function hash_char(x){
     var
      _ab_ = caml_call1(Hash[6], 0),
      _ac_ = hash_fold_char(caml_call2(Hash[7], 0, _ab_), x);
     return caml_call1(Hash[8], _ac_);
    }
    function hash_int(x){
     var
      _$_ = caml_call1(Hash[6], 0),
      _aa_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _$_), x);
     return caml_call1(Hash[8], _aa_);
    }
    function hash_bool(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_bool(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_string(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_float(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_unit(x){
     var _T_ = caml_call1(Hash[6], 0), _U_ = caml_call2(Hash[7], 0, _T_);
     return caml_call1(Hash[8], _U_);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _O_ = caml_call1(Hash[6], 0),
      _P_ = caml_call2(folder, caml_call2(Hash[7], seed, _O_), x);
     return caml_call1(Hash[8], _P_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   function _a_(_N_){return runtime.Base_internalhash_get_hash_value(_N_);}
   function _b_(_M_, _L_){
    return runtime.Base_internalhash_fold_string(_M_, _L_);
   }
   function _c_(_K_, _J_){
    return runtime.Base_internalhash_fold_float(_K_, _J_);
   }
   function _d_(_I_, _H_){
    return runtime.Base_internalhash_fold_int64(_I_, _H_);
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_G_, _F_){
          return runtime.Base_internalhash_fold_int(_G_, _F_);
         },
         _d_,
         _c_,
         _b_,
         alloc,
         reset,
         _a_,
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _t_ = caml_call2(Base_Import0[119], t, 21),
     _u_ = caml_call1(Base_Import0[117], t),
     t$0 = caml_call2(Base_Import0[91], _u_, _t_),
     _v_ = caml_call2(Base_Import0[120], t$0, 24),
     t$1 = caml_call2(Base_Import0[121], t$0, _v_),
     _w_ = caml_call2(Base_Import0[119], t$1, 8),
     _x_ = caml_call2(Base_Import0[119], t$1, 3),
     _y_ = caml_call2(Base_Import0[91], t$1, _x_),
     t$2 = caml_call2(Base_Import0[91], _y_, _w_),
     _z_ = caml_call2(Base_Import0[120], t$2, 14),
     t$3 = caml_call2(Base_Import0[121], t$2, _z_),
     _A_ = caml_call2(Base_Import0[119], t$3, 4),
     _B_ = caml_call2(Base_Import0[119], t$3, 2),
     _C_ = caml_call2(Base_Import0[91], t$3, _B_),
     t$4 = caml_call2(Base_Import0[91], _C_, _A_),
     _D_ = caml_call2(Base_Import0[120], t$4, 28),
     t$5 = caml_call2(Base_Import0[121], t$4, _D_),
     _E_ = caml_call2(Base_Import0[119], t$5, 31);
    return caml_call2(Base_Import0[91], t$5, _E_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    _e_ =
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       function(_s_){return runtime.Base_hash_double(_s_);},
       hash_unit];
   function _f_(_r_){return runtime.Base_internalhash_get_hash_value(_r_);}
   function _g_(_q_, _p_){
    return runtime.Base_internalhash_fold_string(_q_, _p_);
   }
   function _h_(_o_, _n_){
    return runtime.Base_internalhash_fold_float(_o_, _n_);
   }
   function _i_(_m_, _l_){
    return runtime.Base_internalhash_fold_int64(_m_, _l_);
   }
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_k_, _j_){
        return runtime.Base_internalhash_fold_int(_k_, _j_);
       },
       _i_,
       _h_,
       _g_,
       alloc,
       reset,
       _f_,
       For_tests,
       create,
       of_fold,
       _e_,
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int_compare = runtime.caml_int_compare;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    phys_equal = Base_Import0[128],
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _u_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _a_, type_name);
   }
   function equal_abstract(type_name, param, _t_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_char = caml_int_compare,
    compare_float = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int32 = caml_int_compare;
   function compare_int64(_s_, _r_){
    return runtime.caml_int64_compare(_s_, _r_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_string = runtime.caml_string_compare,
    compare_unit = caml_int_compare;
   function compare_array(compare_elt, a, b){
    if(caml_call2(phys_equal, a, b)) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
    }
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function equal_char(_o_, _n_){return _o_ === _n_ ? 1 : 0;}
   function equal_int(_m_, _l_){return _m_ === _l_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int64 = caml_equal,
    equal_nativeint = caml_equal,
    equal_string = runtime.caml_string_equal;
   function equal_unit(_k_, _j_){return _k_ === _j_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_array(equal_elt, a, b){
    var _d_ = caml_call2(phys_equal, a, b);
    if(_d_)
     var _e_ = _d_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _f_ = len_a === len_b ? 1 : 0;
     if(_f_){
      var i = 0;
      for(;;){
       var _g_ = i === len_a ? 1 : 0;
       if(_g_)
        var _h_ = _g_;
       else{
        var l = a[1 + i], r = b[1 + i], _i_ = caml_call2(equal_elt, l, r);
        if(_i_){
         var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
         continue;
        }
        var _h_ = _i_;
       }
       return _h_;
      }
     }
     var _e_ = _f_;
    }
    return _e_;
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt, x, y);
       if(! _c_) return _c_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[6][8], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3(Base_Ppx_compare_lib[6][11], compare, a_005, b_006);
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[59], of_string = 0;
   function invariant(param){return 0;}
   var
    Base_Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       of_string];
   runtime.caml_register_global(4, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    do_domain_local_at_exit = Base_Import0[84],
    Caml = Base_Import0[85],
    bool_to_int = Base_Import0[86],
    symbol$0 = Base_Import0[87],
    symbol$1 = Base_Import0[88],
    symbol$2 = Base_Import0[89],
    symbol$3 = Base_Import0[90],
    symbol$4 = Base_Import0[91],
    symbol$5 = Base_Import0[92],
    symbol$6 = Base_Import0[93],
    symbol$7 = Base_Import0[94],
    symbol$8 = Base_Import0[95],
    symbol$9 = Base_Import0[96],
    Int_replace_polymorphic_compar = Base_Import0[97],
    ascending = Base_Import0[98],
    descending = Base_Import0[99],
    max = Base_Import0[100],
    min = Base_Import0[101],
    Int32_replace_polymorphic_comp = Base_Import0[102],
    Int64_replace_polymorphic_comp = Base_Import0[103],
    Nativeint_replace_polymorphic_ = Base_Import0[104],
    Bool_replace_polymorphic_compa = Base_Import0[105],
    Char_replace_polymorphic_compa = Base_Import0[106],
    Uchar_replace_polymorphic_comp = Base_Import0[107],
    Float_replace_polymorphic_comp = Base_Import0[108],
    String_replace_polymorphic_com = Base_Import0[109],
    Bytes_replace_polymorphic_comp = Base_Import0[110],
    symbol$10 = Base_Import0[111],
    symbol$11 = Base_Import0[112],
    symbol$12 = Base_Import0[113],
    symbol$13 = Base_Import0[114],
    asr = Base_Import0[115],
    land = Base_Import0[116],
    lnot = Base_Import0[117],
    lor = Base_Import0[118],
    lsl = Base_Import0[119],
    lsr = Base_Import0[120],
    lxor = Base_Import0[121],
    mod = Base_Import0[122],
    abs = Base_Import0[123],
    failwith = Base_Import0[124],
    fst = Base_Import0[125],
    invalid_arg = Base_Import0[126],
    snd = Base_Import0[127],
    phys_equal = Base_Import0[128],
    decr = Base_Import0[129],
    incr = Base_Import0[130],
    float_of_string = Base_Import0[131],
    am_testing = Base_Import0[132],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    unit_sexp_grammar = Sexplib0_Sexp_conv[49],
    bool_sexp_grammar = Sexplib0_Sexp_conv[50],
    string_sexp_grammar = Sexplib0_Sexp_conv[51],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[52],
    char_sexp_grammar = Sexplib0_Sexp_conv[53],
    int_sexp_grammar = Sexplib0_Sexp_conv[54],
    float_sexp_grammar = Sexplib0_Sexp_conv[55],
    int32_sexp_grammar = Sexplib0_Sexp_conv[56],
    int64_sexp_grammar = Sexplib0_Sexp_conv[57],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[58],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[59],
    ref_sexp_grammar = Sexplib0_Sexp_conv[60],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    option_sexp_grammar = Sexplib0_Sexp_conv[62],
    list_sexp_grammar = Sexplib0_Sexp_conv[63],
    array_sexp_grammar = Sexplib0_Sexp_conv[64],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[65],
    fun_sexp_grammar = Sexplib0_Sexp_conv[66],
    sexp_of_exn = Sexplib0_Sexp_conv[67],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[68],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[69],
    Exn_converter = Sexplib0_Sexp_conv[70],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    include = Base_Ppx_compare_lib[6],
    compare_bool = include[1],
    compare_char = include[2],
    compare_float = include[3],
    compare_int = include[4],
    compare_int32 = include[5],
    compare_int64 = include[6],
    compare_nativeint = include[7],
    compare_string = include[8],
    compare_unit = include[9],
    compare_array = include[10],
    compare_list = include[11],
    compare_option = include[12],
    compare_ref = include[13],
    equal_bool = include[14],
    equal_char = include[15],
    equal_float = include[16],
    equal_int = include[17],
    equal_int32 = include[18],
    equal_int64 = include[19],
    equal_nativeint = include[20],
    equal_string = include[21],
    equal_unit = include[22],
    equal_array = include[23],
    equal_list = include[24],
    equal_option = include[25],
    equal_ref = include[26],
    Not_found_s = Base_Sexp[7],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Caml,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       Not_found_s];
   runtime.caml_register_global(5, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"],
    cst_unknown_word_size = "unknown word size";
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[124], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[112], M[2], cst_pp));
    return [0, pp];
   }
   function _a_(_c_){return [0, Register_pp(_c_)[1]];}
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       _a_,
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[199],
    exit = Base_Import[85][98],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _k_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"],
    _j_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _i_ = [0, 2],
    _h_ = [0, cst_src_exn_ml, 54, 6],
    _e_ = [0, "exn.ml.Reraised"],
    _f_ = [0, cst_src_exn_ml, 33, 11],
    _b_ = [0, "exn.ml.Finally"],
    _c_ = [0, cst_src_exn_ml, 19, 11],
    cst_Base_Exn_Reraised = "Base__Exn.Reraised",
    cst_Base_Exn_Sexp = "Base__Exn.Sexp";
   function _a_(param){
    if(param[1] !== Finally)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var
     arg1_002 = param[3],
     arg0_001 = param[2],
     res0_003 = caml_call1(sexp_of_t, arg0_001),
     res1_004 = caml_call1(sexp_of_t, arg1_002);
    return [1, [0, _b_, [0, res0_003, [0, res1_004, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Finally, _a_);
   var Reraised = [248, cst_Base_Exn_Reraised, caml_fresh_oo_id(0)];
   function _d_(param){
    if(param[1] !== Reraised)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     arg1_006 = param[3],
     arg0_005 = param[2],
     res0_007 = caml_call1(Base_Import[139], arg0_005),
     res1_008 = caml_call1(sexp_of_t, arg1_006);
    return [1, [0, _e_, [0, res0_007, [0, res1_008, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Reraised, _d_);
   var Sexp = [248, cst_Base_Exn_Sexp, caml_fresh_oo_id(0)];
   function _g_(param){
    if(param[1] !== Sexp)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var t = param[2];
    return t;
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Sexp, _g_);
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    function _y_(str, param){return reraise(exc, str);}
    return caml_call2(Base_Printf[4], _y_, format);
   }
   function to_string(exc){
    var _x_ = caml_call1(Base_Import[199], exc);
    return caml_call2(Base_Sexp[15], _i_, _x_);
   }
   function to_string_mach(exc){
    var _w_ = caml_call1(Base_Import[199], exc);
    return caml_call1(Base_Sexp[16], _w_);
   }
   var sexp_of_t$0 = Base_Import[199];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _u_ = 0; return _u_;}catch(_v_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[201], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[11], ppf, sexp);
    }
    var _t_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _t_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[137], _j_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[85][39], raw_backtrace);
    return caml_call1(Base_Import[85][62], Base_Import[85][39]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _p_ = caml_call1(f, 0); return _p_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[85][102], 0);}catch(_s_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_q_){try{caml_call1(Stdlib_Printf[3], _k_);}catch(_r_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_o_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _n_ = caml_call1(func, 0); return _n_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_m_){
    return runtime.Base_clear_caml_backtrace_pos(_m_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_l_){return runtime.Base_caml_exn_is_most_recent_exn(_l_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned",
    cst_Return = "Return";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[124], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_s_){
    var bind = _s_[1], return$0 = _s_[3];
    function map_via_bind(ma, f){
     function _t_(a){
      var _u_ = caml_call1(f, a);
      return caml_call1(_s_[3], _u_);
     }
     return caml_call2(_s_[1], ma, _t_);
    }
    var match = _s_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _r_ = Make_general([0, bind, map, return$0]);
    return [0,
            _r_[6],
            _r_[7],
            _r_[8],
            _r_[5],
            _r_[1],
            _r_[2],
            _r_[4],
            _r_[9],
            _r_[10],
            _r_[11],
            _r_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _q_ = Make_general([0, bind, map, return$0]);
    return [0,
            _q_[6],
            _q_[7],
            _q_[8],
            _q_[5],
            _q_[1],
            _q_[2],
            _q_[4],
            _q_[9],
            _q_[10],
            _q_[11],
            _q_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _p_ = Make_general([0, bind, map, return$0]);
    return [0,
            _p_[6],
            _p_[7],
            _p_[8],
            _p_[5],
            _p_[1],
            _p_[2],
            _p_[4],
            _p_[9],
            _p_[10],
            _p_[11],
            _p_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _o_ = Make_general([0, bind, map, return$0]);
    return [0,
            _o_[6],
            _o_[7],
            _o_[5],
            _o_[1],
            _o_[2],
            _o_[4],
            _o_[9],
            _o_[10],
            _o_[11],
            _o_[12],
            _o_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _n_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _n_);
    }
    function bind(t, f){
     function _j_(a){
      var _m_ = caml_call1(f, a);
      return caml_call1(M[1], _m_);
     }
     var _k_ = caml_call1(M[1], t), _l_ = caml_call2(Monad[1], _k_, _j_);
     return caml_call1(M[2], _l_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _h_ = caml_call1(M[1], t), _i_ = caml_call2(Monad[2], _h_, f);
         return caml_call1(M[2], _i_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function return$0(a){return a;}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make([0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    Ident =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   function _a_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _g_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _g_[6],
            _g_[7],
            _g_[8],
            _g_[5],
            _g_[1],
            _g_[2],
            _g_[4],
            _g_[9],
            _g_[10],
            _g_[11],
            _g_[12]];
   }
   function _b_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _f_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _f_[6],
            _f_[7],
            _f_[8],
            _f_[5],
            _f_[1],
            _f_[2],
            _f_[4],
            _f_[9],
            _f_[10],
            _f_[11],
            _f_[12]];
   }
   function _c_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _e_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _e_[6],
            _e_[7],
            _e_[8],
            _e_[5],
            _e_[1],
            _e_[2],
            _e_[4],
            _e_[9],
            _e_[10],
            _e_[11],
            _e_[12]];
   }
   var
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$0 = Monad[5],
         map = Monad[6],
         _d_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _d_[6],
                _d_[7],
                _d_[5],
                _d_[1],
                _d_[2],
                _d_[4],
                _d_[9],
                _d_[10],
                _d_[11],
                _d_[12],
                _d_[8]];
       },
       _c_,
       _b_,
       _a_,
       Ident];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_M_){
    var return$0 = _M_[1], symbol = _M_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _M_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     var _O_ = caml_call1(return$0, 0);
     function _P_(x, xs){return [0, x, xs];}
     function _Q_(_R_){return function(_S_){return map2(_R_, _S_, _P_);};}
     return caml_call3(Base_List0[22], ts, _Q_, _O_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _N_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _N_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_D_){
    var return$0 = _D_[1], map2 = _D_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _D_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _L_(fab, c){return caml_call1(fab, c);}
     return caml_call3(map2, caml_call3(map2, ta, tb, f), tc, _L_);
    }
    function all(ts){
     var _F_ = caml_call1(return$0, 0);
     function _G_(x, xs){return [0, x, xs];}
     function _H_(_I_){
      var _J_ = caml_call1(map2, _I_);
      return function(_K_){return caml_call2(_J_, _K_, _G_);};
     }
     return caml_call3(Base_List0[22], ts, _H_, _F_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _E_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _E_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     function _C_(f){return caml_call2(M[7], mx, f);}
     return caml_call2(M[5], mf, _C_);
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _B_ = caml_call1(F[1], a);
     return caml_call1(G[1], _B_);
    }
    function apply(tf, tx){
     var _A_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _A_, tx);
    }
    function custom_map(t, f){
     var _x_ = F[2];
     function _y_(_z_){return caml_call2(_x_, _z_, f);}
     return caml_call2(G[2], t, _y_);
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _w_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _w_];
    }
    function apply(tf, tx){
     var
      _r_ = caml_call1(Base_Import[127], tx),
      _s_ = caml_call1(Base_Import[127], tf),
      _t_ = caml_call2(G[8], _s_, _r_),
      _u_ = caml_call1(Base_Import[125], tx),
      _v_ = caml_call1(Base_Import[125], tf);
     return [0, caml_call2(F[8], _v_, _u_), _t_];
    }
    function custom_map(t, f){
     var
      _o_ = caml_call1(Base_Import[127], t),
      _p_ = caml_call2(G[2], _o_, f),
      _q_ = caml_call1(Base_Import[125], t);
     return [0, caml_call2(F[2], _q_, f), _p_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function _a_(_l_, _k_, _j_){
    var _m_ = Make_let_syntax3(_l_, _k_, _j_)[1], _n_ = _m_[8];
    return [0,
            [0,
             _m_[1],
             _m_[4],
             _m_[5],
             _m_[6],
             _m_[7],
             [0, _n_[1], _n_[2], _n_[3], _n_[8]]]];
   }
   function _b_(_g_, _f_, _e_){
    var _h_ = Make_let_syntax2(_g_, _f_, _e_)[1], _i_ = _h_[8];
    return [0,
            [0,
             _h_[1],
             _h_[4],
             _h_[5],
             _h_[6],
             _h_[7],
             [0, _i_[1], _i_[2], _i_[3], _i_[8]]]];
   }
   var
    Base_Applicative =
      [0,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _c_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _d_ = _c_[8];
        return [0,
                [0,
                 _c_[1],
                 _c_[4],
                 _c_[5],
                 _c_[6],
                 _c_[7],
                 [0, _d_[1], _d_[2], _d_[3], _d_[8]]]];
       },
       _b_,
       _a_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Sys0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Base_Sys0 = global_data.Base__Sys0,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[40],
    copy = Stdlib_BytesLabels[4],
    create = runtime.caml_create_bytes,
    fill = Stdlib_BytesLabels[10],
    make = Stdlib_BytesLabels[1],
    map = Stdlib_BytesLabels[17],
    mapi = Stdlib_BytesLabels[18],
    sub = Stdlib_BytesLabels[7],
    unsafe_blit = runtime.caml_blit_bytes,
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5];
   function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[44], s);}
   var
    unsafe_of_string_promise_no_mu = Stdlib_BytesLabels[45],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       fill,
       make,
       map,
       mapi,
       sub,
       unsafe_blit,
       to_string,
       of_string,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(2, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0], _a_ = [0, "_"];
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare;
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _d_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _c_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _b_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_011 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    cst_Second = cst_Second$0,
    cst_First = cst_First$0,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0];
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_007, of_s_008, sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _c_ = sexp_013[1];
      b:
      if(caml_string_notequal(_c_, cst_First$0)){
       if(caml_string_notequal(_c_, cst_Second$0)){
        if(! caml_string_notequal(_c_, cst_first)) break b;
        if(caml_string_notequal(_c_, cst_second)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
     }
     var _d_ = sexp_013[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_011, sexp_013);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_011, sexp_013);
     var tag_014 = _e_[1];
     b:
     if(caml_string_notequal(tag_014, cst_First$0)){
      if(caml_string_notequal(tag_014, cst_Second$0)){
       if(! caml_string_notequal(tag_014, cst_first)) break b;
       if(caml_string_notequal(tag_014, cst_second)) break a;
      }
      var sexp_args_020 = _d_[2];
      if(sexp_args_020 && ! sexp_args_020[2]){
       var
        arg0_021 = sexp_args_020[1],
        res0_022 = caml_call1(of_s_008, arg0_021);
       return [1, res0_022];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_011,
               tag_014,
               sexp_013);
     }
     var sexp_args_015 = _d_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_f_007, arg0_016);
      return [0, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_011,
              tag_014,
              sexp_013);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_011, sexp_013);
   }
   function sexp_of_t(of_f_025, of_s_026, param){
    if(0 === param[0]){
     var arg0_027 = param[1], res0_028 = caml_call1(of_f_025, arg0_027);
     return [1, [0, _a_, [0, res0_028, 0]]];
    }
    var arg0_029 = param[1], res0_030 = caml_call1(of_s_026, arg0_029);
    return [1, [0, _b_, [0, res0_030, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t, t_sexp_grammar];
   runtime.caml_register_global(16, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Bytes0, Base__Import0, Base__Sys0, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import0 = global_data.Base__Import0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol = Base_Import0[112],
    capitalize = Stdlib_StringLabels[27],
    compare = Stdlib_StringLabels[9];
   function copy(x){
    var _a_ = caml_call1(Base_Bytes0[15], x);
    return caml_call1(Base_Bytes0[16], _a_);
   }
   var
    escaped = Stdlib_StringLabels[24],
    lowercase = Stdlib_StringLabels[26],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[15],
    uncapitalize = Stdlib_StringLabels[28],
    unsafe_blit = runtime.caml_blit_string,
    uppercase = Stdlib_StringLabels[25];
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[6], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){return caml_call2(Stdlib_StringLabels[29], f, t);}
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol,
       capitalize,
       compare,
       copy,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       unsafe_blit,
       uppercase,
       concat,
       iter];
   runtime.caml_register_global(6, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__Ppx_compare_lib, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    var n = caml_call2(Base_Import[233], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[229], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[229], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[229], a_001[4], b_002[4]) : n$1;
   }
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[209], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[207], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[207], hsv$1, arg[3]);
    return caml_call2(Base_Import[207], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[142], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[142], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[142], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[139], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare, hash_fold_t, hash, sexp_of_t],
    compare$0 = T[1],
    hash_fold_t$0 = T[2],
    hash$0 = T[3],
    include = caml_call1(Base_Comparator[5], [0, T[1], T[4]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[93], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[14], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (12, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    length = Base_List0[2],
    rev_append = Base_List0[3],
    tl_exn = Base_List0[4],
    unzip = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    sort = Base_List0[19],
    stable_sort = Base_List0[20],
    rev = Base_List0[21],
    fold_right = Base_List0[22];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0])
      var y = match[1], fst$0 = [0, y, fst], t$0 = t$1, fst = fst$0;
     else
      var y$0 = match[1], snd$0 = [0, y$0, snd], t$0 = t$1, snd = snd$0;
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _c_ = [0, 0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0];
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _f_ = sexp_007[1];
      b:
      if(caml_string_notequal(_f_, cst_Error$0)){
       if(caml_string_notequal(_f_, cst_Ok$0)){
        if(! caml_string_notequal(_f_, cst_error)) break b;
        if(caml_string_notequal(_f_, cst_ok)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
     }
     var _g_ = sexp_007[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_007);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_007);
     var tag_008 = _h_[1];
     b:
     if(caml_string_notequal(tag_008, cst_Error$0)){
      if(caml_string_notequal(tag_008, cst_Ok$0)){
       if(! caml_string_notequal(tag_008, cst_error)) break b;
       if(caml_string_notequal(tag_008, cst_ok)) break a;
      }
      var sexp_args_009 = _g_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _g_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(caml_call2(Base_Ppx_compare_lib[1], a_027, b_028)) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(caml_call2(Base_Ppx_compare_lib[1], a_033, b_034)) return 1;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return 0;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 0;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var Error = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]);
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _e_ = [0, caml_call1(f, 0)]; return _e_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[124], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[24], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    function _d_(param){return 0;}
    return caml_call2(map$0, combine_errors(l), _d_);
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       equal,
       hash_fold_t,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(21, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[91], n, 1) : n;
             });
   }
   function sum(fold, M){
    return function(t, f){
     function _k_(n, a){
      var _l_ = caml_call1(f, a);
      return caml_call2(M[2], n, _l_);
     }
     return caml_call3(fold, t, M[1], _k_);};
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[91], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _j_ = caml_call1(f, x);
                 return _j_ ? caml_call1(r, 1) : _j_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _i_ = 1 - caml_call1(f, x);
                 return _i_ ? caml_call1(r, 0) : _i_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _h_ = caml_call1(f, x);
                 return _h_ ? caml_call1(r, [0, x]) : _h_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _g_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[21], _g_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _e_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _e_, x);
       }
       var _f_ = i[1];
       runtime.caml_check_bound(array[1], _f_)[1 + _f_] = x;
       return caml_call1(Base_Import[130], i);
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function sum$0(m, t){
     var _b_ = sum(fold, m);
     return function(_c_){var _d_ = _c_; return _b_(t, _d_);};
    }
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function _a_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     include = Make_gen([0, fold, iter, length]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[3],
     fold$0 = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16];
    function mem(t, elt){
     return caml_call2(exists, t, caml_call1(T[1][1], elt));
    }
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, a, equal){
         return caml_call2(exists, t, caml_call1(equal, a));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       _a_,
       Make_gen];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[172],
    sexp_of_t = Base_Import[148],
    cst_unforced_lazy = "<unforced lazy>";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function _a_(t, f){
    return [246,
            function(_q_){
             var _r_ = caml_obj_tag(t);
             a:
             if(250 === _r_)
              var _s_ = t[1];
             else{
              if(246 !== _r_ && 244 !== _r_){var _s_ = t; break a;}
              var _s_ = caml_call1(CamlinternalLazy[2], t);
             }
             return caml_call1(f, _s_);
            }];
   }
   function compare(compare_a, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 0;
    var _m_ = caml_obj_tag(t2);
    a:
    if(250 === _m_)
     var _n_ = t2[1];
    else{
     if(246 !== _m_ && 244 !== _m_){var _n_ = t2; break a;}
     var _n_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _o_ = caml_obj_tag(t1);
    a:
    if(250 === _o_)
     var _p_ = t1[1];
    else{
     if(246 !== _o_ && 244 !== _o_){var _p_ = t1; break a;}
     var _p_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(compare_a, _p_, _n_);
   }
   function equal(equal_a, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 1;
    var _i_ = caml_obj_tag(t2);
    a:
    if(250 === _i_)
     var _j_ = t2[1];
    else{
     if(246 !== _i_ && 244 !== _i_){var _j_ = t2; break a;}
     var _j_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _k_ = caml_obj_tag(t1);
    a:
    if(250 === _k_)
     var _l_ = t1[1];
    else{
     if(246 !== _k_ && 244 !== _k_){var _l_ = t1; break a;}
     var _l_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(equal_a, _l_, _j_);
   }
   var hash_fold_t = Base_Hash[13][12];
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_d_){
             var _e_ = caml_obj_tag(t);
             a:
             if(250 === _e_)
              var _f_ = t[1];
             else{
              if(246 !== _e_ && 244 !== _e_){var _f_ = t; break a;}
              var _f_ = caml_call1(CamlinternalLazy[2], t);
             }
             var _g_ = caml_call1(f, _f_), _h_ = caml_obj_tag(_g_);
             if(250 === _h_) return _g_[1];
             if(246 !== _h_ && 244 !== _h_) return _g_;
             return caml_call1(CamlinternalLazy[2], _g_);
            }];
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[139], cst_unforced_lazy);
    var _b_ = caml_obj_tag(t);
    a:
    if(250 === _b_)
     var _c_ = t[1];
    else{
     if(246 !== _b_ && 244 !== _b_){var _c_ = t; break a;}
     var _c_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(sexp_of_a, _c_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
   runtime.caml_register_global(6, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[93], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[91], pos, len),
     _d_ = caml_call2(Base_Import[93], total_length, stop),
     _e_ = caml_call2(Base_Import[118], pos, len),
     _f_ = caml_call2(Base_Import[118], _e_, stop),
     _g_ = caml_call2(Base_Import[118], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: CamlinternalLazy, Stdlib__Bigarray, Stdlib__Domain, Stdlib__Lazy, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy;
   function of_state(_f_){return _f_;}
   var Repr = [0, of_state];
   function assign(dst, src){
    var _b_ = caml_obj_tag(dst);
    a:
    if(250 === _b_)
     var _c_ = dst[1];
    else{
     if(246 !== _b_ && 244 !== _b_){var _c_ = dst; break a;}
     var _c_ = caml_call1(CamlinternalLazy[2], dst);
    }
    var dst$0 = caml_call1(Repr[1], _c_), _d_ = caml_obj_tag(src);
    a:
    if(250 === _d_)
     var _e_ = src[1];
    else{
     if(246 !== _d_ && 244 !== _d_){var _e_ = src; break a;}
     var _e_ = caml_call1(CamlinternalLazy[2], src);
    }
    var src$0 = caml_call1(Repr[1], _e_);
    return runtime.caml_ba_blit(src$0, dst$0);
   }
   function make_default(default$0){
    function split_from_parent(v){
     return caml_call2(Stdlib_Lazy[5], Stdlib_Random[15][15], v);
    }
    function _a_(param){return default$0;}
    return caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], _a_);
   }
   function get_state(random_key){
    return caml_call1(Stdlib_Domain[10][2], random_key);
   }
   var Base_Random_repr = [0, Repr, assign, make_default, get_state];
   runtime.caml_register_global(4, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Lazy, Base__Printf, Base__Random_repr, Base__Word_size, CamlinternalLazy, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Lazy = global_data.Base__Lazy,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"],
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _M_ = Base_Import[132];
    if(! _M_) return _M_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[124], cst_initializing_Random_with_a);
   }
   function bits(t){
    var _K_ = caml_obj_tag(t);
    a:
    if(250 === _K_)
     var _L_ = t[1];
    else{
     if(246 !== _K_ && 244 !== _K_){var _L_ = t; break a;}
     var _L_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(Stdlib_Random[15][4], _L_);
   }
   function bool(t){
    var _I_ = caml_obj_tag(t);
    a:
    if(250 === _I_)
     var _J_ = t[1];
    else{
     if(246 !== _I_ && 244 !== _I_){var _J_ = t; break a;}
     var _J_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(Stdlib_Random[15][11], _J_);
   }
   function int$0(t, x){
    var _G_ = caml_obj_tag(t);
    a:
    if(250 === _G_)
     var _H_ = t[1];
    else{
     if(246 !== _G_ && 244 !== _G_){var _H_ = t; break a;}
     var _H_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[15][5], _H_, x);
   }
   function int32(t, x){
    var _E_ = caml_obj_tag(t);
    a:
    if(250 === _E_)
     var _F_ = t[1];
    else{
     if(246 !== _E_ && 244 !== _E_){var _F_ = t; break a;}
     var _F_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[15][7], _F_, x);
   }
   function int64(t, x){
    var _C_ = caml_obj_tag(t);
    a:
    if(250 === _C_)
     var _D_ = t[1];
    else{
     if(246 !== _C_ && 244 !== _C_){var _D_ = t; break a;}
     var _D_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[15][9], _D_, x);
   }
   function nativeint(t, x){
    var _A_ = caml_obj_tag(t);
    a:
    if(250 === _A_)
     var _B_ = t[1];
    else{
     if(246 !== _A_ && 244 !== _A_){var _B_ = t; break a;}
     var _B_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call2(Stdlib_Random[15][8], _B_, x);
   }
   function make(seed){
    var _z_ = caml_call1(Stdlib_Random[15][1], seed);
    return caml_call1(Base_Lazy[21], _z_);
   }
   function copy(t){
    var _w_ = caml_obj_tag(t);
    a:
    if(250 === _w_)
     var _x_ = t[1];
    else{
     if(246 !== _w_ && 244 !== _w_){var _x_ = t; break a;}
     var _x_ = caml_call1(CamlinternalLazy[2], t);
    }
    var _y_ = caml_call1(Stdlib_Random[15][3], _x_);
    return caml_call1(Base_Lazy[21], _y_);
   }
   function char$0(t){
    var _v_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _v_);
   }
   function ascii(t){
    var _u_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _u_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    var _t_ = caml_call1(Stdlib_Random[15][2], 0);
    return caml_call1(Base_Lazy[21], _t_);
   }
   var assign = Base_Random_repr[2];
   if(Base_Import[132]){
    var t = caml_call1(Stdlib_Random[16], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Lazy[21], t);
   }
   else
    var
     default$0 =
       [246,
        function(param){
         var _r_ = make_self_init(0, 0), _s_ = caml_obj_tag(_r_);
         if(250 === _s_) return _r_[1];
         if(246 !== _s_ && 244 !== _s_) return _r_;
         return caml_call1(CamlinternalLazy[2], _r_);
        }];
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function bits$1(state){return bits(state);}
   function full_range_int32(state){
    var _o_ = bits$1(state) << 30;
    return bits$1(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[93], hi, lo);
    if(diff === Base_Int0[5]){
     var
      _i_ = Base_Int0[5],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[116], _j_, _i_);
     return caml_call2(Base_Import[91], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[7], diff));
     return caml_call2(Base_Import[91], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[102][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[102][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[102][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[102][6], int$0, lo)
       && caml_call2(Base_Import[102][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[104][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[104][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[104][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[104][6], int$0, lo)
       && caml_call2(Base_Import[104][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[90], r1, 9.313225746154785e-10),
      _e_ = caml_call2(Base_Import[92], _d_, r2),
      result = caml_call2(Base_Import[90], _e_, 9.313225746154785e-10);
     if(caml_call2(Base_Import[108][1], result, 1.))
      return caml_call2(Base_Import[90], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(caml_call2(Base_Import[108][5], lo, hi))
     raise_crossed_bounds(cst_float, lo, hi, Base_Import[85][34]);
    var _c_ = float$0(state, caml_call2(Base_Import[94], hi, lo));
    return caml_call2(Base_Import[92], lo, _c_);
   }
   var default$1 = caml_call1(Base_Random_repr[3], default$0);
   function bits$2(param){
    return bits(caml_call1(Base_Random_repr[4], default$1));
   }
   function int$2(x){
    return int$1(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int32$0(x){
    return int32(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function nativeint$0(x){
    return nativeint(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int64$0(x){
    return int64(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function float$1(x){
    return float$0(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int_incl$0(x, y){
    return int_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int32_incl$0(x, y){
    return int32_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function nativeint_incl$0(x, y){
    return nativeint_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int64_incl$0(x, y){
    return int64_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function float_range$0(x, y){
    return float_range(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function bool$0(param){
    return bool(caml_call1(Base_Random_repr[4], default$1));
   }
   function char$1(param){
    return char$0(caml_call1(Base_Random_repr[4], default$1));
   }
   function ascii$0(param){
    return ascii(caml_call1(Base_Random_repr[4], default$1));
   }
   function full_init(seed){
    var t = caml_call1(Base_Random_repr[4], default$1);
    return caml_call2(assign, t, make(seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, caml_call1(Base_Random_repr[4], default$1), s);
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$2,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(24, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    blit = Base_Array0[7],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[93], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[91], pos, i),
       _b_ = caml_call2(Base_Import[91], i, 1),
       _c_ = caml_call2(Base_Random[18][6], random_state, _b_),
       random_i = caml_call2(Base_Import[91], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      var i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var
      x$1 = caml_call1(f, x$0),
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(caml_string_notequal(_d_, cst_Equal)){
       c:
       if(caml_string_notequal(_d_, cst_Greater)){
        if(caml_string_notequal(_d_, cst_Less)){
         if(! caml_string_notequal(_d_, cst_equal)) break b;
         if(! caml_string_notequal(_d_, cst_greater)) break c;
         if(caml_string_notequal(_d_, cst_less)) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(caml_string_notequal(_g_, cst_Equal)){
      c:
      if(caml_string_notequal(_g_, cst_Greater)){
       if(caml_string_notequal(_g_, cst_Less)){
        if(! caml_string_notequal(_g_, cst_equal)) break b;
        if(! caml_string_notequal(_g_, cst_greater)) break c;
        if(caml_string_notequal(_g_, cst_less)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[19],
    getenv = Base_Sys0[20],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Ppx_compare_lib, Base__Printf, Base__Random, Base__Result, Base__Sys, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_022 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Sys = global_data.Base__Sys,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    length = Base_List1[2],
    rev_append = Base_List1[3],
    tl_exn = Base_List1[4],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold_left = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    nontail_map = Base_List1[14],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    sort = Base_List1[19],
    stable_sort = Base_List1[20],
    rev = Base_List1[21],
    fold_right = Base_List1[22],
    is_empty = Base_List1[23],
    partition_map = Base_List1[24],
    invalid_argf = Base_Printf[7],
    t_of_sexp = Base_Import[176],
    sexp_of_t = Base_Import[152],
    cst_List_last = "List.last",
    _s_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _t_ = [0, cst_src_list_ml, 1301, 13],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _q_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _o_ = [0, cst_src_list_ml, 1045, 12],
    _n_ = [0, cst_src_list_ml, 933, 4],
    _m_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _l_ = [0, cst_src_list_ml, 661, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _k_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _j_ = [0, cst_src_list_ml, 528, 11],
    cst_map2_exn = "map2_exn",
    cst_exists2_exn = "exists2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_iter2_exn = "iter2_exn",
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    cst_List_range_stride_function$0 =
      "List.range': stride function cannot change direction",
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"],
    _f_ = [0, "List.find_map_exn: not found"],
    _g_ = [0, "List.find_exn: not found"],
    _h_ = [0, "List.findi_exn: not found"],
    _i_ = [0, "List.find_mapi_exn: not found"],
    _p_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function compare(cmp_a, a_006, b_007){
    if(caml_call2(Base_Ppx_compare_lib[1], a_006, b_007)) return 0;
    if(! a_006) return b_007 ? 1 : 0;
    var a_008 = a_006[1];
    if(! b_007) return -1;
    var b_009 = b_007[1];
    return caml_call2(cmp_a, a_008, b_009);
   }
   function sexp_of_t$0(of_a_010, param){
    if(! param) return _b_;
    var arg0_011 = param[1], res0_012 = caml_call1(of_a_010, arg0_011);
    return [1, [0, _a_, [0, res0_012, 0]]];
   }
   var Or_unequal_lengths = [0, compare, sexp_of_t$0];
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function range(compare, stride, opt, _a0_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_a0_) var sth$0 = _a0_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _a2_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[9], _a2_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[126], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i = start_i$0,
     accum = 0;
    for(;;){
     var i_to_stop_order = order(i, stop_i);
     a:
     {
      b:
      {
       switch(i_to_stop_order){
         case 0:
          if(847855481 > initial_stride_order) break b; break;
         case 1:
          if(104758188 <= stop){var _a1_ = [0, i, accum]; break a;}
          var _a1_ = accum;
          break a;
         default: if(847855481 <= initial_stride_order) break b;
       }
       var next_i$0 = caml_call1(stride, i);
       c:
       {
        switch(order(i, next_i$0)){
          case 0:
           if(847855481 > initial_stride_order) break c; break;
          case 1:
           var _a1_ = raise_stride_cannot_return_sam(0); break a;
          default: if(847855481 <= initial_stride_order) break c;
        }
        var accum$0 = [0, i, accum], i = next_i$0, accum = accum$0;
        continue;
       }
       var
        _a1_ = caml_call1(Base_Import[126], cst_List_range_stride_function$0);
       break a;
      }
      var _a1_ = accum;
     }
     return caml_call1(rev, _a1_);
    }
   }
   function range$0(opt, _aX_, _aW_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_aX_) var sth$0 = _aX_[1], start = sth$0; else var start = 104758188;
    if(_aW_) var sth$1 = _aW_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[126], cst_List_range_stride_must_be_);
    var _aY_ = [0, stop], _aZ_ = [0, start];
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[91], x, stride);},
             _aZ_,
             _aY_,
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = t$1, n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aT_ = caml_call1(length, tail_of_b),
     _aU_ = caml_call2(Base_Import[91], shared_length, _aT_),
     _aV_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[91], shared_length, _aV_),
             _aU_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        c = c$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aQ_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[91], shared_length, _aQ_),
     _aR_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[91], shared_length, _aR_),
     _aS_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[91], shared_length, _aS_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aN_){
              var _aO_ = caml_call1(iter2_ok, _aN_);
              return function(_aP_){return caml_call2(_aO_, _aP_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aK_){
              var _aL_ = caml_call1(rev_map2_ok, _aK_);
              return function(_aM_){return caml_call2(_aL_, _aM_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_aH_){
              var _aI_ = caml_call1(fold2_ok, _aH_);
              return function(_aJ_){return caml_call3(_aI_, _aJ_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aE_){
              var _aF_ = caml_call1(for_all2_ok, _aE_);
              return function(_aG_){return caml_call2(_aF_, _aG_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aB_){
              var _aC_ = caml_call1(exists2_ok, _aB_);
              return function(_aD_){return caml_call2(_aC_, _aD_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _aA_ = caml_call2(equal, a, b);
     if(_aA_) return _aA_;
     var param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x))
      var accu$0 = [0, x, accu], accu = accu$0, param = l;
     else
      var param = l;
    }
   }
   function filter(t, f){return caml_call1(rev, rev_filter(t, f));}
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     var param = l;
    }
   }
   var not_found = [0, Base_Import[252], _f_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     var param = l;
    }
   }
   var not_found$0 = [0, Base_Import[252], _g_];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     var t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[252], _h_];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$2 = [0, Base_Import[252], _i_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _az_ = caml_call2(f, i, hd);
     if(! _az_) return _az_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _ay_ = caml_call2(f, i, hd);
     if(_ay_) return _ay_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   var to_array = Base_Array0[13];
   function to_list(t){return t;}
   var max_non_tailcall = typeof Base_Sys[8] === "number" ? 1000 : 50;
   function count_append(l1, l2, count){
    if(! l2) return l1;
    if(! l1) return l2;
    var _au_ = l1[2], x1 = l1[1];
    if(! _au_) return [0, x1, l2];
    var _av_ = _au_[2], x2 = _au_[1];
    if(! _av_) return [0, x1, [0, x2, l2]];
    var _aw_ = _av_[2], x3 = _av_[1];
    if(! _aw_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _aw_[2], x4 = _aw_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     _ax_ =
       max_non_tailcall < count
        ? caml_call2(rev_append, caml_call1(rev, tl), l2)
        : count_append(tl, l2, caml_call2(Base_Import[91], count, 1));
    return [0, x1, [0, x2, [0, x3, [0, x4, [0, x5, _ax_]]]]];
   }
   function append(l1, l2){return count_append(l1, l2, 0);}
   function count_map(f, l, ctr){
    if(! l) return 0;
    var _aq_ = l[2], x1$0 = l[1];
    if(! _aq_){var f1$3 = caml_call1(f, x1$0); return [0, f1$3, 0];}
    var _ar_ = _aq_[2], x2$0 = _aq_[1];
    if(! _ar_){
     var f1$2 = caml_call1(f, x1$0), f2$2 = caml_call1(f, x2$0);
     return [0, f1$2, [0, f2$2, 0]];
    }
    var _as_ = _ar_[2], x3$0 = _ar_[1];
    if(! _as_){
     var
      f1$1 = caml_call1(f, x1$0),
      f2$1 = caml_call1(f, x2$0),
      f3$1 = caml_call1(f, x3$0);
     return [0, f1$1, [0, f2$1, [0, f3$1, 0]]];
    }
    var match$1 = _as_[2], x4$0 = _as_[1];
    if(! match$1){
     var
      f1$0 = caml_call1(f, x1$0),
      f2$0 = caml_call1(f, x2$0),
      f3$0 = caml_call1(f, x3$0),
      f4$0 = caml_call1(f, x4$0);
     return [0, f1$0, [0, f2$0, [0, f3$0, [0, f4$0, 0]]]];
    }
    var
     tl = match$1[2],
     x5$0 = match$1[1],
     f1 = caml_call1(f, x1$0),
     f2 = caml_call1(f, x2$0),
     f3 = caml_call1(f, x3$0),
     f4 = caml_call1(f, x4$0),
     f5 = caml_call1(f, x5$0);
    if(max_non_tailcall < ctr){
     a:
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            var bs$0 = 0, xs = tl;
            for(;;){
             if(! xs) break a;
             var _aj_ = xs[2];
             if(! _aj_) break;
             var _ak_ = _aj_[2];
             if(! _ak_) break h;
             var _al_ = _ak_[2];
             if(! _al_) break g;
             var _am_ = _al_[2];
             if(! _am_) break f;
             var _an_ = _am_[2];
             if(! _an_) break e;
             var _ao_ = _an_[2];
             if(! _ao_) break d;
             var _ap_ = _ao_[2];
             if(! _ap_) break c;
             var match$0 = _ap_[2];
             if(! match$0) break b;
             var
              xs$0 = match$0[2],
              x8 = match$0[1],
              x7 = _ap_[1],
              x6 = _ao_[1],
              x5 = _an_[1],
              x4 = _am_[1],
              x3 = _al_[1],
              x2 = _ak_[1],
              x1 = _aj_[1],
              x0 = xs[1],
              y0$0 = caml_call1(f, x0),
              y1$0 = caml_call1(f, x1),
              y2$0 = caml_call1(f, x2),
              y3$0 = caml_call1(f, x3),
              y4$0 = caml_call1(f, x4),
              y5$0 = caml_call1(f, x5),
              y6$0 = caml_call1(f, x6),
              y7$0 = caml_call1(f, x7),
              y8$0 = caml_call1(f, x8),
              bs$1 =
                [0,
                 [0, y0$0, y1$0, y2$0, y3$0, y4$0, y5$0, y6$0, y7$0, y8$0],
                 bs$0],
              bs$0 = bs$1,
              xs = xs$0;
            }
            break a;
           }
           break a;
          }
          break a;
         }
         break a;
        }
        break a;
       }
       break a;
      }
      break a;
     }
     var ys$1 = caml_call2(nontail_map, xs, f), ys = ys$1, param = bs$0;
     for(;;){
      if(! param){var _at_ = ys; break;}
      var
       bs = param[2],
       match = param[1],
       y8 = match[9],
       y7 = match[8],
       y6 = match[7],
       y5 = match[6],
       y4 = match[5],
       y3 = match[4],
       y2 = match[3],
       y1 = match[2],
       y0 = match[1],
       ys$0 =
         [0,
          y0,
          [0,
           y1,
           [0, y2, [0, y3, [0, y4, [0, y5, [0, y6, [0, y7, [0, y8, ys]]]]]]]]],
       ys = ys$0,
       param = bs;
     }
    }
    else
     var _at_ = count_map(f, tl, caml_call2(Base_Import[91], ctr, 1));
    return [0, f1, [0, f2, [0, f3, [0, f4, [0, f5, _at_]]]]];
   }
   function map(l, f){return count_map(f, l, 0);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    return caml_call1(rev, caml_call3(rev_map2_ok, l1, l2, f));
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_ah_){
              return function(_ai_){return map2_ok(_ah_, _ai_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac],
        l1$0 = l1$1,
        l2$0 = l2$1,
        l3$0 = l3$1,
        ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_ae_){
              return function(_af_){
               return function(_ag_){
                return rev_map3_ok(_ae_, _af_, _ag_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    return caml_call1(rev, rev_map3_ok(l1, l2, l3, f));
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_ab_){
              return function(_ac_){
               return function(_ad_){return map3_ok(_ab_, _ac_, _ad_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      h = l1$0[1],
      l2$1 = [0, caml_call1(f, h), l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0,
      l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _$_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _$_;
    }
    catch(_aa_){
     var ___ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _k_, caml_call1(length, l1), ___, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      acc = acc$0,
      param = t;
    }
   }
   function mapi(l, f){return caml_call1(rev, rev_mapi(l, f));}
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold_left,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _Y_ =
       caml_call3
        (fold_left,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _Z_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[91], i, 1), _Z_];
         });
    return caml_call1(Base_Import[127], _Y_);
   }
   function filteri(l, f){
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(pos, acc, x){
                return caml_call2(f, pos, x) ? [0, x, acc] : acc;
               }));
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold_left, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[126], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[116], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[115], num$0, 1),
       num$0 = num$1,
       acc$0 = acc$1,
       x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold_left, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[126], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var
     groups =
       foldi
        (l,
         0,
         function(i, acc, x){
          if(! acc) return [0, [0, x, 0], 0];
          var tl = acc[2], current_group = acc[1];
          return caml_call3(break$0, i, caml_call1(hd_exn, current_group), x)
                  ? [0, [0, x, 0], [0, current_group, tl]]
                  : [0, [0, x, current_group], tl];
         });
    return groups ? caml_call2(rev_map, groups, rev) : 0;
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function sort_and_group(l, compare){
    var _X_ = caml_call2(stable_sort, l, compare);
    return group
            (_X_,
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function concat_map(l, f){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call1(f, hd), acc),
      acc = acc$0,
      param = tl;
    }
   }
   function concat_mapi(l, f){
    var cont = 0, acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call2(f, cont, hd), acc),
      cont$0 = caml_call2(Base_Import[91], cont, 1),
      cont = cont$0,
      acc = acc$0,
      param = tl;
    }
   }
   function merge(l1, l2, compare){
    var acc = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return caml_call2(rev_append, acc, l2$0);
     if(! l2$0) return caml_call2(rev_append, acc, l1$0);
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2))
      var acc$0 = [0, h2, acc], acc = acc$0, l2$0 = t2;
     else
      var acc$1 = [0, h1, acc], acc = acc$1, l1$0 = t1;
    }
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function return$0(x){return [0, x, 0];}
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[11], [0, return$0, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, return$0, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, return$0, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[126], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _W_ = caml_call2(equal, hd, hd$0);
     if(! _W_) return _W_;
     var list$0 = list$1, prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     var a1$0 = a2, t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep))
      var
       to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep,
       to_keep = to_keep$1,
       param = tl;
     else
      var
       accum$0 = [0, to_keep, accum],
       to_keep = to_keep$0,
       accum = accum$0,
       param = tl;
    }
   }
   function dedup_and_sort(list, compare){
    if(list && list[2]){
     var
      equal =
        function(x$0, x){return 0 === caml_call2(compare, x$0, x) ? 1 : 0;},
      sorted = caml_call2(sort, list, compare);
     return remove_consecutive_duplicates(0, sorted, equal);
    }
    return list;
   }
   function find_a_dup(l, compare){
    var sorted = caml_call2(sort, l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       var l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    function compare$0(a, b){
     var _V_ = caml_call2(compare, a, b);
     return caml_call2(Base_Import[88], -1, _V_);
    }
    var sorted = caml_call2(sort, l, compare$0);
    if(! sorted) return 0;
    var
     sorted$2 = sorted[2],
     prev$1 = sorted[1],
     sorted$0 = sorted$2,
     prev = prev$1,
     already_recorded = 0,
     acc = 0;
    for(;;){
     if(! sorted$0) return acc;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === compare$0(prev, prev$0))
      if(already_recorded)
       var sorted$0 = sorted$1, prev = prev$0, already_recorded = 1;
      else
       var
        acc$0 = [0, prev$0, acc],
        sorted$0 = sorted$1,
        prev = prev$0,
        already_recorded = 1,
        acc = acc$0;
     else
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 0;
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _T_ = caml_call2(equal, x, x$0);
      if(_T_){var t = xs; continue;}
      var _U_ = _T_;
     }
     else
      var _U_ = 1;
     return _U_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){
    return caml_call3(Base_Container[2], fold_left, t, f);
   }
   function sum(m, t, f){
    return caml_call4(Base_Container[7], fold_left, m, t, f);
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold_left, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold_left, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _m_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[93], i, 1)), accum],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match)
      var x = match[1], accum$0 = [0, x, accum], l$0 = tl, accum = accum$0;
     else
      var l$0 = tl;
    }
   }
   function filter_map(l, f){return caml_call1(rev, rev_filter_map(l, f));}
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match)
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       l$0 = tl,
       accum = accum$0;
     else
      var i$1 = caml_call2(Base_Import[91], i, 1), i = i$1, l$0 = tl;
    }
   }
   function filter_mapi(l, f){return caml_call1(rev, rev_filter_mapi(l, f));}
   function filter_opt(l){return filter_map(l, function(_S_){return _S_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _Q_ = caml_call1(rev, trd), _R_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _R_, _Q_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _P_ = match[1];
     if(4152137 === _P_)
      var y = match[2], snd$0 = [0, y, snd], t$0 = t$1, snd = snd$0;
     else if(4202758 <= _P_)
      var y$0 = match[2], trd$0 = [0, y$0, trd], t$0 = t$1, trd = trd$0;
     else
      var y$1 = match[2], fst$0 = [0, y$1, fst], t$0 = t$1, fst = fst$0;
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[35]);
   }
   function t_of_sexp$0(of_a_014, of_b_015, x_023){
    function _M_(sexp_021){
     if(1 === sexp_021[0]){
      var _N_ = sexp_021[1];
      if(_N_){
       var _O_ = _N_[2];
       if(_O_ && ! _O_[2]){
        var
         arg1_018 = _O_[1],
         arg0_017 = _N_[1],
         res0_019 = caml_call1(of_a_014, arg0_017),
         res1_020 = caml_call1(of_b_015, arg1_018);
        return [0, res0_019, res1_020];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[2], error_source_022, 2, sexp_021);
    }
    return caml_call2(Base_Import[176], _M_, x_023);
   }
   function sexp_of_t$1(of_a_024, of_b_025, x_030){
    function _L_(param){
     var
      arg1_027 = param[2],
      arg0_026 = param[1],
      res0_028 = caml_call1(of_a_024, arg0_026),
      res1_029 = caml_call1(of_b_025, arg1_027);
     return [1, [0, res0_028, [0, res1_029, 0]]];
    }
    return caml_call2(Base_Import[152], _L_, x_030);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    return caml_call1
            (Base_Import[195],
             [2, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]);
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[127])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _K_){
                var y = _K_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _J_){
                var y = _J_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[127], x)];
   }
   var not_found$3 = [0, Base_Import[252], _p_];
   function find_exn$0(t, equal, key){
    var match = find$0(t, equal, key);
    if(! match) throw caml_maybe_attach_backtrace(not_found$3, 1);
    var value = match[1];
    return value;
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _F_ = pos < 0 ? 1 : 0;
    if(_F_)
     var _G_ = _F_;
    else{
     var _H_ = len < 0 ? 1 : 0;
     if(_H_)
      var _G_ = _H_;
     else
      var
       _I_ = caml_call1(length, l),
       _G_ = caml_call2(Base_Import[93], _I_, len) < pos ? 1 : 0;
    }
    if(_G_) caml_call1(Base_Import[126], cst_List_sub);
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(i, acc, el){
                if(pos <= i && i < caml_call2(Base_Import[91], pos, len))
                 return [0, el, acc];
                return acc;
               }));
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     if(! t) return [0, t_orig, 0];
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return caml_call1(rev, accum);
     if(! t) return t_orig;
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = tl, n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _q_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc],
      acc = acc$0,
      l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){var t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[124], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1, accum = 0;
    for(;;){
     if(! l1) return caml_call1(rev, accum);
     var
      tl = l1[2],
      hd = l1[1],
      accum$0 =
        caml_call2
         (rev_append,
          map
           (list2, function(hd){return function(x){return [0, hd, x];};}(hd)),
          accum),
      l1 = tl,
      accum = accum$0;
    }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold_left,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _E_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _E_) return _E_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _D_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _D_) return _D_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(list){
     var _C_ = list[2];
     if(_C_){
      if(_C_[2]){
       var arr = caml_call1(Base_Array0[13], list);
       caml_call4(Base_Array_permute[24], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[15], arr);
      }
      var y = _C_[1], x = list[1];
      return caml_call1(Base_Random[18][16], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[124], cst_List_random_element_exn_em);
    var _B_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[18][6], random_state, _B_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{
     var _z_ = [0, random_element_exn([0, random_state], list)];
     return _z_;
    }
    catch(_A_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[213];
   function equal(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _y_ = caml_call2(equal, x1, x2);
       if(! _y_) return _y_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match)
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc],
        t = tl,
        column_acc = column_acc$0,
        trimmed_rows = trimmed;
      else
       var tl$0 = t[2], t = tl$0, found_empty = 1;
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns],
      rows = trimmed_rows,
      columns = columns$0,
      do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   function _r_(param){
    if(param[1] !== Transpose_got_lists_of_differe)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
    var
     arg0_031 = param[2],
     res0_032 = caml_call2(Base_Import[152], Base_Import[142], arg0_031);
    return [1, [0, _s_, [0, res0_032, 0]]];
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Transpose_got_lists_of_differe, _r_);
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1], _x_ = 0;
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              _x_)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold_left, init, f, t);
   }
   function fold_until(t, init, f){
    var _v_ = caml_call3(Base_Container[9], fold_left, init, f);
    return function(_w_){return caml_call2(_v_, _w_, t);};
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _u_ = suffix_len <= list_len ? 1 : 0;
    return _u_
            ? equal
              (equal_elt,
               drop(list, caml_call2(Base_Import[93], list_len, suffix_len)),
               suffix)
            : _u_;
   }
   var
    Base_List =
      [0,
       compare$0,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold_left,
       fold_result,
       fold_until,
       exists,
       for_all,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        return$0,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, return$0, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       Or_unequal_lengths,
       of_list,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       concat_map,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold_left,
       unzip,
       unzip3,
       zip,
       zip_exn,
       mapi,
       rev_mapi,
       iteri,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count,
       counti,
       range$0,
       range,
       init,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(54, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Assert_failure, Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__Lazy, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ": ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "",
    cst$3 = "; ",
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Lazy = global_data.Base__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _l_ = [0, "src/info.ml", 204, 6],
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_could_not_construct_info = "could not construct info: ",
    _j_ =
      [0,
       [11, "and ", [4, 0, 0, 0, [11, " more info", 0]]],
       "and %d more info"],
    cst_Backtrace = "\nBacktrace:\n",
    cst_Base_Info_Exn = "Base__Info.Exn";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[4], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[139], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[199], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[4], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[139], arg0_009),
        res1_013 = caml_call1(Base_Sexp[4], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[149], Base_Source_code_position0[8], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[139], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[139], arg0_019),
        res1_023 = caml_call1(Base_Sexp[4], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[149], Base_Import[142], arg0_025),
        res1_028 = caml_call2(Base_Import[152], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[139], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_strings_hum(t, ac){
    var t$0 = t, ac$0 = ac;
    for(;;)
     switch(t$0[0]){
       case 0:
        var sexp = t$0[1];
        return [0,
                cst_could_not_construct_info,
                [0, caml_call1(Base_Sexp[16], sexp), ac$0]];
       case 1:
        var string = t$0[1]; return [0, string, ac$0];
       case 2:
        var exn = t$0[1], _R_ = caml_call1(Base_Exn[1], exn);
        return [0, caml_call1(Base_Sexp[16], _R_), ac$0];
       case 3:
        var sexp$0 = t$0[1];
        return [0, caml_call1(Base_Sexp[16], sexp$0), ac$0];
       case 4:
        var sexp$1 = t$0[2], tag = t$0[1];
        return [0,
                tag,
                [0, cst, [0, caml_call1(Base_Sexp[16], sexp$1), ac$0]]];
       case 5:
        var t$1 = t$0[2], tag$0 = t$0[1];
        return [0, tag$0, [0, cst$0, to_strings_hum(t$1, ac$0)]];
       case 6:
        var
         t$2 = t$0[3],
         sexp$2 = t$0[2],
         tag$1 = t$0[1],
         _S_ = [0, cst$1, to_strings_hum(t$2, ac$0)],
         body = [0, caml_call1(Base_Sexp[16], sexp$2), _S_];
        return 0 === caml_ml_string_length(tag$1)
                ? body
                : [0, tag$1, [0, cst$2, body]];
       case 7:
        var ts = t$0[2], trunc_after = t$0[1];
        if(trunc_after){
         var max = trunc_after[1], n = caml_call1(Base_List[7], ts);
         if(n <= max)
          var ts$0 = ts;
         else
          var
           _V_ = caml_call2(Base_Import[93], n, max),
           _W_ = [0, [1, caml_call2(Base_Printf[2], _j_, _V_)], 0],
           _X_ = caml_call2(Base_List[131], ts, max),
           ts$0 = caml_call2(Base_Import[111], _X_, _W_);
         var ts$1 = ts$0;
        }
        else
         var ts$1 = ts;
        var
         _T_ =
           function(ac, t){
            var ac$0 = caml_call1(Base_List[8], ac) ? ac : [0, cst$3, ac];
            return to_strings_hum(t, ac$0);
           },
         _U_ = caml_call1(Base_List[38], ts$1);
        return caml_call3(Base_List[10], _U_, ac$0, _T_);
       default:
        var
         backtrace = t$0[2],
         t$3 = t$0[1],
         ac$1 = [0, cst_Backtrace, [0, backtrace, ac$0]],
         t$0 = t$3,
         ac$0 = ac$1;
     }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _O_ = [0, caml_call1(Base_Source_code_position0[8], here$0), 0];
       else
        var _O_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _O_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var
        ts = t[2],
        _P_ = function(ac, t){return to_sexps_hum(t, ac);},
        _Q_ = caml_call1(Base_List[38], ts);
       return caml_call3(Base_List[10], _Q_, ac, _P_);
      default:
       var backtrace = t[2], t$2 = t[1];
       return [0, [1, [0, to_sexp_hum(t$2), [0, [0, backtrace], 0]]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function protect(f){
    try{var _N_ = caml_call1(f, 0); return _N_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, caml_call1(Base_Exn[1], exn)];
    }
   }
   function to_message(info){
    return protect
            (function(param){
              var _M_ = caml_obj_tag(info);
              if(250 === _M_) return info[1];
              if(246 !== _M_ && 244 !== _M_) return info;
              return caml_call1(CamlinternalLazy[2], info);
             });
   }
   function of_message(t){return [250, t];}
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return [246, function(_L_){return [3, sexp];}];}
   function compare(t1, t2){
    var _J_ = sexp_of_t$0(t2), _K_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _K_, _J_);
   }
   function equal(t1, t2){
    var _H_ = sexp_of_t$0(t2), _I_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[5], _I_, _H_);
   }
   function hash_fold_t(state, t){
    var _G_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[1], state, _G_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _F_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[15], 0, _F_);
   }
   function to_string_hum_deprecated(t){
    var t$0 = to_message(t), _E_ = to_strings_hum(t$0, 0);
    return caml_call2(Base_String0[14], 0, _E_);
   }
   function to_string_mach(t){
    var _D_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[16], _D_);
   }
   function of_lazy(l){
    return [246,
            function(_A_){
             return protect
                     (function(param){
                       var _B_ = caml_obj_tag(l);
                       a:
                       if(250 === _B_)
                        var _C_ = l[1];
                       else{
                        if(246 !== _B_ && 244 !== _B_){var _C_ = l; break a;}
                        var _C_ = caml_call1(CamlinternalLazy[2], l);
                       }
                       return [1, _C_];
                      });
            }];
   }
   function of_lazy_sexp(l){
    return [246,
            function(_x_){
             return protect
                     (function(param){
                       var _y_ = caml_obj_tag(l);
                       a:
                       if(250 === _y_)
                        var _z_ = l[1];
                       else{
                        if(246 !== _y_ && 244 !== _y_){var _z_ = l; break a;}
                        var _z_ = caml_call1(CamlinternalLazy[2], l);
                       }
                       return [3, _z_];
                      });
            }];
   }
   function of_lazy_t(lazy_t){return caml_call1(Base_Lazy[13], lazy_t);}
   function of_string(message){
    return caml_call1(Base_Lazy[21], [1, message]);
   }
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return [246,
            function(_w_){
             return protect(function(param){return [1, caml_call1(f, 0)];});
            }];
   }
   function create(here, strict, tag, x, sexp_of_x){
    return strict
            ? [250, [4, tag, caml_call1(sexp_of_x, x), here]]
            : [246,
              function(_v_){
               return protect
                       (function(param){
                         return [4, tag, caml_call1(sexp_of_x, x), here];
                        });
              }];
   }
   function create_s(sexp){return caml_call1(Base_Lazy[21], [3, sexp]);}
   function tag(t, tag){
    return [246, function(param){return [5, tag, to_message(t)];}];
   }
   function tag_s_lazy(t, tag){
    return [246,
            function(_r_){
             return protect
                     (function(param){
                       var _s_ = to_message(t), _t_ = caml_obj_tag(tag);
                       a:
                       if(250 === _t_)
                        var _u_ = tag[1];
                       else{
                        if(246 !== _t_ && 244 !== _t_){var _u_ = tag; break a;}
                        var _u_ = caml_call1(CamlinternalLazy[2], tag);
                       }
                       return [6, cst$4, _u_, _s_];
                      });
            }];
   }
   function tag_s(t, tag){
    return tag_s_lazy(t, caml_call1(Base_Lazy[21], tag));
   }
   function tag_arg(t, tag, x, sexp_of_x){
    return [246,
            function(_p_){
             return protect
                     (function(param){
                       var _q_ = to_message(t);
                       return [6, tag, caml_call1(sexp_of_x, x), _q_];
                      });
            }];
   }
   function of_list(trunc_after, ts){
    return [246,
            function(param){
             return [7,
                     trunc_after,
                     caml_call2(Base_List[76], ts, to_message)];
            }];
   }
   var Exn = [248, cst_Base_Info_Exn, runtime.caml_fresh_oo_id(0)];
   function _k_(param){
    if(param[1] !== Exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var t = param[2];
    return sexp_of_t$0(t);
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Exn, _k_);
   function to_exn(t){
    if(! caml_call1(Base_Lazy[22], t)) return [0, Exn, t];
    var _o_ = caml_obj_tag(t);
    a:
    if(250 === _o_)
     var match = t[1];
    else{
     if(246 !== _o_ && 244 !== _o_){var match = t; break a;}
     var match = caml_call1(CamlinternalLazy[2], t);
    }
    if(2 !== match[0]) return [0, Exn, t];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _n_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _n_ = [0, s];
     var backtrace$0 = _n_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return [246, function(param){return [8, to_message(t), backtrace$1];}];
    }
    if(! backtrace$0) return caml_call1(Base_Lazy[21], [2, exn]);
    var backtrace$2 = backtrace$0[1];
    return [246,
            function(param){
             return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
            }];
   }
   function pp(ppf, t){
    var _m_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _m_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(37, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    equal = Base_Info[2],
    hash_fold_t = Base_Info[3],
    hash = Base_Info[4],
    t_of_sexp = Base_Info[5],
    sexp_of_t = Base_Info[6],
    invariant = Base_Info[8],
    to_string_hum = Base_Info[9],
    to_string_mach = Base_Info[10],
    to_string_hum_deprecated = Base_Info[11],
    of_string = Base_Info[12],
    of_lazy = Base_Info[13],
    of_lazy_sexp = Base_Info[14],
    of_thunk = Base_Info[15],
    of_lazy_t = Base_Info[16],
    create = Base_Info[17],
    create_s = Base_Info[18],
    createf = Base_Info[19],
    tag = Base_Info[20],
    tag_s = Base_Info[21],
    tag_s_lazy = Base_Info[22],
    tag_arg = Base_Info[23],
    of_list = Base_Info[24],
    of_exn = Base_Info[25],
    to_exn = Base_Info[26],
    pp = Base_Info[27],
    Internal_repr = Base_Info[28];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field",
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[199], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[8], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[199], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[139], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    ignore_m = Base_Result[14],
    join = Base_Result[13],
    return$0 = Base_Result[12],
    bind = Base_Result[11],
    symbol_bind = Base_Result[7],
    _c_ = [0, "src/or_error.ml", 135, 22],
    cst_unimplemented = "unimplemented",
    _b_ = [0, 3553398],
    _a_ = Base_Result[30];
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[6], hash_fold_a, Base_Error[3], hsv, arg);
   }
   function t_of_sexp(of_a_013, x_015){
    return caml_call3(Base_Result[1], of_a_013, Base_Error[5], x_015);
   }
   function sexp_of_t(of_a_016, x_017){
    return caml_call3(Base_Result[2], of_a_016, Base_Error[6], x_017);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[7]);
   }
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[8], error);
   }
   function apply(f, x){
    function _y_(e1, e2){
     return caml_call2(Base_Error[24], 0, [0, e1, [0, e2, 0]]);
    }
    function _z_(f, x){return caml_call1(f, x);}
    return caml_call4(Base_Result[32], f, x, _z_, _y_);
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    include$0 = Base_Result[10],
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Open_on_rhs = [0],
    ok = Base_Result[23],
    is_ok = Base_Result[21],
    is_error = Base_Result[22];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _x_ = [0, caml_call1(f, 0)]; return _x_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _w_ = backtrace ? _b_ : 0;
     return [1, caml_call2(Base_Error[25], _w_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[29], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[25], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[17], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[18], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[12], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _t_ = Base_Error[20];
    function _u_(_v_){return caml_call2(_t_, _v_, tag);}
    return caml_call2(Base_Result[31], t, _u_);
   }
   function tag_s(t, tag){
    var _q_ = Base_Error[21];
    function _r_(_s_){return caml_call2(_q_, _s_, tag);}
    return caml_call2(Base_Result[31], t, _r_);
   }
   function tag_s_lazy(t, tag){
    var _n_ = Base_Error[22];
    function _o_(_p_){return caml_call2(_n_, _p_, tag);}
    return caml_call2(Base_Result[31], t, _o_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _m_(e){
     return caml_call4(Base_Error[23], e, message, a, sexp_of_a);
    }
    return caml_call2(Base_Result[31], t, _m_);
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[139]);
   }
   function combine_errors(l){
    var arg = Base_Error[24];
    function _k_(eta){return caml_call2(arg, 0, eta);}
    var _l_ = caml_call1(Base_Result[33], l);
    return caml_call2(Base_Result[31], _l_, _k_);
   }
   function combine_errors_unit(l){
    function _i_(param){return 0;}
    var _j_ = combine_errors(l);
    return caml_call2(Base_Result[30], _j_, _i_);
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[57], l, Base_Result[35]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call2(Base_Error[24], 0, errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[17], l, Base_Result[23]);
    if(match){var x = match[1]; return [0, x];}
    function _g_(param){
     if(0 === param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var err = param[1];
     return err;
    }
    var _h_ = caml_call2(Base_List[76], l, _g_);
    return [1, caml_call2(Base_Error[24], 0, _h_)];
   }
   function find_map_ok(l, f){
    function _d_(param){
     function _e_(elt){
      var x = caml_call1(f, elt);
      if(0 === x[0]) return caml_call1(param, x);
      var err = x[1];
      return err;
     }
     var _f_ = caml_call2(Base_List[76], l, _e_);
     return [1, caml_call2(Base_Error[24], 0, _f_)];
    }
    return caml_call1(Base_With_return[1], _d_);
   }
   var
    map$1 = Base_Result[30],
    iter = Base_Result[28],
    iter_error = Base_Result[29],
    Base_Or_error =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[10],
       bind,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(caml_string_notequal(_e_, cst_Neg)){
       c:
       if(caml_string_notequal(_e_, cst_Pos)){
        if(caml_string_notequal(_e_, cst_Zero)){
         if(! caml_string_notequal(_e_, cst_neg)) break b;
         if(! caml_string_notequal(_e_, cst_pos)) break c;
         if(caml_string_notequal(_e_, cst_zero)) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(caml_string_notequal(_h_, cst_Neg)){
      c:
      if(caml_string_notequal(_h_, cst_Pos)){
       if(caml_string_notequal(_h_, cst_Zero)){
        if(! caml_string_notequal(_h_, cst_neg)) break b;
        if(! caml_string_notequal(_h_, cst_pos)) break c;
        if(caml_string_notequal(_h_, cst_zero)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[139], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[163], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Assert_failure, Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 133, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _a_ = [0, cst_src_comparable_ml, 47, 4];
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Polymorphic_compare(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Polymorphic_compare([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _s_ = caml_call2(symbol$0, low, t);
     return _s_ ? caml_call2(symbol$0, t, high) : _s_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _p_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _q_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _p_],
      _r_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max$0, _q_);
     return caml_call1(Base_Or_error[35], _r_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[5], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _n_ = caml_call1(T[2], t), _o_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _o_, _n_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     var param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _m_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _m_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function _c_(_i_){
    var _j_ = _i_[3], _k_ = _i_[1];
    function is_positive(t){return 0 < caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_non_negative(t){return 0 <= caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_negative(t){return caml_call2(_k_, t, _j_) < 0 ? 1 : 0;}
    function is_non_positive(t){return caml_call2(_k_, t, _j_) <= 0 ? 1 : 0;}
    function sign(t){
     var _l_ = caml_call2(_k_, t, _j_);
     return caml_call1(Base_Sign0[13], _l_);
    }
    return [0,
            is_positive,
            is_non_negative,
            is_negative,
            is_non_positive,
            sign];
   }
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       equal,
       max,
       min,
       Infix,
       Polymorphic_compare,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _g_ = caml_lessequal(low, t),
          _h_ = _g_ ? caml_lessequal(t, high) : _g_;
         return _h_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _d_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _e_ = [0, [0, cst_min, caml_call1(T[1], min)], _d_],
          _f_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _e_);
         return caml_call1(Base_Or_error[35], _f_);
        }
        var
         include =
           caml_call1(Base_Comparator[5], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       _c_];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    _a_ = [0, "_"];
   function equal(a, b){
    var _b_ = caml_call2(Base_Import[128], a, b);
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = caml_call2(Base_Import[128], a[1], b[1]);
     if(_d_){
      var _e_ = caml_call2(Base_Import[128], a[2], b[2]);
      if(_e_) return caml_call2(Base_Import[128], a[3], b[3]);
      var _c_ = _e_;
     }
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Stdlib_MoreLabels[1][30],
    hash = Stdlib_MoreLabels[1][28],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(3, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer;
   function _a_(T){
    var
     hash_fold_t = T[2],
     hash = T[3],
     t_of_sexp = T[4],
     sexp_of_t = T[5],
     of_string = T[6],
     to_string = T[7],
     _c_ = caml_call1(Base_Comparable[11], [0, T[5], T[9]]),
     symbol = _c_[1],
     symbol$0 = _c_[2],
     symbol$1 = _c_[3],
     symbol$2 = _c_[4],
     symbol$3 = _c_[5],
     symbol$4 = _c_[6],
     equal = _c_[7],
     compare = _c_[8],
     min = _c_[9],
     max = _c_[10],
     ascending = _c_[11],
     descending = _c_[12],
     between = _c_[13],
     clamp_exn = _c_[14],
     clamp = _c_[15],
     comparator = _c_[16],
     include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
     pp = include[1],
     hashable = [0, hash, compare, sexp_of_t];
    return [0,
            hash_fold_t,
            hash,
            t_of_sexp,
            sexp_of_t,
            of_string,
            to_string,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable];
   }
   var
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[10], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       _a_];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    hash_fold_t = Base_Import[211],
    func = Base_Import[225],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[181];
   function compare(param, _a_){return 0;}
   function of_string(param){
    return runtime.caml_string_notequal(param, cst$0)
            ? caml_call1(Base_Import[124], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Or_error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Or_error = global_data.Base__Or_error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return caml_call1(Base_Or_error[36], s);
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Fn, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Fn = global_data.Base__Fn;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[91], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[93], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[93], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[93], hi, lo$1),
      _d_ = caml_call2(Base_Import[95], _c_, 2),
      mid = caml_call2(Base_Import[91], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      var hi = mid;
     else
      var lo$2 = caml_call2(Base_Import[91], mid, 1), lo$1 = lo$2;
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[91], lo, 1), lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0], [0, len$0], t, get, length, caml_call1(Base_Fn[2], pred));
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[93], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[91], pos$0, len$0);
    return [0, caml_call2(Base_Import[93], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(3, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   function _a_(T){
    var get = T[1], length = T[2], _c_ = Make_gen([0, get, length]);
    return [0, _c_[3], _c_[4]];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       _a_];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Bytes0, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _q_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _q_);
     var _r_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _r_);
     var _s_ = 0 < len ? 1 : 0;
     return _s_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _s_;
    }
    function blito(src, opt, _o_, dst, _n_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_o_)
      var sth$0 = _o_[1], src_len = sth$0;
     else
      var
       _p_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[93], _p_, src_pos);
     if(_n_) var sth$1 = _n_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _m_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _m_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _l_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[93], _l_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     var _k_ = caml_call3(To_bytes[4], src, pos, len);
     return caml_call1(Base_Bytes0[16], _k_);
    }
    function subo(pos, len, src){
     var _j_ = caml_call3(To_bytes[5], pos, len, src);
     return caml_call1(Base_Bytes0[16], _j_);
    }
    return [0, sub, subo];
   }
   function _a_(_h_){
    var _i_ = Make_gen([0, _h_[2]], [0, _h_[2], _h_[1], _h_[3]]);
    return [0, _i_[2], _i_[3], _i_[1], _i_[4], _i_[5]];
   }
   function _b_(_e_){
    var _f_ = [0, _e_[2], _e_[1], _e_[3]], _g_ = Make_gen([0, _f_[1]], _f_);
    return [0, _g_[2], _g_[3], _g_[1], _g_[4], _g_[5]];
   }
   function _c_(Src, Dst){
    var length = Dst[1];
    function create_like(len, param){return caml_call1(Dst[2], len);}
    var
     unsafe_blit = Dst[3],
     length$0 = Src[1],
     _d_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
    return [0, _d_[2], _d_[3], _d_[1], _d_[4], _d_[5]];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       _c_,
       Make_to_string,
       _b_,
       _a_];
   runtime.caml_register_global(3, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Container, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Container = global_data.Base__Container,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare = Base_Import[237],
    hash_fold_t = Base_Import[212],
    t_of_sexp = Base_Import[173],
    sexp_of_t = Base_Import[149],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _g_ =
         caml_call2
          (Base_Import[150], Base_Error[6], Base_Source_code_position0[8]),
       _h_ = value(message, cst),
       _i_ = caml_call5(Base_Error[17], 0, 0, _h_, [0, e, p], _g_);
     else if(message)
      var
       m = message[1],
       _i_ =
         caml_call5(Base_Error[17], 0, 0, m, p, Base_Source_code_position0[8]);
     else
      var
       _i_ =
         caml_call5
          (Base_Error[17],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[8]);
     var error$0 = _i_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _j_ = caml_call2(Base_Error[20], e$0, m$0);
     else
      var _j_ = e$0;
     var error$0 = _j_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[12], m$1);
    else
     var error$0 = caml_call1(Base_Error[12], cst_Option_value_exn_None);
    return caml_call1(Base_Error[29], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function min_elt(t, param){return t;}
   function max_elt(t, param){return t;}
   function sum(M){return function(t, f){return value_map(t, M[1], f);};}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function count(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a) ? 1 : 0;
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_f_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_e_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function apply(f, x){if(! f) return 0; var f$0 = f[1]; return _a_(x, f$0);}
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    _b_ = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = _b_[1],
    Monad_infix = _b_[3],
    bind$0 = _b_[4],
    join = _b_[7],
    ignore_m = _b_[8],
    Let_syntax = _b_[11],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _c_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_d_){return caml_call2(_c_, _d_, t);};
   }
   var
    Base_Option =
      [0,
       compare,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result,
       fold_until,
       min_elt,
       max_elt,
       count,
       sum];
   runtime.caml_register_global(9, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[160], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[160], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[160], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[160], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[159], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[160], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    return [0, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(2, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__Option, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_Option = global_data.Base__Option,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare = Base_Either0[1],
    hash_fold_t = Base_Either0[2],
    t_of_sexp = Base_Either0[3],
    sexp_of_t = Base_Either0[4],
    t_sexp_grammar = Base_Either0[5];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     either = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         return caml_call2
                 (bind,
                  t,
                  function(x){return caml_call1(return$0, caml_call1(f, x));});
        }],
     include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9],
     _a_ = include[7];
    function apply(t1, t2){
     return caml_call2
             (bind$0,
              t1,
              function(f){
               return caml_call2
                       (bind$0,
                        t2,
                        function(x){return caml_call1(return$1, caml_call1(f, x));});
              });
    }
    var
     map$0 = [0, -198771759, _a_],
     App = caml_call1(Base_Applicative[6], [0, return$1, apply, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply$0 = App[8],
     map2 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function other_loop(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     function _i_(o){return other_loop(f, caml_call2(f, acc, o), ts);}
     return caml_call3
             (either, t, function(param){return other_loop(f, acc, ts);}, _i_);
    }
    function return_loop(f, acc, param){
     if(! param) return caml_call1(return$2, caml_call1(Base_List0[21], acc));
     var ts = param[2], t = param[1];
     function _h_(o){return other_loop(f, o, ts);}
     return caml_call3
             (either,
              t,
              function(x){return return_loop(f, [0, x, acc], ts);},
              _h_);
    }
    function combine_all(ts, f){return return_loop(f, 0, ts);}
    function other_loop$0(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     function _g_(o){return other_loop$0(f, caml_call2(f, acc, o), ts);}
     return caml_call3
             (either,
              t,
              function(param){return other_loop$0(f, acc, ts);},
              _g_);
    }
    function return_loop$0(f, param){
     if(! param) return caml_call1(return$2, 0);
     var ts = param[2], t = param[1];
     function _f_(o){return other_loop$0(f, o, ts);}
     return caml_call3
             (either, t, function(param){return return_loop$0(f, ts);}, _f_);
    }
    function combine_all_unit(ts, f){return return_loop$0(f, ts);}
    function to_option(t){
     function _e_(param){return 0;}
     return caml_call3(either, t, Base_Option[46], _e_);
    }
    function value(t, default$0){
     function _c_(param){return default$0;}
     return caml_call3(either, t, function(_d_){return _d_;}, _c_);
    }
    function with_return(f){
     function _b_(ret){
      return caml_call1
              (other,
               caml_call1(f, caml_call2(Base_With_return[3], ret, return$2)));
     }
     return caml_call1(Base_With_return[1], _b_);
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function either(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(return$0, x);}
    var y = t[1];
    return caml_call1(other, y);
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, either, combine, bind]);
   function either$0(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(other, x);}
    var y = t[1];
    return caml_call1(return$0, y);
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, either$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(6, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Container, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Container = global_data.Base__Container,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold, t, 0, function(i, x){caml_call2(f, i, x); return i + 1 | 0;});
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = i[1] + 1 | 0;
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){return caml_call2(f, i, a) ? n + 1 | 0 : n;});
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _d_ = caml_call2(f, i, x);
                 return _d_ ? caml_call1(r, 1) : _d_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _c_ = 1 - caml_call2(f, i, x);
                 return _c_ ? caml_call1(r, 0) : _c_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _b_ = caml_call2(f, i, x);
                 return _b_ ? caml_call1(r, [0, [0, i, x]]) : _b_;
                });
              return 0;
             });
   }
   function Make_gen(T){
    var
     include = caml_call1(Base_Container[18], [0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     iter = include[3],
     fold = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function _a_(T){
    var
     C = caml_call1(Base_Container[17], [0, T[1], T[2], T[3], T[4]]),
     mem = C[1],
     fold = T[2],
     iter = T[3],
     length = T[4],
     iteri = T[5],
     foldi = T[6],
     include = Make_gen([0, fold, iter, length, iteri, foldi]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[3],
     fold$0 = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     foldi$0 = include[17],
     iteri$0 = include[18],
     existsi = include[19],
     for_alli = include[20],
     counti = include[21],
     findi = include[22],
     find_mapi = include[23];
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         C = caml_call1(Base_Container[16], [0, T[1], T[2], T[3]]),
         mem = C[1],
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       _a_,
       Make_gen];
   runtime.caml_register_global
    (2, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Result, Base__With_return, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_025 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_With_return = global_data.Base__With_return,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _j_ = [0, 0],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn",
    cst_Sequence_drop = "Sequence.drop",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_hd_exn = "hd_exn",
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _i_ = [0, cst_Both$0],
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    cst_Sequence_nth = cst_Sequence_nth$1,
    _f_ = [0, "src/sequence.ml", 259, 14],
    _e_ = [0, 0, 0],
    _a_ = [0, "Done"],
    _b_ = [0, "Skip"],
    _c_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var arg0_003 = param[1], res0_004 = caml_call1(of_s_002, arg0_003);
     return [1, [0, _b_, [0, res0_004, 0]]];
    }
    var
     arg1_006 = param[2],
     arg0_005 = param[1],
     res0_007 = caml_call1(of_a_001, arg0_005),
     res1_008 = caml_call1(of_s_002, arg1_006);
    return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
   }
   var Step = [0, sexp_of_t];
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_Z_){return loop(s$0, next, finish, f, _Z_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_Y_){return loop(s$1, next, finish, f, _Y_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   var Expert = [0, next_step, delayed_fold_step];
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    return [0,
            init,
            function(s){
             var match = caml_call1(f, s);
             if(! match) return 0;
             var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
             return [1, a, s$0];
            }];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(l){
    return [0,
            l,
            function(param){
             if(! param) return 0;
             var l = param[2], x = param[1];
             return [1, x, l];
            }];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else
      var
       seed$1 = match[2],
       a = match[1],
       v$0 = caml_call2(f, v, a),
       seed = seed$1,
       v = v$0;
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1];
    function to_list(s, next, i){
     var s$0 = s;
     for(;;){
      if(0 === i){
       var t = [0, s$0, next], _X_ = to_list_rev(t);
       return caml_call1(Base_List1[21], _X_);
      }
      var match = caml_call1(next, s$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s$2 = match[2], a = match[1];
       return [0, a, to_list(s$2, next, caml_call2(Base_Import[93], i, 1))];
      }
      var s$1 = match[1], s$0 = s$1;
     }
    }
    return to_list(s, next, 500);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _W_ = to_list(t);
    return caml_call2(Base_Import[152], sexp_of_a, _W_);
   }
   function range(opt, _V_, _U_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_V_) var sth$0 = _V_[1], start = sth$0; else var start = 104758188;
    if(_U_) var sth$1 = _U_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[91], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    return [0,
            t_lazy,
            function(t_lazy){
             var _T_ = caml_obj_tag(t_lazy);
             a:
             if(250 === _T_)
              var match = t_lazy[1];
             else{
              if(246 !== _T_ && 244 !== _T_){var match = t_lazy; break a;}
              var match = caml_call1(CamlinternalLazy[2], t_lazy);
             }
             var next = match[2], s = match[1], match$0 = caml_call1(next, s);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$0 = match$0[1], v = [0, s$0, next];
              return [0, v];
             }
             var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
             return [1, x, v$0];
            }];
   }
   function _d_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _S_ = [0, caml_call2(Base_Import[91], i, 1), s$1];
             return [1, caml_call2(f, i, a), _S_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[91], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _Q_ = Base_Import[127];
    function _R_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return _d_(filter(mapi(t, function(i, s){return [0, i, s];}), _R_), _Q_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s = s$1;
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _e_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[91], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[93], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      var s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[91], i, 1), s = s$1, i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      var seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1], s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    return [0,
            [0, empty, t],
            function(param){
             var
              rest = param[2],
              match = param[1],
              next = match[2],
              seed = match[1],
              match$0 = caml_call1(next, seed);
             if(typeof match$0 === "number"){
              var
               next$0 = rest[2],
               seed$0 = rest[1],
               match$1 = caml_call1(next$0, seed$0);
              if(typeof match$1 === "number") return 0;
              if(0 === match$1[0]){
               var s = match$1[1];
               return [0, [0, empty, [0, s, next$0]]];
              }
              var s$0 = match$1[2], a = match$1[1];
              return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
             }
             if(0 === match$0[0]){
              var s$1 = match$0[1];
              return [0, [0, [0, s$1, next], rest]];
             }
             var s$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, [0, s$2, next], rest]];
            }];
   }
   function return$0(x){
    return [0,
            [0, x],
            function(param){
             if(! param) return 0;
             var x = param[1];
             return [1, x, 0];
            }];
   }
   var
    map = [0, -198771759, _d_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(caml_call2(Base_Import[128], i, 0)) return [0, a];
      var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[126], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare(cmp_a, cmp_b, a_011, b_012){
    if(caml_call2(Base_Ppx_compare_lib[1], a_011, b_012)) return 0;
    switch(a_011[0]){
      case 0:
       var a_013 = a_011[1];
       if(0 !== b_012[0]) return -1;
       var b_014 = b_012[1];
       return caml_call2(cmp_a, a_013, b_014);
      case 1:
       var a_015 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          var b_016 = b_012[1]; return caml_call2(cmp_b, a_015, b_016);
         default: return -1;
       }
       break;
      default:
       var a_019 = a_011[2], a_017 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_020 = b_012[2],
           b_018 = b_012[1],
           n = caml_call2(cmp_a, a_017, b_018);
          return 0 === n ? caml_call2(cmp_b, a_019, b_020) : n;
       }
    }
    return 1;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_021, of_b_022, sexp_027){
    a:
    {
     if(0 === sexp_027[0]){
      var _M_ = sexp_027[1];
      b:
      if(caml_string_notequal(_M_, cst_Both$0)){
       c:
       if(caml_string_notequal(_M_, cst_Left$0)){
        if(caml_string_notequal(_M_, cst_Right$0)){
         if(! caml_string_notequal(_M_, cst_both)) break b;
         if(! caml_string_notequal(_M_, cst_left)) break c;
         if(caml_string_notequal(_M_, cst_right)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
     }
     var _N_ = sexp_027[1];
     if(! _N_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_025, sexp_027);
     var _O_ = _N_[1];
     if(0 !== _O_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_025, sexp_027);
     var tag_028 = _O_[1];
     b:
     if(caml_string_notequal(tag_028, cst_Both$0)){
      c:
      if(caml_string_notequal(tag_028, cst_Left$0)){
       if(caml_string_notequal(tag_028, cst_Right$0)){
        if(! caml_string_notequal(tag_028, cst_both)) break b;
        if(! caml_string_notequal(tag_028, cst_left)) break c;
        if(caml_string_notequal(tag_028, cst_right)) break a;
       }
       var sexp_args_034 = _N_[2];
       if(sexp_args_034 && ! sexp_args_034[2]){
        var
         arg0_035 = sexp_args_034[1],
         res0_036 = caml_call1(of_b_022, arg0_035);
        return [1, res0_036];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_025,
                tag_028,
                sexp_027);
      }
      var sexp_args_029 = _N_[2];
      if(sexp_args_029 && ! sexp_args_029[2]){
       var
        arg0_030 = sexp_args_029[1],
        res0_031 = caml_call1(of_a_021, arg0_030);
       return [0, res0_031];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_025,
               tag_028,
               sexp_027);
     }
     var sexp_args_039 = _N_[2];
     if(sexp_args_039){
      var _P_ = sexp_args_039[2];
      if(_P_ && ! _P_[2]){
       var
        arg1_041 = _P_[1],
        arg0_040 = sexp_args_039[1],
        res0_042 = caml_call1(of_a_021, arg0_040),
        res1_043 = caml_call1(of_b_022, arg1_041);
       return [2, res0_042, res1_043];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_025,
              tag_028,
              sexp_027);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_025, sexp_027);
   }
   function sexp_of_t$1(of_a_046, of_b_047, param){
    switch(param[0]){
      case 0:
       var arg0_048 = param[1], res0_049 = caml_call1(of_a_046, arg0_048);
       return [1, [0, _g_, [0, res0_049, 0]]];
      case 1:
       var arg0_050 = param[1], res0_051 = caml_call1(of_b_047, arg0_050);
       return [1, [0, _h_, [0, res0_051, 0]]];
      default:
       var
        arg1_053 = param[2],
        arg0_052 = param[1],
        res0_054 = caml_call1(of_a_046, arg0_052),
        res1_055 = caml_call1(of_b_047, arg1_053);
       return [1, [0, _i_, [0, res0_054, [0, res1_055, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   var
    Merge_with_duplicates_element =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t$1, t_sexp_grammar];
   function merge_with_duplicates(param, _L_, compare){
    var next2 = _L_[2], s2 = _L_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    function _K_(param){var x = param[1]; return x;}
    return caml_call2(map$0, merge_with_duplicates(s1, s2, compare), _K_);
   }
   function merge_sorted(param, _J_, compare){
    var next2 = _J_[2], s2 = _J_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[124], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    function _I_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return filter_map(mapi(s, function(i, s){return [0, i, s];}), _I_);
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[21], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[21], accum), empty];
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[93], i, 1),
       s$0 = s$2,
       i = i$0,
       accum = accum$0;
    }
   }
   function chunks_exn(t, n){
    return 0 < n
            ? [0,
              t,
              function(t){
               var match = split_n(t, n), xs = match[1];
               if(! xs) return 0;
               var t$0 = match[2];
               return [1, xs, t$0];
              }]
            : caml_call1(Base_Import[126], cst_Sequence_chunks_exn);
   }
   function findi(s, f){
    function _H_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return find(mapi(s, function(i, s){return [0, i, s];}), _H_);
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){return concat_map(s, function(_G_){return _G_;});}
   function concat_mapi(s, f){
    function _F_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return concat_map(mapi(s, function(i, s){return [0, i, s];}), _F_);
   }
   function zip(param, _D_){
    var next2 = _D_[2], s2 = _D_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _E_ = param[1];
     if(typeof _E_ !== "number"){
      if(1 === _E_[0]){
       var match = param[2], s1$0 = _E_[2], a = _E_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _E_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _E_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _C_){
    var next2 = _C_[2], s2 = _C_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0])
      var seed$1 = match[1], seed$0 = seed$1;
     else
      var
       seed$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       seed$0 = seed$2;
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       acc$0 = caml_call2(Base_Import[91], acc, 1),
       s$0 = s$2,
       acc = acc$0;
    }
   }
   function iteri(s, f){
    function _B_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return iter(mapi(s, function(i, s){return [0, i, s];}), _B_);
   }
   function foldi(s, init, f){
    function _A_(acc, param){
     var s = param[2], i = param[1];
     return caml_call3(f, i, acc, s);
    }
    return fold(mapi(s, function(i, s){return [0, i, s];}), init, _A_);
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    return [0,
            [0, [0, 0, s]],
            function(param){
             if(! param) return 0;
             var
              match = param[1],
              s = match[2],
              acc = match[1],
              match$0 = caml_call1(next, s);
             if(typeof match$0 !== "number" && 0 === match$0[0]){
              var s$2 = match$0[1];
              return [0, [0, [0, acc, s$2]]];
             }
             if(acc){
              if(typeof match$0 === "number")
               return [1, caml_call1(Base_List1[21], acc), 0];
              var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
              return caml_call2(break$0, prev, cur)
                      ? [1,
                        caml_call1(Base_List1[21], acc),
                        [0, [0, [0, cur, 0], s$0]]]
                      : [0, [0, [0, [0, cur, acc], s$0]]];
             }
             if(typeof match$0 === "number") return 0;
             var s$1 = match$0[2], cur$0 = match$0[1];
             return [0, [0, [0, [0, cur$0, 0], s$1]]];
            }];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a], last_elt = last_elt$0, s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){return length(filter(s, f));}
   function counti(t, f){return length(filteri(t, f));}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    return [0,
            0,
            function(i){
             if(n <= i) return 0;
             var _z_ = caml_call2(Base_Import[91], i, 1);
             return [1, caml_call1(f, i), _z_];
            }];
   }
   function sub(s, pos, len){
    var _x_ = pos < 0 ? 1 : 0, _y_ = _x_ || (len < 0 ? 1 : 0);
    if(_y_) caml_call1(Base_Import[124], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[93], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var Infix = [0, append];
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _w_ = param[1];
             if(815032112 === _w_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _w_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(x){return [0, x, function(x){return [1, x, x];}];}
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[23], xs))
     caml_call1(Base_Import[126], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function _v_(param){return s;}
    return concat_map(repeat(0), _v_);
   }
   function cartesian_product(sa, sb){
    return concat_map(sa, function(a){return zip(repeat(a), sb);});
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    function _u_(acc, option, k){
     if(! option) return caml_call1(k, acc);
     var a = option[1];
     return caml_call3(f, acc, a, k);
    }
    return caml_call4(Expert[2], s, init, _u_, finish);
   }
   function fold_m(bind, return$0, t, init, f){
    function _t_(acc, option, k){
     if(! option) return caml_call2(bind, caml_call1(return$0, acc), k);
     var a = option[1];
     return caml_call2(bind, caml_call2(f, acc, a), k);
    }
    return caml_call4(Expert[2], t, init, _t_, return$0);
   }
   function iter_m(bind, return$0, t, f){
    function _s_(param, option, k){
     if(! option) return caml_call2(bind, caml_call1(return$0, 0), k);
     var a = option[1];
     return caml_call2(bind, caml_call1(f, a), k);
    }
    return caml_call4(Expert[2], t, 0, _s_, return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[12], acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_r_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1], s$0 = s$1;
               }
              }]];
    }
    function _p_(param){
     var l = param[1], _q_ = caml_obj_tag(l);
     if(250 === _q_) return l[1];
     if(246 !== _q_ && 244 !== _q_) return l;
     return caml_call1(CamlinternalLazy[2], l);
    }
    return [0, memoize(s), _p_];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s$0 = s$2;
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      var s$0 = s$2;
     }
    }
   }
   function compare$0(compare_a, t1, t2){
    function _l_(r){
     function _m_(param){
      var _n_ = param[1];
      if(737457313 !== _n_)
       return 847852583 <= _n_ ? caml_call1(r, 1) : caml_call1(r, -1);
      var
       match = param[2],
       v2 = match[2],
       v1 = match[1],
       c = caml_call2(compare_a, v1, v2),
       _o_ = 0 !== c ? 1 : 0;
      return _o_ ? caml_call1(r, c) : _o_;
     }
     iter(zip_full(t1, t2), _m_);
     return 0;
    }
    return caml_call1(Base_With_return[1], _l_);
   }
   function equal(equal_a, t1, t2){
    function _k_(param){
     if(737457313 !== param[1]) return 0;
     var match = param[2], a2 = match[2], a1 = match[1];
     return caml_call2(equal_a, a1, a2);
    }
    return for_all(zip_full(t1, t2), _k_);
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[23], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[21], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[21], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(seq){
    return [0,
            seq,
            function(seq){
             var match = caml_call1(seq, 0);
             if(! match) return 0;
             var tl = match[2], hd = match[1];
             return [1, hd, tl];
            }];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1], state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _j_;});}
    function f(thunk){return caml_call1(thunk, 0)[1];}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       sexp_of_t$0,
       equal,
       compare$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       Expert];
   runtime.caml_register_global(48, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23],
    compare = Base_Import[235],
    t_of_sexp = Base_Import[177],
    sexp_of_t = Base_Import[153],
    _g_ = [0, cst_src_array_ml, 858, 8],
    cst_Array_transpose_exn = "Array.transpose_exn",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_reduce_exn = "Array.reduce_exn",
    _d_ = [0, "Array.find_exn: not found"],
    _c_ = [0, "Array.findi_exn: not found"],
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_iter2_exn = "Array.iter2_exn",
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _a_ = [0, cst_src_array_ml, 435, 14],
    _e_ = [0, "Array.find_map_exn: not found"],
    _f_ = [0, "Array.find_mapi_exn: not found"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[196], a_sexp_grammar);
   }
   function get(_aL_, _aK_){return caml_check_bound(_aL_, _aK_)[1 + _aK_];}
   function set(_aJ_, _aI_, _aH_){
    caml_check_bound(_aJ_, _aI_)[1 + _aI_] = _aH_;
    return 0;
   }
   function swap$0(arr, i, j){
    var tmp = get(arr, i);
    set(arr, i, get(arr, j));
    return set(arr, j, tmp);
   }
   function sort(arr, compare, left, right){
    var _aF_ = caml_call2(Base_Import[91], left, 1);
    if(right >= _aF_){
     var pos = _aF_;
     for(;;){
      var v = get(arr, pos), final_pos = pos;
      for(;;){
       var i_next = caml_call2(Base_Import[93], final_pos, 1);
       if(left > i_next) break;
       if(0 >= caml_call2(compare, get(arr, i_next), v)) break;
       set(arr, final_pos, get(arr, i_next));
       var final_pos = i_next;
      }
      set(arr, final_pos, v);
      var _aG_ = pos + 1 | 0;
      if(right === pos) break;
      var pos = _aG_;
     }
    }
    return 0;
   }
   var Insertion_sort = [0, sort];
   function heapify(arr, compare, root, left, right){
    var root$0 = root;
    for(;;){
     var
      relative_root = caml_call2(Base_Import[93], root$0, left),
      _ay_ = caml_call2(Base_Import[88], 2, relative_root),
      _az_ = caml_call2(Base_Import[91], _ay_, left),
      left_child = caml_call2(Base_Import[91], _az_, 1),
      _aA_ = caml_call2(Base_Import[88], 2, relative_root),
      _aB_ = caml_call2(Base_Import[91], _aA_, left),
      right_child = caml_call2(Base_Import[91], _aB_, 2);
     a:
     {
      if(left_child <= right){
       var _aC_ = get(arr, root$0);
       if(0 < caml_call2(compare, get(arr, left_child), _aC_)){var largest = left_child; break a;}
      }
      var largest = root$0;
     }
     a:
     {
      if(right_child <= right){
       var _aD_ = get(arr, largest);
       if(0 < caml_call2(compare, get(arr, right_child), _aD_)){var largest$0 = right_child; break a;}
      }
      var largest$0 = largest;
     }
     var _aE_ = largest$0 !== root$0 ? 1 : 0;
     if(! _aE_) return _aE_;
     swap$0(arr, root$0, largest$0);
     var root$0 = largest$0;
    }
   }
   function sort$0(arr, compare, left, right){
    var
     _at_ = caml_call2(Base_Import[91], left, right),
     _au_ = caml_call2(Base_Import[95], _at_, 2);
    if(_au_ >= left){
     var i = _au_;
     for(;;){
      heapify(arr, compare, i, left, right);
      var _av_ = i - 1 | 0;
      if(left === i) break;
      var i = _av_;
     }
    }
    var _aw_ = caml_call2(Base_Import[91], left, 1);
    if(right >= _aw_){
     var i$0 = right;
     for(;;){
      swap$0(arr, left, i$0);
      heapify(arr, compare, left, left, caml_call2(Base_Import[93], i$0, 1));
      var _ax_ = i$0 - 1 | 0;
      if(_aw_ === i$0) break;
      var i$0 = _ax_;
     }
    }
    return 0;
   }
   var Heap_sort = [0, sort$0];
   function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
    function compare_and_swap(i, j){
     var
      _ar_ = get(arr, j),
      _as_ = 0 < caml_call2(compare, get(arr, i), _ar_) ? 1 : 0;
     return _as_ ? swap$0(arr, i, j) : _as_;
    }
    compare_and_swap(m1, m2);
    compare_and_swap(m4, m5);
    compare_and_swap(m1, m3);
    compare_and_swap(m2, m3);
    compare_and_swap(m1, m4);
    compare_and_swap(m3, m4);
    compare_and_swap(m2, m5);
    compare_and_swap(m2, m3);
    return compare_and_swap(m4, m5);
   }
   function intro_sort(arr, max_depth, compare, left, right){
    var max_depth$0 = max_depth, left$0 = left;
    for(;;){
     var
      _aq_ = caml_call2(Base_Import[93], right, left$0),
      len = caml_call2(Base_Import[91], _aq_, 1);
     if(32 >= len)
      return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
     if(0 > max_depth$0)
      return caml_call4(Heap_sort[1], arr, compare, left$0, right);
     var
      max_depth$1 = caml_call2(Base_Import[93], max_depth$0, 1),
      _ap_ = caml_call2(Base_Import[93], right, left$0),
      sixth = caml_call2(Base_Import[95], _ap_, 6),
      m1 = caml_call2(Base_Import[91], left$0, sixth),
      m2 = caml_call2(Base_Import[91], m1, sixth),
      m3 = caml_call2(Base_Import[91], m2, sixth),
      m4 = caml_call2(Base_Import[91], m3, sixth),
      m5 = caml_call2(Base_Import[91], m4, sixth);
     five_element_sort(arr, compare, m1, m2, m3, m4, m5);
     var
      m2_val = get(arr, m2),
      m3_val = get(arr, m3),
      m4_val = get(arr, m4),
      match =
        0 === caml_call2(compare, m2_val, m3_val)
         ? [0, m2_val, m3_val, 1]
         : 0
           === caml_call2(compare, m3_val, m4_val)
           ? [0, m3_val, m4_val, 1]
           : [0, m2_val, m4_val, 0],
      middle_sorted = match[3],
      pivot2 = match[2],
      pivot1 = match[1],
      l$0 = left$0,
      p$1 = left$0,
      r$2 = right;
     for(;;){
      if(r$2 < p$1) break;
      var pv = get(arr, p$1);
      if(0 <= caml_call2(compare, pv, pivot1))
       if(0 < caml_call2(compare, pv, pivot2)){
        var r = r$2;
        for(;;){
         if(p$1 >= r) break;
         if(0 >= caml_call2(compare, get(arr, r), pivot2)) break;
         var r$0 = caml_call2(Base_Import[93], r, 1), r = r$0;
        }
        swap$0(arr, r, p$1);
        var r$1 = caml_call2(Base_Import[93], r, 1), r$2 = r$1;
       }
       else
        var p = caml_call2(Base_Import[91], p$1, 1), p$1 = p;
      else{
       swap$0(arr, p$1, l$0);
       var
        p$0 = caml_call2(Base_Import[91], p$1, 1),
        l = caml_call2(Base_Import[91], l$0, 1),
        l$0 = l,
        p$1 = p$0;
      }
     }
     intro_sort
      (arr, max_depth$1, compare, left$0, caml_call2(Base_Import[93], l$0, 1));
     if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
     var
      left$1 = caml_call2(Base_Import[91], r$2, 1),
      max_depth$0 = max_depth$1,
      left$0 = left$1;
    }
   }
   function sort$1(arr, compare, left, right){
    return intro_sort(arr, 32, compare, left, right);
   }
   var Intro_sort = [0, sort$1, five_element_sort];
   function sort$2(pos, len, arr, compare){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1], pos, len, 0, arr.length - 1),
     len$0 = match[2],
     pos$0 = match[1],
     _an_ = caml_call2(Base_Import[91], pos$0, len$0),
     _ao_ = caml_call2(Base_Import[93], _an_, 1);
    return caml_call4(Intro_sort[1], arr, compare, pos$0, _ao_);
   }
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[129], i);
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[129], i);
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _ai_ = a1[1 + caml_call2(Base_Import[93], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _ai_))
     return caml_call2(append, a1, a2);
    var _aj_ = a2[1 + caml_call2(Base_Import[93], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _aj_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[91], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _al_ = caml_call2(Base_Import[93], len, 1),
     _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[91], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[91], a2_index[1], 1);
      }
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      var i = _am_;
     }
    }
    return merged;
   }
   function copy_matrix(_ah_){return caml_call2(map, _ah_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _af_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_ag_){return caml_call2(_af_, _ag_, t);};
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _ad_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ac_ = 0;
    if(_ad_ >= 0){
     var i = _ac_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      var i = _ae_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[93], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     caml_call1(Base_Import[130], i);
     caml_call1(Base_Import[129], j);
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _$_ = caml_call1(Base_List[7], l$0),
     len = caml_call2(Base_Import[91], 1, _$_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _aa_ = caml_call2(Base_Import[93], len, 2);
    if(_aa_ >= 0){
     var i = _aa_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _ab_ = i - 1 | 0;
      if(0 === i) break;
      var i = _ab_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _Z_ = caml_call1(f, hd),
     ___ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, ___), _Z_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _X_ = caml_call2(f, 0, hd),
     _Y_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, _Y_), _X_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _V_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       caml_call1(Base_Import[130], k);
      }
      var _W_ = i + 1 | 0;
      if(_V_ === i) break;
      var i = _W_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_T_){return _T_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _S_ = n1 !== n2 ? 1 : 0;
    return _S_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _S_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[129], i);
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[129], i);
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){
       caml_call1(Base_Import[129], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[93], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){
       caml_call1(Base_Import[129], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[129], i);
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){caml_call1(Base_Import[129], i); continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function equal(equal, t1, t2){
    var _R_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _R_ ? for_all2_exn(t1, t2, equal) : _R_;
   }
   function map_inplace(t, f){
    var _P_ = caml_call2(Base_Import[93], t.length - 1, 1), _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      var i = _Q_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       caml_call1(Base_Import[130], i);
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    function _N_(param){return 0;}
    return findi_internal
            (t, f, function(i, value){return [0, [0, i, value]];}, _N_);
   }
   function findi_exn(t, f){
    function _M_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[252], _c_], 1);
    }
    return findi_internal
            (t, f, function(i, value){return [0, i, value];}, _M_);
   }
   function find_exn(t, f){
    function _K_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[252], _d_], 1);
    }
    function _L_(param, value){return value;}
    return findi_internal
            (t, function(i, x){return caml_call1(f, x);}, _L_, _K_);
   }
   function find(t, f){
    function _I_(param){var x = param[2]; return x;}
    var _J_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2(Base_Option[21], _J_, _I_);
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      caml_call1(Base_Import[130], i);
      continue;
     }
     return value_found[1];
    }
   }
   var not_found = [0, Base_Import[252], _e_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      caml_call1(Base_Import[130], i);
      continue;
     }
     return value_found[1];
    }
   }
   var not_found$0 = [0, Base_Import[252], _f_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; caml_call1(Base_Import[130], i);}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _G_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _F_ = 1;
    if(_G_ >= 1){
     var i = _F_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _H_ = i + 1 | 0;
      if(_G_ === i) break;
      var i = _H_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[126], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var permute = Base_Array_permute[24];
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(is_empty(t))
     return caml_call1(Base_Import[124], cst_Array_random_element_exn_e);
    var _E_ = caml_call2(Base_Random[18][6], random_state, t.length - 1);
    return caml_check_bound(t, _E_)[1 + _E_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{var _C_ = [0, random_element_exn([0, random_state], t)]; return _C_;}
    catch(_D_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[124], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _A_ = caml_call2(Base_Import[93], n, 1),
     _z_ = 1;
    if(_A_ >= 1){
     var i = _z_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _B_ = i + 1 | 0;
      if(_A_ === i) break;
      var i = _B_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort$2(0, 0, t1, compare);
    return t1;
   }
   function partitioni_tf(t, f){
    var
     both =
       caml_call2
        (mapi,
         t,
         function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];}),
     trues =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     falses =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, trues, falses];
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(i, x){return caml_call1(f, x);});
   }
   function last(t){
    var _y_ = caml_call2(Base_Import[93], t.length - 1, 1);
    return caml_check_bound(t, _y_)[1 + _y_];
   }
   function to_sequence_mutable(t){
    function _w_(i){
     if(t.length - 1 <= i) return 0;
     var _x_ = caml_call2(Base_Import[91], i, 1);
     return [1, caml_check_bound(t, i)[1 + i], _x_];
    }
    return caml_call2(Base_Sequence[41], 0, _w_);
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _l_ = caml_check_bound(t2, 0)[1],
      _m_ = [0, caml_check_bound(t1, 0)[1], _l_],
      t = caml_call2(create, caml_call2(Base_Import[88], n1, n2), _m_),
      r = [0, 0],
      _o_ = caml_call2(Base_Import[93], n1, 1),
      _n_ = 0;
     if(_o_ >= 0){
      var i1 = _n_;
      for(;;){
       var _q_ = caml_call2(Base_Import[93], n2, 1), _p_ = 0;
       if(_q_ >= 0){
        var i2 = _p_;
        for(;;){
         var
          _s_ = caml_check_bound(t2, i2)[1 + i2],
          _t_ = [0, caml_check_bound(t1, i1)[1 + i1], _s_],
          _u_ = r[1];
         caml_check_bound(t, _u_)[1 + _u_] = _t_;
         caml_call1(Base_Import[130], r);
         var _v_ = i2 + 1 | 0;
         if(_q_ === i2) break;
         var i2 = _v_;
        }
       }
       var _r_ = i1 + 1 | 0;
       if(_o_ === i1) break;
       var i1 = _r_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[126], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_k_, _j_){return caml_check_bound(_k_, _j_)[1 + _j_];}
   function length(_i_){return _i_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length]),
    binary_search = include[1],
    binary_search_segmented = include[2];
   function length$0(_h_){return _h_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$0, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   var
    Base_Array =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       max_length,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       of_list,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       iteri,
       mapi,
       foldi,
       fold_right,
       sort$2,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       concat_map,
       concat_mapi,
       partition_tf,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       filter_map,
       filter_mapi,
       for_alli,
       existsi,
       counti,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       filter,
       filteri,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi,
       findi_exn,
       find_mapi,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Insertion_sort, Heap_sort, Intro_sort]]];
   runtime.caml_register_global(28, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""],
    _a_ = [0, "src/obj_array.ml", 11, 18];
   function invariant(t){
    var _t_ = Stdlib_Obj[17];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[14], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - caml_call2(Base_Import[128], old_obj, obj);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - caml_call2(Base_Import[128], old_obj, obj);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    var _l_ = Stdlib_Obj[16];
    if(caml_obj_tag(x) !== _l_) return caml_call2(Base_Array0[4], len, x);
    var
     t = create_zero(len),
     _n_ = caml_call2(Base_Import[93], len, 1),
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      unsafe_set_with_caml_modify(t, i, x);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      var i = _o_;
     }
    }
    return t;
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[93], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var _f_ = src[1 + caml_call2(Base_Import[91], src_pos, i)];
       unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i), _f_);
       var _g_ = i + 1 | 0;
       if(_e_ === i) break;
       var i = _g_;
      }
     }
     return 0;
    }
    var _h_ = caml_call2(Base_Import[93], len, 1);
    if(_h_ >= 0){
     var i$0 = _h_;
     for(;;){
      var _i_ = src[1 + caml_call2(Base_Import[91], src_pos, i$0)];
      unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i$0), _i_);
      var _j_ = i$0 - 1 | 0;
      if(0 === i$0) break;
      var i$0 = _j_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub = include[4],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Blit, Base__Container, Base__Import, Base__List, Base__Obj_array, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    empty = Base_Obj_array[12],
    _b_ = [0, cst_src_uniform_array_ml, 164, 8],
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Uniform_array_init = "Uniform_array.init",
    _a_ = [0, cst_src_uniform_array_ml, 71, 18];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[9], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[9], len);}
   function create(len, x){return caml_call2(Base_Obj_array[8], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[11], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[18], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[14], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[16], arr, i, x);}
   function unsafe_get(arr, i){return caml_call2(Base_Obj_array[15], arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[17], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[22], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   var
    length = Base_Obj_array[13],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[10];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[24], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[19], t, i, x);
   }
   var unsafe_clear_if_pointer = Base_Obj_array[25];
   function invariant(t){
    var _M_ = Stdlib_Obj[17];
    if(runtime.caml_obj_tag(t) !== _M_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[126], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _K_ = caml_call2(Base_Import[93], l, 1),
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      var i = _L_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_I_){return arr[1 + _I_];});
   }
   function map(a, f){
    function _H_(i){return caml_call1(f, unsafe_get(a, i));}
    return init(caml_call1(length, a), _H_);
   }
   function mapi(a, f){
    function _G_(i){return caml_call2(f, i, unsafe_get(a, i));}
    return init(caml_call1(length, a), _G_);
   }
   function iter(a, f){
    var
     _D_ = caml_call1(length, a),
     _E_ = caml_call2(Base_Import[93], _D_, 1),
     _C_ = 0;
    if(_E_ >= 0){
     var i = _C_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _F_ = i + 1 | 0;
      if(_E_ === i) break;
      var i = _F_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _z_ = caml_call1(length, a),
     _A_ = caml_call2(Base_Import[93], _z_, 1),
     _y_ = 0;
    if(_A_ >= 0){
     var i = _y_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _B_ = i + 1 | 0;
      if(_A_ === i) break;
      var i = _B_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     _u_ = caml_call1(length, a),
     _v_ = caml_call2(Base_Import[93], _u_, 1),
     _t_ = 0;
    if(_v_ >= 0){
     var i = _t_;
     for(;;){
      var _w_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _w_);
      var _x_ = i + 1 | 0;
      if(_v_ === i) break;
      var i = _x_;
     }
    }
    return acc[1];
   }
   function to_list(t){
    function _q_(_s_){return get(t, _s_);}
    var _r_ = caml_call1(length, t);
    return caml_call2(Base_List[123], _r_, _q_);
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[7], l),
     res = unsafe_create_uninitialized(len);
    function _p_(i, x){return set(res, i, x);}
    caml_call2(Base_List[98], l, _p_);
    return res;
   }
   function to_array(t){
    function _n_(i){return unsafe_get(t, i);}
    var _o_ = caml_call1(length, t);
    return caml_call2(Base_Array[27], _o_, _n_);
   }
   function exists(t, f){
    var
     _m_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[93], _m_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 0;
     var _l_ = caml_call1(f, unsafe_get(t, i));
     if(_l_) return _l_;
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0;
    }
   }
   function for_all(t, f){
    var
     _k_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[93], _k_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 1;
     var _j_ = caml_call1(f, unsafe_get(t, i));
     if(! _j_) return _j_;
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0;
    }
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _i_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _i_);
             });
   }
   function t_sexp_grammar(grammar){
    var _h_ = caml_call1(Base_Array[4], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _h_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[2], Base_Array[3]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5];
   function fold(t, init, f){
    var
     r = [0, init],
     _d_ = caml_call1(length, t),
     _e_ = caml_call2(Base_Import[93], _d_, 1),
     _c_ = 0;
    if(_e_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _f_);
      var _g_ = i + 1 | 0;
      if(_e_ === i) break;
      var i = _g_;
     }
    }
    return r[1];
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare(compare_elt, a, b){
    if(caml_call2(Base_Import[128], a, b)) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get(a, i),
      r = unsafe_get(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   var
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       foldi,
       of_array,
       to_array,
       of_list,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists,
       for_all,
       map2_exn,
       min_elt,
       max_elt];
   runtime.caml_register_global(14, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Import0, Base__Option, Base__Printf, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float,
    _g_ = [0, cst_src_float0_ml, 170, 4],
    _f_ = [0, cst_src_float0_ml, 174, 4],
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    nan = Base_Import[85][23],
    infinity = Base_Import[85][21],
    neg_infinity = Base_Import[85][22],
    max_finite_value = Base_Import[85][24],
    epsilon_float = Base_Import[85][26],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var is_integer = Stdlib_Float[16];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(caml_call2(Base_Import[108][1], b, 0.))
     caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return caml_call2(Base_Import[108][1], m, 0.)
            ? caml_call2(Base_Import[92], m, b)
            : m;
   }
   var frexp = runtime.caml_frexp_float, ldexp = runtime.caml_ldexp_float;
   function is_nan(x){return caml_call2(Base_Import[108][3], x, x);}
   function to_int64_preserve_order(t){
    return is_nan(t)
            ? 0
            : caml_call2
               (Base_Import[108][4], t, 0.)
              ? _b_
              : caml_call2
                 (Base_Import[108][5], t, 0.)
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[114], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[28], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[114], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[85][23];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[93], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[94], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[93], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[114], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[93], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[94], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[108][1], t, min)
            ? min
            : caml_call2(Base_Import[108][1], max, t) ? max : t;
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[92], f, x);}
   var
    include = Base_Import[108],
    symbol$1 = include[1],
    symbol$2 = include[2],
    symbol$3 = include[3],
    symbol$4 = include[4],
    symbol$5 = include[5],
    symbol$6 = include[6],
    ascending = include[7],
    descending = include[8],
    compare = include[9],
    equal = include[10],
    max = include[11],
    min = include[12],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       ascending,
       descending,
       compare,
       equal,
       max,
       min];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[227],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit",
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    _b_ = [0, [1, 0], "%C"],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[185];
   function to_string(t){return caml_call2(Base_String0[9], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24];
   function pp(fmt, c){return caml_call3(Stdlib_Format[135], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[11], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[15], _c_);
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _u_ = param - 48 | 0;
    a:
    {
     if(42 < _u_ >>> 0){
      if(25 < _u_ - 49 >>> 0) break a;
     }
     else if(6 >= _u_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _s_ = caml_call1(to_int, 48), _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[93], _t_, _s_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _r_ = param - 48 | 0;
    a:
    {
     if(22 < _r_ >>> 0){
      if(5 < _r_ - 49 >>> 0) break a;
     }
     else if(6 >= _r_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _j_ = caml_call1(to_int, 97),
        _k_ = caml_call1(to_int, t),
        _l_ = caml_call2(Base_Import[93], _k_, _j_);
       return caml_call2(Base_Import[91], _l_, 10);
      }
     }
     else if(71 > t){
      var
       _m_ = caml_call1(to_int, 65),
       _n_ = caml_call1(to_int, t),
       _o_ = caml_call2(Base_Import[93], _n_, _m_);
      return caml_call2(Base_Import[91], _o_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _p_ = caml_call1(to_int, 48), _q_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[93], _q_, _p_);
    }
    var
     _h_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _i_ = caml_call2(Base_Sexp[9], cst_Char_get_hex_digit_exn_not, _h_);
    return caml_call1(Base_Error[30], _i_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[106][6],
    symbol$0 = Base_Import[106][2],
    symbol$1 = Base_Import[106][4],
    symbol$2 = Base_Import[106][5],
    symbol$3 = Base_Import[106][1],
    symbol$4 = Base_Import[106][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[165],
    sexp_of_t$1 = Base_Import[141],
    t_sexp_grammar$0 = Base_Import[185];
   function compare$0(c1, c2){
    var _f_ = caml_call1(lowercase, c2), _g_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[106][9], _g_, _f_);
   }
   function hash_fold_t$1(state, t){
    var _e_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[206], state, _e_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16],
    include$1 = Base_Import[106],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$0 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_Char =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[31], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     var i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      var i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      var i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[29], first_target));
    if(! caml_call2(Base_Char[14], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[31], i);
       if(! caml_call2(Base_Char[14], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0, i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, caml_call1(Base_Bytes0[16], tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Import, Base__Indexed_container, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Ppx_compare_lib, Base__Printf, Base__Sexp, Base__Staged, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$1 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$10 = cst$11,
    cst$9 = cst$11,
    cst$8 = cst$11,
    cst$6 = cst$11,
    cst$7 = cst$11,
    cst$5 = cst$11,
    cst$4 = cst$11,
    cst$3 = cst$11,
    cst$2 = cst$11,
    cst$1 = cst$11,
    cst$0 = cst$11,
    cst = cst$11,
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Array0 = global_data.Base__Array0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    copy = Base_String0[6],
    escaped = Base_String0[7],
    lowercase = Base_String0[8],
    make = Base_String0[9],
    uncapitalize = Base_String0[11],
    uppercase = Base_String0[13],
    concat = Base_String0[14],
    iter = Base_String0[15],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[30],
    stage = Base_Staged[1],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _G_ = [0, cst_src_string_ml, 1587, 2],
    _F_ = [0, cst_src_string_ml, 1573, 19],
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$1,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$1,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_index_from = "index_from",
    cst_is_char_literal = "is_char_literal",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_escaping = "is_char_escaping",
    _E_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _D_ = [0, [3, 0, 0], "%S"],
    _C_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _B_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _A_ = [0, cst_src_string_ml, 765, 17],
    cst_suffix = "suffix",
    cst_prefix = "prefix",
    cst_drop_suffix = "drop_suffix",
    cst_drop_prefix = "drop_prefix",
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    _x_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"],
    _p_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"],
    _g_ = [0, "kmp_array"],
    _h_ = [0, cst_case_sensitive],
    _i_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _e_ = [0, cst_case_sensitive],
    _f_ = [0, cst_pattern],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    cst_String_index_from_exn = "String.index_from_exn",
    _a_ = [0, "String.index_exn: not found"],
    _b_ = [0, "String.index_from_exn: not found"],
    _c_ = [0, "String.rindex_exn: not found"],
    _d_ = [0, "String.rindex_from_exn: not found"],
    _y_ = [0, "String.lsplit2_exn: not found"],
    _z_ = [0, "String.rsplit2_exn: not found"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[183],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    runtime.caml_blit_string(src, pos, dst, 0, len);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[93], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _dt_ = caml_call2(Base_Import[93], total_length, pos$1),
     len$0 = caml_call2(Base_Option[27], len, _dt_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[91], pos$1, len$0), pos = pos$1;
    for(;;){
     var _dq_ = pos < end ? 1 : 0;
     if(_dq_){
      var
       _dr_ =
         caml_call2(Base_Char[15], caml_string_unsafe_get(t, pos), char$0);
      if(! _dr_){
       var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
       continue;
      }
      var _ds_ = _dr_;
     }
     else
      var _ds_ = _dq_;
     return _ds_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[91], pos$0, 1), pos$0 = pos$1;
    }
   }
   function index_exn_internal(t, not_found, char$0){
    return index_from_exn_internal
            (t, 0, caml_ml_string_length(t), not_found, char$0);
   }
   var not_found = [0, Base_Import[252], _a_];
   function index_exn(t, char$0){
    return index_exn_internal(t, not_found, char$0);
   }
   var not_found$0 = [0, Base_Import[252], _b_];
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_exn_internal(t, pos, len, not_found$0, char$0);
    return caml_call1(Base_Import[126], cst_String_index_from_exn);
   }
   function rindex_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[93], pos$0, 1), pos$0 = pos$1;
    }
   }
   function rindex_exn_internal(t, not_found, char$0){
    var len = caml_ml_string_length(t);
    return rindex_from_exn_internal
            (t, caml_call2(Base_Import[93], len, 1), len, not_found, char$0);
   }
   var not_found$1 = [0, Base_Import[252], _c_];
   function rindex_exn(t, char$0){
    return rindex_exn_internal(t, not_found$1, char$0);
   }
   var not_found$2 = [0, Base_Import[252], _d_];
   function rindex_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(-1 <= pos && len > pos)
     return rindex_from_exn_internal(t, pos, len, not_found$2, char$0);
    return caml_call1(Base_Import[126], cst_String_rindex_from_exn);
   }
   function index(t, char$0){
    try{var _do_ = [0, index_exn(t, char$0)]; return _do_;}
    catch(_dp_){
     var _dn_ = caml_wrap_exception(_dp_);
     if(_dn_[1] !== Base_Import[252] && _dn_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_dn_, 0);
     return 0;
    }
   }
   function rindex(t, char$0){
    try{var _dl_ = [0, rindex_exn(t, char$0)]; return _dl_;}
    catch(_dm_){
     var _dk_ = caml_wrap_exception(_dm_);
     if(_dk_[1] !== Base_Import[252] && _dk_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_dk_, 0);
     return 0;
    }
   }
   function index_from(t, pos, char$0){
    try{var _di_ = [0, index_from_exn(t, pos, char$0)]; return _di_;}
    catch(_dj_){
     var _dh_ = caml_wrap_exception(_dj_);
     if(_dh_[1] !== Base_Import[252] && _dh_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_dh_, 0);
     return 0;
    }
   }
   function rindex_from(t, pos, char$0){
    try{var _df_ = [0, rindex_from_exn(t, pos, char$0)]; return _df_;}
    catch(_dg_){
     var _de_ = caml_wrap_exception(_dg_);
     if(_de_[1] !== Base_Import[252] && _de_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_de_, 0);
     return 0;
    }
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _dd_ =
       [0,
        [1, [0, _e_, [0, caml_call1(Base_Import[138], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _f_, [0, caml_call1(Base_Import[139], pattern), 0]]],
             _dd_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[93], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[91], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[15] : Base_Char[52][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _db_ = caml_call2(Base_Import[93], n, 1),
      _da_ = 1;
     if(_db_ >= 1){
      var i = _da_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _dc_ = i + 1 | 0;
       if(_db_ === i) break;
       var i = _dc_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[93],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[91], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[93], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){return 0 <= index_internal(0, t)(str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    if(0 <= p) return p;
    var _c$_ = [0, [0, cst_substring, caml_call1(Base_Import[139], t[1])], 0];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[9], cst_Substring_not_found, _c$_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var
      _c5_ = function(_c__){return _c__;},
      _c6_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[123], _c6_, _c5_);
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _c7_ = 0;
    if(n >= 0){
     var j = _c7_;
     for(;;){
      if(matched_chars[1] === k){
       var _c8_ = found[1];
       found[1] = [0, caml_call2(Base_Import[93], j, k), _c8_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[93], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _c9_ = j + 1 | 0;
      if(n === j) break;
      var j = _c9_;
     }
    }
    return caml_call1(Base_List[38], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _cZ_ = caml_call2(Base_Import[91], len_s, len_with),
     _c0_ = caml_call2(Base_Import[93], _cZ_, len_t),
     dst = caml_call1(Base_Bytes0[7], _c0_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _c1_ = caml_call2(Base_Import[93], len_s, i),
     _c2_ = caml_call2(Base_Import[93], _c1_, len_t),
     _c3_ = caml_call2(Base_Import[91], i, len_with),
     _c4_ = caml_call2(Base_Import[91], i, len_t);
    caml_call5(Base_Bytes0[4], s, _c4_, dst, _c3_, _c2_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[7], matches),
     _cR_ = caml_call2(Base_Import[93], len_with, len_t),
     _cS_ = caml_call2(Base_Import[88], _cR_, num_matches),
     _cT_ = caml_call2(Base_Import[91], len_s, _cS_),
     dst = caml_call1(Base_Bytes0[7], _cT_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    function _cU_(i){
     var len = caml_call2(Base_Import[93], i, next_src_pos[1]);
     caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
     var _cW_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     caml_call5(Base_Bytes0[4], with$0, 0, dst, _cW_, len_with);
     var _cX_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     next_dst_pos[1] = caml_call2(Base_Import[91], _cX_, len_with);
     var _cY_ = caml_call2(Base_Import[91], next_src_pos[1], len);
     next_src_pos[1] = caml_call2(Base_Import[91], _cY_, len_t);
     return 0;
    }
    caml_call2(Base_List[9], matches, _cU_);
    var _cV_ = caml_call2(Base_Import[93], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _cV_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s);
    function _cM_(i, j){
     var
      _cP_ = caml_call2(Base_Import[93], j, i),
      _cQ_ = caml_call2(Base_Import[93], _cP_, pattern_len);
     return sub(s, caml_call2(Base_Import[91], i, pattern_len), _cQ_);
    }
    var
     _cN_ =
       caml_call2(Base_Import[111], matches, [0, caml_ml_string_length(s), 0]),
     _cO_ = [0, caml_call1(Base_Import[113], pattern_len), matches];
    return caml_call3(Base_List[83], _cO_, _cN_, _cM_);
   }
   function equal(a_002, b_003){
    if(caml_call2(Base_Ppx_compare_lib[1], a_002, b_003)) return 1;
    var _cJ_ = caml_call2(Base_Import[246], a_002[1], b_003[1]);
    if(_cJ_){
     var _cK_ = caml_call2(Base_Import[239], a_002[2], b_003[2]);
     if(_cK_)
      return caml_call3
              (Base_Import[248], Base_Import[242], a_002[3], b_003[3]);
     var _cL_ = _cK_;
    }
    else
     var _cL_ = _cJ_;
    return _cL_;
   }
   function sexp_of_t$1(param){
    var
     kmp_array_011 = param[3],
     case_sensitive_009 = param[2],
     pattern_007 = param[1],
     arg_012 = caml_call2(Base_Import[153], Base_Import[142], kmp_array_011),
     bnds_006 = [0, [1, [0, _g_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[138], case_sensitive_009),
     bnds_006$0 = [0, [1, [0, _h_, [0, arg_010, 0]]], bnds_006],
     arg_008 = caml_call1(Base_Import[139], pattern_007),
     bnds_006$1 = [0, [1, [0, _i_, [0, arg_008, 0]]], bnds_006$0];
    return [1, bnds_006$1];
   }
   function representation(_cI_){return _cI_;}
   var Private = [0, equal, sexp_of_t$1, representation];
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _cG_ = create(pattern, case_sensitive);
    return function(_cH_){return replace_first(pos, _cG_, t, _cH_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _cE_ = create(pattern, case_sensitive);
    return function(_cF_){return replace_all(_cE_, t, _cF_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _cD_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[50], _cD_);
   }
   var _j_ = 1;
   function substr_index(_cA_, _cB_, _cC_){
    return substr_index_gen(_j_, _cA_, _cB_, _cC_);
   }
   var _k_ = 1;
   function substr_index_exn(_cx_, _cy_, _cz_){
    return substr_index_exn_gen(_k_, _cx_, _cy_, _cz_);
   }
   var _l_ = 1;
   function substr_index_all(_cu_, _cv_, _cw_){
    return substr_index_all_gen(_l_, _cu_, _cv_, _cw_);
   }
   var _m_ = 1;
   function substr_replace_first(_cr_, _cs_, _ct_){
    return substr_replace_first_gen(_m_, _cr_, _cs_, _ct_);
   }
   var _n_ = 1;
   function substr_replace_all(_cp_, _cq_){
    return substr_replace_all_gen(_n_, _cp_, _cq_);
   }
   var _o_ = 1;
   function is_substring(_cn_, _co_){
    return is_substring_gen(_o_, _cn_, _co_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _ck_ = str_pos$1 < 0 ? 1 : 0,
     _cl_ = _ck_ || (str_len < str_pos$1 ? 1 : 0);
    if(_cl_) caml_call4(invalid_argf, _p_, str_pos$1, str_len, 0);
    var
     _cm_ = caml_call2(Base_Import[91], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _cm_) return _cm_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[91], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[91], str_pos, 1),
      str_pos = str_pos$0,
      sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _cj_ = suffix_len <= string_len ? 1 : 0;
    return _cj_
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[93], string_len, suffix_len),
               suffix,
               char_equal)
            : _cj_;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _ci_ = prefix_len <= string_len ? 1 : 0;
    return _ci_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _ci_;
   }
   var
    t_of_sexp$0 = Base_Import[163],
    sexp_of_t$2 = Base_Import[139],
    t_sexp_grammar$0 = Base_Import[183];
   function compare$0(string1, string2){
    if(caml_call2(Base_Import[128], string1, string2)) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _cg_ = caml_call1(Base_Char[34], c2),
      _ch_ = caml_call1(Base_Char[34], c1),
      c = caml_call2(Base_Char[16], _ch_, _cg_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[207], state, len)],
     _cd_ = caml_call2(Base_Import[93], len, 1),
     _cc_ = 0;
    if(_cd_ >= 0){
     var pos = _cc_;
     for(;;){
      var _ce_ = caml_call1(Base_Char[34], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[206], state$0[1], _ce_);
      var _cf_ = pos + 1 | 0;
      if(_cd_ === pos) break;
      var pos = _cf_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[52][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[52][12]);
   }
   var _q_ = 0;
   function substr_index$0(_b$_, _ca_, _cb_){
    return substr_index_gen(_q_, _b$_, _ca_, _cb_);
   }
   var _r_ = 0;
   function substr_index_exn$0(_b8_, _b9_, _b__){
    return substr_index_exn_gen(_r_, _b8_, _b9_, _b__);
   }
   var _s_ = 0;
   function substr_index_all$0(_b5_, _b6_, _b7_){
    return substr_index_all_gen(_s_, _b5_, _b6_, _b7_);
   }
   var _t_ = 0;
   function substr_replace_first$0(_b2_, _b3_, _b4_){
    return substr_replace_first_gen(_t_, _b2_, _b3_, _b4_);
   }
   var _u_ = 0;
   function substr_replace_all$0(_b0_, _b1_){
    return substr_replace_all_gen(_u_, _b0_, _b1_);
   }
   var _v_ = 0;
   function is_substring$0(_bY_, _bZ_){
    return is_substring_gen(_v_, _bY_, _bZ_);
   }
   var _w_ = Base_Char[52][12];
   function is_substring_at(_bV_){
    return function(_bW_){
     return function(_bX_){
      return is_substring_at_gen(_bV_, _bW_, _bX_, _w_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$2]),
    symbol$0 = include$0[1],
    symbol$1 = include$0[2],
    symbol$2 = include$0[3],
    symbol$3 = include$0[4],
    symbol$4 = include$0[5],
    symbol$5 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16];
   function of_string(_bU_){return _bU_;}
   function to_string(_bT_){return _bT_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _x_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _bR_ = caml_call2(Base_Import[93], n, 1),
     _bQ_ = 0;
    if(_bR_ >= 0){
     var i = _bQ_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _bS_ = i + 1 | 0;
      if(_bR_ === i) break;
      var i = _bS_;
     }
    }
    return caml_call1(Base_Bytes0[16], t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[93], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[91], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _bN_ = caml_call2(Base_Import[93], len, 1),
     _bM_ = 0;
    if(_bN_ >= 0){
     var i = _bM_;
     for(;;){
      var _bO_ = caml_call2(Base_Import[93], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[93], _bO_, i)));
      var _bP_ = i + 1 | 0;
      if(_bN_ === i) break;
      var i = _bP_;
     }
    }
    return caml_call1(Base_Bytes0[16], res);
   }
   var not_found$3 = [0, Base_Import[252], _y_];
   function lsplit2_exn(line, delim){
    var
     pos = index_exn_internal(line, not_found$3, delim),
     _bJ_ = caml_call2(Base_Import[93], caml_ml_string_length(line), pos),
     _bK_ = caml_call2(Base_Import[93], _bJ_, 1),
     _bL_ = sub(line, caml_call2(Base_Import[91], pos, 1), _bK_);
    return [0, sub(line, 0, pos), _bL_];
   }
   var not_found$4 = [0, Base_Import[252], _z_];
   function rsplit2_exn(line, delim){
    var
     pos = rindex_exn_internal(line, not_found$4, delim),
     _bG_ = caml_call2(Base_Import[93], caml_ml_string_length(line), pos),
     _bH_ = caml_call2(Base_Import[93], _bG_, 1),
     _bI_ = sub(line, caml_call2(Base_Import[91], pos, 1), _bH_);
    return [0, sub(line, 0, pos), _bI_];
   }
   function lsplit2(line, on){
    try{var _bE_ = [0, lsplit2_exn(line, on)]; return _bE_;}
    catch(_bF_){
     var _bD_ = caml_wrap_exception(_bF_);
     if(_bD_[1] !== Base_Import[252] && _bD_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_bD_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _bB_ = [0, rsplit2_exn(line, on)]; return _bB_;}
    catch(_bC_){
     var _bA_ = caml_wrap_exception(_bC_);
     if(_bA_[1] !== Base_Import[252] && _bA_ !== Base_Import[85][104])
      throw caml_maybe_attach_backtrace(_bA_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _bz_ = caml_call2(Base_Char[15], hd, c);
     if(_bz_) return _bz_;
     var l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[93], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0)))
      var
       pos1 = caml_call2(Base_Import[91], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[93], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[93], last_pos$0, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       last_pos$1 = last_pos$0,
       last_pos$0 = pos;
     else
      var
       pos$0 = caml_call2(Base_Import[93], last_pos$0, 1),
       last_pos$0 = pos$0;
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _bx_ = caml_string_get(t, caml_call2(Base_Import[93], pos[1], 1));
      if(caml_call2(Base_Char[15], _bx_, 13)){var _by_ = 2; break a;}
     }
     var _by_ = 1;
    }
    pos[1] = caml_call2(Base_Import[93], pos[1], _by_);
    eol[1] = caml_call2(Base_Import[91], pos[1], 1);
    return;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import[93], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _bt_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char[15], _bt_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var _bw_ = ac[1]; return [0, sub(t, 0, eol[1]), _bw_];}
     var _bu_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char[14], _bu_, 10))
      caml_call1(Base_Import[129], pos);
     else{
      var start = caml_call2(Base_Import[91], pos[1], 1), _bv_ = ac[1];
      ac[1] =
       [0, sub(t, start, caml_call2(Base_Import[93], eol[1], start)), _bv_];
      back_up_at_newline(t, pos, eol);
     }
    }
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[15]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[15]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[15]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _bq_ = sub(t, pos, len); return _bq_;}
     catch(_bs_){return on_error;}
    var _br_ = caml_call2(symbol, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[126], _br_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     var last = match$0[1], _bp_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _bp_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bn_ = caml_call2(Base_Import[93], l, 1),
     _bm_ = 0;
    if(_bn_ >= 0){
     var i = _bm_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _bo_ = i + 1 | 0;
      if(_bn_ === i) break;
      var i = _bo_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bk_ = caml_call2(Base_Import[93], l, 1),
     _bj_ = 0;
    if(_bk_ >= 0){
     var i = _bj_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _bl_ = i + 1 | 0;
      if(_bk_ === i) break;
      var i = _bl_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function to_array(s){
    function _bi_(i){return caml_string_get(s, i);}
    return caml_call2(Base_Array0[11], caml_ml_string_length(s), _bi_);
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bf_ = i < len ? 1 : 0;
     if(_bf_){
      var _bg_ = caml_call1(f, caml_string_get(s, i));
      if(! _bg_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _bh_ = _bg_;
     }
     else
      var _bh_ = _bf_;
     return _bh_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bc_ = i === len ? 1 : 0;
     if(_bc_)
      var _bd_ = _bc_;
     else{
      var _be_ = caml_call1(f, caml_string_get(s, i));
      if(_be_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _bd_ = _be_;
     }
     return _bd_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _ba_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1),
     _a$_ = 0;
    if(_ba_ >= 0){
     var i = _a$_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _bb_ = i + 1 | 0;
      if(_ba_ === i) break;
      var i = _bb_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _a9_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_a__){return caml_call2(_a9_, _a__, t);};
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _a6_ = i < len ? 1 : 0;
     if(_a6_){
      var _a7_ = caml_call2(Base_Char[15], c, caml_string_unsafe_get(t, i));
      if(! _a7_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _a8_ = _a7_;
     }
     else
      var _a8_ = _a6_;
     return _a8_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[15], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[15], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_a5_){return _a5_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_a4_){return _a4_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _a3_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[29], c));
                         return caml_call2(Base_Char[14], c, _a3_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[29], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[15], ar));
   }
   function concat_map(sep, s, f){
    var _a2_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[20], _a2_, f));
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     caml_call1(Base_Import[130], i);
    }
    if(i[1] === n) return t;
    var
     _a0_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _a0_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[130], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _a1_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _a1_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[130], out_pos);
     }
     caml_call1(Base_Import[130], i);
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _aX_ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _aX_)) break;
     caml_call1(Base_Import[130], i);
    }
    if(i[1] === n) return t;
    var
     _aY_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _aY_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[130], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _aZ_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _aZ_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[130], out_pos);
     }
     caml_call1(Base_Import[130], i);
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _B_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _C_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[10], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _aW_ = caml_call2(Base_Import[93], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[93], _aW_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _aU_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _aV_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[15], _aV_, _aU_)) return len_so_far$0;
     var
      len_so_far$1 = caml_call2(Base_Import[91], len_so_far$0, 1),
      len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[101], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0),
      first$0 = second,
      list$0 = rest,
      max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[135], ppf, _D_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _aS_ = caml_call1(Base_List[7], l),
     t = caml_call1(Base_Bytes0[7], _aS_);
    function _aT_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[98], l, _aT_);
    return caml_call1(Base_Bytes0[16], t);
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[129][7], escapeworthy_map, Base_Char[15], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[29], c_to);
     else
      var k$0 = caml_call1(Base_Char[29], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _aK_ = caml_call1(Base_Char[29], v);
     if(caml_check_bound(vals, _aK_)[1 + _aK_]) break;
     var _aQ_ = caml_call1(Base_Char[29], v);
     caml_check_bound(arr, k)[1 + k] = _aQ_;
     var _aR_ = caml_call1(Base_Char[29], v);
     caml_check_bound(vals, _aR_)[1 + _aR_] = 1;
     var param = l;
    }
    var
     _aL_ = caml_call2(Base_Import[150], Base_Import[141], Base_Import[141]),
     _aM_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[152], _aL_, escapeworthy_map$0)],
        0],
     _aN_ = [0, [0, cst_c_to, caml_call1(Base_Import[141], c_to)], _aM_],
     _aO_ = [0, [0, cst_c_from, caml_call1(Base_Import[141], c_from)], _aN_],
     _aP_ = caml_call2(Base_Sexp[9], cst_escapeworthy_map_not_one_t, _aO_);
    return caml_call1(Base_Or_error[35], _aP_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _aJ_ = caml_call1(Base_Char[29], c),
                    n = caml_check_bound(escapeworthy, _aJ_)[1 + _aJ_];
                   return -1 === n
                           ? acc
                           : (caml_call1
                              (Base_Import[130], to_escape_len),
                             [0, [0, i, caml_call1(Base_Char[32], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[91], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_call1(Base_Bytes0[16], dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _aH_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[93], _aH_, 1),
               dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
               _aI_ = caml_call2(Base_Import[91], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _aI_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[91], last_dst_pos$1, 1),
                escaped_char);
              var
               last_idx$0 = last_idx$1,
               last_dst_pos$0 = last_dst_pos$1,
               param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _aG_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _aG_));
   }
   function escape(escapeworthy, escape_char){
    var
     _aE_ = caml_call2(Base_List[114], escapeworthy, Base_Char[16]),
     _aF_ = Base_List[76],
     escapeworthy_map = caml_call2(_aF_, _aE_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _aw_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[15], _aw_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[91], i, 1),
               i = i$0,
               status = status$0,
               to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _ax_ = caml_call1(Base_List[7], to_unescape),
              _ay_ =
                caml_call2(Base_Import[93], caml_ml_string_length(src), _ax_),
              dst = caml_call1(Base_Bytes0[7], _ay_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _az_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[93], _az_, 2),
                dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
                _aA_ = caml_call2(Base_Import[91], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _aA_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 1),
                _aB_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[91], last_idx$1, 1)),
                _aC_ = caml_call1(Base_Char[29], _aB_),
                n = caml_check_bound(escapeworthy, _aC_)[1 + _aC_],
                _aD_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[91], last_idx$1, 1))
                   : caml_call1(Base_Char[32], n);
               caml_bytes_set(dst, last_dst_pos$1, _aD_);
               var
                last_idx$0 = last_idx$1,
                last_dst_pos$0 = last_dst_pos$1,
                param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[93], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[93], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_call1(Base_Bytes0[16], dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _av_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _av_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[93], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _au_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[14], _au_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[91], cnt, 1),
        p$0 = caml_call2(Base_Import[93], p, 1),
        p = p$0,
        cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _at_ = caml_string_get(str, i);
    return caml_call2(Base_Char[15], _at_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _ar_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[122], _ar_, 2) ? 1 : 0,
     _as_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[15], _as_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _ap_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _aq_ = _ap_ || (pos < 0 ? 1 : 0);
    return _aq_ ? caml_call3(invalid_argf, _E_, function_name, 0) : _aq_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _an_ = -512962225 === status ? 1 : 0;
      if(_an_){
       var _ao_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[15], _ao_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var
      status$0 = update_escape_status(str, escape_char, i$0, status),
      i = i$0,
      status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aj_ = [0, [0, cst_char, caml_call1(Base_Import[141], char$0)], 0],
     _ak_ = [0, [0, cst_pos, caml_call1(Base_Import[142], pos)], _aj_],
     _al_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[141], escape_char)],
        _ak_],
     _am_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _al_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_index_from_exn_not_found, _am_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[15], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[122], escape_chars, 2)){
      var _ah_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[15], _ah_, char$0)) return [0, pos$0];
     }
     var
      _ai_ = caml_call2(Base_Import[93], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[93], _ai_, 1),
      pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _ad_ = [0, [0, cst_char$0, caml_call1(Base_Import[141], char$0)], 0],
     _ae_ = [0, [0, cst_pos$0, caml_call1(Base_Import[142], pos)], _ad_],
     _af_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[141], escape_char)],
        _ae_],
     _ag_ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _af_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_rindex_from_exn_not_found, _ag_));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _ab_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[93], len, last_pos)),
          acc];
      return caml_call1(Base_List[38], _ab_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _ac_ = -512962225 === status$0 ? 1 : 0;
     if(_ac_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[93], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[91], pos, 1),
       last_pos$0 = caml_call2(Base_Import[91], pos, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       status = status$0,
       last_pos = last_pos$0,
       pos = pos$0;
      continue;
     }
     var
      pos$1 = caml_call2(Base_Import[91], pos, 1),
      status = status$0,
      pos = pos$1;
    }
   }
   function split$0(str, on){
    var _$_ = [0, -1044422954, on];
    return function(_aa_){return split_gen$0(str, _aa_, _$_);};
   }
   function split_on_chars$0(str, chars){
    var _Z_ = [0, 552554919, chars];
    return function(___){return split_gen$0(str, ___, _Z_);};
   }
   function split_at(str, pos){
    var
     _W_ = caml_call2(Base_Import[93], caml_ml_string_length(str), pos),
     _X_ = caml_call2(Base_Import[93], _W_, 1),
     _Y_ = sub(str, caml_call2(Base_Import[91], pos, 1), _X_);
    return [0, sub(str, 0, pos), _Y_];
   }
   function lsplit2$0(str, on, escape_char){
    function _U_(x){return split_at(str, x);}
    var _V_ = index$1(str, escape_char, on);
    return caml_call2(Base_Option[21], _V_, _U_);
   }
   function rsplit2$0(str, on, escape_char){
    function _S_(x){return split_at(str, x);}
    var _T_ = rindex$0(str, escape_char, on);
    return caml_call2(Base_Option[21], _T_, _S_);
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _P_ = 1 - caml_call1(drop, c);
              if(_P_)
               var _Q_ = _P_;
              else{
               var _R_ = is_char_escaping(t, escape_char, i);
               if(! _R_) return is_char_escaped(t, escape_char, i);
               var _Q_ = _R_;
              }
              return _Q_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _M_ = 1 - caml_call1(drop, c);
              if(_M_)
               var _N_ = _M_;
              else{
               var _O_ = is_char_escaping(t, escape_char, i);
               if(! _O_) return is_char_escaped(t, escape_char, i);
               var _N_ = _O_;
              }
              return _N_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$8;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$9;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$10;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
     var last = match$0[1], _L_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _L_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _K_ = caml_call2(Base_Import[109][2], low, t);
    return _K_ ? caml_call2(Base_Import[109][2], t, high) : _K_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _H_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _I_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _H_],
     _J_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _I_);
    return caml_call1(Base_Or_error[35], _J_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   var
    include$1 = Base_Import[109],
    symbol$6 = include$1[1],
    symbol$7 = include$1[2],
    symbol$8 = include$1[3],
    symbol$9 = include$1[4],
    symbol$10 = include$1[5],
    symbol$11 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$1 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_String =
      [0,
       t_sexp_grammar,
       sub,
       subo,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$11,
       symbol$7,
       symbol$9,
       symbol$10,
       symbol$6,
       symbol$8,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       invariant,
       max_length,
       make,
       copy,
       init,
       symbol,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map,
       mapi,
       foldi,
       concat_map,
       filter,
       filteri,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal$1,
       of_char,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
   runtime.caml_register_global(86, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[184],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    fill = Base_Bytes0[8],
    make = Base_Bytes0[9],
    map = Base_Bytes0[10],
    mapi = Base_Bytes0[11],
    unsafe_blit = Base_Bytes0[13],
    to_string = Base_Bytes0[14],
    of_string = Base_Bytes0[15],
    unsafe_to_string = Base_Bytes0[16],
    unsafe_of_string_promise_no_mu = Base_Bytes0[17],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _c_ = [0, "src/bytes.ml", 128, 2],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _y_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[135], fmt, _a_, _y_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1], [0, caml_ml_bytes_length, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$1 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$1]);
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _w_ = caml_call2(Base_Import[93], n, 1),
     _v_ = 0;
    if(_w_ >= 0){
     var i = _v_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _x_ = i + 1 | 0;
      if(_w_ === i) break;
      var i = _x_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[7], l));
    function _u_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[98], l, _u_);
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      acc = acc$0;
    }
   }
   function to_array(t){
    function _t_(i){return caml_bytes_unsafe_get(t, i);}
    return caml_call2(Base_Array0[11], caml_ml_bytes_length(t), _t_);
   }
   function map$0(t, f){return caml_call2(map, f, t);}
   function mapi$0(t, f){return caml_call2(mapi, f, t);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[15], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[29], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                var i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[110][2], low, t);
    return _k_ ? caml_call2(Base_Import[110][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[110][1], t, min)
            ? min
            : caml_call2(Base_Import[110][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[110][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[110][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[91], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[15], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    include$0 = Base_Import[110],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    equal = include$0[10],
    max = include$0[11],
    min = include$0[12],
    Base_Bytes =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       caml_bytes_set,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     var ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Assert_failure, Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Int0, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Base__Sys0, Base__Word_size, Sexplib0__Sexp_grammar, Stdlib__Int32, Stdlib__Int64, Stdlib__Lexing, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Printf = global_data.Base__Printf,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    Base_Sexp = global_data.Base__Sexp,
    _g_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"],
    _m_ = [0, cst_src_int_conversions_ml, 19, 9],
    _l_ = [0, cst_src_int_conversions_ml, 75, 9],
    _k_ = [0, cst_src_int_conversions_ml, 96, 9],
    _j_ = [0, cst_src_int_conversions_ml, 148, 9],
    _i_ = [0, cst_src_int_conversions_ml, 176, 9];
   function convert_failure(x, a, b, to_string){
    var _S_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _S_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15],
    _b_ = Base_Import[85][32],
    _c_ = Stdlib_Int32[14];
   function int32_to_int_trunc(_R_){return _R_;}
   function int_to_int32_trunc(_Q_){return _Q_;}
   var
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _O_ = caml_call2(Base_Import[229], min_int32, x) <= 0 ? 1 : 0,
          _P_ =
            _O_
             ? caml_call2(Base_Import[229], x, max_int32) <= 0 ? 1 : 0
             : _O_;
         return _P_;
        };
   if(32 <= num_bits_int)
    var _d_ = function(param){return 1;};
   else
    var
     min$4 = Base_Int0[6],
     max$4 = Base_Int0[5],
     _d_ =
       function(x){
        var
         _M_ = caml_call2(Base_Import[230], min$4, x) <= 0 ? 1 : 0,
         _N_ = _M_ ? caml_call2(Base_Import[230], x, max$4) <= 0 ? 1 : 0 : _M_;
        return _N_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){return _d_(x) ? [0, x] : 0;}
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return _d_(x) ? x : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min = caml_int64_of_int32(Base_Int0[6]),
    max = caml_int64_of_int32(Base_Int0[5]);
   function int64_is_representable_as_int(x){
    var
     _K_ = caml_call2(Base_Import[231], min, x) <= 0 ? 1 : 0,
     _L_ = _K_ ? caml_call2(Base_Import[231], x, max) <= 0 ? 1 : 0 : _K_;
    return _L_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64, cst_int$1, int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   function int_to_nativeint(_J_){return _J_;}
   function nativeint_to_int_trunc(_I_){return _I_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$3 = Base_Int0[6],
     max$3 = Base_Int0[5],
     _e_ =
       function(x){
        var
         _G_ = caml_call2(Base_Import[232], min$3, x) <= 0 ? 1 : 0,
         _H_ = _G_ ? caml_call2(Base_Import[232], x, max$3) <= 0 ? 1 : 0 : _G_;
        return _H_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$0 = caml_int64_of_int32(min_int32),
    max$0 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _E_ = caml_call2(Base_Import[231], min$0, x) <= 0 ? 1 : 0,
     _F_ = _E_ ? caml_call2(Base_Import[231], x, max$0) <= 0 ? 1 : 0 : _E_;
    return _F_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   function int32_to_nativeint(_D_){return _D_;}
   function nativeint_to_int32_trunc(_C_){return _C_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _A_ = caml_call2(Base_Import[232], min_int32, x) <= 0 ? 1 : 0,
          _B_ =
            _A_
             ? caml_call2(Base_Import[232], x, max_int32) <= 0 ? 1 : 0
             : _A_;
         return _B_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _y_ = caml_call2(Base_Import[231], min$2, x) <= 0 ? 1 : 0,
         _z_ = _y_ ? caml_call2(Base_Import[231], x, max$2) <= 0 ? 1 : 0 : _y_;
        return _z_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min$1 = caml_int64_shift_right(min_int64, 1),
    max$1 = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _w_ = caml_call2(Base_Import[231], min$1, x) <= 0 ? 1 : 0,
     _x_ = _w_ ? caml_call2(Base_Import[231], x, max$1) <= 0 ? 1 : 0 : _w_;
    return _x_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[93], input_length, 1) : input_length,
     _t_ = caml_call2(Base_Import[93], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[95], _t_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[91], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[31], output_length),
     input_pos = [0, caml_call2(Base_Import[93], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[93], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign){
       var _v_ = caml_string_get(input, 0);
       caml_call3(Base_Bytes[39], output, 0, _v_);
      }
      return caml_call1(Base_Bytes[49], output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_call3(Base_Bytes[39], output, output_pos[1], delimiter);
      caml_call1(Base_Import[129], output_pos);
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _u_ = caml_string_get(input, input_pos[1]);
     caml_call3(Base_Bytes[39], output, output_pos[1], _u_);
     caml_call1(Base_Import[129], input_pos);
     caml_call1(Base_Import[129], output_pos);
     caml_call1(Base_Import[129], num_chars_until_delimiter);
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var sexp_of_int_style = Base_Sexp[19];
   function _h_(I){
    var compare = I[1], hash_fold_t = I[2], func = I[3];
    function hash(x){return caml_call1(func, x);}
    var chars_per_delimiter = 4;
    function to_string(delimiter, t){
     if(delimiter)
      var
       delimiter$0 = delimiter[1],
       make_suffix =
         function(t){
          return insert_delimiter_every
                  (caml_call1(I[4], t), delimiter$0, chars_per_delimiter);
         };
     else
      var make_suffix = I[4];
     if(caml_call2(I[7], t, I[6])){
      var _r_ = caml_call1(make_suffix, caml_call1(I[8], t));
      return caml_call2(Base_Import[112], cst_0x, _r_);
     }
     var _s_ = caml_call1(make_suffix, t);
     return caml_call2(Base_Import[112], cst_0x$0, _s_);
    }
    function to_string$0(t){return to_string(0, t);}
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     return to_string([0, delimiter], t);
    }
    function invalid(str){
     return caml_call4(Base_Printf[6], _g_, I[9], str, 0);
    }
    function of_string_with_delimiter(str){
     function _p_(c){return caml_call2(Base_Char[14], c, 95);}
     var _q_ = caml_call2(Base_String[98], str, _p_);
     return caml_call1(I[5], _q_);
    }
    function of_string(str){
     var lex = caml_call2(Stdlib_Lexing[3], 0, str);
     function _n_(param){return caml_call1(Base_Hex_lexer[1], lex);}
     var result = caml_call1(Base_Option[44], _n_);
     if(lex[6] !== lex[3]) return invalid(str);
     if(! result) return invalid(str);
     var match = result[1];
     if(0 === match[0]){
      var body = match[1], _o_ = of_string_with_delimiter(body);
      return caml_call1(I[8], _o_);
     }
     var body$0 = match[1];
     return of_string_with_delimiter(body$0);
    }
    var
     t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
     t_of_sexp = include[1],
     sexp_of_t = include[2];
    return [0,
            [0,
             t_of_sexp,
             sexp_of_t,
             t_sexp_grammar,
             compare,
             hash_fold_t,
             hash,
             of_string,
             to_string$0,
             to_string_hum]];
   }
   var
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       _h_,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (44, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[120], -1, 1),
    switcher = Base_Int_conversions[29] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 218, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _i_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else if(switcher)
    var
     _h_ = function(_j_){return _j_;},
     int_positive_overflow_bounds =
       caml_call2(Base_Array0[20], int32_positive_overflow_bounds, _h_);
   else
    var int_positive_overflow_bounds = _i_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[123], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[123], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var abs = Stdlib_Int64[8];
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[96], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Assert_failure, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "src/popcount.ml", 45, 9];
   function int64_popcount(x){
    var
     x$0 =
       runtime.caml_int64_sub
        (x, caml_int64_and(caml_int64_shift_right_unsigne(x, 1), m1)),
     x$1 =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x$1, caml_int64_shift_right_unsigne(x$1, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    all = Base_Sign0[6],
    Replace_polymorphic_compare = Base_Sign0[7],
    to_int = Base_Sign0[10],
    of_int = Base_Sign0[13],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[4],
         Base_Sign0[5],
         Base_Sign0[11],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[8],
         Base_Sign0[9],
         Base_Sign0[12]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24];
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[88], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    max = Replace_polymorphic_compare[11],
    min = Replace_polymorphic_compare[12],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(6, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221],
    _u_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _t_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input",
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/int.ml", 108, 2],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"],
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare;
   function of_string$0(s){
    try{var _aF_ = caml_call1(of_string, s); return _aF_;}
    catch(_aG_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[29],
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function to_float(_aE_){return _aE_;}
   function of_float_unchecked(_aD_){return _aD_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _aC_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _b_, _aC_, 0);
   }
   var
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, 0]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare$0 = Base_Import[229],
    hash_fold_t$0 = Base_Import[207],
    func$0 = Base_Import[221],
    zero = 0,
    one = 1,
    minus_one = -1;
   function hash$0(x){return caml_call1(func$0, x);}
   var neg = Base_Import[113];
   function symbol(_aB_, _aA_){return _aB_ < _aA_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    function _ay_(_az_){return _az_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _ay_);
   }
   var
    include$0 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _aw_ = low <= t ? 1 : 0, _ax_ = _aw_ ? t <= high ? 1 : 0 : _aw_;
    return _ax_;
   }
   function clamp_unchecked(t, min, max){
    return t < min ? min : t <= max ? t : max;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _at_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _au_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _at_],
     _av_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _au_);
    return caml_call1(Base_Or_error[35], _av_);
   }
   function pred(i){return caml_call2(Base_Import[93], i, 1);}
   function succ(i){return caml_call2(Base_Import[91], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[85][18],
    min_value = Base_Import[85][19],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[11],
    of_int64_exn = Base_Int_conversions[12],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[22],
    of_nativeint_exn = Base_Int_conversions[23],
    to_nativeint = Base_Int_conversions[5],
    max_value_30_bits = 1073741823;
   function abs(x){return caml_call1(Base_Import[123], x);}
   function rem(a, b){return caml_call2(Base_Import[122], a, b);}
   function incr(_as_){_as_[1]++; return 0;}
   function decr(_ar_){_ar_[1] += -1; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[115], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[120], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[119], a, b);}
   function bit_not(a){return caml_call1(Base_Import[117], a);}
   function bit_or(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[116], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[121], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[93], x, 1),
     _al_ = caml_call2(Base_Import[120], x$0, 1),
     x$1 = caml_call2(Base_Import[118], x$0, _al_),
     _am_ = caml_call2(Base_Import[120], x$1, 2),
     x$2 = caml_call2(Base_Import[118], x$1, _am_),
     _an_ = caml_call2(Base_Import[120], x$2, 4),
     x$3 = caml_call2(Base_Import[118], x$2, _an_),
     _ao_ = caml_call2(Base_Import[120], x$3, 8),
     x$4 = caml_call2(Base_Import[118], x$3, _ao_),
     _ap_ = caml_call2(Base_Import[120], x$4, 16),
     x$5 = caml_call2(Base_Import[118], x$4, _ap_),
     _aq_ = caml_call2(Base_Import[120], x$5, 32),
     x$6 = caml_call2(Base_Import[118], x$5, _aq_);
    return caml_call2(Base_Import[91], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _ae_ = caml_call2(Base_Import[120], x, 1),
     x$0 = caml_call2(Base_Import[118], x, _ae_),
     _af_ = caml_call2(Base_Import[120], x$0, 2),
     x$1 = caml_call2(Base_Import[118], x$0, _af_),
     _ag_ = caml_call2(Base_Import[120], x$1, 4),
     x$2 = caml_call2(Base_Import[118], x$1, _ag_),
     _ah_ = caml_call2(Base_Import[120], x$2, 8),
     x$3 = caml_call2(Base_Import[118], x$2, _ah_),
     _ai_ = caml_call2(Base_Import[120], x$3, 16),
     x$4 = caml_call2(Base_Import[118], x$3, _ai_),
     _aj_ = caml_call2(Base_Import[120], x$4, 32),
     x$5 = caml_call2(Base_Import[118], x$4, _aj_),
     _ak_ = caml_call2(Base_Import[120], x$5, 1);
    return caml_call2(Base_Import[93], x$5, _ak_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _ad_ = caml_call2(Base_Import[93], x, 1);
    return 0 === caml_call2(Base_Import[116], x, _ad_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _aa_ = [0, [0, cst, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _aa_));
    }
    var
     _ab_ = runtime.Base_int_math_int_clz(i),
     _ac_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _ac_, _ab_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var ___ = [0, [0, cst$0, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_ceil_log2_got_invalid_, ___));
    }
    if(1 === i) return 0;
    var
     _$_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[93], i, 1));
    return caml_call2(Base_Import[93], num_bits, _$_);
   }
   var sign = Base_Sign[27], popcount = Base_Popcount[1];
   function _h_(_Z_){return - _Z_ | 0;}
   function _i_(_Y_, _X_){return _Y_ !== _X_ ? 1 : 0;}
   function _j_(_W_, _V_){return _W_ < _V_ ? 1 : 0;}
   function _k_(_U_, _T_){return _T_ < _U_ ? 1 : 0;}
   function _l_(_S_, _R_){return _S_ === _R_ ? 1 : 0;}
   function _m_(_Q_, _P_){return _Q_ <= _P_ ? 1 : 0;}
   function _n_(_O_, _N_){return _N_ <= _O_ ? 1 : 0;}
   function _o_(_M_){return - _M_ | 0;}
   var _p_ = caml_div, _q_ = runtime.caml_mul;
   function _r_(_L_, _K_){return _L_ - _K_ | 0;}
   var
    _s_ =
      [0,
       of_float,
       to_float,
       of_string$0,
       to_string,
       function(_J_, _I_){return _J_ + _I_ | 0;},
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       abs,
       _h_,
       zero,
       of_int_exn,
       rem],
    F = caml_call1(Base_Int_math[1], _s_),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8];
   function symbol$1(x, y){
    if(y <= 0){
     var _G_ = caml_call1(to_string, y), _H_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _t_, _H_, _G_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _E_ = caml_call1(to_string, y), _F_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _u_, _F_, _E_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[96], x, y);}
   var
    lnot = Base_Import[117],
    include$2 = Base_Import[97],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    _v_ = [0, [0, F[1], F[2], F[3]]],
    _w_ = [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3];
   function _x_(_D_){return runtime.Base_int_math_int_ctz(_D_);}
   function _y_(_C_){return runtime.Base_int_math_int_clz(_C_);}
   var
    _z_ = caml_int_compare,
    Base_Int =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_B_, _A_){return _B_ === _A_ ? 1 : 0;},
       _z_,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _y_,
       _x_,
       _w_,
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       max_value_30_bits,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       _v_];
   runtime.caml_register_global(33, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Comparable, Base__Hash, Base__Import, Base__Pretty_printer, Base__Printf, Base__String, Base__Uchar0, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    _g_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"],
    _f_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _e_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _d_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed",
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"];
   function hash_fold_t(state, t){
    var _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _t_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string(t){
    var _s_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _s_);
   }
   function sexp_of_t(t){return [0, to_string(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[159], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _p_ = function(i){return caml_call1(Base_Uchar0[7], i);},
      _q_ = caml_call3(Stdlib_Scanf[5], s, _b_, _p_);
     return _q_;
    }
    catch(_r_){
     return caml_call2(Base_Import[159], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name, to_string])[1],
    _c_ = caml_call1(Base_Comparable[10], [0, compare, sexp_of_t]),
    between = _c_[13],
    clamp_exn = _c_[14],
    clamp = _c_[15],
    comparator = _c_[16];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _o_ = caml_call1(Base_Uchar0[1], c); return _o_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function succ(c){
    try{var _m_ = [0, caml_call1(Base_Uchar0[1], c)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function pred_exn(c){
    try{var _k_ = caml_call1(Base_Uchar0[2], c); return _k_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _e_, msg, 0);
    }
   }
   function pred(c){
    try{var _i_ = [0, caml_call1(Base_Uchar0[2], c)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _f_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _g_, caml_call1(to_int, c), 0);
   }
   function utf8_byte_length(uchar){
    var codepoint = to_scalar(uchar);
    return 128 <= codepoint
            ? 2048 <= codepoint ? 65536 <= codepoint ? 4 : 3 : 2
            : 1;
   }
   var
    include = Base_Import[107],
    symbol = include[2],
    symbol$0 = include[3],
    symbol$1 = include[4],
    symbol$2 = include[5],
    symbol$3 = include[6],
    symbol$4 = include[7],
    ascending = include[8],
    descending = include[9],
    compare$0 = include[10],
    equal = include[11],
    max = include[12],
    min = include[13],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value,
       max_value];
   runtime.caml_register_global(19, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Error, Base__Import, Base__Int, Base__Option, Base__Sexp, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    some_t = [0, 0],
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Int = global_data.Base__Int,
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids",
    _d_ = [0, "witness"],
    _e_ = [0, "name"],
    cst_Key = "Key",
    _c_ = [0, "type_witness"],
    _b_ = [0, 0, 0],
    _a_ = [0, "T"];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var refl = 0;
   function sym(param){return 0;}
   function trans(param, _$_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, ___){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _Z_, _Y_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _X_){return 0;}
   function Composition_preserves_injectiv(M1, M2){
    function strip(e){
     var _W_ = caml_call1(M2[1], e);
     return caml_call1(M1[1], _W_);
    }
    return [0, strip];
   }
   function sexp_of_t$0(param, _V_){
    var name = _V_[2], witness = _V_[1];
    if(Base_Import[132]) return [0, name];
    var
     t = witness[1],
     _U_ = caml_call1(Stdlib_Obj[23][1], t),
     v_005 = caml_call1(Stdlib_Obj[23][3], _U_);
    return [1,
            [0,
             [1, [0, _e_, [0, [0, name], 0]]],
             [0,
              [1,
               [0,
                _d_,
                [0,
                 [1, [0, _c_, [0, caml_call1(Base_Import[142], v_005), 0]]],
                 0]]],
              0]]];
   }
   function to_sexp(t){return t[3];}
   function name(t){return t[2];}
   function create(name, to_sexp){
    var Key = [248, cst_Key, runtime.caml_fresh_oo_id(0)];
    return [0, [0, Key], name, to_sexp];
   }
   function uid(t){
    var M = t[1], _T_ = caml_call1(Stdlib_Obj[23][1], M[1]);
    return caml_call1(Stdlib_Obj[23][3], _T_);
   }
   function hash(t){return uid(t);}
   function hash_fold_t(s, t){
    var _S_ = uid(t);
    return caml_call2(Base_Import[207], s, _S_);
   }
   function same_witness(t1, t2){
    var b = t2[1], a = t1[1];
    return a[1] === b[1] ? some_t : 0;
   }
   function same(t1, t2){
    var _R_ = same_witness(t1, t2);
    return caml_call1(Base_Option[50], _R_);
   }
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var w = match[1]; return w;}
    var _H_ = 0, _I_ = [0, t1, t2], _J_ = Base_Import[155];
    function _K_(_Q_){return sexp_of_t$0(_J_, _Q_);}
    var _L_ = Base_Import[155];
    function _M_(_P_){return sexp_of_t$0(_L_, _P_);}
    var
     _N_ = [0, [0, cst, caml_call3(Base_Import[150], _M_, _K_, _I_)], _H_],
     _O_ = caml_call2(Base_Sexp[9], cst_Type_equal_Id_same_witness, _N_);
    return caml_call1(Base_Error[30], _O_);
   }
   var
    _f_ = Base_Int[21],
    _g_ = Base_Int[20],
    _h_ = Base_Int[19],
    _i_ = Base_Int[18],
    _j_ = Base_Int[17],
    _k_ = Base_Int[16],
    _l_ = Base_Int[15],
    _m_ = Base_Int[14],
    _n_ = Base_Int[13],
    _o_ = Base_Int[12];
   function _p_(_G_, _F_){return _G_ !== _F_ ? 1 : 0;}
   function _q_(_E_, _D_){return _E_ < _D_ ? 1 : 0;}
   function _r_(_C_, _B_){return _B_ < _C_ ? 1 : 0;}
   function _s_(_A_, _z_){return _A_ === _z_ ? 1 : 0;}
   function _t_(_y_, _x_){return _y_ <= _x_ ? 1 : 0;}
   function _u_(_w_, _v_){return _v_ <= _w_ ? 1 : 0;}
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$0,
        [0,
         Base_Int[6],
         Base_Int[7],
         Base_Int[8],
         Base_Int[9],
         _u_,
         _t_,
         _s_,
         _r_,
         _q_,
         _p_,
         _o_,
         _n_,
         _m_,
         _l_,
         _k_,
         _j_,
         _i_,
         _h_,
         _g_,
         _f_],
        uid,
        create,
        hash,
        name,
        to_sexp,
        hash_fold_t,
        same,
        same_witness,
        same_witness_exn]];
   runtime.caml_register_global(15, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[14], 1),
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]",
    none = 24791911;
   function is_none(x){return caml_call2(Base_Import[128], x, none);}
   function is_some(x){return 1 - caml_call2(Base_Import[128], x, none);}
   function some(x){
    return caml_call2(Base_Import[128], x, none) ? none_substitute : x;
   }
   function value_unsafe(x){
    return caml_call2(Base_Import[128], x, none_substitute) ? none : x;
   }
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[124], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[6], Base_Option[7]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _A_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _A_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _z_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _z_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _x_ = caml_call1(Base_Option[3], a_sexp_grammar),
     _y_ = caml_call1(Sexplib0_Sexp_grammar[1], _x_);
    return caml_call1(Base_Uniform_array[3], _y_);
   }
   var empty = Base_Uniform_array[6];
   function create(len){return caml_call2(Base_Uniform_array[7], len, none);}
   function init(n, f){
    function _w_(i){return of_sexpable(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[9], n, _w_);
   }
   function init_some(n, f){
    function _v_(i){return some(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[9], n, _v_);
   }
   var _a_ = Base_Uniform_array[10];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[11], t, i));
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_none$0(t, i){
    return is_none(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[11], t, i));
   }
   function set(t, i, x){
    var _u_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[13], t, i, _u_);
   }
   function set_some(t, i, x){
    var _t_ = some(x);
    return caml_call3(Base_Uniform_array[13], t, i, _t_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[13], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[15], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[14], t, i, _s_);
   }
   function unsafe_set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[14], t, i, _r_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[14], t, i, none);
   }
   function clear(t){
    var
     _o_ = caml_call1(_a_, t),
     _p_ = caml_call2(Base_Import[93], _o_, 1),
     _n_ = 0;
    if(_p_ >= 0){
     var i = _n_;
     for(;;){
      unsafe_set_none(t, i);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _k_ = caml_call1(_a_, input),
     _l_ = caml_call2(Base_Import[93], _k_, 1),
     _j_ = 0;
    if(_l_ >= 0){
     var i = _j_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _m_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _m_;
     }
    }
    return 0;
   }
   function _c_(input, f){
    return _b_(input, function(param, x){return caml_call1(f, x);});
   }
   function _d_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _d_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _d_],
    iter = [0, -198771759, _c_],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    length$0 = include$0[1],
    is_empty = include$0[2],
    iter$0 = include$0[3],
    fold$0 = include$0[4],
    fold_result = include$0[5],
    fold_until = include$0[6],
    exists = include$0[7],
    for_all = include$0[8],
    count = include$0[9],
    sum = include$0[10],
    find = include$0[11],
    find_map = include$0[12],
    to_list = include$0[13],
    min_elt = include$0[15],
    max_elt = include$0[16],
    foldi$0 = include$0[17],
    iteri$0 = include$0[18],
    existsi = include$0[19],
    for_alli = include$0[20],
    counti = include$0[21],
    findi = include$0[22],
    find_mapi = include$0[23];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _h_ = caml_call2(Base_Import[93], len, 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[12], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    function _e_(i){return unsafe_get(t, i);}
    var _f_ = caml_call1(length$0, t);
    return caml_call2(Base_Array[27], _f_, _e_);
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[30],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[33],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       length$0,
       is_empty,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Assert_failure, Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[30],
    _e_ = [0, cst_src_stack_ml, 107, 14],
    _d_ = [0, cst_src_stack_ml, 39, 4],
    _c_ = [0, cst_src_stack_ml, 46, 6],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_Stack_pop_of_empty_stack = "Stack.pop of empty stack",
    cst_Stack_top_of_empty_stack = "Stack.top of empty stack";
   function capacity(t){return caml_call1(Base_Option_array[6], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[6], elts)){
      var _B_ = caml_call2(Base_Import[93], length, 1), _A_ = 0;
      if(_B_ >= 0){
       var i$0 = _A_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[34], elts, i$0));
        var _G_ = i$0 + 1 | 0;
        if(_B_ === i$0) break;
        var i$0 = _G_;
       }
      }
      var
       _C_ = caml_call1(Base_Option_array[6], elts),
       _D_ = caml_call2(Base_Import[93], _C_, 1);
      if(_D_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[36], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _F_ = i + 1 | 0;
        if(_D_ === i) break;
        var i = _F_;
       }
      }
      var _E_ = 0;
      return _E_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[155],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[142], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _z_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Stack_invariant_failed, _z_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _w_ = caml_call2(Base_Import[93], t[1], 1);
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      var _x_ = caml_call2(Base_Option_array[34], t[2], i);
      r[1] = caml_call2(f, r[1], _x_);
      var _y_ = i - 1 | 0;
      if(0 === i) break;
      var i = _y_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _u_ = caml_call2(Base_Import[93], t[1], 1);
    if(_u_ >= 0){
     var i = _u_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[34], t[2], i));
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      var i = _v_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_list(l){
    if(caml_call1(Base_List[8], l)) return create(0);
    var
     length = caml_call1(Base_List[7], l),
     _r_ = caml_call2(Base_Import[88], 2, length),
     elts = caml_call1(Base_Option_array[5], _r_),
     r = [0, l],
     _s_ = caml_call2(Base_Import[93], length, 1);
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[42], elts, i, a);
      r[1] = l$0;
      var _t_ = i - 1 | 0;
      if(0 === i) break;
      var i = _t_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _q_ = caml_call1(to_list, t);
    return caml_call2(Base_List[4], sexp_of_a, _q_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _p_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _p_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[51], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[100], new_capacity, t[1]),
     _o_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _o_ ? resize(t, new_capacity$0) : _o_;
   }
   function push(t, a){
    var _m_ = caml_call1(Base_Option_array[6], t[2]);
    if(t[1] === _m_){
     var _n_ = caml_call2(Base_Import[91], t[1], 1);
     resize(t, caml_call2(Base_Import[88], 2, _n_));
    }
    caml_call3(Base_Option_array[42], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[93], t[1], 1),
     result = caml_call2(Base_Option_array[34], t[2], i);
    caml_call2(Base_Option_array[43], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[12], cst_Stack_pop_of_empty_stack);
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _l_ = caml_call2(Base_Import[93], t[1], 1);
    return caml_call2(Base_Option_array[34], t[2], _l_);
   }
   var top_error = caml_call1(Base_Error[12], cst_Stack_top_of_empty_stack);
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[56], elts)];
   }
   function clear(t){
    var _g_ = 0 < t[1] ? 1 : 0;
    if(_g_){
     var _i_ = caml_call2(Base_Import[93], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       caml_call2(Base_Option_array[43], t[2], i);
       var _k_ = i + 1 | 0;
       if(_i_ === i) break;
       var i = _k_;
      }
     }
     t[1] = 0;
     var _j_ = 0;
    }
    else
     var _j_ = _g_;
    return _j_;
   }
   function until_empty(t, f){
    for(;;){
     var _f_ = 0 < t[1] ? 1 : 0;
     if(! _f_) return _f_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Int = global_data.Base__Int,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _a_ = caml_call1(Base_Int[7], pos_cnum),
     _b_ = caml_call1(Base_Int[7], pos_bol),
     _c_ = caml_call1(Base_Int[7], pos_lnum),
     _d_ = runtime.Base_hash_string(pos_fname),
     _e_ = caml_call2(Base_Import[121], _d_, _c_),
     _f_ = caml_call2(Base_Import[121], _e_, _b_);
    return caml_call2(Base_Import[121], _f_, _a_);
   }
   var
    hash_fold_t = Base_Source_code_position0[3],
    comparator = Base_Source_code_position0[5],
    to_string = Base_Source_code_position0[7],
    sexp_of_t = Base_Source_code_position0[8],
    include = caml_call1(Base_Comparable[11], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _k_ = sexp_004[1];
      b:
      if(caml_string_notequal(_k_, cst_Nan)){
       c:
       if(caml_string_notequal(_k_, cst_Neg)){
        d:
        if(caml_string_notequal(_k_, cst_Pos)){
         if(caml_string_notequal(_k_, cst_Zero)){
          if(! caml_string_notequal(_k_, cst_nan)) break b;
          if(! caml_string_notequal(_k_, cst_neg)) break c;
          if(! caml_string_notequal(_k_, cst_pos)) break d;
          if(caml_string_notequal(_k_, cst_zero)) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _l_ = sexp_004[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _n_ = _m_[1];
     b:
     if(caml_string_notequal(_n_, cst_Nan)){
      c:
      if(caml_string_notequal(_n_, cst_Neg)){
       d:
       if(caml_string_notequal(_n_, cst_Pos)){
        if(caml_string_notequal(_n_, cst_Zero)){
         if(! caml_string_notequal(_n_, cst_nan)) break b;
         if(! caml_string_notequal(_n_, cst_neg)) break c;
         if(! caml_string_notequal(_n_, cst_pos)) break d;
         if(caml_string_notequal(_n_, cst_zero)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      case 2:
       return caml_call2(Base_Hash[3], hsv, 2);
      default: return caml_call2(Base_Hash[3], hsv, 3);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[139], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[163], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24];
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[126], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[27], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[28], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[31], _g_, _f_));
    }
    return 3;
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(31, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    hash_fold_t = Base_Sexp[1],
    hash = Base_Sexp[2],
    t_of_sexp = Base_Sexp[3],
    sexp_of_t = Base_Sexp[4],
    Not_found_s = Base_Sexp[7],
    Of_sexp_error = Base_Sexp[8],
    message = Base_Sexp[9],
    default_indent = Base_Sexp[10],
    pp_hum = Base_Sexp[11],
    pp_hum_indent = Base_Sexp[12],
    pp_mach = Base_Sexp[13],
    pp = Base_Sexp[14],
    to_string_hum = Base_Sexp[15],
    to_string_mach = Base_Sexp[16],
    to_string = Base_Sexp[17],
    of_float_style = Base_Sexp[18],
    of_int_style = Base_Sexp[19],
    t_sexp_grammar = Base_Sexp[21],
    invariant = Base_Sexp[22],
    of_string = Base_Sexp[23],
    include = caml_call1(Base_Comparable[10], [0, Base_Sexp[6], Base_Sexp[4]]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator = include[16],
    Base_Sexp_with_comparable =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_027 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound",
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _a_ = [0, 0, 0];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc],
      l = l$0,
      acc = acc$0;
    }
    var
     _q_ = caml_call1(Base_List[38], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _r_ = caml_call2(Base_List[75], _q_, _a_);
    for(;;){
     if(! l$1){
      var _s_ = caml_call1(Base_List[38], acc$1);
      return caml_call2(Base_List[75], _s_, _r_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1],
      l$1 = l$2,
      acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _n_ = sexp_008[1];
      b:
      if(caml_string_notequal(_n_, cst_Excl$0)){
       c:
       if(caml_string_notequal(_n_, cst_Incl$0)){
        if(caml_string_notequal(_n_, cst_Unbounded)){
         if(! caml_string_notequal(_n_, cst_excl)) break b;
         if(! caml_string_notequal(_n_, cst_incl)) break c;
         if(caml_string_notequal(_n_, cst_unbounded)) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
     }
     var _o_ = sexp_008[1];
     if(! _o_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
     var _p_ = _o_[1];
     if(0 !== _p_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_008);
     var tag_009 = _p_[1];
     b:
     if(caml_string_notequal(tag_009, cst_Excl$0)){
      c:
      if(caml_string_notequal(tag_009, cst_Incl$0)){
       if(caml_string_notequal(tag_009, cst_Unbounded)){
        if(! caml_string_notequal(tag_009, cst_excl)) break b;
        if(! caml_string_notequal(tag_009, cst_incl)) break c;
        if(caml_string_notequal(tag_009, cst_unbounded)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_008);
      }
      var sexp_args_010 = _o_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _o_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function interval_comparison_of_sexp(sexp_028){
    a:
    {
     if(0 === sexp_028[0]){
      var _j_ = sexp_028[1];
      b:
      if(caml_string_notequal(_j_, cst_Above_upper_bound)){
       c:
       if(caml_string_notequal(_j_, cst_Below_lower_bound)){
        if(caml_string_notequal(_j_, cst_In_range)){
         if(! caml_string_notequal(_j_, cst_above_upper_bound)) break b;
         if(! caml_string_notequal(_j_, cst_below_lower_bound)) break c;
         if(caml_string_notequal(_j_, cst_in_range)) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _k_ = sexp_028[1];
     if(! _k_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_028);
     var _l_ = _k_[1];
     if(0 !== _l_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_028);
     var _m_ = _l_[1];
     b:
     if(caml_string_notequal(_m_, cst_Above_upper_bound)){
      c:
      if(caml_string_notequal(_m_, cst_Below_lower_bound)){
       if(caml_string_notequal(_m_, cst_In_range)){
        if(! caml_string_notequal(_m_, cst_above_upper_bound)) break b;
        if(! caml_string_notequal(_m_, cst_below_lower_bound)) break c;
        if(caml_string_notequal(_m_, cst_in_range)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_028);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var compare_interval_comparison = runtime.caml_int_compare;
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[124], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"],
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _f_ = [0, "Both"],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    _c_ = [0, cst_Left$0],
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && -1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(caml_call2(Base_Ppx_compare_lib[1], a_005, b_006)) return 1;
    if(typeof a_005 === "number"){
     if(typeof b_006 === "number" && -1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0];
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(caml_call2(Base_Ppx_compare_lib[1], t_014, t_016)) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(caml_call2(Base_Ppx_compare_lib[1], t_030, t_032)) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            caml_string_notequal(atom_047, cst_Left$0)
             ? caml_string_notequal
                (atom_047, cst_Right$0)
               ? caml_string_notequal
                  (atom_047, cst_Unequal$0)
                 ? caml_call1(Sexplib0_Sexp_conv_error[19], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(caml_string_notequal(atom_047$0, cst_Left$0))
            if(caml_string_notequal(atom_047$0, cst_Right$0))
             if(caml_string_notequal(atom_047$0, cst_Unequal$0))
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[19], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[22],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[22],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[22],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[18])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[20], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[2], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(caml_call2(Base_Ppx_compare_lib[1], a_085, b_086)) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(caml_call2(Base_Ppx_compare_lib[1], a_097, b_098)) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare;
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare;
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3];
   function Check_accessors(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors3(M){return [0];}
   function Check_accessors3_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators3_with_comparato(M){return [0];}
   var
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
   runtime.caml_register_global(26, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
//# unitInfo: Requires: Base__Map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data();
   global_data.Base__Map_intf;
   function Check_accessors(T, Tree, Elt, Named, Cmp, Options, symbol){return [0];
   }
   function Check_accessors0(M){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors2_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Elt, Cmp, Options, symbol){return [0];}
   function Check_creators0(M){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators2_with_comparato(M){return [0];}
   var
    Base_Set_intf =
      [0,
       Check_accessors,
       Check_accessors0,
       Check_accessors1,
       Check_accessors2,
       Check_accessors2_with_comparat,
       Check_creators,
       Check_creators0,
       Check_creators1,
       Check_creators2,
       Check_creators2_with_comparato];
   runtime.caml_register_global(1, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Comparator, Base__Container, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    with_return = Base_With_return[1],
    _t_ = [0, "_"],
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _s_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    _r_ = [0, cst_src_set_ml, 1047, 8],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    _p_ = [0, 0, 0],
    _o_ = [0, 0, 0, 0],
    _m_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _n_ = [0, cst_src_set_ml, 309, 15],
    _j_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _k_ = [0, cst_src_set_ml, 296, 15],
    _a_ = [0, cst_src_set_ml, 199, 17],
    _b_ = [0, cst_src_set_ml, 200, 18],
    _c_ = [0, cst_src_set_ml, 206, 21],
    _d_ = [0, cst_src_set_ml, 208, 12],
    _e_ = [0, cst_src_set_ml, 214, 17],
    _f_ = [0, cst_src_set_ml, 215, 18],
    _g_ = [0, cst_src_set_ml, 221, 21],
    _h_ = [0, cst_src_set_ml, 223, 12],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_Base_Set_Tree0_Same = "Base__Set.Tree0.Same",
    cst_Base_Set_Tree0_Set_min_elt =
      "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
    cst_Base_Set_Tree0_Set_max_elt =
      "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
    _q_ = [0, "Set.choose_exn: empty set"];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bP_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bP_ = 1;
    if(_bP_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bQ_ = 1;
    }
    else
     var _bQ_ = _bP_;
    return _bQ_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _bE_ = caml_call2(Base_Import[93], hl, hr),
      _bF_ = caml_call1(Base_Import[123], _bE_) <= 2 ? 1 : 0;
     if(_bF_){
      var
       _bG_ = caml_call2(Base_Import[100], hl, hr),
       _bH_ = h === caml_call2(Base_Import[91], _bG_, 1) ? 1 : 0;
      if(_bH_){
       var
        _bI_ = length(r),
        _bJ_ = length(l),
        _bK_ = caml_call2(Base_Import[91], _bJ_, _bI_),
        _bL_ = n === caml_call2(Base_Import[91], _bK_, 1) ? 1 : 0;
       if(_bL_){
        var _bM_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bM_){
         var _bN_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bN_){
          var lower$1 = [0, v$0], lower$0 = lower$1, t$0 = r;
          continue;
         }
         var _bO_ = _bN_;
        }
        else
         var _bO_ = _bM_;
       }
       else
        var _bO_ = _bL_;
      }
      else
       var _bO_ = _bH_;
     }
     else
      var _bO_ = _bF_;
     return _bO_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(1 === h) return [0, v];
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    var _bD_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _bD_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[91], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[91], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _bB_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _bB_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      _bC_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _bC_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _by_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _by_)){
       var
        next =
          function(i){
           var
            _bz_ = caml_call2(Base_Import[93], array_length, 1),
            _bA_ = caml_call2(Base_Import[93], _bz_, i);
           return caml_check_bound(array, _bA_)[1 + _bA_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bs_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bs_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _bu_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _bt_ = 1;
               if(_bu_ >= 1){
                var i$0 = _bt_;
                for(;;){
                 var
                  _bv_ = caml_call2(Base_Import[91], i$0, 1),
                  _bw_ = caml_check_bound(array, _bv_)[1 + _bv_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bw_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _bx_ = i$0 + 1 | 0;
                 if(_bu_ === i$0) break;
                 var i$0 = _bx_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _bl_ = height(lr);
     if(_bl_ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _bn_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _bn_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _bm_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _bm_);
    }
    if(caml_call2(Base_Import[91], hl, 2) < hr){
     if(typeof r === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(0 === r[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var rr = r[3], rv = r[2], rl = r[1], _bo_ = height(rl);
     if(_bo_ <= height(rr)) return create(create(l, v, rl), rv, rr);
     if(typeof rl === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     if(0 !== rl[0]){
      var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bq_ = create(rlr, rv, rr);
      return create(create(l, v, rll), rlv$0, _bq_);
     }
     var rlv = rl[1];
     if(! is_empty(rr))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var _bp_ = create(0, rv, rr);
     return create(create(l, v, 0), rlv, _bp_);
    }
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    if(1 === h) return [0, v];
    var _br_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _br_, 1)];
   }
   var Same = [248, cst_Base_Set_Tree0_Same, caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      if(0 === c) throw caml_maybe_attach_backtrace(Same, 1);
      return 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) throw caml_maybe_attach_backtrace(Same, 1);
     return 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bj_ = aux(t); return _bj_;}
    catch(_bk_){
     var _bi_ = caml_wrap_exception(_bk_);
     if(_bi_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bi_, 0);
    }
   }
   function join(l, v, r, compare_elt){
    if(typeof l === "number") return add(r, v, compare_elt);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rv = r[1];
       return add(add(l, v, compare_elt), rv, compare_elt);
      }
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r, compare_elt))
              : caml_call2
                 (Base_Import[91], lh, 2)
                < rh
                ? bal(join(l, v, rl, compare_elt), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add(l, v, compare_elt);
    var lv = l[1];
    return add(add(r, v, compare_elt), lv, compare_elt);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){var param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Set_min_elt_exn_of_empty_set) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Set_min_elt_exn_of_empty_set, _i_);
   var
    Set_max_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Set_max_elt_exn_of_empty_set) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Set_max_elt_exn_of_empty_set, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1], t$0 = right, acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3], param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[126], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _bh_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _bh_);
   }
   function concat(t1, t2, compare_elt){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _bg_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _bg_, compare_elt);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _o_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr, compare_elt), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r, compare_elt)];
    }
    return split(t);
   }
   var empty_without_value_restrictio = 0;
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _bf_ = 0 === c$0 ? 1 : 0;
     if(_bf_) return _bf_;
     var r$0 = 0 <= c$0 ? r : l, t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 !== t[0]){
      var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
      return 0 === c
              ? merge(l, r)
              : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
     }
     var v = t[1];
     if(0 === caml_call2(compare_elt, x, v)) return 0;
     throw caml_maybe_attach_backtrace(Same, 1);
    }
    try{var _bd_ = aux(t); return _bd_;}
    catch(_be_){
     var _bc_ = caml_wrap_exception(_be_);
     if(_bc_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bc_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 === t[0]){
      if(0 === i) return 0;
      throw caml_maybe_attach_backtrace(Same, 1);
     }
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _bb_ = caml_call2(Base_Import[93], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[93], _bb_, 1)));
    }
    try{var _a$_ = aux(t, i); return _a$_;}
    catch(_ba_){
     var _a__ = caml_wrap_exception(_ba_);
     if(_a__ === Same) return t;
     throw caml_maybe_attach_backtrace(_a__, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(caml_call2(Base_Import[128], s1$0, s2$0)) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1], s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _a8_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _a8_, compare_elt);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _a9_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _a9_, compare_elt);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    function _a7_(ac, x){
     return union(ac, caml_call1(to_tree, x), compare_elt);
    }
    return caml_call3(Base_List[10], xs, empty_without_value_restrictio, _a7_);
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(caml_call2(Base_Import[128], s1, s2)) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _a4_ = split(s2, v1, compare_elt),
          match = _a4_[2],
          l2 = _a4_[1];
         if(match){
          var r2 = _a4_[3], v1$0 = match[1], _a5_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _a5_, compare_elt);
         }
         var r2$0 = _a4_[3], _a6_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _a6_, compare_elt);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(caml_call2(Base_Import[128], s1$0, s2)) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _a1_ = split(s2, v1$0, compare_elt),
        l2 = _a1_[1];
       if(_a1_[2]){
        var r2 = _a1_[3], _a2_ = diff(r1, r2);
        return concat(diff(l1, l2), _a2_, compare_elt);
       }
       var r2$0 = _a1_[3], _a3_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _a3_, compare_elt);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, r, e$0],
      s$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, l, e$0],
      s$0 = r,
      e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[128], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _a0_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _a0_];
     return [0, next_state];
    }
    var _aY_ = of_set(t2), _aZ_ = [0, of_set(t1), _aY_];
    return caml_call2(Base_Sequence[41], _aZ_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aQ_ = Base_Import[125],
      _aR_ = function(_aW_, _aX_){return inclusive_bound(_aQ_, _aW_, _aX_);},
      t$4 = caml_call3(Base_Option[31], less_or_equal_to, t$3, _aR_),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0])
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1], t = t$0;
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key))
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e], t = l, e = e$0;
        else
         var t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[41], init, next);
    }
    var _aS_ = Base_Import[127];
    function _aT_(_aU_, _aV_){return inclusive_bound(_aS_, _aU_, _aV_);}
    var t$5 = caml_call3(Base_Option[31], greater_or_equal_to, t$3, _aT_);
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0])
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1], t$1 = t$2;
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        var t$1 = l$0;
       else
        var
         r$1 = t$1[3],
         v$4 = t$1[2],
         e$2 = [0, v$4, l$0, e$1],
         t$1 = r$1,
         e$1 = e$2;
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[41], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aN_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aO_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aP_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[56], _aP_, _aO_, _aN_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(caml_call2(Base_Import[128], r1, r2))
      var e1 = e1$0, e2 = e2$0;
     else
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0), e1 = e1$1, e2 = e2$1;
    }
   }
   function iter2(s1, s2, compare_elt){
    var t2 = of_set(s2), t1 = of_set(s1);
    return function(f){
     var t1$0 = t1, t2$0 = t2;
     for(;;){
      if(! t1$0)
       return t2$0
               ? iter
                 (function(a){return caml_call1(f, [0, -57574468, a]);}, t2$0)
               : 0;
      if(! t2$0)
       return iter
               (function(a){return caml_call1(f, [0, 847852583, a]);}, t1$0);
      var
       enum2 = t2$0[3],
       tree2 = t2$0[2],
       a2 = t2$0[1],
       enum1 = t1$0[3],
       tree1 = t1$0[2],
       a1 = t1$0[1],
       compare_result = caml_call2(compare_elt, a1, a2);
      if(0 === compare_result){
       caml_call1(f, [0, 737457313, [0, a1, a2]]);
       var
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1),
        t1$0 = t1$1,
        t2$0 = t2$1;
      }
      else if(0 <= compare_result){
       caml_call1(f, [0, -57574468, a2]);
       var t2$2 = cons(tree2, enum2), t2$0 = t2$2;
      }
      else{
       caml_call1(f, [0, 847852583, a1]);
       var t1$2 = cons(tree1, enum1), t1$0 = t1$2;
      }
     }};
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aL_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aL_) return _aL_;
          var s1$0 = l1;
          continue;
         }
         var _aM_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aM_) return _aM_;
         var s1$0 = r1;
         continue;
        }
        var _aI_ = caml_call2(Base_Import[128], s1$0, s2$0);
        if(_aI_)
         var _aJ_ = _aI_;
        else{
         var _aK_ = is_subset(l1, l2);
         if(_aK_){var s1$0 = r1, s2$0 = r2; continue;}
         var _aJ_ = _aK_;
        }
        return _aJ_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(caml_call2(Base_Import[128], s1$0, s2$0)) return 0;
         var _aG_ = split(s2$0, v1, compare_elt), l2 = _aG_[1];
         if(_aG_[2]) return 0;
         var r2 = _aG_[3], _aH_ = are_disjoint(l1, l2, compare_elt);
         if(! _aH_) return _aH_;
         var s1$0 = r1, s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      var param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0),
      s$0 = r,
      accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f)),
      s$0 = l,
      accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aD_ = caml_call1(p, v$0);
     if(_aD_){
      var _aE_ = for_all(l, p);
      if(_aE_){var t$0 = r; continue;}
      var _aF_ = _aE_;
     }
     else
      var _aF_ = _aD_;
     return _aF_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aA_ = caml_call1(p, v$0);
     if(_aA_)
      var _aB_ = _aA_;
     else{
      var _aC_ = exists(l, p);
      if(! _aC_){var t$0 = r; continue;}
      var _aB_ = _aC_;
     }
     return _aB_;
    }
   }
   function filter(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v) ? add(accu$0, v, compare_elt) : accu$0;
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _az_ = caml_call1(p, v$0) ? add(accu$0, v$0, compare_elt) : accu$0,
       accu$1 = filt(_az_, l),
       accu$0 = accu$1,
       param$0 = r;
     }
    }
    return filt(0, s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ay_ = add(accu$0, v$2, compare_elt);
      else
       var _ay_ = accu$0;
      var accu$1 = filt(_ay_, l), accu$0 = accu$1, param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p, compare_elt){
    function part(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      var f = accu$0[2], t = accu$0[1];
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v)
               ? [0, add(t, v, compare_elt), f]
               : [0, t, add(f, v, compare_elt)];
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _ax_ =
         caml_call1(p, v$0)
          ? [0, add(t, v$0, compare_elt), f]
          : [0, t, add(f, v$0, compare_elt)],
       accu$1 = part(_ax_, l),
       accu$0 = accu$1,
       param$0 = r;
     }
    }
    return part(_p_, s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)],
      accu$0 = accu$1,
      param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var not_found = [0, Base_Import[252], _q_];
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    function _aw_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_List[10], lst, empty_without_value_restrictio, _aw_);
   }
   function of_sequence(sequence, compare_elt){
    function _av_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_Sequence[8], sequence, empty_without_value_restrictio, _av_);
   }
   function to_list(s){return elements(s);}
   function of_array(a, compare_elt){
    function _au_(t, x){return add(t, x, compare_elt);}
    return caml_call3(Base_Array[10], a, empty_without_value_restrictio, _au_);
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[25], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _as_ = pos_ref[1];
       caml_check_bound(res, _as_)[1 + _as_] = v;
       return caml_call1(Base_Import[130], pos_ref);
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _at_ = pos_ref[1];
      caml_check_bound(res, _at_)[1 + _at_] = v$0;
      caml_call1(Base_Import[130], pos_ref);
      var param$0 = r;
     }
    }
    loop(l);
    caml_call1(Base_Import[130], pos_ref);
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv, compare_elt){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var
      x = choose_exn(set$0),
      match =
        partition_tf
         (set$0,
          function(x){
            return function(elt){
             var _ar_ = caml_call2(Base_Import[128], x, elt);
             return _ar_ ? _ar_ : caml_call2(equiv, x, elt);};
           }
           (x),
          compare_elt),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes],
      set$0 = not_equiv_x,
      equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     var t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     var t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[124], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _aq_ = caml_call2(Base_Import[93], i$0, l_size),
       i$1 = caml_call2(Base_Import[93], _aq_, 1),
       t$0 = r,
       i$0 = i$1;
     }
     else
      var t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[38], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      var xs$0 = tl;
     else
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers],
       xs$0 = tl,
       leftovers = leftovers$0,
       already_seen = already_seen$0;
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[159], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[76], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _ao_ = caml_call1(Base_List[7], lst);
    if(length(set) === _ao_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    function _ap_(el_sexp, el){
     return mem(set$0[1], el, compare_elt)
             ? caml_call2
               (Base_Import[159], cst_Set_t_of_sexp_duplicate_el, el_sexp)
             : (set$0[1] = add(set$0[1], el, compare_elt), 0);
    }
    caml_call3(Base_List[42], lst, elt_lst, _ap_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _s_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _al_ = caml_call2(Base_Import[112], cst_is_not_a_subset_of, superset[2]),
     _am_ = caml_call2(Base_Import[112], subset[2], _al_),
     _an_ =
       caml_call2
        (Base_Sexp[9],
         _am_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[35], _an_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function invariants$0(t){
    var _ak_ = compare_elt(t);
    return invariants(t[2], _ak_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list$0(t){return to_list(t[2]);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _ai_ = t[2];
    return function(_aj_){return fold_until(_ai_, init, f, _aj_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ah_ = compare_elt(a);
    return iter2(a[2], b[2], _ah_)(f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _ag_ = compare_elt(t); return mem(t[2], a, _ag_);}
   function filter$0(t, f){
    var _af_ = compare_elt(t);
    return like(t, filter(t[2], f, _af_));
   }
   function add$0(t, a){
    var _ae_ = compare_elt(t);
    return like(t, add(t[2], a, _ae_));
   }
   function remove$0(t, a){
    var _ad_ = compare_elt(t);
    return like(t, remove(t[2], a, _ad_));
   }
   function union$0(t1, t2){
    var _ac_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _ac_));
   }
   function inter$0(t1, t2){
    var _ab_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _ab_));
   }
   function diff$0(t1, t2){
    var _aa_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _aa_));
   }
   function symmetric_diff$0(t1, t2){
    var _$_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _$_);
   }
   function compare_direct(t1, t2){
    var _Z_ = t2[2], ___ = t1[2];
    return compare(compare_elt(t1), ___, _Z_);
   }
   function equal$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return equal(t1[2], t2[2], _Y_);
   }
   function is_subset$1(t, of){
    var _X_ = compare_elt(t);
    return is_subset(t[2], of[2], _X_);
   }
   function are_disjoint$0(t1, t2){
    var _W_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _W_);
   }
   function to_named_tree(param){
    var name = param[2], set = param[1];
    return [0, set[2], name];
   }
   function is_subset$2(subset, superset){
    var
     _T_ = compare_elt(subset[1]),
     _U_ = subset[1][1][2],
     _V_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _V_, _U_, _T_);
   }
   function equal$1(t1, t2){
    var
     _R_ = [0, is_subset$2(t2, t1), 0],
     _S_ = [0, is_subset$2(t1, t2), _R_];
    return caml_call1(Base_Or_error[47], _S_);
   }
   function partition_tf$0(t, f){
    var
     _P_ = compare_elt(t),
     match = partition_tf(t[2], f, _P_),
     tree_f = match[2],
     tree_t = match[1],
     _Q_ = like(t, tree_f);
    return [0, like(t, tree_t), _Q_];
   }
   function split$0(t, a){
    var
     _N_ = compare_elt(t),
     match = split(t[2], a, _N_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _O_ = like(t, tree2);
    return [0, like(t, tree1), b, _O_];
   }
   function group_by$0(t, equiv){
    function _J_(_M_){return like(t, _M_);}
    var _K_ = compare_elt(t), _L_ = group_by(t[2], equiv, _K_);
    return caml_call2(Base_List[76], _L_, _J_);
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _I_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _I_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _H_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[207], state, _H_), hash_fold_elem);
   }
   function compare$0(param, _G_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$1(t){return to_list(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f){
    return function(_F_){return fold_until(t, init, f, _F_);};
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(comparator, t, f){return filter(t, f, comparator[1]);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(comparator, t, f){
    return partition_tf(t, f, comparator[1]);
   }
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1])(f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_E_){return _E_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(comparator, t, equiv){
    return group_by(t, equiv, comparator[1]);
   }
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _C_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _D_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _C_];
    return caml_call1(Base_Or_error[47], _D_);
   }
   var Named = [0, is_subset$4, equal$3];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    return [0, comparator, t_of_sexp_direct(a_of_sexp, sexp, comparator[1])];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    return [0, comparator, union_list(comparator, to_tree$0, l)];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return [0, comparator, of_increasing_iterator_uncheck(len, f)];
   }
   function of_sorted_array$1(comparator, array){
    function _A_(tree){return [0, comparator, tree];}
    var _B_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[18][2], _B_, _A_);
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function empty$1(m){return empty$0(m[1]);}
   function singleton$1(m, a){return singleton$0(m[1], a);}
   function union_list$2(m, a){return union_list$1(m[1], a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_list$2(m, a){return of_list$1(m[1], a);}
   function of_sequence$2(m, a){return of_sequence$1(m[1], a);}
   function of_array$2(m, a){return of_array$1(m[1], a);}
   function stable_dedup_list$2(m, a){return stable_dedup_list$1(m[1], a);}
   function map$2(m, a, f){return map$1(m[1], a, f);}
   function filter_map$2(m, a, f){return filter_map$1(m[1], a, f);}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){
     function _z_(param){return _t_;}
     return sexp_of_t$0(Elt[1], _z_, t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _y_ = caml_call1(Base_Import[195], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _y_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt){
    return function(state){
     var _w_ = Elt[1];
     return function(_x_){return hash_fold_direct(_w_, state, _x_);};};
   }
   function hash_m_t(folder, t){
    var
     _v_ = caml_call2(Base_Hash[11], 0, 0),
     state = caml_call1(hash_fold_m_t(folder)(_v_), t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$1(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _u_ = Base_Sequence[55],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list$0,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _u_[1], _u_[3], _u_[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$1],
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         Named,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$1,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio]];
   runtime.caml_register_global(45, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare = Base_Import[238],
    equal = Base_Import[251],
    t_of_sexp = Base_Import[171],
    sexp_of_t = Base_Import[147];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    function _b_(param){t[1] = restore_to; return 0;}
    return caml_call2(Base_Exn[13], f, _b_);
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[9], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[76], and_values, snapshot);
    sets(and_values);
    function _a_(param){return sets(restore_to);}
    return caml_call2(Base_Exn[13], f, _a_);
   }
   var
    Base_Ref =
      [0,
       compare,
       equal,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 451, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    _o_ = [0, cst_src_queue_ml, 193, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _n_ = [0, cst_src_queue_ml, 152, 2],
    _m_ = [0, cst_src_queue_ml, 153, 2],
    _l_ = [0, cst_src_queue_ml, 155, 2],
    _k_ = [0, cst_src_queue_ml, 156, 2],
    _j_ = [0, cst_src_queue_ml, 157, 2],
    _i_ = [0, cst_src_queue_ml, 158, 2],
    _h_ = [0, cst_src_queue_ml, 159, 2],
    _g_ = [0, cst_src_queue_ml, 165, 9],
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"];
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return;
   }
   function capacity(t){return caml_call2(Base_Import[91], t[3], 1);}
   function elts_index(t, i){
    var _a3_ = t[3], _a4_ = caml_call2(Base_Import[91], t[2], i);
    return caml_call2(Base_Import[116], _a4_, _a3_);
   }
   function unsafe_get(t, i){
    var _a2_ = elts_index(t, i);
    return caml_call2(Base_Option_array[38], t[5], _a2_);
   }
   function unsafe_set(t, i, a){
    var _a1_ = elts_index(t, i);
    return caml_call3(Base_Option_array[49], t[5], _a1_, a);
   }
   function check_index_exn(t, i){
    var _aW_ = i < 0 ? 1 : 0, _aX_ = _aW_ || (t[4] <= i ? 1 : 0);
    if(! _aX_) return _aX_;
    var
     _aY_ = [0, [0, cst_length, caml_call1(Base_Int[9], t[4])], 0],
     _aZ_ = [0, [0, cst_index, caml_call1(Base_Int[9], i)], _aY_],
     _a0_ = caml_call2(Base_Sexp[9], cst_Queue_index_out_of_bounds, _aZ_);
    return caml_call1(Base_Error[30], _a0_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aT_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aT_) return _aT_;
    var _aU_ = 0;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = t[1],
     front_005 = t[2],
     mask_007 = t[3],
     length_009 = t[4],
     elts_011 = t[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[142], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[142], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[142], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[142], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aV_ =
       caml_call2
        (Base_Sexp[9],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], _aU_]);
    return caml_call1(Base_Error[30], _aV_);
   }
   function compare(compare_elt, t1, t2){
    if(caml_call2(Base_Import[128], t1, t2)) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aS_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aS_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function equal(equal_elt, t1, t2){
    var _aP_ = caml_call2(Base_Import[128], t1, t2);
    if(_aP_)
     var _aQ_ = _aP_;
    else{
     var len1 = t1[4], len2 = t2[4], _aR_ = len1 === len2 ? 1 : 0;
     if(_aR_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aM_ = pos === len1 ? 1 : 0;
       if(_aM_)
        var _aN_ = _aM_;
       else{
        var
         _aO_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aO_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
         continue;
        }
        var _aN_ = b;
       }
       return _aN_;
      }
     }
     var _aQ_ = _aR_;
    }
    return _aQ_;
   }
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[6], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[67], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aK_ = caml_call2(Base_Import[93], capacity$0, 1), _aJ_ = 0;
    if(_aK_ >= 0){
     var i = _aJ_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aI_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[40], t[5], _aI_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aL_ = i + 1 | 0;
      if(_aK_ === i) break;
      var i = _aL_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _aE_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[63], capacity$0);
     else
      var
       _aG_ = [0, [0, cst_capacity, caml_call1(Base_Int[9], capacity$0)], 0],
       _aH_ = caml_call2(Base_Sexp[9], cst_cannot_have_queue_with_neg, _aG_),
       _aE_ = caml_call1(Base_Error[30], _aH_);
     var capacity$1 = _aE_;
    }
    else
     var capacity$1 = 1;
    var _aF_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[93], capacity$1, 1), 0, _aF_];
   }
   function blit_to_array(src, dst){
    var _aA_ = caml_call1(Base_Option_array[6], dst);
    if(src[4] > _aA_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aB_ = src[2],
     _aC_ = capacity(src),
     _aD_ = caml_call2(Base_Import[93], _aC_, _aB_),
     front_len = caml_call2(Base_Int[14], src[4], _aD_),
     rest_len = caml_call2(Base_Import[93], src[4], front_len);
    caml_call5(Base_Option_array[51], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[51], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _aw_ = caml_call2(Base_Import[100], desired_capacity, t[4]),
     _ax_ = caml_call2(Base_Import[100], 1, _aw_),
     new_capacity = caml_call1(Base_Int[63], _ax_),
     _ay_ = new_capacity !== capacity(t) ? 1 : 0;
    if(_ay_){
     var dst = caml_call1(Base_Option_array[5], new_capacity);
     blit_to_array(t, dst);
     t[2] = 0;
     t[3] = caml_call2(Base_Import[93], new_capacity, 1);
     t[5] = dst;
     var _az_ = 0;
    }
    else
     var _az_ = _ay_;
    return _az_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _av_ = capacity(t);
    if(t[4] === _av_) set_capacity(t, caml_call2(Base_Import[88], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return 0;
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[34], elts, front);
    caml_call2(Base_Option_array[43], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function front_nonempty(t){
    return caml_call2(Base_Option_array[38], t[5], t[2]);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function clear(t){
    inc_num_mutations(t);
    var _aq_ = 0 < t[4] ? 1 : 0;
    if(_aq_){
     var _as_ = caml_call2(Base_Import[93], t[4], 1), _ar_ = 0;
     if(_as_ >= 0){
      var i = _ar_;
      for(;;){
       var _ap_ = elts_index(t, i);
       caml_call2(Base_Option_array[50], t[5], _ap_);
       var _au_ = i + 1 | 0;
       if(_as_ === i) break;
       var i = _au_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _at_ = 0;
    }
    else
     var _at_ = _aq_;
    return _at_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _$_ = [0, [0, cst_length$0, caml_call1(Base_Int[9], len$0)], 0],
       _aa_ = caml_call2(Base_Sexp[9], cst_Queue_blit_transfer_negati, _$_);
      caml_call1(Base_Error[30], _aa_);
     }
     var len$1 = caml_call2(Base_Import[101], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _ab_ = 0 < len$1 ? 1 : 0;
    if(_ab_){
     var
      _ac_ = caml_call2(Base_Import[91], dst[4], len$1),
      _ad_ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[100], _ad_, _ac_));
     var
      dst_start = caml_call2(Base_Import[91], dst[2], dst[4]),
      _af_ = caml_call2(Base_Import[93], len$1, 1),
      _ae_ = 0;
     if(_af_ >= 0){
      var i = _ae_;
      for(;;){
       var
        _aj_ = src[3],
        _ak_ = caml_call2(Base_Import[91], src[2], i),
        src_i = caml_call2(Base_Import[116], _ak_, _aj_),
        _al_ = dst[3],
        _am_ = caml_call2(Base_Import[91], dst_start, i),
        dst_i = caml_call2(Base_Import[116], _am_, _al_),
        _an_ = caml_call2(Base_Option_array[38], src[5], src_i);
       caml_call3(Base_Option_array[49], dst[5], dst_i, _an_);
       caml_call2(Base_Option_array[50], src[5], src_i);
       var _ao_ = i + 1 | 0;
       if(_af_ === i) break;
       var i = _ao_;
      }
     }
     dst[4] = caml_call2(Base_Import[91], dst[4], len$1);
     var _ag_ = src[3], _ah_ = caml_call2(Base_Import[91], src[2], len$1);
     src[2] = caml_call2(Base_Import[116], _ah_, _ag_);
     src[4] = caml_call2(Base_Import[93], src[4], len$1);
     var _ai_ = 0;
    }
    else
     var _ai_ = _ab_;
    return _ai_;
   }
   function enqueue_all(t, l){
    var
     _X_ = caml_call1(Base_List[7], l),
     _Y_ = caml_call2(Base_Import[91], t[4], _X_),
     _Z_ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[15], _Z_, _Y_));
    function ___(x){return enqueue(t, x);}
    return caml_call2(Base_List[9], l, ___);
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _U_ = caml_call2(Base_Import[93], t[4], 1),
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      var _V_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _V_);
      ensure_no_mutation(t, num_mutations);
      var _W_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _W_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _R_ = caml_call2(Base_Import[93], t[4], 1),
     _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      var i = _S_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _O_ = caml_call2(Base_Import[93], t[4], 1),
     _N_ = 0;
    if(_O_ >= 0){
     var i = _N_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _P_ = i + 1 | 0;
      if(_O_ === i) break;
      var i = _P_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _K_ = caml_call2(Base_Import[93], t[4], 1);
    if(_K_ >= 0){
     var i = _K_;
     for(;;){
      var _L_ = result[1];
      result[1] = [0, unsafe_get(t, i), _L_];
      var _M_ = i - 1 | 0;
      if(0 === i) break;
      var i = _M_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       function _I_(b){return enqueue(t_result, b);}
       var _J_ = caml_call1(f, a);
       return caml_call2(Base_List[9], _J_, _I_);
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       function _G_(b){return enqueue(t_result, b);}
       var _H_ = caml_call2(f, i, a);
       return caml_call2(Base_List[9], _H_, _G_);
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _F_ = caml_call1(f, a);
       return _F_ ? enqueue(t_result, a) : _F_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _E_ = caml_call2(f, i, a);
       return _E_ ? enqueue(t_result, a) : _E_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[7], l)], 0);
    function _D_(x){return enqueue(t, x);}
    caml_call2(Base_List[9], l, _D_);
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _x_ = [0, [0, cst_length$1, caml_call1(Base_Int[9], len)], 0],
      _y_ = caml_call2(Base_Sexp[9], cst_Queue_init_negative_length, _x_);
     caml_call1(Base_Error[30], _y_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[6], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _A_ = caml_call2(Base_Import[93], len, 1), _z_ = 0;
    if(_A_ >= 0){
     var i = _z_;
     for(;;){
      var _B_ = caml_call1(f, i);
      caml_call3(Base_Option_array[49], t[5], i, _B_);
      var _C_ = i + 1 | 0;
      if(_A_ === i) break;
      var i = _C_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_w_){return a[1 + _w_];});
   }
   function to_array(t){
    function _v_(i){return unsafe_get(t, i);}
    return caml_call2(Base_Array[27], t[4], _v_);
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _t_ = caml_call2(Base_Import[93], ta[4], 1), _s_ = 0;
    if(_t_ >= 0){
     var i = _s_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[49], tb[5], i, b);
      var _u_ = i + 1 | 0;
      if(_t_ === i) break;
      var i = _u_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(0, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _r_ = to_list(t);
    return caml_call1(caml_call1(Base_List[4], sexp_of_a), _r_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _q_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _q_);
   }
   var
    Base_Queue =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       invariant,
       create,
       last,
       last_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity];
   runtime.caml_register_global(38, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Match_failure, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported",
    cst_Base_Nothing_t = "Base.Nothing.t",
    _a_ = [0, "src/nothing.ml", 6, 25];
   function unreachable_code(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   var all = 0;
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[26], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[124], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24],
    Base_Nothing =
      [0,
       all,
       t_sexp_grammar,
       unreachable_code,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    include = Base_Import[104],
    compare = include[9],
    hash_fold_t = Base_Import[203],
    func = Base_Import[217],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/nativeint.ml", 202, 2],
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146],
    t_sexp_grammar = Base_Import[190],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[104][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    comparator = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare$1 = Base_Import[232],
    hash_fold_t$0 = Base_Import[203],
    func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(_U_){return - _U_ | 0;}
   var symbol = Base_Import[104][1];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    function _S_(_T_){return _T_;}
    return caml_call3(Stdlib_Scanf[5], s, _c_, _S_);
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$1,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function shift_right_logical(_R_, _Q_){return _R_ >>> _Q_ | 0;}
   function shift_right(_P_, _O_){return _P_ >> _O_;}
   function shift_left(_N_, _M_){return _N_ << _M_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_L_, _K_){return _L_ ^ _K_;}
   function bit_or(_J_, _I_){return _J_ | _I_;}
   function bit_and(_H_, _G_){return _H_ & _G_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_F_){return - _F_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1];
   function to_float(_E_){return _E_;}
   function of_float_unchecked(_D_){return _D_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _C_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _d_, _C_, 0);
   }
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0,
     x$6 = x$5 | x$5 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$6);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0,
     x$5 = x$4 | x$4 >>> 32 | 0;
    return x$5 - (x$5 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var _B_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[104][4], _B_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _y_ = [0, [0, cst, caml_call1(Base_Import[146], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_floor_log2_got_i, _y_));
    }
    var
     _z_ = runtime.Base_int_math_nativeint_clz(i),
     _A_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _A_, _z_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _w_ = [0, [0, cst$0, caml_call1(Base_Import[146], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_ceil_log2_got_in, _w_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _x_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[93], num_bits, _x_);
   }
   function between(t, low, high){
    var _v_ = caml_call2(Base_Import[104][2], low, t);
    return _v_ ? caml_call2(Base_Import[104][2], t, high) : _v_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[104][1], t, min)
            ? min
            : caml_call2(Base_Import[104][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _s_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _t_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _s_],
     _u_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _t_);
    return caml_call1(Base_Or_error[35], _u_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_r_, _q_){return _r_ - _q_ | 0;}
   function symbol$4(_p_, _o_){return _p_ + _o_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[22],
    to_int_exn = Base_Int_conversions[23],
    to_int_trunc = Base_Int_conversions[24],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[25],
    to_int32_exn = Base_Int_conversions[26],
    to_int32_trunc = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[17],
    of_int64_exn = Base_Int_conversions[18],
    of_int64_trunc = Base_Int_conversions[19],
    to_int64 = Base_Int_conversions[28];
   function pow(b, e){
    var _m_ = caml_call1(to_int_exn, e), _n_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _n_, _m_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var
    _g_ = Base_Import[104],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[104],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$2 = include$4[9],
    equal = include$4[10],
    max = include$4[11],
    min = include$4[12],
    _h_ = runtime.caml_int32_bswap,
    _i_ =
      [0,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$1,
       symbol$0,
       symbol$5,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$0,
       zero$1,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _j_(_l_){return runtime.Base_int_math_nativeint_ctz(_l_);}
   var
    Base_Nativeint =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_nativeint_clz(_k_);},
       _j_,
       _i_,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       to_int32_trunc,
       of_int64_trunc,
       _h_];
   runtime.caml_register_global(34, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    name = "alist",
    name$0 = "sequence",
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4],
    _z_ = [0, "_"],
    _y_ = [0, "Map.Build_increasing.add: non-increasing key"],
    _x_ = [0, 0, 0],
    _g_ = [0, 0, 0, 0],
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _u_ = [0, 0],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _w_ = [0, cst_src_map_ml, 1639, 6],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    _v_ = [0, 0],
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1,
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    _t_ = [0, [0, 0, 0], [0, 0, 0]],
    _s_ = [0, 0, 0],
    _r_ = [0, 0, 0],
    _q_ = [0, 0, 0],
    _p_ = [0, 0, 0],
    _o_ = [0, 0, 0],
    _m_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _n_ = [0, cst_src_map_ml, 547, 15],
    _j_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _k_ = [0, cst_src_map_ml, 534, 15],
    _h_ = [0, "Map.find_exn: not found"],
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    cst_Map_singleton_to_tree_exn_ =
      "Map.singleton_to_tree_exn: not a singleton",
    _f_ = [1, 0],
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    cst_Map_bal = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 196, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _e_ = [0, cst_src_map_ml, 210, 18],
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    _b_ = [0, "map.ml.Duplicate"],
    _c_ = [0, cst_src_map_ml, 67, 11],
    cst_Base_Map_Duplicate = "Base__Map.Duplicate",
    cst_Base_Map_Tree0_Map_min_elt =
      "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Map_max_elt =
      "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Remove_no_o = "Base__Map.Tree0.Remove_no_op",
    cst_Base_Map_Tree0_Change_no_o = "Base__Map.Tree0.Change_no_op";
   function of_continue_or_stop(_dE_){return _dE_;}
   function to_continue_or_stop(_dD_){return _dD_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _dC_ = param[1];
    if(737457313 === _dC_)
     var left = param[2][1];
    else{if(847852583 > _dC_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _dB_ = param[1];
    if(737457313 === _dB_)
     var right = param[2][2];
    else{if(847852583 <= _dB_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dA_ = t[1];
    if(737457313 === _dA_)
     var left = t[2][1];
    else{if(847852583 > _dA_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dz_ = t[1];
    if(737457313 === _dz_)
     var right = t[2][2];
    else{if(847852583 <= _dz_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _dy_ = t[1];
    if(737457313 === _dy_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _dy_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, cst_Base_Map_Duplicate, caml_fresh_oo_id(0)];
   function _a_(param){
    if(param === Duplicate) return _b_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Duplicate, _a_);
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _dw_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _dw_ = 1;
    if(_dw_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _dx_ = 1;
    }
    else
     var _dx_ = _dw_;
    return _dx_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _dp_ = caml_call2(Base_Import[93], hl, hr),
      _dq_ = caml_call1(Base_Import[123], _dp_) <= 2 ? 1 : 0;
     if(_dq_){
      var
       _dr_ = caml_call2(Base_Import[100], hl, hr),
       _ds_ = h === caml_call2(Base_Import[91], _dr_, 1) ? 1 : 0;
      if(_ds_){
       var _dt_ = in_range(lower$0, upper, compare_key, k$0);
       if(_dt_){
        var _du_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_du_){
         var lower$1 = [0, k$0], lower$0 = lower$1, t$0 = r;
         continue;
        }
        var _dv_ = _du_;
       }
       else
        var _dv_ = _dt_;
      }
      else
       var _dv_ = _ds_;
     }
     else
      var _dv_ = _dq_;
     return _dv_;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _do_ =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    return [1, l, x, d, r, _do_];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[91], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _dm_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _dm_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      v = match[2],
      k = match[1],
      _dn_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _dn_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _dk_ = caml_call2(Base_Import[93], array_length, 1),
            _dl_ = caml_call2(Base_Import[93], _dk_, i);
           return caml_check_bound(array, _dl_)[1 + _dl_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _da_ = caml_check_bound(array, 1)[2],
                _db_ = caml_call1(Base_Import[125], _da_),
                _dc_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[125], _dc_), _db_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _de_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _dd_ = 1;
               if(_de_ >= 1){
                var i$0 = _dd_;
                for(;;){
                 var
                  _df_ = caml_call2(Base_Import[91], i$0, 1),
                  _dg_ = caml_check_bound(array, _df_)[1 + _df_],
                  _dh_ = caml_call1(Base_Import[125], _dg_),
                  _di_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[125], _di_), _dh_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _dj_ = i$0 + 1 | 0;
                 if(_de_ === i$0) break;
                 var i$0 = _dj_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_key)];
              });
    return [0, of_sorted_array_unchecked(array, compare_key)];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[126], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _c6_ = height(lr);
     if(_c6_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[126], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _c7_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _c7_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _c8_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _c8_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr) return create(l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _c9_ = height(rl);
    if(_c9_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _c__ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _c__);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _c$_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _c$_);
   }
   var empty_without_value_restrictio = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _c4_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _c5_ = caml_call2(Base_Sexp[9], cst_Map_add_exn_got_key_alread, _c4_);
    return caml_call1(Base_Error[30], _c5_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[91], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[91], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[91], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0){
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1];
     return [0, bal(l, v$0, d$0, r$0), length$0];
    }
    var
     match$0 =
       find_and_add_or_set
        (l, length, x, data, compare_key, sexp_of_key, add_or_set),
     length$1 = match$0[2],
     l$0 = match$0[1];
    return [0, bal(l$0, v$0, d$0, r), length$1];
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    var _c3_ = 2;
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _f_;},
             _c3_);
   }
   function set$0(t, key, data, compare_key){
    var _c2_ = set(t, 0, key, data, compare_key);
    return caml_call1(Base_Import[125], _c2_);
   }
   function singleton_to_tree_exn(param){
    if(typeof param[1] !== "number")
     return caml_call1(Base_Import[124], cst_Map_singleton_to_tree_exn_);
    var data = param[3], key = param[2];
    return [0, key, data];
   }
   function collapse(l, r){return create(l[1], l[2], l[3], r);}
   function join(l, r){
    var _c0_ = r[3], _c1_ = r[2];
    return [0, collapse(l, r[1]), _c1_, _c0_];
   }
   function go(t, x){
    switch(t[0]){
      case 0:
       return [1, t, x];
      case 1:
       var y = t[2], t$0 = t[1]; return [2, t$0, y, x];
      default:
       var y$0 = t[3], z = t[2], t$1 = t[1];
       return [1, go(t$1, join(z, y$0)), x];
    }
   }
   function add_unchecked(t, key, data){return go(t, [0, 0, key, data]);}
   function go$0(t, r){
    var t$0 = t, r$0 = r;
    for(;;)
     switch(t$0[0]){
       case 0:
        return r$0;
       case 1:
        var
         l = t$0[2],
         t$1 = t$0[1],
         r$1 = collapse(l, r$0),
         t$0 = t$1,
         r$0 = r$1;
        break;
       default:
        var
         l$0 = t$0[3],
         ll = t$0[2],
         t$2 = t$0[1],
         r$2 = collapse(join(ll, l$0), r$0),
         t$0 = t$2,
         r$0 = r$2;
     }
   }
   function to_tree_unchecked(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2], t = param[1];
       return go$0(t, singleton_to_tree_exn(r));
      default:
       var r$0 = param[3], l = param[2], t$0 = param[1];
       return go$0([1, t$0, l], singleton_to_tree_exn(r$0));
    }
   }
   function max_key(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2]; break;
      default: var r = param[3];
    }
    return [0, r[2]];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              function _cX_(param$0, _cY_){
               var
                data = _cY_[2],
                key = _cY_[1],
                length = param$0[2],
                builder = param$0[1],
                match = max_key(builder);
               if(match){
                var prev_key = match[1];
                if(0 <= caml_call2(compare_key, prev_key, key))
                 return caml_call1
                         (param,
                          caml_call1
                           (Base_Or_error[36], cst_of_increasing_sequence_non));
               }
               var _cZ_ = caml_call2(Base_Import[91], length, 1);
               return [0, add_unchecked(builder, key, data), _cZ_];
              }
              var
               match = caml_call3(Base_Sequence[8], seq, [0, empty, 0], _cX_),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join$0(l, k, d, r, compare_key){
    if(typeof l === "number") return set$0(r, k, d, compare_key);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set$0(set$0(l, k, d, compare_key), rk, rd, compare_key);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 3) < lh
              ? bal(ll, lk$0, ld$0, join$0(lr, k, d, r, compare_key))
              : caml_call2
                 (Base_Import[91], lh, 3)
                < rh
                ? bal(join$0(l, k, d, rl, compare_key), rk$0, rd$0, rr)
                : bal(l, k, d, r);
     }
    }
    if(typeof r === "number") return set$0(l, k, d, compare_key);
    var ld = l[2], lk = l[1];
    return set$0(set$0(r, k, d, compare_key), lk, ld, compare_key);
   }
   function split(t, x, compare_key){
    if(typeof t === "number") return _g_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call2(compare_key, x, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call2(compare_key, x, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join$0(l, k$0, d$0, rl, compare_key), maybe, rr];
    }
    var
     match$0 = split(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join$0(lr, k$0, d$0, r, compare_key)];
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     match = split(t, x, compare_key),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(! boundary_opt) return [0, left, right];
    var match$0 = boundary_opt[1], data = match$0[2], key = match$0[1];
    function insert_into(tree){
     var _cW_ = set(tree, 0, key, data, compare_key);
     return caml_call1(Base_Import[125], _cW_);
    }
    return 847852583 <= into
            ? [0, insert_into(left), right]
            : [0, left, insert_into(right)];
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(caml_call3(Base_Maybe_bound[9], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _cU_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _cU_[2],
      left = _cU_[1];
    else
     var
      lb$2 = lower_bound[1],
      _cV_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _cV_[2],
      left$0 = _cV_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _cS_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _cS_[2],
      mid = _cS_[1];
    else
     var
      lb$0 = upper_bound[1],
      _cT_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _cT_[2],
      mid$0 = _cT_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _cR_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[27], _cR_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _cQ_ = [1, [0, _h_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[252], _cQ_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cP_ = find(t, x, compare_key);
    return caml_call1(Base_Option[50], _cP_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Map_min_elt_exn_of_empty_map) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Map_min_elt_exn_of_empty_map, _i_);
   var
    Map_max_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Map_max_elt_exn_of_empty_map) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Map_max_elt_exn_of_empty_map, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4], param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[126], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _cO_ = match$0[1],
     v = _cO_[2],
     min_upper = _cO_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0,
            17724,
            join$0
             (lower_part, min_upper, v, upper_part_without_min, compare_key)];
   }
   function go$1(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min)
       var init$1 = caml_call3(f, k$0, d$0, init$0), t$0 = r, init$0 = init$1;
      else{
       var
        z = go$1(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       var t$0 = r, init$0 = init$2;
      }
     else
      var t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go$1(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cN_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[21], _cN_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   var
    Remove_no_op = [248, cst_Base_Map_Tree0_Remove_no_o, caml_fresh_oo_id(0)];
   function remove(t, x, length, compare_key){
    function remove_loop(t, x, length, compare_key){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Remove_no_op);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_key, x, v)
              ? [0, 0, caml_call2(Base_Import[93], length, 1)]
              : caml_call1(Base_Exn[6], Remove_no_op);
     }
     var
      r = t[4],
      d = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c){
      var _cM_ = caml_call2(Base_Import[93], length, 1);
      return [0, concat_unchecked(l, r), _cM_];
     }
     if(0 <= c){
      var
       match = remove_loop(r, x, length, compare_key),
       length$0 = match[2],
       r$0 = match[1];
      return [0, bal(l, v$0, d, r$0), length$0];
     }
     var
      match$0 = remove_loop(l, x, length, compare_key),
      length$1 = match$0[2],
      l$0 = match$0[1];
     return [0, bal(l$0, v$0, d, r), length$1];
    }
    try{var _cK_ = remove_loop(t, x, length, compare_key); return _cK_;}
    catch(_cL_){
     var _cJ_ = caml_wrap_exception(_cL_);
     if(_cJ_ === Remove_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_cJ_, 0);
    }
   }
   var
    Change_no_op = [248, cst_Base_Map_Tree0_Change_no_o, caml_fresh_oo_id(0)];
   function change(t, key, f, length, compare_key){
    function change_core(t, key, f){
     if(typeof t === "number"){
      var match = caml_call1(f, 0);
      if(! match) throw caml_maybe_attach_backtrace(Change_no_op, 1);
      var data = match[1];
      return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var match$0 = caml_call1(f, [0, d]);
       if(! match$0) return [0, 0, caml_call2(Base_Import[93], length, 1)];
       var d$0 = match$0[1];
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var
        match$1 = change_core(0, key, f),
        length$0 = match$1[2],
        r = match$1[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$2 = change_core(0, key, f),
       length$1 = match$2[2],
       l = match$2[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var match$3 = caml_call1(f, [0, d$1]);
      if(match$3){
       var data$0 = match$3[1];
       return [0, [1, l$0, key, data$0, r$0, h], length];
      }
      var _cI_ = caml_call2(Base_Import[93], length, 1);
      return [0, concat_unchecked(l$0, r$0), _cI_];
     }
     if(0 <= c$0){
      var
       match$4 = change_core(r$0, key, f),
       length$2 = match$4[2],
       r$1 = match$4[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$5 = change_core(l$0, key, f),
      length$3 = match$5[2],
      l$1 = match$5[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    try{var _cG_ = change_core(t, key, f); return _cG_;}
    catch(_cH_){
     var _cF_ = caml_wrap_exception(_cH_);
     if(_cF_ === Change_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_cF_, 0);
    }
   }
   function update(t, key, f, length, compare_key){
    function update_core(t, key, f){
     if(typeof t === "number"){
      var data = caml_call1(f, 0);
      return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var d$0 = caml_call1(f, [0, d]);
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var match = update_core(0, key, f), length$0 = match[2], r = match[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$0 = update_core(0, key, f),
       length$1 = match$0[2],
       l = match$0[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var data$0 = caml_call1(f, [0, d$1]);
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     if(0 <= c$0){
      var
       match$1 = update_core(r$0, key, f),
       length$2 = match$1[2],
       r$1 = match$1[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$2 = update_core(l$0, key, f),
      length$3 = match$2[2],
      l$1 = match$2[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    return update_core(t, key, f);
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cE_ = param[1];
               if(_cE_){
                var non_empty_tail = _cE_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     var t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     var t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     var t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     var t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _cD_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _cD_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f)),
      t$0 = r,
      accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1], t$0 = r, acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f)),
      t$0 = l,
      accu$0 = accu$1;
    }
   }
   function filter_keys(t, f, compare_key){
    return fold
            (t,
             _o_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, key)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter(t, f, compare_key){
    return fold
            (t,
             _p_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filteri(t, f, compare_key){
    return fold
            (t,
             _q_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call2(f, key, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter_map(t, f, compare_key){
    return fold
            (t,
             _r_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call1(f, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function filter_mapi(t, f, compare_key){
    return fold
            (t,
             _s_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call2(f, key, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function partition_mapi(t, f, compare_key){
    return fold
            (t,
             _t_,
             function(key, data, param){
              var
               pair2 = param[2],
               pair1 = param[1],
               match = caml_call2(f, key, data);
              if(0 === match[0]){
               var x = match[1], length = pair1[2], t = pair1[1];
               return [0, set(t, length, key, x, compare_key), pair2];
              }
              var y = match[1], length$0 = pair2[2], t$0 = pair2[1];
              return [0, pair1, set(t$0, length$0, key, y, compare_key)];
             });
   }
   function partition_map(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){return caml_call1(f, data);},
             compare_key);
   }
   function partitioni_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function partition_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){
              return caml_call1(f, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0],
      t$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0],
      t$0 = r,
      e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0),
      init$0 = next,
      param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    var t1$0 = t1, t2$0 = t2, curr = init;
    for(;;){
     if(! t1$0)
      return t2$0
              ? fold$0
                (curr,
                 function(key, data, acc){
                  return caml_call3(f, key, [0, -57574468, data], acc);
                 },
                 t2$0)
              : curr;
     if(! t2$0)
      return fold$0
              (curr,
               function(key, data, acc){
                return caml_call3(f, key, [0, 847852583, data], acc);
               },
               t1$0);
     var
      enum2 = t2$0[4],
      tree2 = t2$0[3],
      v2 = t2$0[2],
      k2 = t2$0[1],
      enum1 = t1$0[4],
      tree1 = t1$0[3],
      v1 = t1$0[2],
      k1 = t1$0[1],
      compare_result = caml_call2(compare_key, k1, k2);
     if(0 === compare_result)
      var
       next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
       t2$1 = cons(tree2, enum2),
       t1$1 = cons(tree1, enum1),
       t1$0 = t1$1,
       t2$0 = t2$1,
       curr = next;
     else if(0 <= compare_result)
      var
       next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
       t2$2 = cons(tree2, enum2),
       t2$0 = t2$2,
       curr = next$0;
     else
      var
       next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
       t1$2 = cons(tree1, enum1),
       t1$0 = t1$2,
       curr = next$1;
    }
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var
       enum$0 = match[4],
       tree = match[3],
       data$0 = match[2],
       key$0 = match[1];
      return [1,
              [0, key$0, [0, -57574468, data$0]],
              [0, 0, cons(tree, enum$0)]];
     }
     var
      right = state[2],
      enum1 = left[4],
      tree1 = left[3],
      data = left[2],
      key = left[1];
     if(! right)
      return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[4],
      tree2 = right[3],
      v2 = right[2],
      k2 = right[1],
      compare_result = caml_call2(compare_key, key, k2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1,
                [0, k2, [0, -57574468, v2]],
                [0, left, cons(tree2, enum2)]]
              : [1,
                [0, key, [0, 847852583, data]],
                [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[128], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _cC_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _cC_];
     return caml_call2(data_equal, data, v2)
             ? [0, next_state]
             : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
    }
    var _cA_ = of_tree(t2), _cB_ = [0, of_tree(t1), _cA_];
    return caml_call2(Base_Sequence[41], _cB_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set$0(t$0, key, data, compare_key);
    }
    if(511974747 <= order){
     var
      _cs_ = Base_Import[127],
      _ct_ = function(_cy_, _cz_){return inclusive_bound(_cs_, _cy_, _cz_);},
      tree = caml_call3(Base_Option[31], keys_greater_or_equal_to, t$3, _ct_),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0])
        var
         d$1 = t$1[2],
         v$2 = t$1[1],
         t$2 = [1, 0, v$2, d$1, 0, 1],
         t$1 = t$2;
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         var t$1 = l$0;
        else
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1],
          t$1 = r$1,
          e$1 = e$2;
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[41], init$0, next$0);
    }
    var _cu_ = Base_Import[125];
    function _cv_(_cw_, _cx_){return inclusive_bound(_cu_, _cw_, _cx_);}
    var t$4 = caml_call3(Base_Option[31], keys_less_or_equal_to, t$3, _cv_);
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0])
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1], t = t$0;
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key))
        var
         r$0 = t[4],
         d$0 = t[3],
         v$1 = t[2],
         e$0 = [0, v$1, d$0, r$0, e],
         t = l,
         e = e$0;
       else
        var t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[41], init, next);
   }
   function compare$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     if(caml_call2(Base_Import[128], r1, r2))
      var t1 = e1, t2 = e2;
     else
      var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1), t1 = t1$0, t2 = t2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _cp_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_cp_){
        var _cq_ = caml_call2(compare_data, d1, d2);
        if(_cq_){
         if(caml_call2(Base_Import[128], r1, r2)){var t1 = e1, t2 = e2; continue;}
         var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1), t1 = t1$0, t2 = t2$0;
         continue;
        }
        var _cr_ = _cq_;
       }
       else
        var _cr_ = _cp_;
       return _cr_;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    function _cn_(key, data, param){return caml_call2(f, key, data);}
    var _co_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _co_, 0, _cn_);
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _cm_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cm_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(caml_call2(Base_Import[128], t1, t2)) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var l$0 = t2[1], r$0 = t2[4], v$2 = t2[3], k$2 = t2[2];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var
           acc$6 = loop(l, l$0, init),
           acc$7 = delta(acc$6, k$1, v$1, v$2),
           t1 = r,
           t2 = r$0,
           init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        right$2 = of_tree(t2),
        left$2 = of_tree(t1),
        left = left$2,
        right = right$2,
        acc = init;
       for(;;){
        if(! left)
         return fold$0
                 (acc,
                  function(key, data, acc){return add$0(acc, key, data);},
                  right);
        if(! right)
         return fold$0
                 (acc,
                  function(key, data, acc){return remove$0(acc, key, data);},
                  left);
        var
         enum2 = right[4],
         tree2 = right[3],
         v2 = right[2],
         k2 = right[1],
         enum1 = left[4],
         tree1 = left[3],
         v1 = left[2],
         k1 = left[1],
         compare_result = caml_call2(compare_key, k1, k2);
        if(0 === compare_result){
         var
          acc$0 =
            caml_call2(data_equal, v1, v2)
             ? acc
             : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]);
         if(caml_call2(Base_Import[128], tree1, tree2))
          var left = enum1, right = enum2, acc = acc$0;
         else
          var
           right$0 = cons(tree2, enum2),
           left$0 = cons(tree1, enum1),
           left = left$0,
           right = right$0,
           acc = acc$0;
        }
        else if(0 <= compare_result)
         var
          acc$1 = add$0(acc, k2, v2),
          right$1 = cons(tree2, enum2),
          right = right$1,
          acc = acc$1;
        else
         var
          acc$2 = remove$0(acc, k1, v1),
          left$1 = cons(tree1, enum1),
          left = left$1,
          acc = acc$2;
       }
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _cj_ = length(r),
     _ck_ = length(l),
     _cl_ = caml_call2(Base_Import[91], _ck_, _cj_);
    return caml_call2(Base_Import[91], _cl_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     function _ch_(param, _ci_){
      var
       data = _ci_[2],
       key = _ci_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], prev_data = prev;
      else
       var prev_data = init;
      var data$0 = caml_call2(f, prev_data, data);
      return set(accum, length, key, data$0, compare_key);
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _ch_);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     function _cf_(param, _cg_){
      var
       data = _cg_[2],
       key = _cg_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], new_data = caml_call2(f, prev, data);
      else
       var new_data = data;
      return set(accum, length, key, new_data, compare_key);
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _cf_);
    }
    function of_foldable(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               function _cd_(param, _ce_){
                var
                 data = _ce_[2],
                 key = _ce_[1],
                 length = param[2],
                 t = param[1],
                 acc = set(t, length, key, data, compare_key),
                 length$0 = acc[2];
                return length === length$0
                        ? caml_call1(r, [0, -1048878709, key])
                        : acc;
               }
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    _cd_);
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _ca_ = comparator[2],
      _cb_ = caml_call2(Base_Import[112], M[1], cst_or_error_duplicate_key),
      _cc_ = caml_call2(Base_Import[112], cst_Map_of, _cb_);
     return caml_call5(Base_Or_error[34], 0, 0, _cc_, key, _ca_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _b8_ = comparator[2],
      _b9_ = caml_call2(Base_Import[112], M[1], cst_exn_duplicate_key),
      _b__ = caml_call2(Base_Import[112], cst_Map_of$0, _b9_),
      _b$_ = caml_call5(Base_Error[17], 0, 0, _b__, key, _b8_);
     return caml_call1(Base_Error[29], _b$_);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable,
            of_foldable_or_error,
            of_foldable_exn];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5];
   function of_foldable_multi(foldable, fold, compare_key){
    var
     alist = caml_call3(fold, foldable, 0, function(l, x){return [0, x, l];});
    return of_alist_fold
            (alist, 0, function(l, x){return [0, x, l];}, compare_key);
   }
   function of_alist_multi(alist, compare_key){
    return of_foldable_multi(alist, Base_List0[8], compare_key);
   }
   var
    fold$2 = Base_Sequence[8],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5];
   function of_sequence_multi(sequence, compare_key){
    return of_foldable_multi(sequence, Base_Sequence[8], compare_key);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _b7_ = 1 - caml_call1(f, data);
                 return _b7_ ? caml_call1(r, 0) : _b7_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _b6_ = 1 - caml_call2(f, key, data);
                 return _b6_ ? caml_call1(r, 0) : _b6_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _b5_ = caml_call1(f, data);
                 return _b5_ ? caml_call1(r, 1) : _b5_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _b4_ = caml_call2(f, key, data);
                 return _b4_ ? caml_call1(r, 1) : _b4_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _b1_ = length(t2),
     _b2_ = length(t1),
     _b3_ = caml_call2(Base_Import[91], _b2_, _b1_),
     elts = caml_call1(Base_Uniform_array[34], _b3_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[13], elts, i[1], [0, key, value]);
       return caml_call1(Base_Import[130], i);
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[11], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return update
                      (t,
                       key,
                       function(param){
                        if(! param) return data;
                        var data$0 = param[1];
                        return caml_call4(call, combine, key, data$0, data);
                       },
                       length,
                       compare_key);
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       var
        t = l,
        found_marker = 1,
        found_key = found_key$0,
        found_value = found_value$0;
       continue;
      }
      var t = r;
      continue;
     }
     if(0 <= c$0)
      var t = l;
     else
      var
       t = r,
       found_marker = 1,
       found_key = found_key$0,
       found_value = found_value$0;
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _b0_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _b0_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _u_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var
       _bW_ =
         function(rank){
          var _bY_ = length(l), _bZ_ = caml_call2(Base_Import[91], rank, 1);
          return caml_call2(Base_Import[91], _bZ_, _bY_);
         },
       _bX_ = rank(r, k, compare_key);
      return caml_call2(Base_Option[21], _bX_, _bW_);
     }
     var t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (caml_call1(Base_Import[129], num_to_search), 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     caml_call1(Base_Import[129], num_to_search);
     var param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _v_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[49], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = pair;
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bV_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bV_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bL_ = caml_call2(Base_Import[174], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[176], _bL_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _bM_(_bU_){return _bU_;}
    function _bN_(_bT_){return _bT_;}
    var
     _bO_ = caml_call2(Base_Import[174], _bN_, _bM_),
     alist_sexps = caml_call2(Base_Import[176], _bO_, sexp),
     found_first_k = [0, 0];
    function _bP_(param, _bQ_){
     var
      k2_sexp = _bQ_[1],
      k2 = param[1],
      _bR_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
     if(_bR_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[159], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
      found_first_k[1] = 1;
      var _bS_ = 0;
     }
     else
      var _bS_ = _bR_;
     return _bS_;
    }
    caml_call3(Base_List0[13], alist, alist_sexps, _bP_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bK_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bK_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, compare_key, sexp_of_key){
    var
     _bI_ = partition_map(t, Base_Result[35], compare_key),
     error_tree = _bI_[2][1],
     oks = _bI_[1];
    if(is_empty(error_tree)) return [0, oks];
    var _bJ_ = sexp_of_t$1(sexp_of_key, Base_Error[6], error_tree);
    return caml_call1(Base_Or_error[35], _bJ_);
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bG_ =
                             add_exn_internal
                              (t2, length, key$0, data, compare_key, sexp_of_key);
                          return _bG_;
                         }
                         catch(_bH_){
                          var _bF_ = caml_wrap_exception(_bH_);
                          if(_bF_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bF_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bD_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bE_ = caml_call2(Base_Sexp[9], cst_Map_map_keys_exn_duplicate, _bD_);
    return caml_call1(Base_Error[30], _bE_);
   }
   function compare_key(t){return t[1][1];}
   function like(param, _bC_){
    var length = _bC_[2], tree = _bC_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like2(x, param){
    var z = param[2], y = param[1], _bB_ = like(x, z);
    return [0, like(x, y), _bB_];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return caml_call2(Base_Import[128], old_tree, tree)
            ? old_t
            : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bx_ = compare_key(t), _by_ = invariants(t[2], _bx_);
    if(_by_)
     var _bz_ = t[3], _bA_ = length(t[2]) === _bz_ ? 1 : 0;
    else
     var _bA_ = _by_;
    return _bA_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$1(t, key, data){
    var _bw_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bw_));
   }
   function add_exn$0(t, key, data){
    var _bu_ = t[1][2], _bv_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bv_, _bu_));
   }
   function add(t, key, data){
    try{
     var
      _bq_ = t[1][2],
      _br_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _br_, _bq_));
    }
    catch(_bt_){
     var _bs_ = caml_wrap_exception(_bt_);
     if(_bs_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bs_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _bp_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _bp_));
   }
   function remove_multi$0(t, key){
    var _bo_ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _bo_));
   }
   function find_multi$0(t, key){
    var _bn_ = compare_key(t);
    return find_multi(t[2], key, _bn_);
   }
   function change$0(t, key, f){
    var _bm_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _bm_));
   }
   function update$0(t, key, f){
    var _bl_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _bl_));
   }
   function find_exn$0(t, key){
    var _bj_ = t[1][2], _bk_ = compare_key(t);
    return find_exn(t[2], key, _bk_, _bj_);
   }
   function find$0(t, key){
    var _bi_ = compare_key(t);
    return find(t[2], key, _bi_);
   }
   function remove$0(t, key){
    var _bh_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _bh_));
   }
   function mem$0(t, key){
    var _bg_ = compare_key(t);
    return mem(t[2], key, _bg_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _bf_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _bf_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _bd_ = t[2];
    return function(_be_){return fold_until(_bd_, init, f, _be_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _bc_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _bc_);
   }
   function filter_keys$0(t, f){
    var _bb_ = compare_key(t);
    return like(t, filter_keys(t[2], f, _bb_));
   }
   function filter$0(t, f){
    var _ba_ = compare_key(t);
    return like(t, filter(t[2], f, _ba_));
   }
   function filteri$0(t, f){
    var _a$_ = compare_key(t);
    return like(t, filteri(t[2], f, _a$_));
   }
   function filter_map$0(t, f){
    var _a__ = compare_key(t);
    return like(t, filter_map(t[2], f, _a__));
   }
   function filter_mapi$0(t, f){
    var _a9_ = compare_key(t);
    return like(t, filter_mapi(t[2], f, _a9_));
   }
   function partition_mapi$0(t, f){
    var _a8_ = compare_key(t);
    return like2(t, partition_mapi(t[2], f, _a8_));
   }
   function partition_map$0(t, f){
    var _a7_ = compare_key(t);
    return like2(t, partition_map(t[2], f, _a7_));
   }
   function partitioni_tf$0(t, f){
    var _a6_ = compare_key(t);
    return like2(t, partitioni_tf(t[2], f, _a6_));
   }
   function partition_tf$0(t, f){
    var _a5_ = compare_key(t);
    return like2(t, partition_tf(t[2], f, _a5_));
   }
   function combine_errors$0(t){
    function _a0_(_a4_){return like(t, _a4_);}
    var
     _a1_ = t[1][2],
     _a2_ = compare_key(t),
     _a3_ = combine_errors(t[2], _a2_, _a1_);
    return caml_call2(Base_Or_error[43], _a3_, _a0_);
   }
   function compare_direct(compare_data, t1, t2){
    var _aY_ = t2[2], _aZ_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aZ_, _aY_);
   }
   function equal$2(compare_data, t1, t2){
    var _aW_ = t2[2], _aX_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aX_, _aW_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aV_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aV_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aU_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aU_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aT_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aT_));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aR_ = compare_key(t1),
     _aS_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aR_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aS_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function split$0(t, k){
    var
     _aP_ = compare_key(t),
     match = split(t[2], k, _aP_),
     r = match[3],
     maybe = match[2],
     l = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[50], maybe)
        ? caml_call2(Base_Import[93], t[3], 1)
        : t[3],
     _aQ_ = height(r);
    if(height(l) < _aQ_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             maybe,
             [0, comparator, r, caml_call2(Base_Import[93], both_len, l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[93], both_len, r$0[3])],
            maybe,
            r$0];
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aL_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aL_),
     right = match[3],
     mid = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[91], h_l, 1)
        : caml_call2(Base_Import[100], h_l, h_r);
    if(outer_joined_height >= height(mid)) return of_tree$0(t[1], mid);
    var
     _aM_ = length(right),
     _aN_ = length(left),
     _aO_ = caml_call2(Base_Import[91], _aN_, _aM_),
     mid_length = caml_call2(Base_Import[93], t[3], _aO_);
    return [0, t[1], mid, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aJ_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aJ_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     _aK_ = caml_call2(Base_Import[91], lower_part[3], upper_part[3]);
    return [0, 17724, [0, lower_part[1], tree, _aK_]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _aI_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _aI_);
   }
   function range_to_alist$0(t, min, max){
    var _aH_ = compare_key(t);
    return range_to_alist(t[2], min, max, _aH_);
   }
   function closest_key$0(t, dir, key){
    var _aG_ = compare_key(t);
    return closest_key(t[2], dir, key, _aG_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _aF_ = nth$1(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _aF_);
   }
   function rank$0(t, key){
    var _aE_ = compare_key(t);
    return rank(t[2], key, _aE_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2];
    function _aC_(key, data, state){
     return caml_call2
             (hash_fold_data, caml_call2(hash_fold_key, state, key), data);
    }
    var _aD_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[207], state, _aD_), _aC_);
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, _x_);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, k, v){return [0, k, v];}
   function of_sorted_array_unchecked$0(comparator, array){
    var _aB_ = of_sorted_array_unchecked(array, comparator[1]);
    return caml_call1(Base_Import[125], _aB_);
   }
   function of_sorted_array$0(comparator, array){
    var _aA_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _aA_, Base_Import[125]);
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _az_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Or_error[43], _az_, Base_Import[125]);
   }
   function of_alist_exn$0(comparator, alist){
    var _ay_ = of_alist_exn(alist, comparator);
    return caml_call1(Base_Import[125], _ay_);
   }
   function of_alist_multi$0(comparator, alist){
    var _ax_ = of_alist_multi(alist, comparator[1]);
    return caml_call1(Base_Import[125], _ax_);
   }
   function of_alist_fold$0(comparator, alist, init, f){
    var _aw_ = of_alist_fold(alist, init, f, comparator[1]);
    return caml_call1(Base_Import[125], _aw_);
   }
   function of_alist_reduce$0(comparator, alist, f){
    var _av_ = of_alist_reduce(alist, f, comparator[1]);
    return caml_call1(Base_Import[125], _av_);
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    var _au_ = of_iteri_exn(iteri, comparator);
    return caml_call1(Base_Import[125], _au_);
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var
     _as_ = Base_Import[125],
     _at_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _at_, _as_);
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var _ar_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Or_error[43], _ar_, Base_Import[125]);
   }
   function of_sequence_exn$0(comparator, seq){
    var _aq_ = of_sequence_exn(seq, comparator);
    return caml_call1(Base_Import[125], _aq_);
   }
   function of_sequence_multi$0(comparator, seq){
    var _ap_ = of_sequence_multi(seq, comparator[1]);
    return caml_call1(Base_Import[125], _ap_);
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    var _ao_ = of_sequence_fold(seq, init, f, comparator[1]);
    return caml_call1(Base_Import[125], _ao_);
   }
   function of_sequence_reduce$0(comparator, seq, f){
    var _an_ = of_sequence_reduce(seq, f, comparator[1]);
    return caml_call1(Base_Import[125], _an_);
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$2(comparator, t, key, data){
    var _am_ = set(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[125], _am_);
   }
   function add_exn$1(comparator, t, key, data){
    var _al_ = add_exn(t, 0, key, data, comparator[1], comparator[2]);
    return caml_call1(Base_Import[125], _al_);
   }
   function add$0(comparator, t, key, data){
    try{
     var _aj_ = [0, 17724, add_exn$1(comparator, t, key, data)];
     return _aj_;
    }
    catch(_ak_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    var _ai_ = add_multi(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[125], _ai_);
   }
   function remove_multi$1(comparator, t, key){
    var _ah_ = remove_multi(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[125], _ah_);
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    var _ag_ = change(t, key, f, 0, comparator[1]);
    return caml_call1(Base_Import[125], _ag_);
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    var _af_ = remove(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[125], _af_);
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(comparator, t, f){
    var _ae_ = filter_keys(t, f, comparator[1]);
    return caml_call1(Base_Import[125], _ae_);
   }
   function filter$1(comparator, t, f){
    var _ad_ = filter(t, f, comparator[1]);
    return caml_call1(Base_Import[125], _ad_);
   }
   function filteri$1(comparator, t, f){
    var _ac_ = filteri(t, f, comparator[1]);
    return caml_call1(Base_Import[125], _ac_);
   }
   function filter_map$1(comparator, t, f){
    var _ab_ = filter_map(t, f, comparator[1]);
    return caml_call1(Base_Import[125], _ab_);
   }
   function filter_mapi$1(comparator, t, f){
    var _aa_ = filter_mapi(t, f, comparator[1]);
    return caml_call1(Base_Import[125], _aa_);
   }
   function partition_mapi$1(comparator, t, f){
    var
     _$_ = partition_mapi(t, f, comparator[1]),
     b = _$_[2][1],
     a = _$_[1][1];
    return [0, a, b];
   }
   function partition_map$1(comparator, t, f){
    var
     ___ = partition_map(t, f, comparator[1]),
     b = ___[2][1],
     a = ___[1][1];
    return [0, a, b];
   }
   function partitioni_tf$1(comparator, t, f){
    var
     _Z_ = partitioni_tf(t, f, comparator[1]),
     b = _Z_[2][1],
     a = _Z_[1][1];
    return [0, a, b];
   }
   function partition_tf$1(comparator, t, f){
    var _Y_ = partition_tf(t, f, comparator[1]), b = _Y_[2][1], a = _Y_[1][1];
    return [0, a, b];
   }
   function combine_errors$1(comparator, t){
    var
     _W_ = Base_Import[125],
     _X_ = combine_errors(t, comparator[1], comparator[2]);
    return caml_call2(Base_Or_error[43], _X_, _W_);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    var _V_ = merge(t1, t2, f, comparator[1]);
    return caml_call1(Base_Import[125], _V_);
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var
     _S_ = comparator[1],
     _T_ = length$1(t2),
     _U_ = merge_skewed(t1, t2, length$1(t1), _T_, combine, _S_);
    return caml_call1(Base_Import[125], _U_);
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _R_ = nth$2(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _R_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    var _Q_ = t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator);
    return caml_call1(Base_Import[125], _Q_);
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    var _P_ = map_keys_exn(t, f, comparator);
    return caml_call1(Base_Import[125], _P_);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[30], _y_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, k, v){return [0, comparator, [0, k, v], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    function _N_(tree){return of_tree0(comparator, tree);}
    var _O_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _O_, _N_);
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    function _L_(tree){return of_tree0(comparator, tree);}
    var _M_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Result[30], _M_, _L_);
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    function _I_(_K_){return of_tree0(comparator, _K_);}
    var _J_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _J_, _I_);
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    function _G_(tree){return of_tree0(comparator, tree);}
    var _H_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Result[30], _H_, _G_);
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function of_tree$3(M){
    return function(tree){return of_tree$0(M[1], tree);};
   }
   function empty$2(m){return empty$1(m[1]);}
   function singleton$1(m, a){
    var _E_ = m[1];
    return function(_F_){return singleton$0(_E_, a, _F_);};
   }
   function of_alist$2(m, a){return of_alist$1(m[1], a);}
   function of_alist_or_error$2(m, a){return of_alist_or_error$1(m[1], a);}
   function of_alist_exn$2(m, a){return of_alist_exn$1(m[1], a);}
   function of_alist_multi$2(m, a){return of_alist_multi$1(m[1], a);}
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(m[1], a, init, f);
   }
   function of_alist_reduce$2(m, a, f){return of_alist_reduce$1(m[1], a, f);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_iteri$2(m, iteri){return of_iteri$1(m[1], iteri);}
   function of_iteri_exn$2(m, iteri){return of_iteri_exn$1(m[1], iteri);}
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(m[1], seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(m[1], s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(m[1], s);
   }
   function of_sequence_exn$2(m, s){return of_sequence_exn$1(m[1], s);}
   function of_sequence_multi$2(m, s){return of_sequence_multi$1(m[1], s);}
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(m[1], s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(m[1], s, f);
   }
   function map_keys$2(m, t, f){return map_keys$1(m[1], t, f);}
   function map_keys_exn$2(m, t, f){return map_keys_exn$1(m[1], t, f);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){
     function _D_(param){return _z_;}
     return sexp_of_t$2(K[1], sexp_of_v, _D_, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){
     return [2, [1, [2, [0, K[1], [0, v_grammar, 0]]]]];};
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K){
    return function(hash_fold_v, state){
     var _B_ = K[1];
     return function(_C_){
      return hash_fold_direct(_B_, hash_fold_v, state, _C_);};};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_A_){return singleton$0(comparator$0, a, _A_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$0,
       length$0,
       set$1,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       split$0,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$2,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$1,
         iter2$1,
         map$1,
         mapi$1,
         fold$4,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         split$1,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){return caml_call2(Stdlib_Queue[15], f, t);}
   function fold(t, init, f){return caml_call3(Stdlib_Queue[16], f, init, t);}
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var
    peek_exn = Base_Linked_queue0[6],
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       function _o_(b){return enqueue(res, b);}
       var _p_ = caml_call1(f, a);
       return caml_call2(Base_List[9], _p_, _o_);
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       function _m_(b){return enqueue(res, b);}
       var _n_ = caml_call2(f, i, a);
       return caml_call2(Base_List[9], _n_, _m_);
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _l_ = caml_call1(f, a);
       return _l_ ? enqueue(res, a) : _l_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _k_ = caml_call2(f, i, a);
       return _k_ ? enqueue(res, a) : _k_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    function _j_(x){return enqueue(t, x);}
    return caml_call2(Base_List[9], list, _j_);
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    function _i_(x){return enqueue(t, x);}
    caml_call2(Base_List[9], list, _i_);
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    function _h_(x){return enqueue(t, x);}
    caml_call2(Base_Array[9], array, _h_);
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[93], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      var i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[25], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       return caml_call1(Base_Import[130], i);
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[176], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[152], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[204],
    func = Base_Import[218],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input",
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int64.ml", 100, 2],
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_C_, _B_){return caml_int64_compare(_C_, _B_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[25], 64),
    float_upper_bound = caml_call1(Base_Float0[23], 64),
    float_of_bits = runtime.caml_int64_float_of_bits,
    bits_of_float = runtime.caml_int64_bits_of_float,
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    pow = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    num_bits = 64;
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return caml_int64_of_float(f);
    var _A_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _A_, 0);
   }
   function symbol(b, e){return caml_call2(pow, b, e);}
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5];
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _y_ = caml_lessequal(low, t),
     _z_ = _y_ ? caml_lessequal(t, high) : _y_;
    return _z_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _v_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _w_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _v_],
     _x_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _w_);
    return caml_call1(Base_Or_error[35], _x_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_u_){return _u_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[11],
    to_int_exn = Base_Int_conversions[12],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[14],
    to_int32_exn = Base_Int_conversions[15],
    of_nativeint = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[17],
    to_nativeint_exn = Base_Int_conversions[18],
    raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 2)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 4)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 8)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 16)),
     x$6 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 32));
    return caml_call1(Stdlib_Int64[6], x$6);
   }
   function floor_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 1)),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 2)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 4)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 8)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 32));
    return caml_int64_sub(x$5, caml_int64_shift_right_unsigne(x$5, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _t_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _t_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _q_ = [0, [0, cst, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_floor_log2_got_inval, _q_));
    }
    var
     _r_ = runtime.Base_int_math_int64_clz(i),
     _s_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _s_, _r_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _o_ = [0, [0, cst$0, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_ceil_log2_got_invali, _o_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _p_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[93], num_bits, _p_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare$0 = Base_Import[231],
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218];
   function hash$0(x){return caml_call1(func$0, x);}
   var symbol$0 = caml_lessthan;
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _m_(_n_){return _n_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _m_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$3[1],
    symbol$2 = include$3[2],
    symbol$3 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[103],
    ascending = include$4[1],
    descending = include$4[2],
    max = include$4[3],
    min = include$4[4],
    _f_ = [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3];
   function _g_(_l_){return runtime.Base_int_math_int64_ctz(_l_);}
   function _h_(_k_){return runtime.Base_int_math_int64_clz(_k_);}
   var
    Base_Int64 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_j_, _i_){return caml_int64_compare(_j_, _i_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _h_,
       _g_,
       _f_,
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       of_nativeint,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(29, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Import[231],
    hash_fold_t = Base_Import[204],
    sexp_of_t = Base_Import[145],
    t_sexp_grammar = Base_Import[189],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    cst_0x = "0x",
    _l_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _k_ = [0, cst_src_int63_emul_ml, 317, 2],
    _i_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"],
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _e_ = [0, cst_src_int63_emul_ml, 114, 20],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[20], x);
    return caml_int64_mul(x, _a_);
   }
   function wrap_modulo(x){return caml_int64_mul(x, _c_);}
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function m(x){return caml_int64_and(x, mask);}
   function invariant(t){
    if(caml_equal(m(t), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(_f_);
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var min_value = m(Stdlib_Int64[10]), max_value = m(Stdlib_Int64[9]);
   function bit_not(x){return m(caml_call1(Stdlib_Int64[11], x));}
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){return m(caml_int64_shift_right(x, i));}
   function shift_right_logical(x, i){
    return m(caml_int64_shift_right_unsigne(x, i));
   }
   var f = Base_Int_math[2][3];
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){return wrap_modulo(runtime.caml_int64_div(a, b));}
   var rem = runtime.caml_int64_mod;
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[21], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return wrap_modulo(t);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[169], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[145], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare, x, y);}
   function is_pow2(x){
    return caml_call1(Base_Int64[67], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[68], x);}
   function ctz(x){
    return caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[65], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Stdlib_MoreLabels[1][28], x);}
   var hashable = [0, hash, compare$0, sexp_of_t$0];
   function invalid_str(x){return caml_call3(Base_Printf[6], _g_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string(str){
    try{
     var len = caml_ml_string_length(str);
     a:
     if(0 < len){
      var switcher = caml_string_get(str, 0) - 43 | 0;
      if(2 >= switcher >>> 0)
       switch(switcher){
         case 0:
          var sign = 4003188, pos = 1; break a;
         case 1: break;
         default: var sign = 3901488, pos = 1; break a;
       }
      var sign = 4003188, pos = 0;
     }
     else
      var sign = 4003188, pos = 0;
     if(caml_call2(Base_Import[91], pos, 2) < len)
      var
       c1 = caml_string_get(str, pos),
       c2 = caml_string_get(str, caml_call2(Base_Import[91], pos, 1)),
       match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
     else
      var match = [0, , 1];
     var signedness = match[2];
     if(signedness)
      var _w_ = of_int64_exn(caml_int64_of_string(str));
     else{
      if(4003188 <= sign)
       var pos_str = str;
      else
       var
        _x_ = caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
        pos_str = caml_call3(Base_String[2], str, 1, _x_);
      var int64 = caml_int64_of_string(pos_str);
      if(caml_lessthan(int64, _h_)) invalid_str(str);
      var
       int63 = wrap_modulo(int64),
       int63$0 = 4003188 <= sign ? int63 : caml_int64_neg(int63),
       _w_ = int63$0;
     }
     return _w_;
    }
    catch(_y_){return invalid_str(str);}
   }
   function bswap16(t){
    return wrap_modulo
            (caml_call1(Base_Int64[84], caml_int64_shift_right(t, 1)));
   }
   function bswap32(t){
    return wrap_modulo
            (caml_call1(Base_Int64[85], caml_int64_shift_right(t, 1)));
   }
   function bswap48(t){
    return wrap_modulo
            (caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1)));
   }
   var
    float_lower_bound = caml_call1(Base_Float0[25], 63),
    float_upper_bound = caml_call1(Base_Float0[23], 63),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    num_bits = 63;
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){return wrap_modulo(caml_int64_of_float(x));}
   function of_float(t){
    if
     (caml_call2(Base_Import[108][6], t, float_lower_bound)
      && caml_call2(Base_Import[108][2], t, float_upper_bound))
     return wrap_modulo(caml_int64_of_float(t));
    var _v_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _i_, _v_, 0);
   }
   var
    _j_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _j_[1],
    is_non_negative = _j_[2],
    is_negative = _j_[3],
    is_non_positive = _j_[4],
    sign = _j_[5];
   function between(t, low, high){
    var
     _t_ = caml_lessequal(low, t),
     _u_ = _t_ ? caml_lessequal(t, high) : _t_;
    return _u_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _q_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _r_ = [0, [0, cst_min, sexp_of_t$0(min)], _q_],
     _s_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _r_);
    return caml_call1(Base_Or_error[35], _s_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){r[1] = caml_int64_add(r[1], one$0); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[11], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_trunc(x){
    return of_int64_trunc(caml_call1(Base_Int_conversions[28], x));
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   var
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$1 = include$0[2];
   function hash$0(x){return hash(x);}
   var symbol$5 = caml_lessthan;
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _l_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[112], cst_0x, s));
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$1[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$2 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    round = include$2[4],
    round_towards_zero = include$2[5],
    round_down = include$2[6],
    round_up = include$2[7],
    round_nearest = include$2[8],
    Repr = [0],
    include$3 = Base_Import[103],
    ascending = include$3[1],
    descending = include$3[2],
    max = include$3[3],
    min = include$3[4],
    repr = 1,
    _m_ = [0, wrap_exn, unwrap],
    _n_ =
      [0,
       symbol,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol$1,
       symbol$4,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$1,
       zero,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical],
    Base_Int63_emul =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_p_, _o_){return runtime.caml_int64_compare(_p_, _o_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       _n_,
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       _m_,
       Repr,
       repr];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, cst_src_bool_ml, 56, 2],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"],
    _c_ = [0, cst_src_bool_ml, 83, 9];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t];
   function of_string(s){
    return caml_string_notequal(s, "false")
            ? caml_string_notequal
               (s, "true")
              ? caml_call3(invalid_argf, _a_, s, 0)
              : 1
            : 0;
   }
   var
    to_string = Base_Import[85][29],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[105][2], low, t);
    return _k_ ? caml_call2(Base_Import[105][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[105][1], t, min)
            ? min
            : caml_call2(Base_Import[105][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[105][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[105][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[86], x);}
   function symbol(a, b){
    var _f_ = to_int(b), _g_ = to_int(a);
    return caml_call2(Base_Import[118], _g_, _f_);
   }
   function symbol$0(a, b){
    var _d_ = to_int(b), _e_ = to_int(a);
    return caml_call2(Base_Import[116], _e_, _d_);
   }
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[105],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     equal = include$1[10],
     max = include$1[11],
     min = include$1[12],
     Base_Bool =
       [0,
        all,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[205],
    func = Base_Import[219],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input",
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int32.ml", 97, 4],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    include = caml_call1(Base_Comparator[5], [0, ascending, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[25], 32),
    float_upper_bound = caml_call1(Base_Float0[23], 32),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float,
    num_bits = 32;
   function shift_right_logical(_S_, _R_){return _S_ >>> _R_ | 0;}
   function shift_right(_Q_, _P_){return _Q_ >> _P_;}
   function shift_left(_O_, _N_){return _O_ << _N_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_M_, _L_){return _M_ ^ _L_;}
   function bit_or(_K_, _J_){return _K_ | _J_;}
   function bit_and(_I_, _H_){return _I_ & _H_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_G_){return - _G_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1];
   function to_float(_F_){return _F_;}
   function of_float_unchecked(_E_){return _E_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[108][6], f, float_lower_bound)
      && caml_call2(Base_Import[108][2], f, float_upper_bound))
     return f | 0;
    var _D_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _D_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = runtime.caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = caml_lessthan,
    symbol$5 = runtime.caml_notequal;
   function descending(x, y){return ascending(y, x);}
   function min(x, y){return caml_lessthan(x, y) ? x : y;}
   function max(x, y){return caml_greaterthan(x, y) ? x : y;}
   var equal = caml_equal;
   function between(t, low, high){
    var _C_ = caml_lessequal(low, t);
    return _C_ ? caml_lessequal(t, high) : _C_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _z_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _A_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _z_],
     _B_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _A_);
    return caml_call1(Base_Or_error[35], _B_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_y_, _x_){return _y_ - _x_ | 0;}
   function symbol$9(_w_, _v_){return _w_ + _v_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[14],
    of_int64_exn = Base_Int_conversions[15],
    of_int64_trunc = Base_Int_conversions[16],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[25],
    of_nativeint_exn = Base_Int_conversions[26],
    of_nativeint_trunc = Base_Int_conversions[27],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _t_ = caml_call1(to_int_exn, e), _u_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _u_, _t_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$5);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0;
    return x$4 - (x$4 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _r_ = Stdlib_Int32[1], _s_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[102][4], _s_, _r_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _o_ = [0, [0, cst, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_floor_log2_got_inval, _o_));
    }
    var
     _p_ = runtime.Base_int_math_int32_clz(i),
     _q_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _q_, _p_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _m_ = [0, [0, cst$0, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_ceil_log2_got_invali, _m_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _n_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[93], num_bits, _n_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare = Base_Import[230],
    hash_fold_t$0 = Base_Import[205],
    func$0 = Base_Import[219];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _k_(_l_){return _l_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _k_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$3[1],
    symbol$12 = include$3[2],
    symbol$13 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    _f_ = caml_int32_bswap,
    _g_ =
      [0,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       symbol,
       symbol$10,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       abs,
       symbol,
       zero,
       symbol$11,
       symbol$12,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _h_(_j_){return runtime.Base_int_math_int32_ctz(_j_);}
   var
    Base_Int32 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_int32_clz(_i_);},
       _h_,
       _g_,
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       _f_];
   runtime.caml_register_global(29, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Assert_failure, Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[30],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _b_ = [0, "src/int63.ml", 155, 9],
    repr = Base_Word_size[3] ? 0 : 1,
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$0 = Base_Int[75],
    symbol$1 = Base_Int[76],
    symbol$2 = Base_Int[77],
    of_int = Base_Int[79],
    to_int32 = Base_Int[82],
    of_int64 = Base_Int[83],
    of_nativeint = Base_Int[84],
    _a_ = Base_Int[85];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_a_, x);}
   function to_nativeint(x){return [0, caml_call1(_a_, x)];}
   var repr$0 = 0;
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[85], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[86], caml_int64_of_int32(t)));
   }
   if(repr)
    var
     include =
       [0,
        Base_Int63_emul[1],
        Base_Int63_emul[2],
        Base_Int63_emul[3],
        Base_Int63_emul[4],
        Base_Int63_emul[5],
        Base_Int63_emul[6],
        Base_Int63_emul[7],
        Base_Int63_emul[8],
        Base_Int63_emul[9],
        Base_Int63_emul[10],
        Base_Int63_emul[11],
        Base_Int63_emul[12],
        Base_Int63_emul[13],
        Base_Int63_emul[14],
        Base_Int63_emul[15],
        Base_Int63_emul[16],
        Base_Int63_emul[17],
        Base_Int63_emul[18],
        Base_Int63_emul[19],
        Base_Int63_emul[20],
        Base_Int63_emul[21],
        Base_Int63_emul[22],
        Base_Int63_emul[23],
        Base_Int63_emul[24],
        Base_Int63_emul[25],
        Base_Int63_emul[26],
        Base_Int63_emul[27],
        Base_Int63_emul[28],
        Base_Int63_emul[29],
        Base_Int63_emul[30],
        Base_Int63_emul[31],
        Base_Int63_emul[32],
        Base_Int63_emul[33],
        Base_Int63_emul[34],
        Base_Int63_emul[35],
        Base_Int63_emul[36],
        Base_Int63_emul[37],
        Base_Int63_emul[38],
        Base_Int63_emul[39],
        Base_Int63_emul[40],
        Base_Int63_emul[41],
        Base_Int63_emul[42],
        Base_Int63_emul[43],
        Base_Int63_emul[44],
        Base_Int63_emul[45],
        Base_Int63_emul[46],
        Base_Int63_emul[47],
        Base_Int63_emul[48],
        Base_Int63_emul[49],
        Base_Int63_emul[50],
        Base_Int63_emul[51],
        Base_Int63_emul[52],
        Base_Int63_emul[53],
        Base_Int63_emul[54],
        Base_Int63_emul[55],
        Base_Int63_emul[56],
        Base_Int63_emul[57],
        Base_Int63_emul[58],
        Base_Int63_emul[59],
        Base_Int63_emul[60],
        Base_Int63_emul[61],
        Base_Int63_emul[62],
        Base_Int63_emul[63],
        Base_Int63_emul[64],
        Base_Int63_emul[65],
        Base_Int63_emul[66],
        Base_Int63_emul[67],
        Base_Int63_emul[68],
        Base_Int63_emul[69],
        Base_Int63_emul[70],
        Base_Int63_emul[71],
        Base_Int63_emul[72],
        Base_Int63_emul[73],
        Base_Int63_emul[74],
        Base_Int63_emul[75],
        Base_Int63_emul[76],
        Base_Int63_emul[77],
        Base_Int63_emul[78],
        Base_Int63_emul[79],
        Base_Int63_emul[80],
        Base_Int63_emul[81],
        Base_Int63_emul[83],
        Base_Int63_emul[84],
        Base_Int63_emul[85],
        Base_Int63_emul[86],
        Base_Int63_emul[87],
        Base_Int63_emul[88],
        Base_Int63_emul[89],
        Base_Int63_emul[90],
        ,
        Base_Int63_emul[92],
        Base_Int63_emul[93],
        Base_Int63_emul[94],
        Base_Int63_emul[95],
        Base_Int63_emul[96],
        Base_Int63_emul[97],
        Base_Int63_emul[98],
        Base_Int63_emul[99],
        Base_Int63_emul[100],
        Base_Int63_emul[101],
        Base_Int63_emul[102],
        Base_Int63_emul[103],
        Base_Int63_emul[104],
        Base_Int63_emul[105],
        Base_Int63_emul[106],
        Base_Int63_emul[107],
        Base_Int63_emul[82],
        Base_Int63_emul[113],
        Base_Int63_emul[108],
        Base_Int63_emul[109],
        Base_Int63_emul[110]];
   else
    var
     _c_ = runtime.caml_bswap16,
     _d_ = function(_bo_){return _bo_;},
     _e_ = caml_int64_to_int32,
     _f_ = function(_bn_){return _bn_;},
     _g_ = function(_bm_, _bl_){return _bm_ >>> _bl_ | 0;},
     _h_ = function(_bk_, _bj_){return _bk_ >> _bj_;},
     _i_ = function(_bi_, _bh_){return _bi_ << _bh_;},
     _j_ = O[2],
     _k_ = function(_bg_, _bf_){return _bg_ ^ _bf_;},
     _l_ = function(_be_, _bd_){return _be_ | _bd_;},
     _m_ = function(_bc_, _bb_){return _bc_ & _bb_;},
     _n_ = O[7],
     _o_ = O[6],
     _p_ = O[5],
     _q_ = O[4],
     _r_ = function(_ba_){return - _ba_ | 0;},
     _s_ = O[3],
     _t_ = function(_a$_, _a__){return _a$_ !== _a__ ? 1 : 0;},
     _u_ = function(_a9_, _a8_){return _a9_ < _a8_ ? 1 : 0;},
     _v_ = function(_a7_, _a6_){return _a6_ < _a7_ ? 1 : 0;},
     _w_ = function(_a5_, _a4_){return _a5_ === _a4_ ? 1 : 0;},
     _x_ = function(_a3_, _a2_){return _a3_ <= _a2_ ? 1 : 0;},
     _y_ = function(_a1_, _a0_){return _a0_ <= _a1_ ? 1 : 0;},
     _z_ = O[1],
     _A_ = function(_aZ_){return - _aZ_ | 0;},
     _B_ = caml_div,
     _C_ = caml_mul,
     _D_ = function(_aY_, _aX_){return _aY_ - _aX_ | 0;},
     _E_ =
       [0,
        function(_aW_, _aV_){return _aW_ + _aV_ | 0;},
        _D_,
        _C_,
        _B_,
        _A_,
        _z_,
        _y_,
        _x_,
        _w_,
        _v_,
        _u_,
        _t_,
        _s_,
        _r_,
        _q_,
        _p_,
        _o_,
        _n_,
        _m_,
        _l_,
        _k_,
        _j_,
        _i_,
        _h_,
        _g_],
     _F_ = function(_aU_, _aT_){return _aU_ >>> _aT_ | 0;},
     _G_ = function(_aS_, _aR_){return _aS_ >> _aR_;},
     _H_ = function(_aQ_, _aP_){return _aQ_ << _aP_;},
     _I_ = function(_aO_, _aN_){return _aO_ ^ _aN_;},
     _J_ = function(_aM_, _aL_){return _aM_ | _aL_;},
     _K_ = function(_aK_, _aJ_){return _aK_ & _aJ_;},
     _L_ = caml_div,
     _M_ = function(_aI_){return - _aI_ | 0;},
     _N_ = function(_aH_){return - _aH_ | 0;},
     _O_ = caml_mul,
     _P_ = function(_aG_, _aF_){return _aG_ - _aF_ | 0;},
     _Q_ = function(_aE_, _aD_){return _aE_ + _aD_ | 0;},
     _R_ = function(_aC_, _aB_){return _aC_ !== _aB_ ? 1 : 0;},
     _S_ = function(_aA_, _az_){return _aA_ < _az_ ? 1 : 0;},
     _T_ = function(_ay_, _ax_){return _ax_ < _ay_ ? 1 : 0;},
     _U_ = function(_aw_, _av_){return _aw_ === _av_ ? 1 : 0;},
     _V_ = function(_au_, _at_){return _au_ <= _at_ ? 1 : 0;},
     include =
       [0,
        t_sexp_grammar,
        of_float,
        to_float,
        of_int_exn,
        to_int_exn,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        function(_as_, _ar_){return _ar_ <= _as_ ? 1 : 0;},
        _V_,
        _U_,
        _T_,
        _S_,
        _R_,
        equal,
        compare,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        invariant,
        Hex,
        to_string_hum,
        zero,
        one,
        minus_one,
        _Q_,
        _P_,
        _O_,
        symbol,
        _N_,
        _M_,
        symbol$1,
        symbol$0,
        _L_,
        rem,
        symbol$2,
        _K_,
        _J_,
        _I_,
        lnot,
        _H_,
        _G_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs,
        succ,
        pred,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount,
        shift_left,
        shift_right,
        decr,
        incr,
        of_int32_exn,
        to_int32_exn,
        of_int64_exn,
        to_int64,
        of_nativeint_exn,
        to_nativeint_exn,
        num_bits,
        max_value,
        min_value,
        _F_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        ,
        is_pow2,
        clz,
        ctz,
        _E_,
        of_int,
        to_int,
        to_int_trunc,
        of_int32_exn,
        to_int32,
        _f_,
        of_int64,
        _e_,
        of_nativeint,
        to_nativeint,
        _d_,
        to_nativeint_trunc,
        of_float_unchecked,
        repr$0,
        _c_,
        bswap32,
        bswap48];
   var
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    invariant$0 = include[35],
    Hex$0 = include[36],
    to_string_hum$0 = include[37],
    zero$0 = include[38],
    one$0 = include[39],
    minus_one$0 = include[40],
    symbol$9 = include[41],
    symbol$10 = include[42],
    symbol$11 = include[43],
    symbol$12 = include[44],
    neg = include[45],
    symbol$13 = include[46],
    symbol$14 = include[47],
    symbol$15 = include[48],
    symbol$16 = include[49],
    rem$0 = include[50],
    symbol$17 = include[51],
    land = include[52],
    lor = include[53],
    lxor = include[54],
    lnot$0 = include[55],
    lsl = include[56],
    asr = include[57],
    round$0 = include[58],
    round_towards_zero$0 = include[59],
    round_down$0 = include[60],
    round_up$0 = include[61],
    round_nearest$0 = include[62],
    abs$0 = include[63],
    succ$0 = include[64],
    pred$0 = include[65],
    pow$0 = include[66],
    bit_and$0 = include[67],
    bit_or$0 = include[68],
    bit_xor$0 = include[69],
    bit_not$0 = include[70],
    popcount$0 = include[71],
    shift_left$0 = include[72],
    shift_right$0 = include[73],
    decr$0 = include[74],
    incr$0 = include[75],
    of_int32_exn$0 = include[76],
    to_int32_exn$0 = include[77],
    of_int64_exn$0 = include[78],
    to_int64$0 = include[79],
    of_nativeint_exn$0 = include[80],
    to_nativeint_exn$0 = include[81],
    num_bits$0 = include[82],
    max_value$0 = include[83],
    min_value$0 = include[84],
    lsr = include[85],
    shift_right_logical$0 = include[86],
    ceil_pow2$0 = include[87],
    floor_pow2$0 = include[88],
    ceil_log2$0 = include[89],
    is_pow2$0 = include[91],
    clz$0 = include[92],
    ctz$0 = include[93],
    O$0 = include[94],
    of_int$0 = include[95],
    to_int$0 = include[96],
    to_int_trunc$0 = include[97],
    of_int32 = include[98],
    to_int32$0 = include[99],
    to_int32_trunc = include[100],
    of_int64$0 = include[101],
    of_int64_trunc = include[102],
    of_nativeint$0 = include[103],
    to_nativeint$0 = include[104],
    of_nativeint_trunc = include[105],
    to_nativeint_trunc$0 = include[106],
    of_float_unchecked$0 = include[107],
    repr$1 = include[108],
    bswap16 = include[109],
    bswap32$0 = include[110],
    bswap48$0 = include[111];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _an_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _an_),
        zero$0))
     return sum;
    var
     _ao_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _ap_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _ao_],
     _aq_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _ap_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow, _aq_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _aj_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[14], pos_diff, _aj_)){
      var
       _ak_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _al_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _ak_],
       _am_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _al_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$0, _am_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _ai_ = caml_call2(symbol$5, t, min_value$0);
    return _ai_ ? caml_call2(symbol$5, u, negative_one) : _ai_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _af_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _ag_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _af_],
      _ah_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _ag_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_overflow$1, _ah_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _ac_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _ad_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _ac_],
     _ae_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _ad_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$2, _ae_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _ab_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[18][6], state, _ab_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _aa_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[18][9], state, _aa_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var
     ___ = caml_call1(to_int_exn$0, hi),
     _$_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[18][11], state, _$_, ___));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _Y_ = caml_call1(to_int64$0, hi), _Z_ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[18][14], state, _Z_, _Y_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _W_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[66], _W_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _X_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _X_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$0,
       Hex$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[112], repr$1]];
   runtime.caml_register_global(31, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Merge_into_action = [0],
    Base_Hashtbl_intf = [0, Key, Merge_into_action];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Assert_failure, Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl",
    _l_ = [0, cst_src_avltree_ml, 417, 15],
    _m_ = [0, cst_src_avltree_ml, 436, 18],
    _k_ = [0, cst_src_avltree_ml, 205, 9],
    _j_ = [0, cst_src_avltree_ml, 193, 9],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _a_ = [0, cst_src_avltree_ml, 50, 6];
   function max(x, y){return y < x ? x : y;}
   var empty = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _B_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[91], _B_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _C_ = caml_call2(Base_Import[93], hl, hr);
      if(2 < caml_call1(Base_Import[123], _C_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _z_ = height(right),
      _A_ = max(height(left), _z_),
      new_height = caml_call2(Base_Import[91], _A_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[91], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _x_ = height(left_node_right);
       if(_x_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[91], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _y_ = height(right_node_left);
      if(_y_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function set_left(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var left = node[1];
     if(! caml_call2(Base_Import[128], left, tree$0)) node[1] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function set_right(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var right = node[5];
     if(! caml_call2(Base_Import[128], right, tree$0)) node[5] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function add(t, replace, added, compare, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     added[1] = 0;
     if(replace) t[3] = v;
    }
    else if(0 <= c)
     set_right(t, add(right, replace, added, compare, k, v));
    else
     set_left(t, add(left, replace, added, compare, k, v));
    return t;
   }
   function add$0(t, replace, compare, added, key, data){
    var t$0 = add(t, replace, added, compare, key, data);
    return added[1] ? balance(t$0) : t$0;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){var t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _v_ = t$0[2], _w_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5], t$0 = r; continue;}
      var v = _w_, k = _v_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left, t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _u_, _t_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _s_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _r_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _q_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _p_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 === left[0]){set_left(tree, remove_min_elt(left)); return tree;}
    var k = tree[2], v = tree[3];
    return typeof tree[5] === "number" ? [1, k, v] : (set_left(tree, 0), tree);
   }
   function remove(t, removed, compare, k$0){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$2 = t[1];
     return 0 === caml_call2(compare, k$0, k$2)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left$0 = t[1],
     k$1 = t[2],
     right = t[5],
     c = caml_call2(compare, k$0, k$1);
    if(0 !== c)
     return 0 <= c
             ? (set_right(t, remove(right, removed, compare, k$0)), t)
             : (set_left(t, remove(left$0, removed, compare, k$0)), t);
    removed[1] = 1;
    if(typeof left$0 === "number") return right;
    if(typeof right === "number") return left$0;
    var tree = right;
    for(;;){
     if(typeof tree === "number")
      var tree$0 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){var tree = left; continue;}
      var tree$0 = tree;
     }
     else
      var tree$0 = tree;
     if(typeof tree$0 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     if(0 === tree$0[0]){
      set_right(tree$0, remove_min_elt(right));
      set_left(tree$0, left$0);
      return tree$0;
     }
     var
      k = tree$0[1],
      v = tree$0[2],
      t2 = balance(remove_min_elt(right)),
      _n_ = height(t2),
      _o_ = max(height(left$0), _n_);
     return [0, left$0, k, v, caml_call2(Base_Import[91], _o_, 1), t2];
    }
   }
   function remove$0(t, removed, compare, k){
    return balance(remove(t, removed, compare, k));
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0)),
        t$0 = right$0,
        init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f)),
      t$0 = right,
      init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     var t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     var t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       empty,
       is_empty,
       invariant,
       add$0,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove$0,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(18, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[30],
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values",
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 575, 4],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    _b_ = [0, "Hashtbl.find_exn: not found"],
    _a_ = [0, cst_src_hashtbl_ml, 323, 2],
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[5][3];}
   function compare_key(t){return t[5][2];}
   function ensure_mutation_allowed(t){
    var _aO_ = 1 - t[6];
    return _aO_
            ? caml_call1(Base_Import[124], cst_Hashtbl_mutation_not_allow)
            : _aO_;
   }
   function without_mutating(t, f){
    if(! t[6]) return caml_call1(f, 0);
    t[6] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = 1;
    return x;
   }
   var max_table_length = caml_call1(Base_Int[64], Base_Array[24]);
   function create(opt, _aM_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aM_) var sth$0 = _aM_[1], size = sth$0; else var size = 0;
    var
     _aN_ = caml_call2(Base_Int[15], 1, size),
     size$0 = caml_call2(Base_Int[14], _aN_, max_table_length),
     size$1 = caml_call1(Base_Int[63], size$0);
    return [0,
            caml_call2(Base_Array[25], size$1, Base_Avltree[1]),
            0,
            [0, 0],
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[5][1], key),
     _aL_ = caml_call2(Base_Import[93], t[1].length - 1, 1);
    return caml_call2(Base_Import[116], hash, _aL_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = t[3];
    added[1] = 0;
    var
     _aI_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aI_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[91], t[2], 1);
    var
     _aJ_ = 1 - caml_call2(Base_Import[128], new_root, root),
     _aK_ = _aJ_ ? (caml_check_bound(t[1], i)[1 + i] = new_root, 0) : _aJ_;
    return _aK_;
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _az_ = should_grow ? t[4] : should_grow;
    if(_az_){
     var
      _aA_ = caml_call2(Base_Import[88], len, 2),
      new_array_length = caml_call2(Base_Int[14], _aA_, max_table_length),
      _aB_ = len < new_array_length ? 1 : 0;
     if(_aB_){
      var
       new_table =
         caml_call2(Base_Array[25], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){return add_worker(t, 1, key, data);},
       _aD_ = caml_call2(Base_Import[93], old_table.length - 1, 1),
       _aC_ = 0;
      if(_aD_ >= 0){
       var i = _aC_;
       for(;;){
        var _aG_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _aG_, f);
        var _aH_ = i + 1 | 0;
        if(_aD_ === i) break;
        var i = _aH_;
       }
      }
      var _aE_ = 0;
     }
     else
      var _aE_ = _aB_;
     var _aF_ = _aE_;
    }
    else
     var _aF_ = _az_;
    return _aF_;
   }
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 0, key, data);
    return t[3][1] ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[29], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _aw_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _av_ = 0;
    if(_aw_ >= 0){
     var i = _av_;
     for(;;){
      var _ax_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _ax_;
      var _ay_ = i + 1 | 0;
      if(_aw_ === i) break;
      var i = _ay_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _at_ = slot(t, key), tree = caml_check_bound(t[1], _at_)[1 + _at_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _au_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _au_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _ar_ = slot(t, key), tree = caml_check_bound(t[1], _ar_)[1 + _ar_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _as_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _as_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ap_ = slot(t, key), tree = caml_check_bound(t[1], _ap_)[1 + _ap_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _aq_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _aq_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _an_ = slot(t, key), tree = caml_check_bound(t[1], _an_)[1 + _an_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ao_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ao_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _al_ = slot(t, key), tree = caml_check_bound(t[1], _al_)[1 + _al_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _am_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _am_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _aj_ = slot(t, key), tree = caml_check_bound(t[1], _aj_)[1 + _aj_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ak_ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, _ak_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _ai_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added_or_removed = t[3];
    added_or_removed[1] = 0;
    var
     _ae_ = compare_key(t),
     new_root =
       caml_call4(Base_Avltree[15], root, added_or_removed, _ae_, key);
    if(1 - caml_call2(Base_Import[128], root, new_root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _af_ = added_or_removed[1],
     _ag_ = _af_ ? (t[2] = caml_call2(Base_Import[93], t[2], 1), 0) : _af_;
    return _ag_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[6];
    try{
     t[6] = 0;
     var _ac_ = caml_call2(Base_Import[93], n, 1), _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _ad_ = i + 1 | 0;
       if(_ac_ === i) break;
       var i = _ad_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[6];
    try{
     t[6] = 0;
     var _$_ = caml_call2(Base_Import[93], n, 1), ___ = 0;
     if(_$_ >= 0){
      var i = ___;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _aa_ = i + 1 | 0;
       if(_$_ === i) break;
       var i = _aa_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = caml_check_bound(table, i$0)[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var i$1 = caml_call2(Base_Import[91], i$0, 1), i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function invariant(invariant_key, invariant_data, t){
    var _W_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      var _X_ = compare_key(t), _Y_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _Y_, _X_);
      var _Z_ = i + 1 | 0;
      if(_W_ === i) break;
      var i = _Z_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[91], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _U_ = [1, [0, _b_, [0, caml_call1(t[5][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[252], _U_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _T_ = caml_call2(f, key, data);
                 return _T_ ? caml_call1(r, 1) : _T_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_S_){return _S_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[4]], [0, t[2]], t[5], 0),
     t1 = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    function _Q_(key, t, default$0){
     var default$1 = caml_call1(default$0, 0);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _R_){return data;},
             _Q_);
   }
   function findi_or_add(t, id, default$0){
    function _O_(key, t, default$0){
     var default$1 = caml_call1(default$0, key);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _P_){return data;},
             _O_);
   }
   function find_and_remove(t, id){
    var result = find(t, id);
    if(caml_call1(Base_Option[50], result)) remove(t, id);
    return result;
   }
   function change(t, id, f){
    var match = caml_call1(f, find(t, id));
    if(! match) return remove(t, id);
    var data = match[1];
    return set(t, id, data);
   }
   function update_and_return(t, id, f){
    var data = caml_call1(f, find(t, id));
    set(t, id, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _N_ = caml_call2(Base_Option[27], opt, 0),
                 n = caml_call2(Base_Import[91], by, _N_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[91], by, i);
               });
   }
   function incr(opt, _M_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_M_)
     var sth$0 = _M_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _L_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_L_)
     var sth$0 = _L_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[113], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var _K_ = match[1];
    if(_K_ && _K_[2]){var tl = _K_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[7], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    function _J_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return mem(res, key)
             ? (dupes[1] = [0, key, dupes[1]], 0)
             : set(res, key, data);
    }
    caml_call2(Base_List[9], rows, _J_);
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[114], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[125],
         Base_Import[127],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[67], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[125],
             Base_Import[127],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[29], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[127], get_key = Base_Import[125];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[7], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    function _I_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return add_multi(res, key, data);
    }
    caml_call2(Base_List[9], rows, _I_);
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _D_ = to_alist(t),
     _E_ = Base_List[62],
     _F_ =
       caml_call2
        (_E_,
         _D_,
         function(param, _H_){
          var k2 = _H_[1], k1 = param[1];
          return caml_call2(t[5][2], k1, k2);
         }),
     _G_ = caml_call2(Base_Import[150], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[152], _G_), _F_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _t_ = caml_call2(Base_Import[174], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[176], _t_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[7], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _u_(_C_){return _C_;}
    function _v_(_B_){return _B_;}
    var
     _w_ = caml_call2(Base_Import[174], _v_, _u_),
     alist_sexps = caml_call2(Base_Import[176], _w_, sexp),
     found_first_k = [0, 0];
    function _x_(param, _y_){
     var
      k2_sexp = _y_[1],
      k2 = param[1],
      _z_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
     if(_z_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[159], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
      found_first_k[1] = 1;
      var _A_ = 0;
     }
     else
      var _A_ = _z_;
     return _A_;
    }
    caml_call3(Base_List[42], alist, alist_sexps, _x_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _s_ = caml_call2(Base_List[129][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _s_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    function _r_(row){
     var
      key = caml_call1(get_key, row),
      data = caml_call1(get_data, row),
      match = find(groups, key);
     if(match)
      var old = match[1], data$0 = caml_call2(combine, old, data);
     else
      var data$0 = data;
     return set(groups, key, data$0);
    }
    caml_call2(Base_List[9], rows, _r_);
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_q_){return _q_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _o_ =
        [0, [0, cst_keys, caml_call2(Base_Import[152], sexp_of_key, keys)], 0],
      _p_ = caml_call2(Base_Sexp[9], cst_Hashtbl_create_with_key_du, _o_);
     return caml_call1(Base_Or_error[35], _p_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _n_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[31], _n_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[5], t_right[5]))
     caml_call1(Base_Import[126], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[4]], [0, t_left[2]], t_left[5], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var match = find(t_right, key);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find(t_left, key)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data = find(dst, key),
               action =
                 without_mutating
                  (dst,
                   function(param){return caml_call3(f, key, data, dst_data);});
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data) return set(dst, key, data$0);
              var
               dst_data$0 = dst_data[1],
               _m_ = 1 - caml_call2(Base_Import[128], dst_data$0, data$0);
              return _m_ ? set(dst, key, data$0) : _m_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    function _l_(key){return remove(t, key);}
    return caml_call2(Base_List[9], to_remove, _l_);
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    function _k_(param){
     var result = param[2], key = param[1];
     if(! result) return remove(t, key);
     var data = result[1];
     return set(t, key, data);
    }
    return caml_call2(Base_List[9], map_results, _k_);
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              function _i_(_j_){return caml_call2(_h_, _j_, f);}
              return caml_call2(Base_Array[9], t[1], _i_);
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find(t, key);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[5];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[5]);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){return sexp_of_t(K[1], sexp_of_v, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     var _e_ = K[1];
     return t_of_sexp
             (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
              _e_,
              v_of_sexp,
              sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){return t_sexp_grammar(K[1], v_grammar);};
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(24, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[81],
    hashable = Base_Hashtbl[90][1],
    poly_hashable = Base_Hashtbl[84][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[30],
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element",
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set",
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[29], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              function _E_(elt){
               var o = caml_call1(f, elt);
               return o ? caml_call1(r, o) : 0;
              }
              caml_call2(Base_Hashtbl[19], t, _E_);
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[34], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[36], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[34], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _D_ = strict_add(t, k);
    return caml_call1(Base_Or_error[31], _D_);
   }
   var remove = Base_Hashtbl[31];
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _C_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[34], 0, 0, cst_element_not_in_set, k, _C_);
   }
   function strict_remove_exn(t, k){
    var _B_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[31], _B_);
   }
   function fold(t, init, f){
    function _A_(key, param, acc){return caml_call2(f, acc, key);}
    return caml_call3(Base_Hashtbl[18], t, init, _A_);
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _y_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_z_){return caml_call2(_y_, _z_, t);};
   }
   var to_list = Base_Hashtbl[64];
   function sexp_of_t(sexp_of_e, t){
    var
     _w_ = caml_call1(to_list, t),
     func = Base_List[62],
     _x_ = caml_call2(func, _w_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[152], sexp_of_e, _x_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[93], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[25], len, key);
              index[1] = caml_call2(Base_Import[93], index[1], 1);
              var _v_ = index[1];
              runtime.caml_check_bound(acc, _v_)[1 + _v_] = key;
              return acc;
             });
   }
   function exists(t, f){
    function _u_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[22], t, _u_);
   }
   function for_all(t, f){
    function _t_(key, param){return 1 - caml_call1(f, key);}
    return 1 - caml_call2(Base_Hashtbl[22], t, _t_);
   }
   function equal(t1, t2){
    function _r_(param, _s_){return 1;}
    return caml_call3(Base_Hashtbl[73], _r_, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    function _q_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[46], t, _q_);
   }
   function union(t1, t2){
    function _o_(param, _p_){return _c_;}
    return caml_call3(Base_Hashtbl[62], t1, t2, _o_);
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[30], t2, key);});
   }
   function inter(t1, t2){
    var _m_ = caml_call1(length, t2);
    if(_m_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    function _n_(key, param){
     return caml_call2(Base_Hashtbl[30], larger, key);
    }
    return caml_call2(Base_Hashtbl[46], smaller, _n_);
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    function _l_(x){return caml_call2(remove, t, x);}
    return caml_call2(Base_List[9], to_remove, _l_);
   }
   function of_hashtbl_keys(hashtbl){
    function _j_(_k_){return 0;}
    return caml_call2(Base_Hashtbl[40], hashtbl, _j_);
   }
   function to_hashtbl(t, f){
    function _i_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[41], t, _i_);
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[7], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    function _h_(k){return add(t, k);}
    caml_call2(Base_List[9], l, _h_);
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[159], cst_Hash_set_t_of_sexp_require, sexp);
    var list = sexp[1], t = create(0, [0, caml_call1(Base_List[7], list)], m);
    function _g_(sexp){
     var e = caml_call1(e_of_sexp, sexp);
     return 0 === strict_add(t, e)[0]
             ? 0
             : caml_call2
               (Base_Import[159], cst_Hash_set_t_of_sexp_got_a_d, sexp);
    }
    caml_call2(Base_List[9], list, _g_);
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){return sexp_of_t(Elt[1], t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){
     return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[195], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[90][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Assert_failure, Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_006 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    nan = Base_Float0[6],
    max_value = Base_Float0[7],
    neg_infinity = Base_Float0[8],
    max_finite_value = Base_Float0[9],
    epsilon_float = Base_Float0[10],
    classify_float = Base_Float0[11],
    abs_float = Base_Float0[12],
    is_integer = Base_Float0[13],
    symbol = Base_Float0[14],
    symbol$0 = Base_Float0[15],
    frexp = Base_Float0[16],
    ldexp = Base_Float0[17],
    is_nan = Base_Float0[18],
    to_int64_preserve_order = Base_Float0[19],
    to_int64_preserve_order_exn = Base_Float0[20],
    of_int64_preserve_order = Base_Float0[21],
    one_ulp = Base_Float0[22],
    upper_bound_for_int = Base_Float0[23],
    lower_bound_for_int = Base_Float0[25],
    clamp_unchecked = Base_Float0[26],
    box = Base_Float0[27],
    compare = Base_Float0[36],
    raise_s = Base_Error[30],
    hash_fold_t = Base_Import[210],
    func = Base_Import[224],
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 859, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 697, 8],
    _E_ = [0, cst_src_float_ml, 700, 8],
    _A_ = [0, cst_src_float_ml, 707, 8],
    _B_ = [0, cst_src_float_ml, 708, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 684, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[108][9],
    include = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _aX_ = caml_call1(float_of_string, s); return _aX_;}
    catch(_aY_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     _aW_ = caml_call1(float_of_string, y),
     y$0 =
       caml_call2(Base_Import[108][4], _aW_, x)
        ? y
        : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[112], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    of_int = Base_Int[3],
    to_int = Base_Int[2],
    zero = 0.,
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329;
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[59]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[59]);
   function iround_up(t){
    if(! caml_call2(Base_Import[108][5], t, 0.))
     return caml_call2(Base_Import[108][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_up, t);
    return caml_call2(Base_Import[108][2], t$0, iround_ubound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_up_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[108][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aU_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _aU_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aV_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _aV_, 0);
   }
   function iround_down(t){
    if(caml_call2(Base_Import[108][6], t, 0.))
     return caml_call2(Base_Import[108][2], t, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_down, t);
    return caml_call2(Base_Import[108][6], t$0, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_down_exn(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aS_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aS_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[108][6], t$0, iround_lbound))
     return caml_call1(Base_Int[58], t$0);
    var _aT_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _aT_, 0);
   }
   function iround_towards_zero(t){
    if
     (caml_call2(Base_Import[108][6], t, iround_lbound)
      && caml_call2(Base_Import[108][2], t, iround_ubound))
     return [0, caml_call1(Base_Int[58], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if
     (caml_call2(Base_Import[108][6], t, iround_lbound)
      && caml_call2(Base_Import[108][2], t, iround_ubound))
     return caml_call1(Base_Int[58], t);
    var _aR_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aR_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[114], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var
     _aQ_ =
       caml_call2(Base_Import[108][4], t, one_ulp_less_than_half)
        ? one_ulp_less_than_half
        : 0.5;
    return caml_call2(Base_Import[92], t, _aQ_);
   }
   function iround_nearest_32(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     return caml_call2(Base_Import[108][2], t$0, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t$0)]
             : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return caml_call2(Base_Import[108][6], t$1, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$1)]
            : 0;
   }
   function iround_nearest_64(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(! caml_call2(Base_Import[108][1], t, round_nearest_ub))
      return caml_call2(Base_Import[108][2], t, iround_ubound)
              ? [0, caml_call1(Base_Int[58], t)]
              : 0;
     var _aO_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[58], _aO_)];
    }
    if(! caml_call2(Base_Import[108][5], t, round_nearest_lb))
     return caml_call2(Base_Import[108][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var _aP_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return [0, caml_call1(Base_Int[58], _aP_)];
   }
   var
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     if(caml_call2(Base_Import[108][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aM_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aM_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    if(caml_call2(Base_Import[108][6], t$1, iround_lbound))
     return caml_call1(Base_Int[58], t$1);
    var _aN_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aN_, 0);
   }
   function iround_nearest_exn_64(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][1], t, round_nearest_ub)){
      var _aI_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[58], _aI_);
     }
     if(caml_call2(Base_Import[108][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aJ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aJ_, 0);
    }
    if(caml_call2(Base_Import[108][5], t, round_nearest_lb)){
     var _aK_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
     return caml_call1(Base_Int[58], _aK_);
    }
    if(caml_call2(Base_Import[108][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aL_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aL_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aG_ = [0, iround_exn([0, dir], t)]; return _aG_;}
    catch(_aH_){return 0;}
   }
   function is_inf(t){
    var _aF_ = caml_call2(Base_Import[96], 1., t);
    return caml_call2(Base_Import[108][4], _aF_, 0.);
   }
   function is_finite(t){
    var _aE_ = caml_call2(Base_Import[94], t, t);
    return caml_call2(Base_Import[108][4], _aE_, 0.);
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[108][1], x, y) ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[108][5], x, y) ? x : y;
   }
   var
    add = Base_Import[92],
    sub = Base_Import[94],
    neg = Base_Import[114],
    scale = Base_Import[90];
   function square(x){return caml_call2(Base_Import[90], x, x);}
   function fractional(t){return caml_call1(Base_Import[125], t);}
   function integral(t){return caml_call1(Base_Import[127], t);}
   function round_towards_zero(t){
    return caml_call2(Base_Import[108][6], t, 0.)
            ? caml_call1(round_down, t)
            : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if
     (caml_call2(Base_Import[108][5], t, round_nearest_lb)
      && caml_call2(Base_Import[108][1], t, round_nearest_ub))
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[92], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if
     (!
      caml_call2(Base_Import[108][2], t, round_nearest_lb)
      && ! caml_call2(Base_Import[108][6], t, round_nearest_ub)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[92], floor, 1.),
      diff_floor = caml_call2(Base_Import[94], t, floor),
      diff_ceil = caml_call2(Base_Import[94], ceil_or_succ, t);
     if(caml_call2(Base_Import[108][1], diff_floor, diff_ceil)) return floor;
     if(caml_call2(Base_Import[108][5], diff_floor, diff_ceil))
      return ceil_or_succ;
     var _aD_ = caml_call2(mod_float, floor, 2.);
     return caml_call2(Base_Import[108][4], _aD_, 0.) ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[92], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[83]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[83]);
   function int63_round_up_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[108][2], t$0, int63_round_ubound))
      return caml_call1(Base_Int63[82], t$0);
     var _aB_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _l_, _aB_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aC_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _m_, _aC_, 0);
   }
   function int63_round_down_exn(t){
    if(caml_call2(Base_Import[108][6], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _az_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _n_, _az_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[108][6], t$0, int63_round_lbound))
     return caml_call1(Base_Int63[82], t$0);
    var _aA_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _o_, _aA_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(caml_call2(Base_Import[108][5], t, 0.)){
     if(caml_call2(Base_Import[108][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _ax_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _ax_, 0);
    }
    if(caml_call2(Base_Import[108][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _ay_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _ay_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _aw_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[96], _aw_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192 <= dir ? round_towards_zero(t) : round_nearest(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare$1 = runtime.caml_int_compare;
   function t_of_sexp$0(sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _aq_ = sexp_007[1], _ar_ = caml_string_compare(_aq_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _ar_){
           if(0 < _ar_){
            if(! caml_string_notequal(_aq_, cst_nan$1)) break e;
            if(! caml_string_notequal(_aq_, cst_normal)) break d;
            if(! caml_string_notequal(_aq_, cst_subnormal)) break c;
            if(caml_string_notequal(_aq_, cst_zero)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(_aq_, cst_Infinite)){
           if(! caml_string_notequal(_aq_, cst_Nan)) break e;
           if(! caml_string_notequal(_aq_, cst_Normal)) break d;
           if(! caml_string_notequal(_aq_, cst_Subnormal)) break c;
           if(caml_string_notequal(_aq_, cst_Zero)) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _as_ = sexp_007[1];
     if(! _as_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_007);
     var _at_ = _as_[1];
     if(0 !== _at_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_007);
     var _au_ = _at_[1], _av_ = caml_string_compare(_au_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _av_){
          if(0 < _av_){
           if(! caml_string_notequal(_au_, cst_nan$1)) break e;
           if(! caml_string_notequal(_au_, cst_normal)) break d;
           if(! caml_string_notequal(_au_, cst_subnormal)) break c;
           if(caml_string_notequal(_au_, cst_zero)) break a;
           break b;
          }
         }
         else if(caml_string_notequal(_au_, cst_Infinite)){
          if(! caml_string_notequal(_au_, cst_Nan)) break e;
          if(! caml_string_notequal(_au_, cst_Normal)) break d;
          if(! caml_string_notequal(_au_, cst_Subnormal)) break c;
          if(caml_string_notequal(_au_, cst_Zero)) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_007);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _ap_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[163], _ap_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[139], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _am_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_am_) var sth$0 = _am_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[84], string, 46);
    if(! match)
     return caml_call2(Base_Int_conversions[37], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_conversions[37], left, delimiter);
    if(strip_zero)
     var
      _an_ = [0, function(c){return caml_call2(Base_Char[11], c, 48);}],
      right$0 = caml_call2(Base_String[92], _an_, right);
    else
     var right$0 = right;
    if(! caml_string_notequal(right$0, cst$4)) return left$0;
    var _ao_ = caml_call2(Base_Import[112], cst$0, right$0);
    return caml_call2(Base_Import[112], left$0, _ao_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _al_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_al_)
     var sth$0 = _al_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match)
     return caml_call2(Base_Import[108][5], f, 0.) ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[18][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[56], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _ak_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[4], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_sexp_of_float_produced_str, _ak_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match)
     return caml_call2(Base_Import[108][1], t, 0.) ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if
        (caml_call2(Base_Import[108][4], denominator, 100.)
         && caml_call2(Base_Import[108][6], numerator, 999.95))
        break a;
       if(caml_call2(Base_Import[108][6], denominator, 100000.)){
        var
         _aj_ =
           round_nearest(caml_call2(Base_Import[90], denominator, 9.9995));
        if(caml_call2(Base_Import[108][6], numerator, _aj_)) break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      var
       _ai_ = round_nearest(caml_call2(Base_Import[90], denominator, 9999.5));
      if(! caml_call2(Base_Import[108][1], numerator, _ai_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[96], numerator, denominator)),
       lower = caml_call2(Base_Import[90], denominator, k),
       _ah_ = caml_call2(Base_Import[92], k, 1.),
       higher = caml_call2(Base_Import[90], denominator, _ah_),
       diff_right = caml_call2(Base_Import[94], higher, numerator),
       diff_left = caml_call2(Base_Import[94], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         caml_call2(Base_Import[108][1], diff_right, diff_left)
          ? caml_call2(Base_Import[91], k$0, 1)
          : caml_call2
             (Base_Import[108][5], diff_right, diff_left)
            ? k$0
            : 0
              === caml_call2(Base_Import[122], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[91], k$0, 1),
       d = caml_call2(Base_Import[122], k$1, 10),
       i = caml_call2(Base_Import[95], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! caml_call2(Base_Import[108][1], t, 999.95)){
      if(caml_call2(Base_Import[108][1], t, 999950.))
       return conv(kilo, t, 100.);
      if(caml_call2(Base_Import[108][1], t, 999950000.))
       return conv(mega, t, 100000.);
      if(caml_call2(Base_Import[108][1], t, 999950000000.))
       return conv(giga, t, 100000000.);
      if(caml_call2(Base_Import[108][1], t, 999950000000000.))
       return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return caml_call2(Base_Import[108][1], t, 999950000000000000.)
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if
      (caml_call2(Base_Import[108][2], 0., t)
       && caml_call2(Base_Import[108][1], t, 999.95)){
      var
       x = caml_call2(Base_Import[112], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[80], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[15], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 2), 32);
      return caml_call1(Base_Bytes0[16], x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(caml_call2(Base_Import[108][6], t, 0.)) return go(t);
    var _ag_ = go(caml_call1(Base_Import[114], t));
    return caml_call2(Base_Import[112], cst$1, _ag_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[92], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[96], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[113], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; caml_call1(Base_Import[129], n$0);}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[90], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[116], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[90], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[90], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[120], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(caml_call2(Base_Import[108][4], x, 0.)) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ac_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[93], sd, _ac_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _af_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[91], dd$1, _af_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[73], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ad_ =
         round_nearest_half_to_even(caml_call2(Base_Import[90], x, order));
      return caml_call2(Base_Import[96], _ad_, order);
     }
     var
      _ae_ = round_nearest_half_to_even(caml_call2(Base_Import[96], x, order));
     return caml_call2(Base_Import[90], _ae_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _ab_ = caml_call2(Base_Import[108][2], low, t);
    return _ab_ ? caml_call2(Base_Import[108][2], t, high) : _ab_;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     ___ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _$_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], ___],
     _aa_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _$_);
    return caml_call1(Base_Or_error[35], _aa_);
   }
   var
    symbol$1 = Base_Import[92],
    symbol$2 = Base_Import[94],
    symbol$3 = Base_Import[90],
    symbol$4 = Base_Import[96],
    symbol$5 = Base_Import[114];
   function sign_exn(t){
    if(caml_call2(Base_Import[108][5], t, 0.)) return 2;
    if(caml_call2(Base_Import[108][1], t, 0.)) return 0;
    if(caml_call2(Base_Import[108][4], t, 0.)) return 1;
    var
     _Y_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _Z_ = caml_call2(Base_Sexp[9], cst_Float_sign_exn_of_NAN, _Y_);
    return caml_call1(Base_Error[30], _Z_);
   }
   function sign_or_nan(t){
    return caml_call2(Base_Import[108][5], t, 0.)
            ? 2
            : caml_call2
               (Base_Import[108][1], t, 0.)
              ? 0
              : caml_call2(Base_Import[108][4], t, 0.) ? 1 : 3;
   }
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    _M_ = Base_Int64[32],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[48], Base_Int64[32], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[5], exponent_mask64),
    _N_ = Base_Int63[39],
    _O_ = caml_call2(Base_Int63[72], Base_Int63[39], 52),
    mantissa_mask = caml_call2(Base_Int63[42], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[79], mantissa_mask),
    mantissa_bits = 52;
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _X_ = caml_call2(Base_Int64[62], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[43], _X_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[78], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[43], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _U_ = caml_call2(Base_Int63[67], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _U_, mantissa)){
     var
      _V_ = caml_call1(Base_Int63[11], mantissa_mask),
      _W_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _W_, _V_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[79], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    function _T_(param){return create_ieee_exn(negative, exponent, mantissa);}
    return caml_call2(Base_Or_error[28], 0, _T_);
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return caml_call2(Base_Import[108][5], t, 0.);}
   function is_non_negative(t){return caml_call2(Base_Import[108][6], t, 0.);}
   function is_negative(t){return caml_call2(Base_Import[108][1], t, 0.);}
   function is_non_positive(t){return caml_call2(Base_Import[108][2], t, 0.);}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1],
    _S_ = Base_Import[108],
    symbol$6 = _S_[3],
    symbol$7 = _S_[1],
    symbol$8 = _S_[5],
    symbol$9 = _S_[4],
    symbol$10 = _S_[2],
    symbol$11 = _S_[6];
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[224],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[108],
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    symbol$15 = include$2[4],
    symbol$16 = include$2[5],
    symbol$17 = include$2[6],
    ascending = include$2[7],
    descending = include$2[8],
    compare$2 = include$2[9],
    equal = include$2[10];
   function min(x, y){
    if(! caml_call2(symbol$12, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! caml_call2(symbol$16, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       symbol$17,
       symbol$13,
       symbol$15,
       symbol$16,
       symbol$12,
       symbol$14,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       invariant,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$1,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[139], _c_);
   }
   function create$0(len){return caml_call1(Base_Bytes[31], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(Stdlib_Buffer[5], src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0],
    cst_b = "b",
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM";
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[60];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _i_ = to_string(t);
    return caml_call1(Base_String[88], _i_);
   }
   function sexp_of_t(t){
    function _g_(x){return [0, x];}
    var _h_ = to_string_list(t);
    return [1, caml_call2(Base_List[76], _h_, _g_)];
   }
   var set_recording = Stdlib_Printexc[7], am_recording = Stdlib_Printexc[8];
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    function _f_(param){return caml_call1(set_recording, saved);}
    return caml_call2(Base_Exn[13], f, _f_);
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[20], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[81],
      _b_ = function(_e_){return caml_call2(_a_, _e_, cst_b);},
      _c_ = caml_call2(Base_String[86], x, 44),
      ocamlrunparam_mentions_backtra = caml_call2(Base_List[13], _c_, _b_);
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _d_ = 1 - ocamlrunparam_mentions_backtra;
    return _d_ ? caml_call1(set_recording, 1) : _d_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    hash_fold_t = Base_Sexp_with_comparable[1],
    hash = Base_Sexp_with_comparable[2],
    t_of_sexp = Base_Sexp_with_comparable[3],
    sexp_of_t = Base_Sexp_with_comparable[4],
    Not_found_s = Base_Sexp_with_comparable[5],
    Of_sexp_error = Base_Sexp_with_comparable[6],
    message = Base_Sexp_with_comparable[7],
    default_indent = Base_Sexp_with_comparable[8],
    pp_hum = Base_Sexp_with_comparable[9],
    pp_hum_indent = Base_Sexp_with_comparable[10],
    pp_mach = Base_Sexp_with_comparable[11],
    pp = Base_Sexp_with_comparable[12],
    to_string_hum = Base_Sexp_with_comparable[13],
    to_string_mach = Base_Sexp_with_comparable[14],
    to_string = Base_Sexp_with_comparable[15],
    of_float_style = Base_Sexp_with_comparable[16],
    of_int_style = Base_Sexp_with_comparable[17],
    t_sexp_grammar = Base_Sexp_with_comparable[18],
    invariant = Base_Sexp_with_comparable[19],
    of_string = Base_Sexp_with_comparable[20],
    symbol$0 = Base_Sexp_with_comparable[21],
    symbol$1 = Base_Sexp_with_comparable[22],
    symbol$2 = Base_Sexp_with_comparable[23],
    symbol$3 = Base_Sexp_with_comparable[24],
    symbol$4 = Base_Sexp_with_comparable[25],
    symbol$5 = Base_Sexp_with_comparable[26],
    equal = Base_Sexp_with_comparable[27],
    compare = Base_Sexp_with_comparable[28],
    min = Base_Sexp_with_comparable[29],
    max = Base_Sexp_with_comparable[30],
    ascending = Base_Sexp_with_comparable[31],
    descending = Base_Sexp_with_comparable[32],
    between = Base_Sexp_with_comparable[33],
    clamp_exn = Base_Sexp_with_comparable[34],
    clamp = Base_Sexp_with_comparable[35],
    comparator = Base_Sexp_with_comparable[36],
    Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator],
    am_testing = Base_Import[132],
    Exported_for_specific_uses = [0, am_testing],
    compare_array = Base_Array[1],
    equal_array = Base_Array[100],
    array_of_sexp = Base_Array[2],
    sexp_of_array = Base_Array[3];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[4], a_sexp_grammar);
   }
   var
    compare_bool = Base_Bool[16],
    equal_bool = Base_Bool[15],
    hash_fold_bool = Base_Bool[3],
    func = Base_Bool[4];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[5],
    sexp_of_bool = Base_Bool[6],
    bool_sexp_grammar = Base_Bool[2],
    compare_char = Base_Char[16],
    equal_char = Base_Char[15],
    hash_fold_char = Base_Char[3],
    func$0 = Base_Char[4];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[5],
    sexp_of_char = Base_Char[6],
    char_sexp_grammar = Base_Char[2],
    sexp_of_exn = Base_Exn[1],
    compare_float = Base_Float[16],
    equal_float = Base_Float[15],
    hash_fold_float = Base_Float[4],
    func$1 = Base_Float[5];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[6],
    sexp_of_float = Base_Float[7],
    float_sexp_grammar = Base_Float[1],
    compare_int = Base_Int[13],
    equal_int = Base_Int[12],
    hash_fold_int = Base_Int[6],
    func$2 = Base_Int[7];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[8],
    sexp_of_int = Base_Int[9],
    int_sexp_grammar = Base_Int[1],
    compare_int32 = Base_Int32[19],
    equal_int32 = Base_Int32[18],
    hash_fold_int32 = Base_Int32[6],
    func$3 = Base_Int32[7];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[8],
    sexp_of_int32 = Base_Int32[9],
    int32_sexp_grammar = Base_Int32[1],
    compare_int64 = Base_Int64[13],
    equal_int64 = Base_Int64[12],
    hash_fold_int64 = Base_Int64[6],
    func$4 = Base_Int64[7];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[8],
    sexp_of_int64 = Base_Int64[9],
    int64_sexp_grammar = Base_Int64[1],
    compare_list = Base_List[1],
    equal_list = Base_List[147],
    hash_fold_list = Base_List[2],
    list_of_sexp = Base_List[3],
    sexp_of_list = Base_List[4];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[5], a_sexp_grammar);
   }
   var
    compare_nativeint = Base_Nativeint[19],
    equal_nativeint = Base_Nativeint[18],
    hash_fold_nativeint = Base_Nativeint[6],
    func$5 = Base_Nativeint[7];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[8],
    sexp_of_nativeint = Base_Nativeint[9],
    nativeint_sexp_grammar = Base_Nativeint[1],
    compare_option = Base_Option[1],
    equal_option = Base_Option[4],
    hash_fold_option = Base_Option[2],
    option_of_sexp = Base_Option[6],
    sexp_of_option = Base_Option[7];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[3], a_sexp_grammar);
   }
   var
    compare_ref = Base_Ref[1],
    equal_ref = Base_Ref[2],
    ref_of_sexp = Base_Ref[3],
    sexp_of_ref = Base_Ref[4];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[5], a_sexp_grammar);
   }
   var
    compare_string = Base_String[37],
    equal_string = Base_String[121],
    hash_fold_string = Base_String[26];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[27],
    sexp_of_string = Base_String[28],
    string_sexp_grammar = Base_String[1],
    compare_bytes = Base_Bytes[16],
    equal_bytes = Base_Bytes[15],
    bytes_of_sexp = Base_Bytes[1],
    sexp_of_bytes = Base_Bytes[2],
    bytes_sexp_grammar = Base_Bytes[3],
    compare_unit = Base_Unit[16],
    equal_unit = Base_Unit[15],
    hash_fold_unit = Base_Unit[3],
    func$6 = Base_Unit[4];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[5],
    sexp_of_unit = Base_Unit[6],
    unit_sexp_grammar = Base_Unit[2],
    symbol$6 = Base_List[148][1],
    _a_ = Base_Int[70],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[97],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[104],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol$18 = Base_String[53],
    fst = Base_Import[125],
    snd = Base_Import[127],
    failwith = Base_Import[124],
    invalid_arg = Base_Import[126],
    raise_s = Base_Error[30],
    phys_equal = Base_Import[128],
    Export =
      [0,
       compare_array,
       equal_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool,
       equal_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char,
       equal_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float,
       equal_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int,
       equal_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32,
       equal_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64,
       equal_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list,
       equal_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint,
       equal_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option,
       equal_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref,
       equal_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string,
       equal_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit,
       equal_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s,
       phys_equal],
    compare_array$0 = Export[1],
    equal_array$0 = Export[2],
    array_of_sexp$0 = Export[3],
    sexp_of_array$0 = Export[4],
    array_sexp_grammar$0 = Export[5],
    compare_bool$0 = Export[6],
    equal_bool$0 = Export[7],
    hash_fold_bool$0 = Export[8],
    hash_bool$0 = Export[9],
    bool_of_sexp$0 = Export[10],
    sexp_of_bool$0 = Export[11],
    bool_sexp_grammar$0 = Export[12],
    compare_char$0 = Export[13],
    equal_char$0 = Export[14],
    hash_fold_char$0 = Export[15],
    hash_char$0 = Export[16],
    char_of_sexp$0 = Export[17],
    sexp_of_char$0 = Export[18],
    char_sexp_grammar$0 = Export[19],
    sexp_of_exn$0 = Export[20],
    compare_float$0 = Export[21],
    equal_float$0 = Export[22],
    hash_fold_float$0 = Export[23],
    hash_float$0 = Export[24],
    float_of_sexp$0 = Export[25],
    sexp_of_float$0 = Export[26],
    float_sexp_grammar$0 = Export[27],
    compare_int$0 = Export[28],
    equal_int$0 = Export[29],
    hash_fold_int$0 = Export[30],
    hash_int$0 = Export[31],
    int_of_sexp$0 = Export[32],
    sexp_of_int$0 = Export[33],
    int_sexp_grammar$0 = Export[34],
    compare_int32$0 = Export[35],
    equal_int32$0 = Export[36],
    hash_fold_int32$0 = Export[37],
    hash_int32$0 = Export[38],
    int32_of_sexp$0 = Export[39],
    sexp_of_int32$0 = Export[40],
    int32_sexp_grammar$0 = Export[41],
    compare_int64$0 = Export[42],
    equal_int64$0 = Export[43],
    hash_fold_int64$0 = Export[44],
    hash_int64$0 = Export[45],
    int64_of_sexp$0 = Export[46],
    sexp_of_int64$0 = Export[47],
    int64_sexp_grammar$0 = Export[48],
    compare_list$0 = Export[49],
    equal_list$0 = Export[50],
    hash_fold_list$0 = Export[51],
    list_of_sexp$0 = Export[52],
    sexp_of_list$0 = Export[53],
    list_sexp_grammar$0 = Export[54],
    compare_nativeint$0 = Export[55],
    equal_nativeint$0 = Export[56],
    hash_fold_nativeint$0 = Export[57],
    hash_nativeint$0 = Export[58],
    nativeint_of_sexp$0 = Export[59],
    sexp_of_nativeint$0 = Export[60],
    nativeint_sexp_grammar$0 = Export[61],
    compare_option$0 = Export[62],
    equal_option$0 = Export[63],
    hash_fold_option$0 = Export[64],
    option_of_sexp$0 = Export[65],
    sexp_of_option$0 = Export[66],
    option_sexp_grammar$0 = Export[67],
    compare_ref$0 = Export[68],
    equal_ref$0 = Export[69],
    ref_of_sexp$0 = Export[70],
    sexp_of_ref$0 = Export[71],
    ref_sexp_grammar$0 = Export[72],
    compare_string$0 = Export[73],
    equal_string$0 = Export[74],
    hash_fold_string$0 = Export[75],
    hash_string$0 = Export[76],
    string_of_sexp$0 = Export[77],
    sexp_of_string$0 = Export[78],
    string_sexp_grammar$0 = Export[79],
    compare_bytes$0 = Export[80],
    equal_bytes$0 = Export[81],
    bytes_of_sexp$0 = Export[82],
    sexp_of_bytes$0 = Export[83],
    bytes_sexp_grammar$0 = Export[84],
    compare_unit$0 = Export[85],
    equal_unit$0 = Export[86],
    hash_fold_unit$0 = Export[87],
    hash_unit$0 = Export[88],
    unit_of_sexp$0 = Export[89],
    sexp_of_unit$0 = Export[90],
    unit_sexp_grammar$0 = Export[91],
    symbol$19 = Export[92],
    symbol$20 = Export[93],
    lnot$0 = Export[94],
    abs$0 = Export[95],
    zero$0 = Export[96],
    symbol$21 = Export[97],
    symbol$22 = Export[98],
    symbol$23 = Export[99],
    ascending$1 = Export[100],
    descending$1 = Export[101],
    max$1 = Export[102],
    min$1 = Export[103],
    symbol$24 = Export[104],
    symbol$25 = Export[105],
    symbol$26 = Export[106],
    symbol$27 = Export[107],
    symbol$28 = Export[108],
    symbol$29 = Export[109],
    symbol$30 = Export[110],
    symbol$31 = Export[111],
    fst$0 = Export[112],
    snd$0 = Export[113],
    failwith$0 = Export[114],
    invalid_arg$0 = Export[115],
    raise_s$0 = Export[116],
    phys_equal$0 = Export[117],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[252];
   caml_call1(Base_Backtrace[7], 0);
   var
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Sexp,
       Exported_for_specific_uses,
       Export,
       compare_array$0,
       equal_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char$0,
       equal_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float$0,
       equal_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int$0,
       equal_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32$0,
       equal_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64$0,
       equal_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list$0,
       equal_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option$0,
       equal_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string$0,
       equal_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes$0,
       equal_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit$0,
       equal_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$19,
       symbol$20,
       lnot$0,
       abs$0,
       zero$0,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       phys_equal$0,
       Continue_or_stop,
       Not_found_s$0];
   runtime.caml_register_global(21, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZXNjZW5kaW5nIiwieCIsInkiLCJtYXgiLCJtaW4iLCJtYXhfaW50IiwibWluX2ludCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJib29sX29mX3N0cmluZ19vcHQiLCJib29sX29mX3N0cmluZyIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnRfb3B0IiwicmVhZF9pbnQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfZmxvYXQiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsIm9wZW5fb3V0X2dlbiIsImZsdXNoIiwiZmx1c2hfYWxsIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0X2J5dGVzIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfdmFsdWUiLCJzZWVrX291dCIsInBvc19vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJzZXRfYmluYXJ5X21vZGVfb3V0Iiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwib3Blbl9pbl9nZW4iLCJpbnB1dF9jaGFyIiwiaW5wdXRfbGluZSIsImlucHV0IiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2J5dGUiLCJpbnB1dF9iaW5hcnlfaW50IiwiaW5wdXRfdmFsdWUiLCJzZWVrX2luIiwicG9zX2luIiwiaW5fY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9pbiIsImNsb3NlX2luX25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX2luIiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCIsImV4aXQiLCJhdF9leGl0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJ1bnNhZmVfcmVhbGx5X2lucHV0IiwiZG9fYXRfZXhpdCIsImRvX2RvbWFpbl9sb2NhbF9hdF9leGl0IiwiYm9vbF90b19pbnQiLCJzeW1ib2wkMyIsInN5bWJvbCQ0Iiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJzeW1ib2wkOSIsInN5bWJvbCQxMCIsInN5bWJvbCQxMSIsInN5bWJvbCQxMiIsImFzY2VuZGluZyIsIm1heCQwIiwibWluJDAiLCJhc2NlbmRpbmckMCIsImRlc2NlbmRpbmckMCIsIm1heCQxIiwibWluJDEiLCJzeW1ib2wkMTMiLCJzeW1ib2wkMTQiLCJzeW1ib2wkMTUiLCJzeW1ib2wkMTYiLCJzeW1ib2wkMTciLCJzeW1ib2wkMTgiLCJhc2NlbmRpbmckMSIsImRlc2NlbmRpbmckMSIsImNvbXBhcmUiLCJlcXVhbCIsIm1heCQyIiwibWluJDIiLCJhc2NlbmRpbmckMiIsImRlc2NlbmRpbmckMiIsIm1heCQzIiwibWluJDMiLCJzeW1ib2wkMTkiLCJzeW1ib2wkMjAiLCJzeW1ib2wkMjEiLCJzeW1ib2wkMjIiLCJzeW1ib2wkMjMiLCJzeW1ib2wkMjQiLCJhc2NlbmRpbmckMyIsImRlc2NlbmRpbmckMyIsImNvbXBhcmUkMCIsImVxdWFsJDAiLCJtYXgkNCIsIm1pbiQ0Iiwic3ltYm9sJDI1Iiwic3ltYm9sJDI2Iiwic3ltYm9sJDI3Iiwic3ltYm9sJDI4Iiwic3ltYm9sJDI5Iiwic3ltYm9sJDMwIiwiYXNjZW5kaW5nJDQiLCJkZXNjZW5kaW5nJDQiLCJjb21wYXJlJDEiLCJlcXVhbCQxIiwibWF4JDUiLCJtaW4kNSIsInN5bWJvbCQzMSIsInN5bWJvbCQzMiIsInN5bWJvbCQzMyIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsInN5bWJvbCQzNiIsImFzY2VuZGluZyQ1IiwiZGVzY2VuZGluZyQ1IiwiY29tcGFyZSQyIiwiZXF1YWwkMiIsIm1heCQ2IiwibWluJDYiLCJpIiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwic3ltYm9sJDQyIiwiYXNjZW5kaW5nJDYiLCJkZXNjZW5kaW5nJDYiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwibWF4JDciLCJtaW4kNyIsInN5bWJvbCQ0MyIsInN5bWJvbCQ0NCIsInN5bWJvbCQ0NSIsInN5bWJvbCQ0NiIsInN5bWJvbCQ0NyIsInN5bWJvbCQ0OCIsImFzY2VuZGluZyQ3IiwiZGVzY2VuZGluZyQ3IiwiY29tcGFyZSQ0IiwiZXF1YWwkNCIsIm1heCQ4IiwibWluJDgiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJzeW1ib2wkNTEiLCJzeW1ib2wkNTIiLCJzeW1ib2wkNTMiLCJzeW1ib2wkNTQiLCJhc2NlbmRpbmckOCIsImRlc2NlbmRpbmckOCIsImNvbXBhcmUkNSIsImVxdWFsJDUiLCJtYXgkOSIsIm1pbiQ5Iiwic3ltYm9sJDU1Iiwic3ltYm9sJDU2Iiwic3ltYm9sJDU3Iiwic3ltYm9sJDU4Iiwic3ltYm9sJDU5Iiwic3ltYm9sJDYwIiwiYXNjZW5kaW5nJDkiLCJkZXNjZW5kaW5nJDkiLCJjb21wYXJlJDYiLCJlcXVhbCQ2IiwibWF4JDEwIiwibWluJDEwIiwic3ltYm9sJDYxIiwic3ltYm9sJDYyIiwic3ltYm9sJDYzIiwic3ltYm9sJDY0IiwiYXNyIiwibGFuZCIsImxub3QkMCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMkMCIsImZhaWx3aXRoJDAiLCJmc3QiLCJpbnZhbGlkX2FyZyQwIiwic25kIiwicGh5c19lcXVhbCIsImRlY3IiLCJpbmNyIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsImZhaWx3aXRoZiIsImZtdCIsInMiLCJpbnZhbGlkX2FyZ2YiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImludF9zaXplX2luX2JpdHMiLCJiaWdfZW5kaWFuIiwibWF4X3N0cmluZ19sZW5ndGgiLCJtYXhfYXJyYXlfbGVuZ3RoIiwicnVudGltZV92YXJpYW50IiwicnVudGltZV9wYXJhbWV0ZXJzIiwiYXJndiIsImdldF9hcmd2Iiwib2NhbWxfdmVyc2lvbiIsImVuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwicnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiZ2V0ZW52X2V4biIsInZhciQwIiwiZ2V0ZW52IiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImxlbiIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwidCIsImYiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidDEiLCJ0MiIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJzdWNjIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0IiwibCIsInJldiIsInJlcyIsInJlc3QiLCJhIiwiYiIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ZvbGRfY2hhciIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9vcHRpb24iLCJoYXNoX2ZvbGRfZWxlbSIsImhhc2hfZm9sZF9saXN0IiwicyQxIiwibGlzdCQxIiwicyQyIiwibGlzdCIsImxpc3QkMCIsInMkMCIsImhhc2hfZm9sZF9sYXp5X3QiLCJoYXNoX2ZvbGRfcmVmX2Zyb3plbiIsImhhc2hfZm9sZF9hcnJheV9mcm96ZW4iLCJhcnJheSIsImUiLCJpJDAiLCJoYXNoX25hdGl2ZWludCIsImhhc2hfaW50NjQiLCJoYXNoX2ludDMyIiwiaGFzaF9jaGFyIiwiaGFzaF9pbnQiLCJoYXNoX2Jvb2wiLCJoYXNoX3N0cmluZyIsImhhc2hfZmxvYXQiLCJoYXNoX3VuaXQiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwicnVuIiwiZm9sZGVyIiwib3B0Iiwic3RoIiwiY29tcGFyZV9zdGF0ZSIsInN0YXRlX3RvX3N0cmluZyIsInN0YXRlIiwidCQwIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwibGVuX2EiLCJsZW5fYiIsInJldCIsInIiLCJjb21wYXJlX2xpc3QiLCJhJDAiLCJiJDAiLCJ5cyIsInhzIiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX3JlZiIsImVxdWFsX2Jvb2wiLCJlcXVhbF9jaGFyIiwiZXF1YWxfaW50IiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQ2NCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3VuaXQiLCJlcXVhbF9mbG9hdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfZWx0IiwiZXF1YWxfbGlzdCIsImVxdWFsX29wdGlvbiIsImVxdWFsX3JlZiIsImFfMDAxIiwiYl8wMDIiLCJhXzAwMyIsImJfMDA0IiwiYV8wMDUiLCJiXzAwNiIsImhhc2giLCJoc3YiLCJhcmciLCJhMCIsImhzdiQwIiwiYTAkMCIsImhzdiQxIiwidF9zZXhwX2dyYW1tYXIiLCJpbnZhcmlhbnQiLCJzZXhwX29mX3QiLCJudW1fYml0cyIsIndvcmRfc2l6ZSIsImFsbCIsInJlZ2lzdGVyIiwicCIsInBwIiwibW9kdWxlX25hbWUiLCJmb3JtYXR0ZXIiLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsImFyZzFfMDA2IiwiYXJnMF8wMDUiLCJyZXMwXzAwNyIsInJlczFfMDA4IiwiY3JlYXRlX3MiLCJzZXhwIiwicmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJyZXJhaXNlIiwiZXhuIiwic3RyIiwiZXhuJDAiLCJidCIsInJlcmFpc2VmIiwiZXhjIiwiZm9ybWF0IiwidG9fc3RyaW5nX21hY2giLCJzZXhwX29mX3QkMCIsInByb3RlY3R4IiwiZmluYWxseSQwIiwiZmluYWxfZXhuJDAiLCJmaW5hbF9leG4iLCJwcm90ZWN0IiwiZG9lc19yYWlzZSIsInBwZiIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJleGMkMCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsImV4aXQkMCIsInJlcmFpc2VfdW5jYXVnaHQiLCJmdW5jIiwicmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UiLCJpbml0aWFsaXplX21vZHVsZSIsImNsZWFyX2JhY2t0cmFjZSIsIndpdGhfcmV0dXJuIiwiaXNfYWxpdmUiLCJyZXR1cm4kMCIsIndpdGhfcmV0dXJuX29wdGlvbiIsInByZXBlbmQiLCJwYXJhbSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJhbGxfdW5pdCIsIm1hcF92aWFfYmluZCIsIm1hIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsInN5bWJvbF9iaW5kJDEiLCJzeW1ib2xfbWFwJDEiLCJib3RoIiwibG9vcCIsInZzIiwidHMiLCJ2IiwiYmluZCQwIiwicmV0dXJuJDEiLCJtYXAkMCIsInRvX21vbmFkIiwib2ZfbW9uYWQiLCJkZXJpdmVkX21hcCIsIm1hcDIiLCJ0YSIsInRiIiwibWFwMyIsInRjIiwic3ltYm9sJDAiLCJ1Iiwic3ltYm9sJDEiLCJ0ZiIsImZhYiIsImMiLCJhcHBseSIsIm1mIiwibXgiLCJ0eCIsImN1c3RvbV9tYXAiLCJhcHBseSQwIiwiYmxpdF9zdHJpbmciLCJtYWtlIiwidW5zYWZlX2JsaXQiLCJ1bnNhZmVfdG9fc3RyaW5nIiwidW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211IiwiY29tcGFyYXRvciIsImVycm9yX3NvdXJjZV8wMTEiLCJjbXBfZiIsImNtcF9zIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCIsIm9mX2ZfMDA3Iiwib2Zfc18wMDgiLCJzZXhwXzAxMyIsInRhZ18wMTQiLCJzZXhwX2FyZ3NfMDIwIiwiYXJnMF8wMjEiLCJyZXMwXzAyMiIsInNleHBfYXJnc18wMTUiLCJhcmcwXzAxNiIsInJlczBfMDE3Iiwib2ZfZl8wMjUiLCJvZl9zXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJhcmcwXzAyOSIsInJlczBfMDMwIiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwidXBkYXRlciIsImZpZWxkIiwiY2FwaXRhbGl6ZSIsInVuY2FwaXRhbGl6ZSIsInNlcCIsIm4iLCJuJDAiLCJuJDEiLCJoc3YkMiIsInBvc19jbnVtXzAxMCIsInBvc19ib2xfMDA4IiwicG9zX2xudW1fMDA2IiwicG9zX2ZuYW1lXzAwNCIsImFyZ18wMTEiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJibmRzXzAwMyQwIiwiYXJnXzAwNyIsImJuZHNfMDAzJDEiLCJhcmdfMDA1IiwiYm5kc18wMDMkMiIsImhhc2hfZm9sZF90JDAiLCJoYXNoJDAiLCJtYWtlX2xvY2F0aW9uX3N0cmluZyIsInBvc19mbmFtZSIsInBvc19sbnVtIiwicG9zX2NudW0iLCJwb3NfYm9sIiwiaXNfZW1wdHkiLCJwYXJ0aXRpb25fbWFwIiwiZnN0JDAiLCJ5JDAiLCJzbmQkMCIsImVycm9yX3NvdXJjZV8wMDUiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJ0YWdfMDA4Iiwic2V4cF9hcmdzXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJzZXhwX2FyZ3NfMDE0IiwiYXJnMF8wMTUiLCJyZXMwXzAxNiIsIm9mX2FfMDE5Iiwib2ZfYl8wMjAiLCJhcmcwXzAyMyIsInJlczBfMDI0IiwiYV9zZXhwX2dyYW1tYXIiLCJiX3NleHBfZ3JhbW1hciIsImNtcF9hIiwiY21wX2IiLCJhXzAyNyIsImJfMDI4IiwiYV8wMjkiLCJiXzAzMCIsImFfMDMxIiwiYl8wMzIiLCJhXzAzMyIsImJfMDM0IiwiYV8wMzUiLCJiXzAzNiIsImFfMDM3IiwiYl8wMzgiLCJoYXNoX2ZvbGRfYSIsImhhc2hfZm9sZF9iIiwieCQwIiwiY2hlY2tfb2siLCJjaGVja19lcnJvciIsIm9rIiwiZXJyb3IiLCJmYWlsIiwiZmFpbGYiLCJtYXBfZXJyb3IiLCJiaW5kJDEiLCJtYXAkMSIsInJldHVybiQyIiwiaXNfb2siLCJpc19lcnJvciIsIm9mX29wdGlvbiIsIml0ZXJfZXJyb3IiLCJ0b19laXRoZXIiLCJvZl9laXRoZXIiLCJva19pZl90cnVlIiwiYm9vbCIsInRyeV93aXRoIiwib2tfZXhuIiwib2tfb3JfZmFpbHdpdGgiLCJjb21iaW5lIiwiZXJyIiwib2sxIiwib2syIiwiZXJyMSIsImVycjIiLCJjb21iaW5lX2Vycm9ycyIsImVycnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiY291bnQiLCJzdW0iLCJNIiwiZm9sZF9yZXN1bHQiLCJhY2MiLCJpdGVtIiwiZm9sZF91bnRpbCIsImZpbmlzaCIsIm1pbl9lbHQiLCJlbHQiLCJtYXhfZWx0IiwiZmluZF9tYXAiLCJmaW5kIiwidG9fYXJyYXkiLCJpdGVyJDAiLCJpdGVyJDEiLCJsZW5ndGgkMCIsImxlbmd0aCQxIiwiaXNfZW1wdHkkMCIsInN1bSQwIiwibSIsImNvdW50JDAiLCJleGlzdHMkMCIsImZvcl9hbGwkMCIsImZpbmRfbWFwJDAiLCJmaW5kJDAiLCJ0b19saXN0JDAiLCJ0b19hcnJheSQwIiwibWluX2VsdCQwIiwibWF4X2VsdCQwIiwiZm9sZF9yZXN1bHQkMCIsImZvbGRfdW50aWwkMCIsImZvbGQkMCIsIm1lbSIsImNvbXBhcmVfYSIsImVxdWFsX2EiLCJzZXhwX29mX2EiLCJzbG93X2NoZWNrX3Bvc19sZW5fZXhuIiwicG9zIiwidG90YWxfbGVuZ3RoIiwiY2hlY2tfcG9zX2xlbl9leG4iLCJzdG9wIiwiZ2V0X3Bvc19sZW5fZXhuIiwibGVuJDAiLCJvZl9zdGF0ZSIsImFzc2lnbiIsImRzdCIsInNyYyIsImRzdCQwIiwic3JjJDAiLCJtYWtlX2RlZmF1bHQiLCJkZWZhdWx0JDAiLCJzcGxpdF9mcm9tX3BhcmVudCIsImdldF9zdGF0ZSIsInJhbmRvbV9rZXkiLCJmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMiLCJhbGxvd19pbl90ZXN0cyIsImJpdHMiLCJpbnQkMCIsImludDMyIiwiaW50NjQiLCJuYXRpdmVpbnQiLCJjaGFyJDAiLCJhc2NpaSIsIm1ha2Vfc2VsZl9pbml0IiwiaW50X29uXzY0Yml0cyIsImJvdW5kIiwiaW50X29uXzMyYml0cyIsImludCQxIiwiYml0cyQwIiwiZnVsbF9yYW5nZV9pbnQ2NCIsImJpdHMkMSIsImZ1bGxfcmFuZ2VfaW50MzIiLCJmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMiLCJmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHMiLCJmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMkMCIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50IiwicmFpc2VfY3Jvc3NlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwic3RyaW5nX29mX2JvdW5kIiwiaW50X2luY2wiLCJsbyIsImhpIiwiZGlmZiIsImludDMyX2luY2wiLCJuYXRpdmVpbnRfaW5jbCIsImludDY0X2luY2wiLCJmbG9hdCQwIiwicjEiLCJyMiIsInJlc3VsdCIsImZsb2F0X3JhbmdlIiwiZGVmYXVsdCQxIiwiYml0cyQyIiwiaW50JDIiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsImludF9pbmNsJDAiLCJpbnQzMl9pbmNsJDAiLCJuYXRpdmVpbnRfaW5jbCQwIiwiaW50NjRfaW5jbCQwIiwiZmxvYXRfcmFuZ2UkMCIsImJvb2wkMCIsImNoYXIkMSIsImFzY2lpJDAiLCJmdWxsX2luaXQiLCJzZWxmX2luaXQiLCJzZXRfc3RhdGUiLCJwZXJtdXRlIiwicmFuZG9tX3N0YXRlIiwic3RoJDAiLCJudW1fc3dhcHMiLCJ0aGlzX2kiLCJyYW5kb21faSIsImNvbnN0JDAiLCJub24iLCJmb3JldmVyIiwiZSQwIiwiY29tcG9zZSIsImciLCJmbGlwIiwiYXBwbHlfbl90aW1lcyIsIngkMSIsInNleHBfMDA2IiwiZXJyb3Jfc291cmNlXzAyMiIsImZvbGRfbGVmdCIsImFfMDA2IiwiYl8wMDciLCJhXzAwOCIsImJfMDA5Iiwib2ZfYV8wMTAiLCJhcmcwXzAxMSIsInJlczBfMDEyIiwicmFuZ2UiLCJzdHJpZGUiLCJzdGFydF9pIiwic3RvcF9pIiwic3RhcnQiLCJuZXh0X2kiLCJvcmRlciIsInJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbSIsImluaXRpYWxfc3RyaWRlX29yZGVyIiwic3RhcnRfaSQwIiwiYWNjdW0iLCJpX3RvX3N0b3Bfb3JkZXIiLCJuZXh0X2kkMCIsImFjY3VtJDAiLCJyYW5nZSQwIiwic3RoJDEiLCJoZCIsInRsIiwibnRoIiwibnRoX2V4biIsInVub3JkZXJlZF9hcHBlbmQiLCJvZl9saXN0cyIsInNoYXJlZF9sZW5ndGgiLCJzaGFyZWRfbGVuZ3RoJDAiLCJjaGVja19sZW5ndGgyX2V4biIsInRhaWxfb2ZfYiIsInRhaWxfb2ZfYSIsImNoZWNrX2xlbmd0aDIiLCJvZl9saXN0cyQwIiwibDMiLCJjJDAiLCJjaGVja19sZW5ndGgzX2V4biIsInRhaWxfb2ZfYyIsIm4xIiwibjIiLCJuMyIsImNoZWNrX2xlbmd0aDMiLCJpdGVyMiIsIml0ZXIyX2V4biIsInJldl9tYXAyIiwicmV2X21hcDJfZXhuIiwiZm9sZDIiLCJmb2xkMl9leG4iLCJmb3JfYWxsMiIsImZvcl9hbGwyX2V4biIsImV4aXN0czIiLCJleGlzdHMyX2V4biIsImJzIiwicmV2X2ZpbHRlciIsImFjY3UiLCJmaWx0ZXIiLCJub3RfZm91bmQiLCJmaW5kX21hcF9leG4iLCJub3RfZm91bmQkMCIsImZpbmRfZXhuIiwiZmluZGkiLCJub3RfZm91bmQkMSIsImZpbmRpX2V4biIsImZpbmRfbWFwaSIsIm5vdF9mb3VuZCQyIiwiZmluZF9tYXBpX2V4biIsImZvcl9hbGxpIiwiZXhpc3RzaSIsIm1heF9ub25fdGFpbGNhbGwiLCJjb3VudF9hcHBlbmQiLCJ4MSIsIngyIiwieDMiLCJ4NCIsIng1IiwiY291bnRfbWFwIiwiY3RyIiwieDEkMCIsImYxJDMiLCJ4MiQwIiwiZjEkMiIsImYyJDIiLCJ4MyQwIiwiZjEkMSIsImYyJDEiLCJmMyQxIiwieDQkMCIsImYxJDAiLCJmMiQwIiwiZjMkMCIsImY0JDAiLCJ4NSQwIiwiZjEiLCJmMiIsImYzIiwiZjQiLCJmNSIsImJzJDAiLCJ4cyQwIiwieDgiLCJ4NyIsIng2IiwieDAiLCJ5MCQwIiwieTEkMCIsInkyJDAiLCJ5MyQwIiwieTQkMCIsInk1JDAiLCJ5NiQwIiwieTckMCIsInk4JDAiLCJ5OCIsInk3IiwieTYiLCJ5NSIsInk0IiwieTMiLCJ5MiIsInkxIiwieTAiLCJmb2xkaW5nX21hcCIsIm5ld19hY2MiLCJmb2xkX21hcCIsIm1hcDJfb2siLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwibDEkMCIsImwyJDAiLCJsMyQwIiwiYWMiLCJsMyQxIiwibDIkMSIsImwxJDEiLCJhYyQwIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJsaXN0JDIiLCJ1bnppcDMiLCJ6IiwiemlwX2V4biIsInppcCIsInJldl9tYXBpIiwiZm9sZGluZ19tYXBpIiwiZm9sZF9tYXBpIiwiZm9sZGkiLCJmaWx0ZXJpIiwicmVkdWNlIiwicmVkdWNlX2V4biIsInJlZHVjZV9iYWxhbmNlZCIsInN0ZXBfYWNjdW0iLCJudW0iLCJudW0kMCIsImFjYyQwIiwiYWNjJDEiLCJudW0kMSIsInJlZHVjZV9iYWxhbmNlZF9leG4iLCJncm91cGkiLCJicmVhayQwIiwiZ3JvdXBzIiwiY3VycmVudF9ncm91cCIsImdyb3VwIiwic29ydF9hbmRfZ3JvdXAiLCJjb25jYXRfbWFwIiwiY29uY2F0X21hcGkiLCJjb250IiwibWVyZ2UiLCJoMiIsImgxIiwibWFwMiQwIiwibWFwMyQwIiwic3ltYm9sJDIiLCJsYXN0X2V4biIsImxhc3QiLCJpc19wcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXgkMCIsInByZWZpeCQxIiwiaGQkMCIsImZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIiwiYTEiLCJhMSQwIiwiYTIiLCJyZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyIsIndoaWNoX3RvX2tlZXAiLCJ0bCQwIiwidG9fa2VlcCQyIiwidG9fa2VlcCIsInRvX2tlZXAkMCIsInRvX2tlZXAkMSIsImRlZHVwX2FuZF9zb3J0Iiwic29ydGVkIiwiZmluZF9hX2R1cCIsImwkMCIsImhkMiIsImhkMSIsImNvbnRhaW5zX2R1cCIsImxzdCIsImZpbmRfYWxsX2R1cHMiLCJzb3J0ZWQkMiIsInByZXYkMSIsInNvcnRlZCQwIiwicHJldiIsImFscmVhZHlfcmVjb3JkZWQiLCJzb3J0ZWQkMSIsInByZXYkMCIsImFsbF9lcXVhbCIsImNvdW50aSIsImlkeCIsInJldl9maWx0ZXJfbWFwIiwiZmlsdGVyX21hcCIsInJldl9maWx0ZXJfbWFwaSIsImkkMSIsImZpbHRlcl9tYXBpIiwiZmlsdGVyX29wdCIsInBhcnRpdGlvbjNfbWFwIiwidHJkIiwidHJkJDAiLCJ5JDEiLCJwYXJ0aXRpb25fdGYiLCJmJDAiLCJwYXJ0aXRpb25fcmVzdWx0IiwidF9vZl9zZXhwJDAiLCJvZl9hXzAxNCIsIm9mX2JfMDE1IiwieF8wMjMiLCJzZXhwXzAyMSIsImFyZzFfMDE4IiwiYXJnMF8wMTciLCJyZXMwXzAxOSIsInJlczFfMDIwIiwic2V4cF9vZl90JDEiLCJvZl9hXzAyNCIsIm9mX2JfMDI1IiwieF8wMzAiLCJhcmcxXzAyNyIsImFyZzBfMDI2IiwicmVzMV8wMjkiLCJ0X3NleHBfZ3JhbW1hciQwIiwicGFpcl9vZl9ncm91cCIsImsiLCJncm91cCQwIiwiYWxpc3QiLCJzb3J0X2FuZF9ncm91cCQwIiwia2V5Iiwia2V5JDAiLCJub3RfZm91bmQkMyIsImZpbmRfZXhuJDAiLCJ2YWx1ZSIsIm1lbSQwIiwicmVtb3ZlIiwiYWRkIiwiaW52ZXJzZSIsIm1hcCQyIiwiZWwiLCJzcGxpdF9uIiwidF9vcmlnIiwidGFrZSIsImRyb3AiLCJjaHVua3Nfb2YiLCJsJDEiLCJzdWJsaXN0Iiwic3BsaXRfd2hpbGUiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsImRyb3BfbGFzdCIsImRyb3BfbGFzdF9leG4iLCJjYXJ0ZXNpYW5fcHJvZHVjdCIsImxpc3QxIiwibGlzdDIiLCJjb25jYXRfbm9fb3JkZXIiLCJjb25zIiwiaXNfc29ydGVkIiwiaXNfc29ydGVkX3N0cmljdGx5IiwiYXJyIiwicmFuZG9tX2VsZW1lbnRfZXhuIiwicmFuZG9tX2VsZW1lbnQiLCJjbXAiLCJ0MSQwIiwidDIkMCIsInQyJDEiLCJ0MSQxIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uX2FjYyQwIiwiY29sdW1uIiwiZG9fcmV2JDAiLCJjb2x1bW5zJDAiLCJhcmcwXzAzMSIsInJlczBfMDMyIiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMV8wMTMiLCJyZXMyXzAxNCIsImFyZzFfMDE2IiwicmVzMV8wMTgiLCJhcmcyXzAyMSIsImFyZzFfMDIwIiwiYXJnMF8wMTkiLCJyZXMxXzAyMyIsInJlczJfMDI0IiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJhcmcxXzAzMCIsInJlczBfMDMxIiwicmVzMV8wMzIiLCJ0b19zdHJpbmdzX2h1bSIsInN0cmluZyIsInNleHAkMCIsInNleHAkMSIsInRhZyIsInRhZyQwIiwic2V4cCQyIiwidGFnJDEiLCJib2R5IiwidHJ1bmNfYWZ0ZXIiLCJ0cyQwIiwidHMkMSIsImFjJDEiLCJ0b19zZXhwc19odW0iLCJoZXJlIiwiaGVyZSQwIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsInRvX21lc3NhZ2UiLCJpbmZvIiwib2ZfbWVzc2FnZSIsInRvX3N0cmluZ19odW0iLCJtZXNzYWdlIiwidG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImxhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMDciLCJiXzAwOCIsIm9mX2FfMDEzIiwieF8wMTUiLCJvZl9hXzAxNiIsInhfMDE3IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX29rIiwiZmluZF9tYXBfb2siLCJlcnJvcl9zb3VyY2VfMDAzIiwic2V4cF8wMDQiLCJnZXEiLCJsZXEiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsImNsYW1wX2V4biIsImNsYW1wIiwibGV4aWNvZ3JhcGhpYyIsImNtcHMiLCJjbXBzJDAiLCJsaWZ0IiwicmV2ZXJzZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInByZWQiLCJwb3MkMCIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsInNyY19wb3MiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsImNhbGwiLCJ2YWx1ZV9leG4iLCJlcnJvciQwIiwibSQwIiwibSQxIiwidmFsdWVfb3JfdGh1bmsiLCJzb21lIiwiZmlyc3Rfc29tZSIsInNvbWVfaWYiLCJjb25kIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJmaXJzdCIsInNlY29uZCIsImVxMSIsImVxMiIsIm90aGVyIiwiZWl0aGVyIiwib3RoZXJfbG9vcCIsInJldHVybl9sb29wIiwiY29tYmluZV9hbGwiLCJvdGhlcl9sb29wJDAiLCJyZXR1cm5fbG9vcCQwIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImVpdGhlciQwIiwiY29tYmluZSQwIiwiaXRlcmkkMCIsIml0ZXJpJDEiLCJmb2xkaSQwIiwiZm9sZGkkMSIsImNvdW50aSQwIiwiZXhpc3RzaSQwIiwiZm9yX2FsbGkkMCIsImZpbmRfbWFwaSQwIiwiZmluZGkkMCIsImVycm9yX3NvdXJjZV8wMjUiLCJvZl9zXzAwMiIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwibmV4dCIsInVuZm9sZF9zdGVwIiwidW5mb2xkIiwidW5mb2xkX3dpdGgiLCJzZWVkJDAiLCJzZWVkJDEiLCJ1bmZvbGRfd2l0aF9hbmRfZmluaXNoIiwicnVubmluZ19zdGVwIiwiaW5uZXJfZmluaXNoZWQiLCJmaW5pc2hpbmdfc3RlcCIsInN0YXRlJDAiLCJzdGF0ZSQxIiwic3RhdGUkMiIsImlubmVyX3N0YXRlIiwic3RhdGUkMyIsImlubmVyX3N0YXRlJDAiLCJpbm5lcl9zdGF0ZSQxIiwic3RhdGUkNCIsInN0YXRlJDUiLCJzZWVkJDIiLCJ2JDAiLCJ0b19saXN0X3JldiIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdGVwIiwidF9sYXp5IiwibCQyIiwic29tZV9iIiwiZW1wdHkiLCJuZXh0JDAiLCJzJDMiLCJhXzAxMSIsImJfMDEyIiwiYV8wMTMiLCJiXzAxNCIsImFfMDE1IiwiYl8wMTYiLCJhXzAxOSIsImFfMDE3IiwiYl8wMjAiLCJiXzAxOCIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInRhZ18wMjgiLCJzZXhwX2FyZ3NfMDM0IiwiYXJnMF8wMzUiLCJyZXMwXzAzNiIsInNleHBfYXJnc18wMjkiLCJhcmcwXzAzMCIsInNleHBfYXJnc18wMzkiLCJhcmcxXzA0MSIsImFyZzBfMDQwIiwicmVzMF8wNDIiLCJyZXMxXzA0MyIsIm9mX2FfMDQ2Iiwib2ZfYl8wNDciLCJhcmcwXzA0OCIsInJlczBfMDQ5IiwiYXJnMF8wNTAiLCJyZXMwXzA1MSIsImFyZzFfMDUzIiwiYXJnMF8wNTIiLCJyZXMwXzA1NCIsInJlczFfMDU1IiwibWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIiwibmV4dDIiLCJzMiIsIm5leHQxIiwiczEiLCJzMiQwIiwiczIkMSIsInMxJDAiLCJzMiQyIiwiczEkMSIsInMyJDMiLCJjb21wYXJpc29uIiwibWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIiwibWVyZ2Vfc29ydGVkIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiY2h1bmtzX2V4biIsInppcF9mdWxsIiwiYm91bmRlZF9sZW5ndGgiLCJhdF9tb3N0IiwibGVuZ3RoX2lzX2JvdW5kZWRfYnkiLCJjdXIiLCJjdXIkMCIsImxhc3RfZWx0IiwibGFzdF9lbHQkMCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfd2l0aF9saXN0IiwicyQ1IiwiYSQxIiwicyQ0IiwicmVwZWF0IiwiY3ljbGVfbGlzdF9leG4iLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9yY2VfZWFnZXJseSIsIm1lbW9pemUiLCJkcm9wX2VhZ2VybHkiLCJkcm9wX3doaWxlX29wdGlvbiIsInYyIiwidjEiLCJyb3VuZF9yb2JpbiIsImRvbmVfc3RhY2siLCJ0b2RvX3N0YWNrIiwidG9kb19zdGFjayQwIiwiaW50ZXJsZWF2ZSIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsInNldCIsInN3YXAkMCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJwdiIsInIkMCIsInIkMSIsInAkMCIsImxlZnQkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJ0b19zZXF1ZW5jZV9tdXRhYmxlIiwidG9fc2VxdWVuY2UiLCJpMSIsImkyIiwidHQiLCJ3aWR0aCIsImRlcHRoIiwiZCIsInciLCJ0dCQwIiwiZ2V0JDAiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJ1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV8iLCJ1bnNhZmVfc2V0X2ludCIsInVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwiY3JlYXRlX29ial9hcnJheSIsIm9mX2FycmF5IiwiZ3JhbW1hciIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJtYXhfZmluaXRlX3ZhbHVlIiwiY2xhc3NpZnlfZmxvYXQiLCJhYnNfZmxvYXQiLCJpc19pbnRlZ2VyIiwiZnJleHAiLCJsZGV4cCIsImlzX25hbiIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIiwib2ZfaW50NjRfcHJlc2VydmVfb3JkZXIiLCJvbmVfdWxwIiwiZGlyIiwidXBwZXJfYm91bmRfZm9yX2ludCIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpJDIiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbV9leG4iLCJyaW5kZXhfZnJvbV9leG5faW50ZXJuYWwiLCJyaW5kZXhfZXhuX2ludGVybmFsIiwicmluZGV4X2V4biIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiaW5kZXhfaW50ZXJuYWwiLCJ0ZXh0IiwibWF0Y2hlcyIsImluJDAiLCJpbmRleF9leG4kMCIsImluZGV4X2FsbCIsIm1heV9vdmVybGFwIiwicmVwbGFjZV9maXJzdCIsIndpdGgkMCIsImxlbl9zIiwibGVuX3QiLCJsZW5fd2l0aCIsInJlcGxhY2VfYWxsIiwibnVtX21hdGNoZXMiLCJuZXh0X2RzdF9wb3MiLCJuZXh0X3NyY19wb3MiLCJzcGxpdF9vbiIsInBhdHRlcm5fbGVuIiwiYV8wMDIiLCJiXzAwMyIsImttcF9hcnJheV8wMTEiLCJjYXNlX3NlbnNpdGl2ZV8wMDkiLCJwYXR0ZXJuXzAwNyIsImFyZ18wMTIiLCJibmRzXzAwNiIsImFyZ18wMTAiLCJibmRzXzAwNiQwIiwiYXJnXzAwOCIsImJuZHNfMDA2JDEiLCJyZXByZXNlbnRhdGlvbiIsInN1YnN0cl9pbmRleF9nZW4iLCJzdWJzdHJfaW5kZXhfZXhuX2dlbiIsInN1YnN0cl9pbmRleF9hbGxfZ2VuIiwic3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIiwic3Vic3RyX3JlcGxhY2VfYWxsX2dlbiIsImlzX3N1YnN0cmluZ19nZW4iLCJzdWJzdHJpbmciLCJzdWJzdHJfaW5kZXgiLCJzdWJzdHJfaW5kZXhfZXhuIiwic3Vic3RyX2luZGV4X2FsbCIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0Iiwic3Vic3RyX3JlcGxhY2VfYWxsIiwiaXNfc3Vic3RyaW5nIiwiaXNfc3Vic3RyaW5nX2F0X2dlbiIsInN0cl9wb3MkMSIsInN0cl9sZW4iLCJzdWJfbGVuIiwic3RyX3BvcyIsInN1Yl9wb3MiLCJzdWJfcG9zJDAiLCJzdHJfcG9zJDAiLCJpc19zdWZmaXhfZ2VuIiwic3RyaW5nX2xlbiIsImlzX3ByZWZpeF9nZW4iLCJwcmVmaXhfbGVuIiwic2V4cF9vZl90JDIiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwic3Vic3RyX2luZGV4JDAiLCJzdWJzdHJfaW5kZXhfZXhuJDAiLCJzdWJzdHJfaW5kZXhfYWxsJDAiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCQwIiwic3Vic3RyX3JlcGxhY2VfYWxsJDAiLCJpc19zdWJzdHJpbmckMCIsImlzX3N1YnN0cmluZ19hdCIsImxzcGxpdDJfZXhuIiwibGluZSIsImRlbGltIiwibm90X2ZvdW5kJDQiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsImxhc3RfcG9zJDEiLCJsYXN0X3BvcyQwIiwicG9zMSIsInN1Yl9zdHIiLCJzcGxpdCIsInNwbGl0X29uX2NoYXJzIiwiY2hhcnMiLCJiYWNrX3VwX2F0X25ld2xpbmUiLCJlb2wiLCJzcGxpdF9saW5lcyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJvbl9lcnJvciIsImRyb3BfcHJlZml4IiwiZHJvcF9zdWZmaXgiLCJsZmluZGkiLCJyZmluZGkiLCJsYXN0X25vbl9kcm9wIiwicnN0cmlwIiwiZmlyc3Rfbm9uX2Ryb3AiLCJsc3RyaXAiLCJzdHJpcCIsInRyIiwidHJfbXVsdGkiLCJjb25jYXRfYXJyYXkiLCJhciIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwib2ZfY2hhciIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiayQwIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImxhc3RfaWR4JDAiLCJsYXN0X2RzdF9wb3MkMCIsInRvX2VzY2FwZSQwIiwiZXNjYXBlZF9jaGFyIiwibGFzdF9pZHgkMSIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJ0b191bmVzY2FwZSIsInN0YXR1cyQwIiwidG9fdW5lc2NhcGUkMCIsInVuZXNjYXBlX2dlbl9leG4iLCJ1bmVzY2FwZSIsInByZWNlZGluZ19lc2NhcGVfY2hhcnMiLCJjbnQiLCJjbnQkMCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJpbmRleF9mcm9tJDAiLCJzdGF0dXMkMSIsImluZGV4X2Zyb21fZXhuJDAiLCJpbmRleCQxIiwiaW5kZXhfZXhuJDEiLCJyaW5kZXhfZnJvbSQwIiwiZXNjYXBlX2NoYXJzIiwicmluZGV4X2Zyb21fZXhuJDAiLCJyaW5kZXgkMCIsInJpbmRleF9leG4kMCIsInNwbGl0X2dlbiQwIiwic3BsaXQkMCIsInNwbGl0X29uX2NoYXJzJDAiLCJzcGxpdF9hdCIsImxzcGxpdDIkMCIsInJzcGxpdDIkMCIsImxzcGxpdDJfZXhuJDAiLCJyc3BsaXQyX2V4biQwIiwibGFzdF9ub25fZHJvcF9saXRlcmFsIiwiZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsInJzdHJpcF9saXRlcmFsIiwibHN0cmlwX2xpdGVyYWwiLCJzdHJpcF9saXRlcmFsIiwiYmV0d2VlbiQwIiwiY2xhbXBfZXhuJDAiLCJjbGFtcCQwIiwiY3JlYXRlJDAiLCJjcmVhdGUkMSIsInVuc2FmZV9ibGl0JDEiLCJtYXBpJDAiLCJvY2FtbF9sZXhfdGFibGVzIiwicGFyc2VfaGV4IiwibGV4YnVmIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJjb252ZXJ0X2ZhaWx1cmUiLCJudW1fYml0c19pbnQiLCJudW1fYml0c19uYXRpdmVpbnQiLCJudW1fYml0c19pbnQzMiIsIm51bV9iaXRzX2ludDY0IiwibWluX2ludDMyIiwibWF4X2ludDMyIiwibWluX2ludDY0IiwibWF4X2ludDY0IiwibWluX25hdGl2ZWludCIsIm1heF9uYXRpdmVpbnQiLCJpbnQ2NF90b19zdHJpbmciLCJuYXRpdmVpbnRfdG9fc3RyaW5nIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50X3RvX2ludDMyX3RydW5jIiwiaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSIsImRlbGltaXRlciIsImNoYXJzX3Blcl9kZWxpbWl0ZXIiLCJpbnB1dF9sZW5ndGgiLCJoYXNfc2lnbiIsIm51bV9kaWdpdHMiLCJudW1fZGVsaW1pdGVycyIsIm91dHB1dF9sZW5ndGgiLCJpbnB1dF9wb3MiLCJvdXRwdXRfcG9zIiwibnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciIsImZpcnN0X2RpZ2l0X3BvcyIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJzZXhwX29mX2ludF9zdHlsZSIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW4iLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUiLCJpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIiwiaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbCIsImludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyIsIm5lZ2F0aXZlX2V4cG9uZW50Iiwib3ZlcmZsb3ciLCJpbnRfcG93IiwiYmFzZSIsImV4cG9uZW50IiwiaW50NjRfcG93IiwiaW50NjNfcG93X29uX2ludDY0IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJtb2R1bHVzIiwicm91bmRfdXAiLCJyZW1haW5kZXIiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJ0b19tdWx0aXBsZV9vZiIsInJvdW5kX25lYXJlc3QiLCJtb2R1bHVzX21pbnVzX3JlbWFpbmRlciIsInJvdW5kIiwiaDAxIiwibWFzayIsImludDY0X3BvcGNvdW50IiwieCQyIiwiaW50MzJfcG9wY291bnQiLCJuYXRpdmVpbnRfcG9wY291bnQiLCJtb2R1bGVfbmFtZSQwIiwib2Zfc3RyaW5nJDAiLCJmbG9hdF9sb3dlcl9ib3VuZCIsImZsb2F0X3VwcGVyX2JvdW5kIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwiZnVuYyQwIiwiemVybyIsIm1pbnVzX29uZSIsIm5lZyIsIm9mX3N0cmluZyQxIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50IiwibWF4X3ZhbHVlXzMwX2JpdHMiLCJhYnMiLCJyZW0iLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfb3IiLCJiaXRfYW5kIiwiYml0X3hvciIsInBvdyIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImNlaWxfcG93MiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsImZsb29yX3BvdzIiLCJpc19wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsInBvcGNvdW50IiwibG5vdCIsInN1Y2NfZXhuIiwibXNnIiwicHJlZF9leG4iLCJvZl9zY2FsYXIiLCJvZl9zY2FsYXJfZXhuIiwidG9fc2NhbGFyIiwidG9fY2hhciIsInRvX2NoYXJfZXhuIiwidXRmOF9ieXRlX2xlbmd0aCIsInVjaGFyIiwiY29kZXBvaW50Iiwic29tZV90IiwicmVmbCIsInN5bSIsInRyYW5zIiwiY29udiIsImRldHVwbGUyIiwidHVwbGUyIiwid2l0bmVzcyIsInZfMDA1IiwidG9fc2V4cCIsInVpZCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNpemUiLCJzZXRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkkMCIsInB1c2giLCJwb3Bfbm9uZW1wdHkiLCJwb3BfZXJyb3IiLCJwb3AiLCJwb3BfZXhuIiwidG9wX25vbmVtcHR5IiwidG9wX2Vycm9yIiwidG9wIiwidG9wX2V4biIsInVudGlsX2VtcHR5IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMjgiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJlcnJvcl9zb3VyY2VfMDU3IiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJyaWdodF8wMDgiLCJsZWZ0XzAwNyIsIm9mX2FfMDA5Iiwidl8wMTAiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsInRfMDMwIiwidF8wMjkiLCJ0XzAzMiIsInRfMDMxIiwicmlnaHRfMDM0IiwibGVmdF8wMzMiLCJyaWdodF8wMzgiLCJsZWZ0XzAzNyIsInRfMDQwIiwidF8wMzkiLCJ0XzA0MiIsInRfMDQxIiwicmlnaHRfMDM2IiwibGVmdF8wMzUiLCJvZl9rXzA0MyIsIm9mX3ZfMDQ0Iiwic2V4cF8wNzEiLCJhcmcxXzA2OCIsImFyZzBfMDY3IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJyZXMwXzA1OSIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJhcmcwXzA2NCIsInJlczBfMDY1IiwicmVzMV8wNzAiLCJvZl9rXzA3MiIsIm9mX3ZfMDczIiwiYXJnMV8wODIiLCJhcmcwXzA4MSIsInJlczBfMDgzIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJsaCIsImx2JDAiLCJyaCIsInJ2JDAiLCJtaW5fZWx0X2V4biIsImZvbGRfdW50aWxfaGVscGVyIiwidmFsdWUkMCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyJDAiLCJyMiQwIiwicjEkMCIsInVuaW9uX2xpc3QiLCJ0b190cmVlIiwiaW50ZXIiLCJvdGhlcl9zZXQiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiZW51bSQwIiwidHJlZSIsInN5bW1ldHJpY19kaWZmIiwiZWx0JDAiLCJlbnVtMSIsInRyZWUxIiwiZW51bTIiLCJ0cmVlMiIsImNvbXBhcmVfcmVzdWx0IiwibmV4dF9zdGF0ZSIsImdyZWF0ZXJfb3JfZXF1YWxfdG8iLCJsZXNzX29yX2VxdWFsX3RvIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsIm1heWJlIiwidiQxIiwiaW5pdCQwIiwidiQyIiwidiQzIiwidiQ0IiwiZSQyIiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJ0MiQyIiwidDEkMiIsImlzX3N1YnNldCIsImFyZV9kaXNqb2ludCIsImFjY3UkMCIsImFjY3UkMSIsImZpbHQiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJjaG9vc2VfZXhuIiwicG9zX3JlZiIsImdyb3VwX2J5IiwiZXF1aXYiLCJzZXQkMCIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJpc19zdWJzZXQkMCIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImludmFyaWFudHMkMCIsImVsZW1lbnRzJDAiLCJtaW5fZWx0X2V4biQwIiwibWF4X2VsdF9leG4kMCIsImNob29zZSQwIiwiY2hvb3NlX2V4biQwIiwiZm9sZF9yaWdodCQwIiwiaXRlcjIkMCIsImZpbHRlciQwIiwiYWRkJDAiLCJyZW1vdmUkMCIsInVuaW9uJDAiLCJpbnRlciQwIiwiZGlmZiQwIiwic3ltbWV0cmljX2RpZmYkMCIsImNvbXBhcmVfZGlyZWN0IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJncm91cF9ieSQwIiwibnRoJDAiLCJyZW1vdmVfaW5kZXgkMCIsInRvX3NlcXVlbmNlJDAiLCJiaW5hcnlfc2VhcmNoJDAiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQwIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJ0X29mX3NleHBfZGlyZWN0JDAiLCJpbnZhcmlhbnRzJDEiLCJpc19lbXB0eSQxIiwiZWxlbWVudHMkMSIsIm1pbl9lbHQkMSIsIm1pbl9lbHRfZXhuJDEiLCJtYXhfZWx0JDEiLCJtYXhfZWx0X2V4biQxIiwiY2hvb3NlJDEiLCJjaG9vc2VfZXhuJDEiLCJ0b19saXN0JDEiLCJ0b19hcnJheSQxIiwiaXRlciQyIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJjb3VudCQxIiwic3VtJDEiLCJmaW5kJDEiLCJmaW5kX2V4biQxIiwiZmluZF9tYXAkMSIsImZvbGQkMSIsImZvbGRfdW50aWwkMSIsImZvbGRfcmlnaHQkMSIsImZpbHRlciQxIiwiZmlsdGVyX21hcCQwIiwicGFydGl0aW9uX3RmJDEiLCJpdGVyMiQxIiwibWVtJDEiLCJhZGQkMSIsInJlbW92ZSQxIiwidW5pb24kMSIsImludGVyJDEiLCJkaWZmJDEiLCJzeW1tZXRyaWNfZGlmZiQxIiwiY29tcGFyZV9kaXJlY3QkMCIsImlzX3N1YnNldCQzIiwiYXJlX2Rpc2pvaW50JDEiLCJvZl9saXN0JDAiLCJvZl9zZXF1ZW5jZSQwIiwib2ZfYXJyYXkkMCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQwIiwib2Zfc29ydGVkX2FycmF5JDAiLCJ1bmlvbl9saXN0JDAiLCJzdGFibGVfZGVkdXBfbGlzdCQwIiwiZ3JvdXBfYnkkMSIsInNwbGl0JDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsImNvbXBhcmF0b3JfcyIsImVtcHR5JDEiLCJzaW5nbGV0b24kMSIsInVuaW9uX2xpc3QkMiIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQyIiwib2Zfc29ydGVkX2FycmF5JDIiLCJvZl9saXN0JDIiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMiIsInN0YWJsZV9kZWR1cF9saXN0JDIiLCJmaWx0ZXJfbWFwJDIiLCJzZXhwX29mX21fdCIsIkVsdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiZXF1YWxfbV90IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfbV90IiwiY29tcGFyYXRvciQwIiwiZW1wdHkkMiIsInNpbmdsZXRvbiQyIiwidW5pb25fbGlzdCQzIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDMiLCJvZl9zb3J0ZWRfYXJyYXkkMyIsIm9mX2xpc3QkMyIsIm9mX3NlcXVlbmNlJDMiLCJvZl9hcnJheSQzIiwic3RhYmxlX2RlZHVwX2xpc3QkMyIsIm1hcCQzIiwiZmlsdGVyX21hcCQzIiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwicmVwbGFjZSIsInNldF90ZW1wb3JhcmlseSIsInJlc3RvcmVfdG8iLCJzZXRzIiwic25hcHNob3QiLCJzZXRzX3RlbXBvcmFyaWx5IiwiYW5kX3ZhbHVlcyIsImluY19udW1fbXV0YXRpb25zIiwiZWx0c19pbmRleCIsImNoZWNrX2luZGV4X2V4biIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJudW1fbXV0YXRpb25zXzAwMyIsImZyb250XzAwNSIsIm1hc2tfMDA3IiwibGVuZ3RoXzAwOSIsImVsdHNfMDExIiwiYm5kc18wMDIkMSIsImJuZHNfMDAyJDIiLCJibmRzXzAwMiQzIiwibXV0MiIsIm11dDEiLCJmcm9udCIsImNhcGFjaXR5JDAiLCJjYXBhY2l0eSQxIiwiYmxpdF90b19hcnJheSIsImZyb250X2xlbiIsInJlc3RfbGVuIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwiYmxpdF90cmFuc2ZlciIsImxlbiQxIiwiZHN0X3N0YXJ0Iiwic3JjX2kiLCJkc3RfaSIsImVucXVldWVfYWxsIiwidF9yZXN1bHQiLCJmaWx0ZXJfaW5wbGFjZSIsImZpbHRlcmlfaW5wbGFjZSIsInVucmVhY2hhYmxlX2NvZGUiLCJ6ZXJvJDAiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJ0b19pbnQzMl90cnVuYyIsIm9mX2ludDY0X3RydW5jIiwibmFtZSQwIiwib2ZfY29udGludWVfb3Jfc3RvcCIsInRvX2NvbnRpbnVlX29yX3N0b3AiLCJsZWZ0X3ZhbHVlIiwicmlnaHRfdmFsdWUiLCJ2YWx1ZXMiLCJsZWZ0X2RlZmF1bHQiLCJyaWdodF9kZWZhdWx0IiwicmlnaHQkMCIsImNvbXBhcmVfa2V5IiwidmwiLCJ2bCQwIiwidnIiLCJrMCIsImsxIiwibGQiLCJscmQiLCJscmQkMCIsInJkIiwicmxkIiwicmxkJDAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNpbmdsZXRvbl90b190cmVlX2V4biIsImNvbGxhcHNlIiwiZ28iLCJhZGRfdW5jaGVja2VkIiwiZ28kMCIsInRvX3RyZWVfdW5jaGVja2VkIiwibWF4X2tleSIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJqb2luJDAiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJhZGRfbXVsdGkiLCJkYXRhJDAiLCJmaW5kX211bHRpIiwibG93ZXJfcGFydCIsInVwcGVyX3BhcnQiLCJtaW5fdXBwZXIiLCJtYXhfbG93ZXIiLCJ1cHBlcl9wYXJ0X3dpdGhvdXRfbWluIiwiZ28kMSIsImNfbWluIiwiaW5pdCQxIiwiY19tYXgiLCJpbml0JDIiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSIsInJhbmdlX3RvX2FsaXN0IiwiY29uY2F0X3VuY2hlY2tlZCIsInJlbW92ZV9sb29wIiwiY2hhbmdlIiwiY2hhbmdlX2NvcmUiLCJkJDEiLCJsZW5ndGgkMiIsImxlbmd0aCQzIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJub25fZW1wdHlfdGFpbCIsIml0ZXJfa2V5cyIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsImZvbGRfdW50aWxfbG9vcCIsImZpbmFsJDEiLCJmaW5hbCQwIiwiZmlsdGVyX2tleXMiLCJwYXJ0aXRpb25fbWFwaSIsInBhaXIyIiwicGFpcjEiLCJjdXJyIiwiazIiLCJuZXh0JDEiLCJkYXRhX2VxdWFsIiwia2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIiwia2V5c19sZXNzX29yX2VxdWFsX3RvIiwiZCQyIiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImZvbGQyJDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwicmlnaHQkMiIsImxlZnQkMiIsInJpZ2h0JDEiLCJrZXlzIiwib2ZfZm9sZGFibGVfZm9sZCIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwibmV3X2RhdGEiLCJvZl9mb2xkYWJsZSIsIm9mX2ZvbGRhYmxlX29yX2Vycm9yIiwib2ZfZm9sZGFibGVfZXhuIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsIm9mX2FsaXN0X211bHRpIiwiZm9sZCQyIiwib2Zfc2VxdWVuY2VfZm9sZCIsIm9mX3NlcXVlbmNlX3JlZHVjZSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJmb3VuZF92YWx1ZSQwIiwiZm91bmRfa2V5JDAiLCJyYW5rIiwibnVtX3RvX3NlYXJjaCIsInBhaXIiLCJwYWlyJDAiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJlcnJvcl90cmVlIiwib2tzIiwibWFwX2tleXMiLCJtYXBfa2V5c19leG4iLCJsaWtlMiIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwid2l0aF9zYW1lX2xlbmd0aCIsInNldCQxIiwiYWRkX2V4biQwIiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJpdGVyX2tleXMkMCIsIml0ZXJpX3VudGlsJDAiLCJmb2xkJDMiLCJmb2xkMiQxIiwiZmlsdGVyX2tleXMkMCIsImZpbHRlcmkkMCIsImZpbHRlcl9tYXBpJDAiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQwIiwicGFydGl0aW9uaV90ZiQwIiwiY29tYmluZV9lcnJvcnMkMCIsImtleXMkMCIsInRvX2FsaXN0JDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQwIiwibWVyZ2Vfc2tld2VkJDAiLCJib3RoX2xlbiIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJvZl9hbGlzdCQwIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMCIsIm9mX2FsaXN0X2V4biQwIiwib2ZfYWxpc3RfbXVsdGkkMCIsIm9mX2FsaXN0X2ZvbGQkMCIsIm9mX2FsaXN0X3JlZHVjZSQwIiwib2ZfaXRlcmkkMCIsIm9mX2l0ZXJpX2V4biQwIiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDAiLCJvZl9zZXF1ZW5jZV9leG4kMCIsIm9mX3NlcXVlbmNlX211bHRpJDAiLCJvZl9zZXF1ZW5jZV9mb2xkJDAiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMCIsInNldCQyIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2Vfc2tld2VkJDEiLCJmb3JfYWxsaSQxIiwiZXhpc3RzaSQxIiwiY291bnRpJDEiLCJhcHBlbmQkMSIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkMiIsIm50aF9leG4kMCIsInJhbmskMSIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UkMCIsIm1hcF9rZXlzJDAiLCJkdXAiLCJtYXBfa2V5c19leG4kMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfdHJlZSQyIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwibWFwX2tleXMkMSIsIm1hcF9rZXlzX2V4biQxIiwib2ZfdHJlZSQzIiwib2ZfYWxpc3QkMiIsIm9mX2FsaXN0X29yX2Vycm9yJDIiLCJvZl9hbGlzdF9leG4kMiIsIm9mX2FsaXN0X211bHRpJDIiLCJvZl9hbGlzdF9mb2xkJDIiLCJvZl9hbGlzdF9yZWR1Y2UkMiIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMiIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsIksiLCJ2X2dyYW1tYXIiLCJjb21wYXJlX3YiLCJlcXVhbF92IiwiaGFzaF9mb2xkX3YiLCJvZl90cmVlJDQiLCJlbXB0eSQzIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX2l0ZXJpJDMiLCJvZl9pdGVyaV9leG4kMyIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDMiLCJvZl9zZXF1ZW5jZV9leG4kMyIsIm9mX3NlcXVlbmNlX211bHRpJDMiLCJvZl9zZXF1ZW5jZV9mb2xkJDMiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMyIsIm1hcF9rZXlzJDMiLCJtYXBfa2V5c19leG4kMyIsInRyYW5zZmVyIiwicSIsInEkMCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0IiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJjbHoiLCJjdHoiLCJpbnZhbGlkX3N0ciIsInNpZ25lZG5lc3MiLCJwb3Nfc3RyIiwiaW50NjMiLCJpbnQ2MyQwIiwib25lJDAiLCJvZl9uYXRpdmVpbnRfdHJ1bmMiLCJ0b19uYXRpdmVpbnRfdHJ1bmMiLCJ0b19zdHJpbmckMSIsInJlcHIiLCJvZl9pbnRfdHJ1bmMiLCJyZXByJDAiLCJpbmNsdWRlIiwib2ZfZmxvYXQkMCIsInRvX2Zsb2F0JDAiLCJvZl9pbnRfZXhuJDAiLCJ0b19pbnRfZXhuJDAiLCJwcCQwIiwiaGFzaGFibGUkMCIsImlzX3Bvc2l0aXZlJDAiLCJpc19ub25fbmVnYXRpdmUkMCIsImlzX25lZ2F0aXZlJDAiLCJpc19ub25fcG9zaXRpdmUkMCIsInNpZ24kMCIsImludmFyaWFudCQwIiwidG9fc3RyaW5nX2h1bSQwIiwibWludXNfb25lJDAiLCJyZW0kMCIsInJvdW5kJDAiLCJyb3VuZF90b3dhcmRzX3plcm8kMCIsInJvdW5kX2Rvd24kMCIsInJvdW5kX3VwJDAiLCJyb3VuZF9uZWFyZXN0JDAiLCJzdWNjJDAiLCJwcmVkJDAiLCJwb3ckMCIsImJpdF9hbmQkMCIsImJpdF9vciQwIiwiYml0X3hvciQwIiwiYml0X25vdCQwIiwicG9wY291bnQkMCIsInNoaWZ0X2xlZnQkMCIsInNoaWZ0X3JpZ2h0JDAiLCJkZWNyJDAiLCJpbmNyJDAiLCJvZl9pbnQzMl9leG4kMCIsInRvX2ludDMyX2V4biQwIiwib2ZfaW50NjRfZXhuJDAiLCJ0b19pbnQ2NCQwIiwib2ZfbmF0aXZlaW50X2V4biQwIiwidG9fbmF0aXZlaW50X2V4biQwIiwibnVtX2JpdHMkMCIsIm1heF92YWx1ZSQwIiwibWluX3ZhbHVlJDAiLCJzaGlmdF9yaWdodF9sb2dpY2FsJDAiLCJjZWlsX3BvdzIkMCIsImZsb29yX3BvdzIkMCIsImNlaWxfbG9nMiQwIiwiaXNfcG93MiQwIiwiY2x6JDAiLCJjdHokMCIsIm9mX2ludCQwIiwidG9faW50JDAiLCJ0b19pbnRfdHJ1bmMkMCIsInRvX2ludDMyJDAiLCJvZl9pbnQ2NCQwIiwib2ZfbmF0aXZlaW50JDAiLCJ0b19uYXRpdmVpbnQkMCIsInRvX25hdGl2ZWludF90cnVuYyQwIiwib2ZfZmxvYXRfdW5jaGVja2VkJDAiLCJyZXByJDEiLCJic3dhcDMyJDAiLCJic3dhcDQ4JDAiLCJwb3NfZGlmZiIsIm5lZ2F0aXZlX29uZSIsImRpdl93b3VsZF9vdmVyZmxvdyIsInByb2R1Y3QiLCJhYnMkMSIsIm5lZyQwIiwicmFuZG9tX29mX2ludCIsInJhbmRvbV9vZl9pbnQ2NCIsInJhbmRvbV9vZl9pbnQkMCIsInJhbmRvbV9pbmNsX29mX2ludCIsInJhbmRvbV9pbmNsX29mX2ludDY0IiwicmFuZG9tX2luY2wiLCJpbnYiLCJsZWZ0X2tleSIsInJpZ2h0X2tleSIsInVwZGF0ZV9oZWlnaHQiLCJvbGRfaGVpZ2h0IiwibmV3X2hlaWdodCIsImJhbGFuY2UiLCJyb290X25vZGUiLCJsZWZ0X25vZGUiLCJyaWdodF9ub2RlIiwibGVmdF9ub2RlX2xlZnQiLCJsZWZ0X25vZGVfcmlnaHQiLCJscl9sZWZ0IiwibHJfcmlnaHQiLCJyaWdodF9ub2RlX2xlZnQiLCJyaWdodF9ub2RlX3JpZ2h0IiwicmxfbGVmdCIsInJsX3JpZ2h0Iiwic2V0X2xlZnQiLCJub2RlIiwidHJlZSQwIiwic2V0X3JpZ2h0IiwiYWRkZWQiLCJmaW5kaV9hbmRfY2FsbF9pbXBsIiwiYXJnMSIsImFyZzIiLCJjYWxsX2lmX2ZvdW5kIiwiY2FsbF9pZl9ub3RfZm91bmQiLCJmaW5kX2FuZF9jYWxsIiwiY2FsbF9pZl9mb3VuZCQwIiwiY2FsbF9pZl9ub3RfZm91bmQkMCIsImZpbmRpX2FuZF9jYWxsIiwiY2FsbF9pZl9mb3VuZCQxIiwiY2FsbF9pZl9ub3RfZm91bmQkMSIsImZpbmRfYW5kX2NhbGwxIiwiY2FsbF9pZl9mb3VuZCQyIiwiY2FsbF9pZl9ub3RfZm91bmQkMiIsImZpbmRpX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMyIsImNhbGxfaWZfbm90X2ZvdW5kJDMiLCJmaW5kX2FuZF9jYWxsMiIsImNhbGxfaWZfZm91bmQkNCIsImNhbGxfaWZfbm90X2ZvdW5kJDQiLCJmaW5kaV9hbmRfY2FsbDIiLCJpZl9mb3VuZCQwIiwiaWZfbm90X2ZvdW5kJDAiLCJyZW1vdmVkIiwia2V5JDQiLCJkYXRhJDQiLCJya2V5IiwicmRhdGEiLCJrZXkkMSIsInJrZXkkMCIsInJkYXRhJDAiLCJsa2V5JDAiLCJsZGF0YSQwIiwia2V5JDMiLCJkYXRhJDMiLCJya2V5JDEiLCJyZGF0YSQxIiwibGtleSIsImxkYXRhIiwia2V5JDIiLCJkYXRhJDIiLCJtYXBpX2lucGxhY2UiLCJlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCIsIndpdGhvdXRfbXV0YXRpbmciLCJtYXhfdGFibGVfbGVuZ3RoIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplJDAiLCJzaXplJDEiLCJzbG90IiwiYWRkX3dvcmtlciIsIm5ld19yb290IiwibWF5YmVfcmVzaXplX3RhYmxlIiwic2hvdWxkX2dyb3ciLCJuZXdfYXJyYXlfbGVuZ3RoIiwibmV3X3RhYmxlIiwib2xkX3RhYmxlIiwic2V4cF9vZl9rZXkkMCIsImFkZGVkX29yX3JlbW92ZWQiLCJidWNrZXQiLCJjaG9vc2Vfbm9uZW1wdHkiLCJ0YWJsZSIsImF2bHRyZWUiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsIm5ld190IiwidDAiLCJuZXdfZGF0YSQwIiwiZmluZF9vcl9hZGQiLCJpZCIsImZpbmRpX29yX2FkZCIsImZpbmRfYW5kX3JlbW92ZSIsInVwZGF0ZV9hbmRfcmV0dXJuIiwiaW5jcl9ieSIsInJlbW92ZV9pZl96ZXJvIiwiYnkiLCJjcmVhdGVfbWFwcGVkIiwiZ2V0X2tleSIsImdldF9kYXRhIiwiZHVwZXMiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMiLCJzZXhwX29mX2RhdGEiLCJkX29mX3NleHAiLCJrX2dyYW1tYXIiLCJyb3ciLCJvbGQiLCJjcmVhdGVfd2l0aF9rZXkiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IiLCJjcmVhdGVfd2l0aF9rZXlfZXhuIiwibWF5YmVfc2V0IiwidF9sZWZ0IiwidF9yaWdodCIsIm1lcmdlX2ludG8iLCJkc3RfZGF0YSIsImFjdGlvbiIsImRzdF9kYXRhJDAiLCJ0b19yZW1vdmUiLCJmaWx0ZXJfa2V5c19pbnBsYWNlIiwiZmlsdGVyX21hcGlfaW5wbGFjZSIsIm1hcF9yZXN1bHRzIiwiZmlsdGVyX21hcF9pbnBsYWNlIiwic2ltaWxhciIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQwIiwiY3JlYXRlX21hcHBlZCQwIiwiY3JlYXRlX3dpdGhfa2V5JDAiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMCIsImNyZWF0ZV93aXRoX2tleV9leG4kMCIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQxIiwiY3JlYXRlX21hcHBlZCQxIiwiY3JlYXRlX3dpdGhfa2V5JDEiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMSIsImNyZWF0ZV93aXRoX2tleV9leG4kMSIsImdyb3VwJDEiLCJoYXNoYWJsZV9zIiwicG9seV9oYXNoYWJsZSIsInN0cmljdF9hZGQiLCJzdHJpY3RfYWRkX2V4biIsInN0cmljdF9yZW1vdmUiLCJzdHJpY3RfcmVtb3ZlX2V4biIsInNleHBfb2ZfZSIsImxhcmdlciIsInNtYWxsZXIiLCJvZl9oYXNodGJsX2tleXMiLCJoYXNodGJsIiwidG9faGFzaHRibCIsImVfb2Zfc2V4cCIsIm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUiLCJtaW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlIiwicGkiLCJzcXJ0X3BpIiwic3FydF8ycGkiLCJldWxlciIsIm9mX2ludDYzIiwiaXJvdW5kX2xib3VuZCIsImlyb3VuZF91Ym91bmQiLCJpcm91bmRfdXAiLCJpcm91bmRfdXBfZXhuIiwiaXJvdW5kX2Rvd24iLCJpcm91bmRfZG93bl9leG4iLCJpcm91bmRfdG93YXJkc196ZXJvIiwiaXJvdW5kX3Rvd2FyZHNfemVyb19leG4iLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCIsImlyb3VuZF9uZWFyZXN0XzMyIiwiaXJvdW5kX25lYXJlc3RfNjQiLCJpcm91bmRfbmVhcmVzdF82NCQwIiwiaXJvdW5kX25lYXJlc3RfZXhuXzMyIiwiaXJvdW5kX25lYXJlc3RfZXhuXzY0IiwiaXJvdW5kX25lYXJlc3RfZXhuIiwiaXJvdW5kX2V4biIsImlyb3VuZCIsImlzX2luZiIsImlzX2Zpbml0ZSIsIm1pbl9pbmFuIiwibWF4X2luYW4iLCJzY2FsZSIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX25lYXJlc3RfaW5saW5lIiwicm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4iLCJjZWlsX29yX3N1Y2MiLCJkaWZmX2Zsb29yIiwiZGlmZl9jZWlsIiwiaW50NjNfcm91bmRfbGJvdW5kIiwiaW50NjNfcm91bmRfdWJvdW5kIiwiaW50NjNfcm91bmRfdXBfZXhuIiwiaW50NjNfcm91bmRfZG93bl9leG4iLCJpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2EiLCJpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2EiLCJpbnQ2M19yb3VuZF9uZWFyZXN0X2V4biIsImNsYXNzaWZ5Iiwic3RyaXBfemVybyIsImRlY2ltYWxzIiwiZXhwbGljaXRfcGx1cyIsInRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0byIsImtpbG8iLCJtZWdhIiwiZ2lnYSIsInRlcmEiLCJwZXRhIiwibWFnIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJoaWdoZXIiLCJkaWZmX3JpZ2h0IiwiZGlmZl9sZWZ0IiwicGV0YSQwIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIiwicm91bmRfZ2VuIiwic2QiLCJkZCIsImRkJDAiLCJzZCQwIiwiZGQkMSIsInNkJDEiLCJhYnNfZGQiLCJyb3VuZF9zaWduaWZpY2FudCIsInNpZ25pZmljYW50X2RpZ2l0cyIsInJvdW5kX2RlY2ltYWwiLCJkZWNpbWFsX2RpZ2l0cyIsInNpZ25fZXhuIiwic2lnbl9vcl9uYW4iLCJpZWVlX25lZ2F0aXZlIiwiZXhwb25lbnRfbWFzazY0IiwiZXhwb25lbnRfbWFzayIsIm1hbnRpc3NhX21hc2siLCJtYW50aXNzYV9tYXNrNjQiLCJtYW50aXNzYV9iaXRzIiwiaWVlZV9leHBvbmVudCIsImllZWVfbWFudGlzc2EiLCJjcmVhdGVfaWVlZV9leG4iLCJuZWdhdGl2ZSIsIm1hbnRpc3NhIiwic2lnbl9iaXRzIiwiZXhwdF9iaXRzIiwibWFudF9iaXRzIiwiY3JlYXRlX2llZWUiLCJzcGVjaWFsaXplZF9oYXNoIiwiYWRkX3N1YnN0cmluZyIsImFkZF9zdWJieXRlcyIsImVsaWRlZF9tZXNzYWdlIiwiZWxpZGUiLCJhdF9tb3N0X251bV9mcmFtZXMiLCJ0b19zdHJpbmdfbGlzdCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJtb3N0X3JlY2VudCIsIm1vc3RfcmVjZW50X2Zvcl9leG4iLCJ3aXRoX3JlY29yZGluZyIsInNhdmVkIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwiYXJyYXlfb2Zfc2V4cCIsInNleHBfb2ZfYXJyYXkiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJib29sX29mX3NleHAiLCJzZXhwX29mX2Jvb2wiLCJib29sX3NleHBfZ3JhbW1hciIsImNoYXJfb2Zfc2V4cCIsInNleHBfb2ZfY2hhciIsImNoYXJfc2V4cF9ncmFtbWFyIiwic2V4cF9vZl9leG4iLCJmdW5jJDEiLCJmbG9hdF9vZl9zZXhwIiwic2V4cF9vZl9mbG9hdCIsImZsb2F0X3NleHBfZ3JhbW1hciIsImZ1bmMkMiIsImludF9vZl9zZXhwIiwic2V4cF9vZl9pbnQiLCJpbnRfc2V4cF9ncmFtbWFyIiwiZnVuYyQzIiwiaW50MzJfb2Zfc2V4cCIsInNleHBfb2ZfaW50MzIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJmdW5jJDQiLCJpbnQ2NF9vZl9zZXhwIiwic2V4cF9vZl9pbnQ2NCIsImludDY0X3NleHBfZ3JhbW1hciIsImxpc3Rfb2Zfc2V4cCIsInNleHBfb2ZfbGlzdCIsImxpc3Rfc2V4cF9ncmFtbWFyIiwiZnVuYyQ1IiwibmF0aXZlaW50X29mX3NleHAiLCJzZXhwX29mX25hdGl2ZWludCIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fb2Zfc2V4cCIsInNleHBfb2Zfb3B0aW9uIiwib3B0aW9uX3NleHBfZ3JhbW1hciIsInJlZl9vZl9zZXhwIiwic2V4cF9vZl9yZWYiLCJyZWZfc2V4cF9ncmFtbWFyIiwic3RyaW5nX29mX3NleHAiLCJzZXhwX29mX3N0cmluZyIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2J5dGVzIiwiZXF1YWxfYnl0ZXMiLCJieXRlc19vZl9zZXhwIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImZ1bmMkNiIsInVuaXRfb2Zfc2V4cCIsInNleHBfb2ZfdW5pdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiZmFpbHdpdGgiLCJpbnZhbGlkX2FyZyIsImNvbXBhcmVfYXJyYXkkMCIsImVxdWFsX2FycmF5JDAiLCJhcnJheV9vZl9zZXhwJDAiLCJzZXhwX29mX2FycmF5JDAiLCJhcnJheV9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYm9vbCQwIiwiZXF1YWxfYm9vbCQwIiwiaGFzaF9mb2xkX2Jvb2wkMCIsImhhc2hfYm9vbCQwIiwiYm9vbF9vZl9zZXhwJDAiLCJzZXhwX29mX2Jvb2wkMCIsImJvb2xfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2NoYXIkMCIsImVxdWFsX2NoYXIkMCIsImhhc2hfZm9sZF9jaGFyJDAiLCJoYXNoX2NoYXIkMCIsImNoYXJfb2Zfc2V4cCQwIiwic2V4cF9vZl9jaGFyJDAiLCJjaGFyX3NleHBfZ3JhbW1hciQwIiwic2V4cF9vZl9leG4kMCIsImNvbXBhcmVfZmxvYXQkMCIsImVxdWFsX2Zsb2F0JDAiLCJoYXNoX2ZvbGRfZmxvYXQkMCIsImhhc2hfZmxvYXQkMCIsImZsb2F0X29mX3NleHAkMCIsInNleHBfb2ZfZmxvYXQkMCIsImZsb2F0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQkMCIsImVxdWFsX2ludCQwIiwiaGFzaF9mb2xkX2ludCQwIiwiaGFzaF9pbnQkMCIsImludF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludCQwIiwiaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQzMiQwIiwiZXF1YWxfaW50MzIkMCIsImhhc2hfZm9sZF9pbnQzMiQwIiwiaGFzaF9pbnQzMiQwIiwiaW50MzJfb2Zfc2V4cCQwIiwic2V4cF9vZl9pbnQzMiQwIiwiaW50MzJfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NCQwIiwiaGFzaF9mb2xkX2ludDY0JDAiLCJoYXNoX2ludDY0JDAiLCJpbnQ2NF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDY0JDAiLCJpbnQ2NF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfbGlzdCQwIiwiZXF1YWxfbGlzdCQwIiwiaGFzaF9mb2xkX2xpc3QkMCIsImxpc3Rfb2Zfc2V4cCQwIiwic2V4cF9vZl9saXN0JDAiLCJsaXN0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9uYXRpdmVpbnQkMCIsImVxdWFsX25hdGl2ZWludCQwIiwiaGFzaF9mb2xkX25hdGl2ZWludCQwIiwiaGFzaF9uYXRpdmVpbnQkMCIsIm5hdGl2ZWludF9vZl9zZXhwJDAiLCJzZXhwX29mX25hdGl2ZWludCQwIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9vcHRpb24kMCIsImVxdWFsX29wdGlvbiQwIiwiaGFzaF9mb2xkX29wdGlvbiQwIiwib3B0aW9uX29mX3NleHAkMCIsInNleHBfb2Zfb3B0aW9uJDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX3JlZiQwIiwiZXF1YWxfcmVmJDAiLCJyZWZfb2Zfc2V4cCQwIiwic2V4cF9vZl9yZWYkMCIsInJlZl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfc3RyaW5nJDAiLCJlcXVhbF9zdHJpbmckMCIsImhhc2hfZm9sZF9zdHJpbmckMCIsImhhc2hfc3RyaW5nJDAiLCJzdHJpbmdfb2Zfc2V4cCQwIiwic2V4cF9vZl9zdHJpbmckMCIsInN0cmluZ19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYnl0ZXMkMCIsImVxdWFsX2J5dGVzJDAiLCJieXRlc19vZl9zZXhwJDAiLCJzZXhwX29mX2J5dGVzJDAiLCJieXRlc19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfdW5pdCQwIiwiZXF1YWxfdW5pdCQwIiwiaGFzaF9mb2xkX3VuaXQkMCIsImhhc2hfdW5pdCQwIiwidW5pdF9vZl9zZXhwJDAiLCJzZXhwX29mX3VuaXQkMCIsInVuaXRfc2V4cF9ncmFtbWFyJDAiLCJyYWlzZV9zJDAiLCJwaHlzX2VxdWFsJDAiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvcG9seTAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvaW1wb3J0MC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9wcmludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvc3lzMC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9hcnJheTAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvY2hhcjAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvaW50MC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9saXN0MC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9oYXNoLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3BweF9jb21wYXJlX2xpYi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9wcHhfaGFzaF9saWIubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvc2V4cC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS93b3JkX3NpemUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvZXhuLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3dpdGhfcmV0dXJuLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL21vbmFkX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvbW9uYWQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYXBwbGljYXRpdmUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYnl0ZXMwLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2NvbXBhcmF0b3IubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvZWl0aGVyMC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9maWVsZC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9zdHJpbmcwLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NvdXJjZV9jb2RlX3Bvc2l0aW9uMC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9saXN0MS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9yZXN1bHQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvY29udGFpbmVyX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvY29udGFpbmVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2xhenkubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvcmFuZG9tX3JlcHIubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvcmFuZG9tLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2FycmF5X3Blcm11dGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvZm4ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvb3JkZXJpbmcubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvbGlzdC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9pbmZvLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2Vycm9yLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2ludmFyaWFudC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9vcl9lcnJvci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9zaWduMC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9jb21wYXJhYmxlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2hhc2hhYmxlX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvaWRlbnRpZmlhYmxlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3VuaXQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYmxpdC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9vcHRpb24ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvc2V4cGFibGUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvZWl0aGVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2luZGV4ZWRfY29udGFpbmVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NlcXVlbmNlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2FycmF5Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL29ial9hcnJheS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS91bmlmb3JtX2FycmF5Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2Zsb2F0MC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9jaGFyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3BweF9lbnVtZXJhdGVfbGliLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2J5dGVzX3RyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3N0YWdlZC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9zdHJpbmcubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYnl0ZXMubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvaGV4X2xleGVyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2ludF9jb252ZXJzaW9ucy5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9wb3dfb3ZlcmZsb3dfYm91bmRzLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2ludF9tYXRoLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3BvcGNvdW50Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NpZ24ubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvaW50Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3VjaGFyLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3R5cGVfZXF1YWwubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvb3B0aW9uX2FycmF5Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3N0YWNrLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NvdXJjZV9jb2RlX3Bvc2l0aW9uLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NpZ25fb3JfbmFuLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL21heWJlX2JvdW5kLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL21hcF9pbnRmLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NldF9pbnRmLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL3NldC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9yZWYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvcXVldWUubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2Uvbm90aGluZy5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9uYXRpdmVpbnQubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvbWFwLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2xpbmtlZF9xdWV1ZTAubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvbGlua2VkX3F1ZXVlLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2ludDY0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2ludDYzX2VtdWwubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYm9vbC5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9pbnQzMi5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9pbnQ2My5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9oYXNodGJsX2ludGYubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYXZsdHJlZS5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9oYXNodGJsLm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2hhc2hfc2V0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2Zsb2F0Lm1sIiwiL1VzZXJzL3N2aXNobnVzLy5vcGFtL2dydi10ZXN0L2xpYi9iYXNlL2J1ZmZlci5tbCIsIi9Vc2Vycy9zdmlzaG51cy8ub3BhbS9ncnYtdGVzdC9saWIvYmFzZS9iYWNrdHJhY2UubWwiLCIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2Jhc2UvYmFzZS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O1lBZ0JJQSxXQUFXQyxHQUFFQyxHQUFJLE9BQUEsYUFBSkEsR0FBRkQsR0FBaUI7O0lBQzVCRTtJQUNBQzttQ0FGQUosWUFFQUksS0FEQUQ7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHQzRCVTs7Ozs7Ozs7SUF2Q1ZFO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lB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Ozs7SUEwQ0RobUc7SUFZQTJiO0lBQ0FFO0lBT0FuWDtJQUNBRTtJQUNBcWhHO0lBSUFDOzs7O0dBZ0JHOzs7Ozs7T0FqaUJMOXVHO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDOzs7O09BMEpFaWtHO09BQ0FDO09BRUFDO09BSUFDO09BSUNDO09BVURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BTUFDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BR0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUFDO09BVUFDO09BSUFDO09BSUNDO09BU0RDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BRUNDO09BU0RDO09BSUFDO09BSUFDO09BVUFDO09BSUFDO09BSUNDO09BVURDO09BQ0FDO09BRUFDO09BSUFDO09BSUNDO09BUURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0NDO09BTURDO09BQ0FDO09BRUNDO09BS0FDO09BS0RDO09BQ0FDO09BQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBDRGhtRztPQVlBMmI7T0FDQUU7T0FPQW5YO09BQ0FFO09BQ0FxaEc7T0FJQUM7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiogUHJpbWl0aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGVxdWFsIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggPSBDYW1sLm1heFxubGV0IG1pbiA9IENhbWwubWluXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAoKiBUaGVzZSBtb2R1bGVzIGFyZSByZWRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0KSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIENhbWwucmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG4oKiBSZXNodWZmbGUgW0NhbWxdIHNvIHRoYXQgd2UgY2hvb3NlIHRoZSBtb2R1bGVzIHVzaW5nIGxhYmVscyB3aGVuIGF2YWlsYWJsZS4gKilcbm1vZHVsZSBDYW1sID0gc3RydWN0XG5cbiAgaW5jbHVkZSBDYW1sXG5cbiAgbW9kdWxlIEFyZyA9IENhbWwuQXJnICgqKiBAY2Fub25pY2FsIENhbWwuQXJnICopXG5cbiAgbW9kdWxlIEFycmF5ID0gQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKilcblxuICBtb2R1bGUgQm9vbCA9IENhbWwuQm9vbCAoKiogQGNhbm9uaWNhbCBDYW1sLkJvb2wgKilcblxuICBtb2R1bGUgQnVmZmVyID0gQ2FtbC5CdWZmZXIgKCoqIEBjYW5vbmljYWwgQ2FtbC5CdWZmZXIgKilcblxuICBtb2R1bGUgQnl0ZXMgPSBDYW1sLlN0ZExhYmVscy5CeXRlcyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5CeXRlcyAqKVxuXG4gIG1vZHVsZSBDaGFyID0gQ2FtbC5DaGFyICgqKiBAY2Fub25pY2FsIENhbWwuQ2hhciAqKVxuXG4gIG1vZHVsZSBFcGhlbWVyb24gPSBDYW1sLkVwaGVtZXJvbiAoKiogQGNhbm9uaWNhbCBDYW1sLkVwaGVtZXJvbiAqKVxuXG4gIG1vZHVsZSBGbG9hdCA9IENhbWwuRmxvYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5GbG9hdCAqKVxuXG4gIG1vZHVsZSBGb3JtYXQgPSBDYW1sLkZvcm1hdCAoKiogQGNhbm9uaWNhbCBDYW1sLkZvcm1hdCAqKVxuXG4gIG1vZHVsZSBGdW4gPSBDYW1sLkZ1biAoKiogQGNhbm9uaWNhbCBDYW1sLkZ1biAqKVxuXG4gIG1vZHVsZSBHYyA9IENhbWwuR2MgKCoqIEBjYW5vbmljYWwgQ2FtbC5HYyAqKVxuXG4gIG1vZHVsZSBIYXNodGJsID0gQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKilcblxuICBtb2R1bGUgSW50MzIgPSBDYW1sLkludDMyICgqKiBAY2Fub25pY2FsIENhbWwuSW50MzIgKilcblxuICBtb2R1bGUgSW50ID0gQ2FtbC5JbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5JbnQgKilcblxuICBtb2R1bGUgSW50NjQgPSBDYW1sLkludDY0ICgqKiBAY2Fub25pY2FsIENhbWwuSW50NjQgKilcblxuICBtb2R1bGUgTGF6eSA9IENhbWwuTGF6eSAoKiogQGNhbm9uaWNhbCBDYW1sLkxhenkgKilcblxuICBtb2R1bGUgTGV4aW5nID0gQ2FtbC5MZXhpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5MZXhpbmcgKilcblxuICBtb2R1bGUgTGlzdCA9IENhbWwuU3RkTGFiZWxzLkxpc3QgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuTGlzdCAqKVxuXG4gIG1vZHVsZSBNYXAgPSBDYW1sLk1vcmVMYWJlbHMuTWFwICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5NYXAgKilcblxuICBtb2R1bGUgTmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5OYXRpdmVpbnQgKilcblxuICBtb2R1bGUgT2JqID0gQ2FtbC5PYmogKCoqIEBjYW5vbmljYWwgQ2FtbC5PYmogKilcblxuICBtb2R1bGUgT3B0aW9uID0gQ2FtbC5PcHRpb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5PcHRpb24gKilcblxuICBtb2R1bGUgUGFyc2luZyA9IENhbWwuUGFyc2luZyAoKiogQGNhbm9uaWNhbCBDYW1sLlBhcnNpbmcgKilcblxuICBtb2R1bGUgUHJpbnRleGMgPSBDYW1sLlByaW50ZXhjICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRleGMgKilcblxuICBtb2R1bGUgUHJpbnRmID0gQ2FtbC5QcmludGYgKCoqIEBjYW5vbmljYWwgQ2FtbC5QcmludGYgKilcblxuICBtb2R1bGUgUXVldWUgPSBDYW1sLlF1ZXVlICgqKiBAY2Fub25pY2FsIENhbWwuUXVldWUgKilcblxuICBtb2R1bGUgUmFuZG9tID0gQ2FtbC5SYW5kb20gKCoqIEBjYW5vbmljYWwgQ2FtbC5SYW5kb20gKilcblxuICBtb2R1bGUgUmVzdWx0ID0gQ2FtbC5SZXN1bHQgKCoqIEBjYW5vbmljYWwgQ2FtbC5SZXN1bHQgKilcblxuICBtb2R1bGUgU2NhbmYgPSBDYW1sLlNjYW5mICgqKiBAY2Fub25pY2FsIENhbWwuU2NhbmYgKilcblxuICBtb2R1bGUgU2VxID0gQ2FtbC5TZXEgKCoqIEBjYW5vbmljYWwgQ2FtbC5TZXEgKilcblxuICBtb2R1bGUgU2V0ID0gQ2FtbC5Nb3JlTGFiZWxzLlNldCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuU2V0ICopXG5cbiAgbW9kdWxlIFN0YWNrID0gQ2FtbC5TdGFjayAoKiogQGNhbm9uaWNhbCBDYW1sLlN0YWNrICopXG5cbiAgbW9kdWxlIFN0cmluZyA9IENhbWwuU3RkTGFiZWxzLlN0cmluZyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKilcblxuICBtb2R1bGUgU3lzID0gQ2FtbC5TeXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TeXMgKilcblxuICBtb2R1bGUgVWNoYXIgPSBDYW1sLlVjaGFyICgqKiBAY2Fub25pY2FsIENhbWwuVWNoYXIgKilcblxuICBtb2R1bGUgVW5pdCA9IENhbWwuVW5pdCAoKiogQGNhbm9uaWNhbCBDYW1sLlVuaXQgKilcblxuICBleGNlcHRpb24gTm90X2ZvdW5kID0gQ2FtbC5Ob3RfZm91bmRcbmVuZFxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4oKiBXZSB1c2UgW09iai5tYWdpY10gaGVyZSBhcyBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZ2VuZXJhdGUgYSBjb25kaXRpb25hbCBqdW1wIGFuZCB0aGVcbiAgIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2UgaXMgbm90aWNlYWJsZS4gKilcbmxldCBib29sX3RvX2ludCAoeCA6IGJvb2wpIDogaW50ID0gQ2FtbC5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5ICopXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgKCAhPSApID0gQ2FtbC4oICE9IClcbmxldCAoICogKSA9IENhbWwuKCAqIClcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxubGV0ICggKi4gKSA9IENhbWwuKCAqLiApXG5sZXQgKCArICkgPSBDYW1sLiggKyApXG5sZXQgKCArLiApID0gQ2FtbC4oICsuIClcbmxldCAoIC0gKSA9IENhbWwuKCAtIClcbmxldCAoIC0uICkgPSBDYW1sLiggLS4gKVxubGV0ICggLyApID0gQ2FtbC4oIC8gKVxubGV0ICggLy4gKSA9IENhbWwuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWF4ICh4IDogaW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGludCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBDYW1sLkludDMyLnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYm9vbCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBib29sKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogY2hhcikgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBjaGFyKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCBpIHggPSBDYW1sLlVjaGFyLnRvX2ludCB4XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIChpIHgpIChpIHkpXG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5kZXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuICBsZXQgbWF4ICh4IDogQ2FtbC5VY2hhci50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogZmxvYXQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogZmxvYXQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogc3RyaW5nKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogc3RyaW5nKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHN0cmluZykgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIFRoaXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBjYW4gc3BlY2lhbGl6ZSBpdCBhcyBhXG4gICBkaXJlY3Qgc2V0IG9yIGNhbWxfbW9kaWZ5ICopXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBvdGhlcndpc2UgdGhlIGNvbXBpbGVyIHdvbid0IHVuYm94XG4gICByZWZlcmVuY2VzICopXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5cbmxldCAoIEAgKSA9IENhbWwuKCBAIClcbmxldCAoIF4gKSA9IENhbWwuKCBeIClcbmxldCAoIH4tICkgPSBDYW1sLiggfi0gKVxubGV0ICggfi0uICkgPSBDYW1sLiggfi0uIClcbmxldCAoIGFzciApID0gQ2FtbC4oIGFzciApXG5sZXQgKCBsYW5kICkgPSBDYW1sLiggbGFuZCApXG5sZXQgbG5vdCA9IENhbWwubG5vdFxubGV0ICggbG9yICkgPSBDYW1sLiggbG9yIClcbmxldCAoIGxzbCApID0gQ2FtbC4oIGxzbCApXG5sZXQgKCBsc3IgKSA9IENhbWwuKCBsc3IgKVxubGV0ICggbHhvciApID0gQ2FtbC4oIGx4b3IgKVxubGV0ICggbW9kICkgPSBDYW1sLiggbW9kIClcbmxldCBhYnMgPSBDYW1sLmFic1xubGV0IGZhaWx3aXRoID0gQ2FtbC5mYWlsd2l0aFxubGV0IGZzdCA9IENhbWwuZnN0XG5sZXQgaW52YWxpZF9hcmcgPSBDYW1sLmludmFsaWRfYXJnXG5sZXQgc25kID0gQ2FtbC5zbmRcblxuKCogW3JhaXNlXSBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIGFzIHRoZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHJlcGxhY2VzXG4gICAnJXJhaXNlJyBieSAnJXJlcmFpc2UnIHdoZW4gYXBwcm9wcmlhdGUuICopXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG5sZXQgcGh5c19lcXVhbCA9IENhbWwuKCA9PSApXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IGluY3IgPSBDYW1sLmluY3JcblxuKCogdXNlZCBieSBzZXhwX2NvbnYsIHdoaWNoIGZsb2F0MCBkZXBlbmRzIG9uIHRocm91Z2ggb3B0aW9uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gQ2FtbC5mbG9hdF9vZl9zdHJpbmdcblxuKCogW2FtX3Rlc3RpbmddIGlzIHVzZWQgaW4gYSBmZXcgcGxhY2VzIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSB3aGVuIGluIHRlc3RpbmcgbW9kZSwgc3VjaFxuICAgYXMgaW4gW3JhbmRvbS5tbF0uICBbYW1fdGVzdGluZ10gaXMgaW1wbGVtZW50ZWQgdXNpbmcgW0Jhc2VfYW1fdGVzdGluZ10sIGEgd2VhayBDL2pzXG4gICBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFtmYWxzZV0sIGJ1dCB3aGVuIGxpbmtpbmcgYW4gaW5saW5lLXRlc3QtcnVubmVyIGV4ZWN1dGFibGUsIGlzXG4gICBvdmVycmlkZGVuIGJ5IGFub3RoZXIgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbdHJ1ZV0uICopXG5leHRlcm5hbCBhbV90ZXN0aW5nIDogdW5pdCAtPiBib29sID0gXCJCYXNlX2FtX3Rlc3RpbmdcIlxuXG5sZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmcgKClcbiIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgQ2FtbC5QcmludGZcblxuKCoqIGZhaWx3aXRoLCBpbnZhbGlkX2FyZywgYW5kIGV4aXQgYWNjZXB0aW5nIHByaW50ZidzIGZvcm1hdC4gKilcblxubGV0IGZhaWx3aXRoZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG5sZXQgaW52YWxpZF9hcmdmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbiIsIigqIFtTeXMwXSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW0NhbWwuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN5c10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzeXMubWxcbiAgIHNob3VsZCB1c2UgW0NhbWwuU3lzXS4gW1N5czBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlXG4gICBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHRoZXNlXG4gICBmdW5jdGlvbnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN5c10gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIFN5cyA9IFN5czBdLiAgRGVmaW5pbmcgW21vZHVsZSBTeXMgPSBTeXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN5c10uICopXG5cbm9wZW4hIEltcG9ydDBcblxudHlwZSBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGVcbmxldCBpbnRlcmFjdGl2ZSA9IENhbWwuU3lzLmludGVyYWN0aXZlXG5sZXQgb3NfdHlwZSA9IENhbWwuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gQ2FtbC5TeXMudW5peFxubGV0IHdpbjMyID0gQ2FtbC5TeXMud2luMzJcbmxldCBjeWd3aW4gPSBDYW1sLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IENhbWwuU3lzLndvcmRfc2l6ZVxubGV0IGludF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy5pbnRfc2l6ZVxubGV0IGJpZ19lbmRpYW4gPSBDYW1sLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBDYW1sLlN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IG1heF9hcnJheV9sZW5ndGggPSBDYW1sLlN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5sZXQgcnVudGltZV92YXJpYW50ID0gQ2FtbC5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gQ2FtbC5TeXMucnVudGltZV9wYXJhbWV0ZXJzXG5sZXQgYXJndiA9IENhbWwuU3lzLmFyZ3ZcbmxldCBnZXRfYXJndiAoKSA9IENhbWwuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gQ2FtbC5TeXMub2NhbWxfdmVyc2lvblxubGV0IGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzID0gQ2FtbC5TeXMuZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcbmxldCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgPSBDYW1sLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IENhbWwuTm90X2ZvdW5kIC0+XG4gICAgUHJpbnRmLmZhaWx3aXRoZiBcIlN5cy5nZXRlbnZfZXhuOiBlbnZpcm9ubWVudCB2YXJpYWJsZSAlcyBpcyBub3Qgc2V0XCIgdmFyICgpXG47O1xuXG5sZXQgZ2V0ZW52IHZhciA9XG4gIG1hdGNoIENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcblxuZXhjZXB0aW9uIEJyZWFrID0gQ2FtbC5TeXMuQnJlYWtcbiIsIigqIFtBcnJheTBdIGRlZmluZXMgYXJyYXkgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zXG4gICBvZiBbQ2FtbC5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuQXJyYXldXG4gICB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGFycmF5MC5tbCBzaG91bGQgdXNlIFtDYW1sLkFycmF5XS5cbiAgIFtBcnJheTBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGFycmF5cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQXJyYXldIGluIGJ1aWxkIG9yZGVyIHNob3VsZFxuICAgZG8gW21vZHVsZSBBcnJheSA9IEFycmF5MF0uICBUaGlzIGluY2x1ZGVzIHVzZXMgb2Ygc3Vic2NyaXB0IHN5bnRheCAoW3guKGkpXSwgW3guKGkpIDwtXG4gICBlXSksIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbQXJyYXkuZ2V0XSBhbmQgW0FycmF5LnNldF0uXG4gICBEZWZpbmluZyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwIGZyb21cbiAgIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkFycmF5XS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCA6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuICBleHRlcm5hbCBnZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIHNldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOidhIGFycmF5XG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6J2EgYXJyYXlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5lbmRcblxuaW5jbHVkZSBBcnJheVxuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZSBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZSB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW4gPVxuICB0cnkgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgbGVuIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGFwcGVuZCA9IENhbWwuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IENhbWwuQXJyYXkuYmxpdFxubGV0IGNvbmNhdCA9IENhbWwuQXJyYXkuY29uY2F0XG5sZXQgY29weSA9IENhbWwuQXJyYXkuY29weVxubGV0IGZpbGwgPSBDYW1sLkFycmF5LmZpbGxcbmxldCBpbml0ID0gQ2FtbC5BcnJheS5pbml0XG5sZXQgbWFrZV9tYXRyaXggPSBDYW1sLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IENhbWwuQXJyYXkub2ZfbGlzdFxubGV0IHN1YiA9IENhbWwuQXJyYXkuc3ViXG5sZXQgdG9fbGlzdCA9IENhbWwuQXJyYXkudG9fbGlzdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkFycmF5LmZvbGRfbGVmdCB0IH5pbml0IH5mXG5sZXQgZm9sZF9yaWdodCB0IH5mIH5pbml0ID0gQ2FtbC5BcnJheS5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXIgdCB+ZlxubGV0IGl0ZXJpIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXJpIHQgfmZcbmxldCBtYXAgdCB+ZiA9IENhbWwuQXJyYXkubWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBDYW1sLkFycmF5Lm1hcGkgdCB+ZlxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBDYW1sLkFycmF5LnN0YWJsZV9zb3J0IHQgfmNtcDpjb21wYXJlXG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGVsdF9pID0gdC4oaSkgaW5cbiAgbGV0IGVsdF9qID0gdC4oaikgaW5cbiAgdW5zYWZlX3NldCB0IGkgZWx0X2o7XG4gIHVuc2FmZV9zZXQgdCBqIGVsdF9pXG47O1xuIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5DaGFyXS4gIFtDaGFyMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkNoYXJdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGNoYXIwLm1sIHNob3VsZCB1c2UgW0NhbWwuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IENhbWwuQ2hhci5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gQ2FtbC5DaGFyLmxvd2VyY2FzZV9hc2NpaVxubGV0IHRvX2ludCA9IENhbWwuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IENhbWwuQ2hhci51bnNhZmVfY2hyXG5sZXQgdXBwZXJjYXNlID0gQ2FtbC5DaGFyLnVwcGVyY2FzZV9hc2NpaVxuXG4oKiBXZSB1c2Ugb3VyIG93biByYW5nZSB0ZXN0IHdoZW4gY29udmVydGluZyBpbnRlZ2VycyB0byBjaGFycyByYXRoZXIgdGhhblxuICAgY2FsbGluZyBbQ2FtbC5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiIsIigqIFtJbnQwXSBkZWZpbmVzIGludGVnZXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbF0uIFtJbnQwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlXG4gICBwYXJ0IG9mIFtDYW1sXSB0aGF0IFtCYXNlXSB1c2VzIGZvciBpbnRlZ2VycyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gaW50MC5tbCBzaG91bGQgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0aHJvdWdoIFtDYW1sXS4gW0ludDBdIGhhc1xuICAgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgaW50cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuSW50XSBpbiBidWlsZFxuICAgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgSW50ICA9IEludDBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgSW50ID0gSW50MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcFxuICAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5JbnRdLiAqKVxuXG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgb2Zfc3RyaW5nID0gQ2FtbC5pbnRfb2Zfc3RyaW5nXG5sZXQgdG9fZmxvYXQgPSBDYW1sLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0ID0gQ2FtbC5pbnRfb2ZfZmxvYXRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBzdWNjID0gQ2FtbC5zdWNjXG4iLCIoKiBbTGlzdDBdIGRlZmluZXMgbGlzdCBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtDYW1sLkxpc3RdLiAgW0xpc3QwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbQ2FtbC5MaXN0XS5cbiAgIFtMaXN0MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgbGlzdHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkxpc3RdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBMaXN0ID0gTGlzdDBdLiAgRGVmaW5pbmcgW21vZHVsZSBMaXN0ID0gTGlzdDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuTGlzdF0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGhkX2V4biA9IENhbWwuTGlzdC5oZFxubGV0IGxlbmd0aCA9IENhbWwuTGlzdC5sZW5ndGhcbmxldCByZXZfYXBwZW5kID0gQ2FtbC5MaXN0LnJldl9hcHBlbmRcbmxldCB0bF9leG4gPSBDYW1sLkxpc3QudGxcbmxldCB1bnppcCA9IENhbWwuTGlzdC5zcGxpdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBleGlzdHMgdCB+ZiA9IENhbWwuTGlzdC5leGlzdHMgdCB+ZlxubGV0IGV4aXN0czJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZXhpc3RzMiBsMSBsMiB+ZlxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQgdCB+ZiB+aW5pdFxubGV0IGZvbGQyX29rIGwxIGwyIH5pbml0IH5mID0gQ2FtbC5MaXN0LmZvbGRfbGVmdDIgbDEgbDIgfmluaXQgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbCB0IH5mXG5sZXQgZm9yX2FsbDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbDIgbDEgbDIgfmZcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkxpc3QuaXRlciB0IH5mXG5sZXQgaXRlcjJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuaXRlcjIgbDEgbDIgfmZcbmxldCBub250YWlsX21hcCB0IH5mID0gQ2FtbC5MaXN0Lm1hcCB0IH5mXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBDYW1sLkxpc3QubWFwaSB0IH5mXG5sZXQgcGFydGl0aW9uIHQgfmYgPSBDYW1sLkxpc3QucGFydGl0aW9uIHQgfmZcbmxldCByZXZfbWFwIHQgfmYgPSBDYW1sLkxpc3QucmV2X21hcCB0IH5mXG5sZXQgcmV2X21hcDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QucmV2X21hcDIgbDEgbDIgfmZcbmxldCBzb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc29ydCBsIH5jbXA6Y29tcGFyZVxubGV0IHN0YWJsZV9zb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc3RhYmxlX3NvcnQgbCB+Y21wOmNvbXBhcmVcblxubGV0IHJldiA9IGZ1bmN0aW9uXG4gIHwgKFtdIHwgWyBfIF0pIGFzIHJlcyAtPiByZXNcbiAgfCB4IDo6IHkgOjogcmVzdCAtPiByZXZfYXBwZW5kIHJlc3QgWyB5OyB4IF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0IGwgfmYgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbClcbjs7XG4iLCIoKlxuICAgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHRvIHRoZSBydW50aW1lIHN1cHBvcnQgZm9yIFtwcHhfaGFzaF0uXG5cbiAgIFRoZSBbcHB4X2hhc2hdIHN5bnRheCBleHRlbnNpb24gc3VwcG9ydHM6IFtAQGRlcml2aW5nIGhhc2hdIGFuZCBbJWhhc2hfZm9sZDogVFlQRV0gYW5kXG4gICBbJWhhc2g6IFRZUEVdXG5cbiAgIEZvciB0eXBlIFt0XSBhIGZ1bmN0aW9uIFtoYXNoX2ZvbGRfdF0gb2YgdHlwZSBbSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGVdIGlzXG4gICBnZW5lcmF0ZWQuXG5cbiAgIFRoZSBnZW5lcmF0ZWQgW2hhc2hfZm9sZF88VD5dIGZ1bmN0aW9uIGlzIGNvbXBvc2l0aW9uYWwsIGZvbGxvd2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgdHlwZTsgYWxsb3dpbmcgdXNlciBvdmVycmlkZXMgYXQgZXZlcnkgbGV2ZWwuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gb2NhbWwncyBidWlsdGluXG4gICBwb2x5bW9ycGhpYyBoYXNoaW5nIFtIYXNodGJsLmhhc2hdIHdoaWNoIGlnbm9yZXMgdXNlciBvdmVycmlkZXMuXG5cbiAgIFRoZSBnZW5lcmF0b3IgYWxzbyBwcm92aWRlcyBhIGRpcmVjdCBoYXNoLWZ1bmN0aW9uIFtoYXNoXSAobmFtZWQgW2hhc2hfPFQ+XSB3aGVuIDxUPiAhPVxuICAgXCJ0XCIpIG9mIHR5cGU6IFt0IC0+IEhhc2guaGFzaF92YWx1ZV0uXG5cbiAgIFRoZSBmb2xkaW5nIGhhc2ggZnVuY3Rpb24gY2FuIGJlIGFjY2Vzc2VkIGFzIFslaGFzaF9mb2xkOiBUWVBFXVxuICAgVGhlIGRpcmVjdCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2g6IFRZUEVdXG4qKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEhhc2hfaW50ZlxuXG4oKiogQnVpbHRpbiBmb2xkaW5nLXN0eWxlIGhhc2ggZnVuY3Rpb25zLCBhYnN0cmFjdGVkIG92ZXIgW0hhc2hfaW50Zi5TXSAqKVxubW9kdWxlIEZvbGRpbmcgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuQnVpbHRpbl9pbnRmXG4gIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgaGFzaF9mb2xkX3VuaXQgcyAoKSA9IHNcbiAgbGV0IGhhc2hfZm9sZF9pbnQgPSBIYXNoLmZvbGRfaW50XG4gIGxldCBoYXNoX2ZvbGRfaW50NjQgPSBIYXNoLmZvbGRfaW50NjRcbiAgbGV0IGhhc2hfZm9sZF9mbG9hdCA9IEhhc2guZm9sZF9mbG9hdFxuICBsZXQgaGFzaF9mb2xkX3N0cmluZyA9IEhhc2guZm9sZF9zdHJpbmdcbiAgbGV0IGFzX2ludCBmIHMgeCA9IGhhc2hfZm9sZF9pbnQgcyAoZiB4KVxuXG4gICgqIFRoaXMgaWdub3JlcyB0aGUgc2lnbiBiaXQgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIHVubGlrZWx5IHRvIGxlYWQgdG9cbiAgICAgZnJlcXVlbnQgY29sbGlzaW9ucyAobWluX3ZhbHVlIGNvbGxpZGluZyB3aXRoIDAgaXMgdGhlIG1vc3QgbGlrZWx5IG9uZSkuICAqKVxuICBsZXQgaGFzaF9mb2xkX2ludDMyID0gYXNfaW50IENhbWwuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoQ2FtbC5MYXp5LmZvcmNlIHgpXG4gIGxldCBoYXNoX2ZvbGRfcmVmX2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzICF4XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gcyBhcnJheSBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIGFycmF5XG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZSA9IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSBpblxuICAgICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIGUpIGFycmF5IChpICsgMSkpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9hcnJheV9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyBhcnJheSA9XG4gICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pXG4gICAgICAoKiBbbGVuZ3RoXSBtdXN0IGJlIGluY29ycG9yYXRlZCBmb3IgYXJyYXlzLCBhcyBpdCBpcyBmb3IgbGlzdHMuIFNlZSBjb21tZW50IGFib3ZlICopXG4gICAgICBoYXNoX2ZvbGRfZWxlbVxuICAgICAgKGhhc2hfZm9sZF9pbnQgcyAoQXJyYXkubGVuZ3RoIGFycmF5KSlcbiAgICAgIGFycmF5XG4gICAgICAwXG4gIDs7XG5cbiAgKCogdGhlIGR1cGxpY2F0aW9uIGhlcmUgaXMgYmVjYXVzZSB3ZSB0aGlua1xuICAgICBvY2FtbCBjYW4ndCBlbGltaW5hdGUgaW5kaXJlY3QgZnVuY3Rpb24gY2FsbHMgb3RoZXJ3aXNlLiAqKVxuICBsZXQgaGFzaF9uYXRpdmVpbnQgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX25hdGl2ZWludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfaW50NjQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQ2NCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludDMyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50MzIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9jaGFyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfY2hhciAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2Jvb2wgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9ib29sIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcblxuICBsZXQgaGFzaF9zdHJpbmcgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3N0cmluZyAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZmxvYXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9mbG9hdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX3VuaXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF91bml0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbmVuZFxuXG5tb2R1bGUgRiAoSGFzaCA6IEhhc2hfaW50Zi5TKSA6XG4gIEhhc2hfaW50Zi5GdWxsXG4gIHdpdGggdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIHNlZWQgPSBIYXNoLnNlZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBvZl9mb2xkIGhhc2hfZm9sZF90IHQgPSBnZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3QgKGNyZWF0ZSAoKSkgdClcblxuICBtb2R1bGUgQnVpbHRpbiA9IEZvbGRpbmcgKEhhc2gpXG5cbiAgbGV0IHJ1biA/c2VlZCBmb2xkZXIgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChIYXNoLnJlc2V0ID9zZWVkIChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxoYXNoIDogc2lnXG4gIGluY2x1ZGVcbiAgICBIYXNoX2ludGYuU1xuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnN0YXRlXG4gICAgICgqIFdlIGdpdmUgYSBjb25jcmV0ZSB0eXBlIGZvciBbc3RhdGVdLCBhbGJlaXQgb25seSBwYXJ0aWFsbHkgZXhwb3NlZCAoc2VlXG4gICAgICAgIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzKSwgc28gdGhhdCBpdCB1bmlmaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBpbiBbQmFzZV9ib290XSxcbiAgICAgICAgYW5kIHRvIGFsbG93IG9wdGltaXphdGlvbnMgZm9yIHRoZSBpbW1lZGlhdGUgdHlwZS4gKilcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnNlZWRcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0IDogc3RhdGUgLT4gaW50NjQgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfaW50IDogc3RhdGUgLT4gaW50IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9mbG9hdCA6IHN0YXRlIC0+IGZsb2F0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX3N0cmluZyA6IHN0YXRlIC0+IHN0cmluZyAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGdldF9oYXNoX3ZhbHVlIDogc3RhdGUgLT4gaGFzaF92YWx1ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcIlxuICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCJCYXNlX2hhc2hfZG91YmxlXCIgW0BAbm9hbGxvY11cblxuICAgIGxldCBoYXNoX3VuaXQgKCkgPSAwXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgVFxuIiwib3BlbiBJbXBvcnQwXG5cbmxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG5leHRlcm5hbCBwb2x5bW9ycGhpY19jb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBwb2x5bW9ycGhpY19lcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG5cbm1vZHVsZSBDb21wYXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjb21wYXJlIDogdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2EgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAoJ2EsICdiKSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAnYyBjb21wYXJlIC0+ICgnYSwgJ2IsICdjKSB0IGNvbXBhcmVcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnVpbHRpbiA9IHN0cnVjdFxuICBsZXQgY29tcGFyZV9ib29sIDogYm9vbCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfZmxvYXQgOiBmbG9hdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludCA6IGludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfc3RyaW5nIDogc3RyaW5nIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfdW5pdCA6IHVuaXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgaWYgcGh5c19lcXVhbCBhIGJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgICAgaWYgcmV0IDw+IDBcbiAgICAgIHRoZW4gcmV0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgICAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAwKSlcbiAgOztcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdCBhIGJcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9lbHQgIWEgIWJcbiAgbGV0IGVxdWFsX2Jvb2wgOiBib29sIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfY2hhciA6IGNoYXIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMiA6IGludDMyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjQgOiBpbnQ2NCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA6IG5hdGl2ZWludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZyA6IHN0cmluZyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXQgOiB1bml0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gICgqIFtQb2x5LmVxdWFsXSBpcyBJRUVFIGNvbXBsaWFudCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudCBoZXJlLiAqKVxuICBsZXQgZXF1YWxfZmxvYXQgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0IHggeSkgMFxuXG4gIGxldCBlcXVhbF9hcnJheSBlcXVhbF9lbHQgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8XG4gICAgbGV0IGxlbl9hID0gQXJyYXkwLmxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgZXF1YWwgbGVuX2EgbGVuX2JcbiAgICAmJlxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGkgPSBsZW5fYVxuICAgICAgfHxcbiAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgZXF1YWxfZWx0IGwgciAmJiBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdCBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCBbXSwgXyB8IF8sIFtdIC0+IGZhbHNlXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+IGVxdWFsX2VsdCB4IHkgJiYgZXF1YWxfbGlzdCBlcXVhbF9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGVxdWFsX2VsdCBhIGJcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIGVxdWFsX2VsdCBhIGIgPSBlcXVhbF9lbHQgIWEgIWJcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIGZvciB1c2UgYnkgcHB4X2hhc2gsIGFuZCBpcyB0aHVzIG5vdCBpbiB0aGUgaW50ZXJmYWNlIG9mIEJhc2UuICopXG5tb2R1bGUgU3RkID0gc3RydWN0XG4gIG1vZHVsZSBIYXNoID0gSGFzaCAoKiogQGNhbm9uaWNhbCBCYXNlLkhhc2ggKilcbmVuZFxuXG50eXBlICdhIGhhc2hfZm9sZCA9IFN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFN0ZC5IYXNoLnN0YXRlXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiB0IGhhc2hfZm9sZFxuICAgIHZhbCBoYXNoIDogdCAtPiBTdGQuSGFzaC5oYXNoX3ZhbHVlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2EgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBoYXNoX2ZvbGRfdCA6ICdhIGhhc2hfZm9sZCAtPiAnYiBoYXNoX2ZvbGQgLT4gKCdhLCAnYikgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3RcbiAgICAgIDogICdhIGhhc2hfZm9sZFxuICAgICAgLT4gJ2IgaGFzaF9mb2xkXG4gICAgICAtPiAnYyBoYXNoX2ZvbGRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSB0IGhhc2hfZm9sZFxuICBlbmRcbmVuZFxuIiwib3BlbiBIYXNoLkJ1aWx0aW5cbm9wZW4gUHB4X2NvbXBhcmVfbGliLkJ1aWx0aW5cbmluY2x1ZGUgU2V4cGxpYjAuU2V4cFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPSBTZXhwbGliMC5TZXhwLnQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG5sZXQgcmVjIGNvbXBhcmUgPVxuICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZyBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgIHwgVzY0IC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlc2NFwiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBudW1fYml0cyA9IGZ1bmN0aW9uXG4gIHwgVzMyIC0+IDMyXG4gIHwgVzY0IC0+IDY0XG47O1xuXG5sZXQgd29yZF9zaXplID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZV9pbl9iaXRzIHdpdGhcbiAgfCAzMiAtPiBXMzJcbiAgfCA2NCAtPiBXNjRcbiAgfCBfIC0+IGZhaWx3aXRoIFwidW5rbm93biB3b3JkIHNpemVcIlxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgciA9IHJlZiBbIFwiQmFzZS5TZXhwLnBwX2h1bVwiIF1cbmxldCBhbGwgKCkgPSAhclxubGV0IHJlZ2lzdGVyIHAgPSByIDo9IHAgOjogIXJcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgcHAgOiBGb3JtYXR0ZXIudCAtPiB0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXJfcHAgKE0gOiBzaWdcbiAgICBpbmNsdWRlIFNcblxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICBsZXQgKCkgPSByZWdpc3RlciAoTS5tb2R1bGVfbmFtZSBeIFwiLnBwXCIpXG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyIChNIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG4gIFJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIGxldCBwcCBmb3JtYXR0ZXIgdCA9IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgKE0udG9fc3RyaW5nIHQpXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBDYW1sLmV4aXRcblxuZXhjZXB0aW9uIEZpbmFsbHkgb2YgdCAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGaW5hbGx5XSAoZnVuY3Rpb25cbiAgICB8IEZpbmFsbHkgKGFyZzBfXzAwMV8sIGFyZzFfXzAwMl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDAzXyA9IHNleHBfb2ZfdCBhcmcwX18wMDFfXG4gICAgICBhbmQgcmVzMV9fMDA0XyA9IHNleHBfb2ZfdCBhcmcxX18wMDJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuRmluYWxseVwiOyByZXMwX18wMDNfOyByZXMxX18wMDRfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFJlcmFpc2VkIG9mIHN0cmluZyAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBSZXJhaXNlZF0gKGZ1bmN0aW9uXG4gICAgfCBSZXJhaXNlZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgIGxldCByZXMwX18wMDdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA1X1xuICAgICAgYW5kIHJlczFfXzAwOF8gPSBzZXhwX29mX3QgYXJnMV9fMDA2XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLlJlcmFpc2VkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gU2V4cCBvZiBTZXhwLnRcblxuKCogV2UgaW5zdGFsbCBhIGN1c3RvbSBleG4tY29udmVydGVyIHJhdGhlciB0aGFuIHVzZTpcblxuICAge1tcbiAgICAgZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuICAgICAoKiAuLi4gKilcbiAgICAgW0BAQGVuZF1cbiAgIF19XG5cbiAgIHRvIGVsaW1pbmF0ZSB0aGUgZXh0cmEgd3JhcHBpbmcgb2YgWyhTZXhwIC4uLildLiAqKVxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNleHBdIChmdW5jdGlvblxuICAgIHwgU2V4cCB0IC0+IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBTZXhwIHNleHBcblxubGV0IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIHQgYmFja3RyYWNlID1cbiAgQ2FtbC5QcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB0IGJhY2t0cmFjZVxuOztcblxuZXh0ZXJuYWwgaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCA6IHQgLT4gYm9vbCA9IFwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG5cIlxuXG5sZXQgcmVyYWlzZSBleG4gc3RyID1cbiAgbGV0IGV4bicgPSBSZXJhaXNlZCAoc3RyLCBleG4pIGluXG4gIGlmIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuXG4gIHRoZW4gKFxuICAgIGxldCBidCA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgKG1hdGNoIGZpbmFsbHkgeCB3aXRoXG4gICAgIHwgKCkgLT4gcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuIGJ0XG4gICAgIHwgZXhjZXB0aW9uIGZpbmFsX2V4biAtPlxuICAgICAgICgqIFVuZm9ydHVuYXRlbHksIHRoZSBiYWNrdHJhY2Ugb2YgdGhlIFtmaW5hbF9leG5dIGlzIGRpc2NhcmRlZCBoZXJlLiAqKVxuICAgICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChGaW5hbGx5IChleG4sIGZpbmFsX2V4bikpIGJ0KVxuOztcblxubGV0IHByb3RlY3QgfmYgfmZpbmFsbHkgPSBwcm90ZWN0eCB+ZiAoKSB+ZmluYWxseVxuXG5sZXQgZG9lc19yYWlzZSAodHlwZSBhKSAoZiA6IHVuaXQgLT4gYSkgPVxuICB0cnlcbiAgICBpZ25vcmUgKGYgKCkgOiBhKTtcbiAgICBmYWxzZVxuICB3aXRoXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBleG5cblxuICAgIGxldCBwcCBwcGYgdCA9XG4gICAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgdCB3aXRoXG4gICAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgICAgfCBOb25lIC0+IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKENhbWwuUHJpbnRleGMudG9fc3RyaW5nIHQpXG4gICAgOztcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuICBlbmQpXG5cbmxldCBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSA9XG4gIENhbWwuRm9ybWF0LmVwcmludGYgXCJAWzwyPlVuY2F1Z2h0IGV4Y2VwdGlvbjpAXFxuQFxcbkBbJWFAXUBdQFxcbkAuXCIgcHAgZXhjO1xuICBpZiBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBDYW1sLlByaW50ZXhjLnByaW50X3Jhd19iYWNrdHJhY2UgQ2FtbC5zdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgQ2FtbC5mbHVzaCBDYW1sLnN0ZGVyclxuOztcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKSA9XG4gIENhbWwuUHJpbnRleGMuc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHByaW50X3dpdGhfYmFja3RyYWNlXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2F1eCB+ZG9fYXRfZXhpdCB+ZXhpdCBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4YyAtPlxuICAgIGxldCByYXdfYmFja3RyYWNlID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgQ2FtbC5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgXyAtPiAoKSk7XG4gICAgKHRyeSBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnlcbiAgICAgICAgICBDYW1sLlByaW50Zi5lcHJpbnRmIFwiRXhuLmhhbmRsZV91bmNhdWdodCBjb3VsZCBub3QgcHJpbnQ7IGV4aXRpbmcgYW55d2F5XFxuJSFcIlxuICAgICAgICB3aXRoXG4gICAgICAgIHwgXyAtPiAoKSkpO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmID0gaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0IH5kb19hdF9leGl0OnRydWVcblxubGV0IGhhbmRsZV91bmNhdWdodCB+ZXhpdDptdXN0X2V4aXQgZiA9XG4gIGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdDooaWYgbXVzdF9leGl0IHRoZW4gZXhpdCBlbHNlIGlnbm9yZSkgfmRvX2F0X2V4aXQ6bXVzdF9leGl0XG47O1xuXG5sZXQgcmVyYWlzZV91bmNhdWdodCBzdHIgZnVuYyA9XG4gIHRyeSBmdW5jICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIENhbWwucmFpc2Vfbm90cmFjZSBlXG47O1xuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKClcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsZWFyX2JhY2t0cmFjZSA9IGNsZWFyX2JhY2t0cmFjZVxuZW5kXG4iLCIoKiBiZWxvbmdzIGluIENvbW1vbiwgYnV0IG1vdmVkIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHJldHVybiA9IHsgcmV0dXJuIDogJ2IuICdhIC0+ICdiIH0gW0BAdW5ib3hlZF1cblxubGV0IHdpdGhfcmV0dXJuICh0eXBlIGEpIGYgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAoKiBSYWlzZWQgdG8gaW5kaWNhdGUgfnJldHVybiB3YXMgY2FsbGVkLiAgTG9jYWwgc28gdGhhdCB0aGUgZXhjZXB0aW9uIGlzIHRpZWQgdG8gYVxuICAgICAgIHBhcnRpY3VsYXIgY2FsbCBvZiBbd2l0aF9yZXR1cm5dLiAqKVxuICAgIGV4Y2VwdGlvbiBSZXR1cm4gb2YgYVxuICBlbmRcbiAgaW5cbiAgbGV0IGlzX2FsaXZlID0gcmVmIHRydWUgaW5cbiAgbGV0IHJldHVybiBhID1cbiAgICBpZiBub3QgIWlzX2FsaXZlXG4gICAgdGhlbiBmYWlsd2l0aCBcInVzZSBvZiBbcmV0dXJuXSBmcm9tIGEgW3dpdGhfcmV0dXJuXSB0aGF0IGFscmVhZHkgcmV0dXJuZWRcIjtcbiAgICBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgKE0uUmV0dXJuIGEpXG4gIGluXG4gIHRyeVxuICAgIGxldCBhID0gZiB7IHJldHVybiB9IGluXG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgYVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgKG1hdGNoIGV4biB3aXRoXG4gICAgIHwgTS5SZXR1cm4gYSAtPiBhXG4gICAgIHwgXyAtPiByYWlzZSBleG4pXG47O1xuXG5sZXQgd2l0aF9yZXR1cm5fb3B0aW9uIGYgPVxuICB3aXRoX3JldHVybiAoZnVuIHJldHVybiAtPlxuICAgIGYgeyByZXR1cm4gPSAoZnVuIGEgLT4gcmV0dXJuLnJldHVybiAoU29tZSBhKSkgfTtcbiAgICBOb25lKVxuOztcblxubGV0IHByZXBlbmQgeyByZXR1cm4gfSB+ZiA9IHsgcmV0dXJuID0gKGZ1biB4IC0+IHJldHVybiAoZiB4KSkgfVxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSB0eXBlIEJhc2ljID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgKCoqIFRoZSBmb2xsb3dpbmcgaWRlbnRpdGllcyBvdWdodCB0byBob2xkIChmb3Igc29tZSB2YWx1ZSBvZiA9KTpcblxuICAgICAgLSBbcmV0dXJuIHggPj49IGYgPSBmIHhdXG4gICAgICAtIFt0ID4+PSBmdW4geCAtPiByZXR1cm4geCA9IHRdXG4gICAgICAtIFsodCA+Pj0gZikgPj49IGcgPSB0ID4+PSBmdW4geCAtPiAoZiB4ID4+PSBnKV1cblxuICAgICAgTm90ZTogWz4+PV0gaXMgdGhlIGluZml4IG5vdGF0aW9uIGZvciBbYmluZF0pICopXG5cbiAgKCoqIFRoZSBbbWFwXSBhcmd1bWVudCB0byBbTW9uYWQuTWFrZV0gc2F5cyBob3cgdG8gaW1wbGVtZW50IHRoZSBtb25hZCdzIFttYXBdIGZ1bmN0aW9uLlxuICAgICAgW2BEZWZpbmVfdXNpbmdfYmluZF0gbWVhbnMgdG8gZGVmaW5lIFttYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC5cblxuICAgICAgU29tZSBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW01vbmFkLk1ha2VdIGFyZSBkZWZpbmVkIGluIHRlcm1zIG9mIFttYXBdLCBzb1xuICAgICAgcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFttYXBdIHdpbGwgaW1wcm92ZSB0aGVpciBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBtYXAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdCBdXG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXggPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIFt0ID4+PSBmXSByZXR1cm5zIGEgY29tcHV0YXRpb24gdGhhdCBzZXF1ZW5jZXMgdGhlIGNvbXB1dGF0aW9ucyByZXByZXNlbnRlZCBieSB0d29cbiAgICAgIG1vbmFkIGVsZW1lbnRzLiAgVGhlIHJlc3VsdGluZyBjb21wdXRhdGlvbiBmaXJzdCBkb2VzIFt0XSB0byB5aWVsZCBhIHZhbHVlIFt2XSwgYW5kXG4gICAgICB0aGVuIHJ1bnMgdGhlIGNvbXB1dGF0aW9uIHJldHVybmVkIGJ5IFtmIHZdLiAqKVxuICB2YWwgKCA+Pj0gKSA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiogW3QgPj58IGZdIGlzIFt0ID4+PSAoZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uICopXG4gIHZhbCAoID4+fCApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IpIC0+ICdiIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXggPSBzaWdcbiAgKCoqIE9wZW5pbmcgYSBtb2R1bGUgb2YgdGhpcyB0eXBlIGFsbG93cyBvbmUgdG8gdXNlIHRoZSBbJWJpbmRdIGFuZCBbJW1hcF0gc3ludGF4XG4gICAgICBleHRlbnNpb25zIGRlZmluZWQgYnkgcHB4X2xldCwgYW5kIGJyaW5ncyBbcmV0dXJuXSBpbnRvIHNjb3BlLiAqKVxuXG4gIHR5cGUgJ2EgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgKCoqIFRoZXNlIGFyZSBjb252ZW5pZW50IHRvIGhhdmUgaW4gc2NvcGUgd2hlbiBwcm9ncmFtbWluZyB3aXRoIGEgbW9uYWQ6ICopXG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICAgaW5jbHVkZSBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgICAgIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gICAgICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICAgICAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtiaW5kIHQgfmZdID0gW3QgPj49IGZdICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFtyZXR1cm4gdl0gcmV0dXJucyB0aGUgKHRyaXZpYWwpIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyB2LiAqKVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBbbWFwIHQgfmZdIGlzIHQgPj58IGYuICopXG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG5cbiAgKCoqIFtqb2luIHRdIGlzIFt0ID4+PSAoZnVuIHQnIC0+IHQnKV0uICopXG4gIHZhbCBqb2luIDogJ2EgdCB0IC0+ICdhIHRcblxuICAoKiogW2lnbm9yZV9tIHRdIGlzIFttYXAgdCB+ZjooZnVuIF8gLT4gKCkpXS4gIFtpZ25vcmVfbV0gdXNlZCB0byBiZSBjYWxsZWQgW2lnbm9yZV0sXG4gICAgICBidXQgd2UgZGVjaWRlZCB0aGF0IHdhcyBhIGJhZCBuYW1lLCBiZWNhdXNlIGl0IHNoYWRvd2VkIHRoZSB3aWRlbHkgdXNlZFxuICAgICAgW0NhbWwuaWdub3JlXS4gIFNvbWUgbW9uYWRzIHN0aWxsIGRvIFtsZXQgaWdub3JlID0gaWdub3JlX21dIGZvciBoaXN0b3JpY2FsXG4gICAgICByZWFzb25zLiAqKVxuICB2YWwgaWdub3JlX20gOiAnYSB0IC0+IHVuaXQgdFxuXG4gIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgKCoqIExpa2UgW2FsbF0sIGJ1dCBlbnN1cmVzIHRoYXQgZXZlcnkgbW9uYWRpYyB2YWx1ZSBpbiB0aGUgbGlzdCBwcm9kdWNlcyBhIHVuaXQgdmFsdWUsXG4gICAgICBhbGwgb2Ygd2hpY2ggYXJlIGRpc2NhcmRlZCByYXRoZXIgdGhhbiBiZWluZyBjb2xsZWN0ZWQgaW50byBhIGxpc3QuICopXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTeW50YXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMiA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBnZXRzIHVuaWZpZWQgYWNyb3NzIGFsbCB0aGUgY29tcHV0YXRpb24uXG4gICAgICBUaGlzIGlzIHVzZWQgdG8gZW5jb2RlIG1vbmFkcyB3b3JraW5nIG9uIGEgbXVsdGkgcGFyYW1ldGVyIGRhdGEgc3RydWN0dXJlIGxpa2VcbiAgICAgIChbKCdhLCdiKSByZXN1bHRdKS4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgbWFwIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHQgXVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgyID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MiA9IHNpZ1xuICB0eXBlICgnYSwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZSkgdCAtPiAoJ2IsICdlKSB0IC0+ICgnYSAqICdiLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdHdvIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBpcyBhbHdheXMganVzdFxuICAgICAgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBpbmNsdWRlIFN5bnRheDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnZSkgdCwgJ2UpIHQgLT4gKCdhLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2UpIHQgLT4gKHVuaXQsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMyA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGdldCB1bmlmaWVkIGFjcm9zcyBhbGwgdGhlXG4gICAgICBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0IF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgzID0gc2lnXG4gICgqKiBTYW1lIGFzIEluZml4LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmQgdGhpcmQgYXJlXG4gICAgICBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheDMgPSBzaWdcbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuXG4gICAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdiLCAnZCwgJ2UpIHQgLT4gKCdhICogJ2IsICdkLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kXG4gICAgICBhbmQgdGhpcmQgYXJlIGFsd2F5cyBqdXN0IHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBpbmNsdWRlIEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgaW5jbHVkZSBTeW50YXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2QsICdlKSB0LCAnZCwgJ2UpIHQgLT4gKCdhLCAnZCwgJ2UpIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdkLCAnZSkgdCAtPiAodW5pdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdkLCAnZSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnZCwgJ2UpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdkLCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gc2lnXG4gICgqKiBJbmRleGVkIG1vbmFkLCBpbiB0aGUgc3R5bGUgb2YgQXRrZXkuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnMgYXJlIGNvbXBvc2VkXG4gICAgICBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiBUbyBzZWUgdGhpcyBtb3JlIGNsZWFybHksIHlvdSBjYW4gbG9vayBhdCB0aGUgdHlwZSBvZiBiaW5kOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICAgICAgXX1cblxuICAgICAgYW5kIGlzb2xhdGUgc29tZSBvZiB0aGUgdHlwZSB2YXJpYWJsZXMgdG8gc2VlIHRoZWlyIGluZGl2aWR1YWwgYmVoYXZpb3JzOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICdhICAgICAgICAgICAgIC0+IGY6KCdhIC0+ICAnYiAgICAgICAgICAgKSAtPiAgJ2JcbiAgICAgICAgdmFsIGJpbmQgOiAgICAgICdpLCAnaiAgICAtPiAgICAgICAgICAgICAgICdqLCAnayAgICAgLT4gICAgICdpLCAna1xuICAgICAgXX1cblxuICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQXRrZXktc3R5bGUgaW5kZXhlZCBtb25hZHMsIHNlZTpcblxuICAgICAge3ZcbiAgICAgICAgUGFyYW1ldGVyaXNlZCBOb3Rpb25zIG9mIENvbXB1dGF0aW9uXG4gICAgICAgIFJvYmVydCBBdGtleVxuICAgICAgICBodHRwOi8vYmVudG5pYi5vcmcvcGFyYW1ub3Rpb25zLWpmcC5wZGZcbiAgICAgIHZ9ICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuXG4gICAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdiLCAnaiwgJ2spIHQgLT4gKCdhICogJ2IsICdpLCAnaykgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfaW5kZXhlZCA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmRcbiAgICAgIHRoaXJkIGFyZSBjb21wb3NlZCBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBpbmNsdWRlIEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIGluY2x1ZGUgU3ludGF4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnaiwgJ2spIHQsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaykgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2ksICdqKSB0IC0+ICh1bml0LCAnaSwgJ2opIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2ksICdpKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdpLCAnaSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2ksICdpKSB0IGxpc3QgLT4gKHVuaXQsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTX3RvX1NfaW5kZXhlZCAoWCA6IFMpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUzIgKFggOiBTMykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgU19pbmRleGVkX3RvX1MyIChYIDogU19pbmRleGVkKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudCA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1vbmFkID0gc2lnXG4gICgqKiBBIG1vbmFkIGlzIGFuIGFic3RyYWN0aW9uIG9mIHRoZSBjb25jZXB0IG9mIHNlcXVlbmNpbmcgb2YgY29tcHV0YXRpb25zLiAgQSB2YWx1ZSBvZlxuICAgICAgdHlwZSBbJ2EgbW9uYWRdIHJlcHJlc2VudHMgYSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIFsnYV0uICopXG5cbiAgbW9kdWxlIHR5cGUgQmFzaWMgPSBCYXNpY1xuICBtb2R1bGUgdHlwZSBCYXNpYzIgPSBCYXNpYzJcbiAgbW9kdWxlIHR5cGUgQmFzaWMzID0gQmFzaWMzXG4gIG1vZHVsZSB0eXBlIEJhc2ljX2luZGV4ZWQgPSBCYXNpY19pbmRleGVkXG4gIG1vZHVsZSB0eXBlIEluZml4ID0gSW5maXhcbiAgbW9kdWxlIHR5cGUgSW5maXgyID0gSW5maXgyXG4gIG1vZHVsZSB0eXBlIEluZml4MyA9IEluZml4M1xuICBtb2R1bGUgdHlwZSBJbmZpeF9pbmRleGVkID0gSW5maXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTeW50YXggPSBTeW50YXhcbiAgbW9kdWxlIHR5cGUgU3ludGF4MiA9IFN5bnRheDJcbiAgbW9kdWxlIHR5cGUgU3ludGF4MyA9IFN5bnRheDNcbiAgbW9kdWxlIHR5cGUgU3ludGF4X2luZGV4ZWQgPSBTeW50YXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gU193aXRob3V0X3N5bnRheFxuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gIG1vZHVsZSB0eXBlIFMzID0gUzNcbiAgbW9kdWxlIHR5cGUgU19pbmRleGVkID0gU19pbmRleGVkXG5cbiAgbW9kdWxlIE1ha2UgKFggOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudFxuICBtb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50XG4gIG1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gIG1vZHVsZSBNYWtlX2luZGV4ZWQgKFggOiBCYXNpY19pbmRleGVkKSA6XG4gICAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50XG5cbiAgKCoqIERlZmluZSBhIG1vbmFkIHRocm91Z2ggYW4gaXNvbW9ycGhpc20gd2l0aCBhbiBleGlzdGluZyBtb25hZC4gRm9yIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgJ2EgdCA9IHsgdmFsdWUgOiAnYSB9XG5cbiAgICAgICAgaW5jbHVkZSBNb25hZC5PZl9tb25hZCAoTW9uYWQuSWRlbnQpIChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgICAgICAgIGxldCB0b19tb25hZCB7IHZhbHVlIH0gPSB2YWx1ZVxuICAgICAgICAgICAgbGV0IG9mX21vbmFkIHZhbHVlID0geyB2YWx1ZSB9XG4gICAgICAgICAgZW5kKVxuICAgICAgXX0gKilcbiAgbW9kdWxlIE9mX21vbmFkXG4gICAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgZW5kKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkMlxuICAgICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDNcbiAgICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50XG5cbiAgbW9kdWxlIElkZW50IDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNb25hZF9pbnRmXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2dlbmVyYWwgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmRcbiAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmRcbiAgICAgIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5lcmFsIChNIDogQmFzaWNfZ2VuZXJhbCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmQgPSBNLmJpbmRcbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gIGxldCBtYXBfdmlhX2JpbmQgbWEgfmYgPSBNLmJpbmQgbWEgfmY6KGZ1biBhIC0+IE0ucmV0dXJuIChmIGEpKVxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIE0ubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYmluZCAtPiBtYXBfdmlhX2JpbmRcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG4gICAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggYSBiID0gYSA+Pj0gZnVuIGEgLT4gYiA+PnwgZnVuIGIgLT4gYSwgYlxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBqb2luIHQgPSB0ID4+PSBmdW4gdCcgLT4gdCdcbiAgbGV0IGlnbm9yZV9tIHQgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpXG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9pbmRleGVkIChNIDogQmFzaWNfaW5kZXhlZCkgOlxuICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMyAoTSA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIE0udCA9XG4gIE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UyIChNIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0IDo9ICgnYSwgJ2QpIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoTSA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9nZW5lcmFsIChNb25hZCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gICAgdmFsIGJpbmRcbiAgICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG4gIGVuZCkgKE0gOiBzaWdcbiAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudFxuICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgICBlbmQpID1cbiAgTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNLnRcblxuICAgIGxldCByZXR1cm4gYSA9IE0ub2ZfbW9uYWQgKE1vbmFkLnJldHVybiBhKVxuICAgIGxldCBiaW5kIHQgfmYgPSBNLm9mX21vbmFkIChNb25hZC5iaW5kIChNLnRvX21vbmFkIHQpIH5mOihmdW4gYSAtPiBNLnRvX21vbmFkIChmIGEpKSlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIHQgfmYgLT4gTS5vZl9tb25hZCAoTW9uYWQubWFwIChNLnRvX21vbmFkIHQpIH5mKSlcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQzXG4gICAgKE1vbmFkIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiLCAnYykgTW9uYWQudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyXG4gICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZFxuICAgIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICAgIGVuZClcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCBiaW5kIGEgfmYgPSBmIGFcbiAgICAgIGxldCByZXR1cm4gYSA9IGFcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gYSB+ZiAtPiBmIGEpXG4gICAgZW5kKVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuXG4oKiogVGhpcyBtb2R1bGUgc2VydmVzIG1vc3RseSBhcyBhIHBhcnRpYWwgY2hlY2sgdGhhdCBbUzJdIGFuZCBbU10gYXJlIGluIHN5bmMsIGJ1dFxuICAgIGFjdHVhbGx5IGNhbGxpbmcgaXQgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bC4gKilcbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYXBwbHkgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IG1hcDIgdGEgdGIgfmYgPSBtYXAgfmYgdGEgPCo+IHRiXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwIH5mIHRhIDwqPiB0YiA8Kj4gdGNcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgKCAqPiApIHUgdiA9IHJldHVybiAoZnVuICgpIHkgLT4geSkgPCo+IHUgPCo+IHZcbiAgbGV0ICggPCogKSB1IHYgPSByZXR1cm4gKGZ1biB4ICgpIC0+IHgpIDwqPiB1IDwqPiB2XG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTMgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4M1xuICAgIChYIDogRm9yX2xldF9zeW50YXgzKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gSW1wbFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4MlxuICAgIChYIDogRm9yX2xldF9zeW50YXgyKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4M1xuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgJ2QsIF8pIHQgPSAoJ2EsICdkKSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXhcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4KSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0eXBlIFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbigqKiBUaGlzIGZ1bmN0b3IgY2xvc2VseSByZXNlbWJsZXMgW01ha2UzXSwgYW5kIGluZGVlZCBpdCBjb3VsZCBiZSBpbXBsZW1lbnRlZFxuICAgIG11Y2ggc2hvcnRlciBpbiB0ZXJtcyBvZiBbTWFrZTNdLiBIb3dldmVyLCB3ZSBpbXBsZW1lbnQgaXQgYnkgaGFuZCBzbyB0aGF0XG4gICAgdGhlIHJlc3VsdGluZyBmdW5jdGlvbnMgYXJlIG1vcmUgZWZmaWNpZW50LCBlLmcuIHVzaW5nIFttYXAyXSBkaXJlY3RseSBpbnN0ZWFkIG9mXG4gICAgZGVmaW5pbmcgW2FwcGx5XSBpbiB0ZXJtcyBvZiBpdCBhbmQgdGhlbiBbbWFwMl0gaW4gdGVybXMgb2YgdGhhdC4gRm9yIG1vc3RcbiAgICBhcHBsaWNhdGl2ZXMgdGhpcyBkb2VzIG5vdCBtYXR0ZXIsIGJ1dCBmb3Igc29tZSAoc3VjaCBhcyBCb25zYWkuVmFsdWUudCksIGl0IGhhcyBhXG4gICAgbGFyZ2VyIGltcGFjdC4gKilcbm1vZHVsZSBNYWtlM191c2luZ19tYXAyIChYIDogQmFzaWMzX3VzaW5nX21hcDIpIDpcbiAgUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0IGFwcGx5IHRmIHRhID0gbWFwMiB0ZiB0YSB+ZjooZnVuIGYgYSAtPiBmIGEpXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfbWFwMiAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPSBtYXAyIChtYXAyIHRhIHRiIH5mKSB0YyB+ZjooZnVuIGZhYiBjIC0+IGZhYiBjKVxuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0ICggKj4gKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuICgpIHkgLT4geSlcbiAgbGV0ICggPCogKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuIHggKCkgLT4geClcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMl91c2luZ19tYXAyIChYIDogQmFzaWMyX3VzaW5nX21hcDIpIDpcbiAgUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTNfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfdXNpbmdfbWFwMiAoWCA6IEJhc2ljX3VzaW5nX21hcDIpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPVxuICBNYWtlMl91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDIgKE0gOiBNb25hZC5TMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBNLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgTS50XG5cbiAgICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgICBsZXQgYXBwbHkgbWYgbXggPSBNLmJpbmQgbWYgfmY6KGZ1biBmIC0+IE0ubWFwIG14IH5mKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIE0ubWFwXG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkIChNIDogTW9uYWQuUykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE9mX21vbmFkMiAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgXykgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBDb21wb3NlIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRy5yZXR1cm4gKEYucmV0dXJuIGEpXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBHLmFwcGx5IChHLm1hcCB+ZjpGLmFwcGx5IHRmKSB0eFxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEcubWFwIH5mOihGLm1hcCB+ZikgdFxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgUGFpciAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgcmV0dXJuIGEgPSBGLnJldHVybiBhLCBHLnJldHVybiBhXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBGLmFwcGx5IChmc3QgdGYpIChmc3QgdHgpLCBHLmFwcGx5IChzbmQgdGYpIChzbmQgdHgpXG4gICAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRi5tYXAgfmYgKGZzdCB0KSwgRy5tYXAgfmYgKHNuZCB0KVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuIiwiKCogW0J5dGVzMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbC5CeXRlc10uIFtCeXRlczBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzc1xuICAgdGhlIHBhcnQgb2YgW0NhbWwuQnl0ZXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGJ5dGVzMC5tbCBzaG91bGQgdXNlIFtDYW1sLkJ5dGVzXS4gW0J5dGVzMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZFxuICAgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5CeXRlc10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEJ5dGVzICA9IEJ5dGVzMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBCeXRlcyA9IEJ5dGVzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5CeXRlc10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBQcmltaXRpdmVzID0gc3RydWN0XG4gIGV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0ICAgICAgICA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5cbiAgKCogW3Vuc2FmZV9ibGl0X3N0cmluZ10gaXMgbm90IGV4cG9ydGVkIGluIHRoZSBbc3RkbGliXSBzbyB3ZSBleHBvcnQgaXQgaGVyZSAqKVxuICBleHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICA6ICBzcmM6c3RyaW5nXG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6Ynl0ZXNcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0dVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmVuZFxuXG5pbmNsdWRlIFByaW1pdGl2ZXNcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBibGl0ID0gQ2FtbC5CeXRlcy5ibGl0XG5sZXQgYmxpdF9zdHJpbmcgPSBDYW1sLkJ5dGVzLmJsaXRfc3RyaW5nXG5sZXQgY29tcGFyZSA9IENhbWwuQnl0ZXMuY29tcGFyZVxubGV0IGNvcHkgPSBDYW1sLkJ5dGVzLmNvcHlcbmxldCBjcmVhdGUgPSBDYW1sLkJ5dGVzLmNyZWF0ZVxubGV0IGZpbGwgPSBDYW1sLkJ5dGVzLmZpbGxcbmxldCBtYWtlID0gQ2FtbC5CeXRlcy5tYWtlXG5sZXQgbWFwID0gQ2FtbC5CeXRlcy5tYXBcbmxldCBtYXBpID0gQ2FtbC5CeXRlcy5tYXBpXG5sZXQgc3ViID0gQ2FtbC5CeXRlcy5zdWJcbmxldCB1bnNhZmVfYmxpdCA9IENhbWwuQnl0ZXMudW5zYWZlX2JsaXRcbmxldCB0b19zdHJpbmcgPSBDYW1sLkJ5dGVzLnRvX3N0cmluZ1xubGV0IG9mX3N0cmluZyA9IENhbWwuQnl0ZXMub2Zfc3RyaW5nXG5sZXQgdW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpzID0gQ2FtbC5CeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcbmxldCB1bnNhZmVfb2Zfc3RyaW5nX3Byb21pc2Vfbm9fbXV0YXRpb24gPSBDYW1sLkJ5dGVzLnVuc2FmZV9vZl9zdHJpbmdcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ3dpdG5lc3MpIHQgPVxuICB7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2IpIGNvbXBhcmF0b3IgPSAoJ2EsICdiKSB0XG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAodCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EgdCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgU19mYyA9IHNpZ1xuICB0eXBlIGNvbXBhcmFibGVfdFxuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgdCA6PSBjb21wYXJhYmxlX3RcbmVuZFxuXG5tb2R1bGUgTW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdiKVxuZW5kXG5cbmxldCBtYWtlICh0eXBlIHQpIH5jb21wYXJlIH5zZXhwX29mX3QgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgY29tcGFyYWJsZV90ID0gdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kIDogU19mY1xuICAgIHdpdGggdHlwZSBjb21wYXJhYmxlX3QgPSB0KVxuOztcblxubW9kdWxlIFNfdG9fUzEgKFMgOiBTKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBTLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBTLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIG9wZW4gU1xuXG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBNYWtlIChNIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICdhIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgXyA9IFNleHAuQXRvbSBcIl9cIlxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIGNvbXBhcmF0b3IgLT4gKCdhIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQgKE0gOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wX2EpIGNvbXBhcmF0b3JcbiAgICAtPiAoJ2IsICdjbXBfYikgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsICdiKSB0LCAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkMiAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2EsICdiKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhIGIgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdFxuICAgIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcCkgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsIF8pIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWRfcGhhbnRvbSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYSwgXykgdCAtPiBTZXhwLnRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wX2EgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOlxuICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICdmICdzLlxuICAoU2V4cGxpYjAuU2V4cC50IC0+ICdmKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdzKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKCdmLCAncykgdFxuICA9XG4gIGZ1biAodHlwZSBmX18wMjNfIHNfXzAyNF8pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjNfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAyNF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAgIC0+IChmX18wMjNfLCBzX18wMjRfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAxMV8gPSBcImVpdGhlcjAubWwudFwiIGluXG4gICAgZnVuIF9vZl9mX18wMDdfIF9vZl9zX18wMDhfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2ZfXzAwN18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgICBGaXJzdCByZXMwX18wMTdfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMTlfKSA6OiBzZXhwX2FyZ3NfXzAyMF8pIGFzXG4gICAgICAgIF9zZXhwX18wMThfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyMF8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAyMV8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9zX18wMDhfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgICAgU2Vjb25kIHJlczBfXzAyMl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTFfXG4gICAgICAgICAgICAgX3RhZ19fMDE5X1xuICAgICAgICAgICAgIF9zZXhwX18wMThfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgc2V4cF9fMDEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTJfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICdmICdzLlxuICAoJ2YgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2YsICdzKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBmX18wMzFfIHNfXzAzMl8pXG4gICAgICA6ICAoKGZfXzAzMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDMyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGZfXzAzMV8sIHNfXzAzMl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfZl9fMDI1XyBfb2Zfc19fMDI2XyAtPiBmdW5jdGlvblxuICAgICAgfCBGaXJzdCBhcmcwX18wMjdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2ZfXzAyNV8gYXJnMF9fMDI3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJGaXJzdFwiOyByZXMwX18wMjhfIF1cbiAgICAgIHwgU2Vjb25kIGFyZzBfXzAyOV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMF8gPSBfb2Zfc19fMDI2XyBhcmcwX18wMjlfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNlY29uZFwiOyByZXMwX18wMzBfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nZl9zZXhwX2dyYW1tYXIgXydzX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRmlyc3RcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlNlY29uZFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nc19zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cbiIsIigqIFRoZSB0eXBlIFt0XSBzaG91bGQgYmUgYWJzdHJhY3QgdG8gbWFrZSB0aGUgZnNldCBhbmQgc2V0IGZ1bmN0aW9ucyB1bmF2YWlsYWJsZVxuICAgZm9yIHByaXZhdGUgdHlwZXMgYXQgdGhlIGxldmVsIG9mIHR5cGVzIChhbmQgbm90IGJ5IHB1dHRpbmcgTm9uZSBpbiB0aGUgZmllbGQpLlxuICAgVW5mb3J0dW5hdGVseSwgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0IG1lYW5zIHRoYXQgd2hlbiBjcmVhdGluZyBmaWVsZHMgKHRocm91Z2hcbiAgIGEgW2NyZWF0ZV0gZnVuY3Rpb24pIHZhbHVlIHJlc3RyaWN0aW9uIGtpY2tzIGluLiBUaGlzIGlzIHdvcmtlZCBhcm91bmQgYnkgaW5zdGVhZFxuICAgbm90IG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCwgYnV0IGZvcmNpbmcgYW55b25lIGJyZWFraW5nIHRoZSBhYnN0cmFjdGlvbiB0byB1c2VcbiAgIHRoZSBbRm9yX2dlbmVyYXRlZF9jb2RlXSBtb2R1bGUsIG1ha2luZyBpdCBvYnZpb3VzIHRvIGFueSByZWFkZXIgdGhhdCBzb21ldGhpbmcgdWdseVxuICAgaXMgZ29pbmcgb24uXG4gICB0X3dpdGhfcGVybSAoYW5kIGRlcml2YXRpdmVzKSBpcyB0aGUgdHlwZSB0aGF0IHVzZXJzIHJlYWxseSB1c2UuIEl0IGlzIGEgY29uc3RydWN0b3JcbiAgIGJlY2F1c2U6XG4gICAxLiBpdCBtYWtlcyB0eXBlIGVycm9ycyBtb3JlIHJlYWRhYmxlIChsZXNzIGFsaWFzaW5nKVxuICAgMi4gdGhlIHR5cGVyIGluIG9jYW1sIDQuMDEgYWxsb3dzIHRoaXM6XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBBID0gc3RydWN0XG4gICAgICAgdHlwZSB0ID0ge2EgOiBpbnR9XG4gICAgIGVuZFxuICAgICB0eXBlIHQgPSBBLnRcbiAgICAgbGV0IGYgKHggOiB0KSA9IHguYVxuICAgXX1cblxuICAgKGFsdGhvdWdoIHdpdGggV2FybmluZyA0MDogYSBpcyB1c2VkIG91dCBvZiBzY29wZSlcbiAgIHdoaWNoIG1lYW5zIHRoYXQgaWYgW3Rfd2l0aF9wZXJtXSB3YXMgcmVhbGx5IGFuIGFsaWFzIG9uIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0sXG4gICBwZW9wbGUgY291bGQgc2F5IFt0LnNldHRlcl0gYW5kIGJyZWFrIHRoZSBhYnN0cmFjdGlvbiB3aXRoIG5vIGluZGljYXRpb24gdGhhdFxuICAgc29tZXRoaW5nIHVnbHkgaXMgZ29pbmcgb24gaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgVGhlIHdhcm5pbmcgaXMgKEkgdGhpbmspIGZvciBwZW9wbGUgd2hvIHdhbnQgdG8gbWFrZSB0aGVpciBjb2RlIGNvbXBhdGlibGUgd2l0aFxuICAgcHJldmlvdXMgdmVyc2lvbnMgb2Ygb2NhbWwsIHNvIHdlIG1heSB2ZXJ5IHdlbGwgdHVybiBpdCBvZmYuXG5cbiAgIFRoZSB0eXBlIHRfd2l0aF9wZXJtIGNvdWxkIGFsc28gaGF2ZSBiZWVuIGEgW3VuaXQgLT4gRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHRvIHdvcmtcbiAgIGFyb3VuZCB2YWx1ZSByZXN0cmljdGlvbiBhbmQgdGhlbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHdvdWxkIGhhdmUgYmVlbiBhIHByb3BlclxuICAgYWJzdHJhY3QgdHlwZSwgYnV0IGl0IGxvb2tzIGxpa2UgaXQgY291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIChmb3IgZXhhbXBsZSwgYSBmb2xkIG9uIGFcbiAgIHJlY29yZCB0eXBlIHdpdGggNDAgZmllbGRzIHdvdWxkIGFjdHVhbGx5IGFsbG9jYXRlIHRoZSA0MCBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdJ3MgYXRcbiAgIGV2ZXJ5IHNpbmdsZSBmb2xkLikgKilcblxubW9kdWxlIEZvcl9nZW5lcmF0ZWRfY29kZSA9IHN0cnVjdFxuICB0eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0ID1cbiAgICB7IGZvcmNlX3ZhcmlhbmNlIDogJ3Blcm0gLT4gdW5pdFxuICAgIDsgKCogZm9yY2UgW3RdIHRvIGJlIGNvbnRyYXZhcmlhbnQgaW4gWydwZXJtXSwgYmVjYXVzZSBwaGFudG9tIHR5cGUgdmFyaWFibGVzIG9uXG4gICAgICAgICBjb25jcmV0ZSB0eXBlcyBkb24ndCB3b3JrIHRoYXQgd2VsbCBvdGhlcndpc2UgKHVzaW5nIDo+IGNhbiByZW1vdmUgdGhlbSBlYXNpbHkpICopXG4gICAgICBuYW1lIDogc3RyaW5nXG4gICAgOyBzZXR0ZXIgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBnZXR0ZXIgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgIDsgZnNldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkIC0+ICdyZWNvcmRcbiAgICB9XG5cbiAgbGV0IG9wYXF1ZV9pZGVudGl0eSA9IFN5czAub3BhcXVlX2lkZW50aXR5XG5lbmRcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gPVxuICB8IEZpZWxkIG9mICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSBGb3JfZ2VuZXJhdGVkX2NvZGUudFxuW0BAdW5ib3hlZF1cblxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0ID0gKFsgYFJlYWQgfCBgU2V0X2FuZF9jcmVhdGUgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSByZWFkb25seV90ID0gKFsgYFJlYWQgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxuXG5sZXQgbmFtZSAoRmllbGQgZmllbGQpID0gZmllbGQubmFtZVxubGV0IGdldCAoRmllbGQgZmllbGQpIHIgPSBmaWVsZC5nZXR0ZXIgclxubGV0IGZzZXQgKEZpZWxkIGZpZWxkKSByIHYgPSBmaWVsZC5mc2V0IHIgdlxubGV0IHNldHRlciAoRmllbGQgZmllbGQpID0gZmllbGQuc2V0dGVyXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAncmVzdWx0KSB1c2VyID1cbiAgeyBmIDogJ2ZpZWxkLiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gLT4gJ3Jlc3VsdCB9XG5cbmxldCBtYXAgKEZpZWxkIGZpZWxkKSByIH5mID0gZmllbGQuZnNldCByIChmIChmaWVsZC5nZXR0ZXIgcikpXG5cbmxldCB1cGRhdGVyIChGaWVsZCBmaWVsZCkgPVxuICBtYXRjaCBmaWVsZC5zZXR0ZXIgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgc2V0dGVyIC0+IFNvbWUgKGZ1biByIH5mIC0+IHNldHRlciByIChmIChmaWVsZC5nZXR0ZXIgcikpKVxuOztcbiIsIigqIFtTdHJpbmcwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN0cmluZ10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzdHJpbmcwLm1sIHNob3VsZFxuICAgdXNlIFtDYW1sLlN0cmluZ10uICBbU3RyaW5nMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzXG4gICBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzLCBpbmNsdWRpbmcgdGhlIHN1YnNjcmlwdCBzeW50YXhcbiAgIFt4LihpKV0gb3IgW3guKGkpIDwtIGVdIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0b1xuICAgW1N0cmluZ10sIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TdHJpbmddIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBDYW1sLlN0cmluZy5jYXBpdGFsaXplX2FzY2lpXG5sZXQgY29tcGFyZSA9IENhbWwuU3RyaW5nLmNvbXBhcmVcblxubGV0IGNvcHkgeCA9XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmdcbiAgICB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpcbiAgICAgIChCeXRlcy5vZl9zdHJpbmcgeClcbjs7XG5cbmxldCBlc2NhcGVkID0gQ2FtbC5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxubGV0IG1ha2UgPSBDYW1sLlN0cmluZy5tYWtlXG5sZXQgc3ViID0gQ2FtbC5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLlN0cmluZy51bnNhZmVfYmxpdFxubGV0IHVwcGVyY2FzZSA9IENhbWwuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxuXG5sZXQgY29uY2F0ID8oc2VwID0gXCJcIikgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiXCJcbiAgKCogVGhlIHN0ZGxpYiBkb2VzIG5vdCBzcGVjaWFsaXplIHRoaXMgY2FzZSBiZWNhdXNlIGl0IGNvdWxkIGJyZWFrIGV4aXN0aW5nIHByb2plY3RzLiAqKVxuICB8IFsgeCBdIC0+IHhcbiAgfCBsIC0+IENhbWwuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbigqIFRoZXNlIGFyZSBldGEgZXhwYW5kZWQgaW4gb3JkZXIgdG8gcGVybXV0ZSBwYXJhbWV0ZXIgb3JkZXIgdG8gZm9sbG93IEJhc2VcbiAgIGNvbnZlbnRpb25zLiAqKVxubGV0IGl0ZXIgdCB+ZiA9IENhbWwuU3RyaW5nLml0ZXIgdCB+ZlxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQ2FtbC5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID1cbiAgICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmcgYV9fMDAxXy5wb3NfZm5hbWUgYl9fMDAyXy5wb3NfZm5hbWUgd2l0aFxuICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19sbnVtIGJfXzAwMl8ucG9zX2xudW0gd2l0aFxuICAgICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludCBhX18wMDFfLnBvc19jbnVtIGJfXzAwMl8ucG9zX2NudW1cbiAgICAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIDogdCAtPiB0IC0+IGludClcbiAgOztcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgZnVuIGhzdiBhcmcgLT5cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IGFyZy5wb3NfZm5hbWVcbiAgICAgICAgICBpblxuICAgICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgICBpblxuICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2JvbFxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfY251bVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW4geyBwb3NfZm5hbWUgPSBwb3NfZm5hbWVfXzAwNF9cbiAgICAgICAgIDsgcG9zX2xudW0gPSBwb3NfbG51bV9fMDA2X1xuICAgICAgICAgOyBwb3NfYm9sID0gcG9zX2JvbF9fMDA4X1xuICAgICAgICAgOyBwb3NfY251bSA9IHBvc19jbnVtX18wMTBfXG4gICAgICAgICB9IC0+XG4gICAgICBsZXQgYm5kc19fMDAzXyA9IFtdIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfY251bVwiOyBhcmdfXzAxMV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfYm9sXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfbG51bVwiOyBhcmdfXzAwN18gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19mbmFtZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwM19cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIFBweF9oZXJlLmxpZnRfcG9zaXRpb25fYXNfc3RyaW5nLiAqKVxubGV0IG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbCA9XG4gIFN0cmluZy5jb25jYXRcbiAgICBbIHBvc19mbmFtZTsgXCI6XCI7IEludC50b19zdHJpbmcgcG9zX2xudW07IFwiOlwiOyBJbnQudG9fc3RyaW5nIChwb3NfY251bSAtIHBvc19ib2wpIF1cbjs7XG5cbmxldCB0b19zdHJpbmcgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCB9ID1cbiAgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpc3QwXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIChmIHggOiBfIEVpdGhlcjAudCkgd2l0aFxuICAgICAgIHwgRmlyc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmRcbiAgICAgICB8IFNlY29uZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBDYW1sLnJlc3VsdCA9XG4gIHwgT2sgb2YgJ2FcbiAgfCBFcnJvciBvZiAnYlxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgZXF1YWwsIGhhc2hdXG5cbmxldCB0X29mX3NleHAgOlxuICAnYSAnYi5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE3XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoYV9fMDE3XywgYl9fMDE4XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJyZXN1bHQubWwudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcIm9rXCIgfCBcIk9rXCIpIGFzIF90YWdfXzAwOF8pIDo6IHNleHBfYXJnc19fMDA5XykgYXNcbiAgICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDA5XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDEwXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgICBPayByZXMwX18wMTFfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAwOF9cbiAgICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgX3RhZ19fMDEzXykgOjogc2V4cF9hcmdzX18wMTRfKSBhc1xuICAgICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTRfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTVfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICAgIEVycm9yIHJlczBfXzAxNl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgICAgX3RhZ19fMDEzX1xuICAgICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwib2tcIiB8IFwiT2tcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDI1XyBiX18wMjZfKVxuICAgICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxOV8gX29mX2JfXzAyMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDIyXyBdXG4gICAgICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyNF8gPSBfb2ZfYl9fMDIwXyBhcmcwX18wMjNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkVycm9yXCI7IHJlczBfXzAyNF8gXVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJPa1wiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXJyb3JcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyN18gYl9fMDI4XyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMjdfIGJfXzAyOF9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAyN18sIGJfXzAyOF8gd2l0aFxuICAgIHwgT2sgX2FfXzAyOV8sIE9rIF9iX18wMzBfIC0+IF9jbXBfX2EgX2FfXzAyOV8gX2JfXzAzMF9cbiAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICB8IF8sIE9rIF8gLT4gMVxuICAgIHwgRXJyb3IgX2FfXzAzMV8sIEVycm9yIF9iX18wMzJfIC0+IF9jbXBfX2IgX2FfXzAzMV8gX2JfXzAzMl8pXG47O1xuXG5sZXQgZXF1YWwgOlxuICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDMzXyBiX18wMzRfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAzM18gYl9fMDM0X1xuICB0aGVuIHRydWVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDMzXywgYl9fMDM0XyB3aXRoXG4gICAgfCBPayBfYV9fMDM1XywgT2sgX2JfXzAzNl8gLT4gX2NtcF9fYSBfYV9fMDM1XyBfYl9fMDM2X1xuICAgIHwgT2sgXywgXyAtPiBmYWxzZVxuICAgIHwgXywgT2sgXyAtPiBmYWxzZVxuICAgIHwgRXJyb3IgX2FfXzAzN18sIEVycm9yIF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGEgYi5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGEsIGIpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgT2sgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICB8IEVycm9yIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbjs7XG5cbltAQEBlbmRdXG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IGYgeFxuICAgIDs7XG5cbiAgICBsZXQgbWFwIHggfmYgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgICB8IE9rIHggLT4gT2sgKGYgeClcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgbGV0IHJldHVybiB4ID0gT2sgeFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgY2hlY2tfb2sgY2hlY2tfZXJyb3IgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIG9rIC0+IGNoZWNrX29rIG9rXG4gIHwgRXJyb3IgZXJyb3IgLT4gY2hlY2tfZXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBmYWlsIHggPSBFcnJvciB4XG5sZXQgZmFpbGYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGZhaWwgZm9ybWF0XG5cbmxldCBtYXBfZXJyb3IgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIF8gYXMgeCAtPiB4XG4gIHwgRXJyb3IgeCAtPiBFcnJvciAoZiB4KVxuOztcblxubW9kdWxlIEVycm9yID0gTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBPayBfIGFzIG9rIC0+IG9rXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcF9lcnJvclxuICAgIGxldCByZXR1cm4gZSA9IEVycm9yIGVcbiAgZW5kKVxuXG5sZXQgaXNfb2sgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBmYWxzZVxuICB8IEVycm9yIF8gLT4gdHJ1ZVxuOztcblxubGV0IG9rID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IFNvbWUgeFxuICB8IEVycm9yIF8gLT4gTm9uZVxuOztcblxubGV0IGVycm9yID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IE5vbmVcbiAgfCBFcnJvciB4IC0+IFNvbWUgeFxuOztcblxubGV0IG9mX29wdGlvbiBvcHQgfmVycm9yID1cbiAgbWF0Y2ggb3B0IHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT4gRXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBpdGVyIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayB4IC0+IGYgeFxuICB8IEVycm9yIF8gLT4gKClcbjs7XG5cbmxldCBpdGVyX2Vycm9yIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayBfIC0+ICgpXG4gIHwgRXJyb3IgeCAtPiBmIHhcbjs7XG5cbmxldCB0b19laXRoZXIgOiBfIHQgLT4gXyBFaXRoZXIudCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBGaXJzdCB4XG4gIHwgRXJyb3IgeCAtPiBTZWNvbmQgeFxuOztcblxubGV0IG9mX2VpdGhlciA6IF8gRWl0aGVyLnQgLT4gXyB0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IE9rIHhcbiAgfCBTZWNvbmQgeCAtPiBFcnJvciB4XG47O1xuXG5sZXQgb2tfaWZfdHJ1ZSBib29sIH5lcnJvciA9IGlmIGJvb2wgdGhlbiBPayAoKSBlbHNlIEVycm9yIGVycm9yXG5cbmxldCB0cnlfd2l0aCBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIGV4blxuOztcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IG9rX29yX2ZhaWx3aXRoID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBzdHIgLT4gZmFpbHdpdGggc3RyXG47O1xuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdvaywgJ2VycikgX3Jlc3VsdCA9ICgnb2ssICdlcnIpIHQgPVxuICAgIHwgT2sgb2YgJ29rXG4gICAgfCBFcnJvciBvZiAnZXJyXG5cbiAgbGV0IGlzX2Vycm9yID0gaXNfZXJyb3JcbiAgbGV0IGlzX29rID0gaXNfb2tcbmVuZFxuXG5sZXQgY29tYmluZSB0MSB0MiB+b2sgfmVyciA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgT2sgXywgRXJyb3IgZSB8IEVycm9yIGUsIE9rIF8gLT4gRXJyb3IgZVxuICB8IE9rIG9rMSwgT2sgb2syIC0+IE9rIChvayBvazEgb2syKVxuICB8IEVycm9yIGVycjEsIEVycm9yIGVycjIgLT4gRXJyb3IgKGVyciBlcnIxIGVycjIpXG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QxLnBhcnRpdGlvbl9tYXAgbCB+Zjp0b19laXRoZXIgaW5cbiAgbWF0Y2ggZXJycyB3aXRoXG4gIHwgW10gLT4gT2sgb2tcbiAgfCBfIDo6IF8gLT4gRXJyb3IgZXJyc1xuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IG1hcCAoY29tYmluZV9lcnJvcnMgbCkgfmY6KGZ1biAoXyA6IHVuaXQgbGlzdCkgLT4gKCkpXG5cbigqIGRlcHJlY2F0ZWQgYmluZGluZyBmb3IgZXhwb3J0IG9ubHkgKilcbmxldCBva19mc3QgPSB0b19laXRoZXJcbiIsIigqKiBQcm92aWRlcyBnZW5lcmljIHNpZ25hdHVyZXMgZm9yIGNvbnRhaW5lciBkYXRhIHN0cnVjdHVyZXMuXG5cbiAgICBUaGVzZSBzaWduYXR1cmVzIGluY2x1ZGUgZnVuY3Rpb25zIChbaXRlcl0sIFtmb2xkXSwgW2V4aXN0c10sIFtmb3JfYWxsXSwgLi4uKSB0aGF0XG4gICAgeW91IHdvdWxkIGV4cGVjdCB0byBmaW5kIGluIGFueSBjb250YWluZXIuIFVzZWQgYnkgaW5jbHVkaW5nIFtDb250YWluZXIuUzBdIG9yXG4gICAgW0NvbnRhaW5lci5TMV0gaW4gdGhlIHNpZ25hdHVyZSBmb3IgZXZlcnkgY29udGFpbmVyLWxpa2UgZGF0YSBzdHJ1Y3R1cmUgKFtBcnJheV0sXG4gICAgW0xpc3RdLCBbU3RyaW5nXSwgLi4uKSB0byBlbnN1cmUgYSBjb25zaXN0ZW50IGludGVyZmFjZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCoqIFtDb250aW51ZV9vcl9zdG9wLnRdIGlzIHVzZWQgYnkgdGhlIFtmXSBhcmd1bWVudCB0byBbZm9sZF91bnRpbF0gaW4gb3JkZXIgdG9cbiAgICAgIGluZGljYXRlIHdoZXRoZXIgZm9sZGluZyBzaG91bGQgY29udGludWUsIG9yIHN0b3AgZWFybHkuXG5cbiAgICAgIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuQ29udGludWVfb3Jfc3RvcFxuICAqKVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgICB8IENvbnRpbnVlIG9mICdhXG4gICAgICB8IFN0b3Agb2YgJ2JcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuU3VtbWFibGUgKilcbm1vZHVsZSB0eXBlIFN1bW1hYmxlID0gc2lnXG4gIHR5cGUgdFxuXG4gICgqKiBUaGUgcmVzdWx0IG9mIHN1bW1pbmcgbm8gdmFsdWVzLiAqKVxuICB2YWwgemVybyA6IHRcblxuICAoKiogQW4gb3BlcmF0aW9uIHRoYXQgY29tYmluZXMgdHdvIFt0XSdzIGFuZCBoYW5kbGVzIFt6ZXJvICsgeF0gYnkganVzdCByZXR1cm5pbmcgW3hdLFxuICAgICAgYXMgd2VsbCBhcyBpbiB0aGUgc3ltbWV0cmljIGNhc2UuICopXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgbW9ub21vcnBoaWMgY29udGFpbmVyIC0gYSBjb250YWluZXIgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCB0eXBlLCBlLmcuLFxuICAgIHN0cmluZywgd2hpY2ggaXMgYSBjb250YWluZXIgb2YgY2hhcmFjdGVycyAoW3R5cGUgZWx0ID0gY2hhcl0pIGFuZCBuZXZlciBvZiBhbnl0aGluZ1xuICAgIGVsc2UuICopXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBlbHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG5cbiAgKCoqIFtpdGVyXSBtdXN0IGFsbG93IGV4Y2VwdGlvbnMgcmFpc2VkIGluIFtmXSB0byBlc2NhcGUsIHRlcm1pbmF0aW5nIHRoZSBpdGVyYXRpb25cbiAgICAgIGNsZWFubHkuICBUaGUgc2FtZSBob2xkcyBmb3IgYWxsIGZ1bmN0aW9ucyBiZWxvdyB0YWtpbmcgYW4gW2ZdLiAqKVxuICB2YWwgaXRlciA6IHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwLiBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWVcbiAgICAgIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiBfIHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6IF8gdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiBfIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZVxuICAgICAgZWxlbWVudHMgd2lsbCBiZSBzdW1tZWQgaXMgdW5zcGVjaWZpZWQuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gXyB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiBfIHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiBfIHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogXyB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gKilcbiAgdmFsIG1pbl9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIHBvbHltb3JwaGljIGNvbnRhaW5lciwgZS5nLiwgWydhIGxpc3RdIG9yIFsnYSBhcnJheV0uICopXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIFtlcXVhbF0uICopXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XSAgKilcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiAnYSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbmltdW0gKHJlc3AgbWF4aW11bSkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAgW2NvbXBhcmVdIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdFxuICAgICAgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZSBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5IGFzIFtmb2xkXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5XG4gICAgICBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICsncGhhbnRvbSkgdFxuXG4gIGluY2x1ZGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEdlbmVyaWMgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSBlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgZWx0IGFycmF5XG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIGVsdCAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBlbHQgYXJyYXlcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2dlbl9hcmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogVGhlIFtpdGVyXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2l0ZXJdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lIFtpdGVyXVxuICAgICAgdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBpdGVyIHQgfmYgPSBDb250YWluZXIuaXRlciB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtpdGVyXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtpdGVyXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeVxuICAgICAgYXMgd2VsbC4gKilcbiAgdmFsIGl0ZXIgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdCBdXG5cbiAgKCoqIFRoZSBbbGVuZ3RoXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2xlbmd0aF0gZnVuY3Rpb24uICBbYERlZmluZV91c2luZ19mb2xkXSBtZWFucyB0byBkZWZpbmVcbiAgICAgIFtsZW5ndGhdIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgbGVuZ3RoIHQgfmYgPSBDb250YWluZXIubGVuZ3RoIH5mb2xkIHQgfmZcbiAgICAgIF19XG5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LiAgU2V2ZXJhbCBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW0NvbnRhaW5lci5NYWtlXSBhcmUgZGVmaW5lZCBpblxuICAgICAgdGVybXMgb2YgW2xlbmd0aF0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbbGVuZ3RoXSB3aWxsIGltcHJvdmUgdGhlaXJcbiAgICAgIGVmZmljaWVuY3kgYXMgd2VsbC4gKilcbiAgdmFsIGxlbmd0aCA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAnYSB0IC0+IGludCBdXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBNb25hZC5JZGVudC50XG5cbm1vZHVsZSB0eXBlIE1ha2UwX2FyZyA9IHNpZ1xuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICB0eXBlIHRcblxuICBpbmNsdWRlIE1ha2VfZ2VuX2FyZyB3aXRoIHR5cGUgJ2EgdCA6PSB0IGFuZCB0eXBlICdhIGVsdCA6PSBFbHQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbnRhaW5lciA9IHNpZ1xuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRXhwb3J0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMwID0gUzBcbiAgbW9kdWxlIHR5cGUgUzBfcGhhbnRvbSA9IFMwX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBTMV9waGFudG9tX2ludmFyaWFudCA9IFMxX3BoYW50b21faW52YXJpYW50XG4gIG1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBTMV9waGFudG9tXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWMgPSBHZW5lcmljXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWNfcGhhbnRvbSA9IEdlbmVyaWNfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBTdW1tYWJsZSA9IFN1bW1hYmxlXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2ZvbGRdLlxuXG4gICAgICBFLmcuOiBbaXRlciB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpXS4gKilcblxuICB0eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuICB0eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbiAgdmFsIGl0ZXIgOiBmb2xkOigndCwgJ2EsIHVuaXQpIGZvbGQgLT4gKCd0LCAnYSkgaXRlclxuICB2YWwgY291bnQgOiBmb2xkOigndCwgJ2EsIGludCkgZm9sZCAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgbWluX2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBsZW5ndGggOiBmb2xkOigndCwgXywgaW50KSBmb2xkIC0+ICd0IC0+IGludFxuICB2YWwgdG9fbGlzdCA6IGZvbGQ6KCd0LCAnYSwgJ2EgbGlzdCkgZm9sZCAtPiAndCAtPiAnYSBsaXN0XG5cbiAgdmFsIHN1bVxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ3N1bSkgZm9sZFxuICAgIC0+IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICd0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYikgZm9sZFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdlKSBSZXN1bHQudClcbiAgICAtPiAndFxuICAgIC0+ICgnYiwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBmb2xkOigndCwgJ2EsICdiKSBmb2xkXG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ3RcbiAgICAtPiAnZmluYWxcblxuICAoKiogR2VuZXJpYyBkZWZpbml0aW9ucyBvZiBjb250YWluZXIgb3BlcmF0aW9ucyBpbiB0ZXJtcyBvZiBbaXRlcl0gYW5kIFtsZW5ndGhdLiAqKVxuICB2YWwgaXNfZW1wdHkgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gYm9vbFxuXG4gIHZhbCBleGlzdHMgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmaW5kIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2FycmF5IDogbGVuZ3RoOid0IGxlbmd0aCAtPiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gJ2EgYXJyYXlcblxuICAoKiogVGhlIGlkaW9tIGZvciB1c2luZyBbQ29udGFpbmVyLk1ha2VdIGlzIHRvIGJpbmQgdGhlIHJlc3VsdGluZyBtb2R1bGUgYW5kIHRvXG4gICAgICBleHBsaWNpdGx5IGltcG9ydCBlYWNoIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBvbmUgd2FudHM6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgICBsZXQgY291bnQgICAgPSBDLmNvdW50XG4gICAgICAgIGxldCBleGlzdHMgICA9IEMuZXhpc3RzXG4gICAgICAgIGxldCBmaW5kICAgICA9IEMuZmluZFxuICAgICAgICAoKiAuLi4gKilcbiAgICAgIF19XG5cbiAgICAgIFRoaXMgaXMgcHJlZmVyYWJsZSB0bzpcblxuICAgICAge1tcbiAgICAgICAgaW5jbHVkZSBDb250YWluZXIuTWFrZSAoc3RydWN0IC4uLiBlbmQpXG4gICAgICBdfVxuXG4gICAgICBiZWNhdXNlIHRoZSBbaW5jbHVkZV0gbWFrZXMgaXQgdG9vIGVhc3kgdG8gc2hhZG93IHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICAgY29udGFpbmVyIGZ1bmN0aW9ucyAoW2xlbmd0aF0gYmVpbmcgYSBjb21tb24gb25lKS5cblxuICAgICAgW0NvbnRhaW5lci5NYWtlMF0gaXMgbGlrZSBbQ29udGFpbmVyLk1ha2VdLCBidXQgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lcnMgbGlrZVxuICAgICAgW3N0cmluZ10uICopXG4gIG1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5cbiAgbW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBlbHQgOj0gVC5FbHQudFxuXG4gIG1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICAgIEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBDb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxudHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxudHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxubGV0IGl0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKVxubGV0IGNvdW50IH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gYSAtPiBpZiBmIGEgdGhlbiBuICsgMSBlbHNlIG4pXG5cbmxldCBzdW0gKHR5cGUgYSkgfmZvbGQgKG1vZHVsZSBNIDogU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgZm9sZCB0IH5pbml0Ok0uemVybyB+ZjooZnVuIG4gYSAtPiBNLiggKyApIG4gKGYgYSkpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIFJlc3VsdC5Pa1xuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgUmVzdWx0Lk9rIHggLT4geFxuICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGUpKSlcbjs7XG5cbmxldCBmb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIH5maW5pc2ggdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIGZpbmlzaFxuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSB4IC0+IHhcbiAgICAgICAgIHwgU3RvcCB4IC0+IHJldHVybiB4KSkpXG47O1xuXG5sZXQgbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWluIC0+IGlmIGNvbXBhcmUgbWluIGVsdCA+IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYylcbjs7XG5cbmxldCBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtYXggLT4gaWYgY29tcGFyZSBtYXggZWx0IDwgMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKVxuOztcblxubGV0IGxlbmd0aCB+Zm9sZCBjID0gZm9sZCBjIH5pbml0OjAgfmY6KGZ1biBhY2MgXyAtPiBhY2MgKyAxKVxuXG5sZXQgaXNfZW1wdHkgfml0ZXIgYyA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIF8gLT4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZXhpc3RzIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGZvcl9hbGwgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgbm90IChmIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXAgfml0ZXIgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgZmluZCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiAoU29tZSB4KSk7XG4gICAgTm9uZSlcbjs7XG5cbmxldCB0b19saXN0IH5mb2xkIGMgPSBMaXN0LnJldiAoZm9sZCBjIH5pbml0OltdIH5mOihmdW4gYWNjIHggLT4geCA6OiBhY2MpKVxuXG5sZXQgdG9fYXJyYXkgfmxlbmd0aCB+aXRlciBjID1cbiAgbGV0IGFycmF5ID0gcmVmIFt8fF0gaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICBpdGVyIGMgfmY6KGZ1biB4IC0+XG4gICAgaWYgIWkgPSAwIHRoZW4gYXJyYXkgOj0gQXJyYXkuY3JlYXRlIH5sZW46KGxlbmd0aCBjKSB4O1xuICAgICFhcnJheS4oIWkpIDwtIHg7XG4gICAgaW5jciBpKTtcbiAgIWFycmF5XG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDogc2lnXG4gIGluY2x1ZGUgR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kID0gc3RydWN0XG4gIGxldCBmb2xkID0gVC5mb2xkXG5cbiAgbGV0IGl0ZXIgPVxuICAgIG1hdGNoIFQuaXRlciB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXIgLT4gaXRlclxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXIgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBsZW5ndGggPVxuICAgIG1hdGNoIFQubGVuZ3RoIHdpdGhcbiAgICB8IGBDdXN0b20gbGVuZ3RoIC0+IGxlbmd0aFxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IC0+IGxlbmd0aCB+Zm9sZCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBpc19lbXB0eSB+aXRlciB0XG4gIGxldCBzdW0gbSB0ID0gc3VtIH5mb2xkIG0gdFxuICBsZXQgY291bnQgdCB+ZiA9IGNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzIH5pdGVyIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGwgfml0ZXIgdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmQgfml0ZXIgdCB+ZlxuICBsZXQgdG9fbGlzdCB0ID0gdG9fbGlzdCB+Zm9sZCB0XG4gIGxldCB0b19hcnJheSB0ID0gdG9fYXJyYXkgfmxlbmd0aCB+aXRlciB0XG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IGZvbGRfcmVzdWx0IHQgfmZvbGQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gZm9sZF91bnRpbCB0IH5mb2xkIH5pbml0IH5mIH5maW5pc2hcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuXG4gIGxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IGVsdCA9IGV4aXN0cyB0IH5mOihULkVsdC5lcXVhbCBlbHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDYW1sLkxhenlcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsYXp5X3Rfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGF6eV90XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuIHggPSBmcm9tX3ZhbCB4XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGxhenkgKGZvcmNlIChmIChmb3JjZSB0KSkpXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBUX3VuZm9yY2luZyA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGlmIGlzX3ZhbCB0IHRoZW4gc2V4cF9vZl9hIChmb3JjZSB0KSBlbHNlIHNleHBfb2Zfc3RyaW5nIFwiPHVuZm9yY2VkIGxhenk+XCJcbiAgOztcbmVuZFxuIiwiKCogU3BsaXQgb2ZmIHRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCBbT3JfZXJyb3JdLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubGV0IHNsb3dfY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgcG9zaXRpb246ICVkXCIgcG9zICgpO1xuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgbGVuZ3RoOiAlZFwiIGxlbiAoKTtcbiAgKCogV2UgdXNlIFtwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiB0b3RhbF9sZW5ndGhdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwicG9zICsgbGVuIHBhc3QgZW5kOiAlZCArICVkID4gJWRcIiBwb3MgbGVuIHRvdGFsX2xlbmd0aCAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gICgqIFRoaXMgaXMgYmV0dGVyIHRoYW4gW3Nsb3dfY2hlY2tfcG9zX2xlbl9leG5dIGZvciB0d28gcmVhc29uczpcblxuICAgICAtIG11Y2ggbGVzcyBpbmxpbmVkIGNvZGVcbiAgICAgLSBvbmx5IG9uZSBjb25kaXRpb25hbCBqdW1wXG5cbiAgICAgVGhlIHJlYXNvbiBpdCB3b3JrcyBpcyB0aGF0IGNoZWNraW5nIFs8IDBdIGlzIHRlc3RpbmcgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0LCBzb1xuICAgICBbYSA8IDAgfHwgYiA8IDBdIGlzIHRoZSBzYW1lIGFzIFthIGxvciBiIDwgMF0uXG5cbiAgICAgW3BvcyArIGxlbl0gY2FuIG92ZXJmbG93LCBzbyBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSBpcyBub3QgZXF1aXZhbGVudCB0b1xuICAgICBbdG90YWxfbGVuZ3RoIC0gbGVuIC0gcG9zIDwgMF0sIHdlIG5lZWQgdG8gdGVzdCBmb3IgW3BvcyArIGxlbl0gb3ZlcmZsb3cgYXNcbiAgICAgd2VsbC4gKilcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgaWYgcG9zIGxvciBsZW4gbG9yIHN0b3AgbG9yICh0b3RhbF9sZW5ndGggLSBzdG9wKSA8IDBcbiAgdGhlbiBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iLCJcbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIG9wZW4gQ2FtbC5CaWdhcnJheVxuXG4gIHR5cGUgdCA9IChpbnQ2NCwgaW50NjRfZWx0LCBjX2xheW91dCkgQXJyYXkxLnRcblxuICBsZXQgb2Zfc3RhdGUgOiBDYW1sLlJhbmRvbS5TdGF0ZS50IC0+IHQgPSBDYW1sLk9iai5tYWdpY1xuZW5kXG5cbmxldCBhc3NpZ24gZHN0IHNyYyA9XG4gIGxldCBkc3QgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIGRzdCkgaW5cbiAgbGV0IHNyYyA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2Ugc3JjKSBpblxuICBDYW1sLkJpZ2FycmF5LkFycmF5MS5ibGl0IHNyYyBkc3RcblxubGV0IG1ha2VfZGVmYXVsdCBkZWZhdWx0ID1cbiAgbGV0IHNwbGl0X2Zyb21fcGFyZW50IHYgPVxuICAgIENhbWwuTGF6eS5tYXBfdmFsIENhbWwuUmFuZG9tLlN0YXRlLnNwbGl0IHZcbiAgaW5cbiAgQ2FtbC5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IChmdW4gKCkgLT4gZGVmYXVsdClcblxubGV0IGdldF9zdGF0ZSByYW5kb21fa2V5ID0gQ2FtbC5Eb21haW4uRExTLmdldCByYW5kb21fa2V5XG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5cbigqIFVuZm9ydHVuYXRlbHksIGJlY2F1c2UgdGhlIHN0YW5kYXJkIGxpYnJhcnkgZG9lcyBub3QgZXhwb3NlXG4gICBbQ2FtbC5SYW5kb20uU3RhdGUuZGVmYXVsdF0sIHdlIGhhdmUgdG8gY29uc3RydWN0IG91ciBvd24uICBXZSB0aGVuIGJ1aWxkIHRoZVxuICAgW0NhbWwuUmFuZG9tLmludF0sIFtDYW1sLlJhbmRvbS5ib29sXSBmdW5jdGlvbnMgYW5kIGZyaWVuZHMgdXNpbmcgdGhhdCBkZWZhdWx0IHN0YXRlIGluXG4gICBleGFjdGx5IHRoZSBzYW1lIHdheSBhcyB0aGUgc3RhbmRhcmQgbGlicmFyeS5cblxuICAgT25lIG90aGVyIHRyaWNraW5lc3MgaXMgdGhhdCB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgdW5leHBvc2VkIFtDYW1sLlJhbmRvbS5TdGF0ZS5hc3NpZ25dXG4gICBmdW5jdGlvbiwgd2hpY2ggYWNjZXNzZXMgdGhlIHVuZXhwb3NlZCBzdGF0ZSByZXByZXNlbnRhdGlvbi4gIFNvLCB3ZSBjb3B5IHRoZVxuICAgW1N0YXRlLnJlcHJdIHR5cGUgZGVmaW5pdGlvbiBhbmQgW2Fzc2lnbl0gZnVuY3Rpb24gdG8gaGVyZSBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LFxuICAgYW5kIHVzZSBbT2JqLm1hZ2ljXSB0byBnZXQgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uLiAqKVxuXG4oKiBSZWdyZXNzaW9uIHRlc3RzIG91Z2h0IHRvIGJlIGRldGVybWluaXN0aWMgYmVjYXVzZSB0aGF0IHdheSBhbnlvbmUgd2hvIGJyZWFrcyB0aGUgdGVzdFxuICAga25vd3MgdGhhdCBpdCdzIHRoZWlyIGNvZGUgdGhhdCBicm9rZSB0aGUgdGVzdC4gIElmIHRlc3RzIGFyZSBub25kZXRlcm1pbmlzdGljLCBhIHRlc3RcbiAgIGZhaWx1cmUgbWF5IGluc3RlYWQgaGFwcGVuIGJlY2F1c2UgdGhlIHRlc3QgcnVubmVyIGdvdCB1bmx1Y2t5IGFuZCB1bmNvdmVyZWQgYW5cbiAgIGV4aXN0aW5nIGJ1ZyBpbiB0aGUgY29kZSBzdXBwb3NlZGx5IGJlaW5nIFwicHJvdGVjdGVkXCIgYnkgdGhlIHRlc3QgaW4gcXVlc3Rpb24uICopXG5sZXQgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cyA9XG4gIGlmIGFtX3Rlc3RpbmdcbiAgdGhlbiAoXG4gICAgbWF0Y2ggYWxsb3dfaW5fdGVzdHMgd2l0aFxuICAgIHwgU29tZSB0cnVlIC0+ICgpXG4gICAgfCBOb25lIHwgU29tZSBmYWxzZSAtPlxuICAgICAgZmFpbHdpdGhcbiAgICAgICAgXCJpbml0aWFsaXppbmcgUmFuZG9tIHdpdGggYSBub25kZXRlcm1pbmlzdGljIHNlZWQgaXMgZm9yYmlkZGVuIGluIGlubGluZSB0ZXN0c1wiKVxuOztcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQgOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5sZXQgcmFuZG9tX3NlZWQgP2FsbG93X2luX3Rlc3RzICgpID1cbiAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgcmFuZG9tX3NlZWQgKClcbjs7XG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAoKiBXZSBhbGxvdyBsYXppbmVzcyBvbmx5IGZvciB0aGUgZGVmaW5pdGlvbiBvZiBbZGVmYXVsdF0sIGJlbG93LCB3aGljaCBtYXkgbGF6aWx5IGNhbGxcbiAgICAgW21ha2Vfc2VsZl9pbml0XS4gRm9yIGFsbCBvdGhlciBwdXJwb3Nlcywgd2UgY3JlYXRlIGFuZCB1c2UgW3RdIGVhZ2VybHkuICopXG4gIHR5cGUgdCA9IENhbWwuUmFuZG9tLlN0YXRlLnQgTGF6eS50XG5cbiAgbGV0IGJpdHMgdCA9IENhbWwuUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgdClcbiAgbGV0IGJvb2wgdCA9IENhbWwuUmFuZG9tLlN0YXRlLmJvb2wgKExhenkuZm9yY2UgdClcbiAgbGV0IGludCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgaW50MzIgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUuaW50MzIgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgaW50NjQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUuaW50NjQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgbmF0aXZlaW50IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLm5hdGl2ZWludCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBtYWtlIHNlZWQgPSBMYXp5LmZyb21fdmFsIChDYW1sLlJhbmRvbS5TdGF0ZS5tYWtlIHNlZWQpXG4gIGxldCBjb3B5IHQgPSBMYXp5LmZyb21fdmFsIChDYW1sLlJhbmRvbS5TdGF0ZS5jb3B5IChMYXp5LmZvcmNlIHQpKVxuICBsZXQgY2hhciB0ID0gaW50IHQgMjU2IHw+IENoYXIudW5zYWZlX29mX2ludFxuICBsZXQgYXNjaWkgdCA9IGludCB0IDEyOCB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcblxuICBsZXQgbWFrZV9zZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID1cbiAgICBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzO1xuICAgIExhenkuZnJvbV92YWwgKENhbWwuUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuICA7O1xuXG4gIGxldCBhc3NpZ24gPSBSYW5kb21fcmVwci5hc3NpZ25cblxuICBsZXQgZnVsbF9pbml0IHQgc2VlZCA9IGFzc2lnbiB0IChtYWtlIHNlZWQpXG5cbiAgbGV0IGRlZmF1bHQgPVxuICAgIGlmIGFtX3Rlc3RpbmdcbiAgICB0aGVuIChcbiAgICAgICgqIFdlIGRlZmluZSBCYXNlJ3MgZGVmYXVsdCByYW5kb20gc3RhdGUgYXMgYSBjb3B5IG9mIE9DYW1sJ3MgZGVmYXVsdCByYW5kb20gc3RhdGUuXG4gICAgICAgICBUaGlzIG1lYW5zIHRoYXQgcHJvZ3JhbXMgdGhhdCB1c2UgQmFzZS5SYW5kb20gd2lsbCBzZWUgdGhlIHNhbWUgc2VxdWVuY2Ugb2ZcbiAgICAgICAgIHJhbmRvbSBiaXRzIGFzIGlmIHRoZXkgaGFkIHVzZWQgQ2FtbC5SYW5kb20uIEhvd2V2ZXIsIGJlY2F1c2UgW2dldF9zdGF0ZV0gcmV0dXJuc1xuICAgICAgICAgYSBjb3B5LCBCYXNlLlJhbmRvbSBhbmQgT0NhbWwuUmFuZG9tIGFyZSBub3QgdXNpbmcgdGhlIHNhbWUgc3RhdGUuIElmIGEgcHJvZ3JhbVxuICAgICAgICAgdXNlZCBib3RoLCBlYWNoIG9mIHRoZW0gd291bGQgZ28gdGhyb3VnaCB0aGUgc2FtZSBzZXF1ZW5jZSBvZiByYW5kb20gYml0cy4gVG9cbiAgICAgICAgIGF2b2lkIHRoYXQsIHdlIHJlc2V0IE9DYW1sJ3MgcmFuZG9tIHN0YXRlIHRvIGEgZGlmZmVyZW50IHNlZWQsIGdpdmluZyBpdCBhXG4gICAgICAgICBkaWZmZXJlbnQgc2VxdWVuY2UuICopXG4gICAgICBsZXQgdCA9IENhbWwuUmFuZG9tLmdldF9zdGF0ZSAoKSBpblxuICAgICAgQ2FtbC5SYW5kb20uaW5pdCAxMzc7XG4gICAgICBMYXp5LmZyb21fdmFsIHQpXG4gICAgZWxzZVxuICAgICAgbGF6eVxuICAgICAgICAoKiBPdXRzaWRlIG9mIHRlc3RzLCB3ZSBpbml0aWFsaXplIHJhbmRvbSBzdGF0ZSBub25kZXRlcm1pbmlzdGljYWxseSBhbmQgbGF6aWx5LlxuICAgICAgICAgICBXZSBmb3JjZSB0aGUgcmFuZG9tIGluaXRpYWxpemF0aW9uIHRvIGJlIGxhenkgc28gdGhhdCB3ZSBkbyBub3QgcGF5IGFueSBjb3N0XG4gICAgICAgICAgIGZvciBpdCBpbiBwcm9ncmFtcyB0aGF0IGRvIG5vdCB1c2UgcmFuZG9tbmVzcy4gKilcbiAgICAgICAgKExhenkuZm9yY2UgKG1ha2Vfc2VsZl9pbml0ICgpKSlcbiAgOztcblxuICBsZXQgaW50X29uXzY0Yml0cyB0IGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAweDNGRkZGRkZGICgqICgxIGxzbCAzMCkgLSAxICopXG4gICAgdGhlbiBpbnQgdCBib3VuZFxuICAgIGVsc2UgQ2FtbC5JbnQ2NC50b19pbnQgKGludDY0IHQgKENhbWwuSW50NjQub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50X29uXzMyYml0cyB0IGJvdW5kID1cbiAgICAoKiBOb3QgYWx3YXlzIHRydWUgd2l0aCB0aGUgSmF2YVNjcmlwdCBiYWNrZW5kLiAqKVxuICAgIGlmIGJvdW5kIDw9IDB4M0ZGRkZGRkYgKCogKDEgbHNsIDMwKSAtIDEgKilcbiAgICB0aGVuIGludCB0IGJvdW5kXG4gICAgZWxzZSBDYW1sLkludDMyLnRvX2ludCAoaW50MzIgdCAoQ2FtbC5JbnQzMi5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50NjQgPVxuICAgIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgICBsZXQgYml0cyBzdGF0ZSA9IG9mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBmdW4gc3RhdGUgLT5cbiAgICAgIGxvZ3hvclxuICAgICAgICAoYml0cyBzdGF0ZSlcbiAgICAgICAgKGxvZ3hvciAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgMzApIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSA2MCkpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50MzIgPVxuICAgIGxldCBvcGVuIENhbWwuSW50MzIgaW5cbiAgICBsZXQgYml0cyBzdGF0ZSA9IG9mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBmdW4gc3RhdGUgLT4gbG9neG9yIChiaXRzIHN0YXRlKSAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgMzApXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyBzdGF0ZSA9IENhbWwuSW50NjQudG9faW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzIHN0YXRlID0gQ2FtbC5JbnQzMi50b19pbnQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIHN0YXRlID1cbiAgICBDYW1sLkludDY0LnRvX25hdGl2ZWludCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIHN0YXRlID1cbiAgICBDYW1sLk5hdGl2ZWludC5vZl9pbnQzMiAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCByYWlzZV9jcm9zc2VkX2JvdW5kcyBuYW1lIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kIHN0cmluZ19vZl9ib3VuZCA9XG4gICAgUHJpbnRmLmZhaWx3aXRoZlxuICAgICAgXCJSYW5kb20uJXM6IGNyb3NzZWQgYm91bmRzIFslcyA+ICVzXVwiXG4gICAgICBuYW1lXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIGxvd2VyX2JvdW5kKVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCB1cHBlcl9ib3VuZClcbiAgICAgICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG4gIDs7XG5cbiAgbGV0IGludF9pbmNsID1cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludFwiIGxvIGhpIEludC50b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IGhpIC0gbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBJbnQubWF4X3ZhbHVlXG4gICAgICB0aGVuIGxvICsgKGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGxhbmQgSW50Lm1heF92YWx1ZSlcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwXG4gICAgICB0aGVuIGxvICsgaW50IHN0YXRlIChJbnQuc3VjYyBkaWZmKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQzMl9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDMyIHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuSW50MzIgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludDMyXCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBsXG4gICAgICB0aGVuIGFkZCBsbyAoaW50MzIgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IG5hdGl2ZWludF9pbmNsID1cbiAgICBsZXQgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9uYXRpdmVpbnQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gQ2FtbC5OYXRpdmVpbnQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcIm5hdGl2ZWludFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9uYXRpdmVpbnQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMG5cbiAgICAgIHRoZW4gYWRkIGxvIChuYXRpdmVpbnQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDY0X2luY2wgPVxuICAgIGxldCBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQ2NCBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50NjRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMExcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQ2NCBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICAoKiBSZXR1cm4gYSB1bmlmb3JtbHkgcmFuZG9tIGZsb2F0IGluIFswLCAxKS4gKilcbiAgbGV0IHJlYyByYXdmbG9hdCBzdGF0ZSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHNjYWxlID0gMHgxcC0zMCBpblxuICAgICgqIDJeLTMwICopXG4gICAgbGV0IHIxID0gQ2FtbC5mbG9hdF9vZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgbGV0IHIyID0gQ2FtbC5mbG9hdF9vZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgbGV0IHJlc3VsdCA9ICgocjEgKi4gc2NhbGUpICsuIHIyKSAqLiBzY2FsZSBpblxuICAgICgqIFdpdGggdmVyeSBzbWFsbCBwcm9iYWJpbGl0eSwgcmVzdWx0IGNhbiByb3VuZCB1cCB0byAxLjAsIHNvIGluIHRoYXQgY2FzZSwgd2UganVzdFxuICAgICAgIHRyeSBhZ2Fpbi4gKilcbiAgICBpZiByZXN1bHQgPCAxLjAgdGhlbiByZXN1bHQgZWxzZSByYXdmbG9hdCBzdGF0ZVxuICA7O1xuXG4gIGxldCBmbG9hdCBzdGF0ZSBoaSA9IHJhd2Zsb2F0IHN0YXRlICouIGhpXG5cbiAgbGV0IGZsb2F0X3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJmbG9hdFwiIGxvIGhpIENhbWwuc3RyaW5nX29mX2Zsb2F0O1xuICAgIGxvICsuIGZsb2F0IHN0YXRlIChoaSAtLiBsbylcbiAgOztcbmVuZFxuXG5sZXQgZGVmYXVsdCA9IFJhbmRvbV9yZXByLm1ha2VfZGVmYXVsdCBTdGF0ZS5kZWZhdWx0XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgaW50IHggPSBTdGF0ZS5pbnQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgaW50MzIgeCA9IFN0YXRlLmludDMyIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IG5hdGl2ZWludCB4ID0gU3RhdGUubmF0aXZlaW50IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludDY0IHggPSBTdGF0ZS5pbnQ2NCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBmbG9hdCB4ID0gU3RhdGUuZmxvYXQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgaW50X2luY2wgeCB5ID0gU3RhdGUuaW50X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBpbnQzMl9pbmNsIHggeSA9IFN0YXRlLmludDMyX2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBuYXRpdmVpbnRfaW5jbCB4IHkgPSBTdGF0ZS5uYXRpdmVpbnRfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGludDY0X2luY2wgeCB5ID0gU3RhdGUuaW50NjRfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGZsb2F0X3JhbmdlIHggeSA9IFN0YXRlLmZsb2F0X3JhbmdlIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGNoYXIgKCkgPSBTdGF0ZS5jaGFyIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBhc2NpaSAoKSA9IFN0YXRlLmFzY2lpIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHNlZWRcbmxldCBpbml0IHNlZWQgPSBmdWxsX2luaXQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCA/YWxsb3dfaW5fdGVzdHMgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkID9hbGxvd19pbl90ZXN0cyAoKSlcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHNcbiIsIigqKiBBbiBpbnRlcm5hbC1vbmx5IG1vZHVsZSBmYWN0b3JlZCBvdXQgZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIGNvcmVfYXJyYXlcbiAgICBhbmQgY29yZV9saXN0LiAgQ29udGFpbnMgY29kZSBmb3IgcGVybXV0aW5nIGFuIGFycmF5LiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbmxldCBwZXJtdXRlID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpID8ocG9zID0gMCkgP2xlbiB0ID1cbiAgKCogQ29waWVkIGZyb20gW09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgd2hlbiBjb21waWxpbmdcbiAgICAgd2l0aG91dCBmbGFtYmRhLiAqKVxuICBsZXQgdG90YWxfbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgbCAtPiBsXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgbGV0IG51bV9zd2FwcyA9IGxlbiAtIDEgaW5cbiAgZm9yIGkgPSBudW1fc3dhcHMgZG93bnRvIDEgZG9cbiAgICBsZXQgdGhpc19pID0gcG9zICsgaSBpblxuICAgICgqIFtyYW5kb21faV0gaXMgZHJhd24gZnJvbSBbcG9zLHRoaXNfaV0gKilcbiAgICBsZXQgcmFuZG9tX2kgPSBwb3MgKyBSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAoaSArIDEpIGluXG4gICAgc3dhcCB0IHRoaXNfaSByYW5kb21faVxuICBkb25lXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBjb25zdCBjIF8gPSBjXG5cbmV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIHRoaXMgaGFzIHRoZSBzYW1lIGJlaGF2aW9yIGFzIFtDYW1sLmlnbm9yZV0gKilcblxubGV0IG5vbiBmIHggPSBub3QgKGYgeClcblxubGV0IGZvcmV2ZXIgZiA9XG4gIGxldCByZWMgZm9yZXZlciAoKSA9XG4gICAgZiAoKTtcbiAgICBmb3JldmVyICgpXG4gIGluXG4gIHRyeSBmb3JldmVyICgpIHdpdGhcbiAgfCBlIC0+IGVcbjs7XG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGUgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhlc2UgZnVuY3Rpb25zIGlzIHRvIHBhc3MgaW4gZnVuY3Rpb25hbCBhcmd1bWVudHMgYW5kIGdldFxuICAgZnVuY3Rpb25zIGFzIGEgcmVzdWx0LiAqKVxubGV0IGNvbXBvc2UgZiBnIHggPSBmIChnIHgpXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgcmVjIGFwcGx5X25fdGltZXMgfm4gZiB4ID0gaWYgbiA8PSAwIHRoZW4geCBlbHNlIGFwcGx5X25fdGltZXMgfm46KG4gLSAxKSBmIChmIHgpXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBMZXNzXG4gIHwgRXF1YWxcbiAgfCBHcmVhdGVyXG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBMZXNzIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IEVxdWFsIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IEdyZWF0ZXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIExlc3M7IEVxdWFsOyBHcmVhdGVyIF0gOiB0IGxpc3QpXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDA1XyA9IFwib3JkZXJpbmcubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIC0+IExlc3NcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIC0+IEVxdWFsXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgLT4gR3JlYXRlclxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZXNzXCIgfCBcIkxlc3NcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgc2V4cF9fMDA0XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IExlc3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVzc1wiXG4gICAgfCBFcXVhbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJFcXVhbFwiXG4gICAgfCBHcmVhdGVyIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkdyZWF0ZXJcIlxuICAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJMZXNzXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJFcXVhbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiR3JlYXRlclwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSBfb3JkZXJpbmcgPSB0ID1cbiAgICB8IExlc3NcbiAgICB8IEVxdWFsXG4gICAgfCBHcmVhdGVyXG5lbmRcblxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBMZXNzIGVsc2UgaWYgbiA9IDAgdGhlbiBFcXVhbCBlbHNlIEdyZWF0ZXJcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTGVzcyAtPiAtMVxuICB8IEVxdWFsIC0+IDBcbiAgfCBHcmVhdGVyIC0+IDFcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxuXG5pbmNsdWRlIExpc3QxXG5cbigqIFRoaXMgaXRzZWxmIGluY2x1ZGVzIFtMaXN0MF0uICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGlzdF9vZl9zZXhwXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xpc3RcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxpc3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBPcl91bmVxdWFsX2xlbmd0aHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE9rIG9mICdhXG4gICAgfCBVbmVxdWFsX2xlbmd0aHNcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDA2XyBiX18wMDdfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDA2XyBiX18wMDdfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDZfLCBiX18wMDdfIHdpdGhcbiAgICAgIHwgT2sgX2FfXzAwOF8sIE9rIF9iX18wMDlfIC0+IF9jbXBfX2EgX2FfXzAwOF8gX2JfXzAwOV9cbiAgICAgIHwgT2sgXywgXyAtPiAtMVxuICAgICAgfCBfLCBPayBfIC0+IDFcbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzLCBVbmVxdWFsX2xlbmd0aHMgLT4gMClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gKHR5cGUgYV9fMDEzXykgOiAoKGFfXzAxM18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMTNfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDEwXyAtPiBmdW5jdGlvblxuICAgICAgfCBPayBhcmcwX18wMTFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAxMF8gYXJnMF9fMDExXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyByZXMwX18wMTJfIF1cbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZXF1YWxfbGVuZ3Roc1wiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGludmFyaWFudCBmIHQgPSBpdGVyIHQgfmZcbmxldCBvZl9saXN0IHQgPSB0XG5cbmxldCByYW5nZScgfmNvbXBhcmUgfnN0cmlkZSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBsZXQgbmV4dF9pID0gc3RyaWRlIHN0YXJ0X2kgaW5cbiAgbGV0IG9yZGVyIHggeSA9IE9yZGVyaW5nLm9mX2ludCAoY29tcGFyZSB4IHkpIGluXG4gIGxldCByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpID1cbiAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IHJldHVybiB0aGUgc2FtZSB2YWx1ZVwiXG4gIGluXG4gIGxldCBpbml0aWFsX3N0cmlkZV9vcmRlciA9XG4gICAgbWF0Y2ggb3JkZXIgc3RhcnRfaSBuZXh0X2kgd2l0aFxuICAgIHwgRXF1YWwgLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgIHwgTGVzcyAtPiBgTGVzc1xuICAgIHwgR3JlYXRlciAtPiBgR3JlYXRlclxuICBpblxuICBsZXQgcmVjIGxvb3AgaSBhY2N1bSA9XG4gICAgbGV0IGlfdG9fc3RvcF9vcmRlciA9IG9yZGVyIGkgc3RvcF9pIGluXG4gICAgbWF0Y2ggaV90b19zdG9wX29yZGVyLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+XG4gICAgICAoKiBoYXZlbid0IHlldCByZWFjaGVkIFtzdG9wX2ldLiBDb250aW51ZS4gKilcbiAgICAgIGxldCBuZXh0X2kgPSBzdHJpZGUgaSBpblxuICAgICAgKG1hdGNoIG9yZGVyIGkgbmV4dF9pLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgICAgfCBFcXVhbCwgXyAtPiByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpXG4gICAgICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IGNoYW5nZSBkaXJlY3Rpb25cIlxuICAgICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPiBsb29wIG5leHRfaSAoaSA6OiBhY2N1bSkpXG4gICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAoKiBzdGVwcGVkIHBhc3QgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIGFjY3VtXG4gICAgfCBFcXVhbCwgXyAtPlxuICAgICAgKCogcmVhY2hlZCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgKG1hdGNoIHN0b3Agd2l0aFxuICAgICAgIHwgYGluY2x1c2l2ZSAtPiBpIDo6IGFjY3VtXG4gICAgICAgfCBgZXhjbHVzaXZlIC0+IGFjY3VtKVxuICBpblxuICBsZXQgc3RhcnRfaSA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgYGluY2x1c2l2ZSAtPiBzdGFydF9pXG4gICAgfCBgZXhjbHVzaXZlIC0+IG5leHRfaVxuICBpblxuICByZXYgKGxvb3Agc3RhcnRfaSBbXSlcbjs7XG5cbmxldCByYW5nZSA/KHN0cmlkZSA9IDEpID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGlmIHN0cmlkZSA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2U6IHN0cmlkZSBtdXN0IGJlIG5vbi16ZXJvXCI7XG4gIHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlOihmdW4geCAtPiB4ICsgc3RyaWRlKSB+c3RhcnQgfnN0b3Agc3RhcnRfaSBzdG9wX2lcbjs7XG5cbmxldCBoZCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogXyAtPiBTb21lIHhcbjs7XG5cbmxldCB0bCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogdCcgLT4gU29tZSB0J1xuOztcblxubGV0IG50aCB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBudGhfYXV4IHQgbiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhIDo6IHQgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IHQgKG4gLSAxKVxuICAgIGluXG4gICAgbnRoX2F1eCB0IG4pXG47O1xuXG5sZXQgbnRoX2V4biB0IG4gPVxuICBtYXRjaCBudGggdCBuIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIkxpc3QubnRoX2V4biAlZCBjYWxsZWQgb24gbGlzdCBvZiBsZW5ndGggJWRcIiBuIChsZW5ndGggdCkgKClcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHVub3JkZXJlZF9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsIHwgbCwgW10gLT4gbFxuICB8IF8gLT4gcmV2X2FwcGVuZCBsMSBsMlxuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgICB8IFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiIC0+IGxvb3AgYSBiIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8gfCBfLCBbXSAtPiBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIGwxIGwyID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iIH0gLT5cbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiXG4gICAgICBuYW1lXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EpXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IpXG4gICAgICAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMilcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2MgOiAnYyBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyIGwzID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIGMgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiLCBjIHdpdGhcbiAgICAgIHwgW10sIFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiLCBfIDo6IGMgLT4gbG9vcCBhIGIgYyAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfLCBfIHwgXywgW10sIF8gfCBfLCBfLCBbXSAtPlxuICAgICAgICBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiOyB0YWlsX29mX2MgPSBjIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgbDMgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgzX2V4biBuYW1lIGwxIGwyIGwzID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iOyB0YWlsX29mX2MgfSAtPlxuICAgIGxldCBuMSA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hIGluXG4gICAgbGV0IG4yID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IgaW5cbiAgICBsZXQgbjMgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYyBpblxuICAgIGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWQgfHwgJWQgPD4gJWRcIiBuYW1lIG4xIG4yIG4yIG4zICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyIGwzKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubGV0IGl0ZXIyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooaXRlcjJfb2sgfmYpXG5cbmxldCBpdGVyMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIml0ZXIyX2V4blwiIGwxIGwyO1xuICBpdGVyMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjoocmV2X21hcDJfb2sgfmYpXG5cbmxldCByZXZfbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcInJldl9tYXAyX2V4blwiIGwxIGwyO1xuICByZXZfbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGZvbGQyIGwxIGwyIH5pbml0IH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9sZDJfb2sgfmluaXQgfmYpXG5cbmxldCBmb2xkMl9leG4gbDEgbDIgfmluaXQgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvbGQyX2V4blwiIGwxIGwyO1xuICBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZlxuOztcblxubGV0IGZvcl9hbGwyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9yX2FsbDJfb2sgfmYpXG5cbmxldCBmb3JfYWxsMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvcl9hbGwyX2V4blwiIGwxIGwyO1xuICBmb3JfYWxsMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGV4aXN0czIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihleGlzdHMyX29rIH5mKVxuXG5sZXQgZXhpc3RzMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImV4aXN0czJfZXhuXCIgbDEgbDI7XG4gIGV4aXN0czJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBlcXVhbCBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBiIDo6IGJzIC0+IGVxdWFsIGEgYiB8fCBsb29wIGVxdWFsIGEgYnNcbiAgaW5cbiAgbG9vcCBlcXVhbCBhIHRcbjs7XG5cbigqIFRoaXMgaXMgYSBjb3B5IG9mIHRoZSBjb2RlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggYW4gZXh0cmEgZXRhLWV4cGFuc2lvbiB0b1xuICAgYXZvaWQgY3JlYXRpbmcgcGFydGlhbCBjbG9zdXJlcyAoc2hvd2VkIHVwIGZvciBbZmlsdGVyXSkgaW4gcHJvZmlsaW5nKS4gKilcbmxldCByZXZfZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVjIGZpbmQgfmYgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gZmluZCB+ZiAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCB+ZiBhY2N1IGxcbiAgaW5cbiAgZmluZCB+ZiBbXSB0XG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSByZXYgKHJldl9maWx0ZXIgdCB+ZilcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBsXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICBpblxuICBsb29wIHRcbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIGxvb3AgbFxuICBpblxuICBsb29wIHRcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmVjIGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCB4IDo6IHQgLT4gaWYgZiB4IHRoZW4geCBlbHNlIGZpbmRfZXhuIHQgfmZcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgKGksIHgpIGVsc2UgbG9vcCAoaSArIDEpIGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBmaW5kaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgZmluZGlfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBsKVxuICBpblxuICBsb29wIDAgdFxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gdHJ1ZVxuICAgIHwgaGQgOjogdGwgLT4gZiBpIGhkICYmIGxvb3AgKGkgKyAxKSB0bFxuICBpblxuICBsb29wIDAgdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCB8fCBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbigqKiBGb3IgdGhlIGNvbnRhaW5lciBpbnRlcmZhY2UuICopXG5sZXQgZm9sZF9sZWZ0ID0gZm9sZFxuXG5sZXQgdG9fYXJyYXkgPSBBcnJheS5vZl9saXN0XG5sZXQgdG9fbGlzdCB0ID0gdFxuXG5sZXQgbWF4X25vbl90YWlsY2FsbCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMV8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQncyBzbWFsbC4gVGhpc1xuICAgICBudW1iZXIgd2FzIHRha2VuIGZyb20gb2NhbWwjc3RkbGliL2xpc3QubWwgd2hpY2ggaXMgYWxzbyBlcXVhbCB0byB0aGUgZGVmYXVsdCBsaW1pdFxuICAgICBvZiByZWN1cnNpdmUgY2FsbCBpbiB0aGUganNfb2Zfb2NhbWwgY29tcGlsZXIgYmVmb3JlIHN3aXRjaGluZyB0byB0cmFtcG9saW5lLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG47O1xuXG4oKiogVGFpbCByZWN1cnNpdmUgdmVyc2lvbnMgb2Ygc3RhbmRhcmQgW0xpc3RdIG1vZHVsZSAqKVxuXG5sZXQgdGFpbF9hcHBlbmQgbDEgbDIgPSByZXZfYXBwZW5kIChyZXYgbDEpIGwyXG5cbigqIFRoZXJlIGFyZSBhIGZldyBvcHRpbWl6ZWQgbGlzdCBvcGVyYXRpb25zIGhlcmUsIGluY2x1ZGluZyBhcHBlbmQgYW5kIG1hcC4gIFRoZXJlIGFyZVxuICAgYmFzaWNhbGx5IHR3byBvcHRpbWl6YXRpb25zIGluIHBsYXk6IGxvb3AgdW5yb2xsaW5nLCBhbmQgZHluYW1pYyBzd2l0Y2hpbmcgYmV0d2VlblxuICAgc3RhY2sgYW5kIGhlYXAgYWxsb2NhdGlvbi5cblxuICAgVGhlIGxvb3AtdW5yb2xsaW5nIGlzIHN0cmFpZ2h0Zm9yd2FyZCwgd2UganVzdCB1bnJvbGwgNSBsZXZlbHMgb2YgdGhlIGxvb3AuICBUaGlzIG1ha2VzXG4gICBlYWNoIGl0ZXJhdGlvbiBmYXN0ZXIsIGFuZCBhbHNvIHJlZHVjZXMgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMgY29uc3VtZWQgcGVyIGxpc3RcbiAgIGVsZW1lbnQuXG5cbiAgIFRoZSBkeW5hbWljIHN3aXRjaGluZyBpcyBkb25lIGJ5IGNvdW50aW5nIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzLCBhbmQgdGhlblxuICAgc3dpdGNoaW5nIHRvIHRoZSBcInNsb3dcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIHdlIGV4Y2VlZCBhIGdpdmVuIGxpbWl0LiAgVGhpcyBtZWFucyB0aGF0XG4gICBzaG9ydCBsaXN0cyB1c2UgdGhlIGZhc3Qgc3RhY2stYWxsb2NhdGlvbiBtZXRob2QsIGFuZCBsb25nIGxpc3RzIHVzZSBhIHNsb3dlciBvbmUgdGhhdFxuICAgZG9lc24ndCByZXF1aXJlIHN0YWNrIHNwYWNlLiAqKVxubGV0IHJlYyBjb3VudF9hcHBlbmQgbDEgbDIgY291bnQgPVxuICBtYXRjaCBsMiB3aXRoXG4gIHwgW10gLT4gbDFcbiAgfCBfIC0+XG4gICAgKG1hdGNoIGwxIHdpdGhcbiAgICAgfCBbXSAtPiBsMlxuICAgICB8IFsgeDEgXSAtPiB4MSA6OiBsMlxuICAgICB8IFsgeDE7IHgyIF0gLT4geDEgOjogeDIgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDMgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiBsMlxuICAgICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiBsMlxuICAgICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgICAgeDFcbiAgICAgICA6OiB4MlxuICAgICAgIDo6IHgzXG4gICAgICAgOjogeDRcbiAgICAgICA6OiB4NVxuICAgICAgIDo6XG4gICAgICAgKGlmIGNvdW50ID4gbWF4X25vbl90YWlsY2FsbFxuICAgICAgICB0aGVuIHRhaWxfYXBwZW5kIHRsIGwyXG4gICAgICAgIGVsc2UgY291bnRfYXBwZW5kIHRsIGwyIChjb3VudCArIDEpKSlcbjs7XG5cbmxldCBhcHBlbmQgbDEgbDIgPSBjb3VudF9hcHBlbmQgbDEgbDIgMFxuXG4oKiBBbiBvcmRpbmFyeSB0YWlsIHJlY3Vyc2l2ZSBtYXAgYnVpbGRzIHVwIGFuIGludGVybWVkaWF0ZSAocmV2ZXJzZWQpIHJlcHJlc2VudGF0aW9uLFxuICAgd2l0aCBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0IHBlciBlbGVtZW50LiBUaGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uIGluc3RlYWQgY2h1bmtzXG4gICA5IG9iamVjdHMgaW50byBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0LCByZWR1Y2luZyBhbGxvY2F0aW9uIGFuZCBwZXJmb3JtYW5jZSBjb3N0c1xuICAgYWNjb3JkaW5nbHkuIE5vdGUgdGhhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGxpc3QgaXMgZG9uZSBieSB0aGUgc3RkbGliJ3MgbWFwXG4gICBmdW5jdGlvbi4gKilcbmxldCB0YWlsX21hcCB4cyB+ZiA9XG4gIGxldCByZWMgcmlzZSB5cyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB5c1xuICAgIHwgKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzIC0+XG4gICAgICByaXNlICh5MCA6OiB5MSA6OiB5MiA6OiB5MyA6OiB5NCA6OiB5NSA6OiB5NiA6OiB5NyA6OiB5OCA6OiB5cykgYnNcbiAgaW5cbiAgbGV0IHJlYyBkaXZlIGJzID0gZnVuY3Rpb25cbiAgICB8IHgwIDo6IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHg2IDo6IHg3IDo6IHg4IDo6IHhzIC0+XG4gICAgICBsZXQgeTAgPSBmIHgwIGluXG4gICAgICBsZXQgeTEgPSBmIHgxIGluXG4gICAgICBsZXQgeTIgPSBmIHgyIGluXG4gICAgICBsZXQgeTMgPSBmIHgzIGluXG4gICAgICBsZXQgeTQgPSBmIHg0IGluXG4gICAgICBsZXQgeTUgPSBmIHg1IGluXG4gICAgICBsZXQgeTYgPSBmIHg2IGluXG4gICAgICBsZXQgeTcgPSBmIHg3IGluXG4gICAgICBsZXQgeTggPSBmIHg4IGluXG4gICAgICBkaXZlICgoeTAsIHkxLCB5MiwgeTMsIHk0LCB5NSwgeTYsIHk3LCB5OCkgOjogYnMpIHhzXG4gICAgfCB4cyAtPiByaXNlIChub250YWlsX21hcCB+ZiB4cykgYnNcbiAgaW5cbiAgZGl2ZSBbXSB4c1xuOztcblxubGV0IHJlYyBjb3VudF9tYXAgfmYgbCBjdHIgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IFsgeDEgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBbIGYxIF1cbiAgfCBbIHgxOyB4MiBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBbIGYxOyBmMiBdXG4gIHwgWyB4MTsgeDI7IHgzIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBbIGYxOyBmMjsgZjMgXVxuICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgbGV0IGYzID0gZiB4MyBpblxuICAgIGxldCBmNCA9IGYgeDQgaW5cbiAgICBbIGYxOyBmMjsgZjM7IGY0IF1cbiAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgbGV0IGYzID0gZiB4MyBpblxuICAgIGxldCBmNCA9IGYgeDQgaW5cbiAgICBsZXQgZjUgPSBmIHg1IGluXG4gICAgZjFcbiAgICA6OiBmMlxuICAgIDo6IGYzXG4gICAgOjogZjRcbiAgICA6OiBmNVxuICAgIDo6IChpZiBjdHIgPiBtYXhfbm9uX3RhaWxjYWxsIHRoZW4gdGFpbF9tYXAgfmYgdGwgZWxzZSBjb3VudF9tYXAgfmYgdGwgKGN0ciArIDEpKVxuOztcblxubGV0IG1hcCBsIH5mID0gY291bnRfbWFwIH5mIGwgMFxuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCAoID4+fCApIGwgZiA9IG1hcCBsIH5mXG5sZXQgbWFwMl9vayBsMSBsMiB+ZiA9IHJldiAocmV2X21hcDJfb2sgbDEgbDIgfmYpXG5sZXQgbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KG1hcDJfb2sgfmYpXG5cbmxldCBtYXAyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwibWFwMl9leG5cIiBsMSBsMjtcbiAgbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAzX29rIGwxIGwyIGwzIH5mID1cbiAgbGV0IHJlYyBsb29wIGwxIGwyIGwzIGFjID1cbiAgICBtYXRjaCBsMSwgbDIsIGwzIHdpdGhcbiAgICB8IFtdLCBbXSwgW10gLT4gYWNcbiAgICB8IHgxIDo6IGwxLCB4MiA6OiBsMiwgeDMgOjogbDMgLT4gbG9vcCBsMSBsMiBsMyAoZiB4MSB4MiB4MyA6OiBhYylcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGxvb3AgbDEgbDIgbDMgW11cbjs7XG5cbmxldCByZXZfbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KHJldl9tYXAzX29rIH5mKVxuXG5sZXQgcmV2X21hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJyZXZfbWFwM19leG5cIiBsMSBsMiBsMztcbiAgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCBtYXAzX29rIGwxIGwyIGwzIH5mID0gcmV2IChyZXZfbWFwM19vayBsMSBsMiBsMyB+ZilcbmxldCBtYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoobWFwM19vayB+ZilcblxubGV0IG1hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJtYXAzX2V4blwiIGwxIGwyIGwzO1xuICBtYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kIGwxIGwyIH5mID1cbiAgbWF0Y2ggbDEgd2l0aFxuICB8IFtdIC0+IGwyXG4gIHwgaCA6OiB0IC0+IHJldl9tYXBfYXBwZW5kIH5mIHQgKGYgaCA6OiBsMilcbjs7XG5cbmxldCB1bnppcCBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyXG4gICAgfCAoeCwgeSkgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXVxuOztcblxubGV0IHVuemlwMyBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgbDMgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyLCBsM1xuICAgIHwgKHgsIHksIHopIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKSAoeiA6OiBsMylcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdIFtdXG47O1xuXG5sZXQgemlwX2V4biBsMSBsMiA9XG4gIHRyeSBtYXAyX29rIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiB6aXBfZXhuOiAlZCA8PiAlZFwiIChsZW5ndGggbDEpIChsZW5ndGggbDIpICgpXG47O1xuXG5sZXQgemlwIGwxIGwyID0gbWFwMiB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMlxuXG4oKiogQWRkaXRpb25hbCBsaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJldl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoIDo6IHQgLT4gbG9vcCAoaSArIDEpIChmIGkgaCA6OiBhY2MpIHRcbiAgaW5cbiAgbG9vcCAwIFtdIGxcbjs7XG5cbmxldCBtYXBpIGwgfmYgPSByZXYgKHJldl9tYXBpIGwgfmYpXG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGl0ZXJpIGwgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCBsIH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIHNuZCAoZm9sZCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHYgLT4gaSArIDEsIGYgaSBhY2MgdikpXG47O1xuXG5sZXQgZmlsdGVyaSBsIH5mID1cbiAgcmV2IChmb2xkaSBsIH5mOihmdW4gcG9zIGFjYyB4IC0+IGlmIGYgcG9zIHggdGhlbiB4IDo6IGFjYyBlbHNlIGFjYykgfmluaXQ6W10pXG47O1xuXG5sZXQgcmVkdWNlIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgaGQgOjogdGwgLT4gU29tZSAoZm9sZCB+aW5pdDpoZCB+ZiB0bClcbjs7XG5cbmxldCByZWR1Y2VfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2UgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiA9XG4gICgqIENhbGwgdGhlIFwic2l6ZVwiIG9mIGEgdmFsdWUgdGhlIG51bWJlciBvZiBsaXN0IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNvbWJpbmVkIGludG9cbiAgICAgaXQgdmlhIGNhbGxzIHRvIFtmXS4gIFdlIHByb2NlZWQgYnkgdXNpbmcgW2ZdIHRvIGNvbWJpbmUgZWxlbWVudHMgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgIG9mIHRoZSBzYW1lIHNpemUgdW50aWwgd2UgY2FuJ3QgY29tYmluZSBhbnkgbW9yZSwgdGhlbiBnZXR0aW5nIGEgbmV3IGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgaW5wdXQgbGlzdCBhbmQgcmVwZWF0aW5nLlxuXG4gICAgIFdpdGggdGhpcyBzdHJhdGVneSwgaW4gdGhlIGFjY3VtdWxhdG9yOlxuICAgICAtIHdlIG9ubHkgZXZlciBoYXZlIGVsZW1lbnRzIG9mIHNpemVzIGEgcG93ZXIgb2YgdHdvXG4gICAgIC0gd2UgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGVsZW1lbnQgb2YgZWFjaCBzaXplXG4gICAgIC0gdGhlIHN1bSBvZiBhbGwgdGhlIGVsZW1lbnQgc2l6ZXMgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZFxuXG4gICAgIFRoZXNlIGNvbmRpdGlvbnMgZW5mb3JjZSB0aGF0IGxpc3Qgb2YgZWxlbWVudHMgb2YgZWFjaCBzaXplIGlzIHByZWNpc2VseSB0aGUgYmluYXJ5XG4gICAgIGV4cGFuc2lvbiBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkOiBpZiB5b3UndmUgY29uc3VtZWQgMTMgPSAwYjExMDFcbiAgICAgZWxlbWVudHMsIHlvdSBoYXZlIG9uZSBlbGVtZW50IG9mIHNpemUgOCwgb25lIG9mIHNpemUgNCwgYW5kIG9uZSBvZiBzaXplIDEuICBIZW5jZVxuICAgICB3aGVuIGEgbmV3IGVsZW1lbnQgY29tZXMgYWxvbmcsIHRoZSBudW1iZXIgb2YgY29tYmluaW5ncyB5b3UgbmVlZCB0byBkbyBpcyB0aGUgbnVtYmVyXG4gICAgIG9mIHRyYWlsaW5nIDFzIGluIHRoZSBiaW5hcnkgZXhwYW5zaW9uIG9mIFtudW1dLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICBhbHJlYWR5IGdvbmUgaW50byB0aGUgYWNjdW11bGF0b3IuICBUaGUgYWNjdW11bGF0b3IgaXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHNpemUsIHNvXG4gICAgIHRoZSBuZXh0IGVsZW1lbnQgdG8gY29tYmluZSB3aXRoIGlzIGFsd2F5cyB0aGUgaGVhZCBvZiB0aGUgbGlzdC4gKilcbiAgbGV0IHJlYyBzdGVwX2FjY3VtIG51bSBhY2MgeCA9XG4gICAgaWYgbnVtIGxhbmQgMSA9IDBcbiAgICB0aGVuIHggOjogYWNjXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICgqIE5ldyBlbGVtZW50cyBmcm9tIGxhdGVyIGluIHRoZSBpbnB1dCBsaXN0IGdvIG9uIHRoZSBmcm9udCBvZiB0aGUgYWNjdW11bGF0b3IsIHNvXG4gICAgICAgICB0aGUgYWNjdW11bGF0b3IgaXMgaW4gcmV2ZXJzZSBvcmRlciB3cnQgdGhlIG9yaWdpbmFsIGxpc3Qgb3JkZXIsIGhlbmNlIFtmIHkgeF1cbiAgICAgICAgIGluc3RlYWQgb2YgW2YgeCB5XS4gKilcbiAgICAgIHwgeSA6OiB5cyAtPiBzdGVwX2FjY3VtIChudW0gYXNyIDEpIHlzIChmIHkgeCkpXG4gIGluXG4gICgqIEV4cGVyaW1lbnRhbGx5LCBpbmxpbmluZyBbZm9sZGldIGFuZCB1bnJvbGxpbmcgdGhpcyBsb29wIGEgZmV3IHRpbWVzIGNhbiByZWR1Y2VcbiAgICAgcnVudGltZSBkb3duIHRvIGEgdGhpcmQgYW5kIGFsbG9jYXRpb24gdG8gMS8xNnRoIG9yIHNvIGluIHRoZSBtaWNyb2JlbmNobWFya3MgYmVsb3cuXG4gICAgIEhvd2V2ZXIsIGluIG1vc3QgdXNlIGNhc2VzIFtmXSBpcyBsaWtlbHkgdG8gYmUgZXhwZW5zaXZlIChvdGhlcndpc2Ugd2h5IGRvIHlvdSBjYXJlXG4gICAgIGFib3V0IHRoZSBvcmRlciBvZiByZWR1Y3Rpb24/KSBzbyB0aGUgb3ZlcmhlYWQgb2YgdGhpcyBmdW5jdGlvbiBpdHNlbGYgZG9lc24ndCByZWFsbHlcbiAgICAgbWF0dGVyLiBJZiB5b3UgY29tZSB1cCB3aXRoIGEgdXNlLWNhc2Ugd2hlcmUgaXQgZG9lcywgdGhlbiB0aGF0J3Mgc29tZXRoaW5nIHlvdSBtaWdodFxuICAgICB3YW50IHRvIHRyeTogc2VlIGhnIGxvZyAtcHIgNDllZjA2NWY0MjlkLiAqKVxuICBtYXRjaCBmb2xkaSBsIH5pbml0OltdIH5mOnN0ZXBfYWNjdW0gd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IFNvbWUgKGZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIHggeSAtPiBmIHkgeCkpXG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlX2JhbGFuY2VkIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9iYWxhbmNlZF9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgZ3JvdXBpIGwgfmJyZWFrID1cbiAgbGV0IGdyb3VwcyA9XG4gICAgZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIHggLT5cbiAgICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgICB8IFtdIC0+IFsgWyB4IF0gXVxuICAgICAgfCBjdXJyZW50X2dyb3VwIDo6IHRsIC0+XG4gICAgICAgIGlmIGJyZWFrIGkgKGhkX2V4biBjdXJyZW50X2dyb3VwKSB4XG4gICAgICAgIHRoZW4gWyB4IF0gOjogY3VycmVudF9ncm91cCA6OiB0bCAoKiBzdGFydCBuZXcgZ3JvdXAgKilcbiAgICAgICAgZWxzZSAoeCA6OiBjdXJyZW50X2dyb3VwKSA6OiB0bClcbiAgICAoKiBleHRlbmQgY3VycmVudCBncm91cCAqKVxuICBpblxuICBtYXRjaCBncm91cHMgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgbCAtPiByZXZfbWFwIGwgfmY6cmV2XG47O1xuXG5sZXQgZ3JvdXAgbCB+YnJlYWsgPSBncm91cGkgbCB+YnJlYWs6KGZ1biBfIHggeSAtPiBicmVhayB4IHkpXG5cbmxldCBzb3J0X2FuZF9ncm91cCBsIH5jb21wYXJlID1cbiAgbCB8PiBzdGFibGVfc29ydCB+Y29tcGFyZSB8PiBncm91cCB+YnJlYWs6KGZ1biB4IHkgLT4gY29tcGFyZSB4IHkgPD4gMClcbjs7XG5cbmxldCBjb25jYXRfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gYXV4IChyZXZfYXBwZW5kIChmIGhkKSBhY2MpIHRsXG4gIGluXG4gIGF1eCBbXSBsXG47O1xuXG5sZXQgY29uY2F0X21hcGkgbCB+ZiA9XG4gIGxldCByZWMgYXV4IGNvbnQgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IGF1eCAoY29udCArIDEpIChyZXZfYXBwZW5kIChmIGNvbnQgaGQpIGFjYykgdGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuOztcblxubGV0IG1lcmdlIGwxIGwyIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGFjYyBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGFjYyBsMlxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgYWNjIGwxXG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNvbXBhcmUgaDEgaDIgPD0gMCB0aGVuIGxvb3AgKGgxIDo6IGFjYykgdDEgbDIgZWxzZSBsb29wIChoMiA6OiBhY2MpIGwxIHQyXG4gIGluXG4gIGxvb3AgW10gbDEgbDJcbjs7XG5cbm1vZHVsZSBDYXJ0ZXNpYW5fcHJvZHVjdCA9IHN0cnVjdFxuICAoKiBXZSBhcmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3ZSBleHBvcnQgZnJvbSBmdW5jdG9ycyBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseVxuICAgICByZWJpbmQgbW9yZSBlZmZpY2llbnQgbGlzdC1zcGVjaWZpYyBmdW5jdGlvbnMuICopXG5cbiAgbGV0IGJpbmQgPSBjb25jYXRfbWFwXG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcDIgYSBiIH5mID0gY29uY2F0X21hcCBhIH5mOihmdW4geCAtPiBtYXAgYiB+ZjooZnVuIHkgLT4gZiB4IHkpKVxuICBsZXQgcmV0dXJuIHggPSBbIHggXVxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG5cbiAgb3BlbiBzdHJ1Y3RcbiAgICBtb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgICAgbGV0IG1hcDIgPSBtYXAyXG4gICAgICBlbmQpXG5cbiAgICBtb2R1bGUgTW9uYWQgPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgZW5kKVxuICBlbmRcblxuICBsZXQgYWxsID0gTW9uYWQuYWxsXG4gIGxldCBhbGxfdW5pdCA9IE1vbmFkLmFsbF91bml0XG4gIGxldCBpZ25vcmVfbSA9IE1vbmFkLmlnbm9yZV9tXG4gIGxldCBqb2luID0gTW9uYWQuam9pblxuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuICBlbmRcblxuICBsZXQgYXBwbHkgPSBBcHBsaWNhdGl2ZS5hcHBseVxuICBsZXQgYm90aCA9IEFwcGxpY2F0aXZlLmJvdGhcbiAgbGV0IG1hcDMgPSBBcHBsaWNhdGl2ZS5tYXAzXG4gIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gICAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuICBlbmRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgKENhcnRlc2lhbl9wcm9kdWN0IDogTW9uYWQuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0KVxuXG4oKiogcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdF9leG4gbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IHhcbiAgfCBfIDo6IHRsIC0+IGxhc3RfZXhuIHRsXG4gIHwgW10gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lmxhc3RcIlxuOztcblxuKCoqIG9wdGlvbmFsbHkgcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdCBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4gU29tZSB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0IHRsXG4gIHwgW10gLT4gTm9uZVxuOztcblxubGV0IHJlYyBpc19wcmVmaXggbGlzdCB+cHJlZml4IH5lcXVhbCA9XG4gIG1hdGNoIHByZWZpeCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IGhkIDo6IHRsIC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+IGZhbHNlXG4gICAgIHwgaGQnIDo6IHRsJyAtPiBlcXVhbCBoZCBoZCcgJiYgaXNfcHJlZml4IHRsJyB+cHJlZml4OnRsIH5lcXVhbClcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBhMSA6OiB0IC0+XG4gICAgbGV0IHJlYyBsb29wIGExIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYTIgOjogdCAtPiBpZiBlcXVhbCBhMSBhMiB0aGVuIFNvbWUgKGExLCBhMikgZWxzZSBsb29wIGEyIHRcbiAgICBpblxuICAgIGxvb3AgYTEgdFxuOztcblxuKCogcmV0dXJucyBsaXN0IHdpdGhvdXQgYWRqYWNlbnQgZHVwbGljYXRlcyAqKVxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzID8od2hpY2hfdG9fa2VlcCA9IGBMYXN0KSBsaXN0IH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCB0b19rZWVwIGFjY3VtID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHRvX2tlZXAgOjogYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBlcXVhbCBoZCB0b19rZWVwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRvX2tlZXAgPVxuICAgICAgICAgIG1hdGNoIHdoaWNoX3RvX2tlZXAgd2l0aFxuICAgICAgICAgIHwgYEZpcnN0IC0+IHRvX2tlZXBcbiAgICAgICAgICB8IGBMYXN0IC0+IGhkXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgdG9fa2VlcCBhY2N1bSB0bClcbiAgICAgIGVsc2UgbG9vcCBoZCAodG9fa2VlcCA6OiBhY2N1bSkgdGxcbiAgaW5cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiByZXYgKGxvb3AgaGQgW10gdGwpXG47O1xuXG4oKiogcmV0dXJucyBzb3J0ZWQgdmVyc2lvbiBvZiBsaXN0IHdpdGggZHVwbGljYXRlcyByZW1vdmVkICopXG5sZXQgZGVkdXBfYW5kX3NvcnQgbGlzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIHwgWyBfIF0gLT4gbGlzdCAoKiBwZXJmb3JtYW5jZSBoYWNrICopXG4gIHwgXyAtPlxuICAgIGxldCBlcXVhbCB4IHgnID0gY29tcGFyZSB4IHgnID0gMCBpblxuICAgIGxldCBzb3J0ZWQgPSBzb3J0IH5jb21wYXJlIGxpc3QgaW5cbiAgICByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyB+ZXF1YWwgc29ydGVkXG47O1xuXG5sZXQgZmluZF9hX2R1cCBsIH5jb21wYXJlID1cbiAgbGV0IHNvcnRlZCA9IHNvcnQgbCB+Y29tcGFyZSBpblxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IE5vbmVcbiAgICB8IGhkMSA6OiAoaGQyIDo6IF8gYXMgdGwpIC0+IGlmIGNvbXBhcmUgaGQxIGhkMiA9IDAgdGhlbiBTb21lIGhkMSBlbHNlIGxvb3AgdGxcbiAgaW5cbiAgbG9vcCBzb3J0ZWRcbjs7XG5cbmxldCBjb250YWluc19kdXAgbHN0IH5jb21wYXJlID1cbiAgbWF0Y2ggZmluZF9hX2R1cCBsc3QgfmNvbXBhcmUgd2l0aFxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZpbmRfYWxsX2R1cHMgbCB+Y29tcGFyZSA9XG4gICgqIFdlIGFkZCB0aGlzIHJldmVyc2FsLCBzbyB3ZSBjYW4gc2tpcCBhIFtyZXZdIGF0IHRoZSBlbmQuIFdlIGNvdWxkIHNraXBcbiAgICAgW3Jldl0gYW55d2F5IHNpbmNlIHdlIGRvbiBub3QgZ2l2ZSBhbnkgb3JkZXJpbmcgZ3VhcmFudGVlcywgYnV0IGl0IGlzXG4gICAgIG5pY2UgdG8gZ2V0IHJlc3VsdHMgaW4gbmF0dXJhbCBvcmRlci4gKilcbiAgbGV0IGNvbXBhcmUgYSBiID0gLTEgKiBjb21wYXJlIGEgYiBpblxuICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsIGluXG4gICgqIFdhbGsgdGhlIGxpc3QgYW5kIHJlY29yZCB0aGUgZmlyc3Qgb2YgZWFjaCBjb25zZWN1dGl2ZSBydW4gb2YgaWRlbnRpY2FsIGVsZW1lbnRzICopXG4gIGxldCByZWMgbG9vcCBzb3J0ZWQgcHJldiB+YWxyZWFkeV9yZWNvcmRlZCBhY2MgPVxuICAgIG1hdGNoIHNvcnRlZCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBjb21wYXJlIHByZXYgaGQgPD4gMFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIGFjY1xuICAgICAgZWxzZSBpZiBhbHJlYWR5X3JlY29yZGVkXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSBhY2NcbiAgICAgIGVsc2UgbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlIChoZCA6OiBhY2MpXG4gIGluXG4gIG1hdGNoIHNvcnRlZCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIFtdXG47O1xuXG5sZXQgcmVjIGFsbF9lcXVhbF90byB0IHYgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IHggOjogeHMgLT4gZXF1YWwgeCB2ICYmIGFsbF9lcXVhbF90byB4cyB2IH5lcXVhbFxuOztcblxubGV0IGFsbF9lcXVhbCB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IGlmIGFsbF9lcXVhbF90byB4cyB4IH5lcXVhbCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcbjs7XG5cbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpZHggY291bnQgYSAtPiBpZiBmIGlkeCBhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG47O1xuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmluaXQgJWRcIiBuICgpO1xuICBsZXQgcmVjIGxvb3AgaSBhY2N1bSA9XG4gICAgYXNzZXJ0IChpID49IDApO1xuICAgIGlmIGkgPSAwIHRoZW4gYWNjdW0gZWxzZSBsb29wIChpIC0gMSkgKGYgKGkgLSAxKSA6OiBhY2N1bSlcbiAgaW5cbiAgbG9vcCBuIFtdXG47O1xuXG5sZXQgcmV2X2ZpbHRlcl9tYXAgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgbCBbXVxuOztcblxubGV0IGZpbHRlcl9tYXAgbCB+ZiA9IHJldiAocmV2X2ZpbHRlcl9tYXAgbCB+ZilcblxubGV0IHJldl9maWx0ZXJfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGkgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgKGkgKyAxKSB0bCAoeCA6OiBhY2N1bSlcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIHRsIGFjY3VtKVxuICBpblxuICBsb29wIDAgbCBbXVxuOztcblxubGV0IGZpbHRlcl9tYXBpIGwgfmYgPSByZXYgKHJldl9maWx0ZXJfbWFwaSBsIH5mKVxubGV0IGZpbHRlcl9vcHQgbCA9IGZpbHRlcl9tYXAgbCB+ZjpGbi5pZFxuXG5sZXQgcGFydGl0aW9uM19tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IGZzdCBzbmQgdHJkID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmQsIHJldiB0cmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBgRnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kIHRyZFxuICAgICAgIHwgYFNuZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSB0cmRcbiAgICAgICB8IGBUcmQgeSAtPiBsb29wIHQgZnN0IHNuZCAoeSA6OiB0cmQpKVxuICBpblxuICBsb29wIHQgW10gW10gW11cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gIGxldCBmIHggOiBfIEVpdGhlci50ID0gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4IGluXG4gIHBhcnRpdGlvbl9tYXAgdCB+ZlxuOztcblxubGV0IHBhcnRpdGlvbl9yZXN1bHQgdCA9IHBhcnRpdGlvbl9tYXAgdCB+ZjpSZXN1bHQudG9fZWl0aGVyXG5cbm1vZHVsZSBBc3NvYyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EgKiAnYikgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdhICdiLlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAyMl8gPSBcImxpc3QubWwuQXNzb2MudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMTRfIF9vZl9iX18wMTVfIHhfXzAyM18gLT5cbiAgICAgIGxpc3Rfb2Zfc2V4cFxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzAxN187IGFyZzFfXzAxOF8gXSAtPlxuICAgICAgICAgICAgbGV0IHJlczBfXzAxOV8gPSBfb2ZfYV9fMDE0XyBhcmcwX18wMTdfXG4gICAgICAgICAgICBhbmQgcmVzMV9fMDIwXyA9IF9vZl9iX18wMTVfIGFyZzFfXzAxOF8gaW5cbiAgICAgICAgICAgIHJlczBfXzAxOV8sIHJlczFfXzAyMF9cbiAgICAgICAgICB8IHNleHBfXzAyMV8gLT5cbiAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjJfXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgc2V4cF9fMDIxXylcbiAgICAgICAgeF9fMDIzX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfYV9fMDI0XyBfb2ZfYl9fMDI1XyB4X18wMzBfIC0+XG4gICAgICBzZXhwX29mX2xpc3RcbiAgICAgICAgKGZ1biAoYXJnMF9fMDI2XywgYXJnMV9fMDI3XykgLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAyOF8gPSBfb2ZfYV9fMDI0XyBhcmcwX18wMjZfXG4gICAgICAgICAgIGFuZCByZXMxX18wMjlfID0gX29mX2JfXzAyNV8gYXJnMV9fMDI3XyBpblxuICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wMjhfOyByZXMxX18wMjlfIF0pXG4gICAgICAgIHhfXzAzMF9cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgICBsaXN0X3NleHBfZ3JhbW1hclxuICAgICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgICAgTGlzdCAoQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSkpXG4gICAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBwYWlyX29mX2dyb3VwID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGssIF8pIDo6IF8gYXMgbGlzdCAtPiBrLCBtYXAgbGlzdCB+ZjpzbmRcbiAgOztcblxuICBsZXQgZ3JvdXAgYWxpc3QgfmVxdWFsID1cbiAgICBncm91cCBhbGlzdCB+YnJlYWs6KGZ1biAoeCwgXykgKHksIF8pIC0+IG5vdCAoZXF1YWwgeCB5KSkgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmUgPVxuICAgIHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlOihmdW4gKHgsIF8pICh5LCBfKSAtPiBjb21wYXJlIHggeSlcbiAgICB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5mOihmdW4gKGtleScsIF8pIC0+IGVxdWFsIGtleSBrZXknKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChzbmQgeClcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuQXNzb2MuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICAgIGxldCBmaW5kX2V4biB0IH5lcXVhbCBrZXkgPVxuICAgICAgbWF0Y2ggZmluZCB0IGtleSB+ZXF1YWwgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHZhbHVlIC0+IHZhbHVlXG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5lcXVhbCBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBfIC0+IHRydWVcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgfmVxdWFsIGtleSA9IGZpbHRlciB0IH5mOihmdW4gKGtleScsIF8pIC0+IG5vdCAoZXF1YWwga2V5IGtleScpKVxuXG4gIGxldCBhZGQgdCB+ZXF1YWwga2V5IHZhbHVlID1cbiAgICAoKiB0aGUgcmVtb3ZlIGRvZXNuJ3QgY2hhbmdlIHRoZSBtYXAgc2VtYW50aWNzLCBidXQga2VlcHMgdGhlIGxpc3Qgc21hbGwgKilcbiAgICAoa2V5LCB2YWx1ZSkgOjogcmVtb3ZlIHQgfmVxdWFsIGtleVxuICA7O1xuXG4gIGxldCBpbnZlcnNlIHQgPSBtYXAgdCB+ZjooZnVuICh4LCB5KSAtPiB5LCB4KVxuICBsZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZjooZnVuIChrZXksIHZhbHVlKSAtPiBrZXksIGYgdmFsdWUpXG5lbmRcblxubGV0IHN1YiBsIH5wb3MgfmxlbiA9XG4gICgqIFdlIHVzZSBbcG9zID4gbGVuZ3RoIGwgLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiBsZW5ndGggbF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gbGVuZ3RoIGwgLSBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3Quc3ViXCI7XG4gIHJldlxuICAgIChmb2xkaSBsIH5pbml0OltdIH5mOihmdW4gaSBhY2MgZWwgLT5cbiAgICAgICBpZiBpID49IHBvcyAmJiBpIDwgcG9zICsgbGVuIHRoZW4gZWwgOjogYWNjIGVsc2UgYWNjKSlcbjs7XG5cbmxldCBzcGxpdF9uIHRfb3JpZyBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gW10sIHRfb3JpZ1xuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bSwgdFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZywgW10gKCogaW4gdGhpcyBjYXNlLCB0X29yaWcgPSByZXYgYWNjdW0gKilcbiAgICAgICAgfCBoZCA6OiB0bCAtPiBsb29wIChuIC0gMSkgdGwgKGhkIDo6IGFjY3VtKSlcbiAgICBpblxuICAgIGxvb3AgbiB0X29yaWcgW10pXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfbl0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZSB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBuIHQgYWNjdW0gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gcmV2IGFjY3VtXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gdF9vcmlnXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxubGV0IHJlYyBkcm9wIHQgbiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IF8gOjogdGwgd2hlbiBuID4gMCAtPiBkcm9wIHRsIChuIC0gMSlcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBjaHVua3Nfb2YgbCB+bGVuZ3RoID1cbiAgaWYgbGVuZ3RoIDw9IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmNodW5rc19vZjogRXhwZWN0ZWQgbGVuZ3RoID4gMCwgZ290ICVkXCIgbGVuZ3RoICgpO1xuICBsZXQgcmVjIGF1eCBvZl9sZW5ndGggYWNjIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgXyA6OiBfIC0+XG4gICAgICBsZXQgc3VibGlzdCwgbCA9IHNwbGl0X24gbCBsZW5ndGggaW5cbiAgICAgIGF1eCBvZl9sZW5ndGggKHN1Ymxpc3QgOjogYWNjKSBsXG4gIGluXG4gIGF1eCBsZW5ndGggW10gbFxuOztcblxubGV0IHNwbGl0X3doaWxlIHhzIH5mID1cbiAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gbG9vcCAoaGQgOjogYWNjKSB0bFxuICAgIHwgdCAtPiByZXYgYWNjLCB0XG4gIGluXG4gIGxvb3AgW10geHNcbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF93aGlsZV0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZV93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IF8gLT4gcmV2IGFjY1xuICBpblxuICBsb29wIFtdIHhzXG47O1xuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBkcm9wX3doaWxlIHRsIH5mXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgZHJvcF9sYXN0IHQgPVxuICBtYXRjaCByZXYgdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogbHN0IC0+IFNvbWUgKHJldiBsc3QpXG47O1xuXG5sZXQgZHJvcF9sYXN0X2V4biB0ID1cbiAgbWF0Y2ggZHJvcF9sYXN0IHQgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJMaXN0LmRyb3BfbGFzdF9leG46IGVtcHR5IGxpc3RcIlxuICB8IFNvbWUgbHN0IC0+IGxzdFxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IGxpc3QxIGxpc3QyID1cbiAgaWYgaXNfZW1wdHkgbGlzdDJcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbDEgbDIgYWNjdW0gPVxuICAgICAgbWF0Y2ggbDEgd2l0aFxuICAgICAgfCBbXSAtPiBhY2N1bVxuICAgICAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGwyIChyZXZfYXBwZW5kIChtYXAgfmY6KGZ1biB4IC0+IGhkLCB4KSBsMikgYWNjdW0pXG4gICAgaW5cbiAgICByZXYgKGxvb3AgbGlzdDEgbGlzdDIgW10pKVxuOztcblxubGV0IGNvbmNhdCBsID0gZm9sZF9yaWdodCBsIH5pbml0OltdIH5mOmFwcGVuZFxubGV0IGNvbmNhdF9ub19vcmRlciBsID0gZm9sZCBsIH5pbml0OltdIH5mOihmdW4gYWNjIGwgLT4gcmV2X2FwcGVuZCBsIGFjYylcbmxldCBjb25zIHggbCA9IHggOjogbFxuXG5sZXQgaXNfc29ydGVkIGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPD0gMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsXG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPCAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGxcbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gICgqIHNwZWNpYWwgY2FzZXMgdG8gc3BlZWQgdGhpbmdzIHVwIGluIHRyaXZpYWwgY2FzZXMgKilcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3RcbiAgfCBbIHg7IHkgXSAtPiBpZiBSYW5kb20uU3RhdGUuYm9vbCByYW5kb21fc3RhdGUgdGhlbiBbIHk7IHggXSBlbHNlIGxpc3RcbiAgfCBfIC0+XG4gICAgbGV0IGFyciA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIEFycmF5X3Blcm11dGUucGVybXV0ZSBhcnIgfnJhbmRvbV9zdGF0ZTtcbiAgICBBcnJheS50b19saXN0IGFyclxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgaWYgaXNfZW1wdHkgbGlzdFxuICB0aGVuIGZhaWx3aXRoIFwiTGlzdC5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGxpc3RcIlxuICBlbHNlIG50aF9leG4gbGlzdCAoUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCBsaXN0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIGxpc3QpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgY29tcGFyZSBjbXAgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgaWYgbiA9IDAgdGhlbiBjb21wYXJlIGNtcCB4cyB5cyBlbHNlIG5cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA9IGhhc2hfZm9sZF9saXN0XG5cbmxldCBlcXVhbCBlcXVhbCB0MSB0MiA9XG4gIGxldCByZWMgbG9vcCB+ZXF1YWwgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgeDEgOjogdDEsIHgyIDo6IHQyIC0+IGVxdWFsIHgxIHgyICYmIGxvb3AgfmVxdWFsIHQxIHQyXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgfmVxdWFsIHQxIHQyXG47O1xuXG5sZXQgdHJhbnNwb3NlID1cbiAgbGV0IHJlYyBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHQgY29sdW1uX2FjYyB0cmltbWVkIGZvdW5kX2VtcHR5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGNvbHVtbl9hY2MsIHRyaW1tZWQsIGZvdW5kX2VtcHR5XG4gICAgfCBbXSA6OiB0bCAtPiBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsIGNvbHVtbl9hY2MgdHJpbW1lZCB0cnVlXG4gICAgfCAoeCA6OiB4cykgOjogdGwgLT5cbiAgICAgIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgKHggOjogY29sdW1uX2FjYykgKHhzIDo6IHRyaW1tZWQpIGZvdW5kX2VtcHR5XG4gIGluXG4gIGxldCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgPSBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgW10gW10gZmFsc2UgaW5cbiAgbGV0IHJlYyBsb29wIHJvd3MgY29sdW1ucyBkb19yZXYgPVxuICAgIG1hdGNoIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyB3aXRoXG4gICAgfCBbXSwgW10sIF8gLT4gU29tZSAocmV2IGNvbHVtbnMpXG4gICAgfCBjb2x1bW4sIHRyaW1tZWRfcm93cywgZm91bmRfZW1wdHkgLT5cbiAgICAgIGlmIGZvdW5kX2VtcHR5XG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgY29sdW1uID0gaWYgZG9fcmV2IHRoZW4gcmV2IGNvbHVtbiBlbHNlIGNvbHVtbiBpblxuICAgICAgICBsb29wIHRyaW1tZWRfcm93cyAoY29sdW1uIDo6IGNvbHVtbnMpIChub3QgZG9fcmV2KSlcbiAgaW5cbiAgZnVuIHQgLT4gbG9vcCB0IFtdIHRydWVcbjs7XG5cbmV4Y2VwdGlvbiBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIG9mIGludCBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXVxuICAgIChmdW5jdGlvblxuICAgICAgfCBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIGFyZzBfXzAzMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMl8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9pbnQgYXJnMF9fMDMxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxpc3QubWwuVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc1wiXG4gICAgICAgICAgOyByZXMwX18wMzJfXG4gICAgICAgICAgXVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmxldCB0cmFuc3Bvc2VfZXhuIGwgPVxuICBtYXRjaCB0cmFuc3Bvc2UgbCB3aXRoXG4gIHwgU29tZSBsIC0+IGxcbiAgfCBOb25lIC0+IHJhaXNlIChUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIChtYXAgbCB+ZjpsZW5ndGgpKVxuOztcblxubGV0IGludGVyc3BlcnNlIHQgfnNlcCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiB4IDo6IGZvbGRfcmlnaHQgeHMgfmluaXQ6W10gfmY6KGZ1biB5IGFjYyAtPiBzZXAgOjogeSA6OiBhY2MpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuXG5sZXQgaXNfc3VmZml4IGxpc3QgfnN1ZmZpeCB+ZXF1YWw6ZXF1YWxfZWx0ID1cbiAgbGV0IGxpc3RfbGVuID0gbGVuZ3RoIGxpc3QgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIGxpc3RfbGVuID49IHN1ZmZpeF9sZW4gJiYgZXF1YWwgZXF1YWxfZWx0IChkcm9wIGxpc3QgKGxpc3RfbGVuIC0gc3VmZml4X2xlbikpIHN1ZmZpeFxuOztcbiIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0luZm9dLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIGFzIG1hbnkgcGxhY2VzIGFzIHBvc3NpYmxlLiBQbGVhc2UgYXZvaWRcbiAgIGFkZGluZyBuZXcgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb19pbnRmXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG5tb2R1bGUgTWVzc2FnZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBvZiBTZXhwLnRcbiAgICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgICB8IEV4biBvZiBleG5cbiAgICB8IFNleHAgb2YgU2V4cC50XG4gICAgfCBUYWdfc2V4cCBvZiBzdHJpbmcgKiBTZXhwLnQgKiBTb3VyY2VfY29kZV9wb3NpdGlvbjAudCBvcHRpb25cbiAgICB8IFRhZ190IG9mIHN0cmluZyAqIHRcbiAgICB8IFRhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50ICogdFxuICAgIHwgT2ZfbGlzdCBvZiBpbnQgb3B0aW9uICogdCBsaXN0XG4gICAgfCBXaXRoX2JhY2t0cmFjZSBvZiB0ICogc3RyaW5nICgqIGJhY2t0cmFjZSAqKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3QgYXJnMF9fMDAxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDAyXyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ291bGRfbm90X2NvbnN0cnVjdFwiOyByZXMwX18wMDJfIF1cbiAgICAgIHwgU3RyaW5nIGFyZzBfXzAwM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlN0cmluZ1wiOyByZXMwX18wMDRfIF1cbiAgICAgIHwgRXhuIGFyZzBfXzAwNV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNl8gPSBzZXhwX29mX2V4biBhcmcwX18wMDVfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4blwiOyByZXMwX18wMDZfIF1cbiAgICAgIHwgU2V4cCBhcmcwX18wMDdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDhfID0gU2V4cC5zZXhwX29mX3QgYXJnMF9fMDA3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZXhwXCI7IHJlczBfXzAwOF8gXVxuICAgICAgfCBUYWdfc2V4cCAoYXJnMF9fMDA5XywgYXJnMV9fMDEwXywgYXJnMl9fMDExXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDlfXG4gICAgICAgIGFuZCByZXMxX18wMTNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDEwX1xuICAgICAgICBhbmQgcmVzMl9fMDE0XyA9IHNleHBfb2Zfb3B0aW9uIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgYXJnMl9fMDExXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19zZXhwXCI7IHJlczBfXzAxMl87IHJlczFfXzAxM187IHJlczJfXzAxNF8gXVxuICAgICAgfCBUYWdfdCAoYXJnMF9fMDE1XywgYXJnMV9fMDE2XykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTVfXG4gICAgICAgIGFuZCByZXMxX18wMThfID0gc2V4cF9vZl90IGFyZzFfXzAxNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX3RcIjsgcmVzMF9fMDE3XzsgcmVzMV9fMDE4XyBdXG4gICAgICB8IFRhZ19hcmcgKGFyZzBfXzAxOV8sIGFyZzFfXzAyMF8sIGFyZzJfXzAyMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE5X1xuICAgICAgICBhbmQgcmVzMV9fMDIzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAyMF9cbiAgICAgICAgYW5kIHJlczJfXzAyNF8gPSBzZXhwX29mX3QgYXJnMl9fMDIxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19hcmdcIjsgcmVzMF9fMDIyXzsgcmVzMV9fMDIzXzsgcmVzMl9fMDI0XyBdXG4gICAgICB8IE9mX2xpc3QgKGFyZzBfXzAyNV8sIGFyZzFfXzAyNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjdfID0gc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9pbnQgYXJnMF9fMDI1X1xuICAgICAgICBhbmQgcmVzMV9fMDI4XyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX3QgYXJnMV9fMDI2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPZl9saXN0XCI7IHJlczBfXzAyN187IHJlczFfXzAyOF8gXVxuICAgICAgfCBXaXRoX2JhY2t0cmFjZSAoYXJnMF9fMDI5XywgYXJnMV9fMDMwXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBzZXhwX29mX3QgYXJnMF9fMDI5X1xuICAgICAgICBhbmQgcmVzMV9fMDMyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzFfXzAzMF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiV2l0aF9iYWNrdHJhY2VcIjsgcmVzMF9fMDMxXzsgcmVzMV9fMDMyXyBdXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcmVjIHRvX3N0cmluZ3NfaHVtIHQgYWMgPVxuICAgICgqIFdlIHVzZSBbU2V4cC50b19zdHJpbmdfbWFjaF0sIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCB3ZSBhcmUgaW1wbGVtZW50aW5nXG4gICAgICAgW3RvX3N0cmluZ3NfaHVtXSwgYmVjYXVzZSB3ZSB3YW50IHRoZSBpbmZvIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lLCBhbmQgb25jZSB3ZSd2ZVxuICAgICAgIGhhZCB0byByZXNvcnQgdG8gc2V4cHMsIHRoZSBtZXNzYWdlIGlzIGdvaW5nIHRvIHN0YXJ0IG5vdCBsb29raW5nIHNvIHByZXR0eVxuICAgICAgIGFueXdheS4gKilcbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgc2V4cCAtPlxuICAgICAgXCJjb3VsZCBub3QgY29uc3RydWN0IGluZm86IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gU2V4cC50b19zdHJpbmdfbWFjaCAoRXhuLnNleHBfb2ZfdCBleG4pIDo6IGFjXG4gICAgfCBTZXhwIHNleHAgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBfKSAtPiB0YWcgOjogXCI6IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gdGFnIDo6IFwiOiBcIiA6OiB0b19zdHJpbmdzX2h1bSB0IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhYyBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gYm9keSBlbHNlIHRhZyA6OiBcIjogXCIgOjogYm9keVxuICAgIHwgV2l0aF9iYWNrdHJhY2UgKHQsIGJhY2t0cmFjZSkgLT5cbiAgICAgIHRvX3N0cmluZ3NfaHVtIHQgKFwiXFxuQmFja3RyYWNlOlxcblwiIDo6IGJhY2t0cmFjZSA6OiBhYylcbiAgICB8IE9mX2xpc3QgKHRydW5jX2FmdGVyLCB0cykgLT5cbiAgICAgIGxldCB0cyA9XG4gICAgICAgIG1hdGNoIHRydW5jX2FmdGVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRzXG4gICAgICAgIHwgU29tZSBtYXggLT5cbiAgICAgICAgICBsZXQgbiA9IExpc3QubGVuZ3RoIHRzIGluXG4gICAgICAgICAgaWYgbiA8PSBtYXhcbiAgICAgICAgICB0aGVuIHRzXG4gICAgICAgICAgZWxzZSBMaXN0LnRha2UgdHMgbWF4IEAgWyBTdHJpbmcgKFByaW50Zi5zcHJpbnRmIFwiYW5kICVkIG1vcmUgaW5mb1wiIChuIC0gbWF4KSkgXVxuICAgICAgaW5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPlxuICAgICAgICB0b19zdHJpbmdzX2h1bSB0IChpZiBMaXN0LmlzX2VtcHR5IGFjIHRoZW4gYWMgZWxzZSBcIjsgXCIgOjogYWMpKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IFN0cmluZy5jb25jYXQgKHRvX3N0cmluZ3NfaHVtIHQgW10pXG5cbiAgbGV0IHJlYyB0b19zZXhwc19odW0gdCBhYyA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IF8gYXMgdCAtPiBzZXhwX29mX3QgdCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBBdG9tIHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBFeG4uc2V4cF9vZl90IGV4biA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIGhlcmUpIC0+XG4gICAgICBMaXN0XG4gICAgICAgIChBdG9tIHRhZ1xuICAgICAgICAgOjogc2V4cFxuICAgICAgICAgOjpcbiAgICAgICAgIChtYXRjaCBoZXJlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgaGVyZSAtPiBbIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZSBdKSlcbiAgICAgIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiBMaXN0IChBdG9tIHRhZyA6OiB0b19zZXhwc19odW0gdCBbXSkgOjogYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gc2V4cCA6OiB0b19zZXhwc19odW0gdCBbXSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gTGlzdCBib2R5IDo6IGFjIGVsc2UgTGlzdCAoQXRvbSB0YWcgOjogYm9keSkgOjogYWNcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICBTZXhwLkxpc3QgWyB0b19zZXhwX2h1bSB0OyBTZXhwLkF0b20gYmFja3RyYWNlIF0gOjogYWNcbiAgICB8IE9mX2xpc3QgKF8sIHRzKSAtPlxuICAgICAgTGlzdC5mb2xkIChMaXN0LnJldiB0cykgfmluaXQ6YWMgfmY6KGZ1biBhYyB0IC0+IHRvX3NleHBzX2h1bSB0IGFjKVxuXG4gIGFuZCB0b19zZXhwX2h1bSB0ID1cbiAgICBtYXRjaCB0b19zZXhwc19odW0gdCBbXSB3aXRoXG4gICAgfCBbIHNleHAgXSAtPiBzZXhwXG4gICAgfCBzZXhwcyAtPiBTZXhwLkxpc3Qgc2V4cHNcbiAgOztcblxuICAoKiBXZSB1c2UgW3Byb3RlY3RdIHRvIGd1YXJkIGFnYWluc3QgZXhjZXB0aW9ucyByYWlzZWQgYnkgdXNlci1zdXBwbGllZCBmdW5jdGlvbnMsIHNvXG4gICAgIHRoYXQgZmFpbHVyZSB0byBwcm9kdWNlIG9uZSBwYXJ0IG9mIGFuIGluZm8gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCBvdGhlciBwYXJ0cy4gKilcbiAgbGV0IHByb3RlY3QgZiA9XG4gICAgdHJ5IGYgKCkgd2l0aFxuICAgIHwgZXhuIC0+IENvdWxkX25vdF9jb25zdHJ1Y3QgKEV4bi5zZXhwX29mX3QgZXhuKVxuICA7O1xuXG4gIGxldCBvZl9pbmZvIGluZm8gPSBwcm90ZWN0IChmdW4gKCkgLT4gTGF6eS5mb3JjZSBpbmZvKVxuICBsZXQgdG9faW5mbyB0ID0gbGF6eSB0XG5lbmRcblxub3BlbiBNZXNzYWdlXG5cbnR5cGUgdCA9IE1lc3NhZ2UudCBMYXp5LnRcblxubGV0IGludmFyaWFudCBfID0gKClcbmxldCB0b19tZXNzYWdlID0gTWVzc2FnZS5vZl9pbmZvXG5sZXQgb2ZfbWVzc2FnZSA9IE1lc3NhZ2UudG9faW5mb1xuXG4oKiBJdCBpcyBPSyB0byB1c2UgW01lc3NhZ2UudG9fc2V4cF9odW1dLCB3aGljaCBpcyBub3Qgc3RhYmxlLCBiZWNhdXNlIFt0X29mX3NleHBdIGJlbG93XG4gICBjYW4gaGFuZGxlIGFueSBzZXhwLiAqKVxubGV0IHNleHBfb2ZfdCB0ID0gTWVzc2FnZS50b19zZXhwX2h1bSAodG9fbWVzc2FnZSB0KVxubGV0IHRfb2Zfc2V4cCBzZXhwID0gbGF6eSAoTWVzc2FnZS5TZXhwIHNleHApXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBBbnkgXCJJbmZvLnRcIiB9XG5sZXQgY29tcGFyZSB0MSB0MiA9IFNleHAuY29tcGFyZSAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGVxdWFsIHQxIHQyID0gU2V4cC5lcXVhbCAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBTZXhwLmhhc2hfZm9sZF90IHN0YXRlIChzZXhwX29mX3QgdClcbmxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG5cbmxldCB0b19zdHJpbmdfaHVtIHQgPVxuICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICB8IFN0cmluZyBzIC0+IHNcbiAgfCBtZXNzYWdlIC0+IFNleHAudG9fc3RyaW5nX2h1bSAoTWVzc2FnZS50b19zZXhwX2h1bSBtZXNzYWdlKVxuOztcblxubGV0IHRvX3N0cmluZ19odW1fZGVwcmVjYXRlZCB0ID0gTWVzc2FnZS50b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgKHRvX21lc3NhZ2UgdClcbmxldCB0b19zdHJpbmdfbWFjaCB0ID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl90IHQpXG5sZXQgb2ZfbGF6eSBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV9zZXhwIGwgPSBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gU2V4cCAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV90IGxhenlfdCA9IExhenkuam9pbiBsYXp5X3RcbmxldCBvZl9zdHJpbmcgbWVzc2FnZSA9IExhenkuZnJvbV92YWwgKFN0cmluZyBtZXNzYWdlKVxubGV0IGNyZWF0ZWYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIG9mX3N0cmluZyBmb3JtYXRcbmxldCBvZl90aHVuayBmID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoZiAoKSkpKVxuXG5sZXQgY3JlYXRlID9oZXJlID9zdHJpY3QgdGFnIHggc2V4cF9vZl94ID1cbiAgbWF0Y2ggc3RyaWN0IHdpdGhcbiAgfCBOb25lIC0+IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfc2V4cCAodGFnLCBzZXhwX29mX3ggeCwgaGVyZSkpKVxuICB8IFNvbWUgKCkgLT4gb2ZfbWVzc2FnZSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBMYXp5LmZyb21fdmFsIChTZXhwIHNleHApXG5sZXQgdGFnIHQgfnRhZyA9IGxhenkgKFRhZ190ICh0YWcsIHRvX21lc3NhZ2UgdCkpXG5cbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnIChcIlwiLCBMYXp5LmZvcmNlIHRhZywgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgdGFnX3MgdCB+dGFnID0gdGFnX3NfbGF6eSB0IH50YWc6KExhenkuZnJvbV92YWwgdGFnKVxuXG5sZXQgdGFnX2FyZyB0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnICh0YWcsIHNleHBfb2ZfeCB4LCB0b19tZXNzYWdlIHQpKSlcbjs7XG5cbmxldCBvZl9saXN0ID90cnVuY19hZnRlciB0cyA9IGxhenkgKE9mX2xpc3QgKHRydW5jX2FmdGVyLCBMaXN0Lm1hcCB0cyB+Zjp0b19tZXNzYWdlKSlcblxuZXhjZXB0aW9uIEV4biBvZiB0XG5cbmxldCAoKSA9XG4gICgqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2VcbiAgICAgW2V4Y2VwdGlvbiBFeG4gb2YgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF0gLi4uIFtAQEBlbmRdXSB0byBlbGltaW5hdGUgdGhlIGV4dHJhXG4gICAgIHdyYXBwaW5nIG9mIFwiKEV4biAuLi4pXCIuICopXG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeG5dIChmdW5jdGlvblxuICAgIHwgRXhuIHQgLT4gc2V4cF9vZl90IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IHRvX2V4biB0ID1cbiAgaWYgbm90IChMYXp5LmlzX3ZhbCB0KVxuICB0aGVuIEV4biB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIExhenkuZm9yY2UgdCB3aXRoXG4gICAgfCBNZXNzYWdlLkV4biBleG4gLT4gZXhuXG4gICAgfCBfIC0+IEV4biB0KVxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9XG4gIGxldCBiYWNrdHJhY2UgPVxuICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYEdldCAtPiBTb21lIChDYW1sLlByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gICAgfCBTb21lIChgVGhpcyBzKSAtPiBTb21lIHNcbiAgaW5cbiAgbWF0Y2ggZXhuLCBiYWNrdHJhY2Ugd2l0aFxuICB8IEV4biB0LCBOb25lIC0+IHRcbiAgfCBFeG4gdCwgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKHRvX21lc3NhZ2UgdCwgYmFja3RyYWNlKSlcbiAgfCBfLCBOb25lIC0+IExhenkuZnJvbV92YWwgKE1lc3NhZ2UuRXhuIGV4bilcbiAgfCBfLCBTb21lIGJhY2t0cmFjZSAtPiBsYXp5IChXaXRoX2JhY2t0cmFjZSAoU2V4cCAoRXhuLnNleHBfb2ZfdCBleG4pLCBiYWNrdHJhY2UpKVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbmZvXCJcbiAgICBsZXQgcHAgcHBmIHQgPSBDYW1sLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmdfaHVtIHQpXG4gIGVuZClcblxubW9kdWxlIEludGVybmFsX3JlcHIgPSBNZXNzYWdlXG5cbiIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0Vycm9yXSBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIHZhcmlvdXMgcGxhY2VzLiAgUGxlYXNlIGF2b2lkIGFkZGluZyBuZXdcbiAgIGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9cblxubGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIkVycm9yLnRcIiB9XG5sZXQgcmFpc2UgdCA9IHJhaXNlICh0b19leG4gdClcbmxldCByYWlzZV9zIHNleHAgPSByYWlzZSAoY3JlYXRlX3Mgc2V4cClcbmxldCB0b19pbmZvIHQgPSB0XG5sZXQgb2ZfaW5mbyB0ID0gdFxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkVycm9yXCJcbiAgICBsZXQgcHAgPSBwcFxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSW52YXJpYW50X2ludGZcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbmxldCBpbnZhcmlhbnQgaGVyZSB0IHNleHBfb2ZfdCBmIDogdW5pdCA9XG4gIHRyeSBmICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgWyBcIlwiLCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGhlcmVcbiAgICAgICAgIDsgXCJleG5cIiwgc2V4cF9vZl9leG4gZXhuXG4gICAgICAgICA7IFwiXCIsIHNleHBfb2ZfdCB0XG4gICAgICAgICBdKVxuOztcblxubGV0IGNoZWNrX2ZpZWxkIHQgZiBmaWVsZCA9XG4gIHRyeSBmIChGaWVsZC5nZXQgZmllbGQgdCkgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwicHJvYmxlbSB3aXRoIGZpZWxkXCJcbiAgICAgICAgIFsgXCJmaWVsZFwiLCBzZXhwX29mX3N0cmluZyAoRmllbGQubmFtZSBmaWVsZCk7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4biBdKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbiAgUmVzdWx0IDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlc3VsdFxuICBlbmRcbiAgd2l0aCBtb2R1bGUgRXJyb3IgOj0gUmVzdWx0LkVycm9yKVxuXG50eXBlICdhIHQgPSAoJ2EsIEVycm9yLnQpIFJlc3VsdC50XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gIGZ1biBfY21wX19hIGFfXzAwMV8gYl9fMDAyXyAtPiBSZXN1bHQuY29tcGFyZSBfY21wX19hIEVycm9yLmNvbXBhcmUgYV9fMDAxXyBiX18wMDJfXG47O1xuXG5sZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIF9jbXBfX2EgYV9fMDA3XyBiX18wMDhfIC0+IFJlc3VsdC5lcXVhbCBfY21wX19hIEVycm9yLmVxdWFsIGFfXzAwN18gYl9fMDA4X1xuOztcblxubGV0IGhhc2hfZm9sZF90IDpcbiAgJ2EuXG4gIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgLT4gJ2EgdFxuICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIGhzdiBhcmcgLT4gUmVzdWx0Lmhhc2hfZm9sZF90IF9oYXNoX2ZvbGRfYSBFcnJvci5oYXNoX2ZvbGRfdCBoc3YgYXJnXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMTNfIHhfXzAxNV8gLT4gUmVzdWx0LnRfb2Zfc2V4cCBfb2ZfYV9fMDEzXyBFcnJvci50X29mX3NleHAgeF9fMDE1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDE2XyB4X18wMTdfIC0+IFJlc3VsdC5zZXhwX29mX3QgX29mX2FfXzAxNl8gRXJyb3Iuc2V4cF9vZl90IHhfXzAxN19cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IFJlc3VsdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyIEVycm9yLnRfc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBhIC0+IGludmFyaWFudF9hIGFcbiAgfCBFcnJvciBlcnJvciAtPiBFcnJvci5pbnZhcmlhbnQgZXJyb3Jcbjs7XG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGxldCBhcHBseSBmIHggPVxuICAgICAgUmVzdWx0LmNvbWJpbmUgZiB4IH5vazooZnVuIGYgeCAtPiBmIHgpIH5lcnI6KGZ1biBlMSBlMiAtPiBFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5sZXQgb2sgPSBSZXN1bHQub2tcbmxldCBpc19vayA9IFJlc3VsdC5pc19va1xubGV0IGlzX2Vycm9yID0gUmVzdWx0LmlzX2Vycm9yXG5cbmxldCB0cnlfd2l0aCA/KGJhY2t0cmFjZSA9IGZhbHNlKSBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuID9iYWNrdHJhY2U6KGlmIGJhY2t0cmFjZSB0aGVuIFNvbWUgYEdldCBlbHNlIE5vbmUpKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2JhY2t0cmFjZSBmID0gam9pbiAodHJ5X3dpdGggP2JhY2t0cmFjZSBmKVxuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IucmFpc2UgZXJyXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRXJyb3IgKEVycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcblxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSA9IGZ1bmN0aW9uXG4gIHwgT2sgXyBhcyB6IC0+IHpcbiAgfCBFcnJvciBleG4gLT4gb2ZfZXhuID9iYWNrdHJhY2UgZXhuXG47O1xuXG5sZXQgZXJyb3IgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRXJyb3IgKEVycm9yLmNyZWF0ZSA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgZXJyb3JfcyBzZXhwID0gRXJyb3IgKEVycm9yLmNyZWF0ZV9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1lc3NhZ2UgPSBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooZnVuIGUgLT4gRXJyb3IudGFnX2FyZyBlIG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBzID0gZXJyb3IgXCJ1bmltcGxlbWVudGVkXCIgcyBzZXhwX29mX3N0cmluZ1xubGV0IGNvbWJpbmVfZXJyb3JzIGwgPSBSZXN1bHQubWFwX2Vycm9yIChSZXN1bHQuY29tYmluZV9lcnJvcnMgbCkgfmY6RXJyb3Iub2ZfbGlzdFxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IFJlc3VsdC5tYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuXG5sZXQgZmlsdGVyX29rX2F0X2xlYXN0X29uZSBsID1cbiAgbGV0IG9rLCBlcnJzID0gTGlzdC5wYXJ0aXRpb25fbWFwIGwgfmY6UmVzdWx0LnRvX2VpdGhlciBpblxuICBtYXRjaCBvayB3aXRoXG4gIHwgW10gLT4gRXJyb3IgKEVycm9yLm9mX2xpc3QgZXJycylcbiAgfCBfIC0+IE9rIG9rXG47O1xuXG5sZXQgZmluZF9vayBsID1cbiAgbWF0Y2ggTGlzdC5maW5kX21hcCBsIH5mOlJlc3VsdC5vayB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgIHwgT2sgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBXaXRoX3JldHVybi53aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgICAgICB8IE9rIF8gYXMgeCAtPiByZXR1cm4geFxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpKVxuOztcblxubGV0IG1hcCA9IFJlc3VsdC5tYXBcbmxldCBpdGVyID0gUmVzdWx0Lml0ZXJcbmxldCBpdGVyX2Vycm9yID0gUmVzdWx0Lml0ZXJfZXJyb3JcbiIsIigqIFRoaXMgaXMgYnJva2VuIG9mZiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gU2lnbiBhbmQgQ29tcGFyYWJsZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTmVnXG4gIHwgWmVyb1xuICB8IFBvc1xuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlXVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ24wLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSAtPiBQb3NcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IHNleHBfXzAwMl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBOZWcgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmVnXCJcbiAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgfCBQb3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiUG9zXCJcbiAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJOZWdcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlBvc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgTmVnIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IFplcm8gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgIHwgUG9zIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zIF0gOiB0IGxpc3QpXG5cbltAQEBlbmRdXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5sZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG5sZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IE5lZyAtPiAtMVxuICB8IFplcm8gLT4gMFxuICB8IFBvcyAtPiAxXG47O1xuXG5sZXQgXyA9IGhhc2hcblxuKCogSWdub3JlIHRoZSBoYXNoIGZ1bmN0aW9uIHByb2R1Y2VkIGJ5IFtAQGRlcml2aW5nX2lubGluZSBoYXNoXSAqKVxubGV0IGhhc2ggPSB0b19pbnRcbmxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduXCJcbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTmVnIGVsc2UgaWYgbiA9IDAgdGhlbiBaZXJvIGVsc2UgUG9zXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29tcGFyYWJsZV9pbnRmXG5cbm1vZHVsZSBXaXRoX3plcm8gKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB6ZXJvIDogdFxuICBlbmQpID1cbnN0cnVjdFxuICBvcGVuIFRcblxuICBsZXQgaXNfcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvID4gMFxuICBsZXQgaXNfbm9uX25lZ2F0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+PSAwXG4gIGxldCBpc19uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPCAwXG4gIGxldCBpc19ub25fcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDw9IDBcbiAgbGV0IHNpZ24gdCA9IFNpZ24wLm9mX2ludCAoY29tcGFyZSB0IHplcm8pXG5lbmRcblxubW9kdWxlIFBvbHkgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBQb2x5XG4gIGVuZFxuXG4gIGluY2x1ZGUgUG9seVxuXG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuXG4gIG1vZHVsZSBDID0gc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSlcbiAgZW5kXG5cbiAgaW5jbHVkZSBDXG5lbmRcblxubGV0IGd0IGNtcCBhIGIgPSBjbXAgYSBiID4gMFxubGV0IGx0IGNtcCBhIGIgPSBjbXAgYSBiIDwgMFxubGV0IGdlcSBjbXAgYSBiID0gY21wIGEgYiA+PSAwXG5sZXQgbGVxIGNtcCBhIGIgPSBjbXAgYSBiIDw9IDBcbmxldCBlcXVhbCBjbXAgYSBiID0gY21wIGEgYiA9IDBcbmxldCBub3RfZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPD4gMFxubGV0IG1pbiBjbXAgdCB0JyA9IGlmIGxlcSBjbXAgdCB0JyB0aGVuIHQgZWxzZSB0J1xubGV0IG1heCBjbXAgdCB0JyA9IGlmIGdlcSBjbXAgdCB0JyB0aGVuIHQgZWxzZSB0J1xuXG5tb2R1bGUgSW5maXggKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA6IEluZml4IHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBsZXQgKCA+ICkgYSBiID0gZ3QgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8ICkgYSBiID0gbHQgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA+PSApIGEgYiA9IGdlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw9ICkgYSBiID0gbGVxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPSApIGEgYiA9IGVxdWFsIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD4gKSBhIGIgPSBub3RfZXF1YWwgVC5jb21wYXJlIGEgYlxuZW5kXG5cbm1vZHVsZSBQb2x5bW9ycGhpY19jb21wYXJlIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBQb2x5bW9ycGhpY19jb21wYXJlIHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4IChUKVxuXG4gIGxldCBjb21wYXJlID0gVC5jb21wYXJlXG4gIGxldCBlcXVhbCA9ICggPSApXG4gIGxldCBtaW4gdCB0JyA9IG1pbiBjb21wYXJlIHQgdCdcbiAgbGV0IG1heCB0IHQnID0gbWF4IGNvbXBhcmUgdCB0J1xuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBULmNvbXBhcmF0b3Jfd2l0bmVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJhdG9yLmNvbXBhcmVcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIG1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBQb2x5bW9ycGhpY19jb21wYXJlIChUKVxuICBpbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHQgdCcgPSBjb21wYXJlIHQnIHRcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbiAgTWFrZV91c2luZ19jb21wYXJhdG9yIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbiAgZW5kKVxuXG5tb2R1bGUgSW5oZXJpdCAoQyA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIChUIDogc2lnXG4gICAgICAgICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICAgICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgICAgICBbQEBAZW5kXVxuXG4gICAgICAgICAgdmFsIGNvbXBvbmVudCA6IHQgLT4gQy50XG4gICAgICAgIGVuZCkgPVxuICBNYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgdCB0JyA9IEMuY29tcGFyZSAoVC5jb21wb25lbnQgdCkgKFQuY29tcG9uZW50IHQnKVxuICBlbmQpXG5cbigqIGNvbXBhcmUgW3hdIGFuZCBbeV0gbGV4aWNvZ3JhcGhpY2FsbHkgdXNpbmcgZnVuY3Rpb25zIGluIHRoZSBsaXN0IFtjbXBzXSAqKVxubGV0IGxleGljb2dyYXBoaWMgY21wcyB4IHkgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgY21wIDo6IGNtcHMgLT5cbiAgICAgIGxldCByZXMgPSBjbXAgeCB5IGluXG4gICAgICBpZiByZXMgPSAwIHRoZW4gbG9vcCBjbXBzIGVsc2UgcmVzXG4gICAgfCBbXSAtPiAwXG4gIGluXG4gIGxvb3AgY21wc1xuOztcblxubGV0IGxpZnQgY21wIH5mIHggeSA9IGNtcCAoZiB4KSAoZiB5KVxubGV0IHJldmVyc2UgY21wIHggeSA9IGNtcCB5IHhcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlLktleSAqKVxubW9kdWxlIHR5cGUgS2V5ID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIFZhbHVlcyByZXR1cm5lZCBieSBbaGFzaF0gbXVzdCBiZSBub24tbmVnYXRpdmUuICBBbiBleGNlcHRpb24gd2lsbCBiZSByYWlzZWQgaW4gdGhlXG4gICAgICBjYXNlIHRoYXQgW2hhc2hdIHJldHVybnMgYSBuZWdhdGl2ZSB2YWx1ZS4gKilcbiAgdmFsIGhhc2ggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gICgqKiBUaGlzIGZ1bmN0aW9uIGlzIHNvdW5kIGJ1dCBub3QgY29tcGxldGUsIG1lYW5pbmcgdGhhdCBpZiBpdCByZXR1cm5zIFt0cnVlXSB0aGVuIGl0J3NcbiAgICAgIHNhZmUgdG8gdXNlIHRoZSB0d28gaW50ZXJjaGFuZ2VhYmx5LiAgSWYgaXQncyBbZmFsc2VdLCB5b3UgaGF2ZSBubyBndWFyYW50ZWVzLiAgRm9yXG4gICAgICBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICA+IHV0b3BcbiAgICAgICAgb3BlbiBDb3JlOztcbiAgICAgICAgbGV0IGVxdWFsIChhIDogJ2EgSGFzaHRibF9pbnRmLkhhc2hhYmxlLnQpIGIgPVxuICAgICAgICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgICAgICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgICAgICAgOztcbiAgICAgICAgbGV0IGEgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBsZXQgYiA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGVxdWFsIGEgYjs7ICAoKiBmYWxzZT8hICopXG4gICAgICBdfVxuICAqKVxuICBsZXQgZXF1YWwgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGhhc2hfcGFyYW0gPSBDYW1sLkhhc2h0YmwuaGFzaF9wYXJhbVxuICBsZXQgaGFzaCA9IENhbWwuSGFzaHRibC5oYXNoXG4gIGxldCBwb2x5ID0geyBoYXNoOyBjb21wYXJlID0gUG9seS5jb21wYXJlOyBzZXhwX29mX3QgPSAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB9XG5cbiAgbGV0IG9mX2tleSAodHlwZSBhKSAobW9kdWxlIEtleSA6IEtleSB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICB7IGhhc2ggPSBLZXkuaGFzaDsgY29tcGFyZSA9IEtleS5jb21wYXJlOyBzZXhwX29mX3QgPSBLZXkuc2V4cF9vZl90IH1cbiAgOztcblxuICBsZXQgdG9fa2V5ICh0eXBlIGEpIHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH0gPVxuICAgIChtb2R1bGUgc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCBoYXNoID0gaGFzaFxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgZW5kIDogS2V5XG4gICAgICB3aXRoIHR5cGUgdCA9IGEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBIYXNoYWJsZVxuXG5tb2R1bGUgdHlwZSBIYXNoYWJsZSA9IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBIYXNoYWJsZS50ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICB2YWwgcG9seSA6ICdhIHRcbiAgdmFsIG9mX2tleSA6IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpIC0+ICdhIHRcbiAgdmFsIHRvX2tleSA6ICdhIHQgLT4gKG1vZHVsZSBLZXkgd2l0aCB0eXBlIHQgPSAnYSlcbiAgdmFsIGhhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+ICdhIC0+IGludFxuICB2YWwgaGFzaCA6ICdhIC0+IGludFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlX2ludGZcblxubW9kdWxlIE1ha2UgKFQgOiBBcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IEFyZ193aXRoX2NvbXBhcmF0b3IpID0gc3RydWN0XG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChUKVxuICBpbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHVuaXQgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBhbGwgPSAoWyAoKSBdIDogdCBsaXN0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfdW5pdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfdW5pdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAodW5pdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl91bml0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHVuaXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgY29tcGFyZSBfIF8gPSAwXG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcIigpXCIgLT4gKClcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJCYXNlLlVuaXQub2Zfc3RyaW5nOiAoKSBleHBlY3RlZFwiXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVW5pdFwiXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG5sZXQgaW52YXJpYW50ICgpID0gKClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMFxuXG5sZXQgZ2V0X3Bvc19sZW4gP3BvcyA/bGVuICgpIH50b3RhbF9sZW5ndGggPVxuICB0cnkgUmVzdWx0Lk9rIChnZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGgpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IHMgLT4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIHNcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCBhIHNlYXJjaCBmb3IgdGhlIGZpcnN0IChyZXNwLiBsYXN0KSBlbGVtZW50XG4gICBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLCBhc3N1bWluZyB0aGF0IHRoZSBwcmVkaWNhdGUgaXMgaW5jcmVhc2luZyBvblxuICAgdGhlIGNvbnRhaW5lciwgbWVhbmluZyB0aGF0LCBpZiB0aGUgY29udGFpbmVyIGlzIFt1MS4uLnVuXSwgdGhlcmUgZXhpc3RzIGFcbiAgIGsgc3VjaCB0aGF0IHAodTEpPS4uLi49cCh1aykgPSBmYWxzZSBhbmQgcCh1aysxKT0uLi4uPXAodW4pPSB0cnVlLlxuICAgSWYgdGhpcyBrID0gMSAocmVzcCBuKSwgZmluZF9sYXN0X25vdF9zYXRpc2Z5aW5nIChyZXNwIGZpbmRfZmlyc3Rfc2F0aXNmeWluZylcbiAgIHdpbGwgcmV0dXJuIE5vbmUuICopXG5cbmxldCByZWMgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgaWYgbG8gPiBoaVxuICB0aGVuIE5vbmVcbiAgZWxzZSBpZiBwcmVkIChnZXQgdCBsbylcbiAgdGhlbiBTb21lIGxvXG4gIGVsc2UgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KGxvICsgMSkgfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhIGNvbnRhaW5lciBbdF0sIGEgcHJlZGljYXRlIFtwcmVkXSBhbmQgdHdvIGluZGljZXMgW2xvIDwgaGldLCBzdWNoIHRoYXRcbiAgIFtwcmVkXSBpcyBpbmNyZWFzaW5nIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uXG5cbiAgIHJldHVybiBhIHJhbmdlIChsbywgaGkpIHdoZXJlOlxuICAgLSBsbyBhbmQgaGkgYXJlIGNsb3NlIGVub3VnaCB0b2dldGhlciBmb3IgYSBsaW5lYXIgc2VhcmNoXG4gICAtIElmIFtwcmVkXSBpcyBub3QgY29uc3RhbnRseSBbZmFsc2VdIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0sIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgIG9uIHdoaWNoIFtwcmVkXSBpcyBbdHJ1ZV0gaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldLiAqKVxuKCogSW52YXJpYW50OiB0aGUgZmlyc3QgZWxlbWVudCBzYXRpc2Z5aW5nIFtwcmVkXSwgaWYgaXQgZXhpc3RzIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXSAqKVxubGV0IHJlYyBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gICgqIFdhcm5pbmc6IHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdGVybWluYXRlIGlmIHRoZSBjb25zdGFudCAoY3VycmVudGx5IDgpIGlzXG4gICAgIHNldCA8PSAxICopXG4gIGlmIGhpIC0gbG8gPD0gOFxuICB0aGVuIGxvLCBoaVxuICBlbHNlIChcbiAgICBsZXQgbWlkID0gbG8gKyAoKGhpIC0gbG8pIC8gMikgaW5cbiAgICBpZiBwcmVkIChnZXQgdCBtaWQpXG4gICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50IGlzIGJldHdlZW4gW2xvXSBhbmQgW21pZF0gKilcbiAgICB0aGVuXG4gICAgICBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaTptaWQgfnByZWRcbiAgICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCwgaWYgaXQgZXhpc3RzLFxuICAgICAgICAgaXMgYmV0d2VlbiBbbWlkKzFdIGFuZCBbaGldICopXG4gICAgZWxzZSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihtaWQgKyAxKSB+aGkgfnByZWQpXG47O1xuXG5sZXQgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbG8gPSBwb3MgaW5cbiAgbGV0IGhpID0gcG9zICsgbGVuIC0gMSBpblxuICBsZXQgbG8sIGhpID0gZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgaW5cbiAgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhbiBhcnJheSB3aXRoIHNoYXBlIFt0cnVlLC4uLnRydWUsZmFsc2UsLi4uZmFsc2VdIChpLmUuLCB0aGUgX3JldmVyc2VfIG9mIHdoYXRcbiAgIGlzIGRlc2NyaWJlZCBhYm92ZSkgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHRydWUgb3IgTm9uZSBpZiB0aGVyZSBhcmUgbm9cbiAgIHRydWUqKVxubGV0IGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5wcmVkIH5nZXQgfmxlbmd0aCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICAoKiBUaGUgbGFzdCBzYXRpc2Z5aW5nIGlzIHRoZSBvbmUganVzdCBiZWZvcmUgdGhlIGZpcnN0IG5vdCBzYXRpc2Z5aW5nICopXG4gICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIH5wb3MgfmxlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooRm4ubm9uIHByZWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSAocG9zICsgbGVuIC0gMSlcbiAgICAoKiBUaGlzIG1lYW5zIHRoYXQgYWxsIGVsZW1lbnRzIHNhdGlzZnkgcHJlZC5cbiAgICAgICBUaGVyZSBpcyBhdCBsZWFzdCBhbiBlbGVtZW50IGFzIChsZW4gPiAwKSAqKVxuICAgIHwgU29tZSBpIHdoZW4gaSA9IHBvcyAtPiBOb25lICgqIG5vIGVsZW1lbnQgc2F0aXNmaWVzIHByZWQgKilcbiAgICB8IFNvbWUgaSAtPiBTb21lIChpIC0gMSkpXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfmNvbXBhcmUgaG93IHYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKVxuICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5zZWdtZW50X29mIGhvdyA9XG4gIGxldCBpc19sZWZ0IHggPVxuICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgaW5cbiAgbGV0IGlzX3JpZ2h0IHggPSBub3QgKGlzX2xlZnQgeCkgaW5cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19sZWZ0XG4gIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfcmlnaHRcbjs7XG4iLCIoKiogTW9kdWxlIHR5cGVzIGZvciBhIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbiBmb3IgYSBzZXF1ZW5jZSwgYW5kIGZ1bmN0b3JzIGZvciBidWlsZGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbnMuICopXG5cbm9wZW4hIEltcG9ydFxuXG4oKiogQW4gW0luZGV4YWJsZV0gdHlwZSBpcyBhIGZpbml0ZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBpbmRleGVkIGJ5IGNvbnNlY3V0aXZlIGludGVnZXJzXG4gICAgWzBdIC4uLiBbbGVuZ3RoIHQgLSAxXS4gIFtnZXRdIGFuZCBbbGVuZ3RoXSBtdXN0IGJlIE8oMSkgZm9yIHRoZSByZXN1bHRpbmdcbiAgICBbYmluYXJ5X3NlYXJjaF0gdG8gYmUgbGcobikuICopXG5tb2R1bGUgdHlwZSBJbmRleGFibGUgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgdmFsIGdldCA6IHQgLT4gaW50IC0+IGVsdFxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmRleGFibGUxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfa2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPVxuICAgIChbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICA7IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBMYXN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgXVxuICAgICA6IHQgbGlzdClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYExhc3Rfb25fbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPSAoWyBgTGFzdF9vbl9sZWZ0OyBgRmlyc3Rfb25fcmlnaHQgXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuZW5kXG5cbnR5cGUgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gY29tcGFyZTooJ2VsdCAtPiAna2V5IC0+IGludClcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gIC0+ICdrZXlcbiAgLT4gaW50IG9wdGlvblxuXG50eXBlICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPVxuICA/cG9zOmludFxuICAtPiA/bGVuOmludFxuICAtPiAndFxuICAtPiBzZWdtZW50X29mOignZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAtPiBpbnQgb3B0aW9uXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgKCoqIFNlZSBbQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoIDogKHQsIGVsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGluIGJpbmFyeV9zZWFyY2gubWwgKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKHQsIGVsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICgnYSB0LCAnYSwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgOiAoJ2EgdCwgJ2EpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgQmluYXJ5X3NlYXJjaGFibGUgPSBzaWdcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBJbmRleGFibGUgPSBJbmRleGFibGVcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlMSA9IEluZGV4YWJsZTFcblxuICBtb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X2tleSA9IFdoaWNoX3RhcmdldF9ieV9rZXlcbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9zZWdtZW50ID0gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnRcblxuICB0eXBlIG5vbnJlYyAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2ggPSAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA9ICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcblxuICBtb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCB3aXRoIHR5cGUgZWx0IDo9IFQuZWx0XG4gIG1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZV9pbnRmXG5cbm1vZHVsZSB0eXBlIEFyZyA9IHNpZ1xuICB0eXBlICdhIGVsdFxuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgZWx0XG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogQXJnKSA9IHN0cnVjdFxuICBsZXQgZ2V0ID0gVC5nZXRcbiAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIEJpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfmNvbXBhcmUgaG93IHZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+c2VnbWVudF9vZiBob3dcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICdhIGVsdCA9IFQuZWx0XG4gICAgdHlwZSAnYSB0ID0gVC50XG4gIGVuZClcblxubW9kdWxlIE1ha2UxIChUIDogSW5kZXhhYmxlMSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIHR5cGUgJ2EgdCA9ICdhIFQudFxuXG4gICAgbGV0IGdldCA9IFQuZ2V0XG4gICAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCbGl0X2ludGZcblxubW9kdWxlIHR5cGUgU2VxdWVuY2VfZ2VuID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuXG4gICAgKFNyYyA6IFNlcXVlbmNlX2dlbikgKERzdCA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIFNyYy50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgU3JjLnQsICdhIHQpIGJsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IHVuc2FmZV9ibGl0ID0gRHN0LnVuc2FmZV9ibGl0XG5cbiAgbGV0IGJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6c3JjX3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6ZHN0X3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooRHN0Lmxlbmd0aCBkc3QpO1xuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlblxuICA7O1xuXG4gIGxldCBibGl0b1xuICAgICAgICB+c3JjXG4gICAgICAgID8oc3JjX3BvcyA9IDApXG4gICAgICAgID8oc3JjX2xlbiA9IFNyYy5sZW5ndGggc3JjIC0gc3JjX3BvcylcbiAgICAgICAgfmRzdFxuICAgICAgICA/KGRzdF9wb3MgPSAwKVxuICAgICAgICAoKVxuICAgID1cbiAgICBibGl0IH5zcmMgfnNyY19wb3MgfmxlbjpzcmNfbGVuIH5kc3QgfmRzdF9wb3NcbiAgOztcblxuICAoKiBbc3ViXSBhbmQgW3N1Ym9dIGVuc3VyZSB0aGF0IGV2ZXJ5IHBvc2l0aW9uIG9mIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGlzIHBvcHVsYXRlZCBieVxuICAgICBhbiBlbGVtZW50IG9mIHRoZSBzb3VyY2UgYXJyYXkuICBUaHVzIGV2ZXJ5IGVsZW1lbnQgb2YgW2RzdF0gYmVsb3cgaXMgd2VsbFxuICAgICBkZWZpbmVkLiAqKVxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBsZXQgZHN0ID0gRHN0LmNyZWF0ZV9saWtlIH5sZW4gc3JjIGluXG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3M6cG9zIH5kc3QgfmRzdF9wb3M6MCB+bGVuO1xuICAgIGRzdFxuICA7O1xuXG4gIGxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICAgIHN1YlxuICAgICAgc3JjXG4gICAgICB+cG9zXG4gICAgICB+bGVuOlxuICAgICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICAgIHwgTm9uZSAtPiBTcmMubGVuZ3RoIHNyYyAtIHBvcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFNlcXVlbmNlIDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIGJsaXRcbiAgZW5kKSA9XG4gIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZTFfZ2VuZXJpYyAoU2VxdWVuY2UgOiBTZXF1ZW5jZTEpID0gTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlIChTZXF1ZW5jZSA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAodCwgdCkgYmxpdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgU2VxdWVuY2UgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSBTZXF1ZW5jZS50XG5cbiAgICBvcGVuIFNlcXVlbmNlXG5cbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcbmVuZFxuXG5tb2R1bGUgTWFrZV9kaXN0aW5jdFxuICAgIChTcmMgOiBTZXF1ZW5jZSkgKERzdCA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiB0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgdW5zYWZlX2JsaXQgOiAoU3JjLnQsIHQpIGJsaXRcbiAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbiAgTWFrZV9nZW5cbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBTcmMudFxuXG4gICAgICBvcGVuIFNyY1xuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IERzdC50XG5cbiAgICAgIG9wZW4gRHN0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgICBlbmQpXG5cbm1vZHVsZSBNYWtlX3RvX3N0cmluZyAoVCA6IHNpZ1xuICAgIHR5cGUgdFxuICBlbmQpXG4gICAgKFRvX2J5dGVzIDogU19kaXN0aW5jdCB3aXRoIHR5cGUgc3JjIDo9IFQudCB3aXRoIHR5cGUgZHN0IDo9IGJ5dGVzKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUb19ieXRlc1xuXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KHN1YiBzcmMgfnBvcyB+bGVuKVxuICA7O1xuXG4gIGxldCBzdWJvID9wb3MgP2xlbiBzcmMgPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWJvID9wb3MgP2xlbiBzcmMpXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbnN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb24gW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9vcHRpb25cblxuICBsZXQgaGFzaF9mb2xkX3QgOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgaGFzaF9mb2xkX29wdGlvblxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICAgIG9wdGlvbl9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgc2V4cF9vZl9vcHRpb25cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IG9wdGlvbl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmQgOlxuc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvbiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPVxuICB8IE5vbmVcbiAgfCBTb21lIG9mICdhXG5cbmxldCBpc19ub25lID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgdmFsdWVfbWFwIG8gfmRlZmF1bHQgfmYgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBTb21lIHggLT4gZiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0XG47O1xuXG5sZXQgaXRlciBvIH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgYSAtPiBmIGFcbjs7XG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5cbmxldCBjYWxsIHggfmYgPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBmIC0+IGYgeFxuOztcblxubGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGRlZmF1bHRcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IHZhbHVlX2V4biA/aGVyZSA/ZXJyb3IgP21lc3NhZ2UgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPlxuICAgIGxldCBlcnJvciA9XG4gICAgICBtYXRjaCBoZXJlLCBlcnJvciwgbWVzc2FnZSB3aXRoXG4gICAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT4gRXJyb3Iub2Zfc3RyaW5nIFwiT3B0aW9uLnZhbHVlX2V4biBOb25lXCJcbiAgICAgIHwgTm9uZSwgTm9uZSwgU29tZSBtIC0+IEVycm9yLm9mX3N0cmluZyBtXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgTm9uZSAtPiBlXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgU29tZSBtIC0+IEVycm9yLnRhZyBlIH50YWc6bVxuICAgICAgfCBTb21lIHAsIE5vbmUsIE5vbmUgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIFwiT3B0aW9uLnZhbHVlX2V4blwiIHAgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdFxuICAgICAgfCBTb21lIHAsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5jcmVhdGUgbSBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBTb21lIGUsIF8gLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgKHZhbHVlIG1lc3NhZ2UgfmRlZmF1bHQ6XCJcIilcbiAgICAgICAgICAoZSwgcClcbiAgICAgICAgICAoc2V4cF9vZl9wYWlyIEVycm9yLnNleHBfb2ZfdCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90KVxuICAgIGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCB2YWx1ZV9vcl90aHVuayBvIH5kZWZhdWx0ID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IHhcbiAgfCBOb25lIC0+IGRlZmF1bHQgKClcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbfHxdXG4gIHwgU29tZSB4IC0+IFt8IHggfF1cbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSB4IC0+IFsgeCBdXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlOl8gPSB0XG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlOl8gPSB0XG5cbmxldCBzdW0gKHR5cGUgYSkgKG1vZHVsZSBNIDogQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIHZhbHVlX21hcCB0IH5kZWZhdWx0Ok0uemVybyB+ZlxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCAtPiBmIHhcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSBhJyAtPiBlcXVhbCBhIGEnXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIF8gLT4gMVxuOztcblxubGV0IGlzX2VtcHR5ID0gaXNfbm9uZVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBpbml0XG4gIHwgU29tZSB4IC0+IGYgaW5pdCB4XG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgYSAtPiBpZiBmIGEgdGhlbiAxIGVsc2UgMFxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgeCAtPiBpZiBmIHggdGhlbiB0IGVsc2UgTm9uZVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgZXF1YWwgZiB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCwgU29tZSB4JyAtPiBmIHggeCdcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgc29tZSB4ID0gU29tZSB4XG5cbmxldCBmaXJzdF9zb21lIHggeSA9XG4gIG1hdGNoIHggd2l0aFxuICB8IFNvbWUgXyAtPiB4XG4gIHwgTm9uZSAtPiB5XG47O1xuXG5sZXQgc29tZV9pZiBjb25kIHggPSBpZiBjb25kIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuXG5sZXQgbWVyZ2UgYSBiIH5mID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgTm9uZSwgeCB8IHgsIE5vbmUgLT4geFxuICB8IFNvbWUgYSwgU29tZSBiIC0+IFNvbWUgKGYgYSBiKVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU29tZSB2IGFzIG8gd2hlbiBmIHYgLT4gb1xuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHRyeV93aXRoIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gU29tZSAoZiBhKVxuOztcblxubGV0IGFwcGx5IGYgeCA9XG4gIG1hdGNoIGYgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgZiAtPiBtYXAgfmYgeFxuOztcblxubW9kdWxlIE1vbmFkX2FyZyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgcmV0dXJuIHggPSBTb21lIHhcbiAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5cbiAgbGV0IGJpbmQgbyB+ZiA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBmIHhcbiAgOztcbmVuZFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKE1vbmFkX2FyZylcbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoTW9uYWRfYXJnKVxuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlXG5cbm1vZHVsZSBPZl9zZXhwYWJsZVxuICAgIChTZXhwYWJsZSA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiB0IC0+IFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiBTZXhwYWJsZS50IC0+IHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMgd2l0aCB0eXBlIHQgOj0gTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cGFibGUuc2V4cF9vZl90IChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMVxuICAgIChTZXhwYWJsZSA6IFMxKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICdhIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAnYSB0IC0+ICdhIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogJ2EgU2V4cGFibGUudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTJcbiAgICAoU2V4cGFibGUgOiBTMikgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IpIFNleHBhYmxlLnQgLT4gKCdhLCAnYikgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUzXG4gICAgKFNleHBhYmxlIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgU2V4cGFibGUudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc3RyaW5nYWJsZSAoTSA6IFN0cmluZ2FibGUuUykgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5BdG9tIHMgLT5cbiAgICAgICh0cnkgTS5vZl9zdHJpbmcgcyB3aXRoXG4gICAgICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHApXG4gICAgfCBTZXhwLkxpc3QgXyAtPlxuICAgICAgb2Zfc2V4cF9lcnJvclxuICAgICAgICBcIlNleHBhYmxlLk9mX3N0cmluZ2FibGUudF9vZl9zZXhwIGV4cGVjdGVkIGFuIGF0b20sIGJ1dCBnb3QgYSBsaXN0XCJcbiAgICAgICAgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAoTS50b19zdHJpbmcgdClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEVpdGhlcl9pbnRmXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEVpdGhlcjBcblxubGV0IHN3YXAgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gU2Vjb25kIHhcbiAgfCBTZWNvbmQgeCAtPiBGaXJzdCB4XG47O1xuXG5sZXQgaXNfZmlyc3QgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gdHJ1ZVxuICB8IFNlY29uZCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc2Vjb25kID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IGZhbHNlXG4gIHwgU2Vjb25kIF8gLT4gdHJ1ZVxuOztcblxubGV0IHZhbHVlIChGaXJzdCB4IHwgU2Vjb25kIHgpID0geFxuXG5sZXQgdmFsdWVfbWFwIHQgfmZpcnN0IH5zZWNvbmQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBGaXJzdCB4IC0+IGZpcnN0IHhcbiAgfCBTZWNvbmQgeCAtPiBzZWNvbmQgeFxuOztcblxubGV0IGl0ZXIgPSB2YWx1ZV9tYXBcblxubGV0IG1hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBGaXJzdCAoZmlyc3QgeClcbiAgfCBTZWNvbmQgeCAtPiBTZWNvbmQgKHNlY29uZCB4KVxuOztcblxubGV0IGZpcnN0IHggPSBGaXJzdCB4XG5sZXQgc2Vjb25kIHggPSBTZWNvbmQgeFxuXG5sZXQgZXF1YWwgZXExIGVxMiB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBlcTEgeCB5XG4gIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IGVxMiB4IHlcbiAgfCBGaXJzdCBfLCBTZWNvbmQgXyB8IFNlY29uZCBfLCBGaXJzdCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaW52YXJpYW50IGYgcyA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBmIHhcbiAgfCBTZWNvbmQgeSAtPiBzIHlcbjs7XG5cbm1vZHVsZSBNYWtlX2ZvY3VzZWQgKE0gOiBzaWdcbiAgICB0eXBlICgrJ2EsICsnYikgdFxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICAgIHZhbCBvdGhlciA6ICdiIC0+IChfLCAnYikgdFxuICAgIHZhbCBlaXRoZXIgOiAoJ2EsICdiKSB0IC0+IHJldHVybjooJ2EgLT4gJ2MpIC0+IG90aGVyOignYiAtPiAnYykgLT4gJ2NcblxuICAgIHZhbCBjb21iaW5lXG4gICAgICA6ICAoJ2EsICdkKSB0XG4gICAgICAtPiAoJ2IsICdkKSB0XG4gICAgICAtPiBmOignYSAtPiAnYiAtPiAnYylcbiAgICAgIC0+IG90aGVyOignZCAtPiAnZCAtPiAnZClcbiAgICAgIC0+ICgnYywgJ2QpIHRcblxuICAgIHZhbCBiaW5kIDogKCdhLCAnYikgdCAtPiBmOignYSAtPiAoJ2MsICdiKSB0KSAtPiAoJ2MsICdiKSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuICBvcGVuIFdpdGhfcmV0dXJuXG5cbiAgbGV0IG1hcCB0IH5mID0gYmluZCB0IH5mOihmdW4geCAtPiByZXR1cm4gKGYgeCkpXG5cbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGVuZClcblxuICBtb2R1bGUgQXBwID0gQXBwbGljYXRpdmUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGFwcGx5IHQxIHQyID0gYmluZCB0MSB+ZjooZnVuIGYgLT4gYmluZCB0MiB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKSlcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGVuZClcblxuICBpbmNsdWRlIEFwcFxuXG4gIGxldCBjb21iaW5lX2FsbCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyXG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZXR1cm46KGZ1biBfIC0+IG90aGVyX2xvb3AgZiBhY2MgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8pIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4geCAtPiByZXR1cm5fbG9vcCBmICh4IDo6IGFjYykgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgbyB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIFtdIHRzXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfYWxsX3VuaXQgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4gKCkgLT4gb3RoZXJfbG9vcCBmIGFjYyB0cylcbiAgICAgICAgICB+b3RoZXI6KGZ1biBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2MgbykgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXIgdCB+cmV0dXJuOihmdW4gKCkgLT4gcmV0dXJuX2xvb3AgZiB0cykgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgbyB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIHRzXG4gIDs7XG5cbiAgbGV0IHRvX29wdGlvbiB0ID0gZWl0aGVyIHQgfnJldHVybjpPcHRpb24uc29tZSB+b3RoZXI6KGZ1biBfIC0+IE5vbmUpXG4gIGxldCB2YWx1ZSB0IH5kZWZhdWx0ID0gZWl0aGVyIHQgfnJldHVybjpGbi5pZCB+b3RoZXI6KGZ1biBfIC0+IGRlZmF1bHQpXG5cbiAgbGV0IHdpdGhfcmV0dXJuIGYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gcmV0IC0+IG90aGVyIChmIChXaXRoX3JldHVybi5wcmVwZW5kIHJldCB+ZjpyZXR1cm4pKSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmlyc3QgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gZmlyc3RcbiAgICBsZXQgb3RoZXIgPSBzZWNvbmRcblxuICAgIGxldCBlaXRoZXIgdCB+cmV0dXJuIH5vdGhlciA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRmlyc3QgeCAtPiByZXR1cm4geFxuICAgICAgfCBTZWNvbmQgeSAtPiBvdGhlciB5XG4gICAgOztcblxuICAgIGxldCBjb21iaW5lIHQxIHQyIH5mIH5vdGhlciA9XG4gICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChmIHggeSlcbiAgICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAob3RoZXIgeCB5KVxuICAgICAgfCBTZWNvbmQgeCwgXyB8IF8sIFNlY29uZCB4IC0+IFNlY29uZCB4XG4gICAgOztcblxuICAgIGxldCBiaW5kIHQgfmYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpcnN0IHggLT4gZiB4XG4gICAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbi4gKilcbiAgICAgIHwgU2Vjb25kIF8gYXMgeSAtPiB5XG4gICAgOztcbiAgZW5kKVxuXG5tb2R1bGUgU2Vjb25kID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gICAgbGV0IHJldHVybiA9IHNlY29uZFxuICAgIGxldCBvdGhlciA9IGZpcnN0XG5cbiAgICBsZXQgZWl0aGVyIHQgfnJldHVybiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFNlY29uZCB5IC0+IHJldHVybiB5XG4gICAgICB8IEZpcnN0IHggLT4gb3RoZXIgeFxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAoZiB4IHkpXG4gICAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKG90aGVyIHggeSlcbiAgICAgIHwgRmlyc3QgeCwgXyB8IF8sIEZpcnN0IHggLT4gRmlyc3QgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeCAtPiBmIHhcbiAgICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLCBsaWtlIFtGaXJzdC5iaW5kXSBhYm92ZS4gKilcbiAgICAgIHwgRmlyc3QgXyBhcyB5IC0+IHlcbiAgICA7O1xuICBlbmQpXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2YsICdzKSBfZWl0aGVyID0gKCdmLCAncykgdCA9XG4gICAgfCBGaXJzdCBvZiAnZlxuICAgIHwgU2Vjb25kIG9mICdzXG5lbmRcbiIsImluY2x1ZGUgSW5kZXhlZF9jb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5sZXQgaXRlcmkgfmZvbGQgdCB+ZiA9XG4gIGlnbm9yZVxuICAgIChmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIGkgeCAtPlxuICAgICAgIGYgaSB4O1xuICAgICAgIGkgKyAxKVxuICAgICA6IGludClcbjs7XG5cbmxldCBmb2xkaSB+Zm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgdiAtPlxuICAgIGxldCBhY2MgPSBmICFpIGFjYyB2IGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgYWNjKVxuOztcblxubGV0IGNvdW50aSB+Zm9sZGkgdCB+ZiA9IGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgbiBhIC0+IGlmIGYgaSBhIHRoZW4gbiArIDEgZWxzZSBuKVxuXG5sZXQgZXhpc3RzaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBmb3JfYWxsaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgbm90IChmIGkgeCkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBmaW5kX21hcGkgfml0ZXJpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgZmluZGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gKFNvbWUgKGksIHgpKSk7XG4gICAgTm9uZSlcbjs7XG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IHNpZ1xuICAgIGluY2x1ZGUgQ29udGFpbmVyX2ludGYuTWFrZV9nZW5fYXJnXG5cbiAgICB2YWwgaXRlcmkgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhIHQsICdhIGVsdCkgaXRlcmkgXVxuICAgIHZhbCBmb2xkaSA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAoJ2EgdCwgJ2EgZWx0LCBfKSBmb2xkaSBdXG4gIGVuZCkgOiBHZW5lcmljIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudCB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0ID0gc3RydWN0XG4gIGluY2x1ZGUgQ29udGFpbmVyLk1ha2VfZ2VuIChUKVxuXG4gIGxldCBpdGVyaSA9XG4gICAgbWF0Y2ggVC5pdGVyaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXJpIC0+IGl0ZXJpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlcmkgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBmb2xkaSA9XG4gICAgbWF0Y2ggVC5mb2xkaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGZvbGRpIC0+IGZvbGRpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmluaXQgfmYgLT4gZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9IGNvdW50aSB+Zm9sZGkgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gZXhpc3RzaSB+aXRlcmkgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IGZvcl9hbGxpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZGkgdCB+ZiA9IGZpbmRpIH5pdGVyaSB0IH5mXG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoVClcblxuICAoKiBOb3QgcGFydCBvZiBbQ29udGFpbmVyLkdlbmVyaWNdLiAqKVxuICBsZXQgbWVtID0gQy5tZW1cblxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA9IHN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlMCAoVClcblxuICAoKiBOb3QgcGFydCBvZiBbQ29udGFpbmVyLkdlbmVyaWNdLiAqKVxuICBsZXQgbWVtID0gQy5tZW1cblxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIGVuZClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuIENvbnRhaW5lcl9pbnRmLkV4cG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgTGlzdCA9IExpc3QxXG5cbm1vZHVsZSBTdGVwID0gc3RydWN0XG4gICgqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZlxuICAgICB0aGUgc2VxdWVuY2UgKilcbiAgdHlwZSAoJ2EsICdzKSB0ID1cbiAgICB8IERvbmVcbiAgICB8IFNraXAgb2YgJ3NcbiAgICB8IFlpZWxkIG9mICdhICogJ3NcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2EgJ3MuXG4gICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ3MpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzAwOV8gc19fMDEwXylcbiAgICAgICAgOiAgKChhX18wMDlfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKHNfXzAxMF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgICAgLT4gKGFfXzAwOV8sIHNfXzAxMF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgICAgZnVuIF9vZl9hX18wMDFfIF9vZl9zX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgRG9uZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEb25lXCJcbiAgICAgICAgfCBTa2lwIGFyZzBfXzAwM18gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDA0XyA9IF9vZl9zX18wMDJfIGFyZzBfXzAwM18gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTa2lwXCI7IHJlczBfXzAwNF8gXVxuICAgICAgICB8IFlpZWxkIChhcmcwX18wMDVfLCBhcmcxX18wMDZfKSAtPlxuICAgICAgICAgIGxldCByZXMwX18wMDdfID0gX29mX2FfXzAwMV8gYXJnMF9fMDA1X1xuICAgICAgICAgIGFuZCByZXMxX18wMDhfID0gX29mX3NfXzAwMl8gYXJnMV9fMDA2XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIllpZWxkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxub3BlbiBTdGVwXG5cbigqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIHNlcXVlbmNlICopXG50eXBlICtfIHQgPSBTZXF1ZW5jZSA6ICdzICogKCdzIC0+ICgnYSwgJ3MpIFN0ZXAudCkgLT4gJ2EgdFxudHlwZSAnYSBzZXF1ZW5jZSA9ICdhIHRcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgbmV4dF9zdGVwIChTZXF1ZW5jZSAocywgZikpID1cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIGYpKVxuICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBTZXF1ZW5jZSAocywgZikpXG4gIDs7XG5cbiAgbGV0IGRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBsb29wIHMgbmV4dCBmaW5pc2ggZiBhY2MgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgICB8IFNraXAgcyAtPiBmIGFjYyBOb25lIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGYgYWNjIChTb21lIGEpIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGZpbmlzaCBmIGluaXRcbiAgOztcbmVuZFxuXG5sZXQgdW5mb2xkX3N0ZXAgfmluaXQgfmYgPSBTZXF1ZW5jZSAoaW5pdCwgZilcblxubGV0IHVuZm9sZCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOihmdW4gcyAtPlxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBOb25lIC0+IFN0ZXAuRG9uZVxuICAgIHwgU29tZSAoYSwgcykgLT4gU3RlcC5ZaWVsZCAoYSwgcykpXG47O1xuXG5sZXQgdW5mb2xkX3dpdGggcyB+aW5pdCB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIChpbml0LCBzKVxuICAgICAgLCBmdW4gKHNlZWQsIHMpIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKHNlZWQsIHMpXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAgICAgKG1hdGNoIGYgc2VlZCBhIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHNlZWQgLT4gU2tpcCAoc2VlZCwgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgc2VlZCkgLT4gWWllbGQgKGEsIChzZWVkLCBzKSkpIClcbjs7XG5cbmxldCB1bmZvbGRfd2l0aF9hbmRfZmluaXNoIHMgfmluaXQgfnJ1bm5pbmdfc3RlcCB+aW5uZXJfZmluaXNoZWQgfmZpbmlzaGluZ19zdGVwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYElubmVyX3J1bm5pbmcgKGluaXQsIHMpXG4gICAgICAsIGZ1biBzdGF0ZSAtPlxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBpbm5lcl9zdGF0ZSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIChgSW5uZXJfZmluaXNoZWQgKGlubmVyX2ZpbmlzaGVkIHN0YXRlKSlcbiAgICAgICAgICAgfCBTa2lwIGlubmVyX3N0YXRlIC0+IFNraXAgKGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKVxuICAgICAgICAgICB8IFlpZWxkICh4LCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAgICAobWF0Y2ggcnVubmluZ19zdGVwIHN0YXRlIHggd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgc3RhdGUgLT4gU2tpcCAoYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkpXG4gICAgICAgICAgICAgIHwgWWllbGQgKHksIHN0YXRlKSAtPiBZaWVsZCAoeSwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkpKSlcbiAgICAgICAgfCBgSW5uZXJfZmluaXNoZWQgc3RhdGUgLT5cbiAgICAgICAgICAobWF0Y2ggZmluaXNoaW5nX3N0ZXAgc3RhdGUgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgc3RhdGUgLT4gU2tpcCAoYElubmVyX2ZpbmlzaGVkIHN0YXRlKVxuICAgICAgICAgICB8IFlpZWxkICh5LCBzdGF0ZSkgLT4gWWllbGQgKHksIGBJbm5lcl9maW5pc2hlZCBzdGF0ZSkpIClcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpsIH5mOihmdW5jdGlvblxuICAgIHwgW10gLT4gRG9uZVxuICAgIHwgeCA6OiBsIC0+IFlpZWxkICh4LCBsKSlcbjs7XG5cblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIHYgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiB2XG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIHYgbmV4dCBmXG4gICAgfCBZaWVsZCAoYSwgcykgLT4gbG9vcCBzIChmIHYgYSkgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgaW5pdCBuZXh0IGZcbjs7XG5cbmxldCB0b19saXN0X3JldiB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbClcblxuXG5sZXQgdG9fbGlzdCAoU2VxdWVuY2UgKHMsIG5leHQpKSA9XG4gIGxldCBzYWZlX3RvX2xpc3QgdCA9IExpc3QucmV2ICh0b19saXN0X3JldiB0KSBpblxuICBsZXQgcmVjIHRvX2xpc3QgcyBuZXh0IGkgPVxuICAgIGlmIGkgPSAwXG4gICAgdGhlbiBzYWZlX3RvX2xpc3QgKFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gW11cbiAgICAgIHwgU2tpcCBzIC0+IHRvX2xpc3QgcyBuZXh0IGlcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGEgOjogdG9fbGlzdCBzIG5leHQgKGkgLSAxKSlcbiAgaW5cbiAgdG9fbGlzdCBzIG5leHQgNTAwXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfdiBzdG9wX3YgPVxuICBsZXQgc3RlcCA9XG4gICAgbWF0Y2ggc3RvcCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPiBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gICAgfCBgaW5jbHVzaXZlIC0+IGZ1biBpIC0+IGlmIGkgPCBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gICAgfCBgZXhjbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPj0gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBmdW4gaSAtPiBpZiBpIDw9IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgaW5cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfdlxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBzdGFydF92ICsgc3RyaWRlXG4gIGluXG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOnN0ZXBcbjs7XG5cbmxldCBvZl9sYXp5IHRfbGF6eSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnRfbGF6eSB+ZjooZnVuIHRfbGF6eSAtPlxuICAgIGxldCAoU2VxdWVuY2UgKHMsIG5leHQpKSA9IExhenkuZm9yY2UgdF9sYXp5IGluXG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+XG4gICAgICBTa2lwXG4gICAgICAgIChsZXQgdiA9IFNlcXVlbmNlIChzLCBuZXh0KSBpblxuICAgICAgICAgbGF6eSB2KVxuICAgIHwgWWllbGQgKHgsIHMpIC0+XG4gICAgICBZaWVsZFxuICAgICAgICAoIHhcbiAgICAgICAgLCBsZXQgdiA9IFNlcXVlbmNlIChzLCBuZXh0KSBpblxuICAgICAgICAgIGxhenkgdiApKVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc2VlZFxuICAgICAgLCBmdW4gc2VlZCAtPlxuICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGYgYSwgcykgKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChmIGkgYSwgKGkgKyAxLCBzKSkgKVxuOztcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICB1bmZvbGRfd2l0aCB0IH5pbml0IH5mOihmdW4gYWNjIHggLT5cbiAgICBsZXQgYWNjLCB4ID0gZiBhY2MgeCBpblxuICAgIFlpZWxkICh4LCBhY2MpKVxuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgaSBhY2MgeCBpblxuICAgIFlpZWxkICh4LCAoaSArIDEsIGFjYykpKVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc2VlZFxuICAgICAgLCBmdW4gc2VlZCAtPlxuICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gWWllbGQgKGEsIHMpXG4gICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IFNraXAgcyApXG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbWFwIH5mOnNuZCAoZmlsdGVyIChtYXBpIHQgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKSlcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gaVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgaSBzIG5leHRcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIChpICsgMSkgcyBuZXh0XG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIDAgc2VlZCBuZXh0XG47O1xuXG5sZXQgdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCA9IGZvbGQgdCB+aW5pdDooW10sIDApIH5mOihmdW4gKGwsIGkpIHggLT4geCA6OiBsLCBpICsgMSlcblxubGV0IHRvX2FycmF5IHQgPVxuICBsZXQgbCwgbGVuID0gdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCBpblxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgeCA6OiBsIC0+XG4gICAgbGV0IGEgPSBBcnJheS5jcmVhdGUgfmxlbiB4IGluXG4gICAgbGV0IHJlYyBsb29wIGkgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gLTEpXG4gICAgICB8IHggOjogbCAtPlxuICAgICAgICBhLihpKSA8LSB4O1xuICAgICAgICBsb29wIChpIC0gMSkgbFxuICAgIGluXG4gICAgbG9vcCAobGVuIC0gMikgbDtcbiAgICBhXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGEgLT4gU29tZSBhXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGYgYSB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgcyBuZXh0IGZcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggZiBpIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIG5vdCAoZiBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIG5vdCAoZiBpIGEpIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBpIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHNlZWQgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiAoKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgZiBhO1xuICAgICAgbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIF8gLT4gZmFsc2VcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGEgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYiwgXykgd2hlbiBlcXVhbCBhIGIgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGFcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGFcbjs7XG5cbmxldCBlbXB0eSA9IFNlcXVlbmNlICgoKSwgZnVuICgpIC0+IERvbmUpXG5cbmxldCBiaW5kIHQgfmYgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCksIHJlc3QgLT5cbiAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICB8IERvbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoZW1wdHksIFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgICAgICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFNraXAgKGYgYSwgU2VxdWVuY2UgKHMsIG5leHQpKSkpXG4gICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChTZXF1ZW5jZSAocywgbmV4dCksIHJlc3QpXG4gICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgKFNlcXVlbmNlIChzLCBuZXh0KSwgcmVzdCkpKSlcbiAgICB+aW5pdDooZW1wdHksIHQpXG47O1xuXG5sZXQgcmV0dXJuIHggPVxuICB1bmZvbGRfc3RlcCB+aW5pdDooU29tZSB4KSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gRG9uZVxuICAgIHwgU29tZSB4IC0+IFlpZWxkICh4LCBOb25lKSlcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgZW5kKVxuXG5sZXQgbnRoIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBOb25lXG4gICAgICB8IFNraXAgcyAtPiBsb29wIGkgcyBuZXh0XG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBpZiBwaHlzX2VxdWFsIGkgMCB0aGVuIFNvbWUgYSBlbHNlIGxvb3AgKGkgLSAxKSBzIG5leHRcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgbiBzIG5leHQpXG47O1xuXG5sZXQgbnRoX2V4biBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UubnRoXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggbnRoIHMgbiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UubnRoXCJcbiAgICB8IFNvbWUgeCAtPiB4KVxuOztcblxubW9kdWxlIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBMZWZ0IG9mICdhXG4gICAgfCBSaWdodCBvZiAnYlxuICAgIHwgQm90aCBvZiAnYSAqICdiXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDExXyBiX18wMTJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTFfLCBiX18wMTJfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDEzXywgTGVmdCBfYl9fMDE0XyAtPiBfY21wX19hIF9hX18wMTNfIF9iX18wMTRfXG4gICAgICB8IExlZnQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gMVxuICAgICAgfCBSaWdodCBfYV9fMDE1XywgUmlnaHQgX2JfXzAxNl8gLT4gX2NtcF9fYiBfYV9fMDE1XyBfYl9fMDE2X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gMVxuICAgICAgfCBCb3RoIChfYV9fMDE3XywgX2FfXzAxOV8pLCBCb3RoIChfYl9fMDE4XywgX2JfXzAyMF8pIC0+XG4gICAgICAgIChtYXRjaCBfY21wX19hIF9hX18wMTdfIF9iX18wMThfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19iIF9hX18wMTlfIF9iX18wMjBfXG4gICAgICAgICB8IG4gLT4gbikpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90XG4gICAgOiB0eXBlIGEgYi5cbiAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAtPiAoYSwgYikgdFxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICB8IExlZnQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgfCBSaWdodCBfYTAgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG4gICAgICB8IEJvdGggKF9hMCwgX2ExKSAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyIGluXG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgICBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdhICdiLlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNDRfIGJfXzA0NV8pXG4gICAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzA0NF8pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDQ1XylcbiAgICAgICAgICAgIC0+IFNleHBsaWIwLlNleHAudCAtPiAoYV9fMDQ0XywgYl9fMDQ1XykgdCkgLT5cbiAgICAgIGxldCBlcnJvcl9zb3VyY2VfXzAyNV8gPSBcInNlcXVlbmNlLm1sLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnRcIiBpblxuICAgICAgZnVuIF9vZl9hX18wMjFfIF9vZl9iX18wMjJfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgX3RhZ19fMDI4XykgOjogc2V4cF9hcmdzX18wMjlfKSBhc1xuICAgICAgICAgIF9zZXhwX18wMjdfIC0+XG4gICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDI5XyB3aXRoXG4gICAgICAgICAgIHwgWyBhcmcwX18wMzBfIF0gLT5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDMxXyA9IF9vZl9hX18wMjFfIGFyZzBfXzAzMF8gaW5cbiAgICAgICAgICAgICBMZWZ0IHJlczBfXzAzMV9cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMjhfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDI3XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIF90YWdfXzAzM18pIDo6IHNleHBfYXJnc19fMDM0XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDMyXyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAzNF8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDM1XyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzNl8gPSBfb2ZfYl9fMDIyXyBhcmcwX18wMzVfIGluXG4gICAgICAgICAgICAgUmlnaHQgcmVzMF9fMDM2X1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyNV9cbiAgICAgICAgICAgICAgIF90YWdfXzAzM19cbiAgICAgICAgICAgICAgIF9zZXhwX18wMzJfKVxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIF90YWdfXzAzOF8pIDo6IHNleHBfYXJnc19fMDM5XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDM3XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAzOV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDQwXzsgYXJnMV9fMDQxXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzA0Ml8gPSBfb2ZfYV9fMDIxXyBhcmcwX18wNDBfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzA0M18gPSBfb2ZfYl9fMDIyXyBhcmcxX18wNDFfIGluXG4gICAgICAgICAgICAgQm90aCAocmVzMF9fMDQyXywgcmVzMV9fMDQzXylcbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMzhfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDM3XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjZfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjZfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI0X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMjRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgICAgICAgfCBzZXhwX18wMjRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI0X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNTZfIGJfXzA1N18pXG4gICAgICAgIDogICgoYV9fMDU2XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wNTdfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wNTZfLCBiX18wNTdfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDQ2XyBfb2ZfYl9fMDQ3XyAtPiBmdW5jdGlvblxuICAgICAgICB8IExlZnQgYXJnMF9fMDQ4XyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNDlfID0gX29mX2FfXzA0Nl8gYXJnMF9fMDQ4XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgcmVzMF9fMDQ5XyBdXG4gICAgICAgIHwgUmlnaHQgYXJnMF9fMDUwXyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTFfID0gX29mX2JfXzA0N18gYXJnMF9fMDUwXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IHJlczBfXzA1MV8gXVxuICAgICAgICB8IEJvdGggKGFyZzBfXzA1Ml8sIGFyZzFfXzA1M18pIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzA1NF8gPSBfb2ZfYV9fMDQ2XyBhcmcwX18wNTJfXG4gICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2ZfYl9fMDQ3XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiOyByZXMwX18wNTRfOyByZXMxX18wNTVfIF1cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgIFZhcmlhbnRcbiAgICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkJvdGhcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5sZXQgbWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSB+Y29tcGFyZSA9XG4gIGxldCB1bnNoYWRvd2VkX2NvbXBhcmUgPSBjb21wYXJlIGluXG4gIGxldCBvcGVuIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50IGluXG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgICB8IChZaWVsZCAoYSwgczEnKSBhcyBzMSksIChZaWVsZCAoYiwgczInKSBhcyBzMikgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gdW5zaGFkb3dlZF9jb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8IDBcbiAgICAgIHRoZW4gWWllbGQgKExlZnQgYSwgKFNraXAgczEnLCBzMikpXG4gICAgICBlbHNlIGlmIGNvbXBhcmlzb24gPSAwXG4gICAgICB0aGVuIFlpZWxkIChCb3RoIChhLCBiKSwgKFNraXAgczEnLCBTa2lwIHMyJykpXG4gICAgICBlbHNlIFlpZWxkIChSaWdodCBiLCAoczEsIFNraXAgczInKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoTGVmdCBhLCAoU2tpcCBzMSwgRG9uZSkpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChSaWdodCBiLCAoRG9uZSwgU2tpcCBzMikpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgbWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIHMxIHMyIH5jb21wYXJlID1cbiAgbWFwIChtZXJnZV93aXRoX2R1cGxpY2F0ZXMgczEgczIgfmNvbXBhcmUpIH5mOihmdW5jdGlvblxuICAgIHwgTGVmdCB4IHwgUmlnaHQgeCB8IEJvdGggKHgsIF8pIC0+IHgpXG47O1xuXG5sZXQgKG1lcmdlIFtAZGVwcmVjYXRlZFxuICAgICAgIFwiW3NpbmNlIDIwMjEtMDddIEZvciBpZGVudGljYWwgYmVoYXZpb3IsIHVzZSBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkXSwgYnV0IGNvbnNpZGVyIHVzaW5nIFxcXG4gICAgICAgIFtTZXF1ZW5jZS5tZXJnZV9zb3J0ZWRdIGluc3RlYWQuXCJdKVxuICA9XG4gIG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZFxuOztcblxubGV0IG1lcmdlX3NvcnRlZCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgfmNvbXBhcmUgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCAoWWllbGQgKGEsIHMxJykgYXMgczEpLCAoWWllbGQgKGIsIHMyJykgYXMgczIpIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IGNvbXBhcmUgYSBiIGluXG4gICAgICBpZiBjb21wYXJpc29uIDw9IDAgdGhlbiBZaWVsZCAoYSwgKFNraXAgczEnLCBzMikpIGVsc2UgWWllbGQgKGIsIChzMSwgU2tpcCBzMicpKVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChhLCAoU2tpcCBzMSwgRG9uZSkpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChiLCAoRG9uZSwgU2tpcCBzMikpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgaGQgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgKGEsIF8pIC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBoZF9leG4gcyA9XG4gIG1hdGNoIGhkIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJoZF9leG5cIlxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdGwgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgKF8sIGEpIC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICAobWF0Y2ggbG9vcCBzIG5leHQgd2l0aFxuICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB8IFNvbWUgcyAtPiBTb21lIChTZXF1ZW5jZSAocywgbmV4dCkpKVxuOztcblxubGV0IHRsX2VhZ2VybHlfZXhuIHMgPVxuICBtYXRjaCB0bCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UudGxfZXhuXCJcbiAgfCBTb21lIHMgLT4gc1xuOztcblxubGV0IGxpZnRfaWRlbnRpdHkgbmV4dCBzID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBEb25lIC0+IERvbmVcbiAgfCBTa2lwIHMgLT4gU2tpcCAoYElkZW50aXR5IHMpXG4gIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgSWRlbnRpdHkgcylcbjs7XG5cbmxldCBuZXh0IHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBTb21lIChhLCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dFxuOztcblxubGV0IGZpbHRlcl9vcHQgcyA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNcbiAgICAgICwgZnVuIHMgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKE5vbmUsIHMpIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChTb21lIGEsIHMpIC0+IFlpZWxkIChhLCBzKSApXG47O1xuXG5sZXQgZmlsdGVyX21hcCBzIH5mID0gZmlsdGVyX29wdCAobWFwIHMgfmYpXG5sZXQgZmlsdGVyX21hcGkgcyB+ZiA9IGZpbHRlcl9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBzcGxpdF9uIHMgbiA9XG4gIGxldCByZWMgbG9vcCBzIGkgYWNjdW0gbmV4dCA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiBMaXN0LnJldiBhY2N1bSwgU2VxdWVuY2UgKHMsIG5leHQpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IExpc3QucmV2IGFjY3VtLCBlbXB0eVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBzIGkgYWNjdW0gbmV4dFxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gbG9vcCBzIChpIC0gMSkgKGEgOjogYWNjdW0pIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbiBbXSBuZXh0XG47O1xuXG5sZXQgY2h1bmtzX2V4biB0IG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmNodW5rc19leG5cIlxuICBlbHNlXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQ6dCB+ZjooZnVuIHQgLT5cbiAgICAgIG1hdGNoIHNwbGl0X24gdCBuIHdpdGhcbiAgICAgIHwgW10sIF9lbXB0eSAtPiBEb25lXG4gICAgICB8IChfIDo6IF8gYXMgeHMpLCB0IC0+IFlpZWxkICh4cywgdCkpXG47O1xuXG5sZXQgZmluZGkgcyB+ZiA9IGZpbmQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBmaW5kX2V4biBzIH5mID1cbiAgbWF0Y2ggZmluZCBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UuZmluZF9leG5cIlxuICB8IFNvbWUgeCAtPiB4XG47O1xuXG5sZXQgYXBwZW5kIHMxIHMyID1cbiAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgfCBTZXF1ZW5jZSAoczEsIG5leHQxKSwgU2VxdWVuY2UgKHMyLCBuZXh0MikgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgRmlyc3RfbGlzdCBzMVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBGaXJzdF9saXN0IHMxIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQxIHMxIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IFNraXAgKGBTZWNvbmRfbGlzdCBzMilcbiAgICAgICAgICAgfCBTa2lwIHMxIC0+IFNraXAgKGBGaXJzdF9saXN0IHMxKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzMSkgLT4gWWllbGQgKGEsIGBGaXJzdF9saXN0IHMxKSlcbiAgICAgICAgfCBgU2Vjb25kX2xpc3QgczIgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dDIgczIgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgczIgLT4gU2tpcCAoYFNlY29uZF9saXN0IHMyKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzMikgLT4gWWllbGQgKGEsIGBTZWNvbmRfbGlzdCBzMikpIClcbjs7XG5cbmxldCBjb25jYXRfbWFwIHMgfmYgPSBiaW5kIHMgfmZcbmxldCBjb25jYXQgcyA9IGNvbmNhdF9tYXAgcyB+ZjpGbi5pZFxubGV0IGNvbmNhdF9tYXBpIHMgfmYgPSBjb25jYXRfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgemlwIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIChhLCBzMSksIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKChhLCBiKSwgKFNraXAgczEsIFNraXAgczIpKVxuICAgIHwgRG9uZSwgXyB8IF8sIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IHppcF9mdWxsIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIChhLCBzMSksIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKGBCb3RoIChhLCBiKSwgKFNraXAgczEsIFNraXAgczIpKVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChgUmlnaHQgYiwgKERvbmUsIG5leHQyIHMyKSlcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKGBMZWZ0IGEsIChuZXh0MSBzMSwgRG9uZSkpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgYm91bmRlZF9sZW5ndGggKFNlcXVlbmNlIChzZWVkLCBuZXh0KSkgfmF0X21vc3QgPVxuICBsZXQgcmVjIGxvb3AgaSBzZWVkIG5leHQgPVxuICAgIGlmIGkgPiBhdF9tb3N0XG4gICAgdGhlbiBgR3JlYXRlclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBgSXMgaVxuICAgICAgfCBTa2lwIHNlZWQgLT4gbG9vcCBpIHNlZWQgbmV4dFxuICAgICAgfCBZaWVsZCAoXywgc2VlZCkgLT4gbG9vcCAoaSArIDEpIHNlZWQgbmV4dClcbiAgaW5cbiAgbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IGxlbmd0aF9pc19ib3VuZGVkX2J5ID8obWluID0gLTEpID9tYXggdCA9XG4gIGxldCBsZW5ndGhfaXNfYXRfbGVhc3QgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICAgIGxldCByZWMgbG9vcCBzIGFjYyA9XG4gICAgICBpZiBhY2MgPj0gbWluXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gZmFsc2VcbiAgICAgICAgfCBTa2lwIHMgLT4gbG9vcCBzIGFjY1xuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgKGFjYyArIDEpKVxuICAgIGluXG4gICAgbG9vcCBzIDBcbiAgaW5cbiAgbWF0Y2ggbWF4IHdpdGhcbiAgfCBOb25lIC0+IGxlbmd0aF9pc19hdF9sZWFzdCB0XG4gIHwgU29tZSBtYXggLT5cbiAgICAobWF0Y2ggYm91bmRlZF9sZW5ndGggdCB+YXRfbW9zdDptYXggd2l0aFxuICAgICB8IGBJcyBsZW4gd2hlbiBsZW4gPj0gbWluIC0+IHRydWVcbiAgICAgfCBfIC0+IGZhbHNlKVxuOztcblxubGV0IGl0ZXJpIHMgfmYgPSBpdGVyIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgZm9sZGkgcyB+aW5pdCB+ZiA9XG4gIGZvbGQgfmluaXQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biBhY2MgKGksIHMpIC0+IGYgaSBhY2Mgcylcbjs7XG5cbmxldCByZWR1Y2UgcyB+ZiA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoYSwgcykgLT4gU29tZSAoZm9sZCBzIH5pbml0OmEgfmYpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBzIH5mID1cbiAgbWF0Y2ggcmVkdWNlIHMgfmYgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHJlcyAtPiByZXNcbjs7XG5cbmxldCBncm91cCAoU2VxdWVuY2UgKHMsIG5leHQpKSB+YnJlYWsgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5pbml0OihTb21lIChbXSwgcykpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gRG9uZVxuICAgICAgfCBTb21lIChhY2MsIHMpIC0+XG4gICAgICAgIChtYXRjaCBhY2MsIG5leHQgcyB3aXRoXG4gICAgICAgICB8IF8sIFNraXAgcyAtPiBTa2lwIChTb21lIChhY2MsIHMpKVxuICAgICAgICAgfCBbXSwgRG9uZSAtPiBEb25lXG4gICAgICAgICB8IGFjYywgRG9uZSAtPiBZaWVsZCAoTGlzdC5yZXYgYWNjLCBOb25lKVxuICAgICAgICAgfCBbXSwgWWllbGQgKGN1ciwgcykgLT4gU2tpcCAoU29tZSAoWyBjdXIgXSwgcykpXG4gICAgICAgICB8IChwcmV2IDo6IF8gYXMgYWNjKSwgWWllbGQgKGN1ciwgcykgLT5cbiAgICAgICAgICAgaWYgYnJlYWsgcHJldiBjdXJcbiAgICAgICAgICAgdGhlbiBZaWVsZCAoTGlzdC5yZXYgYWNjLCBTb21lIChbIGN1ciBdLCBzKSlcbiAgICAgICAgICAgZWxzZSBTa2lwIChTb21lIChjdXIgOjogYWNjLCBzKSkpKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIChTZXF1ZW5jZSAocywgbmV4dCkpIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBsYXN0X2VsdCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBsYXN0X2VsdCBzXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBsYXN0X2VsdCB3aXRoXG4gICAgICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU29tZSAoYiwgYSlcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gbG9vcCAoU29tZSBhKSBzKVxuICBpblxuICBsb29wIE5vbmUgc1xuOztcblxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIHMgfmVxdWFsID1cbiAgdW5mb2xkX3dpdGggcyB+aW5pdDpOb25lIH5mOihmdW4gcHJldiBhIC0+XG4gICAgbWF0Y2ggcHJldiB3aXRoXG4gICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU2tpcCAoU29tZSBhKVxuICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBZaWVsZCAoYSwgU29tZSBhKSlcbjs7XG5cbmxldCBjb3VudCBzIH5mID0gbGVuZ3RoIChmaWx0ZXIgcyB+ZilcbmxldCBjb3VudGkgdCB+ZiA9IGxlbmd0aCAoZmlsdGVyaSB0IH5mKVxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBpbml0IG4gfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gaSAtPiBpZiBpID49IG4gdGhlbiBEb25lIGVsc2UgWWllbGQgKGYgaSwgaSArIDEpKVxuOztcblxubGV0IHN1YiBzIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2Uuc3ViXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIGlmIGkgLSBwb3MgPj0gbGVuXG4gICAgICAgIHRoZW4gRG9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGkgPj0gcG9zIC0+IFlpZWxkIChhLCAoaSArIDEsIHMpKVxuICAgICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IFNraXAgKGkgKyAxLCBzKSkgKVxuOztcblxubGV0IHRha2UgcyBsZW4gPVxuICBpZiBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS50YWtlXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIGlmIGkgPj0gbGVuXG4gICAgICAgIHRoZW4gRG9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSkpIClcbjs7XG5cbmxldCBkcm9wIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UuZHJvcFwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGkgPj0gbGVuIC0+IFlpZWxkIChhLCAoaSArIDEsIHMpKVxuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIChpICsgMSwgcykgKVxuOztcblxubGV0IHRha2Vfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNcbiAgICAgICwgZnVuIHMgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFlpZWxkIChhLCBzKVxuICAgICAgICB8IFlpZWxkIChfLCBfKSAtPiBEb25lIClcbjs7XG5cbmxldCBkcm9wX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgRHJvcHBpbmcgc1xuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBEcm9wcGluZyBzIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGBEcm9wcGluZyBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBTa2lwIChgRHJvcHBpbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBJZGVudGl0eSBzKSlcbiAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcyApXG47O1xuXG5sZXQgc2hpZnRfcmlnaHQgcyB4ID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYENvbnNpbmcgKHNlZWQsIHgpXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYENvbnNpbmcgKHNlZWQsIHgpIC0+IFlpZWxkICh4LCBgSWRlbnRpdHkgc2VlZClcbiAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcyApXG47O1xuXG5sZXQgc2hpZnRfcmlnaHRfd2l0aF9saXN0IHMgbCA9IGFwcGVuZCAob2ZfbGlzdCBsKSBzXG5sZXQgc2hpZnRfbGVmdCA9IGRyb3BcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoIEAgKSA9IGFwcGVuZFxuZW5kXG5cbmxldCBpbnRlcnNwZXJzZSBzIH5zZXAgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgSW5pdCBzXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYEluaXQgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgSW5pdCBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYFJ1bm5pbmcgcykpXG4gICAgICAgIHwgYFJ1bm5pbmcgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgUnVubmluZyBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoc2VwLCBgUHV0dGluZyAoYSwgcykpKVxuICAgICAgICB8IGBQdXR0aW5nIChhLCBzKSAtPiBZaWVsZCAoYSwgYFJ1bm5pbmcgcykgKVxuOztcblxubGV0IHJlcGVhdCB4ID0gdW5mb2xkX3N0ZXAgfmluaXQ6eCB+ZjooZnVuIHggLT4gWWllbGQgKHgsIHgpKVxuXG5sZXQgY3ljbGVfbGlzdF9leG4geHMgPVxuICBpZiBMaXN0LmlzX2VtcHR5IHhzIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jeWNsZV9saXN0X2V4blwiO1xuICBsZXQgcyA9IG9mX2xpc3QgeHMgaW5cbiAgY29uY2F0X21hcCB+ZjooZnVuICgpIC0+IHMpIChyZXBlYXQgKCkpXG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3Qgc2Egc2IgPSBjb25jYXRfbWFwIHNhIH5mOihmdW4gYSAtPiB6aXAgKHJlcGVhdCBhKSBzYilcbmxldCBzaW5nbGV0b24geCA9IHJldHVybiB4XG5cbmxldCBkZWxheWVkX2ZvbGQgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmZpbmlzaCB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgIHwgTm9uZSAtPiBrIGFjY1xuICAgIHwgU29tZSBhIC0+IGYgYWNjIGEgfmspXG47O1xuXG5sZXQgZm9sZF9tIH5iaW5kIH5yZXR1cm4gdCB+aW5pdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdFxuICAgIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gYWNjKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGFjYyBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgaXRlcl9tIH5iaW5kIH5yZXR1cm4gdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdDooKVxuICAgIH5mOihmdW4gKCkgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiAoKSkgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgZm9sZF91bnRpbCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKCdhLCAnYikgQ29udGludWVfb3Jfc3RvcC50KSB3aXRoXG4gICAgICAgfCBTdG9wIHggLT4geFxuICAgICAgIHwgQ29udGludWUgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgcyB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IFJlc3VsdC5yZXR1cm4gYWNjXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKF8sIF8pIFJlc3VsdC50KSB3aXRoXG4gICAgICAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICAgICAgIHwgT2sgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9yY2VfZWFnZXJseSB0ID0gb2ZfbGlzdCAodG9fbGlzdCB0KVxuXG5sZXQgbWVtb2l6ZSAodHlwZSBhKSAoU2VxdWVuY2UgKHMsIG5leHQpKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQgb2YgKGEsIHQpIFN0ZXAudCBMYXp5LnRcbiAgZW5kXG4gIGluXG4gIGxldCByZWMgbWVtb2l6ZSBzID0gTS5UIChsYXp5IChmaW5kX3N0ZXAgcykpXG4gIGFuZCBmaW5kX3N0ZXAgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+IGZpbmRfc3RlcCBzXG4gICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIG1lbW9pemUgcylcbiAgaW5cbiAgU2VxdWVuY2UgKG1lbW9pemUgcywgZnVuIChNLlQgbCkgLT4gTGF6eS5mb3JjZSBsKVxuOztcblxubGV0IGRyb3BfZWFnZXJseSBzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpIH5sZW4gcyBuZXh0ID1cbiAgICBpZiBpID49IGxlblxuICAgIHRoZW4gU2VxdWVuY2UgKHMsIG5leHQpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGVtcHR5XG4gICAgICB8IFNraXAgcyAtPiBsb29wIGkgfmxlbiBzIG5leHRcbiAgICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgKGkgKyAxKSB+bGVuIHMgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgMCB+bGVuIHMgbmV4dFxuOztcblxubGV0IGRyb3Bfd2hpbGVfb3B0aW9uIChTZXF1ZW5jZSAocywgbmV4dCkpIH5mID1cbiAgbGV0IHJlYyBsb29wIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHNcbiAgICB8IFlpZWxkICh4LCBzKSAtPiBpZiBmIHggdGhlbiBsb29wIHMgZWxzZSBTb21lICh4LCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gIGluXG4gIGxvb3Agc1xuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIHQxIHQyID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgICAgfCBgTGVmdCBfIC0+IHIucmV0dXJuIDFcbiAgICAgIHwgYFJpZ2h0IF8gLT4gci5yZXR1cm4gKC0xKVxuICAgICAgfCBgQm90aCAodjEsIHYyKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfYSB2MSB2MiBpblxuICAgICAgICBpZiBjIDw+IDAgdGhlbiByLnJldHVybiBjKTtcbiAgICAwKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPVxuICBmb3JfYWxsICh6aXBfZnVsbCB0MSB0MikgfmY6KGZ1bmN0aW9uXG4gICAgfCBgQm90aCAoYTEsIGEyKSAtPiBlcXVhbF9hIGExIGEyXG4gICAgfCBgTGVmdCBfIHwgYFJpZ2h0IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgcm91bmRfcm9iaW4gbGlzdCA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSAocywgZikgOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYgcyB3aXRoXG4gICAgICAgfCBZaWVsZCAoeCwgcykgLT4gWWllbGQgKHgsICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAocywgZikgOjogZG9uZV9zdGFjaykpXG4gICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIGYpIDo6IHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spXG4gICAgICAgfCBEb25lIC0+IFNraXAgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spKVxuICAgIHwgW10gLT4gaWYgTGlzdC5pc19lbXB0eSBkb25lX3N0YWNrIHRoZW4gRG9uZSBlbHNlIFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdKVxuICBpblxuICBsZXQgc3RhdGUgPSBsaXN0LCBbXSBpblxuICBTZXF1ZW5jZSAoc3RhdGUsIG5leHQpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZSAoU2VxdWVuY2UgKHMxLCBmMSkpID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSAoczIsIGYyKSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZjIgczIgd2l0aFxuICAgICAgIHwgWWllbGQgKHgsIHMyKSAtPiBZaWVsZCAoeCwgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzMiwgZjIpIDo6IGRvbmVfc3RhY2ssIHMxKSlcbiAgICAgICB8IFNraXAgczIgLT4gU2tpcCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMyLCBmMikgOjogZG9uZV9zdGFjaywgczEpXG4gICAgICAgfCBEb25lIC0+IFNraXAgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSlcbiAgICB8IFtdIC0+XG4gICAgICAobWF0Y2ggZjEgczEsIGRvbmVfc3RhY2sgd2l0aFxuICAgICAgIHwgWWllbGQgKHQsIHMxKSwgXyAtPiBTa2lwIChMaXN0LnJldiAodCA6OiBkb25lX3N0YWNrKSwgW10sIHMxKVxuICAgICAgIHwgU2tpcCBzMSwgXyAtPiBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSwgczEpXG4gICAgICAgfCBEb25lLCBfIDo6IF8gLT4gU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxKVxuICAgICAgIHwgRG9uZSwgW10gLT4gRG9uZSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gW10sIFtdLCBzMSBpblxuICBTZXF1ZW5jZSAoc3RhdGUsIG5leHQpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QgczEgczIgPVxuICBtYXAgczEgfmY6KGZ1biB4MSAtPiBtYXAgczIgfmY6KGZ1biB4MiAtPiB4MSwgeDIpKSB8PiBpbnRlcmxlYXZlXG47O1xuXG5sZXQgb2Zfc2VxIChzZXEgOiBfIENhbWwuU2VxLnQpID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6c2VxIH5mOihmdW4gc2VxIC0+XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBEb25lXG4gICAgfCBDb25zIChoZCwgdGwpIC0+IFlpZWxkIChoZCwgdGwpKVxuOztcblxubGV0IHRvX3NlcSAoU2VxdWVuY2UgKHN0YXRlLCBuZXh0KSkgPVxuICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgIG1hdGNoIG5leHQgc3RhdGUgd2l0aFxuICAgIHwgRG9uZSAtPiBDYW1sLlNlcS5OaWxcbiAgICB8IFNraXAgc3RhdGUgLT4gbG9vcCBzdGF0ZVxuICAgIHwgWWllbGQgKGhkLCBzdGF0ZSkgLT4gQ2FtbC5TZXEuQ29ucyAoaGQsIGZ1biAoKSAtPiBsb29wIHN0YXRlKVxuICBpblxuICBmdW4gKCkgLT4gbG9vcCBzdGF0ZVxuOztcblxubW9kdWxlIEdlbmVyYXRvciA9IHN0cnVjdFxuICB0eXBlICdlbHQgc3RlcHMgPSBXcmFwIG9mICgnZWx0LCB1bml0IC0+ICdlbHQgc3RlcHMpIFN0ZXAudFxuXG4gIGxldCB1bndyYXAgKFdyYXAgc3RlcCkgPSBzdGVwXG5cbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2VsdCkgdCA9ICgnYSAtPiAnZWx0IHN0ZXBzKSAtPiAnZWx0IHN0ZXBzXG5cbiAgICBsZXQgcmV0dXJuIHggayA9IGsgeFxuXG4gICAgbGV0IGJpbmQgbSB+ZiBrID1cbiAgICAgIG0gKGZ1biBhIC0+XG4gICAgICAgIGxldCBtJyA9IGYgYSBpblxuICAgICAgICBtJyBrKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwIG0gfmYgayA9IG0gKGZ1biBhIC0+IGsgKGYgYSkpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIE1vbmFkLk1ha2UyIChUKVxuXG4gIGxldCB5aWVsZCBlIGsgPSBXcmFwIChZaWVsZCAoZSwgaykpXG4gIGxldCB0b19zdGVwcyB0ID0gdCAoZnVuICgpIC0+IFdyYXAgRG9uZSlcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICAgIGRlbGF5ZWRfZm9sZFxuICAgICAgc2VxdWVuY2VcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuICgpIHggfmsgZiAtPiBXcmFwIChZaWVsZCAoeCwgZnVuICgpIC0+IGsgKCkgZikpKVxuICAgICAgfmZpbmlzaDpyZXR1cm5cbiAgOztcblxuICBsZXQgcnVuIHQgPVxuICAgIGxldCBpbml0ICgpID0gdG9fc3RlcHMgdCBpblxuICAgIGxldCBmIHRodW5rID0gdW53cmFwICh0aHVuayAoKSkgaW5cbiAgICB1bmZvbGRfc3RlcCB+aW5pdCB+ZlxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbnR5cGUgJ2EgdCA9ICdhIGFycmF5IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX2FycmF5XG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gYXJyYXlfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfYXJyYXlcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gYXJyYXlfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbigqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYSBuZXcgaW4tcGxhY2UsIGNvbnN0YW50IGhlYXAgc29ydGluZyBhbGdvcml0aG0gdG8gcmVwbGFjZSB0aGVcbiAgIG9uZSB1c2VkIGJ5IHRoZSBzdGFuZGFyZCBsaWJyYXJpZXMuICBJdHMgb25seSBwdXJwb3NlIGlzIHRvIGJlIGZhc3RlciAoaG9wZWZ1bGx5XG4gICBzdHJpY3RseSBmYXN0ZXIpIHRoYW4gdGhlIGJhc2Ugc29ydCBhbmQgc3RhYmxlX3NvcnQuXG5cbiAgIEF0IGEgaGlnaCBsZXZlbCB0aGUgYWxnb3JpdGhtIGlzOlxuICAgLSBwaWNrIHR3byBwaXZvdCBwb2ludHMgYnk6XG4gICAtIHBpY2sgNSBhcmJpdHJhcnkgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgIC0gc29ydCB0aGVtIHdpdGhpbiB0aGUgYXJyYXlcbiAgIC0gdGFrZSB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIG1pZGRsZSBlbGVtZW50IG9mIHRoZSBzb3J0IGFzIHRoZSBwaXZvdHNcbiAgIC0gc29ydCB0aGUgYXJyYXkgd2l0aDpcbiAgIC0gYWxsIGVsZW1lbnRzIGxlc3MgdGhhbiBwaXZvdDEgdG8gdGhlIGxlZnQgKHJhbmdlIDEpXG4gICAtIGFsbCBlbGVtZW50cyA+PSBwaXZvdDEgYW5kIDw9IHBpdm90MiBpbiB0aGUgbWlkZGxlIChyYW5nZSAyKVxuICAgLSBhbGwgZWxlbWVudHMgPiBwaXZvdDIgdG8gdGhlIHJpZ2h0IChyYW5nZSAzKVxuICAgLSBpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgZXF1YWwsIHRoZW4gdGhlIG1pZGRsZSByYW5nZSBpcyBzb3J0ZWQsIHNvIGlnbm9yZSBpdFxuICAgLSByZWN1cnNlIGludG8gcmFuZ2UgMSwgMiAoaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIHVuZXF1YWwpLCBhbmQgM1xuICAgLSBkdXJpbmcgcmVjdXJzaW9uIHRoZXJlIGFyZSB0d28gaW5mbGVjdGlvbiBwb2ludHM6XG4gICAtIGlmIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHJhbmdlIGlzIHNtYWxsLCB1c2UgaW5zZXJ0aW9uIHNvcnQgdG8gc29ydCBpdFxuICAgLSBpZiB0aGUgc3RhY2sgZGVwdGggaXMgbGFyZ2UsIHNvcnQgdGhlIHJhbmdlIHdpdGggaGVhcC1zb3J0IHRvIGF2b2lkIG5eMiB3b3JzdC1jYXNlXG4gICAgIGJlaGF2aW9yXG5cbiAgIFNlZSB0aGUgZm9sbG93aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uOlxuICAgLSBcIkR1YWwtUGl2b3QgUXVpY2tzb3J0XCIgYnkgVmxhZGltaXIgWWFyb3NsYXZza2l5LlxuICAgICBBdmFpbGFibGUgYXRcbiAgICAgaHR0cDovL3d3dy5rcmljaGUuY29tLmFyL3Jvb3QvcHJvZ3JhbW1pbmcvc3BhY2VUaW1lQ29tcGxleGl0eS9EdWFsUGl2b3RRdWlja3NvcnQucGRmXG4gICAtIFwiUXVpY2tzb3J0IGlzIE9wdGltYWxcIiBieSBTZWRnZXdpY2sgYW5kIEJlbnRsZXkuXG4gICAgIFNsaWRlcyBhdCBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfnJzL3RhbGtzL1F1aWNrc29ydElzT3B0aW1hbC5wZGZcbiAgIC0gaHR0cDovL3d3dy5zb3J0aW5nLWFsZ29yaXRobXMuY29tL3F1aWNrLXNvcnQtMy13YXkgKilcblxubW9kdWxlIFNvcnQgPSBzdHJ1Y3RcbiAgKCogRm9yIHRoZSBzYWtlIG9mIHNwZWVkIHdlIGNvdWxkIHVzZSB1bnNhZmUgZ2V0L3NldCB0aHJvdWdob3V0LCBidXQgc3BlZWQgdGVzdHMgZG9uJ3RcbiAgICAgc2hvdyBhIHNpZ25pZmljYW50IGltcHJvdmVtZW50LiAqKVxuICBsZXQgZ2V0ID0gZ2V0XG4gIGxldCBzZXQgPSBzZXRcblxuICBsZXQgc3dhcCBhcnIgaSBqID1cbiAgICBsZXQgdG1wID0gZ2V0IGFyciBpIGluXG4gICAgc2V0IGFyciBpIChnZXQgYXJyIGopO1xuICAgIHNldCBhcnIgaiB0bXBcbiAgOztcblxuICBtb2R1bGUgdHlwZSBTb3J0ID0gc2lnXG4gICAgdmFsIHNvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGxlZnQ6aW50ICgqIGxlZnRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiByaWdodDppbnQgKCogcmlnaHRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiB1bml0XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5zZXJ0aW9uX3NvcnQgKilcbiAgbW9kdWxlIEluc2VydGlvbl9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgICBbYXJyXSBpcyBzb3J0ZWQgZnJvbSBbbGVmdF0gdG8gW3BvcyAtIDFdLCBpbmNsdXNpdmUgKilcbiAgICAgIGZvciBwb3MgPSBsZWZ0ICsgMSB0byByaWdodCBkb1xuICAgICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4gaS0xXSBpcyBzb3J0ZWRcbiAgICAgICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uIHBvc10gaXMgc29ydGVkIGFuZCBjb250YWlucyBvbmx5IGVsZW1lbnRzID4gdlxuICAgICAgICAgICAzLiAgYXJyW2ldIG1heSBiZSB0aG91Z2h0IG9mIGFzIGNvbnRhaW5pbmcgdlxuXG4gICAgICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFsbG9jYXRlIGEgY2xvc3VyZSwgYnV0IGlzIGxlZnQgaW4gdGhlIGZvclxuICAgICAgICAgICBsb29wIGZvciB0aGUgcmVhZGFiaWxpdHkgb2YgdGhlIGRvY3VtZW50YXRpb24uICopXG4gICAgICAgIGxldCByZWMgbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaSB2ID1cbiAgICAgICAgICBsZXQgaV9uZXh0ID0gaSAtIDEgaW5cbiAgICAgICAgICBpZiBpX25leHQgPj0gbGVmdCAmJiBjb21wYXJlIChnZXQgYXJyIGlfbmV4dCkgdiA+IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIHNldCBhcnIgaSAoZ2V0IGFyciBpX25leHQpO1xuICAgICAgICAgICAgbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaV9uZXh0IHYpXG4gICAgICAgICAgZWxzZSBpXG4gICAgICAgIGluXG4gICAgICAgIGxldCB2ID0gZ2V0IGFyciBwb3MgaW5cbiAgICAgICAgbGV0IGZpbmFsX3BvcyA9IGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIHBvcyB2IGluXG4gICAgICAgIHNldCBhcnIgZmluYWxfcG9zIHZcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlYXBzb3J0ICopXG4gIG1vZHVsZSBIZWFwX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgcm9vdCdzIGNoaWxkcmVuIGFyZSBib3RoIGVpdGhlciByb290cyBvZiBtYXgtaGVhcHMgb3IgPiByaWdodCAqKVxuICAgIGxldCByZWMgaGVhcGlmeSBhcnIgfmNvbXBhcmUgcm9vdCB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHJlbGF0aXZlX3Jvb3QgPSByb290IC0gbGVmdCBpblxuICAgICAgbGV0IGxlZnRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDEgaW5cbiAgICAgIGxldCByaWdodF9jaGlsZCA9ICgyICogcmVsYXRpdmVfcm9vdCkgKyBsZWZ0ICsgMiBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiBsZWZ0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgbGVmdF9jaGlsZCkgKGdldCBhcnIgcm9vdCkgPiAwXG4gICAgICAgIHRoZW4gbGVmdF9jaGlsZFxuICAgICAgICBlbHNlIHJvb3RcbiAgICAgIGluXG4gICAgICBsZXQgbGFyZ2VzdCA9XG4gICAgICAgIGlmIHJpZ2h0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgcmlnaHRfY2hpbGQpIChnZXQgYXJyIGxhcmdlc3QpID4gMFxuICAgICAgICB0aGVuIHJpZ2h0X2NoaWxkXG4gICAgICAgIGVsc2UgbGFyZ2VzdFxuICAgICAgaW5cbiAgICAgIGlmIGxhcmdlc3QgPD4gcm9vdFxuICAgICAgdGhlbiAoXG4gICAgICAgIHN3YXAgYXJyIHJvb3QgbGFyZ2VzdDtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGFyZ2VzdCB+bGVmdCB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogRWxlbWVudHMgaW4gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhcnJheSBhcmUgYWxyZWFkeSBoZWFwcyBvZiBzaXplIDEuICBXZSBtb3ZlXG4gICAgICAgICB0aHJvdWdoIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSBhcnJheSBmcm9tIGJhY2sgdG8gZnJvbnQgZXhhbWluaW5nIHRoZSBlbGVtZW50IGF0XG4gICAgICAgICBoYW5kLCBhbmQgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkcmVuLCBmaXhpbmcgdGhlIGhlYXAgcHJvcGVydHkgYXMgd2UgZ28uICopXG4gICAgICBmb3IgaSA9IChsZWZ0ICsgcmlnaHQpIC8gMiBkb3dudG8gbGVmdCBkb1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBpIH5sZWZ0IH5yaWdodFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGJ1aWxkX2hlYXAgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodDtcbiAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4uIGldIGlzIGEgbWF4LWhlYXAgSFxuICAgICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uLiByaWdodF0gaXMgc29ydGVkIChjYWxsIGl0IFMpXG4gICAgICAgICAzLiAgZXZlcnkgZWxlbWVudCBvZiBIIGlzIGxlc3MgdGhhbiBldmVyeSBlbGVtZW50IG9mIFMgKilcbiAgICAgIGZvciBpID0gcmlnaHQgZG93bnRvIGxlZnQgKyAxIGRvXG4gICAgICAgIHN3YXAgYXJyIGxlZnQgaTtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGVmdCB+bGVmdCB+cmlnaHQ6KGkgLSAxKVxuICAgICAgZG9uZVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0ICopXG4gIG1vZHVsZSBJbnRyb19zb3J0IDogc2lnXG4gICAgaW5jbHVkZSBTb3J0XG5cbiAgICB2YWwgZml2ZV9lbGVtZW50X3NvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfmNvbXBhcmUgbTEgbTIgbTMgbTQgbTUgPVxuICAgICAgbGV0IGNvbXBhcmVfYW5kX3N3YXAgaSBqID1cbiAgICAgICAgaWYgY29tcGFyZSAoZ2V0IGFyciBpKSAoZ2V0IGFyciBqKSA+IDAgdGhlbiBzd2FwIGFyciBpIGpcbiAgICAgIGluXG4gICAgICAoKiBPcHRpbWFsIDUtZWxlbWVudCBzb3J0aW5nIG5ldHdvcms6XG5cbiAgICAgICAgIHt2XG4gICAgICAgICAgICAxLS1vLS0tLS1vLS0tLS1vLS0tLS0tLS0tLS0tLS0xXG4gICAgICAgICAgICAgICB8ICAgICB8ICAgICB8XG4gICAgICAgICAgICAyLS1vLS0tLS18LS1vLS18LS0tLS1vLS1vLS0tLS0yXG4gICAgICAgICAgICAgICAgICAgICB8ICB8ICB8ICAgICB8ICB8XG4gICAgICAgICAgICAzLS0tLS0tLS1vLS1vLS18LS1vLS18LS1vLS0tLS0zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB8ICB8XG4gICAgICAgICAgICA0LS0tLS1vLS0tLS0tLS1vLS1vLS18LS0tLS1vLS00XG4gICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICB8XG4gICAgICAgICAgICA1LS0tLS1vLS0tLS0tLS0tLS0tLS1vLS0tLS1vLS01XG4gICAgICAgICAgdn0gKilcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTI7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG00IG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG00O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMyBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTU7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNVxuICAgIDs7XG5cbiAgICAoKiBjaG9vc2UgcGl2b3RzIGZvciB0aGUgYXJyYXkgYnkgc29ydGluZyA1IGVsZW1lbnRzIGFuZCBleGFtaW5pbmcgdGhlIGNlbnRlciB0aHJlZVxuICAgICAgIGVsZW1lbnRzLiAgVGhlIGdvYWwgaXMgdG8gY2hvb3NlIHR3byBwaXZvdHMgdGhhdCB3aWxsIGVpdGhlcjpcbiAgICAgICAtIGJyZWFrIHRoZSByYW5nZSB1cCBpbnRvIDMgZXZlbiBwYXJ0aXRpb25zXG4gICAgICAgICBvclxuICAgICAgIC0gZWxpbWluYXRlIGEgY29tbW9ubHkgYXBwZWFyaW5nIGVsZW1lbnQgYnkgc29ydGluZyBpdCBpbnRvIHRoZSBjZW50ZXIgcGFydGl0aW9uXG4gICAgICAgICBieSBpdHNlbGZcbiAgICAgICAgIFRvIHRoaXMgZW5kIHdlIGxvb2sgYXQgdGhlIGNlbnRlciAzIGVsZW1lbnRzIG9mIHRoZSA1IGFuZCByZXR1cm4gcGFpcnMgb2YgZXF1YWxcbiAgICAgICAgIGVsZW1lbnRzIG9yIHRoZSB3aWRlc3QgcmFuZ2UgKilcbiAgICBsZXQgY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBzaXh0aCA9IChyaWdodCAtIGxlZnQpIC8gNiBpblxuICAgICAgbGV0IG0xID0gbGVmdCArIHNpeHRoIGluXG4gICAgICBsZXQgbTIgPSBtMSArIHNpeHRoIGluXG4gICAgICBsZXQgbTMgPSBtMiArIHNpeHRoIGluXG4gICAgICBsZXQgbTQgPSBtMyArIHNpeHRoIGluXG4gICAgICBsZXQgbTUgPSBtNCArIHNpeHRoIGluXG4gICAgICBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfmNvbXBhcmUgbTEgbTIgbTMgbTQgbTU7XG4gICAgICBsZXQgbTJfdmFsID0gZ2V0IGFyciBtMiBpblxuICAgICAgbGV0IG0zX3ZhbCA9IGdldCBhcnIgbTMgaW5cbiAgICAgIGxldCBtNF92YWwgPSBnZXQgYXJyIG00IGluXG4gICAgICBpZiBjb21wYXJlIG0yX3ZhbCBtM192YWwgPSAwXG4gICAgICB0aGVuIG0yX3ZhbCwgbTNfdmFsLCB0cnVlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgbTNfdmFsIG00X3ZhbCA9IDBcbiAgICAgIHRoZW4gbTNfdmFsLCBtNF92YWwsIHRydWVcbiAgICAgIGVsc2UgbTJfdmFsLCBtNF92YWwsIGZhbHNlXG4gICAgOztcblxuICAgIGxldCBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBwaXZvdDEsIHBpdm90MiwgcGl2b3RzX2VxdWFsID0gY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgbGVmdCA8PSBsIDwgciA8PSByaWdodFxuICAgICAgICAgMi4gIGwgPD0gcCA8PSByXG4gICAgICAgICAzLiAgbCA8PSB4IDwgcCAgICAgaW1wbGllcyBhcnJbeF0gPj0gcGl2b3QxXG4gICAgICAgICBhbmQgYXJyW3hdIDw9IHBpdm90MlxuICAgICAgICAgNC4gIGxlZnQgPD0geCA8IGwgIGltcGxpZXMgYXJyW3hdIDwgcGl2b3QxXG4gICAgICAgICA1LiAgciA8IHggPD0gcmlnaHQgaW1wbGllcyBhcnJbeF0gPiBwaXZvdDIgKilcbiAgICAgIGxldCByZWMgbG9vcCBsIHAgciA9XG4gICAgICAgIGxldCBwdiA9IGdldCBhcnIgcCBpblxuICAgICAgICBpZiBjb21wYXJlIHB2IHBpdm90MSA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc3dhcCBhcnIgcCBsO1xuICAgICAgICAgIGNvbnQgKGwgKyAxKSAocCArIDEpIHIpXG4gICAgICAgIGVsc2UgaWYgY29tcGFyZSBwdiBwaXZvdDIgPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIGxvb3AgaW52YXJpYW50czogIHNhbWUgYXMgdGhvc2Ugb2YgdGhlIG91dGVyIGxvb3AgKilcbiAgICAgICAgICBsZXQgcmVjIHNjYW5fYmFja3dhcmRzIHIgPVxuICAgICAgICAgICAgaWYgciA+IHAgJiYgY29tcGFyZSAoZ2V0IGFyciByKSBwaXZvdDIgPiAwIHRoZW4gc2Nhbl9iYWNrd2FyZHMgKHIgLSAxKSBlbHNlIHJcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCByID0gc2Nhbl9iYWNrd2FyZHMgciBpblxuICAgICAgICAgIHN3YXAgYXJyIHIgcDtcbiAgICAgICAgICBjb250IGwgcCAociAtIDEpKVxuICAgICAgICBlbHNlIGNvbnQgbCAocCArIDEpIHJcbiAgICAgIGFuZCBjb250IGwgcCByID0gaWYgcCA+IHIgdGhlbiBsLCByIGVsc2UgbG9vcCBsIHAgciBpblxuICAgICAgbGV0IGwsIHIgPSBjb250IGxlZnQgbGVmdCByaWdodCBpblxuICAgICAgbCwgciwgcGl2b3RzX2VxdWFsXG4gICAgOztcblxuICAgIGxldCByZWMgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGxlbiA9IHJpZ2h0IC0gbGVmdCArIDEgaW5cbiAgICAgICgqIFRoaXMgdGFrZXMgY2FyZSBvZiBzb21lIGVkZ2UgY2FzZXMsIHN1Y2ggYXMgbGVmdCA+IHJpZ2h0IG9yIHZlcnkgc2hvcnQgYXJyYXlzLFxuICAgICAgICAgc2luY2UgSW5zZXJ0aW9uX3NvcnQuc29ydCBoYW5kbGVzIHRoZXNlIGNhc2VzIHByb3Blcmx5LiAgVGh1cyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICBtYWtlIHN1cmUgdGhhdCBsZWZ0IGFuZCByaWdodCBhcmUgdmFsaWQgaW4gcmVjdXJzaXZlIGNhbGxzLiAqKVxuICAgICAgaWYgbGVuIDw9IDMyXG4gICAgICB0aGVuIEluc2VydGlvbl9zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgICAgZWxzZSBpZiBtYXhfZGVwdGggPCAwXG4gICAgICB0aGVuIEhlYXBfc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbWF4X2RlcHRoID0gbWF4X2RlcHRoIC0gMSBpblxuICAgICAgICBsZXQgbCwgciwgbWlkZGxlX3NvcnRlZCA9IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgaW5cbiAgICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ6KGwgLSAxKTtcbiAgICAgICAgaWYgbm90IG1pZGRsZV9zb3J0ZWQgdGhlbiBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OmwgfnJpZ2h0OnI7XG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQ6KHIgKyAxKSB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGhlYXBfc29ydF9zd2l0Y2hfZGVwdGggPVxuICAgICAgICAoKiBXZSBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXQgYSByZWN1cnNpb24gZGVwdGggb2YgMzIuIEdOVSBpbnRyb3NvcnQgdXNlcyAybGcobikuXG4gICAgICAgICAgIFRoZSBleHBlY3RlZCByZWN1cnNpb24gZGVwdGggZm9yIHBlcmZlY3QgMy13YXkgc3BsaXRzIGlzIGxvZ18zKG4pLlxuXG4gICAgICAgICAgIFVzaW5nIDMyIG1lYW5zIGEgYmFsYW5jZWQgMy13YXkgc3BsaXQgd291bGQgd29yayB1cCB0byAzXjMyIGVsZW1lbnRzIChyb3VnaGx5XG4gICAgICAgICAgIDJeNTAgb3IgMTBeMTUpLiBHTlUgcmVhY2hlcyBhIGRlcHRoIG9mIDMyIGF0IDY1NTM2IGVsZW1lbnRzLlxuXG4gICAgICAgICAgIEZvciBzbWFsbCBhcnJheXMsIHRoaXMgbWFrZXMgdXMgbGVzcyBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0LCBidXQgdGhlXG4gICAgICAgICAgIDMyKk4gY29zdCBiZWZvcmUgd2UgZG8gaXMgbm90IHRoYXQgbXVjaC5cblxuICAgICAgICAgICBGb3IgbGFyZ2UgYXJyYXlzLCB0aGlzIG1lYW5zIHdlIGFyZSBtb3JlIGxpa2VseSB0byBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXRcbiAgICAgICAgICAgc29tZSBwb2ludCBpZiB3ZSBnZXQgc29tZSBiYWQgc3BsaXRzIG9yIGlmIHRoZSBhcnJheSBpcyBodWdlLiBCdXQgdGhhdCdzIG9ubHkgYVxuICAgICAgICAgICBjb25zdGFudCBmYWN0b3IgY29zdCBpbiB0aGUgZmluYWwgc3RhZ2VzIG9mIHJlY3Vyc2lvbi5cblxuICAgICAgICAgICBBbGwgaW4gYWxsLCB0aGlzIHNlZW1zIHRvIGJlIGEgc21hbGwgdHJhZGVvZmYgYW5kIGF2b2lkcyBwYXlpbmcgYSBjb3N0IHRvXG4gICAgICAgICAgIGNvbXB1dGUgYSBsb2dhcml0aG0gYXQgdGhlIHN0YXJ0LiAqKVxuICAgICAgICAzMlxuICAgICAgaW5cbiAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGg6aGVhcF9zb3J0X3N3aXRjaF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5sZXQgc29ydCA/cG9zID9sZW4gYXJyIH5jb21wYXJlID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIGFycilcbiAgaW5cbiAgU29ydC5JbnRyb19zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0OnBvcyB+cmlnaHQ6KHBvcyArIGxlbiAtIDEpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IHRcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBpc19zb3J0ZWQgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID4gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPj0gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IG1lcmdlIGExIGEyIH5jb21wYXJlID1cbiAgbGV0IGwxID0gQXJyYXkubGVuZ3RoIGExIGluXG4gIGxldCBsMiA9IEFycmF5Lmxlbmd0aCBhMiBpblxuICBpZiBsMSA9IDBcbiAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbDIgPSAwXG4gIHRoZW4gY29weSBhMVxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTIgMCkgKHVuc2FmZV9nZXQgYTEgKGwxIC0gMSkpID49IDBcbiAgdGhlbiBhcHBlbmQgYTEgYTJcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGExIDApICh1bnNhZmVfZ2V0IGEyIChsMiAtIDEpKSA+IDBcbiAgdGhlbiBhcHBlbmQgYTIgYTFcbiAgZWxzZSAoXG4gICAgbGV0IGxlbiA9IGwxICsgbDIgaW5cbiAgICBsZXQgbWVyZ2VkID0gY3JlYXRlIH5sZW4gKHVuc2FmZV9nZXQgYTEgMCkgaW5cbiAgICBsZXQgYTFfaW5kZXggPSByZWYgMCBpblxuICAgIGxldCBhMl9pbmRleCA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCB1c2VfYTEgPVxuICAgICAgICBpZiBsMSA9ICFhMV9pbmRleFxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgaWYgbDIgPSAhYTJfaW5kZXhcbiAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgIGVsc2UgY29tcGFyZSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCkgPD0gMFxuICAgICAgaW5cbiAgICAgIGlmIHVzZV9hMVxuICAgICAgdGhlbiAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KTtcbiAgICAgICAgYTFfaW5kZXggOj0gIWExX2luZGV4ICsgMSlcbiAgICAgIGVsc2UgKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCk7XG4gICAgICAgIGEyX2luZGV4IDo9ICFhMl9pbmRleCArIDEpXG4gICAgZG9uZTtcbiAgICBtZXJnZWQpXG47O1xuXG5sZXQgY29weV9tYXRyaXggPSBtYXAgfmY6Y29weVxuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuOztcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwIH5mIHQpKVxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcGkgfmYgdCkpXG5cbmxldCByZXZfaW5wbGFjZSB0ID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICB3aGlsZSAhaSA8ICFqIGRvXG4gICAgc3dhcCB0ICFpICFqO1xuICAgIGluY3IgaTtcbiAgICBkZWNyIGpcbiAgZG9uZVxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IHQgPSBjb3B5IHQgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgYSA6OiBsIC0+XG4gICAgbGV0IGxlbiA9IDEgKyBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbiBhIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgICgqIFdlIHN0YXJ0IGF0IFtsZW4gLSAyXSBiZWNhdXNlIHdlIGFscmVhZHkgcHV0IFthXSBhdCBbdC4obGVuIC0gMSldLiAqKVxuICAgIGZvciBpID0gbGVuIC0gMiBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIHQuKGkpIDwtIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgdFxuOztcblxuKCogW29mX2xpc3RfbWFwXSBhbmQgW29mX2xpc3RfcmV2X21hcF0gYXJlIGJhc2VkIG9uIGZ1bmN0aW9ucyBmcm9tIHRoZSBPQ2FtbFxuICAgZGlzdHJpYnV0aW9uLiAqKVxuXG5sZXQgb2ZfbGlzdF9tYXAgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaGQpO1xuICAgICAgICBmaWxsIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgMSB0bFxuOztcblxubGV0IG9mX2xpc3RfbWFwaSB4cyB+ZiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgaGQgOjogdGwgLT5cbiAgICBsZXQgYSA9IGNyZWF0ZSB+bGVuOigxICsgTGlzdC5sZW5ndGggdGwpIChmIDAgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGEgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaSBoZCk7XG4gICAgICAgIGZpbGwgYSAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIGEgMSB0bFxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcCB4cyB+ZiA9XG4gIGxldCB0ID0gb2ZfbGlzdF9tYXAgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcGkgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwaSB4cyB+ZiBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByID0gcmVmIFt8fF0gaW5cbiAgbGV0IGsgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IHQgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBhIC0+XG4gICAgICBpZiAhayA9IDAgdGhlbiByIDo9IGNyZWF0ZSB+bGVuOihsZW5ndGggdCkgYTtcbiAgICAgIHVuc2FmZV9zZXQgIXIgIWsgYTtcbiAgICAgIGluY3Iga1xuICBkb25lO1xuICBpZiAhayA9IGxlbmd0aCB0IHRoZW4gIXIgZWxzZSBpZiAhayA+IDAgdGhlbiBzdWIgfnBvczowIH5sZW46IWsgIXIgZWxzZSBbfHxdXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIF9pIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9vcHQgdCA9IGZpbHRlcl9tYXAgdCB+ZjpGbi5pZFxuXG5sZXQgcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjIgPVxuICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIHQxIHQyID1cbiAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yXG47O1xuXG5sZXQgaXRlcjJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5pdGVyMl9leG5cIiB0MSB0MjtcbiAgaXRlcmkgdDEgfmY6KGZ1biBpIHgxIC0+IGYgeDEgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5Lm1hcDJfZXhuXCIgdDEgdDI7XG4gIGluaXQgKGxlbmd0aCB0MSkgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgZm9sZDJfZXhuIHQxIHQyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb2xkMl9leG5cIiB0MSB0MjtcbiAgZm9sZGkgdDEgfmluaXQgfmY6KGZ1biBpIGFjIHggLT4gZiBhYyB4ICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxubGV0IGZpbHRlcmkgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxuXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAhaSAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKVxuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHMyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZXhpc3RzMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvcl9hbGwyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPSBsZW5ndGggdDEgPSBsZW5ndGggdDIgJiYgZm9yX2FsbDJfZXhuIHQxIHQyIH5mOmVxdWFsXG5cblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBmaW5kaV9pbnRlcm5hbCB0IH5mIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBpZl9ub3RfZm91bmQgKClcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGYgIWkgdmFsdWVcbiAgICAgIHRoZW4gKFxuICAgICAgICB2YWx1ZV9mb3VuZCA6PSB2YWx1ZTtcbiAgICAgICAgZm91bmQgOj0gdHJ1ZSlcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiAhZm91bmQgdGhlbiBpZl9mb3VuZCB+aTohaSB+dmFsdWU6IXZhbHVlX2ZvdW5kIGVsc2UgaWZfbm90X2ZvdW5kICgpKVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBTb21lIChpLCB2YWx1ZSkpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpXG47O1xuXG5sZXQgZmluZGlfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBpLCB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZGlfZXhuOiBub3QgZm91bmRcIikpKVxuOztcblxubGV0IGZpbmRfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZjooZnVuIF9pIHggLT4gZiB4KVxuICAgIH5pZl9mb3VuZDooZnVuIH5pOl8gfnZhbHVlIC0+IHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPSBPcHRpb24ubWFwIChmaW5kaSB0IH5mOihmdW4gX2kgeCAtPiBmIHgpKSB+ZjooZnVuIChfaSwgeCkgLT4geClcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgIWkgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA8PSAxXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVzdWx0ID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgaSA9IHJlZiAxIGluXG4gICAgbGV0IHByZXYgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGN1ciA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZXF1YWwgY3VyICFwcmV2XG4gICAgICB0aGVuIChcbiAgICAgICAgcmVzdWx0IDo9IFNvbWUgKCFwcmV2LCBjdXIpO1xuICAgICAgICBpIDo9IG4pXG4gICAgICBlbHNlIChcbiAgICAgICAgcHJldiA6PSBjdXI7XG4gICAgICAgIGluY3IgaSlcbiAgICBkb25lO1xuICAgICFyZXN1bHQpXG47O1xuXG5sZXQgcmVkdWNlIHQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICAgIGRvbmU7XG4gICAgU29tZSAhcilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHQgfmYgPVxuICBtYXRjaCByZWR1Y2UgdCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcGVybXV0ZSA9IEFycmF5X3Blcm11dGUucGVybXV0ZVxuXG5sZXQgcmFuZG9tX2VsZW1lbnRfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGFycmF5XCJcbiAgZWxzZSB0LihSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAobGVuZ3RoIHQpKVxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICB0cnkgU29tZSAocmFuZG9tX2VsZW1lbnRfZXhuIH5yYW5kb21fc3RhdGUgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHppcCB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDIgdGhlbiBOb25lIGVsc2UgU29tZSAobWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpKVxuOztcblxubGV0IHppcF9leG4gdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyXG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS56aXBfZXhuXCJcbiAgZWxzZSBtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4Milcbjs7XG5cbmxldCB1bnppcCB0ID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuID0gMFxuICB0aGVuIFt8fF0sIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHgsIHkgPSB0LigwKSBpblxuICAgIGxldCByZXMxID0gY3JlYXRlIH5sZW46biB4IGluXG4gICAgbGV0IHJlczIgPSBjcmVhdGUgfmxlbjpuIHkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCB4LCB5ID0gdC4oaSkgaW5cbiAgICAgIHJlczEuKGkpIDwtIHg7XG4gICAgICByZXMyLihpKSA8LSB5XG4gICAgZG9uZTtcbiAgICByZXMxLCByZXMyKVxuOztcblxubGV0IHNvcnRlZF9jb3B5IHQgfmNvbXBhcmUgPVxuICBsZXQgdDEgPSBjb3B5IHQgaW5cbiAgc29ydCB0MSB+Y29tcGFyZTtcbiAgdDFcbjs7XG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBsZXQgYm90aCA9IG1hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIEVpdGhlci5GaXJzdCB4IGVsc2UgRWl0aGVyLlNlY29uZCB4KSBpblxuICBsZXQgdHJ1ZXMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgeCAtPiBTb21lIHhcbiAgICAgIHwgU2Vjb25kIF8gLT4gTm9uZSlcbiAgaW5cbiAgbGV0IGZhbHNlcyA9XG4gICAgZmlsdGVyX21hcCBib3RoIH5mOihmdW5jdGlvblxuICAgICAgfCBGaXJzdCBfIC0+IE5vbmVcbiAgICAgIHwgU2Vjb25kIHggLT4gU29tZSB4KVxuICBpblxuICB0cnVlcywgZmFsc2VzXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biBfaSB4IC0+IGYgeClcbmxldCBsYXN0IHQgPSB0LihsZW5ndGggdCAtIDEpXG5cbigqIENvbnZlcnQgdG8gYSBzZXF1ZW5jZSBidXQgZG9lcyBub3QgYXR0ZW1wdCB0byBwcm90ZWN0IGFnYWluc3QgbW9kaWZpY2F0aW9uXG4gICBpbiB0aGUgYXJyYXkuICopXG5sZXQgdG9fc2VxdWVuY2VfbXV0YWJsZSB0ID1cbiAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT5cbiAgICBpZiBpID49IGxlbmd0aCB0IHRoZW4gU2VxdWVuY2UuU3RlcC5Eb25lIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAodC4oaSksIGkgKyAxKSlcbjs7XG5cbmxldCB0b19zZXF1ZW5jZSB0ID0gdG9fc2VxdWVuY2VfbXV0YWJsZSAoY29weSB0KVxuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgdDEgdDIgPVxuICBpZiBpc19lbXB0eSB0MSB8fCBpc19lbXB0eSB0MlxuICB0aGVuIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gICAgbGV0IG4yID0gbGVuZ3RoIHQyIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbjoobjEgKiBuMikgKHQxLigwKSwgdDIuKDApKSBpblxuICAgIGxldCByID0gcmVmIDAgaW5cbiAgICBmb3IgaTEgPSAwIHRvIG4xIC0gMSBkb1xuICAgICAgZm9yIGkyID0gMCB0byBuMiAtIDEgZG9cbiAgICAgICAgdC4oIXIpIDwtIHQxLihpMSksIHQyLihpMik7XG4gICAgICAgIGluY3IgclxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgdClcbjs7XG5cbmxldCB0cmFuc3Bvc2UgdHQgPVxuICBpZiBsZW5ndGggdHQgPSAwXG4gIHRoZW4gU29tZSBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB3aWR0aCA9IGxlbmd0aCB0dCBpblxuICAgIGxldCBkZXB0aCA9IGxlbmd0aCB0dC4oMCkgaW5cbiAgICBpZiBleGlzdHMgdHQgfmY6KGZ1biB0IC0+IGxlbmd0aCB0IDw+IGRlcHRoKVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgU29tZSAoaW5pdCBkZXB0aCB+ZjooZnVuIGQgLT4gaW5pdCB3aWR0aCB+ZjooZnVuIHcgLT4gdHQuKHcpLihkKSkpKSlcbjs7XG5cbmxldCB0cmFuc3Bvc2VfZXhuIHR0ID1cbiAgbWF0Y2ggdHJhbnNwb3NlIHR0IHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkudHJhbnNwb3NlX2V4blwiXG4gIHwgU29tZSB0dCcgLT4gdHQnXG47O1xuXG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGdldCA9IGdldFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgZW5kKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiB0ID1cbiAgICAgIGlmIGxlbiA9IDBcbiAgICAgIHRoZW4gW3x8XVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgICAgY3JlYXRlIH5sZW4gdC4oMCkpXG4gICAgOztcblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gaXRlciB0IH5mOmludmFyaWFudF9hXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBTb3J0ID0gU29ydFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIG1haW50YWluIHRoZSBwcm9wZXJ0eSB0aGF0IGFsbCB2YWx1ZXMgb2YgdHlwZSBbdF0gZG8gbm90IGhhdmUgdGhlIHRhZ1xuICAgW2RvdWJsZV9hcnJheV90YWddLiAgU29tZSBmdW5jdGlvbnMgYmVsb3cgYXNzdW1lIHRoaXMgaW4gb3JkZXIgdG8gYXZvaWQgdGVzdGluZyB0aGVcbiAgIHRhZywgYW5kIHdpbGwgc2VnZmF1bHQgaWYgdGhpcyBwcm9wZXJ0eSBkb2Vzbid0IGhvbGQuICopXG50eXBlIHQgPSBDYW1sLk9iai50IGFycmF5XG5cbmxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAoQ2FtbC5PYmoudGFnIChDYW1sLk9iai5yZXByIHQpIDw+IENhbWwuT2JqLmRvdWJsZV9hcnJheV90YWcpXG5sZXQgbGVuZ3RoID0gQXJyYXkubGVuZ3RoICgqIHdvdWxkIGNoZWNrIGZvciBmbG9hdCBhcnJheXMgaW4gMzIgYml0LCBidXQgd2hhdGV2ZXIgKilcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgU2V4cC5BdG9tXG4gICAgKFN0cmluZy5jb25jYXQgfnNlcDpcIlwiIFsgXCI8T2JqX2FycmF5LnQgb2YgbGVuZ3RoIFwiOyBJbnQudG9fc3RyaW5nIChsZW5ndGggdCk7IFwiPlwiIF0pXG47O1xuXG5sZXQgemVyb19vYmogPSBDYW1sLk9iai5yZXByICgwIDogaW50KVxuXG4oKiBXZSBjYWxsIFtBcnJheS5jcmVhdGVdIHdpdGggYSB2YWx1ZSB0aGF0IGlzIG5vdCBhIGZsb2F0IHNvIHRoYXQgdGhlIGFycmF5IGRvZXNuJ3QgZ2V0XG4gICB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICopXG5sZXQgY3JlYXRlX3plcm8gfmxlbiA9IEFycmF5LmNyZWF0ZSB+bGVuIHplcm9fb2JqXG5sZXQgZW1wdHkgPSBbfHxdXG5cbnR5cGUgbm90X2FfZmxvYXQgPVxuICB8IE5vdF9hX2Zsb2F0XzBcbiAgfCBOb3RfYV9mbG9hdF8xIG9mIGludFxuXG5sZXQgX25vdF9hX2Zsb2F0XzAgPSBOb3RfYV9mbG9hdF8wXG5sZXQgX25vdF9hX2Zsb2F0XzEgPSBOb3RfYV9mbG9hdF8xIDQyXG5cbmxldCBnZXQgdCBpID1cbiAgKCogTWFrZSB0aGUgY29tcGlsZXIgYmVsaWV2ZSBbdF0gaXMgYW4gYXJyYXkgbm90IGNvbnRhaW5pbmcgZmxvYXRzIHNvIGl0IGRvZXMgbm90IGNoZWNrXG4gICAgIGlmIFt0XSBpcyB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICBJdCBpcyBOT1Qgb2sgdG8gdXNlIFtpbnQgYXJyYXldIHNpbmNlIChpZlxuICAgICB0aGlzIGZ1bmN0aW9uIGlzIGlubGluZWQgYW5kIHRoZSBhcnJheSBjb250YWlucyBpbi1oZWFwIGJveGVkIHZhbHVlcykgd3JvbmcgcmVnaXN0ZXJcbiAgICAgdHlwaW5nIG1heSByZXN1bHQsIGxlYWRpbmcgdG8gYSBmYWlsdXJlIHRvIHJlZ2lzdGVyIG5lY2Vzc2FyeSBHQyByb290cy4gKilcbiAgQ2FtbC5PYmoucmVwciAoKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkuKGkpIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9nZXQgdCBpID1cbiAgKCogTWFrZSB0aGUgY29tcGlsZXIgYmVsaWV2ZSBbdF0gaXMgYW4gYXJyYXkgbm90IGNvbnRhaW5pbmcgZmxvYXRzIHNvIGl0IGRvZXMgbm90IGNoZWNrXG4gICAgIGlmIFt0XSBpcyB0YWdnZWQgd2l0aCBbRG91YmxlX2FycmF5X3RhZ10uICopXG4gIENhbWwuT2JqLnJlcHJcbiAgICAoQXJyYXkudW5zYWZlX2dldCAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KSBpIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqID1cbiAgKCogU2FtZSBjb21tZW50IGFzIFt1bnNhZmVfZ2V0XS4gU3lzLm9wYXF1ZV9pZGVudGl0eSBwcmV2ZW50cyB0aGUgY29tcGlsZXIgZnJvbVxuICAgICBwb3RlbnRpYWxseSB3cm9uZ2x5IGd1ZXNzaW5nIHRoZSB0eXBlIG9mIHRoZSBhcnJheSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LCB0aGF0XG4gICAgIGlzIHByZXZlbnQgdGhlIGltcGxpY2F0aW9uOiAoT2JqLnRhZyBvYmogPSBPYmouZG91YmxlX3RhZykgPT4gKE9iai50YWcgdCA9XG4gICAgIE9iai5kb3VibGVfYXJyYXlfdGFnKSB3aGljaCBmbGFtYmRhIGhhcyB0cmllZCBpbiB0aGUgcGFzdCAoYXQgbGVhc3QgdGhhdCdzIGFzc3VtaW5nXG4gICAgIHRoZSBjb21waWxlciByZXNwZWN0cyBTeXMub3BhcXVlX2lkZW50aXR5LCB3aGljaCBpcyBub3QgYWx3YXlzIHRoZSBjYXNlKS4gKilcbiAgQXJyYXkudW5zYWZlX3NldFxuICAgIChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpXG4gICAgaVxuICAgIChDYW1sLk9iai5vYmogKFN5cy5vcGFxdWVfaWRlbnRpdHkgb2JqKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBzZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqID1cbiAgKCogc2FtZSBhcyB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgYnV0IHNhZmUgKilcbiAgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkuKGkpXG4gIDwtIChDYW1sLk9iai5vYmogKFN5cy5vcGFxdWVfaWRlbnRpdHkgb2JqKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBpbnQgPVxuICAoKiBUaGlzIHNraXBzIFtjYW1sX21vZGlmeV0sIHdoaWNoIGlzIE9LIGlmIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZhbHVlcyBhcmUgaW50ZWdlcnMuICopXG4gIEFycmF5LnVuc2FmZV9zZXQgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBpbnQgYXJyYXkpIGkgKFN5cy5vcGFxdWVfaWRlbnRpdHkgaW50KVxuOztcblxuKCogRm9yIFtzZXRdIGFuZCBbdW5zYWZlX3NldF0sIGlmIGEgcG9pbnRlciBpcyBpbnZvbHZlZCwgd2UgZmlyc3QgZG8gYSBwaHlzaWNhbC1lcXVhbGl0eVxuICAgdGVzdCB0byBzZWUgaWYgdGhlIHBvaW50ZXIgaXMgY2hhbmdpbmcuICBJZiBub3QsIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhlIFtzZXRdLCB3aGljaFxuICAgc2F2ZXMgYSBjYWxsIHRvIFtjYW1sX21vZGlmeV0uICBXZSB0aGluayB0aGlzIHBoeXNpY2FsLWVxdWFsaXR5IHRlc3QgaXMgd29ydGggaXRcbiAgIGJlY2F1c2UgaXQgaXMgdmVyeSBjaGVhcCAoYm90aCB2YWx1ZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlIGZyb20gdGhlIFtpc19pbnRdIHRlc3QpXG4gICBhbmQgYmVjYXVzZSBbY2FtbF9tb2RpZnldIGlzIGV4cGVuc2l2ZS4gKilcblxubGV0IHNldCB0IGkgb2JqID1cbiAgKCogV2UgdXNlIFtnZXRdIGZpcnN0IGJ1dCB0aGVuIHdlIHVzZSBbQXJyYXkudW5zYWZlX3NldF0gc2luY2Ugd2Uga25vdyB0aGF0IFtpXSBpc1xuICAgICB2YWxpZC4gKilcbiAgbGV0IG9sZF9vYmogPSBnZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqICYmIENhbWwuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoQ2FtbC5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldCB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqICYmIENhbWwuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoQ2FtbC5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHN3YXAgdCBpIGogPVxuICBsZXQgYSA9IGdldCB0IGkgaW5cbiAgbGV0IGIgPSBnZXQgdCBqIGluXG4gIHVuc2FmZV9zZXQgdCBpIGI7XG4gIHVuc2FmZV9zZXQgdCBqIGFcbjs7XG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgKCogSWYgd2UgY2FuLCB1c2UgW0FycmF5LmNyZWF0ZV0gZGlyZWN0bHkuICopXG4gIGlmIENhbWwuT2JqLnRhZyB4IDw+IENhbWwuT2JqLmRvdWJsZV90YWdcbiAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiB4XG4gIGVsc2UgKFxuICAgICgqIE90aGVyd2lzZSB1c2UgW2NyZWF0ZV96ZXJvXSBhbmQgc2V0IHRoZSBjb250ZW50cyAqKVxuICAgIGxldCB0ID0gY3JlYXRlX3plcm8gfmxlbiBpblxuICAgIGxldCB4ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSB4IGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeFxuICAgIGRvbmU7XG4gICAgdClcbjs7XG5cbmxldCBzaW5nbGV0b24gb2JqID0gY3JlYXRlIH5sZW46MSBvYmpcblxuKCogUHJlLWNvbmRpdGlvbjogdC4oaSkgaXMgYW4gaW50ZWdlci4gKilcbmxldCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIG9iaiA9XG4gIGlmIENhbWwuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoQ2FtbC5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZVxuICAgICgqIFt0LihpKV0gaXMgYW4gaW50ZWdlciBhbmQgW29ial0gaXMgbm90LCBzbyB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBpZiB0aGV5IGFyZVxuICAgICAgIGVxdWFsLiAqKVxuICAgIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXQgdW5zYWZlX3NldF9pbnQgdCBpIGludCA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBpbnRcbiAgZWxzZSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIGludClcbjs7XG5cbmxldCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciB0IGkgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIG5vdCAoQ2FtbC5PYmouaXNfaW50IG9sZF9vYmopIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciAwKVxuOztcblxuKCoqIFt1bnNhZmVfYmxpdF0gaXMgbGlrZSBbQXJyYXkuYmxpdF0sIGV4Y2VwdCBpdCB1c2VzIG91ciBvd24gZm9yLWxvb3AgdG8gYXZvaWRcbiAgICBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlLiAgSXRzIHBlcmZvcm1hbmNlIGlzIHN0aWxsIG5vdCBjb21wYXJhYmxlIHRvIGEgbWVtY3B5LiAqKVxubGV0IHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgKCogV2hlbiBbcGh5c19lcXVhbCBzcmMgZHN0XSwgd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIFtkc3RfcG9zIDwgc3JjX3Bvc10gYW5kIGhhdmUgdGhlXG4gICAgIGZvciBsb29wIGdvIGluIHRoZSByaWdodCBkaXJlY3Rpb24gc28gdGhhdCB3ZSBkb24ndCBvdmVyd3JpdGUgZGF0YSB0aGF0IHdlIHN0aWxsIG5lZWRcbiAgICAgdG8gcmVhZC4gIFdoZW4gW25vdCAocGh5c19lcXVhbCBzcmMgZHN0KV0sIGRvaW5nIHRoaXMgaXMgaGFybWxlc3MuICBGcm9tIGFcbiAgICAgbWVtb3J5LXBlcmZvcm1hbmNlIHBlcnNwZWN0aXZlLCBpdCBkb2Vzbid0IG1hdHRlciB3aGV0aGVyIG9uZSBsb29wcyB1cCBvciBkb3duLlxuICAgICBDb25zdGFudC1zdHJpZGUgYWNjZXNzLCBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzaG91bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgKGF0IGxlYXN0IG9uXG4gICAgIGFuIGludGVsIGk3KS4gIFNvLCB3ZSBkb24ndCBkbyBhIGNoZWNrIGZvciBbcGh5c19lcXVhbCBzcmMgZHN0XSBhbmQgYWx3YXlzIGxvb3AgdXAgaW5cbiAgICAgdGhhdCBjYXNlLiAqKVxuICBpZiBkc3RfcG9zIDwgc3JjX3Bvc1xuICB0aGVuXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkc3RfcG9zICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzcmNfcG9zICsgaSkpXG4gICAgZG9uZVxuICBlbHNlXG4gICAgZm9yIGkgPSBsZW4gLSAxIGRvd250byAwIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbjs7XG5cbmluY2x1ZGUgQmxpdC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZV96ZXJvXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZV96ZXJvIH5sZW46KGxlbmd0aCBzcmMpIGluXG4gIGJsaXRvIH5zcmMgfmRzdCAoKTtcbiAgZHN0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFdBUk5JTkc6XG4gICBXZSB1c2Ugbm9uLW1lbW9yeS1zYWZlIHRoaW5ncyB0aHJvdWdob3V0IHRoZSBbVHJ1c3RlZF0gbW9kdWxlLlxuICAgTW9zdCBvZiBpdCBpcyBvbmx5IHNhZmUgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgdHlwZSBzaWduYXR1cmUgKGUuZy4gZXhwb3NpbmdcbiAgIFt2YWwgY29weSA6ICdhIHQgLT4gJ2IgdF0gd291bGQgYmUgYSBiaWcgbWlzdGFrZSkuICopXG5tb2R1bGUgVHJ1c3RlZCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgZW1wdHkgOiAnYSB0XG4gIHZhbCB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgOiBsZW46aW50IC0+ICdhIHRcbiAgdmFsIGNyZWF0ZV9vYmpfYXJyYXkgOiBsZW46aW50IC0+ICdhIHRcbiAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2EgdFxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHNldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHN3YXAgOiBfIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHVuc2FmZV9zZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgQmxpdC5ibGl0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciA6IF8gdCAtPiBpbnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IE9ial9hcnJheS50XG5cbiAgbGV0IGVtcHR5ID0gT2JqX2FycmF5LmVtcHR5XG4gIGxldCB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGVfb2JqX2FycmF5IH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlIH5sZW4geCA9IE9ial9hcnJheS5jcmVhdGUgfmxlbiAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgc2luZ2xldG9uIHggPSBPYmpfYXJyYXkuc2luZ2xldG9uIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCBzd2FwIHQgaSBqID0gT2JqX2FycmF5LnN3YXAgdCBpIGpcbiAgbGV0IGdldCBhcnIgaSA9IENhbWwuT2JqLm9iaiAoT2JqX2FycmF5LmdldCBhcnIgaSlcbiAgbGV0IHNldCBhcnIgaSB4ID0gT2JqX2FycmF5LnNldCBhcnIgaSAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2dldCBhcnIgaSA9IENhbWwuT2JqLm9iaiAoT2JqX2FycmF5LnVuc2FmZV9nZXQgYXJyIGkpXG4gIGxldCB1bnNhZmVfc2V0IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldCBhcnIgaSAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX3NldF9pbnQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0X2ludCBhcnIgaSB4XG5cbiAgbGV0IHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeFxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCBsZW5ndGggPSBPYmpfYXJyYXkubGVuZ3RoXG4gIGxldCB1bnNhZmVfYmxpdCA9IE9ial9hcnJheS51bnNhZmVfYmxpdFxuICBsZXQgY29weSA9IE9ial9hcnJheS5jb3B5XG5cbiAgbGV0IHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPSBPYmpfYXJyYXkuc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciA9IE9ial9hcnJheS51bnNhZmVfY2xlYXJfaWZfcG9pbnRlclxuZW5kXG5cbmluY2x1ZGUgVHJ1c3RlZFxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKENhbWwuT2JqLnRhZyAoQ2FtbC5PYmoucmVwciB0KSA8PiBDYW1sLk9iai5kb3VibGVfYXJyYXlfdGFnKVxuXG5sZXQgaW5pdCBsIH5mID1cbiAgaWYgbCA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlVuaWZvcm1fYXJyYXkuaW5pdFwiXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjpsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgZG9uZTtcbiAgICByZXMpXG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyID0gaW5pdCB+ZjooQXJyYXkudW5zYWZlX2dldCBhcnIpIChBcnJheS5sZW5ndGggYXJyKVxubGV0IG1hcCBhIH5mID0gaW5pdCB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpXG5sZXQgbWFwaSBhIH5mID0gaW5pdCB+ZjooZnVuIGkgLT4gZiBpICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSlcblxubGV0IGl0ZXIgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGZvbGRpIGEgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCB0b19saXN0IHQgPSBMaXN0LmluaXQgfmY6KGdldCB0KSAobGVuZ3RoIHQpXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSB4IC0+IHNldCByZXMgaSB4KTtcbiAgcmVzXG47O1xuXG4oKiBJdCBpcyBub3Qgc2FmZSBmb3IgW3RvX2FycmF5XSB0byBiZSB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYmVjYXVzZSB3ZSBoYXZlIGNvZGUgdGhhdFxuICAgcmVsaWVzIG9uIFtmbG9hdCBhcnJheV1zIGJlaW5nIHVuYm94ZWQsIGZvciBleGFtcGxlIGluIFtiaW5fd3JpdGVfYXJyYXldLiAqKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiBpID1cbiAgICBpZiBpIDwgMCB0aGVuIGZhbHNlIGVsc2UgZiAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCB+ZiAoaSAtIDEpXG4gIGluXG4gIGxvb3AgdCB+ZiAobGVuZ3RoIHQgLSAxKVxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IH5mIGkgPSBpZiBpIDwgMCB0aGVuIHRydWUgZWxzZSBmICh1bnNhZmVfZ2V0IHQgaSkgJiYgbG9vcCB0IH5mIChpIC0gMSkgaW5cbiAgbG9vcCB0IH5mIChsZW5ndGggdCAtIDEpXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQxIGluXG4gIGlmIGxlbmd0aCB0MiA8PiBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDJfZXhuXCI7XG4gIGluaXQgbGVuIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKGdyYW1tYXIgOiBlbHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogZWx0IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChBcnJheS50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxuaW5jbHVkZVxuICBTZXhwYWJsZS5PZl9zZXhwYWJsZTFcbiAgICAoQXJyYXkpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHRvX3NleHBhYmxlID0gdG9fYXJyYXlcbiAgICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX2FycmF5XG4gICAgZW5kKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiB0ID1cbiAgICAgIGlmIGxlbiA9IDBcbiAgICAgIHRoZW4gZW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICAgIGNyZWF0ZSB+bGVuIChnZXQgdCAwKSlcbiAgICA7O1xuXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBwcHhfY29tcGFyZSBbY29tcGFyZV9hcnJheV0gYnV0IHVzZXMgb3VyIFt1bnNhZmVfZ2V0XSBhbmQgW2xlbmd0aF0uICopXG5sZXQgY29tcGFyZSBjb21wYXJlX2VsdCBhIGIgPVxuICBpZiBwaHlzX2VxdWFsIGEgYlxuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbGV0IGxlbl9hID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGVuX2IgPSBsZW5ndGggYiBpblxuICAgIGxldCByZXQgPSBjb21wYXJlIGxlbl9hIGxlbl9iIGluXG4gICAgaWYgcmV0IDw+IDBcbiAgICB0aGVuIHJldFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgdGhlbiAwXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsID0gdW5zYWZlX2dldCBhIGlcbiAgICAgICAgICBhbmQgciA9IHVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgbG9vcCAoaSArIDEpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgMCkpXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgY2VpbCA9IENhbWwuY2VpbFxubGV0IGZsb29yID0gQ2FtbC5mbG9vclxubGV0IG1vZF9mbG9hdCA9IENhbWwubW9kX2Zsb2F0XG5sZXQgbW9kZiA9IENhbWwubW9kZlxubGV0IGZsb2F0X29mX3N0cmluZyA9IENhbWwuZmxvYXRfb2Zfc3RyaW5nXG5sZXQgbmFuID0gQ2FtbC5uYW5cbmxldCBpbmZpbml0eSA9IENhbWwuaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBDYW1sLm5lZ19pbmZpbml0eVxubGV0IG1heF9maW5pdGVfdmFsdWUgPSBDYW1sLm1heF9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBDYW1sLmVwc2lsb25fZmxvYXRcbmxldCBjbGFzc2lmeV9mbG9hdCA9IENhbWwuY2xhc3NpZnlfZmxvYXRcbmxldCBhYnNfZmxvYXQgPSBDYW1sLmFic19mbG9hdFxubGV0IGlzX2ludGVnZXIgPSBDYW1sLkZsb2F0LmlzX2ludGVnZXJcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxuXG5sZXQgKCAlLiApIGEgYiA9XG4gICgqIFJhaXNlIGluIGNhc2Ugb2YgYSBuZWdhdGl2ZSBtb2R1bHVzLCBhcyBkb2VzIEludC4oICUgKS4gKilcbiAgaWYgYiA8IDAuXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIiVmICUlICVmIGluIGZsb2F0MC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIiBhIGIgKCk7XG4gIGxldCBtID0gQ2FtbC5tb2RfZmxvYXQgYSBiIGluXG4gICgqIFByb2R1Y2UgYSBub24tbmVnYXRpdmUgcmVzdWx0IGluIGFuYWxvZ3kgd2l0aCBJbnQuKCAlICkuICopXG4gIGlmIG0gPCAwLiB0aGVuIG0gKy4gYiBlbHNlIG1cbjs7XG5cbigqIFRoZSBiaXRzIG9mIElOUklBJ3MgW1BlcnZhc2l2ZXNdIHRoYXQgd2UganVzdCB3YW50IHRvIGV4cG9zZSBpbiBbRmxvYXRdLiBNb3N0IGFyZVxuICAgYWxyZWFkeSBkZXByZWNhdGVkIGluIFtQZXJ2YXNpdmVzXSwgYW5kIGV2ZW50dWFsbHkgYWxsIG9mIHRoZW0gc2hvdWxkIGJlLiAqKVxuaW5jbHVkZSAoXG4gIENhbWwgOlxuICBzaWdcbiAgICBleHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcblxuICAgIGV4dGVybmFsIGxkZXhwXG4gICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgICAgLT4gKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgID0gXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICBlbmQpXG5cbigqIFdlIG5lZWQgdGhpcyBpbmRpcmVjdGlvbiBiZWNhdXNlIHRoZXNlIGFyZSBleHBvc2VkIGFzIFwidmFsXCIgaW5zdGVhZCBvZiBcImV4dGVybmFsXCIgKilcbmxldCBmcmV4cCA9IGZyZXhwXG5sZXQgbGRleHAgPSBsZGV4cFxubGV0IGlzX25hbiB4ID0gKHggOiBmbG9hdCkgPD4geFxuXG4oKiBBbiBvcmRlci1wcmVzZXJ2aW5nIGJpamVjdGlvbiBiZXR3ZWVuIGFsbCBmbG9hdHMgZXhjZXB0IGZvciBOYU5zLCBhbmQgOTkuOTUlIG9mXG4gICBpbnQ2NHMuXG5cbiAgIE5vdGUgd2UgZG9uJ3QgZGlzdGluZ3Vpc2ggMC4gYW5kIC0wLiBhcyBzZXBhcmF0ZSB2YWx1ZXMgaGVyZSwgdGhleSBib3RoIG1hcCB0byAwTCwgd2hpY2hcbiAgIG1hcHMgYmFjayB0byAwLlxuXG4gICBUaGlzIHNob3VsZCB3b3JrIGJvdGggb24gbGl0dGxlLWVuZGlhbiBhbmQgaGlnaC1lbmRpYW4gQ1BVcy4gIFdpa2lwZWRpYSBzYXlzOiBcIm9uXG4gICBtb2Rlcm4gc3RhbmRhcmQgY29tcHV0ZXJzIChpLmUuLCBpbXBsZW1lbnRpbmcgSUVFRSA3NTQpLCBvbmUgbWF5IGluIHByYWN0aWNlIHNhZmVseVxuICAgYXNzdW1lIHRoYXQgdGhlIGVuZGlhbm5lc3MgaXMgdGhlIHNhbWUgZm9yIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYXMgZm9yIGludGVnZXJzXCJcbiAgIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VuZGlhbm5lc3MjRmxvYXRpbmctcG9pbnRfYW5kX2VuZGlhbm5lc3MpLlxuKilcbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0ID1cbiAgaWYgaXNfbmFuIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gKCogYWxzbyBpbmNsdWRlcyAtMC4gKilcbiAgICBTb21lIDBMXG4gIGVsc2UgaWYgdCA+IDAuXG4gIHRoZW4gU29tZSAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQpXG4gIGVsc2UgU29tZSAoQ2FtbC5JbnQ2NC5uZWcgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCAoLS50KSkpXG47O1xuXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIHggPSBPcHRpb24udmFsdWVfZXhuICh0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4KVxuXG5sZXQgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXIgeCA9XG4gIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgeCAwTFxuICB0aGVuIENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyB4XG4gIGVsc2Ugfi0uKENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyAoQ2FtbC5JbnQ2NC5uZWcgeCkpXG47O1xuXG5sZXQgb25lX3VscCBkaXIgdCA9XG4gIG1hdGNoIHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgd2l0aFxuICB8IE5vbmUgLT4gQ2FtbC5uYW5cbiAgfCBTb21lIHggLT5cbiAgICBvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlclxuICAgICAgKENhbWwuSW50NjQuYWRkXG4gICAgICAgICB4XG4gICAgICAgICAobWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICB8IGBVcCAtPiAxTFxuICAgICAgICAgIHwgYERvd24gLT4gLTFMKSlcbjs7XG5cbigqIFt1cHBlcl9ib3VuZF9mb3JfaW50XSBhbmQgW2xvd2VyX2JvdW5kX2Zvcl9pbnRdIGFyZSBmb3IgY2FsY3VsYXRpbmcgdGhlIG1heC9taW4gZmxvYXRcbiAgIHRoYXQgZml0cyBpbiBhIGdpdmVuLXNpemUgaW50ZWdlciB3aGVuIHJvdW5kZWQgdG93YXJkcyAwICh1c2luZyBbaW50X29mX2Zsb2F0XSkuXG5cbiAgIG1heF9pbnQvbWluX2ludCBkZXBlbmQgb24gW251bV9iaXRzXSwgZS5nLiArLy0gMl4zMCwgKy8tIDJeNjIgaWYgMzEtYml0LCA2My1iaXRcbiAgIChyZXNwZWN0aXZlbHkpIHdoaWxlIGZsb2F0IGlzIElFRUUgc3RhbmRhcmQgZm9yIGRvdWJsZSAoNTIgc2lnbmlmaWNhbnQgYml0cykuXG5cbiAgIEluIGFsbCBjYXNlcywgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdFxuICAgW2xvd2VyX2JvdW5kX2Zvcl9pbnQgPD0geCA8PSB1cHBlcl9ib3VuZF9mb3JfaW50XVxuICAgaWZmIFtpbnRfb2ZfZmxvYXQgeF0gZml0cyBpbiBhbiBpbnQgd2l0aCBbbnVtX2JpdHNdIGJpdHMuXG5cbiAgIFsyICoqIChudW1fYml0cyAtIDEpXSBpcyB0aGUgZmlyc3QgZmxvYXQgZ3JlYXRlciB0aGF0IG1heF9pbnQsIHdlIHVzZSB0aGUgcHJlY2VkaW5nXG4gICBmbG9hdCBhcyB1cHBlciBib3VuZC5cblxuICAgWy0gKDIgKiogKG51bV9iaXRzIC0gMSkpXSBpcyBlcXVhbCB0byBtaW5faW50LlxuICAgRm9yIGxvd2VyIGJvdW5kIHdlIGxvb2sgZm9yIHRoZSBzbWFsbGVzdCBmbG9hdCBbZl0gc2F0aXNmeWluZyBbZiA+IG1pbl9pbnQgLSAxXSBzbyB0aGF0XG4gICBbZl0gcm91bmRzIHRvd2FyZCB6ZXJvIHRvIFttaW5faW50XVxuXG4gICBTbyBpbiBwYXJ0aWN1bGFyIHdlIHdpbGwgaGF2ZTpcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IHggPD0gLSAoMiAqKiAoMS14KSldXG4gICBbdXBwZXJfYm91bmRfZm9yX2ludCB4ICA8ICAgIDIgKiogKDEteCkgXVxuKilcbmxldCB1cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzID1cbiAgbGV0IGV4cCA9IENhbWwuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIG9uZV91bHAgYERvd24gKDIuICoqIGV4cClcbjs7XG5cbmxldCBpc194X21pbnVzX29uZV9leGFjdCB4ID1cbiAgKCogW3ggPSB4IC0uIDEuXSBkb2VzIG5vdCB3b3JrIHdpdGggeDg3IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgYmFja2VuZCAod2hpY2ggaXMgdXNlZFxuICAgICBvbiAzMi1iaXQgb2NhbWwpIGJlY2F1c2Ugb2YgODAtYml0IHJlZ2lzdGVyIHByZWNpc2lvbiBvZiBpbnRlcm1lZGlhdGUgY29tcHV0YXRpb25zLlxuXG4gICAgIEFuIGFsdGVybmF0aXZlIHdheSBvZiBjb21wdXRpbmcgdGhpczogW3ggLS4gb25lX3VscCBgRG93biB4IDw9IDEuXSBpcyBhbHNvIHByb25lIHRvXG4gICAgIHRoZSBzYW1lIHByZWNpc2lvbiBpc3N1ZXM6IHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBbeF0gaXMgNjQtYml0LlxuICAqKVxuICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgbm90IChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgeCA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCAoeCAtLiAxLikpXG47O1xuXG5sZXQgbG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBDYW1sLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBsZXQgbWluX2ludF9hc19mbG9hdCA9IH4tLigyLiAqKiBleHApIGluXG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbnVtX2JpdHMgLSAxIDwgNTMgKCogNTMgPSAjYml0cyBpbiB0aGUgZmxvYXQncyBtYW50aXNzYSB3aXRoIHNpZ24gaW5jbHVkZWQgKilcbiAgdGhlbiAoXG4gICAgKCogVGhlIHNtYWxsZXN0IGZsb2F0IHRoYXQgcm91bmRzIHRvd2FyZHMgemVybyB0byBbbWluX2ludF0gaXNcbiAgICAgICBbbWluX2ludCAtIDEgKyBlcHNpbG9uXSAqKVxuICAgIGFzc2VydCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCk7XG4gICAgb25lX3VscCBgVXAgKG1pbl9pbnRfYXNfZmxvYXQgLS4gMS4pKVxuICBlbHNlIChcbiAgICAoKiBbbWluX2ludF9hc19mbG9hdF0gaXMgYWxyZWFkeSB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0uICopXG4gICAgYXNzZXJ0IChub3QgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpKTtcbiAgICBtaW5faW50X2FzX2Zsb2F0KVxuOztcblxuKCogRmxvYXQgY2xhbXBpbmcgaXMgc3RydWN0dXJlZCBzbGlnaHRseSBkaWZmZXJlbnRseSB0aGFuIGNsYW1waW5nIGZvciBvdGhlciB0eXBlcywgc29cbiAgIHRoYXQgd2UgZ2V0IHRoZSBiZWhhdmlvciBvZiBbY2xhbXBfdW5jaGVja2VkIG5hbiB+bWluIH5tYXggPSBuYW5dIChmb3IgYW55IFttaW5dIGFuZFxuICAgW21heF0pIGZvciBmcmVlLlxuKilcbmxldCBjbGFtcF91bmNoZWNrZWQgKHQgOiBmbG9hdCkgfm1pbiB+bWF4ID1cbiAgaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIG1heCA8IHQgdGhlbiBtYXggZWxzZSB0XG47O1xuXG5sZXQgYm94ID1cbiAgKCogUHJldmVudCBwb3RlbnRpYWwgY29uc3RhbnQgZm9sZGluZyBvZiBbKy4gMC5dIGluIHRoZSBuZWFyIG9jYW1sb3B0IGZ1dHVyZS4gKilcbiAgbGV0IHggPSBTeXMwLm9wYXF1ZV9pZGVudGl0eSAwLiBpblxuICBmdW4gZiAtPiBmICsuIHhcbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuaW5jbHVkZSBDaGFyMFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBjaGFyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9jaGFyIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2NoYXJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2NoYXIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGNoYXJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBjaGFyX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gU3RyaW5nLm1ha2UgMSB0XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICBtYXRjaCBTdHJpbmcubGVuZ3RoIHMgd2l0aFxuICAgIHwgMSAtPiBzLlswXVxuICAgIHwgXyAtPiBmYWlsd2l0aGYgXCJDaGFyLm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkNoYXJcIlxuICBlbmQpXG5cbmxldCBwcCBmbXQgYyA9IENhbWwuRm9ybWF0LmZwcmludGYgZm10IFwiJUNcIiBjXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYWxsID0gQXJyYXkuaW5pdCAyNTYgfmY6dW5zYWZlX29mX2ludCB8PiBBcnJheS50b19saXN0XG5cbmxldCBpc19sb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc191cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19wcmludCA9IGZ1bmN0aW9uXG4gIHwgJyAnIC4uICd+JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3doaXRlc3BhY2UgPSBmdW5jdGlvblxuICB8ICdcXHQnIHwgJ1xcbicgfCAnXFwwMTEnICgqIHZlcnRpY2FsIHRhYiAqKSB8ICdcXDAxMicgKCogZm9ybSBmZWVkICopIHwgJ1xccicgfCAnICcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2FscGhhID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxuKCogV3JpdGluZyB0aGVzZSBvdXQsIGluc3RlYWQgb2YgY2FsbGluZyBbaXNfYWxwaGFdIGFuZCBbaXNfZGlnaXRdLCByZWR1Y2VzXG4gICBydW50aW1lIGJ5IGFwcHJveC4gMzAlICopXG5sZXQgaXNfYWxwaGFudW0gPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9kaWdpdF91bnNhZmUgdCA9IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuXG5sZXQgZ2V0X2RpZ2l0X2V4biB0ID1cbiAgaWYgaXNfZGlnaXQgdFxuICB0aGVuIGdldF9kaWdpdF91bnNhZmUgdFxuICBlbHNlIGZhaWx3aXRoZiBcIkNoYXIuZ2V0X2RpZ2l0X2V4biAlQzogbm90IGEgZGlnaXRcIiB0ICgpXG47O1xuXG5sZXQgZ2V0X2RpZ2l0IHQgPSBpZiBpc19kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2RpZ2l0X3Vuc2FmZSB0KSBlbHNlIE5vbmVcblxubGV0IGlzX2hleF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X2xvd2VyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF91cHBlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0X2V4biA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuICB8ICdhJyAuLiAnZicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnYScgKyAxMFxuICB8ICdBJyAuLiAnRicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnQScgKyAxMFxuICB8IHQgLT5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkNoYXIuZ2V0X2hleF9kaWdpdF9leG46IG5vdCBhIGhleGFkZWNpbWFsIGRpZ2l0XCJcbiAgICAgICAgIFsgXCJjaGFyXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdCB0ID0gaWYgaXNfaGV4X2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfaGV4X2RpZ2l0X2V4biB0KSBlbHNlIE5vbmVcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggPj0gKSA9ICggPj0gKVxuICBsZXQgKCA8PSApID0gKCA8PSApXG4gIGxldCAoID0gKSA9ICggPSApXG4gIGxldCAoID4gKSA9ICggPiApXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCAoIDw+ICkgPSAoIDw+IClcbmVuZFxuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBjaGFyIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKGNoYXJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY29tcGFyZSBjMSBjMiA9IGNvbXBhcmUgKGxvd2VyY2FzZSBjMSkgKGxvd2VyY2FzZSBjMilcbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IGhhc2hfZm9sZF9jaGFyIHN0YXRlIChsb3dlcmNhc2UgdClcbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJtb2R1bGUgTGlzdCA9IExpc3RcblxubW9kdWxlIEVudW1lcmFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGFsbCA6IHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2EgdCBsaXN0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYiBsaXN0IC0+ICgnYSwgJ2IpIHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdiIGxpc3QgLT4gJ2MgbGlzdCAtPiAoJ2EsICdiLCAnYykgdCBsaXN0XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnQwLkludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxuKCogQ29uc3RydWN0IGEgYnl0ZSBzdHJpbmcgb2YgbGVuZ3RoIDI1NiwgbWFwcGluZyBldmVyeSBpbnB1dCBjaGFyYWN0ZXIgY29kZSB0b1xuICAgaXRzIGNvcnJlc3BvbmRpbmcgb3V0cHV0IGNoYXJhY3Rlci5cblxuICAgQmVuY2htYXJrcyBpbmRpY2F0ZSB0aGF0IHRoaXMgaXMgZmFzdGVyIHRoYW4gdGhlIGxhbWJkYSAoaW5jbHVkaW5nIGNvc3Qgb2ZcbiAgIHRoaXMgZnVuY3Rpb24pLCBldmVuIGlmIHRhcmdldC9yZXBsYWNlbWVudCBhcmUganVzdCAyIGNoYXJhY3RlcnMgZWFjaC5cblxuICAgUmV0dXJuIE5vbmUgaWYgdGhlIHRyYW5zbGF0aW9uIG1hcCBpcyBlcXVpdmFsZW50IHRvIGp1c3QgdGhlIGlkZW50aXR5LiAqKVxubGV0IHRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBsZXQgdHJfbWFwID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBmb3IgaSA9IDAgdG8gMjU1IGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgLSAxIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IChTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCBpKVxuICBkb25lO1xuICBsZXQgbGFzdF9yZXBsYWNlbWVudCA9IFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50IC0gMSkgaW5cbiAgZm9yXG4gICAgaSA9IG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSB0byBTdHJpbmcubGVuZ3RoIHRhcmdldCAtIDFcbiAgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggbGFzdF9yZXBsYWNlbWVudFxuICBkb25lO1xuICBsZXQgcmVjIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgaSA9XG4gICAgaWYgaSA9IDI1NlxuICAgIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgaSkgKENoYXIub2ZfaW50X2V4biBpKVxuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAoaSArIDEpXG4gIGluXG4gICgqIHF1aWNrIGNoZWNrIG9uIHRoZSBmaXJzdCB0YXJnZXQgY2hhcmFjdGVyIHdoaWNoIHdpbGwgOTklIGJlIHRydWUgKilcbiAgbGV0IGZpcnN0X3RhcmdldCA9IHRhcmdldC5bMF0gaW5cbiAgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgZmlyc3RfdGFyZ2V0KSkgZmlyc3RfdGFyZ2V0XG4gIHx8IGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgMFxuICB0aGVuIFNvbWUgKEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRyX21hcClcbiAgZWxzZSBOb25lXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9ICdhXG5cbmxldCBzdGFnZSA9IEZuLmlkXG5sZXQgdW5zdGFnZSA9IEZuLmlkXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuaW5jbHVkZSBTdHJpbmcwXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbigqIFRoaXMgYWxpYXMgaXMgbmVjZXNzYXJ5IGRlc3BpdGUgW1N0cmluZzBdIGRlZmluaW5nIFtCeXRlcyA9IEJ5dGVzMF0sIGluIG9yZGVyIHRvXG4gICBjb252aW5jZSBvY2FtbGRlcCB0aGF0IHRoaXMgZmlsZSBkb2Vzbid0IGRlcGVuZCBvbiBieXRlcy5tbC4gKilcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfc3RyaW5nXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9zdHJpbmcgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHN0cmluZ19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9zdHJpbmcgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG50eXBlIGVsdCA9IGNoYXJcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxuKCogVGhpcyBpcyBjb3BpZWQvYWRhcHRlZCBmcm9tICdibGl0Lm1sJy5cbiAgIFtzdWJdLCBbc3Vib10gY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgW0JsaXQuTWFrZShCeXRlcyldIHBsdXMgdW5zYWZlIGNhc3RzIHRvL2Zyb21cbiAgIHN0cmluZyBidXQgd2VyZSBpbmxpbmVkIGhlcmUgdG8gYXZvaWQgdXNpbmcgW0J5dGVzLnVuc2FmZV9vZl9zdHJpbmddIGFzIG11Y2ggYXMgcG9zc2libGUuXG4qKVxubGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgaWYgcG9zID0gMCAmJiBsZW4gPSBTdHJpbmcubGVuZ3RoIHNyY1xuICB0aGVuIHNyY1xuICBlbHNlIChcbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggc3JjKTtcbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBcIlwiXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6cG9zIH5kc3QgfmRzdF9wb3M6MCB+bGVuO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpKVxuOztcblxubGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gIHN1YlxuICAgIHNyY1xuICAgIH5wb3NcbiAgICB+bGVuOlxuICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgIHwgTm9uZSAtPiBsZW5ndGggc3JjIC0gcG9zKVxuOztcblxubGV0IHJlYyBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfIGNoYXIgPVxuICBwb3MgPCBlbmRfXG4gICYmIChDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHQgcG9zKSBjaGFyIHx8IGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3M6KHBvcyArIDEpIH5lbmRfIGNoYXIpXG47O1xuXG5sZXQgY29udGFpbnMgPyhwb3MgPSAwKSA/bGVuIHQgY2hhciA9XG4gIGxldCB0b3RhbF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9IE9wdGlvbi52YWx1ZSBsZW4gfmRlZmF1bHQ6KHRvdGFsX2xlbmd0aCAtIHBvcykgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXzoocG9zICsgbGVuKSBjaGFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgcmVjIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyID1cbiAgaWYgcG9zID49IGxlblxuICB0aGVuIHJhaXNlIG5vdF9mb3VuZFxuICBlbHNlIGlmIENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgc3RyaW5nIHBvcykgY2hhclxuICB0aGVuIHBvc1xuICBlbHNlIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zOihwb3MgKyAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IGluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciA9XG4gIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvczowIH5sZW46KGxlbmd0aCB0KSB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCBpbmRleF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGluZGV4X2V4biB0IGNoYXIgPSBpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9leG5cbjs7XG5cbmxldCBpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9leG5cIlxuICAgIGVsc2UgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgaW5kZXhfZnJvbV9leG5cbjs7XG5cbmxldCByZWMgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyID1cbiAgaWYgcG9zIDwgMFxuICB0aGVuIHJhaXNlIG5vdF9mb3VuZFxuICBlbHNlIGlmIENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgc3RyaW5nIHBvcykgY2hhclxuICB0aGVuIHBvc1xuICBlbHNlIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvczoocG9zIC0gMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCByaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3M6KGxlbiAtIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgcmluZGV4X2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yaW5kZXhfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJpbmRleF9leG4gdCBjaGFyID0gcmluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJpbmRleF9leG5cbjs7XG5cbmxldCByaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBwb3MgPCAtMSB8fCBwb3MgPj0gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG5cIlxuICAgIGVsc2UgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhclxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJpbmRleF9mcm9tX2V4blxuOztcblxubGV0IGluZGV4IHQgY2hhciA9XG4gIHRyeSBTb21lIChpbmRleF9leG4gdCBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByaW5kZXggdCBjaGFyID1cbiAgdHJ5IFNvbWUgKHJpbmRleF9leG4gdCBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCBpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICB0cnkgU29tZSAoaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmluZGV4X2Zyb20gdCBwb3MgY2hhciA9XG4gIHRyeSBTb21lIChyaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm4wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgOyBjYXNlX3NlbnNpdGl2ZSA6IGJvb2xcbiAgICA7IGttcF9hcnJheSA6IGludCBhcnJheVxuICAgIH1cblxuICBsZXQgc2V4cF9vZl90IHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSA9IF8gfSA6IFNleHAudCA9XG4gICAgTGlzdFxuICAgICAgWyBMaXN0IFsgQXRvbSBcInBhdHRlcm5cIjsgc2V4cF9vZl9zdHJpbmcgcGF0dGVybiBdXG4gICAgICA7IExpc3QgWyBBdG9tIFwiY2FzZV9zZW5zaXRpdmVcIjsgc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlIF1cbiAgICAgIF1cbiAgOztcblxuICBsZXQgcGF0dGVybiB0ID0gdC5wYXR0ZXJuXG4gIGxldCBjYXNlX3NlbnNpdGl2ZSB0ID0gdC5jYXNlX3NlbnNpdGl2ZVxuXG4gICgqIEZpbmQgbWF4IG51bWJlciBvZiBtYXRjaGVkIGNoYXJhY3RlcnMgYXQgW25leHRfdGV4dF9jaGFyXSwgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAgICAgW21hdGNoZWRfY2hhcnNdLiBUcnkgdG8gZXh0ZW5kIHRoZSBjdXJyZW50IG1hdGNoLCBpZiBjaGFycyBkb24ndCBtYXRjaCwgdHJ5IHRvIG1hdGNoXG4gICAgIGZld2VyIGNoYXJzLiBJZiBjaGFycyBtYXRjaCB0aGVuIGV4dGVuZCB0aGUgbWF0Y2guICopXG4gIGxldCBrbXBfaW50ZXJuYWxfbG9vcCB+bWF0Y2hlZF9jaGFycyB+bmV4dF90ZXh0X2NoYXIgfnBhdHRlcm4gfmttcF9hcnJheSB+Y2hhcl9lcXVhbCA9XG4gICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgbWF0Y2hlZF9jaGFycyBpblxuICAgIHdoaWxlXG4gICAgICAhbWF0Y2hlZF9jaGFycyA+IDBcbiAgICAgICYmIG5vdCAoY2hhcl9lcXVhbCBuZXh0X3RleHRfY2hhciAodW5zYWZlX2dldCBwYXR0ZXJuICFtYXRjaGVkX2NoYXJzKSlcbiAgICBkb1xuICAgICAgbWF0Y2hlZF9jaGFycyA6PSBBcnJheS51bnNhZmVfZ2V0IGttcF9hcnJheSAoIW1hdGNoZWRfY2hhcnMgLSAxKVxuICAgIGRvbmU7XG4gICAgaWYgY2hhcl9lcXVhbCBuZXh0X3RleHRfY2hhciAodW5zYWZlX2dldCBwYXR0ZXJuICFtYXRjaGVkX2NoYXJzKVxuICAgIHRoZW4gbWF0Y2hlZF9jaGFycyA6PSAhbWF0Y2hlZF9jaGFycyArIDE7XG4gICAgIW1hdGNoZWRfY2hhcnNcbiAgOztcblxuICBsZXQgZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBtYXRjaCBjYXNlX3NlbnNpdGl2ZSB3aXRoXG4gICAgfCB0cnVlIC0+IENoYXIuZXF1YWxcbiAgICB8IGZhbHNlIC0+IENoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgOztcblxuICAoKiBDbGFzc2ljIEtNUCBwcmUtcHJvY2Vzc2luZyBvZiB0aGUgcGF0dGVybjogYnVpbGQgdGhlIGludCBhcnJheSwgd2hpY2gsIGZvciBlYWNoIGksXG4gICAgIGNvbnRhaW5zIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3Qgbm9uLXRyaXZpYWwgcHJlZml4IG9mIHMgd2hpY2ggaXMgZXF1YWwgdG8gYSBzdWZmaXhcbiAgICAgZW5kaW5nIGF0IHMuW2ldICopXG4gIGxldCBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIGxldCBuID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICBsZXQga21wX2FycmF5ID0gQXJyYXkuY3JlYXRlIH5sZW46biAoLTEpIGluXG4gICAgaWYgbiA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSAwIDA7XG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICA6PSBrbXBfaW50ZXJuYWxfbG9vcFxuICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyOih1bnNhZmVfZ2V0IHBhdHRlcm4gaSlcbiAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgaSAhbWF0Y2hlZF9jaGFyc1xuICAgICAgZG9uZSk7XG4gICAgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH1cbiAgOztcblxuICAoKiBDbGFzc2ljIEtNUDogdXNlIHRoZSBwcmUtcHJvY2Vzc2VkIHBhdHRlcm4gdG8gb3B0aW1pemUgbG9vay1iZWhpbmRzIG9uIG5vbi1tYXRjaGVzLlxuICAgICBXZSByZXR1cm4gaW50IHRvIGF2b2lkIGFsbG9jYXRpb24gaW4gW2luZGV4X2V4bl0uIC0xIG1lYW5zIG5vIG1hdGNoLiAqKVxuICBsZXQgaW5kZXhfaW50ZXJuYWwgPyhwb3MgPSAwKSB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+aW5fOnRleHQgPVxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuZ3RoIHRleHQgLSBsZW5ndGggcGF0dGVyblxuICAgIHRoZW4gLTFcbiAgICBlbHNlIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBsZXQgaiA9IHJlZiBwb3MgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIHdoaWxlICFqIDwgbiAmJiAhbWF0Y2hlZF9jaGFycyA8IGsgZG9cbiAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0ICFqIGluXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhclxuICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBqIDo9ICFqICsgMVxuICAgICAgZG9uZTtcbiAgICAgIGlmICFtYXRjaGVkX2NoYXJzID0gayB0aGVuICFqIC0gayBlbHNlIC0xKVxuICA7O1xuXG4gIGxldCBtYXRjaGVzIHQgc3RyID0gaW5kZXhfaW50ZXJuYWwgdCB+aW5fOnN0ciA+PSAwXG5cbiAgbGV0IGluZGV4ID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA8IDAgdGhlbiBOb25lIGVsc2UgU29tZSBwXG4gIDs7XG5cbiAgbGV0IGluZGV4X2V4biA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPj0gMFxuICAgIHRoZW4gcFxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIlN1YnN0cmluZyBub3QgZm91bmRcIiBbIFwic3Vic3RyaW5nXCIsIHNleHBfb2Zfc3RyaW5nIHQucGF0dGVybiBdKVxuICA7O1xuXG4gIGxldCBpbmRleF9hbGwgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfm1heV9vdmVybGFwIH5pbl86dGV4dCA9XG4gICAgaWYgbGVuZ3RoIHBhdHRlcm4gPSAwXG4gICAgdGhlbiBMaXN0LmluaXQgKDEgKyBsZW5ndGggdGV4dCkgfmY6Rm4uaWRcbiAgICBlbHNlIChcbiAgICAgIGxldCBjaGFyX2VxdWFsID0gZ2V0X2NoYXJfZXF1YWwgfmNhc2Vfc2Vuc2l0aXZlIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICBsZXQgZm91bmQgPSByZWYgW10gaW5cbiAgICAgIGZvciBqID0gMCB0byBuIGRvXG4gICAgICAgIGlmICFtYXRjaGVkX2NoYXJzID0ga1xuICAgICAgICB0aGVuIChcbiAgICAgICAgICBmb3VuZCA6PSAoaiAtIGspIDo6ICFmb3VuZDtcbiAgICAgICAgICAoKiB3ZSBqdXN0IGZvdW5kIGEgbWF0Y2ggaW4gdGhlIHByZXZpb3VzIGl0ZXJhdGlvbiAqKVxuICAgICAgICAgIG1hdGNoIG1heV9vdmVybGFwIHdpdGhcbiAgICAgICAgICB8IHRydWUgLT4gbWF0Y2hlZF9jaGFycyA6PSBBcnJheS51bnNhZmVfZ2V0IGttcF9hcnJheSAoayAtIDEpXG4gICAgICAgICAgfCBmYWxzZSAtPiBtYXRjaGVkX2NoYXJzIDo9IDApO1xuICAgICAgICBpZiBqIDwgblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgaiBpblxuICAgICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgICA6PSBrbXBfaW50ZXJuYWxfbG9vcFxuICAgICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhclxuICAgICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgIH5jaGFyX2VxdWFsKVxuICAgICAgZG9uZTtcbiAgICAgIExpc3QucmV2ICFmb3VuZClcbiAgOztcblxuICBsZXQgcmVwbGFjZV9maXJzdCA/cG9zIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbWF0Y2ggaW5kZXggP3BvcyB0IH5pbl86cyB3aXRoXG4gICAgfCBOb25lIC0+IHNcbiAgICB8IFNvbWUgaSAtPlxuICAgICAgbGV0IGxlbl9zID0gbGVuZ3RoIHMgaW5cbiAgICAgIGxldCBsZW5fdCA9IGxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICAgIGxldCBsZW5fd2l0aCA9IGxlbmd0aCB3aXRoXyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuX3MgKyBsZW5fd2l0aCAtIGxlbl90KSBpblxuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46aTtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6d2l0aF8gfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmkgfmxlbjpsZW5fd2l0aDtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6c1xuICAgICAgICB+c3JjX3BvczooaSArIGxlbl90KVxuICAgICAgICB+ZHN0XG4gICAgICAgIH5kc3RfcG9zOihpICsgbGVuX3dpdGgpXG4gICAgICAgIH5sZW46KGxlbl9zIC0gaSAtIGxlbl90KTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0XG4gIDs7XG5cblxuICBsZXQgcmVwbGFjZV9hbGwgdCB+aW5fOnMgfndpdGhfID1cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBtYXRjaCBtYXRjaGVzIHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IGxlbl9zID0gbGVuZ3RoIHMgaW5cbiAgICAgIGxldCBsZW5fdCA9IGxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICAgIGxldCBsZW5fd2l0aCA9IGxlbmd0aCB3aXRoXyBpblxuICAgICAgbGV0IG51bV9tYXRjaGVzID0gTGlzdC5sZW5ndGggbWF0Y2hlcyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuX3MgKyAoKGxlbl93aXRoIC0gbGVuX3QpICogbnVtX21hdGNoZXMpKSBpblxuICAgICAgbGV0IG5leHRfZHN0X3BvcyA9IHJlZiAwIGluXG4gICAgICBsZXQgbmV4dF9zcmNfcG9zID0gcmVmIDAgaW5cbiAgICAgIExpc3QuaXRlciBtYXRjaGVzIH5mOihmdW4gaSAtPlxuICAgICAgICBsZXQgbGVuID0gaSAtICFuZXh0X3NyY19wb3MgaW5cbiAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5zcmNfcG9zOiFuZXh0X3NyY19wb3MgfmRzdCB+ZHN0X3BvczohbmV4dF9kc3RfcG9zIH5sZW47XG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgICAgfnNyYzp3aXRoX1xuICAgICAgICAgIH5zcmNfcG9zOjBcbiAgICAgICAgICB+ZHN0XG4gICAgICAgICAgfmRzdF9wb3M6KCFuZXh0X2RzdF9wb3MgKyBsZW4pXG4gICAgICAgICAgfmxlbjpsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9kc3RfcG9zIDo9ICFuZXh0X2RzdF9wb3MgKyBsZW4gKyBsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9zcmNfcG9zIDo9ICFuZXh0X3NyY19wb3MgKyBsZW4gKyBsZW5fdCk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6IW5leHRfc3JjX3Bvc1xuICAgICAgICB+ZHN0XG4gICAgICAgIH5kc3RfcG9zOiFuZXh0X2RzdF9wb3NcbiAgICAgICAgfmxlbjoobGVuX3MgLSAhbmV4dF9zcmNfcG9zKTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0XG4gIDs7XG5cbiAgbGV0IHNwbGl0X29uIHQgcyA9XG4gICAgbGV0IHBhdHRlcm5fbGVuID0gU3RyaW5nLmxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBMaXN0Lm1hcDJfZXhuXG4gICAgICAoLXBhdHRlcm5fbGVuIDo6IG1hdGNoZXMpXG4gICAgICAobWF0Y2hlcyBAIFsgU3RyaW5nLmxlbmd0aCBzIF0pXG4gICAgICB+ZjooZnVuIGkgaiAtPiBzdWIgcyB+cG9zOihpICsgcGF0dGVybl9sZW4pIH5sZW46KGogLSBpIC0gcGF0dGVybl9sZW4pKVxuICA7O1xuXG4gIG1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gICAgdHlwZSBwdWJsaWMgPSB0XG5cbiAgICB0eXBlIG5vbnJlYyB0ID0gdCA9XG4gICAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgICA7IGttcF9hcnJheSA6IGludCBhcnJheVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBlcXVhbCwgc2V4cF9vZl1cblxuICAgIGxldCBlcXVhbCA9XG4gICAgICAoZnVuIGFfXzAwMl8gYl9fMDAzXyAtPlxuICAgICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDAyXyBiX18wMDNfXG4gICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgUHB4X2NvbXBhcmVfbGliLiggJiYgKVxuICAgICAgICAgICAgIChlcXVhbF9zdHJpbmcgYV9fMDAyXy5wYXR0ZXJuIGJfXzAwM18ucGF0dGVybilcbiAgICAgICAgICAgICAoUHB4X2NvbXBhcmVfbGliLiggJiYgKVxuICAgICAgICAgICAgICAgIChlcXVhbF9ib29sIGFfXzAwMl8uY2FzZV9zZW5zaXRpdmUgYl9fMDAzXy5jYXNlX3NlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAoZXF1YWxfYXJyYXkgZXF1YWxfaW50IGFfXzAwMl8ua21wX2FycmF5IGJfXzAwM18ua21wX2FycmF5KSlcbiAgICAgICAgICAgOiB0IC0+IHQgLT4gYm9vbClcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCA9XG4gICAgICAoZnVuIHsgcGF0dGVybiA9IHBhdHRlcm5fXzAwN19cbiAgICAgICAgICAgOyBjYXNlX3NlbnNpdGl2ZSA9IGNhc2Vfc2Vuc2l0aXZlX18wMDlfXG4gICAgICAgICAgIDsga21wX2FycmF5ID0ga21wX2FycmF5X18wMTFfXG4gICAgICAgICAgIH0gLT5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPSBbXSBpblxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgICAgbGV0IGFyZ19fMDEyXyA9IHNleHBfb2ZfYXJyYXkgc2V4cF9vZl9pbnQga21wX2FycmF5X18wMTFfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwia21wX2FycmF5XCI7IGFyZ19fMDEyXyBdIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgIGxldCBhcmdfXzAxMF8gPSBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmVfXzAwOV8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBhcmdfXzAxMF8gXVxuICAgICAgICAgIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgIGxldCBhcmdfXzAwOF8gPSBzZXhwX29mX3N0cmluZyBwYXR0ZXJuX18wMDdfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicGF0dGVyblwiOyBhcmdfXzAwOF8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDZfXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgcmVwcmVzZW50YXRpb24gPSBGbi5pZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm5faGVscGVyID0gc3RydWN0XG4gIG1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IFNlYXJjaF9wYXR0ZXJuMFxuZW5kXG5cbm9wZW4gU2VhcmNoX3BhdHRlcm5faGVscGVyXG5cbmxldCBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9leG4gP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+bWF5X292ZXJsYXAgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5pbmRleF9hbGxcbiAgICAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKVxuICAgIH5tYXlfb3ZlcmxhcFxuICAgIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9maXJzdCA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2FsbCAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5zdWJzdHJpbmcgPVxuICBPcHRpb24uaXNfc29tZSAoc3Vic3RyX2luZGV4X2dlbiB0IH5wYXR0ZXJuOnN1YnN0cmluZyB+Y2FzZV9zZW5zaXRpdmUpXG47O1xuXG5sZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcblxubGV0IGlzX3N1YnN0cmluZ19hdF9nZW4gPVxuICBsZXQgcmVjIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zIH5zdWJfbGVuIH5jaGFyX2VxdWFsID1cbiAgICBpZiBzdWJfcG9zID0gc3ViX2xlblxuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgY2hhcl9lcXVhbCAodW5zYWZlX2dldCBzdHIgc3RyX3BvcykgKHVuc2FmZV9nZXQgc3ViIHN1Yl9wb3MpXG4gICAgdGhlbiBsb29wIH5zdHIgfnN0cl9wb3M6KHN0cl9wb3MgKyAxKSB+c3ViIH5zdWJfcG9zOihzdWJfcG9zICsgMSkgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbiAgICBlbHNlIGZhbHNlXG4gIGluXG4gIGZ1biBzdHIgfnBvczpzdHJfcG9zIH5zdWJzdHJpbmc6c3ViIH5jaGFyX2VxdWFsIC0+XG4gICAgbGV0IHN0cl9sZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHN1Yl9sZW4gPSBsZW5ndGggc3ViIGluXG4gICAgaWYgc3RyX3BvcyA8IDAgfHwgc3RyX3BvcyA+IHN0cl9sZW5cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJTdHJpbmcuaXNfc3Vic3RyaW5nX2F0OiBpbnZhbGlkIGluZGV4ICVkIGZvciBzdHJpbmcgb2YgbGVuZ3RoICVkXCJcbiAgICAgICAgc3RyX3Bvc1xuICAgICAgICBzdHJfbGVuXG4gICAgICAgICgpO1xuICAgIHN0cl9wb3MgKyBzdWJfbGVuIDw9IHN0cl9sZW5cbiAgICAmJiBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvczowIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfc3VmZml4X2dlbiBzdHJpbmcgfnN1ZmZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgc3VmZml4X2xlbiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBzdWZmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW5cbiAgICAgICBzdHJpbmdcbiAgICAgICB+cG9zOihzdHJpbmdfbGVuIC0gc3VmZml4X2xlbilcbiAgICAgICB+c3Vic3RyaW5nOnN1ZmZpeFxuICAgICAgIH5jaGFyX2VxdWFsXG47O1xuXG5sZXQgaXNfcHJlZml4X2dlbiBzdHJpbmcgfnByZWZpeCB+Y2hhcl9lcXVhbCA9XG4gIGxldCBzdHJpbmdfbGVuID0gbGVuZ3RoIHN0cmluZyBpblxuICBsZXQgcHJlZml4X2xlbiA9IGxlbmd0aCBwcmVmaXggaW5cbiAgc3RyaW5nX2xlbiA+PSBwcmVmaXhfbGVuXG4gICYmIGlzX3N1YnN0cmluZ19hdF9nZW4gc3RyaW5nIH5wb3M6MCB+c3Vic3RyaW5nOnByZWZpeCB+Y2hhcl9lcXVhbFxuOztcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKHN0cmluZ19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcl9jb21wYXJlX2Nhc2VsZXNzIGMxIGMyID0gQ2hhci5jb21wYXJlIChDaGFyLmxvd2VyY2FzZSBjMSkgKENoYXIubG93ZXJjYXNlIGMyKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2xvb3AgfnBvcyB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMiA9XG4gICAgICBpZiBwb3MgPSBsZW4xXG4gICAgICB0aGVuIGlmIHBvcyA9IGxlbjIgdGhlbiAwIGVsc2UgLTFcbiAgICAgIGVsc2UgaWYgcG9zID0gbGVuMlxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMgPSBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgKHVuc2FmZV9nZXQgc3RyaW5nMSBwb3MpICh1bnNhZmVfZ2V0IHN0cmluZzIgcG9zKSBpblxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbG9vcCB+cG9zOihwb3MgKyAxKSB+c3RyaW5nMSB+bGVuMSB+c3RyaW5nMiB+bGVuMlxuICAgICAgICB8IF8gLT4gYylcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgc3RyaW5nMSBzdHJpbmcyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgc3RyaW5nMSBzdHJpbmcyXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgY29tcGFyZV9sb29wXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfnN0cmluZzFcbiAgICAgICAgICB+bGVuMTooU3RyaW5nLmxlbmd0aCBzdHJpbmcxKVxuICAgICAgICAgIH5zdHJpbmcyXG4gICAgICAgICAgfmxlbjI6KFN0cmluZy5sZW5ndGggc3RyaW5nMilcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPVxuICAgICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgICBsZXQgc3RhdGUgPSByZWYgKGhhc2hfZm9sZF9pbnQgc3RhdGUgbGVuKSBpblxuICAgICAgZm9yIHBvcyA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBzdGF0ZSA6PSBoYXNoX2ZvbGRfY2hhciAhc3RhdGUgKENoYXIubG93ZXJjYXNlICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgICAgIGRvbmU7XG4gICAgICAhc3RhdGVcbiAgICA7O1xuXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgICBsZXQgaXNfc3VmZml4IHMgfnN1ZmZpeCA9IGlzX3N1ZmZpeF9nZW4gcyB+c3VmZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgICBsZXQgc3Vic3RyX2luZGV4ID0gc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2ZpcnN0ID0gc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBpc19zdWJzdHJpbmdfYXQgPSBpc19zdWJzdHJpbmdfYXRfZ2VuIH5jaGFyX2VxdWFsOkNoYXIuQ2FzZWxlc3MuZXF1YWxcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgPSBGbi5pZFxubGV0IHRvX3N0cmluZyA9IEZuLmlkXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIlN0cmluZy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBCeXRlcy5zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dFxuOztcblxubGV0IHRvX2xpc3QgcyA9XG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPCAwIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSAtIDEpIGluXG4gIGxvb3AgW10gKGxlbmd0aCBzIC0gMSlcbjs7XG5cbmxldCB0b19saXN0X3JldiBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBhY2MgaSA9IGlmIGkgPSBsZW4gdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpICsgMSkgaW5cbiAgbG9vcCBbXSAwXG47O1xuXG5sZXQgcmV2IHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHJlcyBpICh1bnNhZmVfZ2V0IHQgKGxlbiAtIDEgLSBpKSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpyZXNcbjs7XG5cbigqKiBFZmZpY2llbnQgc3RyaW5nIHNwbGl0dGluZyAqKVxuXG5sZXQgbHNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcubHNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgbHNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBwb3MgPSBpbmRleF9leG5faW50ZXJuYWwgbGluZSB+bm90X2ZvdW5kIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggbGluZSAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgbHNwbGl0Ml9leG5cbjs7XG5cbmxldCByc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yc3BsaXQyX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IHBvcyA9IHJpbmRleF9leG5faW50ZXJuYWwgbGluZSB+bm90X2ZvdW5kIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggbGluZSAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcnNwbGl0Ml9leG5cbjs7XG5cbmxldCBsc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKGxzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKHJzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgY2hhcl9saXN0X21lbSBsIChjIDogY2hhcikgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBmYWxzZVxuICB8IGhkIDo6IHRsIC0+IENoYXIuZXF1YWwgaGQgYyB8fCBjaGFyX2xpc3RfbWVtIHRsIGNcbjs7XG5cbmxldCBzcGxpdF9nZW4gc3RyIH5vbiA9XG4gIGxldCBpc19kZWxpbSA9XG4gICAgbWF0Y2ggb24gd2l0aFxuICAgIHwgYGNoYXIgYycgLT4gZnVuIGMgLT4gQ2hhci5lcXVhbCBjIGMnXG4gICAgfCBgY2hhcl9saXN0IGwgLT4gZnVuIGMgLT4gY2hhcl9saXN0X21lbSBsIGNcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyBsYXN0X3BvcyBwb3MgPVxuICAgIGlmIHBvcyA9IC0xXG4gICAgdGhlbiBzdWIgc3RyIH5wb3M6MCB+bGVuOmxhc3RfcG9zIDo6IGFjY1xuICAgIGVsc2UgaWYgaXNfZGVsaW0gc3RyLltwb3NdXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcG9zMSA9IHBvcyArIDEgaW5cbiAgICAgIGxldCBzdWJfc3RyID0gc3ViIHN0ciB+cG9zOnBvczEgfmxlbjoobGFzdF9wb3MgLSBwb3MxKSBpblxuICAgICAgbG9vcCAoc3ViX3N0ciA6OiBhY2MpIHBvcyAocG9zIC0gMSkpXG4gICAgZWxzZSBsb29wIGFjYyBsYXN0X3BvcyAocG9zIC0gMSlcbiAgaW5cbiAgbG9vcCBbXSBsZW4gKGxlbiAtIDEpXG47O1xuXG5sZXQgc3BsaXQgc3RyIH5vbiA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhciBvbilcbmxldCBzcGxpdF9vbl9jaGFycyBzdHIgfm9uOmNoYXJzID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyX2xpc3QgY2hhcnMpXG5cbmxldCBzcGxpdF9saW5lcyA9XG4gIGxldCBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sID1cbiAgICBwb3MgOj0gIXBvcyAtIGlmICFwb3MgPiAwICYmIENoYXIuZXF1YWwgdC5bIXBvcyAtIDFdICdcXHInIHRoZW4gMiBlbHNlIDE7XG4gICAgZW9sIDo9ICFwb3MgKyAxXG4gIGluXG4gIGZ1biB0IC0+XG4gICAgbGV0IG4gPSBsZW5ndGggdCBpblxuICAgIGlmIG4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgKCogSW52YXJpYW50OiBbLTEgPD0gcG9zIDwgZW9sXS4gKilcbiAgICAgIGxldCBwb3MgPSByZWYgKG4gLSAxKSBpblxuICAgICAgbGV0IGVvbCA9IHJlZiBuIGluXG4gICAgICBsZXQgYWMgPSByZWYgW10gaW5cbiAgICAgICgqIFdlIHRyZWF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyBzcGVjaWFsbHksIGJlY2F1c2UgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYVxuICAgICAgICAgbmV3bGluZSwgd2UgZG9uJ3Qgd2FudCBhbiBleHRyYSBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZCBvZiB0aGUgb3V0cHV0LiAqKVxuICAgICAgaWYgQ2hhci5lcXVhbCB0LlshcG9zXSAnXFxuJyB0aGVuIGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2w7XG4gICAgICB3aGlsZSAhcG9zID49IDAgZG9cbiAgICAgICAgaWYgQ2hhci4oIDw+ICkgdC5bIXBvc10gJ1xcbidcbiAgICAgICAgdGhlbiBkZWNyIHBvc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBCZWNhdXNlIFtwb3MgPCBlb2xdLCB3ZSBrbm93IHRoYXQgW3N0YXJ0IDw9IGVvbF0uICopXG4gICAgICAgICAgbGV0IHN0YXJ0ID0gIXBvcyArIDEgaW5cbiAgICAgICAgICBhYyA6PSBzdWIgdCB+cG9zOnN0YXJ0IH5sZW46KCFlb2wgLSBzdGFydCkgOjogIWFjO1xuICAgICAgICAgIGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2wpXG4gICAgICBkb25lO1xuICAgICAgc3ViIHQgfnBvczowIH5sZW46IWVvbCA6OiAhYWMpXG47O1xuXG5sZXQgaXNfc3VmZml4IHMgfnN1ZmZpeCA9IGlzX3N1ZmZpeF9nZW4gcyB+c3VmZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcbmxldCBpc19wcmVmaXggcyB+cHJlZml4ID0gaXNfcHJlZml4X2dlbiBzIH5wcmVmaXggfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuXG5sZXQgaXNfc3Vic3RyaW5nX2F0IHMgfnBvcyB+c3Vic3RyaW5nID1cbiAgaXNfc3Vic3RyaW5nX2F0X2dlbiBzIH5wb3MgfnN1YnN0cmluZyB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG47O1xuXG5sZXQgd3JhcF9zdWJfbiB0IG4gfm5hbWUgfnBvcyB+bGVuIH5vbl9lcnJvciA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgKG5hbWUgXiBcIiBleHBlY3Rpbmcgbm9ubmVnYXRpdmUgYXJndW1lbnRcIilcbiAgZWxzZSAoXG4gICAgdHJ5IHN1YiB0IH5wb3MgfmxlbiB3aXRoXG4gICAgfCBfIC0+IG9uX2Vycm9yKVxuOztcblxubGV0IGRyb3BfcHJlZml4IHQgbiA9XG4gIHdyYXBfc3ViX24gfm5hbWU6XCJkcm9wX3ByZWZpeFwiIHQgbiB+cG9zOm4gfmxlbjoobGVuZ3RoIHQgLSBuKSB+b25fZXJyb3I6XCJcIlxuOztcblxubGV0IGRyb3Bfc3VmZml4IHQgbiA9XG4gIHdyYXBfc3ViX24gfm5hbWU6XCJkcm9wX3N1ZmZpeFwiIHQgbiB+cG9zOjAgfmxlbjoobGVuZ3RoIHQgLSBuKSB+b25fZXJyb3I6XCJcIlxuOztcblxubGV0IHByZWZpeCB0IG4gPSB3cmFwX3N1Yl9uIH5uYW1lOlwicHJlZml4XCIgdCBuIH5wb3M6MCB+bGVuOm4gfm9uX2Vycm9yOnRcbmxldCBzdWZmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInN1ZmZpeFwiIHQgbiB+cG9zOihsZW5ndGggdCAtIG4pIH5sZW46biB+b25fZXJyb3I6dFxuXG5sZXQgbGZpbmRpID8ocG9zID0gMCkgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlYyBsb29wIGkgPSBpZiBpID0gbiB0aGVuIE5vbmUgZWxzZSBpZiBmIGkgdC5baV0gdGhlbiBTb21lIGkgZWxzZSBsb29wIChpICsgMSkgaW5cbiAgbG9vcCBwb3Ncbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBmIGMpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGkgLT4gU29tZSB0LltpXVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZiB0LltpXSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzKVxuICBpblxuICBsb29wIDBcbjs7XG5cbmxldCByZmluZGkgP3BvcyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgPSBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZSBpZiBmIGkgdC5baV0gdGhlbiBTb21lIGkgZWxzZSBsb29wIChpIC0gMSkgaW5cbiAgbGV0IHBvcyA9XG4gICAgbWF0Y2ggcG9zIHdpdGhcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICAgIHwgTm9uZSAtPiBsZW5ndGggdCAtIDFcbiAgaW5cbiAgbG9vcCBwb3Ncbjs7XG5cbmxldCBsYXN0X25vbl9kcm9wIH5kcm9wIHQgPSByZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBub3QgKGRyb3AgYykpXG5cbmxldCByc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG47O1xuXG5sZXQgZmlyc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSlcblxubGV0IGxzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBtYXRjaCBmaXJzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIDAgLT4gdFxuICB8IFNvbWUgbiAtPiBkcm9wX3ByZWZpeCB0IG5cbjs7XG5cbigqIFtzdHJpcCB0XSBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBbbHN0cmlwIChyc3RyaXAgdCldLiAgVGhlIGltcGxlbWVudGF0aW9uXG4gICBiZWxvdyBzYXZlcyAoYXQgbGVhc3QpIGEgZmFjdG9yIG9mIHR3byBhbGxvY2F0aW9uLCBieSBvbmx5IGFsbG9jYXRpbmcgdGhlXG4gICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbmxldCBzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIGZpcnN0IC0+XG4gICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBTb21lIGxhc3QgLT4gc3ViIHQgfnBvczpmaXJzdCB+bGVuOihsYXN0IC0gZmlyc3QgKyAxKSkpXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgaSB0LltpXSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0J1xuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBtYXAgdCB+ZiA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHQnID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0JyBpIChmIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG5sZXQgdG9fYXJyYXkgcyA9IEFycmF5LmluaXQgKGxlbmd0aCBzKSB+ZjooZnVuIGkgLT4gcy5baV0pXG5cbmxldCBleGlzdHMgPVxuICBsZXQgcmVjIGxvb3AgcyBpIH5sZW4gfmYgPSBpIDwgbGVuICYmIChmIHMuW2ldIHx8IGxvb3AgcyAoaSArIDEpIH5sZW4gfmYpIGluXG4gIGZ1biBzIH5mIC0+IGxvb3AgcyAwIH5sZW46KGxlbmd0aCBzKSB+ZlxuOztcblxubGV0IGZvcl9hbGwgPVxuICBsZXQgcmVjIGxvb3AgcyBpIH5sZW4gfmYgPSBpID0gbGVuIHx8IChmIHMuW2ldICYmIGxvb3AgcyAoaSArIDEpIH5sZW4gfmYpIGluXG4gIGZ1biBzIH5mIC0+IGxvb3AgcyAwIH5sZW46KGxlbmd0aCBzKSB+ZlxuOztcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjIH5mIH5sZW4gPVxuICAgIGlmIGkgPSBsZW4gdGhlbiBhYyBlbHNlIGxvb3AgdCAoaSArIDEpIChmIGFjIHQuW2ldKSB+ZiB+bGVuXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCAwIGluaXQgfmYgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgZm9sZGkgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjIH5mIH5sZW4gPVxuICAgIGlmIGkgPSBsZW4gdGhlbiBhYyBlbHNlIGxvb3AgdCAoaSArIDEpIChmIGkgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0XG5sZXQgbWF4X2VsdCB0ID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdFxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbmxldCBmaW5kX21hcGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxubGV0IGZpbmRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kaSB+aXRlcmkgdCB+ZlxubGV0IGNvdW50aSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuY291bnRpIH5mb2xkaSB0IH5mXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZvcl9hbGxpIH5pdGVyaSB0IH5mXG5sZXQgZXhpc3RzaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZXhpc3RzaSB+aXRlcmkgdCB+ZlxuXG5sZXQgbWVtID1cbiAgbGV0IHJlYyBsb29wIHQgYyB+cG9zOmkgfmxlbiA9XG4gICAgaSA8IGxlbiAmJiAoQ2hhci5lcXVhbCBjICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IGMgfnBvczooaSArIDEpIH5sZW4pXG4gIGluXG4gIGZ1biB0IGMgLT4gbG9vcCB0IGMgfnBvczowIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBpZiBDaGFyLmVxdWFsIHRhcmdldCByZXBsYWNlbWVudFxuICB0aGVuIHNcbiAgZWxzZSBpZiBtZW0gcyB0YXJnZXRcbiAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gaWYgQ2hhci5lcXVhbCBjIHRhcmdldCB0aGVuIHJlcGxhY2VtZW50IGVsc2UgYylcbiAgZWxzZSBzXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBpc19lbXB0eSB0YXJnZXRcbiAgdGhlbiBzdGFnZSBGbi5pZFxuICBlbHNlIGlmIGlzX2VtcHR5IHJlcGxhY2VtZW50XG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aSByZXBsYWNlbWVudCBpcyBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgRm4uaWRcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgaWYgZXhpc3RzIHMgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgKHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSkpXG4gICAgICAgIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSlcbiAgICAgICAgZWxzZSBzKSlcbjs7XG5cbigqIGZhc3QgdmVyc2lvbiwgaWYgd2UgZXZlciBuZWVkIGl0OlxuICAge1tcbiAgICAgbGV0IGNvbmNhdF9hcnJheSB+c2VwIGFyID1cbiAgICAgICBsZXQgYXJfbGVuID0gQXJyYXkubGVuZ3RoIGFyIGluXG4gICAgICAgaWYgYXJfbGVuID0gMCB0aGVuIFwiXCJcbiAgICAgICBlbHNlXG4gICAgICAgICBsZXQgc2VwX2xlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgIGxldCByZXNfbGVuX3JlZiA9IHJlZiAoc2VwX2xlbiAqIChhcl9sZW4gLSAxKSkgaW5cbiAgICAgICAgIGZvciBpID0gMCB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIHJlc19sZW5fcmVmIDo9ICFyZXNfbGVuX3JlZiArIGxlbmd0aCBhci4oaSlcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICBsZXQgcmVzID0gY3JlYXRlICFyZXNfbGVuX3JlZiBpblxuICAgICAgICAgbGV0IHN0cl8wID0gYXIuKDApIGluXG4gICAgICAgICBsZXQgbGVuXzAgPSBsZW5ndGggc3RyXzAgaW5cbiAgICAgICAgIGJsaXQgfnNyYzpzdHJfMCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjAgfmxlbjpsZW5fMDtcbiAgICAgICAgIGxldCBwb3NfcmVmID0gcmVmIGxlbl8wIGluXG4gICAgICAgICBmb3IgaSA9IDEgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICBsZXQgcG9zID0gIXBvc19yZWYgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnNlcCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOnBvcyB+bGVuOnNlcF9sZW47XG4gICAgICAgICAgIGxldCBuZXdfcG9zID0gcG9zICsgc2VwX2xlbiBpblxuICAgICAgICAgICBsZXQgc3RyX2kgPSBhci4oaSkgaW5cbiAgICAgICAgICAgbGV0IGxlbl9pID0gbGVuZ3RoIHN0cl9pIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzdHJfaSB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOm5ld19wb3MgfmxlbjpsZW5faTtcbiAgICAgICAgICAgcG9zX3JlZiA6PSBuZXdfcG9zICsgbGVuX2lcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICByZXNcbiAgIF19ICopXG5cbmxldCBjb25jYXRfYXJyYXkgP3NlcCBhciA9IGNvbmNhdCA/c2VwIChBcnJheS50b19saXN0IGFyKVxubGV0IGNvbmNhdF9tYXAgP3NlcCBzIH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcCAodG9fYXJyYXkgcykgfmYpXG5cbigqIFtmaWx0ZXIgdCBmXSBpcyBpbXBsZW1lbnRlZCBieSB0aGUgZm9sbG93aW5nIGFsZ29yaXRobS5cblxuICAgTGV0IFtuID0gbGVuZ3RoIHRdLlxuXG4gICAxLiBGaW5kIHRoZSBsb3dlc3QgW2ldIHN1Y2ggdGhhdCBbbm90IChmIHQuW2ldKV0uXG5cbiAgIDIuIElmIHRoZXJlIGlzIG5vIHN1Y2ggW2ldLCB0aGVuIHJldHVybiBbdF0uXG5cbiAgIDMuIElmIHRoZXJlIGlzIHN1Y2ggYW4gW2ldLCBhbGxvY2F0ZSBhIHN0cmluZywgW291dF0sIHRvIGhvbGQgdGhlIHJlc3VsdC4gIFtvdXRdIGhhc1xuICAgbGVuZ3RoIFtuIC0gMV0sIHdoaWNoIGlzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIG91dHB1dCBzaXplIGdpdmVuIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3RcbiAgIG9uZSBjaGFyYWN0ZXIgbm90IHNhdGlzZnlpbmcgW2ZdLlxuXG4gICA0LiBDb3B5IGNoYXJhY3RlcnMgYXQgaW5kaWNlcyAwIC4uLiBbaSAtIDFdIGZyb20gW3RdIHRvIFtvdXRdLlxuXG4gICA1LiBXYWxrIHRocm91Z2ggY2hhcmFjdGVycyBhdCBpbmRpY2VzIFtpKzFdIC4uLiBbbi0xXSBvZiBbdF0sIGNvcHlpbmcgdGhvc2UgdGhhdFxuICAgc2F0aXNmeSBbZl0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDYuIElmIHdlIGNvbXBsZXRlbHkgZmlsbGVkIFtvdXRdLCB0aGVuIHJldHVybiBpdC4gIElmIG5vdCwgcmV0dXJuIHRoZSBwcmVmaXggb2YgW291dF1cbiAgIHRoYXQgd2UgZGlkIGZpbGwgaW4uXG5cbiAgIFRoaXMgYWxnb3JpdGhtIGhhcyB0aGUgcHJvcGVydHkgdGhhdCBpdCBkb2Vzbid0IGFsbG9jYXRlIGEgbmV3IHN0cmluZyBpZiB0aGVyZSdzXG4gICBub3RoaW5nIHRvIGZpbHRlciwgd2hpY2ggaXMgYSBjb21tb24gY2FzZS4gKilcbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IG4gJiYgZiB0LlshaV0gZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgaWYgIWkgPSBuXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgb3V0ID0gQnl0ZXMuY3JlYXRlIChuIC0gMSkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om91dCB+ZHN0X3BvczowIH5sZW46IWk7XG4gICAgbGV0IG91dF9wb3MgPSByZWYgIWkgaW5cbiAgICBpbmNyIGk7XG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgYyA9IHQuWyFpXSBpblxuICAgICAgaWYgZiBjXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dCAhb3V0X3BvcyBjO1xuICAgICAgICBpbmNyIG91dF9wb3MpO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBsZXQgb3V0ID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXQgaW5cbiAgICBpZiAhb3V0X3BvcyA9IG4gLSAxIHRoZW4gb3V0IGVsc2Ugc3ViIG91dCB+cG9zOjAgfmxlbjohb3V0X3Bvcylcbjs7XG5cbigqIHJlcGVhdGVkIGNvZGUgdG8gYXZvaWQgcmVxdWlyaW5nIGFuIGV4dHJhIGFsbG9jYXRpb24gZm9yIGEgY2xvc3VyZSBvbiBlYWNoIGNhbGwuICopXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmICFpIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmICFpIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxubGV0IGNob3BfcHJlZml4IHMgfnByZWZpeCA9XG4gIGlmIGlzX3ByZWZpeCBzIH5wcmVmaXggdGhlbiBTb21lIChkcm9wX3ByZWZpeCBzIChsZW5ndGggcHJlZml4KSkgZWxzZSBOb25lXG47O1xuXG5sZXQgY2hvcF9wcmVmaXhfaWZfZXhpc3RzIHMgfnByZWZpeCA9XG4gIGlmIGlzX3ByZWZpeCBzIH5wcmVmaXggdGhlbiBkcm9wX3ByZWZpeCBzIChsZW5ndGggcHJlZml4KSBlbHNlIHNcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9leG4gcyB+cHJlZml4ID1cbiAgbWF0Y2ggY2hvcF9wcmVmaXggcyB+cHJlZml4IHdpdGhcbiAgfCBTb21lIHN0ciAtPiBzdHJcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIlN0cmluZy5jaG9wX3ByZWZpeF9leG4gJVMgJVNcIiBzIHByZWZpeCAoKVxuOztcblxubGV0IGNob3Bfc3VmZml4IHMgfnN1ZmZpeCA9XG4gIGlmIGlzX3N1ZmZpeCBzIH5zdWZmaXggdGhlbiBTb21lIChkcm9wX3N1ZmZpeCBzIChsZW5ndGggc3VmZml4KSkgZWxzZSBOb25lXG47O1xuXG5sZXQgY2hvcF9zdWZmaXhfaWZfZXhpc3RzIHMgfnN1ZmZpeCA9XG4gIGlmIGlzX3N1ZmZpeCBzIH5zdWZmaXggdGhlbiBkcm9wX3N1ZmZpeCBzIChsZW5ndGggc3VmZml4KSBlbHNlIHNcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9leG4gcyB+c3VmZml4ID1cbiAgbWF0Y2ggY2hvcF9zdWZmaXggcyB+c3VmZml4IHdpdGhcbiAgfCBTb21lIHN0ciAtPiBzdHJcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIlN0cmluZy5jaG9wX3N1ZmZpeF9leG4gJVMgJVNcIiBzIHN1ZmZpeCAoKVxuOztcblxubW9kdWxlIEZvcl9jb21tb25fcHJlZml4X2FuZF9zdWZmaXggPSBzdHJ1Y3RcbiAgKCogV2hlbiB0YWtpbmcgYSBzdHJpbmcgcHJlZml4IG9yIHN1ZmZpeCwgd2UgZXh0cmFjdCBmcm9tIHRoZSBzaG9ydGVzdCBpbnB1dCBhdmFpbGFibGVcbiAgICAgaW4gY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gb25lIG9mIG91ciBpbnB1dHMgd2l0aG91dCBhbGxvY2F0aW5nIGEgbmV3IHN0cmluZy4gKilcblxuICBsZXQgc2hvcnRlciBhIGIgPSBpZiBsZW5ndGggYSA8PSBsZW5ndGggYiB0aGVuIGEgZWxzZSBiXG5cbiAgbGV0IHNob3J0ZXN0IGxpc3QgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gXCJcIlxuICAgIHwgZmlyc3QgOjogcmVzdCAtPiBMaXN0LmZvbGQgcmVzdCB+aW5pdDpmaXJzdCB+ZjpzaG9ydGVyXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIGZvciBjb21tb24gcHJlZml4L3N1ZmZpeCBhYnN0cmFjdCBvdmVyIFtnZXRfcG9zXSwgd2hpY2ggaXNcbiAgICAgZWl0aGVyIFtwb3NfZnJvbV9sZWZ0XSBvciBbcG9zX2Zyb21fcmlnaHRdLiAqKVxuXG4gIGxldCBwb3NfZnJvbV9sZWZ0IChfIDogdCkgKGkgOiBpbnQpID0gaVxuICBsZXQgcG9zX2Zyb21fcmlnaHQgdCBpID0gbGVuZ3RoIHQgLSBpIC0gMVxuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhciA9XG4gICAgaWYgbGVuX3NvX2ZhciA+PSBtYXhfbGVuXG4gICAgdGhlbiBtYXhfbGVuXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsXG4gICAgICAgICAgICAgICh1bnNhZmVfZ2V0IGEgKGdldF9wb3MgYSBsZW5fc29fZmFyKSlcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYiAoZ2V0X3BvcyBiIGxlbl9zb19mYXIpKVxuICAgIHRoZW4gY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjoobGVuX3NvX2ZhciArIDEpXG4gICAgZWxzZSBsZW5fc29fZmFyXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zID1cbiAgICBsZXQgbWF4X2xlbiA9IG1pbiAobGVuZ3RoIGEpIChsZW5ndGggYikgaW5cbiAgICBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOjBcbiAgOztcblxuICBsZXQgcmVjIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IGxpc3QgfmdldF9wb3Mgfm1heF9sZW4gPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbWF4X2xlblxuICAgIHwgc2Vjb25kIDo6IHJlc3QgLT5cbiAgICAgIGxldCBtYXhfbGVuID1cbiAgICAgICAgKCogV2UgY2FsbCBbY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wXSByYXRoZXIgdGhhbiBbY29tbW9uX2dlbmVyaWMyX2xlbmd0aF0gc29cbiAgICAgICAgICAgdGhhdCBbbWF4X2xlbl0gbGltaXRzIG91ciB0cmF2ZXJzYWwgb2YgW2ZpcnN0XSBhbmQgW3NlY29uZF0uICopXG4gICAgICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBmaXJzdCBzZWNvbmQgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICAgICAgaW5cbiAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIHNlY29uZCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IDBcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIFByZWNvbXB1dGluZyBbbWF4X2xlbl0gYmFzZWQgb24gW3Nob3J0ZXN0IGxpc3RdIHNhdmVzIHVzIHdvcmsgaW4gbG9uZ2VyIHN0cmluZ3MsXG4gICAgICAgICBhdCB0aGUgY29zdCBvZiBhbiBleHRyYSBwYXNzIG92ZXIgdGhlIHNwaW5lIG9mIFtsaXN0XS5cblxuICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIHlvdSdyZSBsb29raW5nIGZvciB0aGUgbG9uZ2VzdCBwcmVmaXggb2YgdGhlIHN0cmluZ3M6XG5cbiAgICAgICAgIHt2XG4gICAgICAgICAgICBsZXQgbG9uZ19hID0gTGlzdC5pbml0IDEwMDAgfmY6KEZuLmNvbnN0ICdhJylcbiAgICAgICAgICAgIFsgbG9uZ19hOyBsb25nX2E7ICdhYScgXVxuICAgICAgICAgdn1cblxuICAgICAgICAgdGhlIGFwcHJvYWNoIGJlbG93IHdpbGwganVzdCBjaGVjayB0aGUgZmlyc3QgdHdvIGNoYXJhY3RlcnMgb2YgYWxsIHRoZSBzdHJpbmdzLlxuICAgICAgKilcbiAgICAgIGxldCBtYXhfbGVuID0gbGVuZ3RoIChzaG9ydGVzdCBsaXN0KSBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICA7O1xuXG4gICgqIE91ciBnZW5lcmljIGFjY2Vzc29ycyB0aGF0IHByb2R1Y2UgYSBzdHJpbmcgYWJzdHJhY3Qgb3ZlciBbdGFrZV0sIHdoaWNoIGlzIGVpdGhlclxuICAgICBbcHJlZml4XSBvciBbc3VmZml4XS4gKilcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyIGEgYiB+Z2V0X3BvcyB+dGFrZSA9XG4gICAgbGV0IGxlbiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zIGluXG4gICAgKCogVXNlIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gc3RyaW5ncywgc28gdGhhdCBpZiB0aGUgc2hvcnRlciBvbmUgaXMgdGhlIHNoYXJlZFxuICAgICAgIHByZWZpeCwgW3Rha2VdIHdvbid0IGFsbG9jYXRlIGFub3RoZXIgc3RyaW5nLiAqKVxuICAgIHRha2UgKHNob3J0ZXIgYSBiKSBsZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMgbGlzdCB+Z2V0X3BvcyB+dGFrZSA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+XG4gICAgICAoKiBBcyB3aXRoIFtjb21tb25fZ2VuZXJpY19sZW5ndGhdLCB3ZSBiYXNlIFttYXhfbGVuXSBvbiBbc2hvcnRlc3QgbGlzdF0uIFdlIGFsc29cbiAgICAgICAgIHVzZSB0aGlzIHJlc3VsdCBmb3IgW3Rha2VdLCBiZWxvdywgdG8gcG90ZW50aWFsbHkgYXZvaWQgYWxsb2NhdGluZyBhIHN0cmluZy4gKilcbiAgICAgIGxldCBzID0gc2hvcnRlc3QgbGlzdCBpblxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggcyBpblxuICAgICAgaWYgbWF4X2xlbiA9IDBcbiAgICAgIHRoZW4gXCJcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsZW4gPVxuICAgICAgICAgICgqIFdlIGNhbGwgZGlyZWN0bHkgaW50byBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0gdG8gYXZvaWQgcmVjb21wdXRpbmcgW3Nob3J0ZXN0IGxpc3RdLiAqKVxuICAgICAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgICAgICAgaW5cbiAgICAgICAgdGFrZSBzIGxlbilcbiAgOztcbmVuZFxuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIEZvcl9jb21tb25fcHJlZml4X2FuZF9zdWZmaXhcblxuICBsZXQgY29tbW9uX3ByZWZpeCBsaXN0ID0gY29tbW9uX2dlbmVyaWMgbGlzdCB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeCBsaXN0ID0gY29tbW9uX2dlbmVyaWMgbGlzdCB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyIGEgYiA9IGNvbW1vbl9nZW5lcmljMiBhIGIgfnRha2U6cHJlZml4IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXgyIGEgYiA9IGNvbW1vbl9nZW5lcmljMiBhIGIgfnRha2U6c3VmZml4IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeF9sZW5ndGggbGlzdCA9IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIGEgYiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG5lbmRcblxuKCogVGhlcmUgdXNlZCB0byBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdhcyBmYXN0ZXIgZm9yIHZlcnkgc2hvcnQgc3RyaW5nc1xuICAgKHBlYWtpbmcgYXQgNDAlIGZhc3RlciBmb3IgNC02IGNoYXIgbG9uZyBzdHJpbmdzKS5cbiAgIFRoaXMgbmV3IGZ1bmN0aW9uIGlzIGFyb3VuZCAyMCUgZmFzdGVyIHRoYW4gdGhlIGRlZmF1bHQgaGFzaCBmdW5jdGlvbiwgYnV0IHNsb3dlclxuICAgdGhhbiB0aGUgcHJldmlvdXMgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB0aGUgbmV3IE9DYW1sIGZ1bmN0aW9uIGlzIHdlbGxcbiAgIGJlaGF2ZWQsIGFuZCB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGxlc3MgbGlrZWx5IHRvIGRpdmVyZ2UgZnJvbSB0aGUgZGVmYXVsdCBPQ2FtbFxuICAgaW1wbGVtZW50YXRpb24gZG9lcywgd2hpY2ggaXMgYSBkZXNpcmFibGUgcHJvcGVydHkuIChUaGUgb25seSB3YXkgdG8gYXZvaWQgdGhlXG4gICBkaXZlcmdlbmNlIGlzIHRvIGV4cG9zZSB0aGUgbWFjcm8gcmVkZWZpbmVkIGluIGhhc2hfc3R1YnMuYyBpbiB0aGUgaGFzaC5oIGhlYWRlciBvZlxuICAgdGhlIE9DYW1sIGNvbXBpbGVyLikgKilcbm1vZHVsZSBIYXNoID0gc3RydWN0XG4gIGV4dGVybmFsIGhhc2ggOiBzdHJpbmcgLT4gaW50ID0gXCJCYXNlX2hhc2hfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmVuZFxuXG4oKiBbaW5jbHVkZSBIYXNoXSB0byBtYWtlIHRoZSBbZXh0ZXJuYWxdIHZlcnNpb24gb3ZlcnJpZGUgdGhlIFtoYXNoXSBmcm9tXG4gICBbSGFzaGFibGUuTWFrZV9iaW5hYmxlXSwgc28gdGhhdCB3ZSBnZXQgYSBsaXR0bGUgYml0IG9mIGEgc3BlZWR1cCBieSBleHBvc2luZyBpdCBhc1xuICAgZXh0ZXJuYWwgaW4gdGhlIG1saS4gKilcbmxldCBfID0gaGFzaFxuXG5pbmNsdWRlIEhhc2hcblxuKCogZm9yIGludGVyYWN0aXZlIHRvcC1sZXZlbHMgLS0gbW9kdWxlcyBkZXJpdmluZyBmcm9tIFN0cmluZyBzaG91bGQgaGF2ZSBTdHJpbmcncyBwcmV0dHlcbiAgIHByaW50ZXIuICopXG5sZXQgcHAgcHBmIHN0cmluZyA9IENhbWwuRm9ybWF0LmZwcmludGYgcHBmIFwiJVNcIiBzdHJpbmdcbmxldCBvZl9jaGFyIGMgPSBtYWtlIDEgY1xuXG5sZXQgb2ZfY2hhcl9saXN0IGwgPVxuICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSBjIC0+IEJ5dGVzLnNldCB0IGkgYyk7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dFxuOztcblxubW9kdWxlIEVzY2FwaW5nID0gc3RydWN0XG4gICgqIElmIHRoaXMgaXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRvIHVwZGF0ZSBbZXNjYXBlXSwgd2hpY2ggYXR0ZW1wdHMgdG8gZW5zdXJlIGFsbCB0aGVcbiAgICAgaW52YXJpYW50cyBjaGVja2VkIGhlcmUuICAqKVxuICBsZXQgYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBmdW5jID1cbiAgICBsZXQgZXNjYXBld29ydGh5X21hcCA9XG4gICAgICBpZiBMaXN0LkFzc29jLm1lbSBlc2NhcGV3b3J0aHlfbWFwIH5lcXVhbDpDaGFyLmVxdWFsIGVzY2FwZV9jaGFyXG4gICAgICB0aGVuIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgIGVsc2UgKGVzY2FwZV9jaGFyLCBlc2NhcGVfY2hhcikgOjogZXNjYXBld29ydGh5X21hcFxuICAgIGluXG4gICAgbGV0IGFyciA9IEFycmF5LmNyZWF0ZSB+bGVuOjI1NiAoLTEpIGluXG4gICAgbGV0IHZhbHMgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgZmFsc2UgaW5cbiAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBPayBhcnJcbiAgICAgIHwgKGNfZnJvbSwgY190bykgOjogbCAtPlxuICAgICAgICBsZXQgaywgdiA9XG4gICAgICAgICAgbWF0Y2ggZnVuYyB3aXRoXG4gICAgICAgICAgfCBgRXNjYXBlIC0+IENoYXIudG9faW50IGNfZnJvbSwgY190b1xuICAgICAgICAgIHwgYFVuZXNjYXBlIC0+IENoYXIudG9faW50IGNfdG8sIGNfZnJvbVxuICAgICAgICBpblxuICAgICAgICBpZiBhcnIuKGspIDw+IC0xIHx8IHZhbHMuKENoYXIudG9faW50IHYpXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgICBcImVzY2FwZXdvcnRoeV9tYXAgbm90IG9uZS10by1vbmVcIlxuICAgICAgICAgICAgICAgWyBcImNfZnJvbVwiLCBzZXhwX29mX2NoYXIgY19mcm9tXG4gICAgICAgICAgICAgICA7IFwiY190b1wiLCBzZXhwX29mX2NoYXIgY190b1xuICAgICAgICAgICAgICAgOyAoIFwiZXNjYXBld29ydGh5X21hcFwiXG4gICAgICAgICAgICAgICAgICwgc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9jaGFyIHNleHBfb2ZfY2hhcikgZXNjYXBld29ydGh5X21hcFxuICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICBdKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBhcnIuKGspIDwtIENoYXIudG9faW50IHY7XG4gICAgICAgICAgdmFscy4oQ2hhci50b19pbnQgdikgPC0gdHJ1ZTtcbiAgICAgICAgICBsb29wIGwpXG4gICAgaW5cbiAgICBsb29wIGVzY2FwZXdvcnRoeV9tYXBcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYEVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICAoKiBjYWxjdWxhdGUgYSBsaXN0IG9mIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgZmlyc3QsIHRoZSBvcmRlclxuICAgICAgICAgICAgICBpcyBmcm9tIHRhaWwgdG8gaGVhZCAqKVxuICAgICAgICAgICBsZXQgdG9fZXNjYXBlX2xlbiA9IHJlZiAwIGluXG4gICAgICAgICAgIGxldCB0b19lc2NhcGUgPVxuICAgICAgICAgICAgIGZvbGRpIHNyYyB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGMgLT5cbiAgICAgICAgICAgICAgIG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgYykgd2l0aFxuICAgICAgICAgICAgICAgfCAtMSAtPiBhY2NcbiAgICAgICAgICAgICAgIHwgbiAtPlxuICAgICAgICAgICAgICAgICAoKiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpICopXG4gICAgICAgICAgICAgICAgIGluY3IgdG9fZXNjYXBlX2xlbjtcbiAgICAgICAgICAgICAgICAgKGksIENoYXIudW5zYWZlX29mX2ludCBuKSA6OiBhY2MpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIG1hdGNoIHRvX2VzY2FwZSB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICgqIFt0b19lc2NhcGVdIGRpdmlkZSBbc3JjXSB0byBbTGlzdC5sZW5ndGggdG9fZXNjYXBlICsgMV0gcGllY2VzIHNlcGFyYXRlZCBieVxuICAgICAgICAgICAgICAgIHRoZSBjaGFycyB0byBlc2NhcGUuXG5cbiAgICAgICAgICAgICAgICBMZXRzIHRha2VcbiAgICAgICAgICAgICAgICB7W1xuICAgICAgICAgICAgICAgICAgZXNjYXBlX2dlbl9leG5cbiAgICAgICAgICAgICAgICAgICAgfmVzY2FwZXdvcnRoeV9tYXA6WygnYScsICdBJyk7ICgnYicsICdCJyk7ICgnYycsICdDJyldXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGVfY2hhcjonXydcbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCBhbmQgYXNzdW1lIHRoZSBzdHJpbmcgdG8gZXNjYXBlIGlzXG5cbiAgICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgICB0aGVuIFt0b19lc2NhcGVdIGlzIFsoMTEsICdDJyk7ICg3LCAnQicpOyAoMywgJ0EnKV0uXG5cbiAgICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIFtkc3RdIG9mIGxlbmd0aCBbbGVuZ3RoIHNyYyArIDNdIHRvIHN0b3JlIHRoZVxuICAgICAgICAgICAgICAgIHJlc3VsdCwgY29weSBwaWVjZSBcIjMzM1wiIHRvIFtkc3RdIGRpcmVjdGx5LCB0aGVuIGNvcHkgJ18nIGFuZCAnQycgdG8gW2RzdF07XG4gICAgICAgICAgICAgICAgdGhlbiBtb3ZlIG9uIHRvIG5leHQ7IGFmdGVyIDMgaXRlcmF0aW9ucywgY29weSBwaWVjZSBcIjAwMFwiIGFuZCB3ZSBhcmUgZG9uZS5cblxuICAgICAgICAgICAgICAgIEZpbmFsbHkgdGhlIHJlc3VsdCB3aWxsIGJlXG5cbiAgICAgICAgICAgICAgICBcIjAwMF9BMTExX0IyMjJfQzMzM1wiICopXG4gICAgICAgICAgICAgbGV0IHNyY19sZW4gPSBsZW5ndGggc3JjIGluXG4gICAgICAgICAgICAgbGV0IGRzdF9sZW4gPSBzcmNfbGVuICsgIXRvX2VzY2FwZV9sZW4gaW5cbiAgICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGRzdF9sZW4gaW5cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgICB8IChpZHgsIGVzY2FwZWRfY2hhcikgOjogdG9fZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgICgqW2lkeF0gPSB0aGUgY2hhciB0byBlc2NhcGUqKVxuICAgICAgICAgICAgICAgICAoKiB0YWtlIGZpcnN0IGl0ZXJhdGlvbiBmb3IgZXhhbXBsZSAqKVxuICAgICAgICAgICAgICAgICAoKiBjYWxjdWxhdGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDEgYmVjYXVzZSB3ZSBkb24ndCBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAxIGluXG4gICAgICAgICAgICAgICAgICgqIHNldCB0aGUgZHN0X3BvcyB0byBjb3B5IHRvICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiwgc2V0IFtzcmNfcG9zXSB0byBbaWR4ICsgMV0gdG8gc2tpcCAnYycgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMSkgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAyIHRvIGNvcHkgJ18nIGFuZCAnQycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMiBpblxuICAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IGRzdF9wb3MgZXNjYXBlX2NoYXI7XG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldCBkc3QgKGRzdF9wb3MgKyAxKSBlc2NhcGVkX2NoYXI7XG4gICAgICAgICAgICAgICAgIGxvb3AgaWR4IGRzdF9wb3MgdG9fZXNjYXBlXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBzZXQgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gdG8gbGVuZ3RoIG9mIFtkc3RdIGFuZCBbc3JjXSBmaXJzdCAqKVxuICAgICAgICAgICAgIGxvb3Agc3JjX2xlbiBkc3RfbGVuIHRvX2VzY2FwZTtcbiAgICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCBlc2NhcGUgfmVzY2FwZXdvcnRoeSB+ZXNjYXBlX2NoYXIgPVxuICAgICgqIEZvciBbZXNjYXBlX2dlbl9leG5dLCB3ZSBkb24ndCBrbm93IGhvdyB0byBmaXggaW52YWxpZCBlc2NhcGV3b3J0aHlfbWFwIHNvIHdlIGhhdmVcbiAgICAgICB0byByYWlzZSBleGNlcHRpb247IGJ1dCBpbiB0aGlzIGNhc2UsIHdlIGtub3cgaG93IHRvIGZpeCBkdXBsaWNhdGVkIGVsZW1lbnRzIGluXG4gICAgICAgZXNjYXBld29ydGh5IGxpc3QsIHNvIHdlIGp1c3QgZml4IGl0IGluc3RlYWQgb2YgcmFpc2luZyBleGNlcHRpb24gdG8gbWFrZSB0aGlzXG4gICAgICAgZnVuY3Rpb24gZWFzaWVyIHRvIHVzZS4gICopXG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgZXNjYXBld29ydGh5XG4gICAgICB8PiBMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOkNoYXIuY29tcGFyZVxuICAgICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBjIC0+IGMsIGMpXG4gICAgaW5cbiAgICBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXJcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYFVuZXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgICgqIENvbnRpbnVlIHRoZSBleGFtcGxlIGluIFtlc2NhcGVfZ2VuX2V4bl0sIG5vdyB3ZSB1bmVzY2FwZVxuXG4gICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCJcblxuICAgICAgICAgICAgICBiYWNrIHRvXG5cbiAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgIFRoZW4gW3RvX3VuZXNjYXBlXSBpcyBbMTQ7IDk7IDRdLCB3aGljaCBpcyBpbmRleGVzIG9mICdfJ3MuXG5cbiAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBzdHJpbmcgW2RzdF0gdG8gc3RvcmUgdGhlIHJlc3VsdCwgY29weSBcIjMzM1wiIHRvIGl0LCB0aGVuIGNvcHlcbiAgICAgICAgICAgICAgJ2MnLCB0aGVuIG1vdmUgb24gdG8gbmV4dCBpdGVyYXRpb24uIEFmdGVyIDMgaXRlcmF0aW9ucyBjb3B5IFwiMDAwXCIgYW5kIHdlIGFyZVxuICAgICAgICAgICAgICBkb25lLiAgKilcbiAgICAgICAgICAgKCogaW5kZXhlcyBvZiBlc2NhcGUgY2hhcnMgKilcbiAgICAgICAgICAgbGV0IHRvX3VuZXNjYXBlID1cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgYWNjID1cbiAgICAgICAgICAgICAgIGlmIGkgPj0gbGVuZ3RoIHNyY1xuICAgICAgICAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3JjIH5lc2NhcGVfY2hhciBpIHN0YXR1cyBpblxuICAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IGBFc2NhcGluZyAtPiBpIDo6IGFjY1xuICAgICAgICAgICAgICAgICAgICB8IGBFc2NhcGVkIHwgYExpdGVyYWwgLT4gYWNjKSlcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGxvb3AgMCBgTGl0ZXJhbCBbXVxuICAgICAgICAgICBpblxuICAgICAgICAgICBtYXRjaCB0b191bmVzY2FwZSB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgIHwgaWR4IDo6IHRvX3VuZXNjYXBlJyAtPlxuICAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbmd0aCBzcmMgLSBMaXN0Lmxlbmd0aCB0b191bmVzY2FwZSkgaW5cbiAgICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZSAtPlxuICAgICAgICAgICAgICAgICAoKiBbaWR4XSA9IGluZGV4IG9mIGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgICAgKCogdGFrZSAxc3QgaXRlcmF0aW9uIGFzIGV4YW1wbGUsIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIFwiMzMzXCIsIG1pbnVzIDIgdG9cbiAgICAgICAgICAgICAgICAgICAgc2tpcCAnX0MnICopXG4gICAgICAgICAgICAgICAgIGxldCBsZW4gPSBsYXN0X2lkeCAtIGlkeCAtIDIgaW5cbiAgICAgICAgICAgICAgICAgKCogcG9pbnQgW2RzdF9wb3NdIHRvIHRoZSBwb3NpdGlvbiB0byBjb3B5IFwiMzMzXCIgdG8gKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjMzM1wiICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDIpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMSB0byBjb3B5ICdjJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGRzdF9wb3MgLSAxIGluXG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldFxuICAgICAgICAgICAgICAgICAgIGRzdFxuICAgICAgICAgICAgICAgICAgIGRzdF9wb3NcbiAgICAgICAgICAgICAgICAgICAobWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBzcmMuW2lkeCArIDFdKSB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgLTEgLT4gc3JjLltpZHggKyAxXVxuICAgICAgICAgICAgICAgICAgICB8IG4gLT4gQ2hhci51bnNhZmVfb2ZfaW50IG4pO1xuICAgICAgICAgICAgICAgICAoKiB1cGRhdGUgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gKilcbiAgICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b191bmVzY2FwZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgaWYgaWR4IDwgbGVuZ3RoIHNyYyAtIDFcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAoKiBzZXQgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gdG8gbGVuZ3RoIG9mIFtkc3RdIGFuZCBbc3JjXSAqKVxuICAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYykgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgKCogZm9yIGVzY2FwZWQgc3RyaW5nIGVuZGluZyB3aXRoIGFuIGVzY2FwaW5nIGNoYXIgbGlrZSBcIjAwMF9cIiwganVzdCBpZ25vcmVcbiAgICAgICAgICAgICAgICAgIHRoZSBsYXN0IGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMgLSAxKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGUnO1xuICAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuICh1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCB1bmVzY2FwZSB+ZXNjYXBlX2NoYXIgPSB1bmVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwOltdIH5lc2NhcGVfY2hhclxuXG4gIGxldCBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgcmVjIGxvb3AgcCBjbnQgPVxuICAgICAgaWYgcCA8IDAgfHwgQ2hhci4oIDw+ICkgc3RyLltwXSBlc2NhcGVfY2hhciB0aGVuIGNudCBlbHNlIGxvb3AgKHAgLSAxKSAoY250ICsgMSlcbiAgICBpblxuICAgIGxvb3AgKHBvcyAtIDEpIDBcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCBvZGQgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIG1vZCAyID0gMSBpblxuICAgIG1hdGNoIG9kZCwgQ2hhci5lcXVhbCBzdHIuW3Bvc10gZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgdHJ1ZSwgKHRydWUgfCBmYWxzZSkgLT4gYEVzY2FwZWRcbiAgICB8IGZhbHNlLCB0cnVlIC0+IGBFc2NhcGluZ1xuICAgIHwgZmFsc2UsIGZhbHNlIC0+IGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IGNoZWNrX2JvdW5kIHN0ciBwb3MgZnVuY3Rpb25fbmFtZSA9XG4gICAgaWYgcG9zID49IGxlbmd0aCBzdHIgfHwgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIiVzOiBvdXQgb2YgYm91bmRzXCIgZnVuY3Rpb25fbmFtZSAoKVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwaW5nIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGluZ1wiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwaW5nIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGVkIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9lc2NhcGVkXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBlZCAtPiB0cnVlXG4gICAgfCBgRXNjYXBpbmcgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2xpdGVyYWwgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2xpdGVyYWxcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImluZGV4X2Zyb21cIjtcbiAgICBsZXQgcmVjIGxvb3AgaSBzdGF0dXMgPVxuICAgICAgaWYgaSA+PSBwb3NcbiAgICAgICYmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAmJiBDaGFyLmVxdWFsIHN0ci5baV0gY2hhclxuICAgICAgdGhlbiBTb21lIGlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaSA9IGkgKyAxIGluXG4gICAgICAgIGlmIGkgPj0gbGVuZ3RoIHN0clxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSBsb29wIGkgKHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMpKVxuICAgIGluXG4gICAgbG9vcCBwb3MgKGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3MpXG4gIDs7XG5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCBpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG4gIGxldCBpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcblxuICBsZXQgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcInJpbmRleF9mcm9tXCI7XG4gICAgKCogaWYgdGhlIHRhcmdldCBjaGFyIGlzIHRoZSBzYW1lIGFzIFtlc2NhcGVfY2hhcl0sIHdlIGhhdmUgbm8gd2F5IHRvIGRldGVybWluZSB3aGljaFxuICAgICAgIGVzY2FwZV9jaGFyIGlzIGxpdGVyYWwsIHNvIGp1c3QgcmV0dXJuIE5vbmUgKilcbiAgICBpZiBDaGFyLmVxdWFsIGNoYXIgZXNjYXBlX2NoYXJcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBwb3MgPVxuICAgICAgICBpZiBwb3MgPCAwXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgZXNjYXBlX2NoYXJzID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBpblxuICAgICAgICAgIGlmIGVzY2FwZV9jaGFycyBtb2QgMiA9IDAgJiYgQ2hhci5lcXVhbCBzdHIuW3Bvc10gY2hhclxuICAgICAgICAgIHRoZW4gU29tZSBwb3NcbiAgICAgICAgICBlbHNlIGxvb3AgKHBvcyAtIGVzY2FwZV9jaGFycyAtIDEpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgcG9zKVxuICA7O1xuXG4gIGxldCByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJyaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgcmluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgaWYgaXNfZW1wdHkgc3RyIHRoZW4gTm9uZSBlbHNlIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICByaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICAoKiBbc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uXSB3b3JrcyBzaW1pbGFybHkgdG8gW1N0cmluZy5zcGxpdF9nZW5dLCB3aXRoIGFuXG4gICAgIGFkZGl0aW9uYWwgcmVxdWlyZW1lbnQ6IG9ubHkgc3BsaXQgb24gbGl0ZXJhbCBjaGFycywgbm90IGVzY2FwaW5nIG9yIGVzY2FwZWQgKilcbiAgbGV0IHNwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbiA9XG4gICAgbGV0IGlzX2RlbGltID1cbiAgICAgIG1hdGNoIG9uIHdpdGhcbiAgICAgIHwgYGNoYXIgYycgLT4gZnVuIGMgLT4gQ2hhci5lcXVhbCBjIGMnXG4gICAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICAgIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyBwb3MgPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIExpc3QucmV2IChzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoobGVuIC0gbGFzdF9wb3MpIDo6IGFjYylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc3RhdHVzID0gdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgc3RhdHVzIGluXG4gICAgICAgIGlmIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAgICYmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihwb3MgLSBsYXN0X3BvcykgaW5cbiAgICAgICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgc3RhdHVzIChwb3MgKyAxKSAocG9zICsgMSkpXG4gICAgICAgIGVsc2UgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIChwb3MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgW10gYExpdGVyYWwgMCAwXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG4gIGxldCBzcGxpdF9vbl9jaGFycyBzdHIgfm9uOmNoYXJzID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyX2xpc3QgY2hhcnMpXG5cbiAgbGV0IHNwbGl0X2F0IHN0ciBwb3MgPVxuICAgIHN1YiBzdHIgfnBvczowIH5sZW46cG9zLCBzdWIgc3RyIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBzdHIgLSBwb3MgLSAxKVxuICA7O1xuXG4gIGxldCBsc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IHJzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcbiAgbGV0IHJzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChyaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG5cbiAgKCogW2xhc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYW5kIFtmaXJzdF9ub25fZHJvcF9saXRlcmFsXSBhcmUgZWl0aGVyIGJvdGggW05vbmVdIG9yIGJvdGhcbiAgICAgW1NvbWVdLiBJZiBbU29tZV0sIHRoZW4gdGhlIGZvcm1lciBpcyA+PSB0aGUgbGF0dGVyLiAqKVxuICBsZXQgbGFzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICByZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpXG4gIDs7XG5cbiAgbGV0IGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgfmRyb3AgfmVzY2FwZV9jaGFyIHQgPVxuICAgIGxmaW5kaSB0IH5mOihmdW4gaSBjIC0+XG4gICAgICAobm90IChkcm9wIGMpKVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGluZyB0IH5lc2NhcGVfY2hhciBpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwZWQgdCB+ZXNjYXBlX2NoYXIgaSlcbiAgOztcblxuICBsZXQgcnN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICB8IE5vbmUgLT4gXCJcIlxuICAgIHwgU29tZSBpIC0+IGlmIGkgPSBsZW5ndGggdCAtIDEgdGhlbiB0IGVsc2UgcHJlZml4IHQgKGkgKyAxKVxuICA7O1xuXG4gIGxldCBsc3RyaXBfbGl0ZXJhbCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICB8IE5vbmUgLT4gXCJcIlxuICAgIHwgU29tZSAwIC0+IHRcbiAgICB8IFNvbWUgbiAtPiBkcm9wX3ByZWZpeCB0IG5cbiAgOztcblxuICAoKiBbc3RyaXAgdF0gY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgW2xzdHJpcCAocnN0cmlwIHQpXS4gIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgICBiZWxvdyBzYXZlcyAoYXQgbGVhc3QpIGEgZmFjdG9yIG9mIHR3byBhbGxvY2F0aW9uLCBieSBvbmx5IGFsbG9jYXRpbmcgdGhlXG4gICAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxuICBsZXQgc3RyaXBfbGl0ZXJhbCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgfmVzY2FwZV9jaGFyID1cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgICAoKiBwZXJmb3JtYW5jZSBoYWNrOiBhdm9pZCBjb3B5aW5nIFt0XSBpbiBjb21tb24gY2FzZXMgKilcbiAgICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICAgIHRoZW4gdFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgICB8IE5vbmUgLT4gXCJcIlxuICAgICAgfCBTb21lIGZpcnN0IC0+XG4gICAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgfCBTb21lIGxhc3QgLT4gc3ViIHQgfnBvczpmaXJzdCB+bGVuOihsYXN0IC0gZmlyc3QgKyAxKSkpXG4gIDs7XG5lbmRcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG4oKiBPdmVycmlkZSBbU2VhcmNoX3BhdHRlcm5dIHdpdGggZGVmYXVsdCBjYXNlLXNlbnNpdGl2aXR5IGFyZ3VtZW50IGF0IHRoZSBlbmQgb2YgdGhlXG4gICBmaWxlLCBzbyB0aGF0IGNhbGwgc2l0ZXMgYWJvdmUgYXJlIGZvcmNlZCB0byBzdXBwbHkgY2FzZS1zZW5zaXRpdml0eSBleHBsaWNpdGx5LiAqKVxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuID0gc3RydWN0XG4gIGluY2x1ZGUgU2VhcmNoX3BhdHRlcm4wXG5cbiAgbGV0IGNyZWF0ZSA/KGNhc2Vfc2Vuc2l0aXZlID0gdHJ1ZSkgcGF0dGVybiA9IGNyZWF0ZSBwYXR0ZXJuIH5jYXNlX3NlbnNpdGl2ZVxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYnl0ZXMgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwID0gKGJ5dGVzX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2J5dGVzIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJ5dGVzX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBCeXRlczBcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQnl0ZXNcIlxuICBsZXQgcHAgZm10IHQgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVTXCIgKHRvX3N0cmluZyB0KVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5tb2R1bGUgVG9fYnl0ZXMgPSBCbGl0Lk1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IGNyZWF0ZSB+bGVuID0gY3JlYXRlIGxlblxuICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgVG9fc3RyaW5nID0gQmxpdC5NYWtlX3RvX3N0cmluZyAoVCkgKFRvX2J5dGVzKVxuXG5tb2R1bGUgRnJvbV9zdHJpbmcgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgZW5kKVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBuIDBcbiAgdGhlbiBQcmludGYuaW52YWxpZF9hcmdmIFwiQnl0ZXMuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCB0ID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgdFxuOztcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBjcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBzZXQgdCBpIGMpO1xuICB0XG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaSAwXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCAoaSAtIDEpICh1bnNhZmVfZ2V0IHQgaSA6OiBhY2MpXG4gIGluXG4gIGxvb3AgdCAobGVuZ3RoIHQgLSAxKSBbXVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxubGV0IG1hcCB0IH5mID0gbWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBtYXBpIHQgfmZcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiB+bGVuIH5wb3MgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IH5mIH5sZW4gfnBvczoocG9zICsgMSkgKGYgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IGZvbGRpID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIHBvcyBhY2MgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgfmYgfmxlbjoobGVuZ3RoIHQpIH5wb3M6MCBpbml0XG47O1xuXG5sZXQgdHIgfnRhcmdldCB+cmVwbGFjZW1lbnQgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHMgaSkgdGFyZ2V0IHRoZW4gdW5zYWZlX3NldCBzIGkgcmVwbGFjZW1lbnRcbiAgZG9uZVxuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIDBcbiAgdGhlbiBzdGFnZSBpZ25vcmVcbiAgZWxzZSBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aTogcmVwbGFjZW1lbnQgaXMgdGhlIGVtcHR5IHN0cmluZ1wiXG4gIGVsc2UgKFxuICAgIG1hdGNoIEJ5dGVzX3RyLnRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgd2l0aFxuICAgIHwgTm9uZSAtPiBzdGFnZSBpZ25vcmVcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgcyBpIChTdHJpbmcudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50ICh1bnNhZmVfZ2V0IHMgaSkpKVxuICAgICAgICBkb25lKSlcbjs7XG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCBjb250YWlucyA/cG9zID9sZW4gdCBjaGFyID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGxldCBsYXN0ID0gcG9zICsgbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgbGFzdFxuICAgICYmIChDaGFyLmVxdWFsIChnZXQgdCBpKSBjaGFyIHx8IGxvb3AgKGkgKyAxKSlcbiAgaW5cbiAgbG9vcCBwb3Ncbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIiMgMSBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiBcbnR5cGUgcmVzdWx0ID1cbnwgTmVnIG9mIHN0cmluZ1xufCBQb3Mgb2Ygc3RyaW5nXG5cbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxcIlxubGV0IF9fb2NhbWxfbGV4X3RhYmxlcyA9IHtcbiAgTGV4aW5nLmxleF9iYXNlID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDFcXDAwMFxcMDAyXFwwMDBcXDAyN1xcMDAwXFwwODJcXDAwMFxcMTA1XFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmsgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwwMDFcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdCA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF90cmFucyA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDdcXDAwMFxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHBhcnNlX2hleCBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgMFxuYW5kIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDEzNSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDMpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE0IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIE5lZyBib2R5IClcbiMgMTM5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG5sZXRcbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiMgMTQ1IFwic3JjL2hleF9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMikgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTUgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggUG9zIGJvZHkgKVxuIyAxNDkgXCJzcmMvaGV4X2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuOztcblxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGNvbnZlcnRfZmFpbHVyZSB4IGEgYiB0b19zdHJpbmcgPVxuICBQcmludGYuZmFpbHdpdGhmXG4gICAgXCJjb252ZXJzaW9uIGZyb20gJXMgdG8gJXMgZmFpbGVkOiAlcyBpcyBvdXQgb2YgcmFuZ2VcIlxuICAgIGFcbiAgICBiXG4gICAgKHRvX3N0cmluZyB4KVxuICAgICgpXG5bQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuOztcblxubGV0IG51bV9iaXRzX2ludCA9IFN5cy5pbnRfc2l6ZV9pbl9iaXRzXG5sZXQgbnVtX2JpdHNfaW50MzIgPSAzMlxubGV0IG51bV9iaXRzX2ludDY0ID0gNjRcbmxldCBudW1fYml0c19uYXRpdmVpbnQgPSBXb3JkX3NpemUubnVtX2JpdHMgV29yZF9zaXplLndvcmRfc2l6ZVxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPSA2MyB8fCBudW1fYml0c19pbnQgPSAzMSB8fCBudW1fYml0c19pbnQgPSAzMilcbmxldCBtaW5faW50MzIgPSBDYW1sLkludDMyLm1pbl9pbnRcbmxldCBtYXhfaW50MzIgPSBDYW1sLkludDMyLm1heF9pbnRcbmxldCBtaW5faW50NjQgPSBDYW1sLkludDY0Lm1pbl9pbnRcbmxldCBtYXhfaW50NjQgPSBDYW1sLkludDY0Lm1heF9pbnRcbmxldCBtaW5fbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQubWluX2ludFxubGV0IG1heF9uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5tYXhfaW50XG5sZXQgaW50X3RvX3N0cmluZyA9IENhbWwuc3RyaW5nX29mX2ludFxubGV0IGludDMyX3RvX3N0cmluZyA9IENhbWwuSW50MzIudG9fc3RyaW5nXG5sZXQgaW50NjRfdG9fc3RyaW5nID0gQ2FtbC5JbnQ2NC50b19zdHJpbmdcbmxldCBuYXRpdmVpbnRfdG9fc3RyaW5nID0gQ2FtbC5OYXRpdmVpbnQudG9fc3RyaW5nXG5cbigqIGludCA8LT4gaW50MzIgKilcblxubGV0IGludF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludFwiIFwiaW50MzJcIiBpbnRfdG9fc3RyaW5nXG5sZXQgaW50MzJfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50MzJcIiBcImludFwiIGludDMyX3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF90cnVuYyA9IENhbWwuSW50MzIudG9faW50XG5sZXQgaW50X3RvX2ludDMyX3RydW5jID0gQ2FtbC5JbnQzMi5vZl9pbnRcblxubGV0IGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9faW50X3RydW5jIG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19pbnRfdHJ1bmMgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludCB4IG1heCA8PSAwKVxuOztcblxubGV0IGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgaWYgbnVtX2JpdHNfaW50MzIgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX2ludDMyX3RydW5jIEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX2ludDMyX3RydW5jIEludC5tYXhfdmFsdWUgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludDMyIG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQzMiB4IG1heCA8PSAwKVxuOztcblxubGV0IGludF90b19pbnQzMiB4ID1cbiAgaWYgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIFNvbWUgKGludF90b19pbnQzMl90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQzMl90b19pbnQgeCA9XG4gIGlmIGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBTb21lIChpbnQzMl90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIGludF90b19pbnQzMl90cnVuYyB4IGVsc2UgaW50X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxubGV0IGludDMyX3RvX2ludF9leG4geCA9XG4gIGlmIGludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQzMl90b19pbnRfdHJ1bmMgeCBlbHNlIGludDMyX3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gaW50NjQgKilcblxubGV0IGludDY0X3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnRcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDwgbnVtX2JpdHNfaW50NjQpXG5sZXQgaW50X3RvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9pbnRcbmxldCBpbnQ2NF90b19pbnRfdHJ1bmMgPSBDYW1sLkludDY0LnRvX2ludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBsZXQgbWluID0gaW50X3RvX2ludDY0IEludC5taW5fdmFsdWUgaW5cbiAgbGV0IG1heCA9IGludF90b19pbnQ2NCBJbnQubWF4X3ZhbHVlIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBTb21lIChpbnQ2NF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDY0X3RvX2ludF90cnVuYyB4IGVsc2UgaW50NjRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBuYXRpdmVpbnQgKilcblxubGV0IG5hdGl2ZWludF90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludFwiIG5hdGl2ZWludF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDw9IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnRfdG9fbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQub2ZfaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludF90cnVuYyA9IENhbWwuTmF0aXZlaW50LnRvX2ludFxuXG5sZXQgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludF90b19uYXRpdmVpbnQgSW50Lm1pbl92YWx1ZSBpblxuICAgIGxldCBtYXggPSBpbnRfdG9fbmF0aXZlaW50IEludC5tYXhfdmFsdWUgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX25hdGl2ZWludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfbmF0aXZlaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludCB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBTb21lIChuYXRpdmVpbnRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnRfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeFxuICB0aGVuIG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeFxuICBlbHNlIG5hdGl2ZWludF90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQzMiA8LT4gaW50NjQgKilcblxubGV0IGludDY0X3RvX2ludDMyX2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcImludDMyXCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDMyIDwgbnVtX2JpdHNfaW50NjQpXG5sZXQgaW50MzJfdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX2ludDMyXG5sZXQgaW50NjRfdG9faW50MzJfdHJ1bmMgPSBDYW1sLkludDY0LnRvX2ludDMyXG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgbGV0IG1pbiA9IGludDMyX3RvX2ludDY0IG1pbl9pbnQzMiBpblxuICBsZXQgbWF4ID0gaW50MzJfdG9faW50NjQgbWF4X2ludDMyIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMiB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBpbnQ2NF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQzMiA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4ID1cbiAgY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludDMyXCIgbmF0aXZlaW50X3RvX3N0cmluZ1xuOztcblxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50MzJfdG9fbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQub2ZfaW50MzJcbmxldCBuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMgPSBDYW1sLk5hdGl2ZWludC50b19pbnQzMlxuXG5sZXQgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19uYXRpdmVpbnQgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX25hdGl2ZWludCBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX25hdGl2ZWludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfbmF0aXZlaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMl9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMgeFxuICBlbHNlIG5hdGl2ZWludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBuYXRpdmVpbnQgKilcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJuYXRpdmVpbnRcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50NjQgPj0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludDY0X3RvX25hdGl2ZWludF90cnVuYyA9IENhbWwuSW50NjQudG9fbmF0aXZlaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50ID1cbiAgaWYgbnVtX2JpdHNfaW50NjQgPD0gbnVtX2JpdHNfbmF0aXZlaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gbmF0aXZlaW50X3RvX2ludDY0IG1pbl9uYXRpdmVpbnQgaW5cbiAgICBsZXQgbWF4ID0gbmF0aXZlaW50X3RvX2ludDY0IG1heF9uYXRpdmVpbnQgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwKVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludCB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgeFxuICB0aGVuIFNvbWUgKGludDY0X3RvX25hdGl2ZWludF90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHhcbiAgZWxzZSBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gaW50NjMgKilcblxubGV0IGludDY0X3RvX2ludDYzX2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcImludDYzXCIgaW50NjRfdG9fc3RyaW5nXG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzID1cbiAgbGV0IG1pbiA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHQgbWluX2ludDY0IDEgaW5cbiAgbGV0IG1heCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHQgbWF4X2ludDY0IDEgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X2ZpdF9vbl9pbnQ2M19leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuICgpIGVsc2UgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4XG47O1xuXG4oKiBzdHJpbmcgY29udmVyc2lvbnMgKilcblxubGV0IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlciA9XG4gIGxldCBpbnB1dF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIGlucHV0IGluXG4gIGlmIGlucHV0X2xlbmd0aCA8PSBjaGFyc19wZXJfZGVsaW1pdGVyXG4gIHRoZW4gaW5wdXRcbiAgZWxzZSAoXG4gICAgbGV0IGhhc19zaWduID1cbiAgICAgIG1hdGNoIGlucHV0LlswXSB3aXRoXG4gICAgICB8ICcrJyB8ICctJyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBudW1fZGlnaXRzID0gaWYgaGFzX3NpZ24gdGhlbiBpbnB1dF9sZW5ndGggLSAxIGVsc2UgaW5wdXRfbGVuZ3RoIGluXG4gICAgbGV0IG51bV9kZWxpbWl0ZXJzID0gKG51bV9kaWdpdHMgLSAxKSAvIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgb3V0cHV0X2xlbmd0aCA9IGlucHV0X2xlbmd0aCArIG51bV9kZWxpbWl0ZXJzIGluXG4gICAgbGV0IG91dHB1dCA9IEJ5dGVzLmNyZWF0ZSBvdXRwdXRfbGVuZ3RoIGluXG4gICAgbGV0IGlucHV0X3BvcyA9IHJlZiAoaW5wdXRfbGVuZ3RoIC0gMSkgaW5cbiAgICBsZXQgb3V0cHV0X3BvcyA9IHJlZiAob3V0cHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgPSByZWYgY2hhcnNfcGVyX2RlbGltaXRlciBpblxuICAgIGxldCBmaXJzdF9kaWdpdF9wb3MgPSBpZiBoYXNfc2lnbiB0aGVuIDEgZWxzZSAwIGluXG4gICAgd2hpbGUgIWlucHV0X3BvcyA+PSBmaXJzdF9kaWdpdF9wb3MgZG9cbiAgICAgIGlmICFudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXRwdXQgIW91dHB1dF9wb3MgZGVsaW1pdGVyO1xuICAgICAgICBkZWNyIG91dHB1dF9wb3M7XG4gICAgICAgIG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgOj0gY2hhcnNfcGVyX2RlbGltaXRlcik7XG4gICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGlucHV0LlshaW5wdXRfcG9zXTtcbiAgICAgIGRlY3IgaW5wdXRfcG9zO1xuICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgZGVjciBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyXG4gICAgZG9uZTtcbiAgICBpZiBoYXNfc2lnbiB0aGVuIEJ5dGVzLnNldCBvdXRwdXQgMCBpbnB1dC5bMF07XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXRwdXQpXG47O1xuXG5sZXQgaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyID1cbiAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBpbnB1dCB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyOjNcbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgaW5wdXQgPSBpbnNlcnRfZGVsaW1pdGVyIGlucHV0IH5kZWxpbWl0ZXI6J18nXG5sZXQgc2V4cF9vZl9pbnRfc3R5bGUgPSBTZXhwLm9mX2ludF9zdHlsZVxuXG5tb2R1bGUgTWFrZSAoSSA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIGVuZCkgPVxuc3RydWN0XG4gIG9wZW4gSVxuXG4gIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gM1xuXG4gIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID1cbiAgICBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5ICh0b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbGV0IHMgPSB0b19zdHJpbmcgdCBpblxuICAgIFNleHAuQXRvbVxuICAgICAgKG1hdGNoICFzZXhwX29mX2ludF9zdHlsZSB3aXRoXG4gICAgICAgfCBgVW5kZXJzY29yZXMgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBzIH5jaGFyc19wZXJfZGVsaW1pdGVyIH5kZWxpbWl0ZXI6J18nXG4gICAgICAgfCBgTm9fdW5kZXJzY29yZXMgLT4gcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9oZXggKEkgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICAgIHZhbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gdFxuICAgIHZhbCB6ZXJvIDogdFxuICAgIHZhbCAoIDwgKSA6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIG5lZyA6IHQgLT4gdFxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgVF9oZXggPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBJLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChJLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgSS5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBJLmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNoYXJzX3Blcl9kZWxpbWl0ZXIgPSA0XG5cbiAgICBsZXQgdG9fc3RyaW5nJyA/ZGVsaW1pdGVyIHQgPVxuICAgICAgbGV0IG1ha2Vfc3VmZml4ID1cbiAgICAgICAgbWF0Y2ggZGVsaW1pdGVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEkudG9fc3RyaW5nXG4gICAgICAgIHwgU29tZSBkZWxpbWl0ZXIgLT5cbiAgICAgICAgICBmdW4gdCAtPiBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IChJLnRvX3N0cmluZyB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyXG4gICAgICBpblxuICAgICAgaWYgSS4oIDwgKSB0IEkuemVybyB0aGVuIFwiLTB4XCIgXiBtYWtlX3N1ZmZpeCAoSS5uZWcgdCkgZWxzZSBcIjB4XCIgXiBtYWtlX3N1ZmZpeCB0XG4gICAgOztcblxuICAgIGxldCB0b19zdHJpbmcgdCA9IHRvX3N0cmluZycgdCA/ZGVsaW1pdGVyOk5vbmVcbiAgICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9IHRvX3N0cmluZycgdCB+ZGVsaW1pdGVyXG5cbiAgICBsZXQgaW52YWxpZCBzdHIgPVxuICAgICAgUHJpbnRmLmZhaWx3aXRoZiBcIiVzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIEkubW9kdWxlX25hbWUgc3RyICgpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgc3RyID1cbiAgICAgIEkub2Zfc3RyaW5nIChTdHJpbmcuZmlsdGVyIHN0ciB+ZjooZnVuIGMgLT4gQ2hhci4oIDw+ICkgYyAnXycpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgICBsZXQgbW9kdWxlIEwgPSBIZXhfbGV4ZXIgaW5cbiAgICAgIGxldCBsZXggPSBDYW1sLkxleGluZy5mcm9tX3N0cmluZyBzdHIgaW5cbiAgICAgIGxldCByZXN1bHQgPSBPcHRpb24udHJ5X3dpdGggKGZ1biAoKSAtPiBMLnBhcnNlX2hleCBsZXgpIGluXG4gICAgICBpZiBsZXgubGV4X2N1cnJfcG9zID0gbGV4LmxleF9idWZmZXJfbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGludmFsaWQgc3RyXG4gICAgICAgIHwgU29tZSAoTmVnIGJvZHkpIC0+IEkubmVnIChvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgYm9keSlcbiAgICAgICAgfCBTb21lIChQb3MgYm9keSkgLT4gb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICBlbHNlIGludmFsaWQgc3RyXG4gICAgOztcblxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIFN0cmluZy50X3NleHBfZ3JhbW1hclxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBIZXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRfaGV4XG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zdHJpbmdhYmxlIChUX2hleClcbiAgZW5kXG5lbmRcbiIsIigqIFRoaXMgZmlsZSB3YXMgYXV0b2dlbmVyYXRlZCBieSAuLi9nZW5lcmF0ZS9nZW5lcmF0ZV9wb3dfb3ZlcmZsb3dfYm91bmRzLmV4ZSAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIGhhdmUgdG8gdXNlIEludDY0LnRvX2ludF9leG4gaW5zdGVhZCBvZiBpbnQgY29uc3RhbnRzIHRvIG1ha2VcbiAgIHN1cmUgdGhhdCBmaWxlIGNhbiBiZSBwcmVwcm9jZXNzZWQgb24gMzItYml0IG1hY2hpbmVzLiAqKVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIDogaW50MzIgPVxuICAyMTQ3NDgzNjQ3bFxuXG5sZXQgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50MzIgYXJyYXkgPVxuICBbfCAyMTQ3NDgzNjQ3bFxuICA7ICAyMTQ3NDgzNjQ3bFxuICA7ICA0NjM0MGxcbiAgOyAgMTI5MGxcbiAgOyAgMjE1bFxuICA7ICA3M2xcbiAgOyAgMzVsXG4gIDsgIDIxbFxuICA7ICAxNGxcbiAgOyAgMTBsXG4gIDsgIDhsXG4gIDsgIDdsXG4gIDsgIDVsXG4gIDsgIDVsXG4gIDsgIDRsXG4gIDsgIDRsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIHxdXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIDogaW50ID1cbiAgKC0xKSBsc3IgMVxuXG5sZXQgaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludCBhcnJheSA9XG4gIG1hdGNoIEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnQgd2l0aFxuICB8IDMyIC0+IEFycmF5Lm1hcCBpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgfmY6Q2FtbC5JbnQzMi50b19pbnRcbiAgfCA2MyAtPlxuICAgIFt8IENhbWwuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgOyAgQ2FtbC5JbnQ2NC50b19pbnQgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgICA7ICBDYW1sLkludDY0LnRvX2ludCAyMTQ3NDgzNjQ3TFxuICAgIDsgIDE2NjQ1MTBcbiAgICA7ICA0NjM0MFxuICAgIDsgIDU0MDRcbiAgICA7ICAxMjkwXG4gICAgOyAgNDYzXG4gICAgOyAgMjE1XG4gICAgOyAgMTE4XG4gICAgOyAgNzNcbiAgICA7ICA0OVxuICAgIDsgIDM1XG4gICAgOyAgMjdcbiAgICA7ICAyMVxuICAgIDsgIDE3XG4gICAgOyAgMTRcbiAgICA7ICAxMlxuICAgIDsgIDEwXG4gICAgOyAgOVxuICAgIDsgIDhcbiAgICA7ICA3XG4gICAgOyAgN1xuICAgIDsgIDZcbiAgICA7ICA1XG4gICAgOyAgNVxuICAgIDsgIDVcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgfF1cbiAgfCAzMSAtPlxuICAgIFt8IDEwNzM3NDE4MjNcbiAgICA7ICAxMDczNzQxODIzXG4gICAgOyAgMzI3NjdcbiAgICA7ICAxMDIzXG4gICAgOyAgMTgxXG4gICAgOyAgNjNcbiAgICA7ICAzMVxuICAgIDsgIDE5XG4gICAgOyAgMTNcbiAgICA7ICAxMFxuICAgIDsgIDdcbiAgICA7ICA2XG4gICAgOyAgNVxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIHxdXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbnQ2NF92YWx1ZSA6IGludDY0ID1cbiAgNDYxMTY4NjAxODQyNzM4NzkwM0xcblxubGV0IGludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgOyAgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgOyAgMjE0NzQ4MzY0N0xcbiAgOyAgMTY2NDUxMExcbiAgOyAgNDYzNDBMXG4gIDsgIDU0MDRMXG4gIDsgIDEyOTBMXG4gIDsgIDQ2M0xcbiAgOyAgMjE1TFxuICA7ICAxMThMXG4gIDsgIDczTFxuICA7ICA0OUxcbiAgOyAgMzVMXG4gIDsgIDI3TFxuICA7ICAyMUxcbiAgOyAgMTdMXG4gIDsgIDE0TFxuICA7ICAxMkxcbiAgOyAgMTBMXG4gIDsgIDlMXG4gIDsgIDhMXG4gIDsgIDdMXG4gIDsgIDdMXG4gIDsgIDZMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDFMXG4gIDsgIDFMXG4gIHxdXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUgOiBpbnQ2NCA9XG4gIDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG5cbmxldCBpbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIDMwMzcwMDA0OTlMXG4gIDsgIDIwOTcxNTFMXG4gIDsgIDU1MTA4TFxuICA7ICA2MjA4TFxuICA7ICAxNDQ4TFxuICA7ICA1MTFMXG4gIDsgIDIzNExcbiAgOyAgMTI3TFxuICA7ICA3OExcbiAgOyAgNTJMXG4gIDsgIDM4TFxuICA7ICAyOExcbiAgOyAgMjJMXG4gIDsgIDE4TFxuICA7ICAxNUxcbiAgOyAgMTNMXG4gIDsgIDExTFxuICA7ICA5TFxuICA7ICA4TFxuICA7ICA3TFxuICA7ICA3TFxuICA7ICA2TFxuICA7ICA2TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAxTFxuICB8XVxuXG5sZXQgaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCAtOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIC0zMDM3MDAwNDk5TFxuICA7ICAtMjA5NzE1MUxcbiAgOyAgLTU1MTA4TFxuICA7ICAtNjIwOExcbiAgOyAgLTE0NDhMXG4gIDsgIC01MTFMXG4gIDsgIC0yMzRMXG4gIDsgIC0xMjdMXG4gIDsgIC03OExcbiAgOyAgLTUyTFxuICA7ICAtMzhMXG4gIDsgIC0yOExcbiAgOyAgLTIyTFxuICA7ICAtMThMXG4gIDsgIC0xNUxcbiAgOyAgLTEzTFxuICA7ICAtMTFMXG4gIDsgIC05TFxuICA7ICAtOExcbiAgOyAgLTdMXG4gIDsgIC03TFxuICA7ICAtNkxcbiAgOyAgLTZMXG4gIDsgIC01TFxuICA7ICAtNUxcbiAgOyAgLTVMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTFMXG4gIHxdXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcbmxldCBuZWdhdGl2ZV9leHBvbmVudCAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJleHBvbmVudCBjYW4gbm90IGJlIG5lZ2F0aXZlXCIgKClcbmxldCBvdmVyZmxvdyAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJpbnRlZ2VyIG92ZXJmbG93IGluIHBvd1wiICgpXG5cbigqIFRvIGltcGxlbWVudCBbaW50NjRfcG93XSwgd2UgdXNlIEMgY29kZSByYXRoZXIgdGhhbiBPQ2FtbCB0byBlbGltaW5hdGUgYWxsb2NhdGlvbi4gKilcbmV4dGVybmFsIGludF9tYXRoX2ludF9wb3cgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWJcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaW50X21hdGhfaW50NjRfcG93IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWJcIlxuXG5sZXQgaW50X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgaWYgZXhwb25lbnQgPCAwIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMVxuICAmJiAoZXhwb25lbnQgPiA2M1xuICAgICAgfHwgYWJzIGJhc2UgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKGV4cG9uZW50KSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgSW50NjRfd2l0aF9jb21wYXJpc29ucyA9IHN0cnVjdFxuICBpbmNsdWRlIENhbWwuSW50NjRcblxuICBleHRlcm5hbCAoIDwgKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5lbmRcblxuKCogd2UgZG9uJ3QgZG8gW2Fic10gaW4gaW50NjQgY2FzZSB0byBhdm9pZCBhbGxvY2F0aW9uICopXG5sZXQgaW50NjRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgKGJhc2UgPiAxTCB8fCBiYXNlIDwgLTFMKVxuICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgIHx8IChiYXNlID49IDBMXG4gICAgICAgICAgJiYgYmFzZSA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpXG4gICAgICAgICApXG4gICAgICB8fCAoYmFzZSA8IDBMXG4gICAgICAgICAgJiYgYmFzZSA8IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpXG4gICAgICAgICApKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubGV0IGludDYzX3Bvd19vbl9pbnQ2NCBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMUxcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCBhYnMgYmFzZVxuICAgICAgICAgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICApXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlIHRcblxuICBpbmNsdWRlIEZsb2F0YWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBTdHJpbmdhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoICogKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC8gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIH4tICkgOiB0IC0+IHRcblxuICBpbmNsdWRlIENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCBvZl9pbnRfZXhuIDogaW50IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG5lbmRcblxubW9kdWxlIE1ha2UgKFggOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgb3BlbiBYXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gWC5yZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgb25lID0gb2ZfaW50X2V4biAxXG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gICgqKiBmbG9hdCBkaXZpc2lvbiBvZiBpbnRlZ2VycyAqKVxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGxldCByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPSBpIC0gKGkgJSBtb2R1bHVzKVxuXG4gIGxldCByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBpZiByZW1haW5kZXIgPSB6ZXJvIHRoZW4gaSBlbHNlIGkgKyBtb2R1bHVzIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgaWYgaSA9IHplcm9cbiAgICB0aGVuIHplcm9cbiAgICBlbHNlIGlmIGkgPiB6ZXJvXG4gICAgdGhlbiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgZWxzZSByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuXG4gIGxldCByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGxldCBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA9IG1vZHVsdXMgLSByZW1haW5kZXIgaW5cbiAgICBpZiBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA8PSByZW1haW5kZXJcbiAgICB0aGVuIGkgKyBtb2R1bHVzX21pbnVzX3JlbWFpbmRlclxuICAgIGVsc2UgaSAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgbWF0Y2ggZGlyIHdpdGhcbiAgICB8IGBOZWFyZXN0IC0+IHJvdW5kX25lYXJlc3QgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBEb3duIC0+IHJvdW5kX2Rvd24gaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBVcCAtPiByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYFplcm8gLT4gcm91bmRfdG93YXJkc196ZXJvIGkgfnRvX211bHRpcGxlX29mXG4gIDs7XG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGludF9wb3cgPSBpbnRfcG93XG4gIGxldCBpbnQ2NF9wb3cgPSBpbnQ2NF9wb3dcbiAgbGV0IGludDYzX3Bvd19vbl9pbnQ2NCA9IGludDYzX3Bvd19vbl9pbnQ2NFxuXG4gIG1vZHVsZSBQb3dfb3ZlcmZsb3dfYm91bmRzID0gUG93X292ZXJmbG93X2JvdW5kc1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCogQyBzdHViIGZvciBpbnQgcG9wY291bnQgdG8gdXNlIHRoZSBQT1BDTlQgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbmV4dGVybmFsIGludF9wb3Bjb3VudCA6IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50XCIgW0BAbm9hbGxvY11cblxuKCogVG8gbWFpbnRhaW4gamF2YXNjcmlwdCBjb21wYXRpYmlsaXR5IGFuZCBlbmFibGUgdW5ib3hpbmcsIHdlIGltcGxlbWVudCBwb3Bjb3VudCBpblxuICAgT0NhbWwgcmF0aGVyIHRoYW4gdXNlIEMgc3R1YnMuIEltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbTpcbiAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbW1pbmdfd2VpZ2h0I0VmZmljaWVudF9pbXBsZW1lbnRhdGlvbiAqKVxubGV0IGludDY0X3BvcGNvdW50ID1cbiAgbGV0IG9wZW4gQ2FtbC5JbnQ2NCBpblxuICBsZXQgKCArICkgPSBhZGQgaW5cbiAgbGV0ICggLSApID0gc3ViIGluXG4gIGxldCAoICogKSA9IG11bCBpblxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaW5cbiAgbGV0ICggbGFuZCApID0gbG9nYW5kIGluXG4gIGxldCBtMSA9IDB4NTU1NTU1NTU1NTU1NTU1NUwgaW5cbiAgKCogMGIwMTAxMDEwMS4uLiAqKVxuICBsZXQgbTIgPSAweDMzMzMzMzMzMzMzMzMzMzNMIGluXG4gICgqIDBiMDAxMTAwMTEuLi4gKilcbiAgbGV0IG00ID0gMHgwZjBmMGYwZjBmMGYwZjBmTCBpblxuICAoKiAwYjAwMDAxMTExLi4uICopXG4gIGxldCBoMDEgPSAweDAxMDEwMTAxMDEwMTAxMDFMIGluXG4gICgqIDEgYml0IHNldCBwZXIgYnl0ZSAqKVxuICBmdW4gW0BpbmxpbmVdIHggLT5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgcGFpciBvZiBiaXRzICopXG4gICAgbGV0IHggPSB4IC0gKCh4IGxzciAxKSBsYW5kIG0xKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSA0IGJpdHMgKilcbiAgICBsZXQgeCA9ICh4IGxhbmQgbTIpICsgKCh4IGxzciAyKSBsYW5kIG0yKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBieXRlICopXG4gICAgbGV0IHggPSAoeCArICh4IGxzciA0KSkgbGFuZCBtNCBpblxuICAgICgqIHN1bSB0aGUgYml0IGNvdW50cyBpbiB0aGUgdG9wIGJ5dGUgYW5kIHNoaWZ0IGl0IGRvd24gKilcbiAgICB0b19pbnQgKCh4ICogaDAxKSBsc3IgNTYpXG47O1xuXG5sZXQgaW50MzJfcG9wY291bnQgPVxuICAoKiBPbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpcyBmYXN0ZXIgdGhhbiBpbXBsZW1lbnRpbmcgdXNpbmcgW2ludDMyXSBhcml0aG1ldGljLiAqKVxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmTCBpblxuICBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKENhbWwuSW50NjQubG9nYW5kIChDYW1sLkludDY0Lm9mX2ludDMyIHgpIG1hc2spXG47O1xuXG5sZXQgbmF0aXZlaW50X3BvcGNvdW50ID1cbiAgbWF0Y2ggQ2FtbC5OYXRpdmVpbnQuc2l6ZSB3aXRoXG4gIHwgMzIgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDMyX3BvcGNvdW50IChDYW1sLk5hdGl2ZWludC50b19pbnQzMiB4KVxuICB8IDY0IC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQ2NF9wb3Bjb3VudCAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTaWduMFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoU2lnbjApXG5cbigqIE9wZW4gW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb25zIHNvXG4gICB0aGV5IGRvIG5vdCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvblxuICB8IE5lZyAtPiAtMS5cbiAgfCBaZXJvIC0+IDAuXG4gIHwgUG9zIC0+IDEuXG47O1xuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbjs7XG5cbmxldCAoICogKSB0IHQnID0gb2ZfaW50ICh0b19pbnQgdCAqIHRvX2ludCB0JylcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYXQgdGhlIGVuZCwgYWZ0ZXIgYW55XG4gICBmdW5jdG9yIGFwcGxpY2F0aW9ucyB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzb1xuICAgdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzXG4gICBtb2R1bGUuICopXG5pbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludF9pbnRmXG5pbmNsdWRlIEludDBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlIHggeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZSB4IHlcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIHRyeSBvZl9zdHJpbmcgcyB3aXRoXG4gICAgfCBfIC0+IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG5lbmRcblxubGV0IG51bV9iaXRzID0gSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgdG9fZmxvYXQgPSBDYW1sLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IENhbWwuaW50X29mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIENhbWwuaW50X29mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSAoIH4tIClcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJXhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiV4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50XCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5leHRlcm5hbCB0b19pbnQzMl90cnVuYyA6IHQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50MzJfdHJ1bmMgOiBpbnQzMiAtPiB0ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2ludDY0X3RydW5jIDogaW50NjQgLT4gdCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnRfdHJ1bmMgOiBuYXRpdmVpbnQgLT4gdCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuXG5sZXQgcHJlZCBpID0gaSAtIDFcbmxldCBzdWNjIGkgPSBpICsgMVxubGV0IHRvX2ludCBpID0gaVxubGV0IHRvX2ludF9leG4gPSB0b19pbnRcbmxldCBvZl9pbnQgaSA9IGlcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgbWF4X3ZhbHVlID0gQ2FtbC5tYXhfaW50XG5sZXQgbWluX3ZhbHVlID0gQ2FtbC5taW5faW50XG5sZXQgbWF4X3ZhbHVlXzMwX2JpdHMgPSAweDNGRkZfRkZGRlxubGV0IG9mX2ludDMyID0gQ29udi5pbnQzMl90b19pbnRcbmxldCBvZl9pbnQzMl9leG4gPSBDb252LmludDMyX3RvX2ludF9leG5cbmxldCB0b19pbnQzMiA9IENvbnYuaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5pbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9faW50X2V4blxubGV0IHRvX2ludDY0ID0gQ29udi5pbnRfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50X2V4blxubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50X3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBhYnMgeCA9IGFicyB4XG5cbigqIG5vdGUgdGhhdCByZW0gaXMgbm90IHNhbWUgYXMgJSAqKVxubGV0IHJlbSBhIGIgPSBhIG1vZCBiXG5sZXQgaW5jciA9IENhbWwuaW5jclxubGV0IGRlY3IgPSBDYW1sLmRlY3JcbmxldCBzaGlmdF9yaWdodCBhIGIgPSBhIGFzciBiXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCBhIGIgPSBhIGxzciBiXG5sZXQgc2hpZnRfbGVmdCBhIGIgPSBhIGxzbCBiXG5sZXQgYml0X25vdCBhID0gbG5vdCBhXG5sZXQgYml0X29yIGEgYiA9IGEgbG9yIGJcbmxldCBiaXRfYW5kIGEgYiA9IGEgbGFuZCBiXG5sZXQgYml0X3hvciBhIGIgPSBhIGx4b3IgYlxubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50X3Bvd1xubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IC0gMSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCArIDFcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggLSAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kICh4IC0gMSkgPSAwXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogICgqIE5vdGUgdGhhdCB3ZSBwYXNzIHRoZSB0YWdnZWQgaW50IGhlcmUuIFNlZSBpbnRfbWF0aF9zdHVicy5jIGZvciBkZXRhaWxzIG9uIHdoeVxuICAgICAgICAgIHRoaXMgaXMgY29ycmVjdC4gKilcbiAgICBpbnRcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6X3VudGFnZ2VkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50W0B1bnRhZ2dlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50X2N0el91bnRhZ2dlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIGlmIGkgPSAxIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChpIC0gMSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcblxubGV0IHNpZ24gPSBTaWduLm9mX2ludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50X3BvcGNvdW50XG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBleHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbiAgZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG4gIGV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuICBleHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbiAgZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5cbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiB0IC0+IHQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgbW9kdWxlIEYgPSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBpbmNsdWRlIEZcblxuICBleHRlcm5hbCBic3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuXG4gICgqIFRoZXNlIGlubGluZWQgdmVyc2lvbnMgb2YgKCUpLCAoLyUpLCBhbmQgKC8vKSBwZXJmb3JtIGJldHRlciB0aGFuIHRoZWlyIGZ1bmN0b3JpemVkXG4gICAgIGNvdW50ZXJwYXJ0cyBpbiBbRl0gKHNlZSBiZW5jaG1hcmtzIGJlbG93KS5cblxuICAgICBUaGUgcmVhc29uIHRoZXNlIGZ1bmN0aW9ucyBhcmUgaW5saW5lZCBpbiBbSW50XSBidXQgbm90IGluIGFueSBvZiB0aGUgb3RoZXIgaW50ZWdlclxuICAgICBtb2R1bGVzIGlzIHRoYXQgdGhleSBleGlzdGVkIGluIFtJbnRdIGFuZCBbSW50XSBhbG9uZSBwcmlvciB0byB0aGUgaW50cm9kdWN0aW9uIG9mXG4gICAgIHRoZSBbSW50X21hdGguTWFrZV0gZnVuY3RvciwgYW5kIHdlIGRpZG4ndCB3YW50IHRvIGRlZ3JhZGUgdGhlaXIgcGVyZm9ybWFuY2UuXG5cbiAgICAgV2Ugd29uJ3QgcHJlLWVtcHRpdmVseSBkbyB0aGUgc2FtZSBmb3IgbmV3IGZ1bmN0aW9ucywgdW5sZXNzIHNvbWVvbmUgY2FyZXMsIG9uIGEgY2FzZVxuICAgICBieSBjYXNlIGZhc2hpb24uICAqKVxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAlJSAlcyBpbiBjb3JlX2ludC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgbGV0IHJ2YWwgPSByZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgKCAvJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gIGxldCAoIC8vICkgeCB5ID0gdG9fZmxvYXQgeCAvLiB0b19mbG9hdCB5XG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG4gIGV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbiAgbGV0IGxub3QgPSBsbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbiAgZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbiAgZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludF0gYW5kIFtJbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgT19GID0gTy5GXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yXG4gICBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgVWNoYXIwXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyXCJcbiAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBIYXNoLmZvbGRfaW50IHN0YXRlICh0b19pbnQgdClcbiAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgbGV0IHRvX3N0cmluZyB0ID0gUHJpbnRmLnNwcmludGYgXCJVKyUwNFhcIiAodG9faW50IHQpXG5cbiAgKCogRG8gbm90IGFjdHVhbGx5IGV4cG9ydCB0aGlzLiBTZWUgZGlzY3Vzc2lvbiBpbiB0aGUgLm1saSAqKVxuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAodG9fc3RyaW5nIHQpXG5cbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJVY2hhci50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuICAgIHwgU2V4cC5BdG9tIHMgLT5cbiAgICAgICh0cnkgQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIlUrJVhcIiAoZnVuIGkgLT4gVWNoYXIwLm9mX2ludCBpKSB3aXRoXG4gICAgICAgfCBfIC0+IG9mX3NleHBfZXJyb3IgXCJVY2hhci50X29mX3NleHA6IGF0b20gb2YgdGhlIGZvcm0gVStYWFhYIG5lZWRlZFwiIHNleHApXG4gIDs7XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgaW50X2lzX3NjYWxhciA9IGlzX3ZhbGlkXG5cbmxldCBzdWNjX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5zdWNjIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnN1Y2NfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHN1Y2MgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAuc3VjYyBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBwcmVkX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5wcmVkIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnByZWRfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHByZWQgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAucHJlZCBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBvZl9zY2FsYXIgaSA9IGlmIGludF9pc19zY2FsYXIgaSB0aGVuIFNvbWUgKHVuc2FmZV9vZl9pbnQgaSkgZWxzZSBOb25lXG5cbmxldCBvZl9zY2FsYXJfZXhuIGkgPVxuICBpZiBpbnRfaXNfc2NhbGFyIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci5vZl9pbnRfZXhuIGdvdCBhIGludmFsaWQgVW5pY29kZSBzY2FsYXIgdmFsdWU6ICUwNFhcIiBpICgpXG47O1xuXG5sZXQgdG9fc2NhbGFyIHQgPSBVY2hhcjAudG9faW50IHRcbmxldCB0b19jaGFyIGMgPSBpZiBpc19jaGFyIGMgdGhlbiBTb21lICh1bnNhZmVfdG9fY2hhciBjKSBlbHNlIE5vbmVcblxubGV0IHRvX2NoYXJfZXhuIGMgPVxuICBpZiBpc19jaGFyIGNcbiAgdGhlbiB1bnNhZmVfdG9fY2hhciBjXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIudG9fY2hhcl9leG4gZ290IGEgbm9uIGxhdGluLTEgY2hhcmFjdGVyOiBVKyUwNFhcIiAodG9faW50IGMpICgpXG47O1xuXG5sZXQgdXRmOF9ieXRlX2xlbmd0aCB1Y2hhciA9XG4gIGxldCBjb2RlcG9pbnQgPSB0b19zY2FsYXIgdWNoYXIgaW5cbiAgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDgwXG4gIHRoZW4gMVxuICBlbHNlIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHg4MDBcbiAgdGhlbiAyXG4gIGVsc2UgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDEwMDAwXG4gIHRoZW4gM1xuICBlbHNlIDRcbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ2IpIHQgPSBUIDogKCdhLCAnYSkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6XG4gICdhICdiLlxuICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBhX18wMDNfIGJfXzAwNF8pXG4gICAgICA6ICAoKGFfXzAwM18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDA0XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGFfXzAwM18sIGJfXzAwNF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2ZfYl9fMDAyXyBUIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlRcIlxuOztcblxuW0BAQGVuZF1cblxudHlwZSAoJ2EsICdiKSBlcXVhbCA9ICgnYSwgJ2IpIHRcblxubGV0IHJlZmwgPSBUXG5sZXQgc3ltICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYiwgYSkgdCA9IFRcbmxldCB0cmFucyAodHlwZSBhIGIgYykgKFQgOiAoYSwgYikgdCkgKFQgOiAoYiwgYykgdCkgOiAoYSwgYykgdCA9IFRcbmxldCBjb252ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgKGEgOiBhKSA6IGIgPSBhXG5cbm1vZHVsZSBMaWZ0IChYIDogc2lnXG4gICAgdHlwZSAnYSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYSBYLnQsIGIgWC50KSB0ID0gVFxuZW5kXG5cbm1vZHVsZSBMaWZ0MiAoWCA6IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyKSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGExIGIxIGEyIGIyKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdClcbiAgICA6ICgoYTEsIGEyKSBYLnQsIChiMSwgYjIpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubW9kdWxlIExpZnQzIChYIDogc2lnXG4gICAgdHlwZSAoJ2ExLCAnYTIsICdhMykgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMiBhMyBiMykgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIChUIDogKGEzLCBiMykgdClcbiAgICA6ICgoYTEsIGEyLCBhMykgWC50LCAoYjEsIGIyLCBiMykgWC50KSB0XG4gICAgPVxuICAgIFRcbiAgOztcbmVuZFxuXG5sZXQgZGV0dXBsZTIgKHR5cGUgYTEgYTIgYjEgYjIpIChUIDogKGExICogYTIsIGIxICogYjIpIHQpIDogKGExLCBiMSkgdCAqIChhMiwgYjIpIHQgPVxuICBULCBUXG47O1xuXG5sZXQgdHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdCkgOiAoYTEgKiBhMiwgYjEgKiBiMikgdCA9IFRcblxubW9kdWxlIHR5cGUgSW5qZWN0aXZlID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBzdHJpcCA6ICgnYSB0LCAnYiB0KSBlcXVhbCAtPiAoJ2EsICdiKSBlcXVhbFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluamVjdGl2ZTIgPSBzaWdcbiAgdHlwZSAoJ2ExLCAnYTIpIHRcblxuICB2YWwgc3RyaXAgOiAoKCdhMSwgJ2EyKSB0LCAoJ2IxLCAnYjIpIHQpIGVxdWFsIC0+ICgnYTEsICdiMSkgZXF1YWwgKiAoJ2EyLCAnYjIpIGVxdWFsXG5lbmRcblxubW9kdWxlIENvbXBvc2l0aW9uX3ByZXNlcnZlc19pbmplY3Rpdml0eSAoTTEgOiBJbmplY3RpdmUpIChNMiA6IEluamVjdGl2ZSkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgTTEudCBNMi50XG5cbiAgbGV0IHN0cmlwIGUgPSBNMS5zdHJpcCAoTTIuc3RyaXAgZSlcbmVuZFxuXG5tb2R1bGUgSWQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVpZCA9IEludFxuXG4gIG1vZHVsZSBXaXRuZXNzID0gc3RydWN0XG4gICAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgICAgdHlwZSBfIHQgPSAuLlxuICAgICAgdHlwZSB0eXBlX3dpdG5lc3NfaW50ID0gWyBgdHlwZV93aXRuZXNzIG9mIGludCBdIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICBsZXQgc2V4cF9vZl90eXBlX3dpdG5lc3NfaW50ID1cbiAgICAgICAgKGZ1biAoYHR5cGVfd2l0bmVzcyB2X18wMDVfKSAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJ0eXBlX3dpdG5lc3NcIjsgc2V4cF9vZl9pbnQgdl9fMDA1XyBdXG4gICAgICAgICAgIDogdHlwZV93aXRuZXNzX2ludCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICA7O1xuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICBsZXQgc2V4cF9vZl90IF9zZXhwX29mX2EgdCA9XG4gICAgICAgIGB0eXBlX3dpdG5lc3NcbiAgICAgICAgICAoQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIHQpKVxuICAgICAgICB8PiBzZXhwX29mX3R5cGVfd2l0bmVzc19pbnRcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgXyBLZXkudCArPSBLZXkgOiB0IEtleS50XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSlcblxuICAgIGxldCBzZXhwX29mX3QgKHR5cGUgYSkgc2V4cF9vZl9hIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgICBNLktleSB8PiBLZXkuc2V4cF9vZl90IHNleHBfb2ZfYVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlICh0eXBlIHQpICgpID1cbiAgICAgIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuICAgICAgICB0eXBlIF8gS2V5LnQgKz0gS2V5IDogdCBLZXkudFxuICAgICAgZW5kXG4gICAgICBpblxuICAgICAgKG1vZHVsZSBNIDogUyB3aXRoIHR5cGUgdCA9IHQpXG4gICAgOztcblxuICAgIGxldCB1aWQgKHR5cGUgYSkgKG1vZHVsZSBNIDogUyB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICAgIENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBNLktleSlcbiAgICA7O1xuXG4gICAgKCogV2Ugd2FudCBhIGNvbnN0YW50IGFsbG9jYXRlZCBvbmNlIHRoYXQgW3NhbWVdIGNhbiByZXR1cm4gd2hlbmV2ZXIgaXQgZ2V0cyB0aGUgc2FtZVxuICAgICAgIHdpdG5lc3Nlcy4gIElmIHdlIHdyaXRlIHRoZSBjb25zdGFudCBpbnNpZGUgdGhlIGJvZHkgb2YgW3NhbWVdLCB0aGUgbmF0aXZlLWNvZGVcbiAgICAgICBjb21waWxlciB3aWxsIGRvIHRoZSByaWdodCB0aGluZyBhbmQgbGlmdCBpdCBvdXQuICBCdXQgZm9yIGNsYXJpdHkgYW5kIHJvYnVzdG5lc3MsXG4gICAgICAgd2UgZG8gaXQgb3Vyc2VsdmVzLiAqKVxuICAgIGxldCBzb21lX3QgPSBTb21lIFRcblxuICAgIGxldCBzYW1lICh0eXBlIGEgYikgKGEgOiBhIHQpIChiIDogYiB0KSA6IChhLCBiKSBlcXVhbCBvcHRpb24gPVxuICAgICAgbGV0IG1vZHVsZSBBID0gKHZhbCBhIDogUyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEIgPSAodmFsIGIgOiBTIHdpdGggdHlwZSB0ID0gYikgaW5cbiAgICAgIG1hdGNoIEEuS2V5IHdpdGhcbiAgICAgIHwgQi5LZXkgLT4gc29tZV90XG4gICAgICB8IF8gLT4gTm9uZVxuICAgIDs7XG4gIGVuZFxuXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IHdpdG5lc3MgOiAnYSBXaXRuZXNzLnRcbiAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICA7IHRvX3NleHAgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCBfIHsgd2l0bmVzczsgbmFtZTsgdG9fc2V4cCB9IDogU2V4cC50ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiBBdG9tIG5hbWVcbiAgICBlbHNlXG4gICAgICBMaXN0XG4gICAgICAgIFsgTGlzdCBbIEF0b20gXCJuYW1lXCI7IEF0b20gbmFtZSBdXG4gICAgICAgIDsgTGlzdCBbIEF0b20gXCJ3aXRuZXNzXCI7IHdpdG5lc3MgfD4gV2l0bmVzcy5zZXhwX29mX3QgdG9fc2V4cCBdXG4gICAgICAgIF1cbiAgOztcblxuICBsZXQgdG9fc2V4cCB0ID0gdC50b19zZXhwXG4gIGxldCBuYW1lIHQgPSB0Lm5hbWVcbiAgbGV0IGNyZWF0ZSB+bmFtZSB0b19zZXhwID0geyB3aXRuZXNzID0gV2l0bmVzcy5jcmVhdGUgKCk7IG5hbWU7IHRvX3NleHAgfVxuICBsZXQgdWlkIHQgPSBXaXRuZXNzLnVpZCB0LndpdG5lc3NcbiAgbGV0IGhhc2ggdCA9IHVpZCB0XG4gIGxldCBoYXNoX2ZvbGRfdCBzIHQgPSBoYXNoX2ZvbGRfaW50IHMgKHVpZCB0KVxuICBsZXQgc2FtZV93aXRuZXNzIHQxIHQyID0gV2l0bmVzcy5zYW1lIHQxLndpdG5lc3MgdDIud2l0bmVzc1xuICBsZXQgc2FtZSB0MSB0MiA9IE9wdGlvbi5pc19zb21lIChzYW1lX3dpdG5lc3MgdDEgdDIpXG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gdDEgdDIgPVxuICAgIG1hdGNoIHNhbWVfd2l0bmVzcyB0MSB0MiB3aXRoXG4gICAgfCBTb21lIHcgLT4gd1xuICAgIHwgTm9uZSAtPlxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIGdvdCBkaWZmZXJlbnQgaWRzXCJcbiAgICAgICAgICAgWyAoIFwiXCJcbiAgICAgICAgICAgICAsIHNleHBfb2ZfcGFpciAoc2V4cF9vZl90IHNleHBfb2Zfb3BhcXVlKSAoc2V4cF9vZl90IHNleHBfb2Zfb3BhcXVlKSAodDEsIHQyKVxuICAgICAgICAgICAgIClcbiAgICAgICAgICAgXSlcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqKiBbJ2EgQ2hlYXBfb3B0aW9uLnRdIGlzIGxpa2UgWydhIG9wdGlvbl0sIGJ1dCBpdCBkb2Vzbid0IGJveCBbc29tZSBfXSB2YWx1ZXMuXG5cbiAgICBUaGVyZSBhcmUgc2V2ZXJhbCB0aGluZ3MgdGhhdCBhcmUgdW5zYWZlIGFib3V0IGl0OlxuXG4gICAgLSBbZmxvYXQgdCBhcnJheV0gKG9yIGFueSBhcnJheS1iYWNrZWQgY29udGFpbmVyKSBpcyBub3QgbWVtb3J5LXNhZmVcbiAgICAgIGJlY2F1c2UgZmxvYXQgYXJyYXkgb3B0aW1pemF0aW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHVuYm94ZWQgb3B0aW9uXG4gICAgICBvcHRpbWl6YXRpb24uIFlvdSBoYXZlIHRvIHVzZSBbVW5pZm9ybV9hcnJheS50XSBpbnN0ZWFkIG9mIFthcnJheV0uXG5cbiAgICAtIE5lc3RlZCBvcHRpb25zIChbJ2EgdCB0XSkgZG9uJ3Qgd29yay4gVGhleSBhcmUgYmVsaWV2ZWQgdG8gYmVcbiAgICAgIG1lbW9yeS1zYWZlLCBidXQgbm90IHBhcmFtZXRyaWMuXG5cbiAgICAtIEEgcmVjb3JkIHdpdGggW2Zsb2F0IHRdcyBpbiBpdCBzaG91bGQgYmUgc2FmZSwgYnV0IGl0J3Mgb25seSBbdF0gYmVpbmdcbiAgICAgIGFic3RyYWN0IHRoYXQgZ2l2ZXMgeW91IHNhZmV0eS4gSWYgdGhlIGNvbXBpbGVyIHdhcyBzbWFydCBlbm91Z2ggdG8gcGVla1xuICAgICAgdGhyb3VnaCB0aGUgbW9kdWxlIHNpZ25hdHVyZSB0aGVuIGl0IGNvdWxkIGRlY2lkZSB0byBjb25zdHJ1Y3QgYSBmbG9hdFxuICAgICAgYXJyYXkgaW5zdGVhZC4gKilcbm1vZHVsZSBDaGVhcF9vcHRpb24gPSBzdHJ1Y3RcbiAgKCogVGhpcyBpcyB0YWtlbiBmcm9tIGNvcmUuIFJhdGhlciB0aGFuIGV4cG9zZSBpdCBpbiB0aGUgcHVibGljIGludGVyZmFjZSBvZiBiYXNlLCBqdXN0XG4gICAgIGtlZXAgYSBjb3B5IGFyb3VuZCBoZXJlLiAqKVxuICBsZXQgcGh5c19zYW1lICh0eXBlIGEgYikgKGEgOiBhKSAoYiA6IGIpID0gcGh5c19lcXVhbCBhIChDYW1sLk9iai5tYWdpYyBiIDogYSlcblxuICBtb2R1bGUgVDAgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBub25lIDogXyB0XG4gICAgdmFsIHNvbWUgOiAnYSAtPiAnYSB0XG4gICAgdmFsIGlzX25vbmUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCBpc19zb21lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgdmFsdWVfZXhuIDogJ2EgdCAtPiAnYVxuICAgIHZhbCB2YWx1ZV91bnNhZmUgOiAnYSB0IC0+ICdhXG4gICAgdmFsIGl0ZXJfc29tZSA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICsnYSB0XG5cbiAgICAoKiBCZWluZyBhIHBvaW50ZXIsIG5vIG9uZSBvdXRzaWRlIHRoaXMgbW9kdWxlIGNhbiBjb25zdHJ1Y3QgYSB2YWx1ZSB0aGF0IGlzXG4gICAgICAgW3BoeXNfc2FtZV0gYXMgdGhpcyBvbmUuXG5cbiAgICAgICBJdCB3b3VsZCBiZSBzaW1wbGVyIHRvIHVzZSB0aGlzIHZhbHVlIGFzIFtub25lXSwgYnV0IHdlIHVzZSBhbiBpbW1lZGlhdGUgaW5zdGVhZFxuICAgICAgIGJlY2F1c2UgaXQgbGV0cyB1cyBhdm9pZCBjYW1sX21vZGlmeSB3aGVuIHNldHRpbmcgdG8gW25vbmVdLCBtYWtpbmcgY2VydGFpblxuICAgICAgIGJlbmNobWFya3Mgc2lnbmlmaWNhbnRseSBmYXN0ZXIgKGUuZy4gLi4vYmVuY2gvYXJyYXlfcXVldWUuZXhlKS5cblxuICAgICAgIHRoaXMgY29kZSBpcyBkdXBsaWNhdGVkIGluIE1vcHRpb24sIGFuZCBpZiB3ZSBmaW5kIHlldCBhbm90aGVyIHBsYWNlIHdoZXJlIHdlIHdhbnRcbiAgICAgICBpdCB3ZSBzaG91bGQgcmVjb25zaWRlciBtYWtpbmcgaXQgc2hhcmVkLiAqKVxuICAgIGxldCBub25lX3N1YnN0aXR1dGUgOiBfIHQgPSBDYW1sLk9iai5vYmogKENhbWwuT2JqLm5ld19ibG9jayBDYW1sLk9iai5hYnN0cmFjdF90YWcgMSlcblxuICAgIGxldCBub25lIDogXyB0ID1cbiAgICAgICgqIFRoZSBudW1iZXIgd2FzIHByb2R1Y2VkIGJ5XG4gICAgICAgICBbPCAvZGV2L3VyYW5kb20gdHIgLWMgLWQgJzEyMzQ1Njc4OTBhYmNkZWYnIHwgaGVhZCAtYyAxNl0uXG5cbiAgICAgICAgIFRoZSBpZGVhIGlzIHRoYXQgYSByYW5kb20gbnVtYmVyIHdpbGwgaGF2ZSBsb3dlciBwcm9iYWJpbGl0eSB0byBjb2xsaWRlIHdpdGhcbiAgICAgICAgIGFueXRoaW5nIHRoYW4gYW55IG51bWJlciB3ZSBjYW4gY2hvb3NlIG91cnNlbHZlcy5cblxuICAgICAgICAgV2UgYXJlIHVzaW5nIGEgcG9seW1vcnBoaWMgdmFyaWFudCBpbnN0ZWFkIG9mIGFuIGludGVnZXIgY29uc3RhbnQgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgaXMgYSBjb21waWxlciBidWcgd2hlcmUgaXQgd3JvbmdseSBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdCBvZiBbaWYgXyB0aGVuIGMgZWxzZVxuICAgICAgICAgeV0gaXMgbm90IGEgcG9pbnRlciBpZiBbY10gaXMgYW4gaW50ZWdlciBjb21waWxlLXRpbWUgY29uc3RhbnQuICBUaGlzIGlzIGJlaW5nXG4gICAgICAgICBmaXhlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvcHVsbC81NTUuICBUaGUgXCJtZW1vcnkgY29ycnVwdGlvblwiIHRlc3RcbiAgICAgICAgIGJlbG93IGRlbW9uc3RyYXRlcyB0aGUgaXNzdWUuICAqKVxuICAgICAgQ2FtbC5PYmoubWFnaWMgYHg2ZThlZTM0NzhlMWQ3NDQ5XG4gICAgOztcblxuICAgIGxldCBpc19ub25lIHggPSBwaHlzX2VxdWFsIHggbm9uZVxuICAgIGxldCBpc19zb21lIHggPSBub3QgKHBoeXNfZXF1YWwgeCBub25lKVxuXG4gICAgbGV0IHNvbWUgKHR5cGUgYSkgKHggOiBhKSA6IGEgdCA9XG4gICAgICBpZiBwaHlzX3NhbWUgeCBub25lIHRoZW4gbm9uZV9zdWJzdGl0dXRlIGVsc2UgQ2FtbC5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfdW5zYWZlICh0eXBlIGEpICh4IDogYSB0KSA6IGEgPVxuICAgICAgaWYgcGh5c19lcXVhbCB4IG5vbmVfc3Vic3RpdHV0ZSB0aGVuIENhbWwuT2JqLm1hZ2ljIG5vbmUgZWxzZSBDYW1sLk9iai5tYWdpYyB4XG4gICAgOztcblxuICAgIGxldCB2YWx1ZV9leG4geCA9XG4gICAgICBpZiBpc19zb21lIHhcbiAgICAgIHRoZW4gdmFsdWVfdW5zYWZlIHhcbiAgICAgIGVsc2UgZmFpbHdpdGggXCJPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuOiB0aGUgZWxlbWVudCBpcyBbTm9uZV1cIlxuICAgIDs7XG5cbiAgICBsZXQgaXRlcl9zb21lIHQgfmYgPSBpZiBpc19zb21lIHQgdGhlbiBmICh2YWx1ZV91bnNhZmUgdClcbiAgZW5kXG5cbiAgbW9kdWxlIFQxID0gc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuXG4gICAgbGV0IG9mX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgfCBTb21lIHggLT4gc29tZSB4XG4gICAgOztcblxuICAgIGxldFtAaW5saW5lXSB0b19vcHRpb24geCA9IGlmIGlzX3NvbWUgeCB0aGVuIFNvbWUgKHZhbHVlX3Vuc2FmZSB4KSBlbHNlIE5vbmVcbiAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19vcHRpb25cbiAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9vcHRpb25cblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgPVxuICAgICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoT3B0aW9uLnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG4gICAgOztcbiAgZW5kXG5cbiAgaW5jbHVkZSBUMVxuICBpbmNsdWRlIFNleHBhYmxlLk9mX3NleHBhYmxlMSAoT3B0aW9uKSAoVDEpXG5lbmRcblxudHlwZSAnYSB0ID0gJ2EgQ2hlYXBfb3B0aW9uLnQgVW5pZm9ybV9hcnJheS50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAwMV8geF9fMDAzXyAtPlxuICBVbmlmb3JtX2FycmF5LnRfb2Zfc2V4cCAoQ2hlYXBfb3B0aW9uLnRfb2Zfc2V4cCBfb2ZfYV9fMDAxXykgeF9fMDAzX1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDA0XyB4X18wMDVfIC0+XG4gIFVuaWZvcm1fYXJyYXkuc2V4cF9vZl90IChDaGVhcF9vcHRpb24uc2V4cF9vZl90IF9vZl9hX18wMDRfKSB4X18wMDVfXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICBVbmlmb3JtX2FycmF5LnRfc2V4cF9ncmFtbWFyIChDaGVhcF9vcHRpb24udF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hcilcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBlbXB0eSA9IFVuaWZvcm1fYXJyYXkuZW1wdHlcbmxldCBjcmVhdGUgfmxlbiA9IFVuaWZvcm1fYXJyYXkuY3JlYXRlIH5sZW4gQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBpbml0IG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiAoZiBpKSlcbmxldCBpbml0X3NvbWUgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24uc29tZSAoZiBpKSlcbmxldCBsZW5ndGggPSBVbmlmb3JtX2FycmF5Lmxlbmd0aFxubGV0W0BpbmxpbmVdIGdldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19ub25lIHQgaSA9IENoZWFwX29wdGlvbi5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfc29tZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfc29tZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IHNldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiB4KVxubGV0IHNldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHNldF9ub25lIHQgaSA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxubGV0IHN3YXAgdCBpIGogPSBVbmlmb3JtX2FycmF5LnN3YXAgdCBpIGpcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX2dldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgdW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUgdCBpID1cbiAgQ2hlYXBfb3B0aW9uLnZhbHVlX3Vuc2FmZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbjs7XG5cbmxldCB1bnNhZmVfaXNfc29tZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfc29tZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiB4KVxubGV0IHVuc2FmZV9zZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgdW5zYWZlX3NldF9ub25lIHQgaSA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcblxubGV0IGNsZWFyIHQgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldF9ub25lIHQgaVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgaW5wdXQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGlucHV0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBpbnB1dCBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlciBpbnB1dCB+ZiA9IGl0ZXJpIGlucHV0IH5mOihmdW4gKF8gOiBpbnQpIHggLT4gZiB4KVxuXG5sZXQgZm9sZGkgaW5wdXQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gYWNjIDo9IGYgaSAhYWNjIGVsZW0pO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZCBpbnB1dCB+aW5pdCB+ZiA9IGZvbGRpIGlucHV0IH5pbml0IH5mOihmdW4gKF8gOiBpbnQpIGFjYyB4IC0+IGYgYWNjIHgpXG5cbmluY2x1ZGUgSW5kZXhlZF9jb250YWluZXIuTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG4gICAgdHlwZSAnYSBlbHQgPSAnYSBvcHRpb25cblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBmb2xkaSA9IGBDdXN0b20gZm9sZGlcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgZW5kKVxuXG5sZXQgbWFwaSBpbnB1dCB+ZiA9XG4gIGxldCBvdXRwdXQgPSBjcmVhdGUgfmxlbjoobGVuZ3RoIGlucHV0KSBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiB1bnNhZmVfc2V0IG91dHB1dCBpIChmIGkgZWxlbSkpO1xuICBvdXRwdXRcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBpIGlucHV0IH5mOihmdW4gKF8gOiBpbnQpIGVsZW0gLT4gZiBlbGVtKVxuXG5sZXQgbWFwX3NvbWUgaW5wdXQgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0IGluXG4gIGxldCBvdXRwdXQgPSBjcmVhdGUgfmxlbiBpblxuICBsZXQgKCkgPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgb3B0ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IGlucHV0IGkgaW5cbiAgICAgIENoZWFwX29wdGlvbi5pdGVyX3NvbWUgb3B0IH5mOihmdW4geCAtPiB1bnNhZmVfc2V0X3NvbWUgb3V0cHV0IGkgKGYgeCkpXG4gICAgZG9uZVxuICBpblxuICBvdXRwdXRcbjs7XG5cbmxldCBvZl9hcnJheSBhcnJheSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhcnJheSkgfmY6KGZ1biBpIC0+IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSlcblxubGV0IG9mX2FycmF5X3NvbWUgYXJyYXkgPVxuICBpbml0X3NvbWUgKEFycmF5Lmxlbmd0aCBhcnJheSkgfmY6KGZ1biBpIC0+IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSlcbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxuaW5jbHVkZSBCbGl0Lk1ha2UxX2dlbmVyaWMgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBjb3B5ID0gVW5pZm9ybV9hcnJheS5jb3B5XG5cbm1vZHVsZSBGb3JfdGVzdGluZyA9IHN0cnVjdFxuICBtb2R1bGUgVW5zYWZlX2NoZWFwX29wdGlvbiA9IENoZWFwX29wdGlvblxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU3RhY2tfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIFtEZXF1ZV0gaW4gdGhhdCBpdCB1c2VzIGFuIGFycmF5IG9mIFsnYV0gYW5kXG4gICBhIG11dGFibGUgW2ludF0gdG8gaW5kaWNhdGUgd2hhdCBpbiB0aGUgYXJyYXkgaXMgdXNlZC4gIFdlIGNob29zZSB0byBpbXBsZW1lbnQgW1N0YWNrXVxuICAgZGlyZWN0bHkgcmF0aGVyIHRoYW4gb24gdG9wIG9mIFtEZXF1ZV0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBFLmcuIGEgc2ltcGxlXG4gICBtaWNyb2JlbmNobWFyayBzaG93cyB0aGF0IHB1c2gvcG9wIGlzIGFib3V0IDIwJSBmYXN0ZXIuICopXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV8geyBsZW5ndGggPSBsZW5ndGhfXzAwM187IGVsdHMgPSBlbHRzX18wMDVfIH0gLT5cbiAgbGV0IGJuZHNfXzAwMl8gPSBbXSBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA2XyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDA1XyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImVsdHNcIjsgYXJnX18wMDZfIF0gOjogYm5kc19fMDAyX1xuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA0XyA9IHNleHBfb2ZfaW50IGxlbmd0aF9fMDAzXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gIGluXG4gIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDJfXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG5sZXQgc2V4cF9vZl90ID0gYFJlYm91bmRfbGF0ZXJcbmxldCBfID0gc2V4cF9vZl90XG5sZXQgY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgKHsgbGVuZ3RoOyBlbHRzIH0gYXMgdCkgOiB1bml0ID1cbiAgdHJ5XG4gICAgYXNzZXJ0ICgwIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgICAgaW52YXJpYW50X2EgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBpKVxuICAgIGRvbmU7XG4gICAgKCogV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHVudXNlZCBlbGVtZW50cyBhcmUgdW5zZXQgdG8gYXZvaWQgYSBzcGFjZVxuICAgICAgIGxlYWsuICopXG4gICAgZm9yIGkgPSBsZW5ndGggdG8gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzIC0gMSBkb1xuICAgICAgYXNzZXJ0IChub3QgKE9wdGlvbl9hcnJheS5pc19zb21lIGVsdHMgaSkpXG4gICAgZG9uZVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJTdGFjay5pbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJleG5cIiwgZXhuIHw+IEV4bi5zZXhwX29mX3Q7IFwic3RhY2tcIiwgdCB8PiBzZXhwX29mX3RfaW50ZXJuYWwgc2V4cF9vZl9vcGFxdWUgXSlcbjs7XG5cbmxldCBjcmVhdGUgKHR5cGUgYSkgKCkgOiBhIHQgPSB7IGxlbmd0aCA9IDA7IGVsdHMgPSBPcHRpb25fYXJyYXkuZW1wdHkgfVxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbigqIFRoZSBvcmRlciBpbiB3aGljaCBlbGVtZW50cyBhcmUgdmlzaXRlZCBoYXMgYmVlbiBjaG9zZW4gc28gYXMgdG8gYmUgYmFja3dhcmRzXG4gICBjb21wYXRpYmxlIHdpdGggW0NhbWwuU3RhY2tdICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAhciAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2xpc3QgKHR5cGUgYSkgKGwgOiBhIGxpc3QpID1cbiAgaWYgTGlzdC5pc19lbXB0eSBsXG4gIHRoZW4gY3JlYXRlICgpXG4gIGVsc2UgKFxuICAgIGxldCBsZW5ndGggPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46KDIgKiBsZW5ndGgpIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIE9wdGlvbl9hcnJheS5zZXRfc29tZSBlbHRzIGkgYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB7IGxlbmd0aDsgZWx0cyB9KVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCByZXNpemUgdCBzaXplID1cbiAgbGV0IGFyciA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpzaXplIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5zcmM6dC5lbHRzIH5kc3Q6YXJyIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnQubGVuZ3RoO1xuICB0LmVsdHMgPC0gYXJyXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgbmV3X2NhcGFjaXR5ID1cbiAgbGV0IG5ld19jYXBhY2l0eSA9IG1heCBuZXdfY2FwYWNpdHkgKGxlbmd0aCB0KSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdCB0aGVuIHJlc2l6ZSB0IG5ld19jYXBhY2l0eVxuOztcblxubGV0IHB1c2ggdCBhID1cbiAgaWYgdC5sZW5ndGggPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyB0aGVuIHJlc2l6ZSB0ICgyICogKHQubGVuZ3RoICsgMSkpO1xuICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgdC5lbHRzIHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9ub25lbXB0eSB0ID1cbiAgbGV0IGkgPSB0Lmxlbmd0aCAtIDEgaW5cbiAgbGV0IHJlc3VsdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpO1xuICB0Lmxlbmd0aCA8LSBpO1xuICByZXN1bHRcbjs7XG5cbmxldCBwb3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay5wb3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHBvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3Bfbm9uZW1wdHkgdClcbmxldCBwb3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgcG9wX2Vycm9yIGVsc2UgcG9wX25vbmVtcHR5IHRcbmxldCB0b3Bfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzICh0Lmxlbmd0aCAtIDEpXG5sZXQgdG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sudG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCB0b3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX25vbmVtcHR5IHQpXG5sZXQgdG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHRvcF9lcnJvciBlbHNlIHRvcF9ub25lbXB0eSB0XG5sZXQgY29weSB7IGxlbmd0aDsgZWx0cyB9ID0geyBsZW5ndGg7IGVsdHMgPSBPcHRpb25fYXJyYXkuY29weSBlbHRzIH1cblxubGV0IGNsZWFyIHQgPVxuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwKVxuOztcblxubGV0IHVudGlsX2VtcHR5IHQgZiA9XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBmIChwb3Bfbm9uZW1wdHkgdCk7XG4gICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpXG47O1xuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBwdXNoIHQgeDtcbiAgdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBUaGlzIGlzIGxpZnRlZCBvdXQgb2YgW01dIGJlY2F1c2UgW1NvdXJjZV9jb2RlX3Bvc2l0aW9uMF0gZXhwb3J0cyBbU3RyaW5nMF1cbiAgIGFzIFtTdHJpbmddLCB3aGljaCBkb2VzIG5vdCBleHBvcnQgYSBoYXNoIGZ1bmN0aW9uLiAqKVxubGV0IGhhc2hfb3ZlcnJpZGUgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfYm9sOyBwb3NfY251bSB9ID1cbiAgU3RyaW5nLmhhc2ggcG9zX2ZuYW1lXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2xudW1cbiAgbHhvciBJbnQuaGFzaCBwb3NfYm9sXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2NudW1cbjs7XG5cbm1vZHVsZSBNID0gc3RydWN0XG4gIGluY2x1ZGUgU291cmNlX2NvZGVfcG9zaXRpb24wXG5cbiAgbGV0IGhhc2ggPSBoYXNoX292ZXJyaWRlXG5lbmRcblxuaW5jbHVkZSBNXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChNKVxuXG5sZXQgb2ZfcG9zIChwb3NfZm5hbWUsIHBvc19sbnVtLCBwb3NfY251bSwgXykgPVxuICB7IHBvc19mbmFtZTsgcG9zX2xudW07IHBvc19jbnVtOyBwb3NfYm9sID0gMCB9XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBOZWdcbiAgICB8IFplcm9cbiAgICB8IFBvc1xuICAgIHwgTmFuXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZV1cblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwic2lnbl9vcl9uYW4ubWwuVC50XCIgaW5cbiAgICAgZnVuY3Rpb25cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSAtPiBOZWdcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSAtPiBQb3NcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSAtPiBOYW5cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBOZWcgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmVnXCJcbiAgICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJOZWdcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTmFuXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIChmdW4gaHN2IGFyZyAtPlxuICAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICAgfCBOZWcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgICAgfCBaZXJvIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICAgIHwgUG9zIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgIHwgTmFuIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgM1xuICAgICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBhbGwgPSAoWyBOZWc7IFplcm87IFBvczsgTmFuIF0gOiB0IGxpc3QpXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG4gIGxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25fb3JfbmFuXCJcbmVuZFxuXG5tb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogVC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBULnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBULnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogVC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBULnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogVC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IFQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IG9mX3NpZ24gPSBmdW5jdGlvblxuICB8IFNpZ24uTmVnIC0+IE5lZ1xuICB8IFNpZ24uWmVybyAtPiBaZXJvXG4gIHwgU2lnbi5Qb3MgLT4gUG9zXG47O1xuXG5sZXQgdG9fc2lnbl9leG4gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBTaWduLk5lZ1xuICB8IFplcm8gLT4gU2lnbi5aZXJvXG4gIHwgUG9zIC0+IFNpZ24uUG9zXG4gIHwgTmFuIC0+IGludmFsaWRfYXJnIFwiQmFzZS5TaWduX29yX25hbi50b19zaWduX2V4bjogTmFuXCJcbjs7XG5cbmxldCBvZl9pbnQgbiA9IG9mX3NpZ24gKFNpZ24ub2ZfaW50IG4pXG5sZXQgdG9faW50X2V4biB0ID0gU2lnbi50b19pbnQgKHRvX3NpZ25fZXhuIHQpXG5cbmxldCBmbGlwID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gUG9zXG4gIHwgWmVybyAtPiBaZXJvXG4gIHwgUG9zIC0+IE5lZ1xuICB8IE5hbiAtPiBOYW5cbjs7XG5cbmxldCAoICogKSB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5hbiwgXyB8IF8sIE5hbiAtPiBOYW5cbiAgfCBfIC0+IG9mX3NpZ24gKFNpZ24uKCAqICkgKHRvX3NpZ25fZXhuIHQpICh0b19zaWduX2V4biB0JykpXG47O1xuXG4oKiBJbmNsdWRlIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGFueSBmdW5jdG9yIGFwcGxpY2F0aW9ucyB0aGF0XG4gICBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9XG4gIHwgSW5jbCBvZiAnYVxuICB8IEV4Y2wgb2YgJ2FcbiAgfCBVbmJvdW5kZWRcbltAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGFsbCA6ICdhLiAnYSBsaXN0IC0+ICdhIHQgbGlzdCA9XG4gIGZ1biBfYWxsX29mX2EgLT5cbiAgUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgfCBlbnVtZXJhdGVfXzAwMV8gOjogbCAtPiBtYXAgbCAoSW5jbCBlbnVtZXJhdGVfXzAwMV8gOjogYWNjKVxuICAgICBpblxuICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgIChQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICAgICB8IGVudW1lcmF0ZV9fMDAyXyA6OiBsIC0+IG1hcCBsIChFeGNsIGVudW1lcmF0ZV9fMDAyXyA6OiBhY2MpXG4gICAgICAgIGluXG4gICAgICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgICAgWyBVbmJvdW5kZWQgXSlcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDE4XykgOiAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XyB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMDZfID0gXCJtYXliZV9ib3VuZC5tbC50XCIgaW5cbiAgZnVuIF9vZl9hX18wMDNfIC0+IGZ1bmN0aW9uXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIF90YWdfXzAwOV8pIDo6IHNleHBfYXJnc19fMDEwXykgYXNcbiAgICAgIF9zZXhwX18wMDhfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTBfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDExXyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgIEluY2wgcmVzMF9fMDEyX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDA5X1xuICAgICAgICAgICBfc2V4cF9fMDA4XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgX3RhZ19fMDE0XykgOjogc2V4cF9hcmdzX18wMTVfKSBhc1xuICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNV8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTZfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2FfXzAwM18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgRXhjbCByZXMwX18wMTdfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMTRfXG4gICAgICAgICAgIF9zZXhwX18wMTNfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgLT4gVW5ib3VuZGVkXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSA6OiBfKSBhc1xuICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuICh0eXBlIGFfXzAyNF8pIDogKChhX18wMjRfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gYV9fMDI0XyB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgZnVuIF9vZl9hX18wMTlfIC0+IGZ1bmN0aW9uXG4gICAgfCBJbmNsIGFyZzBfXzAyMF8gLT5cbiAgICAgIGxldCByZXMwX18wMjFfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIwXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5jbFwiOyByZXMwX18wMjFfIF1cbiAgICB8IEV4Y2wgYXJnMF9fMDIyXyAtPlxuICAgICAgbGV0IHJlczBfXzAyM18gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFeGNsXCI7IHJlczBfXzAyM18gXVxuICAgIHwgVW5ib3VuZGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuYm91bmRlZFwiXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiSW5jbFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXhjbFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlVuYm91bmRlZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuXG50eXBlIGludGVydmFsX2NvbXBhcmlzb24gPVxuICB8IEJlbG93X2xvd2VyX2JvdW5kXG4gIHwgSW5fcmFuZ2VcbiAgfCBBYm92ZV91cHBlcl9ib3VuZFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaF1cblxubGV0IGludGVydmFsX2NvbXBhcmlzb25fb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMjdfID0gXCJtYXliZV9ib3VuZC5tbC5pbnRlcnZhbF9jb21wYXJpc29uXCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJiZWxvd19sb3dlcl9ib3VuZFwiIHwgXCJCZWxvd19sb3dlcl9ib3VuZFwiKSAtPiBCZWxvd19sb3dlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5fcmFuZ2VcIiB8IFwiSW5fcmFuZ2VcIikgLT4gSW5fcmFuZ2VcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIC0+IEFib3ZlX3VwcGVyX2JvdW5kXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMjZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICB8IHNleHBfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IGludGVydmFsX2NvbXBhcmlzb24pXG47O1xuXG5sZXQgc2V4cF9vZl9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBCZWxvd19sb3dlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJCZWxvd19sb3dlcl9ib3VuZFwiXG4gICAgfCBJbl9yYW5nZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJJbl9yYW5nZVwiXG4gICAgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJBYm92ZV91cHBlcl9ib3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0IChpbnRlcnZhbF9jb21wYXJpc29uX3NleHBfZ3JhbW1hciA6IGludGVydmFsX2NvbXBhcmlzb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJCZWxvd19sb3dlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiSW5fcmFuZ2VcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkFib3ZlX3VwcGVyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24gPVxuICAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmVcbiAgIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludClcbjs7XG5cbmxldCAoaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24gOlxuICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBCZWxvd19sb3dlcl9ib3VuZCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBJbl9yYW5nZSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaF9pbnRlcnZhbF9jb21wYXJpc29uIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24gaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gSW5jbCAoZiBpbmNsKVxuICB8IEV4Y2wgZXhjbCAtPiBFeGNsIChmIGV4Y2wpXG4gIHwgVW5ib3VuZGVkIC0+IFVuYm91bmRlZFxuOztcblxubGV0IGlzX2xvd2VyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgaW5jbCBhIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBleGNsIGEgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBpc191cHBlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGEgaW5jbCA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgYSBleGNsIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIG1hdGNoIGxvd2VyIHdpdGhcbiAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgfCBJbmNsIGxvd2VyIHwgRXhjbCBsb3dlciAtPlxuICAgIChtYXRjaCB1cHBlciB3aXRoXG4gICAgIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gICAgIHwgSW5jbCB1cHBlciB8IEV4Y2wgdXBwZXIgLT4gY29tcGFyZSBsb3dlciB1cHBlciA+IDApXG47O1xuXG5sZXQgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBpZiBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlXG4gIHRoZW4gZmFpbHdpdGggXCJNYXliZV9ib3VuZC5jb21wYXJlX3RvX2ludGVydmFsX2V4bjogbG93ZXIgYm91bmQgPiB1cHBlciBib3VuZFwiXG47O1xuXG5sZXQgY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmU7XG4gIGlmIG5vdCAoaXNfbG93ZXJfYm91bmQgbG93ZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEJlbG93X2xvd2VyX2JvdW5kXG4gIGVsc2UgaWYgbm90IChpc191cHBlcl9ib3VuZCB1cHBlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQWJvdmVfdXBwZXJfYm91bmRcbiAgZWxzZSBJbl9yYW5nZVxuOztcblxubGV0IGludGVydmFsX2NvbnRhaW5zX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBtYXRjaCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgd2l0aFxuICB8IEluX3JhbmdlIC0+IHRydWVcbiAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IGZhbHNlXG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSBPcl9kdXBsaWNhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICBbIGBPayBvZiAnYVxuICAgIHwgYER1cGxpY2F0ZVxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgICB8IGBPayBfbGVmdF9fMDAzXywgYE9rIF9yaWdodF9fMDA0XyAtPiBfY21wX19hIF9sZWZ0X18wMDNfIF9yaWdodF9fMDA0X1xuICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IDBcbiAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSB4IHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDA1XyBiX18wMDZfIC0+XG4gICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDVfIGJfXzAwNl9cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGFfXzAwNV8sIGJfXzAwNl8gd2l0aFxuICAgICAgICB8IGBPayBfbGVmdF9fMDA3XywgYE9rIF9yaWdodF9fMDA4XyAtPiBfY21wX19hIF9sZWZ0X18wMDdfIF9yaWdodF9fMDA4X1xuICAgICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gdHJ1ZVxuICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gX29mX2FfXzAwOV8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYE9rIHZfXzAxMF8gLT4gU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgX29mX2FfXzAwOV8gdl9fMDEwXyBdXG4gICAgICB8IGBEdXBsaWNhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRHVwbGljYXRlXCJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSAnelxuZW5kXG5cbm1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSBjb21wYXJhdG9yOigna2V5LCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnelxuZW5kXG5cbm1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9ICdrICogWyBgTGVmdCBvZiAndiB8IGBSaWdodCBvZiAndiB8IGBVbmVxdWFsIG9mICd2ICogJ3YgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgJ2sgJ3YuICgnayAtPiAnayAtPiBpbnQpIC0+ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YpIHQgLT4gKCdrLCAndikgdCAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2sgX2NtcF9fdiBhX18wMTFfIGJfXzAxMl8gLT5cbiAgICBsZXQgdF9fMDEzXywgdF9fMDE0XyA9IGFfXzAxMV8gaW5cbiAgICBsZXQgdF9fMDE1XywgdF9fMDE2XyA9IGJfXzAxMl8gaW5cbiAgICBtYXRjaCBfY21wX19rIHRfXzAxM18gdF9fMDE1XyB3aXRoXG4gICAgfCAwIC0+XG4gICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCB0X18wMTRfIHRfXzAxNl9cbiAgICAgIHRoZW4gMFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHRfXzAxNF8sIHRfXzAxNl8gd2l0aFxuICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wMTdfLCBgTGVmdCBfcmlnaHRfXzAxOF8gLT4gX2NtcF9fdiBfbGVmdF9fMDE3XyBfcmlnaHRfXzAxOF9cbiAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAxOV8sIGBSaWdodCBfcmlnaHRfXzAyMF8gLT4gX2NtcF9fdiBfbGVmdF9fMDE5XyBfcmlnaHRfXzAyMF9cbiAgICAgICAgfCBgVW5lcXVhbCBfbGVmdF9fMDIxXywgYFVuZXF1YWwgX3JpZ2h0X18wMjJfIC0+XG4gICAgICAgICAgbGV0IHRfXzAyM18sIHRfXzAyNF8gPSBfbGVmdF9fMDIxXyBpblxuICAgICAgICAgIGxldCB0X18wMjVfLCB0X18wMjZfID0gX3JpZ2h0X18wMjJfIGluXG4gICAgICAgICAgKG1hdGNoIF9jbXBfX3YgdF9fMDIzXyB0X18wMjVfIHdpdGhcbiAgICAgICAgICAgfCAwIC0+IF9jbXBfX3YgdF9fMDI0XyB0X18wMjZfXG4gICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICAgIHwgbiAtPiBuXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAnayAndi5cbiAgICAoJ2sgLT4gJ2sgLT4gYm9vbCkgLT4gKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YpIHQgLT4gKCdrLCAndikgdCAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDI3XyBiX18wMjhfIC0+XG4gICAgICBsZXQgdF9fMDI5XywgdF9fMDMwXyA9IGFfXzAyN18gaW5cbiAgICAgIGxldCB0X18wMzFfLCB0X18wMzJfID0gYl9fMDI4XyBpblxuICAgICAgUHB4X2NvbXBhcmVfbGliLiggJiYgKVxuICAgICAgICAoX2NtcF9fayB0X18wMjlfIHRfXzAzMV8pXG4gICAgICAgIChpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCB0X18wMzBfIHRfXzAzMl9cbiAgICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIG1hdGNoIHRfXzAzMF8sIHRfXzAzMl8gd2l0aFxuICAgICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wMzNfLCBgTGVmdCBfcmlnaHRfXzAzNF8gLT4gX2NtcF9fdiBfbGVmdF9fMDMzXyBfcmlnaHRfXzAzNF9cbiAgICAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAzNV8sIGBSaWdodCBfcmlnaHRfXzAzNl8gLT4gX2NtcF9fdiBfbGVmdF9fMDM1XyBfcmlnaHRfXzAzNl9cbiAgICAgICAgICAgfCBgVW5lcXVhbCBfbGVmdF9fMDM3XywgYFVuZXF1YWwgX3JpZ2h0X18wMzhfIC0+XG4gICAgICAgICAgICAgbGV0IHRfXzAzOV8sIHRfXzA0MF8gPSBfbGVmdF9fMDM3XyBpblxuICAgICAgICAgICAgIGxldCB0X18wNDFfLCB0X18wNDJfID0gX3JpZ2h0X18wMzhfIGluXG4gICAgICAgICAgICAgUHB4X2NvbXBhcmVfbGliLiggJiYgKSAoX2NtcF9fdiB0X18wMzlfIHRfXzA0MV8pIChfY21wX192IHRfXzA0MF8gdF9fMDQyXylcbiAgICAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpKVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdrICd2LlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2spXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAndilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzA1N18gPSBcIm1hcF9pbnRmLm1sLlN5bW1ldHJpY19kaWZmX2VsZW1lbnQudFwiIGluXG4gICAgZnVuIF9vZl9rX18wNDNfIF9vZl92X18wNDRfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA2N187IGFyZzFfXzA2OF8gXSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDY5XyA9IF9vZl9rX18wNDNfIGFyZzBfXzA2N19cbiAgICAgICAgYW5kIHJlczFfXzA3MF8gPVxuICAgICAgICAgIGxldCBzZXhwX18wNjZfID0gYXJnMV9fMDY4XyBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbWF0Y2ggc2V4cF9fMDY2XyB3aXRoXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIGFzIF9zZXhwX18wNDlfIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBhdG9tX18wNDdfIHdpdGhcbiAgICAgICAgICAgICAgIHwgXCJMZWZ0XCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIGF0b21fXzA0N18gOjogc2V4cF9hcmdzX18wNTBfKSBhc1xuICAgICAgICAgICAgICBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIGFzIF90YWdfXzA2M18gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDY0XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjVfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDY0XyBpblxuICAgICAgICAgICAgICAgICAgICBgTGVmdCByZXMwX18wNjVfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA2M19cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIGFzIF90YWdfXzA2MF8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDYxXyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjJfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDYxXyBpblxuICAgICAgICAgICAgICAgICAgICBgUmlnaHQgcmVzMF9fMDYyX1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjBfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIGFzIF90YWdfXzA1MV8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDU4XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTlfID1cbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcwX18wNThfIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA1Ml87IGFyZzFfXzA1M18gXSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA1NF8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNTJfXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmVzMV9fMDU1XyA9IF9vZl92X18wNDRfIGFyZzFfXzA1M18gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlczBfXzA1NF8sIHJlczFfXzA1NV9cbiAgICAgICAgICAgICAgICAgICAgICB8IHNleHBfXzA1Nl8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V4cF9fMDU2X1xuICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICBgVW5lcXVhbCByZXMwX18wNTlfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA1MV9cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fdmFyaWFudF9tYXRjaCAoKSlcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wNDhfIC0+XG4gICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5Ob192YXJpYW50X21hdGNoIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZFxuICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgc2V4cF9fMDY2X1xuICAgICAgICBpblxuICAgICAgICByZXMwX18wNjlfLCByZXMxX18wNzBfXG4gICAgICB8IHNleHBfXzA3MV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBlcnJvcl9zb3VyY2VfXzA1N18gMiBzZXhwX18wNzFfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9rX18wNzJfIF9vZl92X18wNzNfIChhcmcwX18wODFfLCBhcmcxX18wODJfKSAtPlxuICAgICAgbGV0IHJlczBfXzA4M18gPSBfb2Zfa19fMDcyXyBhcmcwX18wODFfXG4gICAgICBhbmQgcmVzMV9fMDg0XyA9XG4gICAgICAgIG1hdGNoIGFyZzFfXzA4Ml8gd2l0aFxuICAgICAgICB8IGBMZWZ0IHZfXzA3NF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IF9vZl92X18wNzNfIHZfXzA3NF8gXVxuICAgICAgICB8IGBSaWdodCB2X18wNzVfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3ZfXzA3M18gdl9fMDc1XyBdXG4gICAgICAgIHwgYFVuZXF1YWwgdl9fMDc2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsXCJcbiAgICAgICAgICAgIDsgKGxldCBhcmcwX18wNzdfLCBhcmcxX18wNzhfID0gdl9fMDc2XyBpblxuICAgICAgICAgICAgICAgbGV0IHJlczBfXzA3OV8gPSBfb2Zfdl9fMDczXyBhcmcwX18wNzdfXG4gICAgICAgICAgICAgICBhbmQgcmVzMV9fMDgwXyA9IF9vZl92X18wNzNfIGFyZzFfXzA3OF8gaW5cbiAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA3OV87IHJlczFfXzA4MF8gXSlcbiAgICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wODNfOyByZXMxX18wODRfIF1cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydrX3NleHBfZ3JhbW1hciBfJ3Zfc2V4cF9ncmFtbWFyIC0+XG4gICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgIExpc3RcbiAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAoIF8na19zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgLCBDb25zXG4gICAgICAgICAgICAgICAgICAgKCBWYXJpYW50XG4gICAgICAgICAgICAgICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJVbmVxdWFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIEVtcHR5IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgLCBFbXB0eSApICkpXG4gICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnbGVmdCwgJ3JpZ2h0KSB0ID1cbiAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgfCBgUmlnaHQgb2YgJ3JpZ2h0XG4gICAgfCBgQm90aCBvZiAnbGVmdCAqICdyaWdodFxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnbGVmdCAncmlnaHQuXG4gICAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBpbnQpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fbGVmdCBfY21wX19yaWdodCBhX18wODVfIGJfXzA4Nl8gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wODVfIGJfXzA4Nl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzA4NV8sIGJfXzA4Nl8gd2l0aFxuICAgICAgfCBgTGVmdCBfbGVmdF9fMDg3XywgYExlZnQgX3JpZ2h0X18wODhfIC0+IF9jbXBfX2xlZnQgX2xlZnRfXzA4N18gX3JpZ2h0X18wODhfXG4gICAgICB8IGBSaWdodCBfbGVmdF9fMDg5XywgYFJpZ2h0IF9yaWdodF9fMDkwXyAtPiBfY21wX19yaWdodCBfbGVmdF9fMDg5XyBfcmlnaHRfXzA5MF9cbiAgICAgIHwgYEJvdGggX2xlZnRfXzA5MV8sIGBCb3RoIF9yaWdodF9fMDkyXyAtPlxuICAgICAgICBsZXQgdF9fMDkzXywgdF9fMDk0XyA9IF9sZWZ0X18wOTFfIGluXG4gICAgICAgIGxldCB0X18wOTVfLCB0X18wOTZfID0gX3JpZ2h0X18wOTJfIGluXG4gICAgICAgIChtYXRjaCBfY21wX19sZWZ0IHRfXzA5M18gdF9fMDk1XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fcmlnaHQgdF9fMDk0XyB0X18wOTZfXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSB4IHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAnbGVmdCAncmlnaHQuXG4gICAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGJvb2wpXG4gICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fbGVmdCBfY21wX19yaWdodCBhX18wOTdfIGJfXzA5OF8gLT5cbiAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzA5N18gYl9fMDk4X1xuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggYV9fMDk3XywgYl9fMDk4XyB3aXRoXG4gICAgICAgIHwgYExlZnQgX2xlZnRfXzA5OV8sIGBMZWZ0IF9yaWdodF9fMTAwXyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wOTlfIF9yaWdodF9fMTAwX1xuICAgICAgICB8IGBSaWdodCBfbGVmdF9fMTAxXywgYFJpZ2h0IF9yaWdodF9fMTAyXyAtPiBfY21wX19yaWdodCBfbGVmdF9fMTAxXyBfcmlnaHRfXzEwMl9cbiAgICAgICAgfCBgQm90aCBfbGVmdF9fMTAzXywgYEJvdGggX3JpZ2h0X18xMDRfIC0+XG4gICAgICAgICAgbGV0IHRfXzEwNV8sIHRfXzEwNl8gPSBfbGVmdF9fMTAzXyBpblxuICAgICAgICAgIGxldCB0X18xMDdfLCB0X18xMDhfID0gX3JpZ2h0X18xMDRfIGluXG4gICAgICAgICAgUHB4X2NvbXBhcmVfbGliLiggJiYgKSAoX2NtcF9fbGVmdCB0X18xMDVfIHRfXzEwN18pIChfY21wX19yaWdodCB0X18xMDZfIHRfXzEwOF8pXG4gICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfbGVmdF9fMTA5XyBfb2ZfcmlnaHRfXzExMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgdl9fMTExXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IF9vZl9sZWZ0X18xMDlfIHZfXzExMV8gXVxuICAgICAgfCBgUmlnaHQgdl9fMTEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyBfb2ZfcmlnaHRfXzExMF8gdl9fMTEyXyBdXG4gICAgICB8IGBCb3RoIHZfXzExM18gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJCb3RoXCJcbiAgICAgICAgICA7IChsZXQgYXJnMF9fMTE0XywgYXJnMV9fMTE1XyA9IHZfXzExM18gaW5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMTE2XyA9IF9vZl9sZWZ0X18xMDlfIGFyZzBfXzExNF9cbiAgICAgICAgICAgICBhbmQgcmVzMV9fMTE3XyA9IF9vZl9yaWdodF9fMTEwXyBhcmcxX18xMTVfIGluXG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMTE2XzsgcmVzMV9fMTE3XyBdKVxuICAgICAgICAgIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkNvbnRpbnVlX29yX3N0b3AgKilcbm1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb250aW51ZVxuICAgIHwgU3RvcFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBDb250aW51ZTsgU3RvcCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IENvbnRpbnVlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkNvbnRpbnVlXCJcbiAgICAgIHwgU3RvcCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdG9wXCJcbiAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuRmluaXNoZWRfb3JfdW5maW5pc2hlZCAqKVxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEZpbmlzaGVkXG4gICAgfCBVbmZpbmlzaGVkXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEZpbmlzaGVkOyBVbmZpbmlzaGVkIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRmluaXNoZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmluaXNoZWRcIlxuICAgICAgfCBVbmZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZmluaXNoZWRcIlxuICAgICAgICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgJ2NtcCBjbXBcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcblxuICB2YWwgYWRkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYWRkX2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHNldFxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGFkZF9tdWx0aVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCByZW1vdmVfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmluZF9tdWx0aSA6ICgnaywgJ2NtcCwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndiBsaXN0KSBvcHRpb25zXG5cbiAgdmFsIGNoYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHVwZGF0ZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+IGY6KCd2IG9wdGlvbiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmluZCA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3Ygb3B0aW9uKSBvcHRpb25zXG4gIHZhbCBmaW5kX2V4biA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YpIG9wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgbWVtIDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQgLT4gJ2sga2V5IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayBrZXkgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAndiwgXykgdCAtPiBmOigndiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgICAgLT4gdW5pdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKSAtPiAnYVxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gKCdhLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKSAtPiAnYVxuXG4gIHZhbCBmb2xkMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgLT4gaW5pdDonYVxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICdhIC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9rZXlzXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ2sga2V5IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooJ3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogKCdrLCAnY21wLCAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gaW50KSBvcHRpb25zXG5cbiAgdmFsIGVxdWFsXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBrZXlzIDogKCdrLCBfLCBfKSB0IC0+ICdrIGtleSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICd2LCBfKSB0IC0+ICd2IGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+ICgnayBrZXkgKiAndikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiAoJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAndjMgb3B0aW9uKVxuICAgICAgLT4gKCdrLCAndjMsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbWJpbmU6KGtleTonayBrZXkgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgICAtPiAoJ2sga2V5LCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gaW5pdDonYVxuICAgICAgLT4gZjooJ2EgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtaW5fZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrIGtleSAqICd2XG4gIHZhbCBtYXhfZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrIGtleSAqICd2XG4gIHZhbCBmb3JfYWxsIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICdrIGtleVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayBrZXkgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYXBwZW5kXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGxvd2VyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAtPiB1cHBlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBtaW46J2sga2V5XG4gICAgICAtPiBtYXg6J2sga2V5XG4gICAgICAtPiBpbml0OidhXG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayBrZXkgLT4gbWF4OidrIGtleSAtPiAoJ2sga2V5ICogJ3YpIGxpc3QgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbnRoIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCAtPiAnayBrZXkgKiAndlxuICB2YWwgcmFuayA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBpbnQgb3B0aW9uKSBvcHRpb25zXG4gIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2sga2V5LCAndiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonayBrZXlcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnayBrZXkgKiAndikgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgICAgLT4gJ2tleVxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gc2VnbWVudF9vZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gY29tcGFyZTooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSB0cmVlXG4gIHR5cGUga2V5XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgdCBPcl9kdXBsaWNhdGUudFxuICB2YWwgYWRkX2V4biA6ICdhIHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIHRcbiAgdmFsIHNldCA6ICdhIHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIHRcbiAgdmFsIGFkZF9tdWx0aSA6ICdhIGxpc3QgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgbGlzdCB0XG4gIHZhbCByZW1vdmVfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5IC0+ICdhIGxpc3QgdFxuICB2YWwgZmluZF9tdWx0aSA6ICdhIGxpc3QgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgY2hhbmdlIDogJ2EgdCAtPiBrZXkgLT4gZjooJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdFxuICB2YWwgdXBkYXRlIDogJ2EgdCAtPiBrZXkgLT4gZjooJ2Egb3B0aW9uIC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiAnYSB0XG4gIHZhbCBtZW0gOiBfIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6IF8gdCAtPiBmOihrZXkgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyIDogJ2EgdCAtPiAnYiB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTooJ2EsICdiKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgbWFwaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2FjYyAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBmb2xkMlxuICAgIDogICdhIHRcbiAgICAtPiAnYiB0XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTooJ2EsICdiKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmlsdGVyX2tleXMgOiAnYSB0IC0+IGY6KGtleSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBmaWx0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIGZpbHRlcmkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIHRcbiAgdmFsIGZpbHRlcl9tYXBpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBwYXJ0aXRpb25fbWFwaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICgnYiwgJ2MpIEVpdGhlci50KSAtPiAnYiB0ICogJ2MgdFxuICB2YWwgcGFydGl0aW9uX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gKCdiLCAnYykgRWl0aGVyLnQpIC0+ICdiIHQgKiAnYyB0XG4gIHZhbCBwYXJ0aXRpb25pX3RmIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gJ2EgdCAqICdhIHRcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdCAqICdhIHRcbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogJ2EgT3JfZXJyb3IudCB0IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICB2YWwga2V5cyA6IF8gdCAtPiBrZXkgbGlzdFxuICB2YWwgZGF0YSA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYWxpc3QgOiA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdIC0+ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gIHZhbCBtZXJnZSA6ICdhIHQgLT4gJ2IgdCAtPiBmOihrZXk6a2V5IC0+ICgnYSwgJ2IpIE1lcmdlX2VsZW1lbnQudCAtPiAnYyBvcHRpb24pIC0+ICdjIHRcbiAgdmFsIG1lcmdlX3NrZXdlZCA6ICd2IHQgLT4gJ3YgdCAtPiBjb21iaW5lOihrZXk6a2V5IC0+ICd2IC0+ICd2IC0+ICd2KSAtPiAndiB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+IChrZXksICdhKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoa2V5LCAnYSkgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICdhIHQgLT4ga2V5ICogJ2FcbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICdhIHQgLT4ga2V5ICogJ2FcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzcGxpdCA6ICdhIHQgLT4ga2V5IC0+ICdhIHQgKiAoa2V5ICogJ2EpIG9wdGlvbiAqICdhIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDonYSB0XG4gICAgLT4gdXBwZXJfcGFydDonYSB0XG4gICAgLT4gWyBgT2sgb2YgJ2EgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAnYSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6a2V5IE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDprZXkgTWF5YmVfYm91bmQudFxuICAgIC0+ICdhIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAnYSB0XG4gICAgLT4gbWluOmtleVxuICAgIC0+IG1heDprZXlcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIC0+ICdiKVxuICAgIC0+ICdiXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogJ2EgdCAtPiBtaW46a2V5IC0+IG1heDprZXkgLT4gKGtleSAqICdhKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgJ2EgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiBrZXlcbiAgICAtPiAoa2V5ICogJ2EpIG9wdGlvblxuXG4gIHZhbCBudGggOiAnYSB0IC0+IGludCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICdhIHQgLT4gaW50IC0+IGtleSAqICdhXG4gIHZhbCByYW5rIDogXyB0IC0+IGtleSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogJ2EgdCAtPiAnYSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOmtleVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86a2V5XG4gICAgLT4gJ2EgdFxuICAgIC0+IChrZXkgKiAnYSkgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KGtleTprZXkgLT4gZGF0YTonYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKGtleSAqICdhKSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAnYSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKGtleSAqICdhKSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICdhIHRcbiAgICAtPiBjb21wYXJlOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCdhLCAnYikgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGFkZCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYikgdCBPcl9kdXBsaWNhdGUudFxuICB2YWwgYWRkX2V4biA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYikgdFxuICB2YWwgc2V0IDogKCdhLCAnYikgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiKSB0XG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiBsaXN0KSB0XG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4gJ2EgLT4gKCdhLCAnYiBsaXN0KSB0XG4gIHZhbCBmaW5kX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIC0+ICdiIGxpc3RcbiAgdmFsIGNoYW5nZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbikgLT4gKCdhLCAnYikgdFxuICB2YWwgdXBkYXRlIDogKCdhLCAnYikgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbmQgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICdiIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICdiXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG1lbSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBtYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBtYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgZm9sZCA6ICgnYSwgJ2IpIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gKCdhLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2MpIHRcbiAgICAtPiBpbml0OidkXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIC0+ICdkKVxuICAgIC0+ICdkXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdhLCAnYikgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuICB2YWwgZmlsdGVyX21hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudCkgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogKCdhLCAnYiBPcl9lcnJvci50KSB0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICB2YWwga2V5cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiKSB0IC0+ICdiIGxpc3RcbiAgdmFsIHRvX2FsaXN0IDogP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAtPiAoJ2EsICdiKSB0IC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2MpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gKCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIG9wdGlvbilcbiAgICAtPiAoJ2EsICdkKSB0XG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YpIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2EsICdiKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAqICdiXG4gIHZhbCBtYXhfZWx0IDogKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgKiAnYlxuICB2YWwgZm9yX2FsbCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIHNwbGl0IDogKCdhLCAnYikgdCAtPiAnYSAtPiAoJ2EsICdiKSB0ICogKCdhICogJ2IpIG9wdGlvbiAqICgnYSwgJ2IpIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2EsICdiKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2EsICdiKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2EsICdiKSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICgnYSwgJ2IpIHQgLT4gbWluOidhIC0+IG1heDonYSAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EgKiAnYikgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2EsICdiKSB0IC0+IGludCAtPiAnYSAqICdiXG4gIHZhbCByYW5rIDogKCdhLCBfKSB0IC0+ICdhIC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcbiAgdmFsIGFkZCA6ICgnYSwgJ2IsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudFxuICB2YWwgYWRkX2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgc2V0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2EsICdiIGxpc3QsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2EsICdiIGxpc3QsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gIHZhbCBmaW5kX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+ICdhIC0+ICdiIGxpc3RcbiAgdmFsIGNoYW5nZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbikgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgdXBkYXRlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGZpbmQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICdiIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICdiXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIG1lbSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfLCAnY21wKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBtYXAgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgZm9sZCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gKCdhLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBpbml0OidkXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIC0+ICdkKVxuICAgIC0+ICdkXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHQgKiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnYSwgJ2IgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYiwgXykgdCAtPiAnYiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnYSwgJ2IsIF8pIHRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYiwgXykgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6IChfLCAnYiwgXykgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnYSwgJ2IsIF8pIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2EsICdiLCBfKSB0IC0+IG1pbjonYSAtPiBtYXg6J2EgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2EsICdiLCBfKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiLCBfKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYiwgXykgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6ICgnYSwgXywgXykgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2IsIF8pIHRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgaXNfZW1wdHkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50XG5cbiAgdmFsIGFkZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgc2V0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBhZGRfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCByZW1vdmVfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgZmluZF9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICdiIGxpc3RcblxuICB2YWwgY2hhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmluZCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICdiXG5cbiAgdmFsIHJlbW92ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG1lbSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8sICdjbXApIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBtYXAgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgZm9sZCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gKCdhLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5c1xuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcmlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHQgKiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHQgKiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgT3JfZXJyb3IudCwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2IgLT4gJ2IgLT4gaW50KVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBrZXlzIDogKCdhLCBfLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IsIF8pIHQgLT4gJ2IgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gKCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIG9wdGlvbilcbiAgICAtPiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBtYXhfZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgZm9yX2FsbCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSAqICdiKSBvcHRpb24gKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsb3dlcl9wYXJ0OignYSwgJ2IsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignYSwgJ2IsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EgKiAnYikgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludCAtPiAnYSAqICdiXG4gIHZhbCByYW5rIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbmVuZFxuXG4oKiogQ29uc2lzdGVuY3kgY2hlY2tzIChzYW1lIGFzIGluIFtDb250YWluZXJdKS4gKilcbm1vZHVsZSBDaGVja19hY2Nlc3NvcnNcbiAgICAoVCA6IFQzKVxuICAgIChUcmVlIDogVDMpXG4gICAgKEtleSA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcbiAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBDbXAudCkgPVxuc3RydWN0IGVuZFxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMSAoTSA6IEFjY2Vzc29yczEpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0ua2V5XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyIChNIDogQWNjZXNzb3JzMikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczMgKE0gOiBBY2Nlc3NvcnMzKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciAoTSA6IEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0XG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdHJlZVxuICB0eXBlICdrIGtleVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gIHZhbCBlbXB0eSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2ssICdjbXAsICdrIGtleSAtPiAndiAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAgIC0+IGY6KCdrMSBrZXkgLT4gJ2syIGtleSlcbiAgICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBrZXkgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHQgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KSAtPiAoJ2syLCAndiwgJ2NtcDIpIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgYXJyYXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCBsZW46aW50IC0+IGY6KGludCAtPiAnayBrZXkgKiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgbGlzdCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIGxpc3QgLT4gaW5pdDondjIgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+IGY6KCd2IC0+ICd2IC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF1cbiAgICAgIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2MSkgU2VxdWVuY2UudFxuICAgICAgLT4gaW5pdDondjJcbiAgICAgIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBpdGVyaTooZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdCkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfdHJlZSA6ICgnaywgJ2NtcCwgKCdrIGtleSwgJ3YsICdjbXApIHRyZWUgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSB0cmVlXG4gIHR5cGUga2V5XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogXyB0XG4gIHZhbCBzaW5nbGV0b24gOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgbWFwX2tleXMgOiAndiB0IC0+IGY6KGtleSAtPiBrZXkpIC0+IFsgYE9rIG9mICd2IHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgbWFwX2tleXNfZXhuIDogJ3YgdCAtPiBmOihrZXkgLT4ga2V5KSAtPiAndiB0XG4gIHZhbCBvZl9hbGlzdCA6IChrZXkgKiAnYSkgbGlzdCAtPiBbIGBPayBvZiAnYSB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yIDogKGtleSAqICdhKSBsaXN0IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKGtleSAqICdhKSBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKGtleSAqICdhKSBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgb2ZfYWxpc3RfZm9sZCA6IChrZXkgKiAnYSkgbGlzdCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2UgOiAoa2V5ICogJ2EpIGxpc3QgLT4gZjooJ2EgLT4gJ2EgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6IChrZXkgKiAnYSkgYXJyYXkgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKGtleSAqICdhKSBhcnJheSAtPiAnYSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+IGtleSAqICdhKSAtPiAnYSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgJ2EgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvciA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlX2V4biA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSBsaXN0IHRcbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGQgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IGY6KCdhIC0+ICdhIC0+ICdhKSAtPiAnYSB0XG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgaXRlcmk6KGY6KGtleTprZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICd2IHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuXG4gIHZhbCBvZl9pdGVyaV9leG4gOiBpdGVyaTooZjooa2V5OmtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpIC0+ICd2IHRcbiAgdmFsIG9mX3RyZWUgOiAnYSB0cmVlIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCdhLCAnYikgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6IChfLCBfKSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYiAtPiAoJ2EsICdiKSB0XG5cbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMSwgJ3YpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2KSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICB2YWwgbWFwX2tleXNfZXhuIDogKCdrMSwgJ3YpIHQgLT4gZjooJ2sxIC0+ICdrMikgLT4gKCdrMiwgJ3YpIHRcbiAgdmFsIG9mX2FsaXN0IDogKCdhICogJ2IpIGxpc3QgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgb2ZfYWxpc3RfZm9sZCA6ICgnYSAqICdiKSBsaXN0IC0+IGluaXQ6J2MgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZSA6ICgnYSAqICdiKSBsaXN0IC0+IGY6KCdiIC0+ICdiIC0+ICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoJ2EgKiAnYikgYXJyYXkgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKCdhICogJ2IpIGFycmF5IC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EgKiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlX2V4biA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYiBsaXN0KSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+IGY6KCdiIC0+ICdiIC0+ICdiKSAtPiAoJ2EsICdiKSB0XG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2ZfaXRlcmlfZXhuIDogaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX3RyZWUgOiAoJ2EsICdiKSB0cmVlIC0+ICgnYSwgJ2IpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgZW1wdHkgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgXywgJ2NtcCkgdFxuICB2YWwgc2luZ2xldG9uIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSAtPiAnYiAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIgXVxuXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX2FsaXN0X2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgb2ZfYWxpc3RfZm9sZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSAqICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfdHJlZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0cmVlXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yc1xuICAgIChUIDogVDMpXG4gICAgKFRyZWUgOiBUMylcbiAgICAoS2V5IDogVDEpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBDcmVhdG9yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgd2l0aCB0eXBlICdhIGNtcCA6PSAnYSBDbXAudCkgPVxuc3RydWN0IGVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMxIChNIDogQ3JlYXRvcnMxKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0ua2V5XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczIgKE0gOiBDcmVhdG9yczIpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IgKE0gOiBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnNfZ2VuZXJpY1xuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gICAgd2l0aCB0eXBlICdhIGNtcCA6PSAnYSBjbXBcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzMVxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMxXG4gICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgIHdpdGggdHlwZSAnYSB0cmVlIDo9ICdhIHRyZWVcbiAgICB3aXRoIHR5cGUga2V5IDo9IGtleVxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yczJcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzMlxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0cmVlXG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3RcbiAgICA6ICAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICgndiAtPiBTZXhwLnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBjb21wYXJlX21fX3RcbiAgICA6ICAobW9kdWxlIENvbXBhcmVfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gaW50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsX21fX3RcbiAgICA6ICAobW9kdWxlIEVxdWFsX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGhhc2hfZm9sZF9tX190XG4gICAgOiAgKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+IChIYXNoLnN0YXRlIC0+ICd2IC0+IEhhc2guc3RhdGUpXG4gICAgLT4gSGFzaC5zdGF0ZVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5lbmRcblxubW9kdWxlIHR5cGUgTWFwID0gc2lnXG4gICgqKiBbTWFwXSBpcyBhIGZ1bmN0aW9uYWwgZGF0YSBzdHJ1Y3R1cmUgKGJhbGFuY2VkIGJpbmFyeSB0cmVlKSBpbXBsZW1lbnRpbmcgZmluaXRlIG1hcHNcbiAgICAgIG92ZXIgYSB0b3RhbGx5LW9yZGVyZWQgZG9tYWluLCBjYWxsZWQgYSBcImtleVwiLiAqKVxuXG4gIHR5cGUgKCdrZXksICsndmFsdWUsICdjbXApIHRcblxuICBtb2R1bGUgT3JfZHVwbGljYXRlID0gT3JfZHVwbGljYXRlXG4gIG1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gQ29udGludWVfb3Jfc3RvcFxuXG4gIG1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkIDogc2lnXG4gICAgdHlwZSB0ID0gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50ID1cbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgVW5maW5pc2hlZFxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9lbnVtZXJhdGVfbGliLkVudW1lcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogTWFwcyBbQ29udGludWVdIHRvIFtGaW5pc2hlZF0gYW5kIFtTdG9wXSB0byBbVW5maW5pc2hlZF0uICopXG4gICAgdmFsIG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdFxuXG4gICAgKCoqIE1hcHMgW0ZpbmlzaGVkXSB0byBbQ29udGludWVdIGFuZCBbVW5maW5pc2hlZF0gdG8gW1N0b3BdLiAqKVxuICAgIHZhbCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnRcbiAgZW5kXG5cbiAgbW9kdWxlIE1lcmdlX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnbGVmdCwgJ3JpZ2h0KSB0ID1cbiAgICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgICAgfCBgQm90aCBvZiAnbGVmdCAqICdyaWdodFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIHZhbCBjb21wYXJlXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBpbnRcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGJvb2wpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBib29sXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdyaWdodCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIGxlZnQgOiAoJ2xlZnQsIF8pIHQgLT4gJ2xlZnQgb3B0aW9uXG4gICAgdmFsIHJpZ2h0IDogKF8sICdyaWdodCkgdCAtPiAncmlnaHQgb3B0aW9uXG4gICAgdmFsIGxlZnRfdmFsdWUgOiAoJ2xlZnQsIF8pIHQgLT4gZGVmYXVsdDonbGVmdCAtPiAnbGVmdFxuICAgIHZhbCByaWdodF92YWx1ZSA6IChfLCAncmlnaHQpIHQgLT4gZGVmYXVsdDoncmlnaHQgLT4gJ3JpZ2h0XG5cbiAgICB2YWwgdmFsdWVzXG4gICAgICA6ICAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gbGVmdF9kZWZhdWx0OidsZWZ0XG4gICAgICAtPiByaWdodF9kZWZhdWx0OidyaWdodFxuICAgICAgLT4gJ2xlZnQgKiAncmlnaHRcbiAgZW5kXG5cbiAgdHlwZSAoJ2ssICdjbXApIGNvbXBhcmF0b3IgPSAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIxLTEyXSB1c2UgW0NvbXBhcmF0b3IuTW9kdWxlLnRdIGluc3RlYWRcIl1cblxuICAoKiogVGVzdCBpZiB0aGUgaW52YXJpYW50cyBvZiB0aGUgaW50ZXJuYWwgQVZMIHNlYXJjaCB0cmVlIGhvbGQuICopXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgZmlyc3QtY2xhc3MgbW9kdWxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVpbGQgb3RoZXIgbWFwL3NldC9ldGMuXG4gICAgICB3aXRoIHRoZSBzYW1lIG5vdGlvbiBvZiBjb21wYXJpc29uLiAqKVxuICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgKCoqIFRoZSBlbXB0eSBtYXAuICopXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIEEgbWFwIHdpdGggb25lIChrZXksIGRhdGEpIHBhaXIuICopXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgLT4gJ2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLiAqKVxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMsIHJldHVybmluZyBhbiBlcnJvciBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMsIHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC4gKilcbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gVGhlIGFjY3VtdWxhdG9yIGlzIHBlci1rZXkuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgICMgbGV0IG1hcCA9IFN0cmluZy5NYXAub2ZfYWxpc3RfZm9sZFxuICAgICAgICAgICAgICAgICAgICAgIFsgXCJhXCIsIDE7IFwiYVwiLCAxMDsgXCJiXCIsIDI7IFwiYlwiLCAyMDsgXCJiXCIsIDIwMCBdXG4gICAgICAgICAgICAgICAgICAgICAgfmluaXQ6SW50LlNldC5lbXB0eVxuICAgICAgICAgICAgICAgICAgICAgIH5mOlNldC5hZGRcbiAgICAgICAgICBpblxuICAgICAgICAgIHByaW50X3MgWyVzZXhwIChtYXAgOiBJbnQuU2V0LnQgU3RyaW5nLk1hcC50KV07O1xuICAgICAgICAoKGEgKDEgMTApKSAoYiAoMiAyMCAyMDApKSlcbiAgICAgICAgLSA6IHVuaXQgPSAoKVxuICAgICAgXX1cbiAgKilcbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLiAqKVxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pdGVyaSB+aXRlcmldIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RdLCBleGNlcHQgdGhhdCBpbnN0ZWFkIG9mIHRha2luZyBhIGNvbmNyZXRlXG4gICAgICBkYXRhIHN0cnVjdHVyZSwgaXQgdGFrZXMgYW4gaXRlcmF0aW9uIGZ1bmN0aW9uLiAgRm9yIGluc3RhbmNlLCB0byBjb252ZXJ0IGEgc3RyaW5nIHRhYmxlXG4gICAgICBpbnRvIGEgbWFwOiBbb2ZfaXRlcmkgKG1vZHVsZSBTdHJpbmcpIH5mOihIYXNodGJsLml0ZXJpIHRhYmxlKV0uICBJdCBpcyBmYXN0ZXIgdGhhblxuICAgICAgYWRkaW5nIHRoZSBlbGVtZW50cyBvbmUgYnkgb25lLiAqKVxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBMaWtlIFtvZl9pdGVyaV0gZXhjZXB0IHRoYXQgaXQgcmFpc2VzIGFuIGV4Y2VwdGlvbiBpZiBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGEgc29ydGVkIGFycmF5IG9mIGtleS1kYXRhIHBhaXJzLiBUaGUgaW5wdXQgYXJyYXkgbXVzdCBiZSBzb3J0ZWRcbiAgICAgIChlaXRoZXIgaW4gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcgb3JkZXIpLCBhcyBnaXZlbiBieSB0aGUgcmVsZXZhbnQgY29tcGFyYXRvciwgYW5kXG4gICAgICBtdXN0IG5vdCBjb250YWluIGR1cGxpY2F0ZSBrZXlzLiBJZiBlaXRoZXIgb2YgdGhlc2UgY29uZGl0aW9ucyBkb2VzIG5vdCBob2xkLFxuICAgICAgYW4gZXJyb3IgaXMgcmV0dXJuZWQuICAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIExpa2UgW29mX3NvcnRlZF9hcnJheV0gZXhjZXB0IHRoYXQgaXQgcmV0dXJucyBhIG1hcCB3aXRoIGJyb2tlbiBpbnZhcmlhbnRzIHdoZW4gYW5cbiAgICAgIFtFcnJvcl0gd291bGQgaGF2ZSBiZWVuIHJldHVybmVkLiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIGMgfmxlbiB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGNcbiAgICAgIChBcnJheS5pbml0IGxlbiB+ZildLCB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIHRoYXQgYSBkZWNyZWFzaW5nIG9yZGVyIGlzIG5vdFxuICAgICAgc3VwcG9ydGVkLiAgVGhlIGFkdmFudGFnZSBpcyBub3QgcmVxdWlyaW5nIHlvdSB0byBhbGxvY2F0ZSBhbiBpbnRlcm1lZGlhdGUgYXJyYXkuICBbZl1cbiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggMCwgMSwgLi4uIFtsZW4gLSAxXSwgaW4gb3JkZXIuICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EgKiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheSBjIChTZXF1ZW5jZS50b19hcnJheVxuICAgICAgc2VxKV0sIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGFycmF5LlxuXG4gICAgICBUaGUgc2VxdWVuY2Ugd2lsbCBiZSBmb2xkZWQgb3ZlciBvbmNlLCBhbmQgdGhlIGFkZGl0aW9uYWwgdGltZSBjb21wbGV4aXR5IGlzIHtlIE8obil9LlxuICAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2UgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3QgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cblxuICAgICAgSWYgeW91ciBzZXF1ZW5jZSBpcyBpbmNyZWFzaW5nLCB1c2UgW29mX2luY3JlYXNpbmdfc2VxdWVuY2VdLlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBdXG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLlxuXG4gICAgICBbb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3Rfb3JfZXJyb3IgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMsIHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX2V4biBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9leG4gYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCBwb3NzaWJseSByZXBlYXRlZCBrZXlzLiBUaGUgdmFsdWVzIGluXG4gICAgICB0aGUgbWFwIGZvciBhIGdpdmVuIGtleSBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBkaWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICBsaXN0LlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfbXVsdGkgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIGludG8gYSBtYXAsIGZvbGRpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfZm9sZCBjIHNlcSB+aW5pdCB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9mb2xkIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKSB+aW5pdCB+Zl1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9yZWR1Y2UgYyBzZXEgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfcmVkdWNlIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKSB+Zl1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFRlc3RzIHdoZXRoZXIgYSBtYXAgaXMgZW1wdHkuICopXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogW2xlbmd0aCBtYXBdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBbbWFwXS4gIE8oMSksIGJ1dCBbVHJlZS5sZW5ndGhdIGlzXG4gICAgICBPKG4pLiAqKVxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggdGhlIHNwZWNpZmllZCBuZXcgYmluZGluZzsgaWYgdGhlIGtleSB3YXMgYWxyZWFkeSBib3VuZCwgaXRzXG4gICAgICBwcmV2aW91cyBiaW5kaW5nIGRpc2FwcGVhcnMuICopXG4gIHZhbCBzZXQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2FkZCB0IH5rZXkgfmRhdGFdIGFkZHMgYSBuZXcgZW50cnkgdG8gW3RdIG1hcHBpbmcgW2tleV0gdG8gW2RhdGFdIGFuZCByZXR1cm5zIFtgT2tdXG4gICAgICB3aXRoIHRoZSBuZXcgbWFwLCBvciBpZiBba2V5XSBpcyBhbHJlYWR5IHByZXNlbnQgaW4gW3RdLCByZXR1cm5zIFtgRHVwbGljYXRlXS4gKilcbiAgdmFsIGFkZCA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudFxuXG4gIHZhbCBhZGRfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIElmIFtrZXldIGlzIG5vdCBwcmVzZW50IHRoZW4gYWRkIGEgc2luZ2xldG9uIGxpc3QsIG90aGVyd2lzZSwgY29ucyBkYXRhIG9udG8gdGhlXG4gICAgICBoZWFkIG9mIHRoZSBleGlzdGluZyBsaXN0LiAqKVxuICB2YWwgYWRkX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBJZiB0aGUga2V5IGlzIHByZXNlbnQsIHRoZW4gcmVtb3ZlIGl0cyBoZWFkIGVsZW1lbnQ7IGlmIHRoZSByZXN1bHQgaXMgZW1wdHksIHJlbW92ZVxuICAgICAgdGhlIGtleS4gKilcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgdGhlIGVtcHR5IGxpc3QgaWYgdGhlcmUgaXMgbm9uZS4gKilcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gJ3YgbGlzdFxuXG4gICgqKiBbY2hhbmdlIHQga2V5IH5mXSByZXR1cm5zIGEgbmV3IG1hcCBbbV0gdGhhdCBpcyB0aGUgc2FtZSBhcyBbdF0gb24gYWxsIGtleXMgZXhjZXB0XG4gICAgICBmb3IgW2tleV0sIGFuZCB3aG9zZSB2YWx1ZSBmb3IgW2tleV0gaXMgZGVmaW5lZCBieSBbZl0sIGkuZS4sIFtmaW5kIG0ga2V5ID0gZiAoZmluZFxuICAgICAgdCBrZXkpXS4gKilcbiAgdmFsIGNoYW5nZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbikgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG5cbiAgKCoqIFJldHVybnMgW1NvbWUgdmFsdWVdIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIFtOb25lXSBpZiBub25lIGV4aXN0cy4gKilcbiAgdmFsIGZpbmQgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2IG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCByYWlzaW5nIFtDYW1sLk5vdF9mb3VuZF0gb3IgW05vdF9mb3VuZF9zXVxuICAgICAgaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3ZcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBhbnkgYmluZGluZyBmb3IgdGhlIGtleSBpbiBxdWVzdGlvbiByZW1vdmVkLiAqKVxuICB2YWwgcmVtb3ZlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFttZW0gbWFwIGtleV0gdGVzdHMgd2hldGhlciBbbWFwXSBjb250YWlucyBhIGJpbmRpbmcgZm9yIFtrZXldLiAqKVxuICB2YWwgbWVtIDogKCdrLCBfLCAnY21wKSB0IC0+ICdrIC0+IGJvb2xcblxuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZXMgdW50aWwgdGhlIGZpcnN0IHRpbWUgW2ZdIHJldHVybnMgW1N0b3BdLiBJZiBbZl0gcmV0dXJucyBbU3RvcF0sIHRoZSBmaW5hbFxuICAgICAgcmVzdWx0IGlzIFtVbmZpbmlzaGVkXS4gT3RoZXJ3aXNlLCB0aGUgZmluYWwgcmVzdWx0IGlzIFtGaW5pc2hlZF0uICopXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgKCoqIEl0ZXJhdGVzIHR3byBtYXBzIHNpZGUgYnkgc2lkZS4gVGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBmdW5jdGlvbiBpcyBPKE0gKyBOKS4gIElmIHR3b1xuICAgICAgaW5wdXRzIGFyZSBbWygwLCBhKTsgKDEsIGEpXV0gYW5kIFtbKDEsIGIpOyAoMiwgYildXSwgW2ZdIHdpbGwgYmUgY2FsbGVkIHdpdGggW1soMCxcbiAgICAgIGBMZWZ0IGEpOyAoMSwgYEJvdGggKGEsIGIpKTsgKDIsIGBSaWdodCBiKV1dLiAqKVxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYm91bmQgdmFsdWVzIHJlcGxhY2VkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZCB2YWx1ZXMuKilcbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHRha2VzIGJvdGggW2tleV0gYW5kIFtkYXRhXSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogQ29udmVydCBtYXAgd2l0aCBrZXlzIG9mIHR5cGUgWydrMl0gdG8gYSBtYXAgd2l0aCBrZXlzIG9mIHR5cGUgWydrMl0gdXNpbmcgW2ZdLiAqKVxuICB2YWwgbWFwX2tleXNcbiAgICA6ICAoJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICAoKiogTGlrZSBbbWFwX2tleXNdLCBidXQgcmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICAoJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSB0XG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkIDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKSAtPiAnYVxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLCB1bnRpbCB0aGUgZmlyc3RcbiAgICAgIHRpbWUgdGhhdCBbZl0gcmV0dXJucyBbU3RvcCBfXS4gSWYgW2ZdIHJldHVybnMgW1N0b3AgZmluYWxdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgIGltbWVkaWF0ZWx5IHdpdGggdGhlIHZhbHVlIFtmaW5hbF0uIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCBhbmQgdGhlIGZpbmFsXG4gICAgICBjYWxsIHRvIFtmXSByZXR1cm5zIFtDb250aW51ZSBsYXN0XSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFtmaW5pc2ggbGFzdF0uICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBkZWNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZF9yaWdodCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICAoKiogRm9sZHMgb3ZlciB0d28gbWFwcyBzaWRlIGJ5IHNpZGUsIGxpa2UgW2l0ZXIyXS4gKilcbiAgdmFsIGZvbGQyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYSAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbZmlsdGVyXSwgW2ZpbHRlcmldLCBbZmlsdGVyX2tleXNdLCBbZmlsdGVyX21hcF0sIGFuZCBbZmlsdGVyX21hcGldIHJ1biBpbiBPKG4gKiBsZ1xuICAgICAgbikgdGltZTsgdGhleSBzaW1wbHkgYWNjdW11bGF0ZSBlYWNoIGtleSAmIGRhdGEgcGFpciByZXRhaW5lZCBieSBbZl0gaW50byBhIG5ldyBtYXBcbiAgICAgIHVzaW5nIFthZGRdLiAqKVxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZmlsdGVyIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYm91bmQgdmFsdWVzIGZpbHRlcmVkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZCB2YWx1ZXMuICopXG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXNcbiAgICAgIGFyZ3VtZW50cy4gKilcbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcGkgdCB+Zl0gcmV0dXJucyB0d28gbmV3IFt0XXMsIHdpdGggZWFjaCBrZXkgaW4gW3RdIGFwcGVhcmluZyBpblxuICAgICAgZXhhY3RseSBvbmUgb2YgdGhlIHJlc3VsdGluZyBtYXBzIGRlcGVuZGluZyBvbiBpdHMgbWFwcGluZyBpbiBbZl0uICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooJ3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKlxuICAgICB7W1xuICAgICAgIHBhcnRpdGlvbmlfdGYgdCB+ZlxuICAgICAgID1cbiAgICAgICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgaWYgZiB+a2V5IH5kYXRhXG4gICAgICAgICB0aGVuIEZpcnN0IGRhdGFcbiAgICAgICAgIGVsc2UgU2Vjb25kIGRhdGEpXG4gICAgIF19ICopXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSldICopXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBQcm9kdWNlcyBbT2tdIG9mIGEgbWFwIGluY2x1ZGluZyBhbGwga2V5cyBpZiBhbGwgZGF0YSBpcyBbT2tdLCBvciBhbiBbRXJyb3JdXG4gICAgICBpbmNsdWRpbmcgYWxsIGVycm9ycyBvdGhlcndpc2UuICopXG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogUmV0dXJucyBhIHRvdGFsIG9yZGVyaW5nIGJldHdlZW4gbWFwcy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgdG90YWwgb3JkZXJpbmcgdXNlZFxuICAgICAgdG8gY29tcGFyZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlcXVhbCBrZXlzIGluIHRoZSB0d28gbWFwcy4gKilcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludFxuXG4gICgqKiBIYXNoIGZ1bmN0aW9uOiBhIGJ1aWxkaW5nIGJsb2NrIHRvIHVzZSB3aGVuIGhhc2hpbmcgZGF0YSBzdHJ1Y3R1cmVzIGNvbnRhaW5pbmcgbWFwcyBpblxuICAgICAgdGhlbS4gW2hhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFtjb21wYXJlX2RpcmVjdF0gaWZmXG4gICAgICBbaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFsoY29tcGFyYXRvciBtKS5jb21wYXJlXSBvZiB0aGUgbWFwIFttXSBiZWluZ1xuICAgICAgaGFzaGVkLiAqKVxuICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdrIEhhc2guZm9sZGVyIC0+ICd2IEhhc2guZm9sZGVyIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAoKiogW2VxdWFsIGNtcCBtMSBtMl0gdGVzdHMgd2hldGhlciB0aGUgbWFwcyBbbTFdIGFuZCBbbTJdIGFyZSBlcXVhbCwgdGhhdCBpcywgY29udGFpblxuICAgICAgdGhlIHNhbWUga2V5cyBhbmQgYXNzb2NpYXRlIGVhY2gga2V5IHdpdGggdGhlIHNhbWUgdmFsdWUuICBbY21wXSBpcyB0aGUgZXF1YWxpdHlcbiAgICAgIHByZWRpY2F0ZSB1c2VkIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleXMuICopXG4gIHZhbCBlcXVhbCA6ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUga2V5cyBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBsaXN0XG5cbiAgKCoqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCBkYXRhIDogKF8sICd2LCBfKSB0IC0+ICd2IGxpc3RcblxuICAoKiogQ3JlYXRlcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGZyb20gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAoKiogZGVmYXVsdCBpcyBbYEluY3JlYXNpbmddICopXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIHsyIEFkZGl0aW9uYWwgb3BlcmF0aW9ucyBvbiBtYXBzfSAqKVxuXG4gICgqKiBNZXJnZXMgdHdvIG1hcHMuIFRoZSBydW50aW1lIGlzIE8obGVuZ3RoKHQxKSArIGxlbmd0aCh0MikpLiBZb3Ugc2hvdWxkbid0IHVzZSB0aGlzXG4gICAgICBmdW5jdGlvbiB0byBtZXJnZSBhIGxpc3Qgb2YgbWFwczsgY29uc2lkZXIgdXNpbmcgW21lcmdlX3NrZXdlZF0gaW5zdGVhZC4gKilcbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiAoJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAndjMgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqIEEgc3BlY2lhbCBjYXNlIG9mIFttZXJnZV0sIFttZXJnZV9za2V3ZWQgdDEgdDJdIGlzIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZVxuICAgICAgYmluZGluZ3Mgb2YgW3QxXSBhbmQgW3QyXS4gQmluZGluZ3MgdGhhdCBhcHBlYXIgaW4gYm90aCBbdDFdIGFuZCBbdDJdIGFyZVxuICAgICAgY29tYmluZWQgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyB0aGUgW2NvbWJpbmVdIGZ1bmN0aW9uLiBJbiBhIGNhbGxcbiAgICAgIFtjb21iaW5lIH5rZXkgdjEgdjJdLCB0aGUgdmFsdWUgW3YxXSBjb21lcyBmcm9tIFt0MV0gYW5kIFt2Ml0gZnJvbSBbdDJdLlxuXG4gICAgICBUaGUgcnVudGltZSBvZiBbbWVyZ2Vfc2tld2VkXSBpcyBbTyhtaW4obDEsIGwyKSAqIGxvZyhtYXgobDEsIGwyKSkpXSwgd2hlcmUgW2wxXSBpc1xuICAgICAgdGhlIGxlbmd0aCBvZiBbdDFdIGFuZCBbbDJdIHRoZSBsZW5ndGggb2YgW3QyXS4gVGhpcyBpcyBsaWtlbHkgdG8gYmUgZmFzdGVyIHRoYW5cbiAgICAgIFttZXJnZV0gd2hlbiBvbmUgb2YgdGhlIG1hcHMgaXMgYSBsb3Qgc21hbGxlciwgb3Igd2hlbiB5b3UgbWVyZ2UgYSBsaXN0IG9mIG1hcHMuICopXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgbW9kdWxlIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hclxuICAgICAgOiAgJ2sgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICAoKiogW3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsXSByZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS5cbiAgICAgIEl0IGlzIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50XG4gICAgICBvZiBzdHJ1Y3R1cmUuIFRoZSBrZXlzIGluIHRoZSBvdXRwdXQgc2VxdWVuY2Ugd2lsbCBiZSBpbiBzb3J0ZWQgb3JkZXIuXG5cbiAgICAgIEl0IGlzIGFzc3VtZWQgdGhhdCBbZGF0YV9lcXVhbF0gaXMgYXQgbGVhc3QgYXMgZXF1YXRpbmcgYXMgcGh5c2ljYWwgZXF1YWxpdHk6IHRoYXRcbiAgICAgIFtwaHlzX2VxdWFsIHggeV0gaW1wbGllcyBbZGF0YV9lcXVhbCB4IHldLiBPdGhlcndpc2UsIFtzeW1tZXRyaWNfZGlmZl0gbWF5IGJlaGF2ZSBpblxuICAgICAgdW5leHBlY3RlZCB3YXlzLiBGb3IgZXhhbXBsZSwgd2l0aCBbfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gZmFsc2UpXSBpdCBpcyBOT1RcbiAgICAgIG5lY2Vzc2FyaWx5IHRoZSBjYXNlIHRoZSByZXN1bHRpbmcgY2hhbmdlIHNlcXVlbmNlIHdpbGwgY29udGFpbiBhbiBlbGVtZW50XG4gICAgICBbKGssIGBVbmVxdWFsIF8pXSBmb3IgZXZlcnkga2V5IFtrXSBzaGFyZWQgYnkgYm90aCBtYXBzLlxuXG4gICAgICBXYXJuaW5nOiBGbG9hdCBlcXVhbGl0eSB2aW9sYXRlcyB0aGlzIHByb3BlcnR5ISBbcGh5c19lcXVhbCBGbG9hdC5uYW4gRmxvYXQubmFuXSBpc1xuICAgICAgdHJ1ZSwgYnV0IFtGbG9hdC4oPSkgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXMgZmFsc2UuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gICgqKiBbZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gZm9sZHMgYWNyb3NzIGFuIGltcGxpY2l0IHNlcXVlbmNlIG9mIGNoYW5nZXNcbiAgICAgIGJldHdlZW4gW3QxXSBhbmQgW3QyXSwgaW4gc29ydGVkIG9yZGVyIGJ5IGtleXMuIEVxdWl2YWxlbnQgdG9cbiAgICAgIFtTZXF1ZW5jZS5mb2xkIChzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCldLCBhbmQgbW9yZSBlZmZpY2llbnQuICopXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOignYSAtPiAoJ2ssICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW21pbl9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1pbmltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBbbWF4X2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWF4aW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgW21hcF0gaXMgZW1wdHkuICopXG4gIHZhbCBtYXhfZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIHRoZSBzYW1lIHNlbWFudGljcyBhcyBzaW1pbGFyIGZ1bmN0aW9ucyBpbiBbTGlzdF0uICopXG5cbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gaW50XG5cblxuICAoKiogW3NwbGl0IHQga2V5XSByZXR1cm5zIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrZXldLCB0aGUgbWFwcGluZyBvZiBba2V5XSBpZlxuICAgICAgYW55LCBhbmQgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBncmVhdGVyIHRoYW4gW2tleV0uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gb3V0cHV0IG1hcHMuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBtYXBzLiAqKVxuICB2YWwgc3BsaXRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gJ2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2FwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydF0gcmV0dXJucyBbYE9rIG1hcF0gd2hlcmUgW21hcF0gY29udGFpbnMgYWxsIHRoZVxuICAgICAgWyhrZXksIHZhbHVlKV0gcGFpcnMgZnJvbSB0aGUgdHdvIGlucHV0IG1hcHMgaWYgYWxsIHRoZSBrZXlzIGZyb20gW2xvd2VyX3BhcnRdIGFyZVxuICAgICAgbGVzcyB0aGFuIGFsbCB0aGUga2V5cyBmcm9tIFt1cHBlcl9wYXJ0XS4gIE90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICBbYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNdLlxuXG4gICAgICBSdW50aW1lIGlzIE8obG9nIG4pIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGxhcmdlciBpbnB1dCBtYXAuICBUaGlzIGNhbiBiZVxuICAgICAgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiBbTWFwLm1lcmdlXSBvciByZXBlYXRlZCBbTWFwLmFkZF0uXG5cbiAgICAgIHtbXG4gICAgICAgIGFzc2VydCAobWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgfCBgT2sgd2hvbGVfbWFwIC0+XG4gICAgICAgICAgICBNYXAudG9fYWxpc3Qgd2hvbGVfbWFwXG4gICAgICAgICAgICA9IExpc3QuYXBwZW5kICh0b19hbGlzdCBsb3dlcl9wYXJ0KSAodG9fYWxpc3QgdXBwZXJfcGFydClcbiAgICAgICAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+IHRydWUpO1xuICAgICAgXX0gKilcbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgKCoqIFtzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRdIHJldHVybnMgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGVudHJpZXMgZnJvbVxuICAgICAgW3RdIHdob3NlIGtleXMgbGllIGluc2lkZSB0aGUgaW50ZXJ2YWwgaW5kaWNhdGVkIGJ5IFt+bG93ZXJfYm91bmRdIGFuZFxuICAgICAgW351cHBlcl9ib3VuZF0uICBJZiB0aGlzIGludGVydmFsIGlzIGVtcHR5LCBhbiBlbXB0eSBtYXAgaXMgcmV0dXJuZWQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBvdXRwdXQgbWFwLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICBvdXRwdXQgbWFwLiAqKVxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtmb2xkX3JhbmdlX2luY2x1c2l2ZSB0IH5taW4gfm1heCB+aW5pdCB+Zl0gZm9sZHMgW2ZdICh3aXRoIGluaXRpYWwgdmFsdWUgW35pbml0XSlcbiAgICAgIG92ZXIgYWxsIGtleXMgKGFuZCB0aGVpciBhc3NvY2lhdGVkIHZhbHVlcykgdGhhdCBhcmUgaW4gdGhlIHJhbmdlIFtbbWluLCBtYXhdXVxuICAgICAgKGluY2x1c2l2ZSkuICAqKVxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbWluOidrXG4gICAgLT4gbWF4OidrXG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFtyYW5nZV90b19hbGlzdCB0IH5taW4gfm1heF0gcmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBsaXN0IG9mIHRoZSBlbGVtZW50cyB3aG9zZSBrZXlzXG4gICAgICBsaWUgaW4gW1ttaW4sIG1heF1dIChpbmNsdXNpdmUpLCB3aXRoIHRoZSBzbWFsbGVzdCBrZXkgYmVpbmcgYXQgdGhlIGhlYWQgb2YgdGhlXG4gICAgICBsaXN0LiAqKVxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayAtPiBtYXg6J2sgLT4gKCdrICogJ3YpIGxpc3RcblxuICAoKiogW2Nsb3Nlc3Rfa2V5IHQgZGlyIGtdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdIHdpdGggW2tleV0gY2xvc2VzdCB0b1xuICAgICAgW2tdIHRoYXQgc2F0aXNmaWVzIHRoZSBnaXZlbiBpbmVxdWFsaXR5IGJvdW5kLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgW2Nsb3Nlc3Rfa2V5IHQgYExlc3NfdGhhbiBrXSB3b3VsZCBiZSB0aGUgcGFpciB3aXRoIHRoZSBjbG9zZXN0IGtleSB0b1xuICAgICAgW2tdIHdoZXJlIFtrZXkgPCBrXS5cblxuICAgICAgW3RvX3NlcXVlbmNlXSBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHNhbWUgcmVzdWx0cyBhcyBbY2xvc2VzdF9rZXldLiAgSXQgaXMgbGVzc1xuICAgICAgZWZmaWNpZW50IGZvciBpbmRpdmlkdWFsIGxvb2t1cHMgYnV0IG1vcmUgZWZmaWNpZW50IGZvciBmaW5kaW5nIG1hbnkgZWxlbWVudHMgc3RhcnRpbmdcbiAgICAgIGF0IHNvbWUgdmFsdWUuICopXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2tcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtudGggdCBuXSBmaW5kcyB0aGUgKGtleSwgdmFsdWUpIHBhaXIgb2YgcmFuayBuIChpLmUuLCBzdWNoIHRoYXQgdGhlcmUgYXJlIGV4YWN0bHkgblxuICAgICAga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gdGhlIGZvdW5kIGtleSksIGlmIG9uZSBleGlzdHMuICBPKGxvZyhsZW5ndGggdCkgKyBuKSB0aW1lLiAqKVxuICB2YWwgbnRoIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gJ2sgKiAndlxuXG4gICgqKiBbcmFuayB0IGtdIElmIFtrXSBpcyBpbiBbdF0sIHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba10gaW5cbiAgICAgIFt0XSwgYW5kIFtOb25lXSBvdGhlcndpc2UuICopXG4gIHZhbCByYW5rIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBpbnQgb3B0aW9uXG5cblxuXG4gICgqKiBbdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XVxuICAgICAgZ2l2ZXMgYSBzZXF1ZW5jZSBvZiBrZXktdmFsdWUgcGFpcnMgYmV0d2VlbiBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSwgcHJlc2VudGVkIGluIFtvcmRlcl0uICBJZlxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA+IGtleXNfbGVzc19vcl9lcXVhbF90b10sIHRoZSBzZXF1ZW5jZSBpc1xuICAgICAgZW1wdHkuXG5cbiAgICAgIFdoZW4gbmVpdGhlciBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBub3IgW2tleXNfbGVzc19vcl9lcXVhbF90b10gYXJlXG4gICAgICBwcm92aWRlZCwgdGhlIGNvc3QgaXMgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIHRvIHByb2R1Y2VcbiAgICAgIGVhY2ggZWxlbWVudC4gSWYgZWl0aGVyIGlzIHByb3ZpZGVkIChhbmQgaXMgdXNlZCBieSB0aGUgb3JkZXIgcGFyYW1ldGVyXG4gICAgICBwcm92aWRlZCksIHRoZW4gdGhlIHRoZSBjb3N0IGlzIE8obikgdXAgZnJvbnQsIGFuZCBhbW9ydGl6ZWQgTygxKSB0b1xuICAgICAgcHJvZHVjZSBlYWNoIGVsZW1lbnQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzona1xuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdXG4gICAgICBzcGVjaWZpZWQgYnkgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgICAgXVxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZVxuICAgICAgc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGVcbiAgICAgIGxlZnQgc2VnbWVudCwgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LlxuICAgICAgSXQgcmV0dXJucyBbTm9uZV0gaWYgdGhlIHNlZ21lbnQgaXMgZW1wdHkuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbc2VnbWVudF9vZl0gc2VnbWVudHMgW3RdIGFzIGluIHRoZVxuICAgICAgZGlhZ3JhbSwgYW5kIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBkb2Vzbid0IHNlZ21lbnQgW3RdLiAgQmVoYXZpb3JcbiAgICAgIGlzIGFsc28gdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zdWJyYW5nZV0gdGFrZXMgYSBbY29tcGFyZV0gZnVuY3Rpb24gdGhhdCBkaXZpZGVzIFt0XSBpbnRvIHRocmVlXG4gICAgICAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzIHdpdGggcmVzcGVjdCB0byBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdOlxuXG4gICAgICB7dlxuICAgICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgSW5fcmFuZ2UgfCBBYm92ZV91cHBlcl9ib3VuZCB8XG4gICAgICB2fVxuXG4gICAgICBhbmQgcmV0dXJucyBhIG1hcCBvZiB0aGUgW0luX3JhbmdlXSBzZWdtZW50LlxuXG4gICAgICBSdW50aW1lIGlzIE8obG9nIG0gKyBuKSB3aGVyZSBbbV0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgbWFwIGFuZCBbbl0gaXMgdGhlXG4gICAgICBsZW5ndGggb2YgdGhlIG91dHB1dC4gVGhlIGxpbmVhciB0ZXJtIGluIFtuXSBpcyB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dC5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIFtjb21wYXJlXSBkb2VzIG5vdCBzZWdtZW50IFt0XSBhcyBzaG93biBhYm92ZSwgb3IgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIGl0cyBpbnB1dHMuICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gaW50IE1hcC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IChTdHJpbmcudCwgaW50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBNYXAudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBNYXAuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgW1N0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzc11cbiAgICAgIC0tIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuXG5cbiAgICAgIEluIGFkZGl0aW9uLCB3aGVuIHVzaW5nIFtAQGRlcml2aW5nXSwgdGhlIHJlcXVpcmVtZW50cyBvbiB0aGUga2V5IG1vZHVsZSBhcmUgb25seVxuICAgICAgdGhvc2UgbmVlZGVkIHRvIHNhdGlzZnkgd2hhdCB5b3UgYXJlIHRyeWluZyB0byBkZXJpdmUgb24gdGhlIG1hcCBpdHNlbGYuIFNheSB5b3VcbiAgICAgIHdyaXRlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHQgPSBpbnQgTWFwLk0oWCkudCBbQEBkZXJpdmluZyBoYXNoXVxuICAgICAgXX1cblxuICAgICAgdGhlbiB0aGlzIHdpbGwgYmUgd2VsbCB0eXBlZCBleGFjdGx5IGlmIFtYXSBjb250YWlucyBhdCBsZWFzdDpcbiAgICAgIC0gYSB0eXBlIFt0XSB3aXRoIG5vIHBhcmFtZXRlcnNcbiAgICAgIC0gYSBjb21wYXJhdG9yIHdpdG5lc3NcbiAgICAgIC0gYSBbaGFzaF9mb2xkX3RdIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IHR5cGUgKilcbiAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdrZXksICd2YWx1ZSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0XG5cbiAgKCoqIFtVc2luZ19jb21wYXJhdG9yXSBpcyBhIHNpbWlsYXIgaW50ZXJmYWNlIGFzIHRoZSB0b3BsZXZlbCBvZiBbTWFwXSwgZXhjZXB0IHRoZVxuICAgICAgZnVuY3Rpb25zIHRha2UgYSBbfmNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRdLCB3aGVyZWFzIHRoZSBmdW5jdGlvbnMgYXQgdGhlXG4gICAgICB0b3BsZXZlbCBvZiBbTWFwXSB0YWtlIGEgWygnaywgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdrLCArJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgIG1vZHVsZSBUcmVlIDogc2lnXG4gICAgICB0eXBlICgrJ2ssICsndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICB2YWwgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA6IChfLCBfLCBfKSB0XG5cbiAgICAgICgqKiBbQnVpbGRfaW5jcmVhc2luZ10gY2FuIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgbWFwIGluY3JlbWVudGFsbHkgZnJvbSBhXG4gICAgICAgICAgc2VxdWVuY2UgdGhhdCBpcyBrbm93biB0byBiZSBpbmNyZWFzaW5nLlxuXG4gICAgICAgICAgVGhlIHRvdGFsIHRpbWUgY29tcGxleGl0eSBvZiBjb25zdHJ1Y3RpbmcgYSBtYXAgdGhpcyB3YXkgaXMgTyhuKSwgd2hpY2ggaXMgbW9yZVxuICAgICAgICAgIGVmZmljaWVudCB0aGFuIHVzaW5nIFtNYXAuYWRkXSBieSBhIGxvZ2FyaXRobWljIGZhY3Rvci5cblxuICAgICAgICAgIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgZHVhbCBvZiBbdG9fc2VxdWVuY2VdLCBidXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIGFuIGVxdWFsbHkgbmVhdCBpZGlvbSBmb3IgdGhlIGR1YWxzIG9mIHNlcXVlbmNlcyAoW29mX3NlcXVlbmNlXSBpcyBtdWNoIGxlc3NcbiAgICAgICAgICBnZW5lcmFsIGJlY2F1c2UgaXQgZG9lcyBub3QgYWxsb3cgdGhlIHNlcXVlbmNlIHRvIGJlIHByb2R1Y2VkIGFzeW5jaHJvbm91c2x5KS4gKilcbiAgICAgIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nIDogc2lnXG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgdHlwZSAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgIHZhbCBlbXB0eSA6ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBvZiBbYWRkX2V4bl0gaXMgYW1vcnRpemVkIGNvbnN0YW50LXRpbWUgKGlmIFt0XSBpcyB1c2VkXG4gICAgICAgICAgICBsaW5lYXJseSksIHdpdGggYSB3b3JzdC1jYXNlIE8obG9nKG4pKSB0aW1lLiAqKVxuICAgICAgICB2YWwgYWRkX2V4blxuICAgICAgICAgIDogICgnaywgJ3YsICd3KSB0XG4gICAgICAgICAgLT4gY29tcGFyYXRvcjooJ2ssICd3KSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiBrZXk6J2tcbiAgICAgICAgICAtPiBkYXRhOid2XG4gICAgICAgICAgLT4gKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICAoKiogVGltZSBjb21wbGV4aXR5IGlzIE8obG9nKG4pKS4gKilcbiAgICAgICAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAndykgdCAtPiAoJ2ssICd2LCAndykgdHJlZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlXG4gICAgICBBY2Nlc3NvcnMzXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG5cbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG5cbiAgICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICAgdmFsIGhhc2hfZm9sZF9kaXJlY3RcbiAgICAgIDogICdrIEhhc2guZm9sZGVyXG4gICAgICAtPiAndiBIYXNoLmZvbGRlclxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICAgKCoqIFRvIGdldCBhcm91bmQgdGhlIHZhbHVlIHJlc3RyaWN0aW9uLCBhcHBseSB0aGUgZnVuY3RvciBhbmQgaW5jbHVkZSBpdC4gWW91XG4gICAgICAgIGNhbiBzZWUgYW4gZXhhbXBsZSBvZiB0aGlzIGluIHRoZSBbUG9seV0gc3VibW9kdWxlIGJlbG93LiAqKVxuICAgIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChLIDogQ29tcGFyYXRvci5TMSkgOiBzaWdcbiAgICAgIHZhbCBlbXB0eSA6ICgnYSBLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcblxuICAoKiogQSBwb2x5bW9ycGhpYyBNYXAuICopXG4gIG1vZHVsZSBQb2x5IDpcbiAgICBTX3BvbHlcbiAgICB3aXRoIHR5cGUgKCdrZXksICsndmFsdWUpIHQgPSAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgIGFuZCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0cmVlID1cbiAgICAgICAgICAgKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICgqKiBDcmVhdGUgYSBtYXAgZnJvbSBhIHRyZWUgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmF0b3IuICopXG4gIHZhbCBvZl90cmVlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIEV4dHJhY3QgYSB0cmVlIGZyb20gYSBtYXAuICopXG4gIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuXG5cbiAgKCoqIHsyIE1vZHVsZXMgYW5kIG1vZHVsZSB0eXBlcyBmb3IgZXh0ZW5kaW5nIFtNYXBdfVxuXG4gICAgICBGb3IgdXNlIGluIGV4dGVuc2lvbnMgb2YgQmFzZSwgbGlrZSBbQ29yZV0uICopXG5cbiAgbW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IFdpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxuICBtb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gV2l0aG91dF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gQWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gQWNjZXNzb3JzMlxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gQWNjZXNzb3JzM1xuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9IEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gQWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gQ3JlYXRvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IENyZWF0b3JzMlxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yID0gQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPVxuICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIHR5cGUgRWx0X3BsYWluID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhvdXRfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gTWFwX2ludGYuV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbm1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50ID0gU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuR2VuZXJpY19waGFudG9tXG5cbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICAoKiogVGhlIFtvcHRpb25zXSB0eXBlIGlzIHVzZWQgdG8gbWFrZSBbQWNjZXNzb3JzX2dlbmVyaWNdIGZsZXhpYmxlIGFzIHRvIHdoZXRoZXIgYVxuICAgICAgY29tcGFyYXRvciBpcyByZXF1aXJlZCB0byBiZSBwYXNzZWQgdG8gY2VydGFpbiBmdW5jdGlvbnMuICopXG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgaW52YXJpYW50cyA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcblxuICAoKiogb3ZlcnJpZGUgW0NvbnRhaW5lcl0ncyBbbWVtXSAqKVxuICB2YWwgbWVtIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+IGJvb2wpIG9wdGlvbnNcblxuICB2YWwgYWRkIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgdW5pb24gOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EgZWx0LCAnYSBlbHQpIEVpdGhlci50IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludCkgb3B0aW9uc1xuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuXG4gIHR5cGUgKCdhLCAnY21wKSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXRcbiAgICAgIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIG5hbWVkIC0+IG9mXzooJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSBuYW1lZCAtPiAoJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudCkgb3B0aW9uc1xuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSBlbHQgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYiAtPiBmOignYSBlbHQgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgZWx0IHwgYFJpZ2h0IG9mICdhIGVsdCB8IGBCb3RoIG9mICdhIGVsdCAqICdhIGVsdCBdIC0+IHVuaXQpXG4gICAgICAtPiB1bml0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCAqICdhIGVsdCBvcHRpb24gKiAoJ2EsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGdyb3VwX2J5XG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSBlbHQgLT4gJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0XG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gJ2EgZWx0IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAna2V5IC0+IGludClcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgICAgLT4gJ2tleVxuICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgIC0+IHNlZ21lbnRfb2Y6KCdhIGVsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAtPiAnYSBlbHQgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiAoJ2EgZWx0LCAnYSBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczAgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzBcblxuICB0eXBlIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IHQgLT4gYm9vbFxuICB2YWwgbWVtIDogdCAtPiBlbHQgLT4gYm9vbFxuICB2YWwgYWRkIDogdCAtPiBlbHQgLT4gdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBlbHQgLT4gdFxuICB2YWwgdW5pb24gOiB0IC0+IHQgLT4gdFxuICB2YWwgaW50ZXIgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGlmZiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6IHQgLT4gdCAtPiAoZWx0LCBlbHQpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgaXNfc3Vic2V0IDogdCAtPiBvZl86dCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiB0IC0+IHQgLT4gYm9vbFxuXG4gIHR5cGUgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogbmFtZWQgLT4gb2ZfOm5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgIHZhbCBlcXVhbCA6IG5hbWVkIC0+IG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gZWx0IC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogdCAtPiBpbml0OidiIC0+IGY6KGVsdCAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICB0XG4gICAgLT4gdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgZWx0IHwgYFJpZ2h0IG9mIGVsdCB8IGBCb3RoIG9mIGVsdCAqIGVsdCBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXIgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0ICogdFxuICB2YWwgZWxlbWVudHMgOiB0IC0+IGVsdCBsaXN0XG4gIHZhbCBtaW5fZWx0IDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6IHQgLT4gZWx0XG4gIHZhbCBtYXhfZWx0IDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6IHQgLT4gZWx0XG4gIHZhbCBjaG9vc2UgOiB0IC0+IGVsdCBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiB0IC0+IGVsdFxuICB2YWwgc3BsaXQgOiB0IC0+IGVsdCAtPiB0ICogZWx0IG9wdGlvbiAqIHRcbiAgdmFsIGdyb3VwX2J5IDogdCAtPiBlcXVpdjooZWx0IC0+IGVsdCAtPiBib29sKSAtPiB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0XG4gIHZhbCBudGggOiB0IC0+IGludCAtPiBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiB0IC0+IGludCAtPiB0XG4gIHZhbCB0b190cmVlIDogdCAtPiB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gdFxuICAgIC0+IGVsdCBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICB0XG4gICAgLT4gY29tcGFyZTooZWx0IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGVsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzplbHRcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzplbHRcbiAgICAtPiB0XG4gICAgLT4gdFxuICAgIC0+IChlbHQsIGVsdCkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMxXG5cbiAgdHlwZSAnYSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiBfIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgdW5pb24gOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgaW50ZXIgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgZGlmZiA6ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICdhIHQgLT4gJ2EgdCAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6ICdhIHQgLT4gb2ZfOidhIHQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcblxuICB0eXBlICdhIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6ICdhIG5hbWVkIC0+IG9mXzonYSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiAnYSBuYW1lZCAtPiAnYSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KCdhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBlbGVtZW50cyA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICdhIHQgLT4gJ2FcbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICdhIHQgLT4gJ2FcbiAgdmFsIHNwbGl0IDogJ2EgdCAtPiAnYSAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICB2YWwgZ3JvdXBfYnkgOiAnYSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAnYSB0IC0+IGludCAtPiAnYSB0XG4gIHZhbCB0b190cmVlIDogJ2EgdCAtPiAnYSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICdhIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICdhIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMV9waGFudG9tX2ludmFyaWFudFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdW5pb24gOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gIHR5cGUgKCdhLCAnY21wKSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIG5hbWVkIC0+IG9mXzooJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgbmFtZWQgLT4gKCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYiAtPiBmOignYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgc3BsaXQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMxX3BoYW50b21faW52YXJpYW50XG5cbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHVuaW9uXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBpbnRlclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWwgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gIHZhbCBpc19zdWJzZXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gb2ZfOignYSwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwgYXJlX2Rpc2pvaW50XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiBvZl86KCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2EgLT4gJ2FjY3VtIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOignYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICB2YWwgc3BsaXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcblxuICB2YWwgZ3JvdXBfYnlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0IGxpc3RcblxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHJlbW92ZV9pbmRleFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBpbnRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbigqKiBDb25zaXN0ZW5jeSBjaGVja3MgKHNhbWUgYXMgaW4gW0NvbnRhaW5lcl0pLiAqKVxubW9kdWxlIENoZWNrX2FjY2Vzc29yc1xuICAgIChUIDogVDIpXG4gICAgKFRyZWUgOiBUMilcbiAgICAoRWx0IDogVDEpXG4gICAgKE5hbWVkIDogVDIpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczAgKE0gOiBBY2Nlc3NvcnMwKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5lbHRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMSAoTSA6IEFjY2Vzc29yczEpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyIChNIDogQWNjZXNzb3JzMikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yIChNIDogQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuICB0eXBlICdhIGVsdFxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXAsICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGxpc3QgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9hcnJheSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICgnYSwgJ2NtcCwgbGVuOmludCAtPiBmOihpbnQgLT4gJ2EgZWx0KSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAoJ2EsIF8sICdhIGVsdCBsaXN0IC0+ICdhIGVsdCBsaXN0KSBvcHRpb25zXG5cbiAgKCoqIFRoZSB0eXBlcyBvZiBbbWFwXSBhbmQgW2ZpbHRlcl9tYXBdIGFyZSBzdWJ0bGUuICBUaGUgaW5wdXQgc2V0LCBbKCdhLCBfKSBzZXRdLFxuICAgICAgcmVmbGVjdHMgdGhlIGZhY3QgdGhhdCB0aGVzZSBmdW5jdGlvbnMgdGFrZSBhIHNldCBvZiAqYW55KiB0eXBlLCB3aXRoIGFueVxuICAgICAgY29tcGFyYXRvciwgd2hpbGUgdGhlIG91dHB1dCBzZXQsIFsoJ2IsICdjbXApIHRdLCByZWZsZWN0cyB0aGF0IHRoZSBvdXRwdXQgc2V0IGhhc1xuICAgICAgdGhlIHBhcnRpY3VsYXIgWydjbXBdIG9mIHRoZSBjcmVhdGlvbiBmdW5jdGlvbi4gIFRoZSBjb21wYXJhdG9yIGNhbiBjb21lIGluIG9uZSBvZlxuICAgICAgdGhyZWUgd2F5cywgZGVwZW5kaW5nIG9uIHdoaWNoIHNldCBtb2R1bGUgaXMgdXNlZFxuXG4gICAgICAtIFtTZXQubWFwXSAtLSBjb21wYXJhdG9yIGNvbWVzIGFzIGFuIGFyZ3VtZW50XG4gICAgICAtIFtTZXQuUG9seS5tYXBdIC0tIGNvbXBhcmF0b3IgaXMgcG9seW1vcnBoaWMgY29tcGFyaXNvblxuICAgICAgLSBbRm9vLlNldC5tYXBdIC0tIGNvbXBhcmF0b3IgaXMgW0Zvby5jb21wYXJhdG9yXSAqKVxuICB2YWwgbWFwIDogKCdiLCAnY21wLCAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBlbHQpIC0+ICgnYiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2IsICdjbXAsICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIGVsdCBvcHRpb24pIC0+ICgnYiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdhLCAnY21wLCAoJ2EgZWx0LCAnY21wKSB0cmVlIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMCA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgdFxuICB0eXBlIHRyZWVcbiAgdHlwZSBlbHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiB0XG4gIHZhbCBzaW5nbGV0b24gOiBlbHQgLT4gdFxuICB2YWwgdW5pb25fbGlzdCA6IHQgbGlzdCAtPiB0XG4gIHZhbCBvZl9saXN0IDogZWx0IGxpc3QgLT4gdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiBlbHQgU2VxdWVuY2UudCAtPiB0XG4gIHZhbCBvZl9hcnJheSA6IGVsdCBhcnJheSAtPiB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogZWx0IGFycmF5IC0+IHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gZWx0KSAtPiB0XG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6IGVsdCBsaXN0IC0+IGVsdCBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiBlbHQpIC0+IHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiBlbHQgb3B0aW9uKSAtPiB0XG4gIHZhbCBvZl90cmVlIDogdHJlZSAtPiB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuICB2YWwgb2ZfbGlzdCA6ICdhIGxpc3QgLT4gJ2EgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAnYSBTZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogJ2EgYXJyYXkgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogJ2EgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAnYSBsaXN0IC0+ICdhIGxpc3RcbiAgdmFsIG1hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBvZl90cmVlIDogJ2EgdHJlZSAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfbGlzdCA6ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICdhIFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAnYSBsaXN0IC0+ICdhIGxpc3RcbiAgdmFsIG1hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICgnYiwgJ2NtcCkgdFxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgZW1wdHkgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc2luZ2xldG9uIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICB2YWwgbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2IsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgXykgc2V0XG4gICAgLT4gZjooJ2EgLT4gJ2IpXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICBjb21wYXJhdG9yOignYiwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCBfKSBzZXRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3RyZWUgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnNcbiAgICAoVCA6IFQyKVxuICAgIChUcmVlIDogVDIpXG4gICAgKEVsdCA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMCAoTSA6IENyZWF0b3JzMCkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5lbHRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMxIChNIDogQ3JlYXRvcnMxKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczIgKE0gOiBDcmVhdG9yczIpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gJ2NtcFxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciAoTSA6IENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gJ2NtcFxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnNfZ2VuZXJpY1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBvcHRpb25zXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIGVsdFxuICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIGNtcFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczBcbiAgICB3aXRoIHR5cGUgdCA6PSB0XG4gICAgd2l0aCB0eXBlIHRyZWUgOj0gdHJlZVxuICAgIHdpdGggdHlwZSBlbHQgOj0gZWx0XG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczFcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMxXG4gICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgIHdpdGggdHlwZSAnYSB0cmVlIDo9ICdhIHRyZWVcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMlxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdCA6IChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2VsdCkgLT4gKCdlbHQsICdjbXApIHQgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2VsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdlbHQpXG4gICAgLT4gKCdlbHQsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190IDogKG1vZHVsZSBDb21wYXJlX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWxfbV9fdCA6IChtb2R1bGUgRXF1YWxfbSkgLT4gKCdlbHQsICdjbXApIHQgLT4gKCdlbHQsICdjbXApIHQgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2VsdCwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcblxuICB2YWwgaGFzaF9tX190IDogKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCBfKSB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNldCA9IHNpZ1xuICAoKiogU2V0cyBiYXNlZCBvbiB7IUNvbXBhcmF0b3IuU30uXG5cbiAgICAgIENyZWF0b3JzIHJlcXVpcmUgYSBjb21wYXJhdG9yIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCBpbiwgd2hlcmVhcyBhY2Nlc3NvcnMgdXNlIHRoZVxuICAgICAgY29tcGFyYXRvciBwcm92aWRlZCBieSB0aGUgaW5wdXQgc2V0LiAqKVxuXG4gICgqKiBUaGUgdHlwZSBvZiBhIHNldC4gIFRoZSBmaXJzdCB0eXBlIHBhcmFtZXRlciBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBhbmRcbiAgICAgIHRoZSBzZWNvbmQgaWRlbnRpZmllcyB0aGUgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0aGF0XG4gICAgICBpcyB1c2VkIGZvciBvcmRlcmluZyBlbGVtZW50cyBpbiB0aGlzIHNldC4gIE1hbnkgb3BlcmF0aW9ucyAoZS5nLiwgeyF1bmlvbn0pLFxuICAgICAgcmVxdWlyZSB0aGF0IHRoZXkgYmUgcGFzc2VkIHNldHMgd2l0aCB0aGUgc2FtZSBlbGVtZW50IHR5cGUgYW5kIHRoZSBzYW1lIGNvbXBhcmF0b3JcbiAgICAgIHR5cGUuICopXG4gIHR5cGUgKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdlbHQsICdjbXApIHQgOj0gKCdlbHQsICdjbXApIHRcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3RzIGludGVybmFsIGludmFyaWFudHMgb2YgdGhlIHNldCBkYXRhIHN0cnVjdHVyZS4gIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjXG4gICAgICB3aXRoIHRoZSBzYW1lIG5vdGlvbiBvZiBjb21wYXJpc29uLiAqKVxuICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgKCoqIENyZWF0ZXMgYW4gZW1wdHkgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IgdGhhdCBjb250YWlucyBvbmx5IHRoZSBwcm92aWRlZFxuICAgICAgZWxlbWVudC4gKilcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogUmV0dXJucyB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIHNldC4gW08oMSldLiAqKVxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG5cbiAgKCoqIFtpc19lbXB0eSB0XSBpcyBbdHJ1ZV0gaWZmIFt0XSBpcyBlbXB0eS4gIFtPKDEpXS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbWVtIHQgYV0gcmV0dXJucyBbdHJ1ZV0gaWZmIFthXSBpcyBpbiBbdF0uICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcblxuICAoKiogW2FkZCB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIGFkZGVkIHRvIFt0XSwgb3IgcmV0dXJucyBbdF0gaWYgW21lbSB0IGFdLlxuICAgICAgW08obG9nIG4pXS4gKilcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3JlbW92ZSB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIHJlbW92ZWQgZnJvbSBbdF0gaWYgW21lbSB0IGFdLCBvciByZXR1cm5zIFt0XVxuICAgICAgb3RoZXJ3aXNlLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uIHQxIHQyXSByZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgdHdvIHNldHMuICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uIGMgbGlzdF0gcmV0dXJucyB0aGUgdW5pb24gb2YgYWxsIHRoZSBzZXRzIGluIFtsaXN0XS4gIFRoZVxuICAgICAgW2NvbXBhcmF0b3JdIGFyZ3VtZW50IGlzIHJlcXVpcmVkIGZvciB0aGUgY2FzZSB3aGVyZSBbbGlzdF0gaXMgZW1wdHkuXG4gICAgICBbTyhtYXgoTGlzdC5sZW5ndGggbGlzdCwgbiBsb2cgbikpXSwgd2hlcmUgW25dIGlzIHRoZSBzdW0gb2Ygc2l6ZXMgb2YgdGhlIGlucHV0IHNldHMuICopXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbaW50ZXIgdDEgdDJdIGNvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2Ygc2V0cyBbdDFdIGFuZCBbdDJdLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildLiAqKVxuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbZGlmZiB0MSB0Ml0gY29tcHV0ZXMgdGhlIHNldCBkaWZmZXJlbmNlIFt0MSAtIHQyXSwgaS5lLiwgdGhlIHNldCBjb250YWluaW5nIGFsbFxuICAgICAgZWxlbWVudHMgaW4gW3QxXSB0aGF0IGFyZSBub3QgaW4gW3QyXS4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0Ml0gcmV0dXJucyBhIHNlcXVlbmNlIG9mIGNoYW5nZXMgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLiBJdCBpc1xuICAgICAgaW50ZW5kZWQgdG8gYmUgZWZmaWNpZW50IGluIHRoZSBjYXNlIHdoZXJlIFt0MV0gYW5kIFt0Ml0gc2hhcmUgYSBsYXJnZSBhbW91bnQgb2ZcbiAgICAgIHN0cnVjdHVyZS4gKilcbiAgdmFsIHN5bW1ldHJpY19kaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtjb21wYXJlX2RpcmVjdCB0MSB0Ml0gY29tcGFyZXMgdGhlIHNldHMgW3QxXSBhbmQgW3QyXS4gIEl0IHJldHVybnMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICBhcyBbY29tcGFyZV0sIGJ1dCB1bmxpa2UgY29tcGFyZSwgZG9lc24ndCByZXF1aXJlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgaW4gZm9yIHRoZVxuICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBzZXQuICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIHNldHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgcykuY29tcGFyZV0gb2YgdGhlIHNldCBbc10gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnYSBIYXNoLmZvbGRlciAtPiAoJ2EsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAoKiogW2VxdWFsIHQxIHQyXSByZXR1cm5zIFt0cnVlXSBpZmYgdGhlIHR3byBzZXRzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMuICBbTyhsZW5ndGggdDEgK1xuICAgICAgbGVuZ3RoIHQyKV0gKilcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFtleGlzdHMgdCB+Zl0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZXJlIGV4aXN0cyBhbiBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhXS4gIFtPKG4pXSxcbiAgICAgIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbZiBhXS4gKilcbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFtmb3JfYWxsIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiBmb3IgYWxsIFthXSBpbiBbdF0sIFtmIGFdLiAgW08obildLCBidXQgcmV0dXJucyBhc1xuICAgICAgc29vbiBhcyBpdCBmaW5kcyBhbiBbYV0gZm9yIHdoaWNoIFtub3QgKGYgYSldLiAqKVxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFtjb3VudCB0XSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgW3RdIGZvciB3aGljaCBbZl0gcmV0dXJucyBbdHJ1ZV0uXG4gICAgICBbTyhuKV0uICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogW3N1bSB0XSByZXR1cm5zIHRoZSBzdW0gb2YgW2YgdF0gZm9yIGVhY2ggW3RdIGluIHRoZSBzZXQuXG4gICAgICBbTyhuKV0uICopXG4gIHZhbCBzdW1cbiAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gKCdhLCBfKSB0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgKCoqIFtmaW5kIHQgZl0gcmV0dXJucyBhbiBlbGVtZW50IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgdHJ1ZSwgd2l0aCBubyBndWFyYW50ZWUgYXNcbiAgICAgIHRvIHdoaWNoIGVsZW1lbnQgaXMgcmV0dXJuZWQuICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgYSBzdWl0YWJsZSBlbGVtZW50IGlzXG4gICAgICBmb3VuZC4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtmaW5kX21hcCB0IGZdIHJldHVybnMgW2JdIGZvciBzb21lIFthXSBpbiBbdF0gZm9yIHdoaWNoIFtmIGEgPSBTb21lIGJdLiAgSWYgbm8gc3VjaFxuICAgICAgW2FdIGV4aXN0cywgdGhlbiBbZmluZF0gcmV0dXJucyBbTm9uZV0uICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgYSBzdWl0YWJsZVxuICAgICAgZWxlbWVudCBpcyBmb3VuZC4gKilcbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIExpa2UgW2ZpbmRdLCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBmYWlsdXJlLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcblxuICAoKiogW250aCB0IGldIHJldHVybnMgdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgb2YgW3RdLCBpbiBbTyhsb2cgbildIHRpbWUuICBUaGVcbiAgICAgIHNtYWxsZXN0IGVsZW1lbnQgaGFzIFtpID0gMF0uICBSZXR1cm5zIFtOb25lXSBpZiBbaSA8IDBdIG9yIFtpID49IGxlbmd0aCB0XS4gKilcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtyZW1vdmVfaW5kZXggdCBpXSByZXR1cm5zIGEgdmVyc2lvbiBvZiBbdF0gd2l0aCB0aGUgW2lddGggc21hbGxlc3QgZWxlbWVudCByZW1vdmVkLFxuICAgICAgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlIHNtYWxsZXN0IGVsZW1lbnQgaGFzIFtpID0gMF0uICBSZXR1cm5zIFt0XSBpZiBbaSA8IDBdIG9yXG4gICAgICBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXApIHQgLT4gaW50IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbaXNfc3Vic2V0IHQxIH5vZl86dDJdIHJldHVybnMgdHJ1ZSBpZmYgW3QxXSBpcyBhIHN1YnNldCBvZiBbdDJdLiAqKVxuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbYXJlX2Rpc2pvaW50IHQxIHQyXSByZXR1cm5zIFt0cnVlXSBpZmYgW2lzX2VtcHR5IChpbnRlciB0MSB0MildLCBidXQgaXMgbW9yZVxuICAgICAgZWZmaWNpZW50LiAqKVxuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFtOYW1lZF0gYWxsb3dzIHRoZSB2YWxpZGF0aW9uIG9mIHN1YnNldCBhbmQgZXF1YWxpdHkgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIHNldHMuICBBXG4gICAgICBbTmFtZWQudF0gaXMgYSByZWNvcmQgb2YgYSBzZXQgYW5kIGEgbmFtZSwgd2hlcmUgdGhlIG5hbWUgaXMgdXNlZCBpbiBlcnJvciBtZXNzYWdlcyxcbiAgICAgIGFuZCBbTmFtZWQuaXNfc3Vic2V0XSBhbmQgW05hbWVkLmVxdWFsXSB2YWxpZGF0ZSBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHNcbiAgICAgIHJlc3BlY3RpdmVseS5cblxuICAgICAgVGhlIGVycm9yIG1lc3NhZ2UgZm9yLCBlLmcuLFxuICAgICAge1tcbiAgICAgICAgTmFtZWQuaXNfc3Vic2V0IHsgc2V0ID0gc2V0MTsgbmFtZSA9IFwic2V0MVwiIH0gfm9mXzp7c2V0ID0gc2V0MjsgbmFtZSA9IFwic2V0MlwiIH1cbiAgICAgIF19XG5cbiAgICAgIGxvb2tzIGxpa2VcbiAgICAgIHt2XG4gICAgICAgIChcInNldDEgaXMgbm90IGEgc3Vic2V0IG9mIHNldDJcIiAoaW52YWxpZF9lbGVtZW50cyAoLi4uZWxlbWVudHMgb2Ygc2V0MSAtIHNldDIuLi4pKSlcbiAgICAgdn1cblxuICAgICAgc28gW25hbWVdIHNob3VsZCBiZSBhIG5vdW4gcGhyYXNlIHRoYXQgZG9lc24ndCBzb3VuZCBhd2t3YXJkIGluIHRoZSBhYm92ZSBlcnJvclxuICAgICAgbWVzc2FnZS4gIEV2ZW4gdGhvdWdoIGl0IGFkZHMgdmVyYm9zaXR5LCBjaG9vc2luZyBbbmFtZV1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgcGhyYXNlXG4gICAgICBcInRoZSBzZXQgb2ZcIiBvZnRlbiBtYWtlcyB0aGUgZXJyb3IgbWVzc2FnZSBzb3VuZCBtb3JlIG5hdHVyYWwuXG4gICopXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHNldCA6ICgnYSwgJ2NtcCkgdFxuICAgICAgOyBuYW1lIDogc3RyaW5nXG4gICAgICB9XG5cbiAgICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIFtPayAoKV0gaWYgW3QxXSBpcyBhIHN1YnNldCBvZiBbdDJdIGFuZCBhXG4gICAgICAgIGh1bWFuLXJlYWRhYmxlIGVycm9yIG90aGVyd2lzZS4gICopXG4gICAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgZXF1YWwgdG8gW3QyXSBhbmQgYSBodW1hbi1yZWFkYWJsZVxuICAgICAgICBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gICgqKiBUaGUgbGlzdCBvciBhcnJheSBnaXZlbiB0byBbb2ZfbGlzdF0gYW5kIFtvZl9hcnJheV0gbmVlZCBub3QgYmUgc29ydGVkLiAqKVxuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt0b19saXN0XSBhbmQgW3RvX2FycmF5XSBwcm9kdWNlIHNlcXVlbmNlcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGFjY29yZGluZyB0byB0aGVcbiAgICAgIGNvbXBhcmF0b3IuICopXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogQ3JlYXRlIHNldCBmcm9tIHNvcnRlZCBhcnJheS4gIFRoZSBpbnB1dCBtdXN0IGJlIHNvcnRlZCAoZWl0aGVyIGluIGFzY2VuZGluZyBvclxuICAgICAgZGVzY2VuZGluZyBvcmRlciBhcyBnaXZlbiBieSB0aGUgY29tcGFyYXRvcikgYW5kIGNvbnRhaW4gbm8gZHVwbGljYXRlcywgb3RoZXJ3aXNlIHRoZVxuICAgICAgcmVzdWx0IGlzIGFuIGVycm9yLiAgVGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBmdW5jdGlvbiBpcyBbTyhuKV0uICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFNpbWlsYXIgdG8gW29mX3NvcnRlZF9hcnJheV0sIGJ1dCB3aXRob3V0IGNoZWNraW5nIHRoZSBpbnB1dCBhcnJheS4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgYyB+bGVuIH5mXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgY1xuICAgICAgKEFycmF5LmluaXQgbGVuIH5mKV0sIHdpdGggdGhlIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gdGhhdCBhIGRlY3JlYXNpbmcgb3JkZXIgaXMgbm90XG4gICAgICBzdXBwb3J0ZWQuICBUaGUgYWR2YW50YWdlIGlzIG5vdCByZXF1aXJpbmcgeW91IHRvIGFsbG9jYXRlIGFuIGludGVybWVkaWF0ZSBhcnJheS4gIFtmXVxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCAwLCAxLCAuLi4gW2xlbiAtIDFdLCBpbiBvcmRlci4gKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3N0YWJsZV9kZWR1cF9saXN0XSBpcyBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBbTGlzdF0gbW9kdWxlIGJlY2F1c2UgdGhlXG4gICAgICBpbXBsZW1lbnRhdGlvbiByZWxpZXMgY3J1Y2lhbGx5IG9uIHNldHMsIGFuZCBiZWNhdXNlIGRvaW5nIHNvIGFsbG93cyBvbmUgdG8gYXZvaWQgdXNlc1xuICAgICAgb2YgcG9seW1vcnBoaWMgY29tcGFyaXNvbiBieSBpbnN0YW50aWF0aW5nIHRoZSBmdW5jdG9yIGF0IGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uXG4gICAgICBvZiBbQ29tcGFyYXRvcl0gYW5kIHVzaW5nIHRoZSByZXN1bHRpbmcgW3N0YWJsZV9kZWR1cF9saXN0XS4gKilcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGxpc3QgLT4gJ2EgbGlzdFxuXG4gICgqKiBbbWFwIGMgdCB+Zl0gcmV0dXJucyBhIG5ldyBzZXQgY3JlYXRlZCBieSBhcHBseWluZyBbZl0gdG8gZXZlcnkgZWxlbWVudCBpblxuICAgICAgW3RdLiAgVGhlIHJldHVybmVkIHNldCBpcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgW2NvbXBhcmF0b3JdLiAgW08obiBsb2cgbildLiAqKVxuICB2YWwgbWFwIDogKCdiLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgeyFtYXB9LCBleGNlcHQgZWxlbWVudHMgZm9yIHdoaWNoIFtmXSByZXR1cm5zIFtOb25lXSB3aWxsIGJlIGRyb3BwZWQuICAqKVxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2IsICdjbXApIHRcblxuICAoKiogW2ZpbHRlciB0IH5mXSByZXR1cm5zIHRoZSBzdWJzZXQgb2YgW3RdIGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICBbTyhuIGxvZ1xuICAgICAgbildLiAqKVxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSBmb2xkcyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgc2V0IGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdC4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvXG4gICAgICBsYXJnZXN0LCBzaG9ydCBjaXJjdWl0aW5nIHRoZSBmb2xkIGlmIFtmIGFjY3VtIHhdIGlzIGFuIFtFcnJvciBfXSAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cblxuICAoKiogTGlrZSB7IWZvbGR9LCBleGNlcHQgdGhhdCBpdCBnb2VzIGZyb20gdGhlIGxhcmdlc3QgdG8gdGhlIHNtYWxsZXN0IGVsZW1lbnQuICopXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhIC0+ICdhY2N1bSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbaXRlciB0IH5mXSBjYWxscyBbZl0gb24gZXZlcnkgZWxlbWVudCBvZiBbdF0sIGdvaW5nIGluIG9yZGVyIGZyb20gdGhlIHNtYWxsZXN0IHRvXG4gICAgICBsYXJnZXN0LiAgKilcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlIHR3byBzZXRzIHNpZGUgYnkgc2lkZS4gIENvbXBsZXhpdHkgaXMgW08obStuKV0gd2hlcmUgW21dIGFuZCBbbl0gYXJlIHRoZSBzaXplc1xuICAgICAgb2YgdGhlIHR3byBpbnB1dCBzZXRzLiAgQXMgYW4gZXhhbXBsZSwgd2l0aCB0aGUgaW5wdXRzIFswOyAxXSBhbmQgWzE7IDJdLCBbZl0gd2lsbCBiZVxuICAgICAgY2FsbGVkIHdpdGggW2BMZWZ0IDBdOyBbYEJvdGggKDEsIDEpXTsgYW5kIFtgUmlnaHQgMl0uICopXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIGlmIFthLCBiID0gcGFydGl0aW9uX3RmIHNldCB+Zl0gdGhlbiBbYV0gaXMgdGhlIGVsZW1lbnRzIG9uIHdoaWNoIFtmXSBwcm9kdWNlZCBbdHJ1ZV0sXG4gICAgICBhbmQgW2JdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZXMgW2ZhbHNlXS4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICAoKiogU2FtZSBhcyB7IXRvX2xpc3R9LiAqKVxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBzZXQuICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1pbl9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFJldHVybnMgdGhlIGxhcmdlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gICopXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshbWF4X2VsdH0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogcmV0dXJucyBhbiBhcmJpdHJhcnkgZWxlbWVudCwgb3IgW05vbmVdIGlmIHRoZSBzZXQgaXMgZW1wdHkuICopXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFjaG9vc2V9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFtzcGxpdCB0IHhdIHByb2R1Y2VzIGEgdHJpcGxlIFsodDEsIG1heWJlX3gsIHQyKV0gd2hlcmUgW3QxXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzXG4gICAgICBzdHJpY3RseSBsZXNzIHRoYW4gW3hdLCBbbWF5YmVfeF0gaXMgdGhlIG1lbWJlciAoaWYgYW55KSBvZiBbdF0gd2hpY2ggY29tcGFyZXMgZXF1YWxcbiAgICAgIHRvIFt4XSwgYW5kIFt0Ml0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBzdHJpY3RseSBsYXJnZXIgdGhhbiBbeF0uICopXG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcblxuICAoKiogaWYgW2VxdWl2XSBpcyBhbiBlcXVpdmFsZW5jZSBwcmVkaWNhdGUsIHRoZW4gW2dyb3VwX2J5IHNldCB+ZXF1aXZdIHByb2R1Y2VzIGEgbGlzdFxuICAgICAgb2YgZXF1aXZhbGVuY2UgY2xhc3NlcyAoaS5lLiwgYSBzZXQtdGhlb3JldGljIHF1b3RpZW50KS4gIEUuZy4sXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBjaGFycyA9IFNldC5vZl9saXN0IFsnQSc7ICdhJzsgJ2InOyAnYyddIGluXG4gICAgICAgIGxldCBlcXVpdiBjIGMnID0gQ2hhci5lcXVhbCAoQ2hhci51cHBlcmNhc2UgYykgKENoYXIudXBwZXJjYXNlIGMnKSBpblxuICAgICAgICBncm91cF9ieSBjaGFycyB+ZXF1aXZcbiAgICAgIF19XG5cbiAgICAgIHByb2R1Y2VzOlxuXG4gICAgICB7W1xuICAgICAgICBbU2V0Lm9mX2xpc3QgWydBJzsnYSddOyBTZXQuc2luZ2xldG9uICdiJzsgU2V0LnNpbmdsZXRvbiAnYyddXG4gICAgICBdfVxuXG4gICAgICBbZ3JvdXBfYnldIHJ1bnMgaW4gTyhuXjIpIHRpbWUsIHNvIGlmIHlvdSBoYXZlIGEgY29tcGFyaXNvbiBmdW5jdGlvbiwgaXQncyB1c3VhbGx5XG4gICAgICBtdWNoIGZhc3RlciB0byB1c2UgW1NldC5vZl9saXN0XS4gKilcbiAgdmFsIGdyb3VwX2J5IDogKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdFxuXG4gICgqKiBbdG9fc2VxdWVuY2UgdF0gY29udmVydHMgdGhlIHNldCBbdF0gdG8gYSBzZXF1ZW5jZSBvZiB0aGUgZWxlbWVudHMgYmV0d2VlblxuICAgICAgW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZCBbbGVzc19vcl9lcXVhbF90b10gaW5jbHVzaXZlIGluIHRoZSBvcmRlciBpbmRpY2F0ZWQgYnlcbiAgICAgIFtvcmRlcl0uICBJZiBbZ3JlYXRlcl9vcl9lcXVhbF90byA+IGxlc3Nfb3JfZXF1YWxfdG9dIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS4gIENvc3QgaXNcbiAgICAgIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSBmb3IgZWFjaCBlbGVtZW50IHByb2R1Y2VkLiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgZWxlbWVudCBpbiBbdF0gc3BlY2lmaWVkIGJ5XG4gICAgICBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBzZWdtZW50cyBhc1xuICAgICAgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGVmdCBzZWdtZW50LFxuICAgICAgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LiAgSXQgcmV0dXJuc1xuICAgICAgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgdHdvIHNldHMgYmV0d2VlbiBbZ3JlYXRlcl9vcl9lcXVhbF90b10gYW5kXG4gICAgICBbbGVzc19vcl9lcXVhbF90b10gaW4gW29yZGVyXSwgbm90aW5nIHdoZXRoZXIgZWFjaCBlbGVtZW50IGFwcGVhcnMgaW4gdGhlIGxlZnQgc2V0LFxuICAgICAgdGhlIHJpZ2h0IHNldCwgb3IgYm90aC4gIEluIHRoZSBib3RoIGNhc2UsIGJvdGggZWxlbWVudHMgYXJlIHJldHVybmVkLCBpbiBjYXNlIHRoZVxuICAgICAgY2FsbGVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuIGVsZW1lbnRzIHRoYXQgYXJlIGVxdWFsIHRvIHRoZSBzZXRzJyBjb21wYXJhdG9yLiAgUnVuc1xuICAgICAgaW4gTyhsZW5ndGggdCArIGxlbmd0aCB0JykuICopXG4gIG1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQudCA9XG4gICAgICB8IExlZnQgb2YgJ2FcbiAgICAgIHwgUmlnaHQgb2YgJ2JcbiAgICAgIHwgQm90aCBvZiAnYSAqICdiXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IFNldC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfc2V0ID0gKFN0cmluZy50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBTZXQudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW1NldC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3MsXG4gICAgICBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLiAqKVxuICBtb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICgqKiBBIHBvbHltb3JwaGljIFNldC4gKilcbiAgbW9kdWxlIFBvbHkgOiBTX3BvbHkgd2l0aCB0eXBlICdlbHQgdCA9ICgnZWx0LCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5cbiAgKCoqIFVzaW5nIGNvbXBhcmF0b3IgaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW1NldF0sIGV4Y2VwdCB0aGUgZnVuY3Rpb25zXG4gICAgICB0YWtlIGEgW35jb21wYXJhdG9yOignZWx0LCAnY21wKSBDb21wYXJhdG9yLnRdIHdoZXJlIHRoZSBmdW5jdGlvbnMgYXQgdGhlIHRvcGxldmVsIG9mXG4gICAgICBbU2V0XSB0YWtlcyBhIFsoJ2VsdCwgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnZWx0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgKCoqIEEgW1RyZWUudF0gY29udGFpbnMganVzdCB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZSB0aGF0IGEgc2V0IGlzIGJhc2VkIG9uLCB3aXRob3V0XG4gICAgICAgICAgaW5jbHVkaW5nIHRoZSBjb21wYXJhdG9yLiAgQWNjb3JkaW5nbHksIGFueSBvcGVyYXRpb24gb24gYSBbVHJlZS50XSBtdXN0IGFsc28gdGFrZVxuICAgICAgICAgIGFzIGFuIGFyZ3VtZW50IHRoZSBjb3JyZXNwb25kaW5nIGNvbXBhcmF0b3IuICopXG4gICAgICB0eXBlICgnYSwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2VsdClcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICAgIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgICAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgICAgIHsgdHJlZSA6ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgICAgIH1cblxuICAgICAgICB2YWwgaXNfc3Vic2V0XG4gICAgICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IG9mXzooJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICAgICB2YWwgZXF1YWxcbiAgICAgICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgICBlbmRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHNldCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudFxuICAgICAgICB3aXRoIG1vZHVsZSBOYW1lZCA6PSBOYW1lZFxuXG4gICAgICB2YWwgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA6IChfLCBfKSB0XG4gICAgZW5kXG5cbiAgICBpbmNsdWRlXG4gICAgICBBY2Nlc3NvcnMyXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50XG5cbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdlbHQgSGFzaC5mb2xkZXIgLT4gKCdlbHQsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiB7MiBNb2R1bGVzIGFuZCBtb2R1bGUgdHlwZXMgZm9yIGV4dGVuZGluZyBbU2V0XX1cblxuICAgICAgRm9yIHVzZSBpbiBleHRlbnNpb25zIG9mIEJhc2UsIGxpa2UgW0NvcmVdLiAqKVxuXG4gIG1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBXaXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbiAgbW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IFdpdGhvdXRfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMCA9IEFjY2Vzc29yczBcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IEFjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IEFjY2Vzc29yczJcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgPSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMCA9IENyZWF0b3JzMFxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBDcmVhdG9yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gQ3JlYXRvcnMyXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgPSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczBcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID1cbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBFbHRfcGxhaW4gPSBFbHRfcGxhaW5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V0X2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEVtcHR5XG4gICAgKCogKExlYWYgeCkgaXMgdGhlIHNhbWUgYXMgKE5vZGUgKEVtcHR5LCB4LCBFbXB0eSwgMSwgMSkpIGJ1dCB1c2VzIGxlc3Mgc3BhY2UuICopXG4gICAgfCBMZWFmIG9mICdhXG4gICAgKCogZmlyc3QgaW50IGlzIGhlaWdodCwgc2Vjb25kIGlzIHN1Yi10cmVlIHNpemUgKilcbiAgICB8IE5vZGUgb2YgJ2EgdCAqICdhICogJ2EgdCAqIGludCAqIGludFxuXG4gIHR5cGUgJ2EgdHJlZSA9ICdhIHRcblxuICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZSBjaGlsZHJlbiBkaWZmZXIgYnlcbiAgICAgYXQgbW9zdCAyLiAqKVxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzID1cbiAgICBsZXQgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdiA9XG4gICAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgfCBTb21lIGxvd2VyIC0+IGNvbXBhcmVfZWx0IGxvd2VyIHYgPCAwKVxuICAgICAgJiZcbiAgICAgIG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFNvbWUgdXBwZXIgLT4gY29tcGFyZV9lbHQgdiB1cHBlciA8IDBcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgICB8IExlYWYgdiAtPiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIGgsIG4pIC0+XG4gICAgICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICAgIGFicyAoaGwgLSBocikgPD0gMlxuICAgICAgICAmJiBoID0gbWF4IGhsIGhyICsgMVxuICAgICAgICAmJiBuID0gbGVuZ3RoIGwgKyBsZW5ndGggciArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIHYpIGNvbXBhcmVfZWx0IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSB2KSB1cHBlciBjb21wYXJlX2VsdCByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9lbHQgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9lbHQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2VcbiAgOztcblxuICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgbGV0IGhsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGxldCBociA9XG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaCA9IGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxIGluXG4gICAgaWYgaCA9IDFcbiAgICB0aGVuIExlYWYgdlxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNsID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGxldCBzciA9XG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBOb2RlIChsLCB2LCByLCBoLCBzbCArIHNyICsgMSkpXG4gIDs7XG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuU2V0IG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrID0gZiBpIGluXG4gICAgICAgIExlYWYga1xuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgRW1wdHlcbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgbGV0IGtyID0gZiAoaSArIDIpIGluXG4gICAgICAgIGNyZWF0ZSAoTGVhZiBrbCkgayAoTGVhZiBrcilcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgICgqIFdlIGRvbid0IGNoZWNrIGlmIHRoZSBhcnJheSBpcyBzb3J0ZWQgb3Iga2V5cyBhcmUgZHVwbGljYXRlZCwgYmVjYXVzZSB0aGF0XG4gICAgICAgICBjaGVja2luZyBpcyBzbG93ZXIgdGhhbiB0aGUgd2hvbGUgW29mX3NvcnRlZF9hcnJheV0gZnVuY3Rpb24gKilcbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDIgfHwgY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHRcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdClcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2VsdCBhcnJheS4oaSkgYXJyYXkuKGkgKyAxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGVsZW1lbnRzIGFyZSBub3Qgb3JkZXJlZFwiKVxuICAgICAgICBkb25lO1xuICAgICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0KSlcbiAgOztcblxuICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgbGV0IGJhbCBsIHYgciA9XG4gICAgbGV0IGhsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGxldCBociA9XG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChsKT5oKHIpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIChsbCwgbHYsIGxyLCBfLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyXG4gICAgICAgIHRoZW4gY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgbHJ2IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IGxsKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IEVtcHR5KSBscnYgKGNyZWF0ZSBFbXB0eSB2IHIpXG4gICAgICAgICAgfCBOb2RlIChscmwsIGxydiwgbHJyLCBfLCBfKSAtPiBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogYmVjYXVzZSBoKHIpPmgobCkrMiBhbmQgaChsZWFmKT0xICopXG4gICAgICB8IE5vZGUgKHJsLCBydiwgcnIsIF8sIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmxcbiAgICAgICAgdGhlbiBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTGVhZiBybHYgLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgcnIpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IEVtcHR5KSBybHYgKGNyZWF0ZSBFbXB0eSBydiBycilcbiAgICAgICAgICB8IE5vZGUgKHJsbCwgcmx2LCBybHIsIF8sIF8pIC0+IGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycikpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgICAgbGV0IHNsID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGxldCBzciA9XG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBpZiBoID0gMSB0aGVuIExlYWYgdiBlbHNlIE5vZGUgKGwsIHYsIHIsIGgsIHNsICsgc3IgKyAxKSlcbiAgOztcblxuICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICBleGNlcHRpb24gU2FtZVxuXG4gIGxldCBhZGQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBMZWFmIHhcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gcmFpc2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gY3JlYXRlIChMZWFmIHgpIHYgRW1wdHlcbiAgICAgICAgZWxzZSBjcmVhdGUgRW1wdHkgdiAoTGVhZiB4KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJhaXNlIFNhbWUgZWxzZSBpZiBjIDwgMCB0aGVuIGJhbCAoYXV4IGwpIHYgciBlbHNlIGJhbCBsIHYgKGF1eCByKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZFxuICAgICByLiAqKVxuICBsZXQgcmVjIGpvaW4gbCB2IHIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBsLCByIHdpdGhcbiAgICB8IEVtcHR5LCBfIC0+IGFkZCByIHYgfmNvbXBhcmVfZWx0XG4gICAgfCBfLCBFbXB0eSAtPiBhZGQgbCB2IH5jb21wYXJlX2VsdFxuICAgIHwgTGVhZiBsdiwgXyAtPiBhZGQgKGFkZCByIHYgfmNvbXBhcmVfZWx0KSBsdiB+Y29tcGFyZV9lbHRcbiAgICB8IF8sIExlYWYgcnYgLT4gYWRkIChhZGQgbCB2IH5jb21wYXJlX2VsdCkgcnYgfmNvbXBhcmVfZWx0XG4gICAgfCBOb2RlIChsbCwgbHYsIGxyLCBsaCwgXyksIE5vZGUgKHJsLCBydiwgcnIsIHJoLCBfKSAtPlxuICAgICAgaWYgbGggPiByaCArIDJcbiAgICAgIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgciB+Y29tcGFyZV9lbHQpXG4gICAgICBlbHNlIGlmIHJoID4gbGggKyAyXG4gICAgICB0aGVuIGJhbCAoam9pbiBsIHYgcmwgfmNvbXBhcmVfZWx0KSBydiByclxuICAgICAgZWxzZSBjcmVhdGUgbCB2IHJcbiAgOztcblxuICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IHwgTm9kZSAoRW1wdHksIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICAgIHwgTm9kZSAobCwgXywgXywgXywgXykgLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgYWNjID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB2YWx1ZSAtPiBmIGFjYyB2YWx1ZVxuICAgICAgfCBOb2RlIChsZWZ0LCB2YWx1ZSwgcmlnaHQsIF8sIF8pIC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiBsZWZ0IGFjYyB3aXRoXG4gICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiBhY2MgdmFsdWUgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgICAgfCBDb250aW51ZSBhIC0+IGZvbGRfdW50aWxfaGVscGVyIH5mIHJpZ2h0IGEpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgdCBpbml0IHdpdGhcbiAgICB8IENvbnRpbnVlIHggLT4gZmluaXNoIHhcbiAgICB8IFN0b3AgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiB8IE5vZGUgKF8sIHYsIEVtcHR5LCBfLCBfKSAtPiBTb21lIHZcbiAgICB8IE5vZGUgKF8sIF8sIHIsIF8sIF8pIC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgKEVtcHR5LCBfLCByLCBfLCBfKSAtPiByXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBiYWwgdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcbiAgbGV0IGNvbmNhdCB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gam9pbiB0MSAobWluX2VsdF9leG4gdDIpIChyZW1vdmVfbWluX2VsdCB0MikgfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgc3BsaXQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRW1wdHksIE5vbmUsIEVtcHR5XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEVtcHR5LCBTb21lIHYsIEVtcHR5XG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgTGVhZiB2XG4gICAgICAgIGVsc2UgTGVhZiB2LCBOb25lLCBFbXB0eVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIGwsIFNvbWUgdiwgclxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsbCwgbWF5YmVfZWx0LCBybCA9IHNwbGl0IGwgaW5cbiAgICAgICAgICBsbCwgbWF5YmVfZWx0LCBqb2luIHJsIHYgciB+Y29tcGFyZV9lbHQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsciwgbWF5YmVfZWx0LCByciA9IHNwbGl0IHIgaW5cbiAgICAgICAgICBqb2luIGwgdiBsciB+Y29tcGFyZV9lbHQsIG1heWJlX2VsdCwgcnIpXG4gICAgaW5cbiAgICBzcGxpdCB0XG4gIDs7XG5cbiAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgcmVjIG1lbSB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHYgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMFxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMCB8fCBtZW0gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiB4ID0gTGVhZiB4XG5cbiAgbGV0IHJlbW92ZSB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBTYW1lXG4gICAgICB8IExlYWYgdiAtPiBpZiBjb21wYXJlX2VsdCB4IHYgPSAwIHRoZW4gRW1wdHkgZWxzZSByYWlzZSBTYW1lXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6XyA9XG4gICAgbGV0IHJlYyBhdXggdCBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBTYW1lXG4gICAgICB8IExlYWYgXyAtPiBpZiBpID0gMCB0aGVuIEVtcHR5IGVsc2UgcmFpc2UgU2FtZVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGJhbCAoYXV4IGwgaSkgdiByXG4gICAgICAgIGVsc2UgYmFsIGwgdiAoYXV4IHIgKGkgLSBsX3NpemUgLSAxKSlcbiAgICBpblxuICAgIHRyeSBhdXggdCBpIHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gIGxldCB1bmlvbiBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIHQgfCB0LCBFbXB0eSAtPiB0XG4gICAgICAgIHwgTGVhZiB2MSwgXyAtPiB1bmlvbiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHMyXG4gICAgICAgIHwgXywgTGVhZiB2MiAtPiB1bmlvbiBzMSAoTm9kZSAoRW1wdHksIHYyLCBFbXB0eSwgMSwgMSkpXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgaDEsIF8pLCBOb2RlIChsMiwgdjIsIHIyLCBoMiwgXykgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMlxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMVxuICAgICAgICAgICAgdGhlbiBhZGQgczEgdjIgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGwyLCBfLCByMiA9IHNwbGl0IHMyIHYxIH5jb21wYXJlX2VsdCBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKSB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgZWxzZSBpZiBoMSA9IDFcbiAgICAgICAgICB0aGVuIGFkZCBzMiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsMSwgXywgcjEgPSBzcGxpdCBzMSB2MiB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICB1bmlvbiBzMSBzMlxuICA7O1xuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIHhzID1cbiAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIExpc3QuZm9sZCB4cyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjIHggLT4gdW5pb24gYWMgKHRvX3RyZWUgeCkgfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlciBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IChMZWFmIGVsdCBhcyBzaW5nbGV0b24pLCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIChMZWFmIGVsdCBhcyBzaW5nbGV0b24pIC0+XG4gICAgICAgICAgaWYgbWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0IHRoZW4gc2luZ2xldG9uIGVsc2UgRW1wdHlcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgfCBsMiwgU29tZSB2MSwgcjIgLT4gam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMikgfmNvbXBhcmVfZWx0KSlcbiAgICBpblxuICAgIGludGVyIHMxIHMyXG4gIDs7XG5cbiAgbGV0IGRpZmYgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBFbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gLT4gRW1wdHlcbiAgICAgICAgfCB0MSwgRW1wdHkgLT4gdDFcbiAgICAgICAgfCBMZWFmIHYxLCB0MiAtPiBkaWZmIChOb2RlIChFbXB0eSwgdjEsIEVtcHR5LCAxLCAxKSkgdDJcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpIH5jb21wYXJlX2VsdFxuICAgICAgICAgICB8IGwyLCBTb21lIF8sIHIyIC0+IGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICBkaWZmIHMxIHMyXG4gIDs7XG5cbiAgbW9kdWxlIEVudW0gPSBzdHJ1Y3RcbiAgICB0eXBlIGluY3JlYXNpbmdcbiAgICB0eXBlIGRlY3JlYXNpbmdcblxuICAgIHR5cGUgKCdhLCAnZGlyZWN0aW9uKSB0ID1cbiAgICAgIHwgRW5kXG4gICAgICB8IE1vcmUgb2YgJ2EgKiAnYSB0cmVlICogKCdhLCAnZGlyZWN0aW9uKSB0XG5cbiAgICBsZXQgcmVjIGNvbnMgcyAoZSA6IChfLCBpbmNyZWFzaW5nKSB0KSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgdiAtPiBNb3JlICh2LCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gY29ucyBsIChNb3JlICh2LCByLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb25zX3JpZ2h0IHMgKGUgOiAoXywgZGVjcmVhc2luZykgdCkgOiAoXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHYgLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGNvbnNfcmlnaHQgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl9zZXQgcyA6IChfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyBzIEVuZFxuICAgIGxldCBvZl9zZXRfcmlnaHQgcyA6IChfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCBzIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB2IC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBFbXB0eSwgMSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChfLCB2LCByLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gbG9vcCBsIChNb3JlICh2LCByLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBzdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgdiAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgRW1wdHksIDEsIDEpKSBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgXywgXywgXykgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGxvb3AgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2VsdCBlMSBlMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgZTEgZTIgPVxuICAgICAgICBtYXRjaCBlMSwgZTIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCByMSwgZTEpLCBNb3JlICh2MiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGlmIHBoeXNfZXF1YWwgcjEgcjJcbiAgICAgICAgICB0aGVuIGxvb3AgZTEgZTJcbiAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKVxuICAgICAgaW5cbiAgICAgIGxvb3AgZTEgZTJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBpdGVyIH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+ICgpXG4gICAgICB8IE1vcmUgKGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgIGYgYTtcbiAgICAgICAgaXRlciAoY29ucyB0cmVlIGVudW0pIH5mXG4gICAgOztcblxuICAgIGxldCBpdGVyMiBjb21wYXJlX2VsdCB0MSB0MiB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+ICgpXG4gICAgICAgIHwgRW5kLCBfIC0+IGl0ZXIgdDIgfmY6KGZ1biBhIC0+IGYgKGBSaWdodCBhKSlcbiAgICAgICAgfCBfLCBFbmQgLT4gaXRlciB0MSB+ZjooZnVuIGEgLT4gZiAoYExlZnQgYSkpXG4gICAgICAgIHwgTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBCb3RoIChhMSwgYTIpKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYExlZnQgYTEpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBmIChgUmlnaHQgYTIpO1xuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICAgIGxldCBzdGVwIHN0YXRlIDogKChfLCBfKSBFaXRoZXIudCwgXykgU2VxdWVuY2UuU3RlcC50ID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IERvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGVsdCwgdHJlZSwgZW51bSkgLT4gWWllbGQgKFNlY29uZCBlbHQsIChFbmQsIGNvbnMgdHJlZSBlbnVtKSlcbiAgICAgICAgfCBNb3JlIChlbHQsIHRyZWUsIGVudW0pLCBFbmQgLT4gWWllbGQgKEZpcnN0IGVsdCwgKGNvbnMgdHJlZSBlbnVtLCBFbmQpKVxuICAgICAgICB8IChNb3JlIChhMSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9XG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgICAgdGhlbiBlbnVtMSwgZW51bTJcbiAgICAgICAgICAgICAgZWxzZSBjb25zIHRyZWUxIGVudW0xLCBjb25zIHRyZWUyIGVudW0yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU2tpcCBuZXh0X3N0YXRlKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiBZaWVsZCAoRmlyc3QgYTEsIChjb25zIHRyZWUxIGVudW0xLCByaWdodCkpXG4gICAgICAgICAgZWxzZSBZaWVsZCAoU2Vjb25kIGEyLCAobGVmdCwgY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6KG9mX3NldCB0MSwgb2Zfc2V0IHQyKSB+ZjpzdGVwXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoaywgRW51bS5jb25zIHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fZWx0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3NldCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKGssIEVudW0uY29uc19yaWdodCB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXRfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfZWx0IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIGVsdCAtPiBhZGQgdCBlbHQgfmNvbXBhcmVfZWx0XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBsZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0OmdyZWF0ZXJfb3JfZXF1YWxfdG8gdFxuICAgIHwgYERlY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgZ3JlYXRlcl9vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgc25kKSBpblxuICAgICAgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpsZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIHZcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgciB+ZlxuICA7O1xuXG4gIGxldCByZWMgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMClcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IHggPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHRcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICAgICAgdCdcbiAgICA9XG4gICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdClcbiAgICAgICh0b19zZXF1ZW5jZSBjb21wYXJhdG9yIH5vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0JylcbiAgICAgIH5jb21wYXJlOlxuICAgICAgICAobWF0Y2ggb3JkZXIgd2l0aFxuICAgICAgICAgfCBgSW5jcmVhc2luZyAtPiBjb21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIHwgYERlY3JlYXNpbmcgLT4gRm4uZmxpcCBjb21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPVxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMilcbiAgOztcblxuICBsZXQgaXRlcjIgczEgczIgfmNvbXBhcmVfZWx0ID0gRW51bS5pdGVyMiBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMilcbiAgbGV0IGVxdWFsIHMxIHMyIH5jb21wYXJlX2VsdCA9IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPSAwXG5cbiAgbGV0IGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBpc19zdWJzZXQgczEgfm9mXzpzMiA9XG4gICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgfCBFbXB0eSwgXyAtPiB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IExlYWYgdjEsIHQyIC0+IG1lbSB0MiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIExlYWYgdjIgLT5cbiAgICAgICAgKG1hdGNoIGwxLCByMSB3aXRoXG4gICAgICAgICB8IEVtcHR5LCBFbXB0eSAtPlxuICAgICAgICAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkbid0IG9jY3VyIGluIHByYWN0aWNlIGJlY2F1c2Ugd2Ugc2hvdWxkIGhhdmUgY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgYSBMZWFmIHJhdGhlciB0aGFuIGEgTm9kZSB3aXRoIHR3byBFbXB0eSBzdWJ0cmVlcyAqKVxuICAgICAgICAgICBjb21wYXJlX2VsdCB2MSB2MiA9IDBcbiAgICAgICAgIHwgXywgXyAtPiBmYWxzZSlcbiAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIChOb2RlIChsMiwgdjIsIHIyLCBfLCBfKSBhcyB0MikgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgcGh5c19lcXVhbCBzMSBzMiB8fCAoaXNfc3Vic2V0IGwxIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86cjIpXG4gICAgICAgICAgKCogTm90ZSB0aGF0IGhlaWdodCBhbmQgc2l6ZSBkb24ndCBtYXR0ZXIgaGVyZS4gKilcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGlzX3N1YnNldCAoTm9kZSAobDEsIHYxLCBFbXB0eSwgMCwgMCkpIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86dDJcbiAgICAgICAgZWxzZSBpc19zdWJzZXQgKE5vZGUgKEVtcHR5LCB2MSwgcjEsIDAsIDApKSB+b2ZfOnIyICYmIGlzX3N1YnNldCBsMSB+b2ZfOnQyXG4gICAgaW5cbiAgICBpc19zdWJzZXQgczEgfm9mXzpzMlxuICA7O1xuXG4gIGxldCByZWMgYXJlX2Rpc2pvaW50IHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBlbHQsIG90aGVyX3NldCB8IG90aGVyX3NldCwgTGVhZiBlbHQgLT4gbm90IChtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQpXG4gICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICB8IGwyLCBOb25lLCByMiAtPlxuICAgICAgICAgIGFyZV9kaXNqb2ludCBsMSBsMiB+Y29tcGFyZV9lbHQgJiYgYXJlX2Rpc2pvaW50IHIxIHIyIH5jb21wYXJlX2VsdFxuICAgICAgICB8IF8sIFNvbWUgXywgXyAtPiBmYWxzZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID1cbiAgICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBMZWFmIHYgLT4gZiB2XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGl0ZXIgbDtcbiAgICAgICAgZiB2O1xuICAgICAgICBpdGVyIHJcbiAgICBpblxuICAgIGl0ZXIgdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgcmVjIGZvbGQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIGFjY3UgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZCB+ZiByIH5pbml0OihmIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkgdilcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9lbGVtIHN0YXRlIHQgPVxuICAgIGZvbGQgdCB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKSB+ZjpoYXNoX2ZvbGRfZWxlbVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuXG4gIGxldCByZWMgZm9sZF9yaWdodCBzIH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IGYgdiBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBmb2xkX3JpZ2h0IH5mIGwgfmluaXQ6KGYgdiAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCByZWMgZm9yX2FsbCB0IH5mOnAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2ICYmIGZvcl9hbGwgfmY6cCBsICYmIGZvcl9hbGwgfmY6cCByXG4gIDs7XG5cbiAgbGV0IHJlYyBleGlzdHMgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHYgLT4gcCB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBwIHYgfHwgZXhpc3RzIH5mOnAgbCB8fCBleGlzdHMgfmY6cCByXG4gIDs7XG5cbiAgbGV0IGZpbHRlciBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGZpbHQgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+IGlmIHAgdiB0aGVuIGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0IGVsc2UgYWNjdVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBmaWx0IChmaWx0IChpZiBwIHYgdGhlbiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdCBlbHNlIGFjY3UpIGwpIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgc1xuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgZmlsdCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGZpbHRcbiAgICAgICAgICAoZmlsdFxuICAgICAgICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgICAgICAgICBsKVxuICAgICAgICAgIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgc1xuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBwYXJ0ICgodCwgZikgYXMgYWNjdSkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPiBpZiBwIHYgdGhlbiBhZGQgdCB2IH5jb21wYXJlX2VsdCwgZiBlbHNlIHQsIGFkZCBmIHYgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIHBhcnQgKHBhcnQgKGlmIHAgdiB0aGVuIGFkZCB0IHYgfmNvbXBhcmVfZWx0LCBmIGVsc2UgdCwgYWRkIGYgdiB+Y29tcGFyZV9lbHQpIGwpIHJcbiAgICBpblxuICAgIHBhcnQgKEVtcHR5LCBFbXB0eSkgc1xuICA7O1xuXG4gIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IHYgOjogYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcbiAgOztcblxuICBsZXQgZWxlbWVudHMgcyA9IGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgbGV0IGNob29zZSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBTb21lIHZcbiAgICB8IE5vZGUgKF8sIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICA7O1xuXG4gIGxldCBjaG9vc2VfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTZXQuY2hvb3NlX2V4bjogZW1wdHkgc2V0XCIpIGluXG4gICAgbGV0IGNob29zZV9leG4gdCA9XG4gICAgICBtYXRjaCBjaG9vc2UgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IFNvbWUgdiAtPiB2XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgY2hvb3NlX2V4blxuICA7O1xuXG4gIGxldCBvZl9saXN0IGxzdCB+Y29tcGFyZV9lbHQgPVxuICAgIExpc3QuZm9sZCBsc3QgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlIH5jb21wYXJlX2VsdCA9XG4gICAgU2VxdWVuY2UuZm9sZCBzZXF1ZW5jZSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgdG9fbGlzdCBzID0gZWxlbWVudHMgc1xuXG4gIGxldCBvZl9hcnJheSBhIH5jb21wYXJlX2VsdCA9XG4gICAgQXJyYXkuZm9sZCBhIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gICgqIGZhc3RlciBidXQgZXF1aXZhbGVudCB0byBbQXJyYXkub2ZfbGlzdCAodG9fbGlzdCB0KV0gKilcbiAgbGV0IHRvX2FycmF5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IFt8fF1cbiAgICB8IExlYWYgdiAtPiBbfCB2IHxdXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgbGV0IHJlcyA9IEFycmF5LmNyZWF0ZSB+bGVuOnMgdiBpblxuICAgICAgbGV0IHBvc19yZWYgPSByZWYgMCBpblxuICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgKCogSW52YXJpYW50OiBvbiBlbnRyeSBhbmQgb24gZXhpdCB0byBbbG9vcF0sICFwb3NfcmVmIGlzIHRoZSBuZXh0XG4gICAgICAgICAgIGF2YWlsYWJsZSBjZWxsIGluIHRoZSBhcnJheS4gKilcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IExlYWYgdiAtPlxuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgICBsb29wIGw7XG4gICAgICAgICAgcmVzLighcG9zX3JlZikgPC0gdjtcbiAgICAgICAgICBpbmNyIHBvc19yZWY7XG4gICAgICAgICAgbG9vcCByXG4gICAgICBpblxuICAgICAgbG9vcCBsO1xuICAgICAgKCogcmVzLighcG9zX3JlZikgaXMgYWxyZWFkeSBpbml0aWFsaXplZCAoYnkgQXJyYXkuY3JlYXRlIH5sZW46YWJvdmUpLiAqKVxuICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgbG9vcCByO1xuICAgICAgcmVzXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mIH5jb21wYXJlX2VsdCA9IGZvbGQgdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCAoZiB4KSB+Y29tcGFyZV9lbHQpXG5cbiAgbGV0IGdyb3VwX2J5IHNldCB+ZXF1aXYgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGxvb3Agc2V0IGVxdWl2X2NsYXNzZXMgPVxuICAgICAgaWYgaXNfZW1wdHkgc2V0XG4gICAgICB0aGVuIGVxdWl2X2NsYXNzZXNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeCA9IGNob29zZV9leG4gc2V0IGluXG4gICAgICAgIGxldCBlcXVpdl94LCBub3RfZXF1aXZfeCA9XG4gICAgICAgICAgcGFydGl0aW9uX3RmIHNldCB+ZjooZnVuIGVsdCAtPiBwaHlzX2VxdWFsIHggZWx0IHx8IGVxdWl2IHggZWx0KSB+Y29tcGFyZV9lbHRcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCBub3RfZXF1aXZfeCAoZXF1aXZfeCA6OiBlcXVpdl9jbGFzc2VzKSlcbiAgICBpblxuICAgIGxvb3Agc2V0IFtdXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gU29tZSB2XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggZmluZCBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbmQgciB+ZlxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX21hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBmIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAobWF0Y2ggZiB2IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIChtYXRjaCBmaW5kX21hcCBsIH5mIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgciB+ZlxuICAgICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcikpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2V0LmZpbmRfZXhuIGZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgZWxlbWVudFwiXG4gICAgfCBTb21lIGUgLT4gZVxuICA7O1xuXG4gIGxldCByZWMgbnRoIHQgaSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgaSA9IDAgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgaWYgaSA+PSBzXG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBudGggbCBpIGVsc2UgaWYgYyA9IDAgdGhlbiBTb21lIHYgZWxzZSBudGggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgbG9vcCB4cyBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgbGVmdG92ZXJzXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGlmIG1lbSBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0XG4gICAgICAgIHRoZW4gbG9vcCB0bCBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuXG4gICAgICAgIGVsc2UgbG9vcCB0bCAoaGQgOjogbGVmdG92ZXJzKSAoYWRkIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHQpXG4gICAgaW5cbiAgICBsb29wIHhzIFtdIGVtcHR5XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgYV9vZl9zZXhwIHNleHAgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuTGlzdCBsc3QgLT5cbiAgICAgIGxldCBlbHRfbHN0ID0gTGlzdC5tYXAgbHN0IH5mOmFfb2Zfc2V4cCBpblxuICAgICAgbGV0IHNldCA9IG9mX2xpc3QgZWx0X2xzdCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGxlbmd0aCBzZXQgPSBMaXN0Lmxlbmd0aCBsc3RcbiAgICAgIHRoZW4gc2V0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHNldCA9IHJlZiBlbXB0eSBpblxuICAgICAgICBMaXN0Lml0ZXIyX2V4biBsc3QgZWx0X2xzdCB+ZjooZnVuIGVsX3NleHAgZWwgLT5cbiAgICAgICAgICBpZiBtZW0gIXNldCBlbCB+Y29tcGFyZV9lbHRcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBkdXBsaWNhdGUgZWxlbWVudCBpbiBzZXRcIiBlbF9zZXhwXG4gICAgICAgICAgZWxzZSBzZXQgOj0gYWRkICFzZXQgZWwgfmNvbXBhcmVfZWx0KTtcbiAgICAgICAgYXNzZXJ0IGZhbHNlKVxuICAgIHwgc2V4cCAtPiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biBlbCBhY2MgLT4gc2V4cF9vZl9hIGVsIDo6IGFjYykpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgdHJlZSA6ICdhIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgbGV0IGlzX3N1YnNldCAoc3Vic2V0IDogXyB0KSB+b2ZfOihzdXBlcnNldCA6IF8gdCkgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdCA9XG4gICAgICBsZXQgaW52YWxpZF9lbGVtZW50cyA9IGRpZmYgc3Vic2V0LnRyZWUgc3VwZXJzZXQudHJlZSB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGlzX2VtcHR5IGludmFsaWRfZWxlbWVudHNcbiAgICAgIHRoZW4gT2sgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaW52YWxpZF9lbGVtZW50c19zZXhwID0gc2V4cF9vZl90IHNleHBfb2ZfZWx0IGludmFsaWRfZWxlbWVudHMgaW5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAoc3Vic2V0Lm5hbWUgXiBcIiBpcyBub3QgYSBzdWJzZXQgb2YgXCIgXiBzdXBlcnNldC5uYW1lKVxuICAgICAgICAgICAgIFsgXCJpbnZhbGlkX2VsZW1lbnRzXCIsIGludmFsaWRfZWxlbWVudHNfc2V4cCBdKSlcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHMxIHMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxuICAgICAgICBbIGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgOyBpc19zdWJzZXQgczIgfm9mXzpzMSB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIF1cbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPVxuICB7ICgqIFtjb21wYXJhdG9yXSBpcyB0aGUgZmlyc3QgZmllbGQgc28gdGhhdCBwb2x5bW9ycGhpYyBlcXVhbGl0eSBmYWlscyBvbiBhIG1hcCBkdWVcbiAgICAgICB0byB0aGUgZnVuY3Rpb25hbCB2YWx1ZSBpbiB0aGUgY29tcGFyYXRvci5cbiAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgcG9seW1vcnBoaWMgW2NvbXBhcmVdOiB0aGF0IHN0aWxsIHByb2R1Y2VzXG4gICAgICAgbm9uc2Vuc2UuICopXG4gICAgY29tcGFyYXRvciA6ICgnYSwgJ2NvbXBhcmF0b3IpIENvbXBhcmF0b3IudFxuICA7IHRyZWUgOiAnYSBUcmVlMC50XG4gIH1cblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlID0gJ2EgVHJlZTAudFxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBjb21wYXJhdG9yIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvciB9XG5sZXQgY29tcGFyZV9lbHQgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCBpbnZhcmlhbnRzIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0LnRyZWVcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0LnRyZWVcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdC50cmVlXG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHQudHJlZVxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0LnRyZWVcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0LnRyZWVcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEudHJlZSBiLnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBhKVxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQudHJlZSB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0LnRyZWUgfmZcbiAgbGV0IG1lbSB0IGEgPSBUcmVlMC5tZW0gdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgZmlsdGVyIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IGFkZCB0IGEgPSBsaWtlIHQgKFRyZWUwLmFkZCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgcmVtb3ZlIHQgYSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLnVuaW9uIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGludGVyIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuaW50ZXIgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmRpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY29tcGFyZV9lbHQgdDEpIHQxLnRyZWUgdDIudHJlZVxuICBsZXQgZXF1YWwgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgbGV0IGlzX3N1YnNldCB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdC50cmVlIH5vZl86b2ZfLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuXG4gIGxldCBhcmVfZGlzam9pbnQgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyBzZXQgOiAoJ2EsICdjbXApIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgbGV0IHRvX25hbWVkX3RyZWUgeyBzZXQ7IG5hbWUgfSA9IHsgVHJlZTAuTmFtZWQudHJlZSA9IHNldC50cmVlOyBuYW1lIH1cblxuICAgIGxldCBpc19zdWJzZXQgKHN1YnNldCA6IChfLCBfKSB0KSB+b2ZfOihzdXBlcnNldCA6IChfLCBfKSB0KSA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgKHRvX25hbWVkX3RyZWUgc3Vic2V0KVxuICAgICAgICB+b2ZfOih0b19uYW1lZF90cmVlIHN1cGVyc2V0KVxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHN1YnNldC5zZXQpXG4gICAgICAgIH5zZXhwX29mX2VsdDpzdWJzZXQuc2V0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB0MSB0MiA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0IFsgaXNfc3Vic2V0IHQxIH5vZl86dDI7IGlzX3N1YnNldCB0MiB+b2ZfOnQxIF1cbiAgICA7O1xuICBlbmRcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIGxldCB0cmVlX3QsIHRyZWVfZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlX3QsIGxpa2UgdCB0cmVlX2ZcbiAgOztcblxuICBsZXQgc3BsaXQgdCBhID1cbiAgICBsZXQgdHJlZTEsIGIsIHRyZWUyID0gVHJlZTAuc3BsaXQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgYiwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IHQgfmVxdWl2ID1cbiAgICBMaXN0Lm1hcCAoVHJlZTAuZ3JvdXBfYnkgdC50cmVlIH5lcXVpdiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKSB+ZjoobGlrZSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQudHJlZSBpXG4gIGxldCByZW1vdmVfaW5kZXggdCBpID0gbGlrZSB0IChUcmVlMC5yZW1vdmVfaW5kZXggdC50cmVlIGkgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIHQuY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gICAgICB0Jy50cmVlXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBzdGF0ZSB0LnRyZWVcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY29tcGFyZSBfIF8gdDEgdDIgPSBjb21wYXJlX2RpcmVjdCB0MSB0MlxuXG5tb2R1bGUgVHJlZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGNlIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcikgYV9vZl9zZXhwIHNleHBcbiAgOztcblxuICBsZXQgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA9IFRyZWUwLmVtcHR5XG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvcjpfID0gZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gZSA9IFRyZWUwLnNpbmdsZXRvbiBlXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG4gIGxldCBpbnZhcmlhbnRzIH5jb21wYXJhdG9yIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHRcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0XG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBjaG9vc2UgdCA9IFRyZWUwLmNob29zZSB0XG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHRcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdFxuICBsZXQgdG9fYXJyYXkgdCA9IFRyZWUwLnRvX2FycmF5IHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdCB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfdW50aWwgdCB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5pbml0IH5mXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlciB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHBhcnRpdGlvbl90ZiB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAucGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgYSBiIH5mID0gVHJlZTAuaXRlcjIgYSBiIH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5tZW0gdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5hZGQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5yZW1vdmUgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAudW5pb24gdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaW50ZXIgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5pbnRlciB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBkaWZmIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY2UgY29tcGFyYXRvcikgdDEgdDJcbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQgfm9mXyA9IFRyZWUwLmlzX3N1YnNldCB0IH5vZl8gfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBhcmVfZGlzam9pbnQgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYSA9XG4gICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6XyB+bGVuIH5mID1cbiAgICBUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2Zfc29ydGVkX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAudW5pb25fbGlzdCBsIH50b190cmVlOkZuLmlkIH5jb21wYXJhdG9yXG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IH5jb21wYXJhdG9yIHQgfmVxdWl2ID0gVHJlZTAuZ3JvdXBfYnkgdCB+ZXF1aXYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdCBpXG4gIGxldCByZW1vdmVfaW5kZXggfmNvbXBhcmF0b3IgdCBpID0gVHJlZTAucmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdFxuICBsZXQgdG9fdHJlZSB0ID0gdFxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvcjpfIHQgPSB0XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVHJlZTAuTmFtZWRcblxuICAgIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdDEgfm9mXzp0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgdDFcbiAgICAgICAgfm9mXzp0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5lcXVhbFxuICAgICAgICB0MVxuICAgICAgICB0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcbiAgZW5kXG5lbmRcblxubW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZVxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLmNvbXBhcmUgYV9vZl9zZXhwIHNleHApXG4gIDs7XG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA9IHsgY29tcGFyYXRvciA9IEVsdC5jb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuICBlbmRcblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5zaW5nbGV0b24gZSB9XG5cbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAudW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSBsKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBsZXQgdHJlZSA9XG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgeyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZiA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZilcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5Nb25hZF9pbmZpeC4oXG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICA+PnwgZnVuIHRyZWUgLT4geyBjb21wYXJhdG9yOyB0cmVlIH0pXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG1hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yXG4gICAgOyB0cmVlID0gVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfVxuICA7O1xuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbnR5cGUgKCdlbHQsICdjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcblxubGV0IGNvbXBhcmF0b3JfcyAodHlwZSBrIGNtcCkgdCA6IChrLCBjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGtcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcFxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3JcbiAgZW5kKVxuOztcblxubGV0IHRvX2NvbXBhcmF0b3IgKHR5cGUgZWx0IGNtcCkgKChtb2R1bGUgTSkgOiAoZWx0LCBjbXApIGNvbXBhcmF0b3IpID0gTS5jb21wYXJhdG9yXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IHVuaW9uX2xpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci51bmlvbl9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBtIH5sZW4gfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIH5sZW4gfmZcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2xpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9zZXF1ZW5jZSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IHN0YWJsZV9kZWR1cF9saXN0IG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iuc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG1hcCBtIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG5sZXQgZmlsdGVyX21hcCBtIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLmZpbHRlcl9tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuXG5tb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgICAgICh0eXBlIGVsdCBjbXApXG4gICAgICAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOkVsdC5jb21wYXJhdG9yIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdClcbiAgOiAoZWx0LCBfKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGVsdCkgc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEVsdC5oYXNoX2ZvbGRfdCBzdGF0ZVxuOztcblxubGV0IGhhc2hfbV9fdCBmb2xkZXIgdCA9XG4gIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9tX190IGZvbGRlciAoSGFzaC5jcmVhdGUgKCkpIHQgaW5cbiAgSGFzaC5nZXRfaGFzaF92YWx1ZSBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSBzZXQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgJ2VsdCB0cmVlID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdHJlZVxuICB0eXBlIG5vbnJlYyAnZWx0IG5hbWVkID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgTmFtZWQudFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvclxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgdW5pb25fbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci51bmlvbl9saXN0IH5jb21wYXJhdG9yIGFcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2Zfc2VxdWVuY2UgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcCB+Y29tcGFyYXRvciBhIH5mXG4gIGxldCBmaWx0ZXJfbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLmZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgb2ZfdHJlZSB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgcmVmIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX3JlZlxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID0gZXF1YWxfcmVmXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSByZWZfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9yZWZcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IHJlZl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmQgOlxuc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxuKCogSW4gdGhlIGRlZmluaXRpb24gb2YgW3RdLCB3ZSBkbyBub3QgaGF2ZSBbW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1dIGJlY2F1c2VcbiAgIGluIGdlbmVyYWwsIHN5bnRheCBleHRlbnNpb25zIHRlbmQgdG8gdXNlIHRoZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGF2YWlsYWJsZSByYXRoZXIgdGhhblxuICAgdXNpbmcgdGhlIGFsaWFzLiAgSGVyZSB0aGF0IHdvdWxkIGxlYWQgdG8gdXNlIHRoZSByZWNvcmQgcmVwcmVzZW50YXRpb24gWyB7IG11dGFibGVcbiAgIGNvbnRlbnRzIDogJ2EgfSBdIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBkaWZmZXJlbnQgKGFuZCB1bndhbnRlZCkgYmVoYXZpb3IuICAqKVxudHlwZSAnYSB0ID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG5leHRlcm5hbCBjcmVhdGUgOiAnYSAtPiAnYSB0ID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSB0IC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHQgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbmxldCBzd2FwIHQxIHQyID1cbiAgbGV0IHRtcCA9ICF0MSBpblxuICB0MSA6PSAhdDI7XG4gIHQyIDo9IHRtcFxuOztcblxubGV0IHJlcGxhY2UgdCBmID0gdCA6PSBmICF0XG5cbmxldCBzZXRfdGVtcG9yYXJpbHkgdCBhIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSAhdCBpblxuICB0IDo9IGE7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gdCA6PSByZXN0b3JlX3RvKVxuOztcblxubW9kdWxlIEFuZF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUIDogJ2EgcmVmICogJ2EgLT4gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBzZXQgKFQgKHIsIGEpKSA9IHIgOj0gYVxuICBsZXQgc2V0cyB0cyA9IExpc3QuaXRlciB0cyB+ZjpzZXRcbiAgbGV0IHNuYXBzaG90IChUIChyLCBfKSkgPSBUIChyLCAhcilcbiAgbGV0IHNuYXBzaG90cyB0cyA9IExpc3QubWFwIHRzIH5mOnNuYXBzaG90XG5lbmRcblxubGV0IHNldHNfdGVtcG9yYXJpbHkgYW5kX3ZhbHVlcyB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gQW5kX3ZhbHVlLnNuYXBzaG90cyBhbmRfdmFsdWVzIGluXG4gIEFuZF92YWx1ZS5zZXRzIGFuZF92YWx1ZXM7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gQW5kX3ZhbHVlLnNldHMgcmVzdG9yZV90bylcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuXG4oKiBbdF0gc3RvcmVzIHRoZSBbdC5sZW5ndGhdIHF1ZXVlIGVsZW1lbnRzIGF0IGNvbnNlY3V0aXZlIGluY3JlYXNpbmcgaW5kaWNlcyBvZiBbdC5lbHRzXSxcbiAgIG1vZCB0aGUgY2FwYWNpdHkgb2YgW3RdLCB3aGljaCBpcyBbT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAgVGhlIGNhcGFjaXR5IGlzXG4gICByZXF1aXJlZCB0byBiZSBhIHBvd2VyIG9mIHR3byAodXNlci1yZXF1ZXN0ZWQgY2FwYWNpdGllcyBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdFxuICAgcG93ZXIpLCBzbyB0aGF0IG1vZCBjYW4gcXVpY2tseSBiZSBjb21wdXRlZCB1c2luZyBbbGFuZCB0Lm1hc2tdLCB3aGVyZSBbdC5tYXNrID1cbiAgIGNhcGFjaXR5IHQgLSAxXS4gIFNvLCBxdWV1ZSBlbGVtZW50IFtpXSBpcyBhdCBbdC5lbHRzLiggKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFzayApXS5cblxuICAgW251bV9tdXRhdGlvbnNdIGlzIHVzZWQgdG8gZGV0ZWN0IG1vZGlmaWNhdGlvbiBkdXJpbmcgaXRlcmF0aW9uLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIG51bV9tdXRhdGlvbnMgOiBpbnRcbiAgOyBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBtYXNrIDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxX1xuICAgIHsgbnVtX211dGF0aW9ucyA9IG51bV9tdXRhdGlvbnNfXzAwM19cbiAgICA7IGZyb250ID0gZnJvbnRfXzAwNV9cbiAgICA7IG1hc2sgPSBtYXNrX18wMDdfXG4gICAgOyBsZW5ndGggPSBsZW5ndGhfXzAwOV9cbiAgICA7IGVsdHMgPSBlbHRzX18wMTFfXG4gICAgfSAtPlxuICAgIGxldCBibmRzX18wMDJfID0gW10gaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMTJfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMTFfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDEyXyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAxMF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwOV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAxMF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9pbnQgbWFza19fMDA3XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFza1wiOyBhcmdfXzAwOF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDZfID0gc2V4cF9vZl9pbnQgZnJvbnRfXzAwNV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImZyb250XCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBudW1fbXV0YXRpb25zX18wMDNfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJudW1fbXV0YXRpb25zXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDJfXG47O1xuXG5bQEBAZW5kXVxuXG5tb2R1bGUgdHlwZSBTID0gUXVldWVfaW50Zi5TXG5cbmxldCBpbmNfbnVtX211dGF0aW9ucyB0ID0gdC5udW1fbXV0YXRpb25zIDwtIHQubnVtX211dGF0aW9ucyArIDFcbmxldCBjYXBhY2l0eSB0ID0gdC5tYXNrICsgMVxubGV0IGVsdHNfaW5kZXggdCBpID0gKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFza1xubGV0IHVuc2FmZV9nZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfaXNfc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfaXNfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIGEgPSBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpIGFcbmxldCB1bnNhZmVfdW5zZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxuXG5sZXQgY2hlY2tfaW5kZXhfZXhuIHQgaSA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gdC5sZW5ndGhcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiUXVldWUgaW5kZXggb3V0IG9mIGJvdW5kc1wiXG4gICAgICAgICBbIFwiaW5kZXhcIiwgaSB8PiBJbnQuc2V4cF9vZl90OyBcImxlbmd0aFwiLCB0Lmxlbmd0aCB8PiBJbnQuc2V4cF9vZl90IF0pXG47O1xuXG5sZXQgZ2V0IHQgaSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIHVuc2FmZV9nZXQgdCBpXG47O1xuXG5sZXQgc2V0IHQgaSBhID1cbiAgY2hlY2tfaW5kZXhfZXhuIHQgaTtcbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgdW5zYWZlX3NldCB0IGkgYVxuOztcblxubGV0IGlzX2VtcHR5IHQgPSB0Lmxlbmd0aCA9IDBcbmxldCBsZW5ndGggeyBsZW5ndGg7IF8gfSA9IGxlbmd0aFxuXG5sZXQgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9ucyA9XG4gIGlmIHQubnVtX211dGF0aW9ucyA8PiBudW1fbXV0YXRpb25zXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIm11dGF0aW9uIG9mIHF1ZXVlIGR1cmluZyBpdGVyYXRpb25cIlxuICAgICAgICAgWyBcIlwiLCB0IHw+IHNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSBdKVxuOztcblxubGV0IGNvbXBhcmUgPVxuICBsZXQgcmVjIHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgcG9zIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDIgPVxuICAgIG1hdGNoIHBvcyA9IGxlbjEsIHBvcyA9IGxlbjIgd2l0aFxuICAgIHwgdHJ1ZSwgdHJ1ZSAtPiAwXG4gICAgfCB0cnVlLCBmYWxzZSAtPiAtMVxuICAgIHwgZmFsc2UsIHRydWUgLT4gMVxuICAgIHwgZmFsc2UsIGZhbHNlIC0+XG4gICAgICBsZXQgeCA9IGNvbXBhcmVfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDIgbXV0MjtcbiAgICAgIChtYXRjaCB4IHdpdGhcbiAgICAgICB8IDAgLT4gdW5zYWZlX2NvbXBhcmVfZnJvbSBjb21wYXJlX2VsdCAocG9zICsgMSkgfnQxIH50MiB+bGVuMSB+bGVuMiB+bXV0MSB+bXV0MlxuICAgICAgIHwgbiAtPiBuKVxuICBpblxuICBmdW4gY29tcGFyZV9lbHQgdDEgdDIgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHQxIHQyXG4gICAgdGhlbiAwXG4gICAgZWxzZVxuICAgICAgdW5zYWZlX2NvbXBhcmVfZnJvbVxuICAgICAgICBjb21wYXJlX2VsdFxuICAgICAgICAwXG4gICAgICAgIH50MVxuICAgICAgICB+dDJcbiAgICAgICAgfmxlbjE6dDEubGVuZ3RoXG4gICAgICAgIH5sZW4yOnQyLmxlbmd0aFxuICAgICAgICB+bXV0MTp0MS5udW1fbXV0YXRpb25zXG4gICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBlcXVhbCA9XG4gIGxldCByZWMgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IHBvcyB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW4gPVxuICAgIHBvcyA9IGxlblxuICAgIHx8XG4gICAgbGV0IGIgPSBlcXVhbF9lbHQgKHVuc2FmZV9nZXQgdDEgcG9zKSAodW5zYWZlX2dldCB0MiBwb3MpIGluXG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgYiAmJiB1bnNhZmVfZXF1YWxfZnJvbSBlcXVhbF9lbHQgKHBvcyArIDEpIH50MSB+dDIgfm11dDEgfm11dDIgfmxlblxuICBpblxuICBmdW4gZXF1YWxfZWx0IHQxIHQyIC0+XG4gICAgcGh5c19lcXVhbCB0MSB0MlxuICAgIHx8XG4gICAgbGV0IGxlbjEgPSB0MS5sZW5ndGggaW5cbiAgICBsZXQgbGVuMiA9IHQyLmxlbmd0aCBpblxuICAgIGxlbjEgPSBsZW4yXG4gICAgJiYgdW5zYWZlX2VxdWFsX2Zyb21cbiAgICAgICAgIGVxdWFsX2VsdFxuICAgICAgICAgMFxuICAgICAgICAgfnQxXG4gICAgICAgICB+dDJcbiAgICAgICAgIH5sZW46bGVuMVxuICAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICAgfm11dDI6dDIubnVtX211dGF0aW9uc1xuOztcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbGV0IHsgbnVtX211dGF0aW9uczsgbWFzayA9IF87IGVsdHM7IGZyb250OyBsZW5ndGggfSA9IHQgaW5cbiAgYXNzZXJ0IChmcm9udCA+PSAwKTtcbiAgYXNzZXJ0IChmcm9udCA8IGNhcGFjaXR5IHQpO1xuICBsZXQgY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGFzc2VydCAoY2FwYWNpdHkgPSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICBhc3NlcnQgKGNhcGFjaXR5ID49IDEpO1xuICBhc3NlcnQgKEludC5pc19wb3cyIGNhcGFjaXR5KTtcbiAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5KTtcbiAgZm9yIGkgPSAwIHRvIGNhcGFjaXR5IC0gMSBkb1xuICAgIGlmIGkgPCB0Lmxlbmd0aFxuICAgIHRoZW4gKFxuICAgICAgaW52YXJpYW50X2EgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMpXG4gICAgZWxzZSBhc3NlcnQgKG5vdCAodW5zYWZlX2lzX3NldCB0IGkpKVxuICBkb25lXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpID9jYXBhY2l0eSAoKSA6IGEgdCA9XG4gIGxldCBjYXBhY2l0eSA9XG4gICAgbWF0Y2ggY2FwYWNpdHkgd2l0aFxuICAgIHwgTm9uZSAtPiAxXG4gICAgfCBTb21lIGNhcGFjaXR5IC0+XG4gICAgICBpZiBjYXBhY2l0eSA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcImNhbm5vdCBoYXZlIHF1ZXVlIHdpdGggbmVnYXRpdmUgY2FwYWNpdHlcIlxuICAgICAgICAgICAgIFsgXCJjYXBhY2l0eVwiLCBjYXBhY2l0eSB8PiBJbnQuc2V4cF9vZl90IF0pXG4gICAgICBlbHNlIGlmIGNhcGFjaXR5ID0gMFxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIEludC5jZWlsX3BvdzIgY2FwYWNpdHlcbiAgaW5cbiAgeyBudW1fbXV0YXRpb25zID0gMFxuICA7IGZyb250ID0gMFxuICA7IG1hc2sgPSBjYXBhY2l0eSAtIDFcbiAgOyBsZW5ndGggPSAwXG4gIDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpjYXBhY2l0eVxuICB9XG47O1xuXG5sZXQgYmxpdF90b19hcnJheSB+c3JjIGRzdCA9XG4gIGFzc2VydCAoc3JjLmxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGRzdCk7XG4gIGxldCBmcm9udF9sZW4gPSBJbnQubWluIHNyYy5sZW5ndGggKGNhcGFjaXR5IHNyYyAtIHNyYy5mcm9udCkgaW5cbiAgbGV0IHJlc3RfbGVuID0gc3JjLmxlbmd0aCAtIGZyb250X2xlbiBpblxuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOmZyb250X2xlbiB+c3JjOnNyYy5lbHRzIH5zcmNfcG9zOnNyYy5mcm9udCB+ZHN0IH5kc3RfcG9zOjA7XG4gIE9wdGlvbl9hcnJheS5ibGl0IH5sZW46cmVzdF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6ZnJvbnRfbGVuXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgZGVzaXJlZF9jYXBhY2l0eSA9XG4gICgqIFdlIGFsbG93IGFyZ3VtZW50cyBsZXNzIHRoYW4gMSB0byBbc2V0X2NhcGFjaXR5XSwgYnV0IHRyYW5zbGF0ZSB0aGVtIHRvIDEgdG8gc2ltcGxpZnlcbiAgICAgdGhlIGNvZGUgdGhhdCByZWxpZXMgb24gdGhlIGFycmF5IGxlbmd0aCBiZWluZyBhIHBvd2VyIG9mIDIuICopXG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBuZXdfY2FwYWNpdHkgPSBJbnQuY2VpbF9wb3cyIChtYXggMSAobWF4IGRlc2lyZWRfY2FwYWNpdHkgdC5sZW5ndGgpKSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdFxuICB0aGVuIChcbiAgICBsZXQgZHN0ID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOm5ld19jYXBhY2l0eSBpblxuICAgIGJsaXRfdG9fYXJyYXkgfnNyYzp0IGRzdDtcbiAgICB0LmZyb250IDwtIDA7XG4gICAgdC5tYXNrIDwtIG5ld19jYXBhY2l0eSAtIDE7XG4gICAgdC5lbHRzIDwtIGRzdClcbjs7XG5cbmxldCBlbnF1ZXVlIHQgYSA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eSB0ICgyICogdC5sZW5ndGgpO1xuICB1bnNhZmVfc2V0IHQgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgZGVxdWV1ZV9ub25lbXB0eSB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IGVsdHMgPSB0LmVsdHMgaW5cbiAgbGV0IGZyb250ID0gdC5mcm9udCBpblxuICBsZXQgcmVzID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGZyb250IGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSBlbHRzIGZyb250O1xuICB0LmZyb250IDwtIGVsdHNfaW5kZXggdCAxO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIHJlc1xuOztcblxubGV0IGRlcXVldWVfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGRlcXVldWVfbm9uZW1wdHkgdFxubGV0IGRlcXVldWUgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZGVxdWV1ZV9ub25lbXB0eSB0KVxubGV0IGZyb250X25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgdC5mcm9udFxubGV0IGxhc3Rfbm9uZW1wdHkgdCA9IHVuc2FmZV9nZXQgdCAodC5sZW5ndGggLSAxKVxubGV0IHBlZWsgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZnJvbnRfbm9uZW1wdHkgdClcbmxldCBwZWVrX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBmcm9udF9ub25lbXB0eSB0XG5sZXQgbGFzdCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChsYXN0X25vbmVtcHR5IHQpXG5sZXQgbGFzdF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgbGFzdF9ub25lbXB0eSB0XG5cbmxldCBjbGVhciB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPiAwXG4gIHRoZW4gKFxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHVuc2FmZV91bnNldCB0IGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgdC5mcm9udCA8LSAwKVxuOztcblxubGV0IGJsaXRfdHJhbnNmZXIgfnNyYyB+ZHN0ID9sZW4gKCkgPVxuICBpbmNfbnVtX211dGF0aW9ucyBzcmM7XG4gIGluY19udW1fbXV0YXRpb25zIGRzdDtcbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gc3JjLmxlbmd0aFxuICAgIHwgU29tZSBsZW4gLT5cbiAgICAgIGlmIGxlbiA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcIlF1ZXVlLmJsaXRfdHJhbnNmZXI6IG5lZ2F0aXZlIGxlbmd0aFwiXG4gICAgICAgICAgICAgWyBcImxlbmd0aFwiLCBsZW4gfD4gSW50LnNleHBfb2ZfdCBdKTtcbiAgICAgIG1pbiBsZW4gc3JjLmxlbmd0aFxuICBpblxuICBpZiBsZW4gPiAwXG4gIHRoZW4gKFxuICAgIHNldF9jYXBhY2l0eSBkc3QgKG1heCAoY2FwYWNpdHkgZHN0KSAoZHN0Lmxlbmd0aCArIGxlbikpO1xuICAgIGxldCBkc3Rfc3RhcnQgPSBkc3QuZnJvbnQgKyBkc3QubGVuZ3RoIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICgqIFRoaXMgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiBzaW1wbHkgW2VucXVldWUgZHN0IChkZXF1ZXVlX25vbmVtcHR5IHNyYyldICopXG4gICAgICBsZXQgc3JjX2kgPSAoc3JjLmZyb250ICsgaSkgbGFuZCBzcmMubWFzayBpblxuICAgICAgbGV0IGRzdF9pID0gKGRzdF9zdGFydCArIGkpIGxhbmQgZHN0Lm1hc2sgaW5cbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWVcbiAgICAgICAgZHN0LmVsdHNcbiAgICAgICAgZHN0X2lcbiAgICAgICAgKE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHNyYy5lbHRzIHNyY19pKTtcbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgc3JjLmVsdHMgc3JjX2lcbiAgICBkb25lO1xuICAgIGRzdC5sZW5ndGggPC0gZHN0Lmxlbmd0aCArIGxlbjtcbiAgICBzcmMuZnJvbnQgPC0gKHNyYy5mcm9udCArIGxlbikgbGFuZCBzcmMubWFzaztcbiAgICBzcmMubGVuZ3RoIDwtIHNyYy5sZW5ndGggLSBsZW4pXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIHNldF9jYXBhY2l0eSB0IChJbnQubWF4IChjYXBhY2l0eSB0KSAodC5sZW5ndGggKyBMaXN0Lmxlbmd0aCBsKSk7XG4gIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gICAgbGV0IHIgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICAgIGRvbmU7XG4gICAgIXIpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGEgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgYSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYylcbjs7XG5cblxuKCogW2l0ZXJdIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGJlY2F1c2UgaW1wbGVtZW50aW5nIGl0IGluIHRlcm1zIG9mIFtmb2xkXSBpc1xuICAgc2xvd2VyLiAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVzdWx0ID0gcmVmIFtdIGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgcmVzdWx0IDo9IHVuc2FmZV9nZXQgdCBpIDo6ICFyZXN1bHRcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICBlbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5cblxuKCogRm9yIFtjb25jYXRfbWFwXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl0sIHdlIGRvbid0IGNyZWF0ZSBbdF9yZXN1bHRdIHdpdGggW3RdJ3NcbiAgIGNhcGFjaXR5IGJlY2F1c2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyBtYW55IGVsZW1lbnRzIFt0X3Jlc3VsdF0gd2lsbCB1bHRpbWF0ZWx5IGhvbGQuICopXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlciB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlcmkgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlIH5jYXBhY2l0eTpzcmMubGVuZ3RoICgpIGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QuZWx0cztcbiAgZHN0Lmxlbmd0aCA8LSBzcmMubGVuZ3RoO1xuICBkc3Rcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OihMaXN0Lmxlbmd0aCBsKSAoKSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG4oKiBUaGUgcXVldWUgW3RdIHJldHVybmVkIGJ5IFtjcmVhdGVdIHdpbGwgaGF2ZSBbdC5sZW5ndGggPSAwXSwgW3QuZnJvbnQgPSAwXSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IEludC5jZWlsX3BvdzIgbGVuXS4gIFNvLCB3ZSBvbmx5IGhhdmUgdG8gc2V0IFt0Lmxlbmd0aF0gdG8gW2xlbl0gYWZ0ZXJcbiAgIHRoZSBibGl0IHRvIG1haW50YWluIGFsbCB0aGUgaW52YXJpYW50czogW3QubGVuZ3RoXSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICBpbiB0aGUgcXVldWUsIFt0LmZyb250XSBpcyB0aGUgYXJyYXkgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAqKVxubGV0IGluaXQgbGVuIH5mID1cbiAgaWYgbGVuIDwgMFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIlF1ZXVlLmluaXQ6IG5lZ2F0aXZlIGxlbmd0aFwiIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTpsZW4gKCkgaW5cbiAgYXNzZXJ0IChPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyA+PSBsZW4pO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIGkgKGYgaSlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gbGVuO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkudW5zYWZlX2dldCBhKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IHQubGVuZ3RoIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IG1hcCB0YSB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdGEubnVtX211dGF0aW9ucyBpblxuICBsZXQgdGIgPSBjcmVhdGUgfmNhcGFjaXR5OnRhLmxlbmd0aCAoKSBpblxuICB0Yi5sZW5ndGggPC0gdGEubGVuZ3RoO1xuICBmb3IgaSA9IDAgdG8gdGEubGVuZ3RoIC0gMSBkb1xuICAgIGxldCBiID0gZiAodW5zYWZlX2dldCB0YSBpKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0YSBudW1fbXV0YXRpb25zO1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdGIuZWx0cyBpIGJcbiAgZG9uZTtcbiAgdGJcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIG1hcCB0IH5mOihmdW4gYSAtPlxuICAgIGxldCByZXN1bHQgPSBmICFpIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICByZXN1bHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgeDtcbiAgdFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHRvX2xpc3QgdCB8PiBMaXN0LnNleHBfb2ZfdCBzZXhwX29mX2FcbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBMaXN0LnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCB8PiBvZl9saXN0XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB8XG5cbiAgbGV0IHVucmVhY2hhYmxlX2NvZGUgPSBmdW5jdGlvblxuICAgIHwgKF8gOiB0KSAtPiAuXG4gIDs7XG5cbiAgbGV0IGFsbCA9IFtdXG4gIGxldCBoYXNoX2ZvbGRfdCBfIHQgPSB1bnJlYWNoYWJsZV9jb2RlIHRcbiAgbGV0IGhhc2ggPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBjb21wYXJlIGEgXyA9IHVucmVhY2hhYmxlX2NvZGUgYVxuICBsZXQgc2V4cF9vZl90ID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgdF9vZl9zZXhwIHNleHAgPSBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfdHlwZSBcIkJhc2UuTm90aGluZy50XCIgc2V4cFxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBVbmlvbiBbXSB9XG4gIGxldCB0b19zdHJpbmcgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBvZl9zdHJpbmcgKF8gOiBzdHJpbmcpID0gZmFpbHdpdGggXCJCYXNlLk5vdGhpbmcub2Zfc3RyaW5nOiBub3Qgc3VwcG9ydGVkXCJcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTm90aGluZ1wiXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5OYXRpdmVpbnRcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChuYXRpdmVpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfbmF0aXZlaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IG5hdGl2ZWludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX25hdGl2ZWludCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfbmF0aXZlaW50XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSBuZWdcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJW54XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlbnhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnRcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBudW1fYml0cyA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJOYXRpdmVpbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLk5hdGl2ZWludC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuTmF0aXZlaW50LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5OYXRpdmVpbnQubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyICh4IDogbmF0aXZlaW50KSA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuTmF0aXZlaW50LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5OYXRpdmVpbnQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5OYXRpdmVpbnQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5OYXRpdmVpbnQucHJlZCB4ID0gMG5cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBuYXRpdmVpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiXG4gICAgICAgICAgIFsgXCJcIiwgc2V4cF9vZl9uYXRpdmVpbnQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgaWYgQ2FtbC5OYXRpdmVpbnQuZXF1YWwgaSBDYW1sLk5hdGl2ZWludC5vbmVcbiAgICB0aGVuIDBcbiAgICBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLk5hdGl2ZWludC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfbmF0aXZlaW50IHQgPSB0XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IG9mX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludCB0ID0gdFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50Lm5hdGl2ZWludF9wb3Bjb3VudFxubGV0IG9mX2ludCA9IENvbnYuaW50X3RvX25hdGl2ZWludFxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludF90cnVuY1xubGV0IG9mX2ludDMyID0gQ29udi5pbnQzMl90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCB0b19pbnQzMl90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbTmF0aXZlaW50XSBhbmQgW05hdGl2ZWludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmV4dGVybmFsIGJzd2FwIDogdCAtPiB0ID0gXCIlYnN3YXBfbmF0aXZlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1hcF9pbnRmXG5cbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuRmluaXNoZWRfb3JfdW5maW5pc2hlZFxuXG4gICgqIFRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIHRlc3RlZCBpbiBbdGVzdF9tYXAubWxdIHRvIG1ha2Ugc3VyZSBvdXIgdXNlIG9mXG4gICAgIFtDYW1sLk9iai5tYWdpY10gaXMgY29ycmVjdCBhbmQgc2FmZS4gKilcbiAgbGV0IG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdCA9IENhbWwuT2JqLm1hZ2ljXG4gIGxldCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnQgPSBDYW1sLk9iai5tYWdpY1xuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuTWVyZ2VfZWxlbWVudFxuXG4gIGxldCBsZWZ0ID0gZnVuY3Rpb25cbiAgICB8IGBSaWdodCBfIC0+IE5vbmVcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gU29tZSBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiBTb21lIHJpZ2h0XG4gIDs7XG5cbiAgbGV0IGxlZnRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgUmlnaHQgXyAtPiBkZWZhdWx0XG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBfIC0+IGRlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gcmlnaHRcbiAgOztcblxuICBsZXQgdmFsdWVzIHQgfmxlZnRfZGVmYXVsdCB+cmlnaHRfZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBsZWZ0IC0+IGxlZnQsIHJpZ2h0X2RlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCAtPiBsZWZ0X2RlZmF1bHQsIHJpZ2h0XG4gICAgfCBgQm90aCAobGVmdCwgcmlnaHQpIC0+IGxlZnQsIHJpZ2h0XG4gIDs7XG5lbmRcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxuZXhjZXB0aW9uIER1cGxpY2F0ZSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIER1cGxpY2F0ZV0gKGZ1bmN0aW9uXG4gICAgfCBEdXBsaWNhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLkR1cGxpY2F0ZVwiXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbm1vZHVsZSBUcmVlMCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPVxuICAgIHwgRW1wdHlcbiAgICB8IExlYWYgb2YgJ2sgKiAndlxuICAgIHwgTm9kZSBvZiAoJ2ssICd2KSB0ICogJ2sgKiAndiAqICgnaywgJ3YpIHQgKiBpbnRcblxuICB0eXBlICgnaywgJ3YpIHRyZWUgPSAoJ2ssICd2KSB0XG5cbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgXywgaCkgLT4gaFxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzID1cbiAgICBsZXQgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkgayA9XG4gICAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgfCBTb21lIGxvd2VyIC0+IGNvbXBhcmVfa2V5IGxvd2VyIGsgPCAwKVxuICAgICAgJiZcbiAgICAgIG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFNvbWUgdXBwZXIgLT4gY29tcGFyZV9rZXkgayB1cHBlciA8IDBcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBsb3dlciB1cHBlciBjb21wYXJlX2tleSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgICB8IExlYWYgKGssIF8pIC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgIHwgTm9kZSAobCwgaywgXywgciwgaCkgLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSBrKSBjb21wYXJlX2tleSBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgaykgdXBwZXIgY29tcGFyZV9rZXkgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfa2V5IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfa2V5IHRcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDIgKilcbiAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgaWYgaGwgPSAwICYmIGhyID0gMFxuICAgIHRoZW4gTGVhZiAoeCwgZClcbiAgICBlbHNlIE5vZGUgKGwsIHgsIGQsIHIsIGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKVxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24ga2V5IGRhdGEgPSBMZWFmIChrZXksIGRhdGEpXG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuTWFwIG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA6IChfLCBfKSB0ID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGssIHYgPSBmIGkgaW5cbiAgICAgICAgTGVhZiAoaywgdilcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIE5vZGUgKExlYWYgKGtsLCB2bCksIGssIHYsIEVtcHR5LCAyKVxuICAgICAgfCAzIC0+XG4gICAgICAgIGxldCBrbCwgdmwgPSBmIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgMSkgaW5cbiAgICAgICAgbGV0IGtyLCB2ciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBOb2RlIChMZWFmIChrbCwgdmwpLCBrLCB2LCBMZWFmIChrciwgdnIpLCAyKVxuICAgICAgfCBuIC0+XG4gICAgICAgIGxldCBsZWZ0X2xlbmd0aCA9IG4gbHNyIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X2xlbmd0aCA9IG4gLSBsZWZ0X2xlbmd0aCAtIDEgaW5cbiAgICAgICAgbGV0IGxlZnQgPSBsb29wIGxlZnRfbGVuZ3RoIH5mIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgbGVmdF9sZW5ndGgpIGluXG4gICAgICAgIGxldCByaWdodCA9IGxvb3AgcmlnaHRfbGVuZ3RoIH5mIChpICsgbGVmdF9sZW5ndGggKyAxKSBpblxuICAgICAgICBjcmVhdGUgbGVmdCBrIHYgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyXG4gICAgICAgICB8fFxuICAgICAgICAgbGV0IGswLCBfID0gYXJyYXkuKDApIGluXG4gICAgICAgICBsZXQgazEsIF8gPSBhcnJheS4oMSkgaW5cbiAgICAgICAgIGNvbXBhcmVfa2V5IGswIGsxIDwgMFxuICAgICAgdGhlbiBmdW4gaSAtPiBhcnJheS4oaSlcbiAgICAgIGVsc2UgZnVuIGkgLT4gYXJyYXkuKGFycmF5X2xlbmd0aCAtIDEgLSBpKVxuICAgIGluXG4gICAgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbjphcnJheV9sZW5ndGggfmY6bmV4dCwgYXJyYXlfbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfa2V5IChmc3QgYXJyYXkuKDApKSAoZnN0IGFycmF5LigxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oaSkpIChmc3QgYXJyYXkuKGkgKyAxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSkpXG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAzICopXG4gIGxldCBiYWwgbCB4IGQgciA9XG4gICAgbGV0IGhsID0gaGVpZ2h0IGwgaW5cbiAgICBsZXQgaHIgPSBoZWlnaHQgciBpblxuICAgIGlmIGhsID4gaHIgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBoZWlnaHQoTGVhZikgPSAxICYmIDEgaXMgbm90IGxhcmdlciB0aGFuIGhyICsgMiAqKVxuICAgICAgfCBOb2RlIChsbCwgbHYsIGxkLCBsciwgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgIHwgTGVhZiAobHJ2LCBscmQpIC0+IGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIEVtcHR5KSBscnYgbHJkIChjcmVhdGUgRW1wdHkgeCBkIHIpXG4gICAgICAgICAgfCBOb2RlIChscmwsIGxydiwgbHJkLCBscnIsIF8pIC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBoZWlnaHQoTGVhZikgPSAxICYmIDEgaXMgbm90IGxhcmdlciB0aGFuIGhsICsgMiAqKVxuICAgICAgfCBOb2RlIChybCwgcnYsIHJkLCByciwgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgIHwgTGVhZiAocmx2LCBybGQpIC0+IGNyZWF0ZSAoY3JlYXRlIGwgeCBkIEVtcHR5KSBybHYgcmxkIChjcmVhdGUgRW1wdHkgcnYgcmQgcnIpXG4gICAgICAgICAgfCBOb2RlIChybGwsIHJsdiwgcmxkLCBybHIsIF8pIC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpKSlcbiAgICBlbHNlIGNyZWF0ZSBsIHggZCByXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiW01hcC5hZGRfZXhuXSBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5cbiAgbW9kdWxlIEFkZF9vcl9zZXQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBBZGRfZXhuX2ludGVybmFsXG4gICAgICB8IEFkZF9leG5cbiAgICAgIHwgU2V0XG4gIGVuZFxuXG5cbiAgbGV0IHJlYyBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICAgICB0XG4gICAgICAgICAgICB+bGVuZ3RoXG4gICAgICAgICAgICB+a2V5OnhcbiAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICAgICAgICAgIH5zZXhwX29mX2tleVxuICAgICAgICAgICAgfihhZGRfb3Jfc2V0IDogQWRkX29yX3NldC50KVxuICAgID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgKHgsIGRhdGEpLCBsZW5ndGggKyAxXG4gICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT4gTGVhZiAoeCwgZGF0YSksIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gTm9kZSAoTGVhZiAoeCwgZGF0YSksIHYsIGQsIEVtcHR5LCAyKSwgbGVuZ3RoICsgMVxuICAgICAgZWxzZSBOb2RlIChFbXB0eSwgdiwgZCwgTGVhZiAoeCwgZGF0YSksIDIpLCBsZW5ndGggKyAxXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT4gTm9kZSAobCwgeCwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbCwgbGVuZ3RoID1cbiAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IH5sZW5ndGggfmtleTp4IH5kYXRhIGwgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldFxuICAgICAgICBpblxuICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByLCBsZW5ndGggPVxuICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgfmxlbmd0aCB+a2V5OnggfmRhdGEgciB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0XG4gICAgICAgIGluXG4gICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0OkFkZF9leG5cbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXlcbiAgICAgIH5hZGRfb3Jfc2V0OkFkZF9leG5faW50ZXJuYWxcbiAgOztcblxuICBsZXQgc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgdFxuICAgICAgfmxlbmd0aFxuICAgICAgfmtleVxuICAgICAgfmRhdGFcbiAgICAgIH5jb21wYXJlX2tleVxuICAgICAgfnNleHBfb2Zfa2V5OihmdW4gXyAtPiBMaXN0IFtdKVxuICAgICAgfmFkZF9vcl9zZXQ6U2V0XG4gIDs7XG5cbiAgbGV0IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXkgPSBmc3QgKHNldCB0IH5sZW5ndGg6MCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSlcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIG1vZHVsZSBGcmFnbWVudCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9XG4gICAgICAgIHsgbGVmdF9zdWJ0cmVlIDogKCdrLCAndikgdFxuICAgICAgICA7IGtleSA6ICdrXG4gICAgICAgIDsgZGF0YSA6ICd2XG4gICAgICAgIH1cblxuICAgICAgbGV0IHNpbmdsZXRvbl90b190cmVlX2V4biA9IGZ1bmN0aW9uXG4gICAgICAgIHwgeyBsZWZ0X3N1YnRyZWUgPSBFbXB0eTsga2V5OyBkYXRhIH0gLT4gc2luZ2xldG9uIGtleSBkYXRhXG4gICAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIk1hcC5zaW5nbGV0b25fdG9fdHJlZV9leG46IG5vdCBhIHNpbmdsZXRvblwiXG4gICAgICA7O1xuXG4gICAgICBsZXQgc2luZ2xldG9uIH5rZXkgfmRhdGEgPSB7IGxlZnRfc3VidHJlZSA9IEVtcHR5OyBrZXk7IGRhdGEgfVxuXG4gICAgICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobC5sZWZ0X3N1YnRyZWUpIC0gaGVpZ2h0KHIpfCA8PSAyLFxuICAgICAgICAgbWF4X2tleShsKSA8IG1pbl9rZXkocilcbiAgICAgICopXG4gICAgICBsZXQgY29sbGFwc2UgbCByID0gY3JlYXRlIGwubGVmdF9zdWJ0cmVlIGwua2V5IGwuZGF0YSByXG5cbiAgICAgICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsLmxlZnRfc3VidHJlZSkgLSBoZWlnaHQoci5sZWZ0X3N1YnRyZWUpfCA8PSAyLFxuICAgICAgICAgbWF4X2tleShsKSA8IG1pbl9rZXkocilcbiAgICAgICopXG4gICAgICBsZXQgam9pbiBsIHIgPSB7IHIgd2l0aCBsZWZ0X3N1YnRyZWUgPSBjb2xsYXBzZSBsIHIubGVmdF9zdWJ0cmVlIH1cbiAgICAgIGxldCBtYXhfa2V5IHQgPSB0LmtleVxuICAgIGVuZFxuXG4gICAgKCoqIEJ1aWxkIHRyZWVzIGZyb20gc2luZ2xldG9ucyBpbiBhIGJhbGFuY2VkIHdheSBieSB1c2luZyBza2V3IGJpbmFyeSBlbmNvZGluZy5cbiAgICAgICAgRWFjaCBsZXZlbCBjb250YWlucyB0cmVlcyBvZiB0aGUgc2FtZSBoZWlnaHQsIGNvbnNlY3V0aXZlIGxldmVscyBoYXZlIGNvbnNlY3V0aXZlXG4gICAgICAgIGhlaWdodHMuIFRoZXJlIGFyZSBubyBnYXBzLiBUaGUgZmlyc3QgbGV2ZWwgYXJlIHNpbmdsZSBrZXlzLlxuICAgICopXG4gICAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICAgIHwgWmVybyBvZiB1bml0XG4gICAgICAoKiBbdW5pdF0gdG8gbWFrZSBwYXR0ZXJuIG1hdGNoaW5nIGZhc3RlciAqKVxuICAgICAgfCBPbmUgb2YgKCdrLCAndikgdCAqICgnaywgJ3YpIEZyYWdtZW50LnRcbiAgICAgIHwgVHdvIG9mICgnaywgJ3YpIHQgKiAoJ2ssICd2KSBGcmFnbWVudC50ICogKCdrLCAndikgRnJhZ21lbnQudFxuXG4gICAgbGV0IGVtcHR5ID0gWmVybyAoKVxuXG4gICAgbGV0IGFkZF91bmNoZWNrZWQgPVxuICAgICAgbGV0IHJlYyBnbyB0IHggPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBaZXJvICgpIC0+IE9uZSAodCwgeClcbiAgICAgICAgfCBPbmUgKHQsIHkpIC0+IFR3byAodCwgeSwgeClcbiAgICAgICAgfCBUd28gKHQsIHosIHkpIC0+IE9uZSAoZ28gdCAoRnJhZ21lbnQuam9pbiB6IHkpLCB4KVxuICAgICAgaW5cbiAgICAgIGZ1biB0IH5rZXkgfmRhdGEgLT4gZ28gdCAoRnJhZ21lbnQuc2luZ2xldG9uIH5rZXkgfmRhdGEpXG4gICAgOztcblxuICAgIGxldCB0b190cmVlX3VuY2hlY2tlZCA9XG4gICAgICBsZXQgcmVjIGdvIHQgciA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFplcm8gKCkgLT4gclxuICAgICAgICB8IE9uZSAodCwgbCkgLT4gZ28gdCAoRnJhZ21lbnQuY29sbGFwc2UgbCByKVxuICAgICAgICB8IFR3byAodCwgbGwsIGwpIC0+IGdvIHQgKEZyYWdtZW50LmNvbGxhcHNlIChGcmFnbWVudC5qb2luIGxsIGwpIHIpXG4gICAgICBpblxuICAgICAgZnVuY3Rpb25cbiAgICAgIHwgWmVybyAoKSAtPiBFbXB0eVxuICAgICAgfCBPbmUgKHQsIHIpIC0+IGdvIHQgKEZyYWdtZW50LnNpbmdsZXRvbl90b190cmVlX2V4biByKVxuICAgICAgfCBUd28gKHQsIGwsIHIpIC0+IGdvIChPbmUgKHQsIGwpKSAoRnJhZ21lbnQuc2luZ2xldG9uX3RvX3RyZWVfZXhuIHIpXG4gICAgOztcblxuICAgIGxldCBtYXhfa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgWmVybyAoKSAtPiBOb25lXG4gICAgICB8IE9uZSAoXywgcikgfCBUd28gKF8sIF8sIHIpIC0+IFNvbWUgKEZyYWdtZW50Lm1heF9rZXkgcilcbiAgICA7O1xuICBlbmRcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGxldCBidWlsZGVyLCBsZW5ndGggPVxuICAgICAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICAgICAgc2VxXG4gICAgICAgICAgfmluaXQ6KEJ1aWxkX2luY3JlYXNpbmcuZW1wdHksIDApXG4gICAgICAgICAgfmY6KGZ1biAoYnVpbGRlciwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbWF0Y2ggQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IGJ1aWxkZXIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIHByZXZfa2V5IHdoZW4gY29tcGFyZV9rZXkgcHJldl9rZXkga2V5ID49IDAgLT5cbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX2luY3JlYXNpbmdfc2VxdWVuY2U6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgICAgICAgfCBfIC0+IEJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCBidWlsZGVyIH5rZXkgfmRhdGEsIGxlbmd0aCArIDEpXG4gICAgICBpblxuICAgICAgT2sgKEJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgYnVpbGRlciwgbGVuZ3RoKSlcbiAgOztcblxuICAoKiBMaWtlIFtiYWxdIGJ1dCBhbGxvd3MgYW55IGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGJldHdlZW4gW2xdIGFuZCBbcl0uXG5cbiAgICAgTyh8aGVpZ2h0IGwgLSBoZWlnaHQgcnwpICopXG4gIGxldCByZWMgam9pbiBsIGsgZCByIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBzZXQnIHIgayBkIH5jb21wYXJlX2tleVxuICAgIHwgXywgRW1wdHkgLT4gc2V0JyBsIGsgZCB+Y29tcGFyZV9rZXlcbiAgICB8IExlYWYgKGxrLCBsZCksIF8gLT4gc2V0JyAoc2V0JyByIGsgZCB+Y29tcGFyZV9rZXkpIGxrIGxkIH5jb21wYXJlX2tleVxuICAgIHwgXywgTGVhZiAocmssIHJkKSAtPiBzZXQnIChzZXQnIGwgayBkIH5jb21wYXJlX2tleSkgcmsgcmQgfmNvbXBhcmVfa2V5XG4gICAgfCBOb2RlIChsbCwgbGssIGxkLCBsciwgbGgpLCBOb2RlIChybCwgcmssIHJkLCByciwgcmgpIC0+XG4gICAgICAoKiBbYmFsXSByZXF1aXJlcyBoZWlnaHQgZGlmZmVyZW5jZSA8PSAzLiAqKVxuICAgICAgaWYgbGggPiByaCArIDNcbiAgICAgICgqIFtoZWlnaHQgbHIgPj0gaGVpZ2h0IHJdLFxuICAgICAgICAgdGhlcmVmb3JlIFtoZWlnaHQgKGpvaW4gbHIgayBkIHIgLi4uKV0gaXMgW2hlaWdodCBybCArIDFdIG9yIFtoZWlnaHQgcmxdXG4gICAgICAgICB0aGVyZWZvcmUgdGhlIGhlaWdodCBkaWZmZXJlbmNlIHdpdGggW2xsXSB3aWxsIGJlIDw9IDMgKilcbiAgICAgIHRoZW4gYmFsIGxsIGxrIGxkIChqb2luIGxyIGsgZCByIH5jb21wYXJlX2tleSlcbiAgICAgIGVsc2UgaWYgcmggPiBsaCArIDNcbiAgICAgIHRoZW4gYmFsIChqb2luIGwgayBkIHJsIH5jb21wYXJlX2tleSkgcmsgcmQgcnJcbiAgICAgIGVsc2UgYmFsIGwgayBkIHJcbiAgOztcblxuICBsZXQgcmVjIHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHksIE5vbmUsIEVtcHR5XG4gICAgfCBMZWFmIChrLCBkKSAtPlxuICAgICAgbGV0IGNtcCA9IGNvbXBhcmVfa2V5IHggayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBFbXB0eSwgU29tZSAoaywgZCksIEVtcHR5XG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gRW1wdHksIE5vbmUsIHRcbiAgICAgIGVsc2UgdCwgTm9uZSwgRW1wdHlcbiAgICB8IE5vZGUgKGwsIGssIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgeCBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIGwsIFNvbWUgKGssIGQpLCByXG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIG1heWJlLCBsciA9IHNwbGl0IGwgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgbGwsIG1heWJlLCBqb2luIGxyIGsgZCByIH5jb21wYXJlX2tleSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmwsIG1heWJlLCByciA9IHNwbGl0IHIgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgam9pbiBsIGsgZCBybCB+Y29tcGFyZV9rZXksIG1heWJlLCBycilcbiAgOztcblxuICBsZXQgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG8geCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsZWZ0LCBib3VuZGFyeV9vcHQsIHJpZ2h0ID0gc3BsaXQgdCB4IH5jb21wYXJlX2tleSBpblxuICAgIG1hdGNoIGJvdW5kYXJ5X29wdCB3aXRoXG4gICAgfCBOb25lIC0+IGxlZnQsIHJpZ2h0XG4gICAgfCBTb21lIChrZXksIGRhdGEpIC0+XG4gICAgICBsZXQgaW5zZXJ0X2ludG8gdHJlZSA9IGZzdCAoc2V0IHRyZWUgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5KSBpblxuICAgICAgKG1hdGNoIGludG8gd2l0aFxuICAgICAgIHwgYExlZnQgLT4gaW5zZXJ0X2ludG8gbGVmdCwgcmlnaHRcbiAgICAgICB8IGBSaWdodCAtPiBsZWZ0LCBpbnNlcnRfaW50byByaWdodClcbiAgOztcblxuICBsZXQgc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+KGxvd2VyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICAgICAgfih1cHBlcl9ib3VuZCA6ICdhIE1heWJlX2JvdW5kLnQpXG4gICAgICAgIH5jb21wYXJlX2tleVxuICAgID1cbiAgICBpZiBNYXliZV9ib3VuZC5ib3VuZHNfY3Jvc3NlZFxuICAgICAgICAgfmNvbXBhcmU6Y29tcGFyZV9rZXlcbiAgICAgICAgIH5sb3dlcjpsb3dlcl9ib3VuZFxuICAgICAgICAgfnVwcGVyOnVwcGVyX2JvdW5kXG4gICAgdGhlbiBlbXB0eSwgZW1wdHksIGVtcHR5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVmdCwgbWlkX2FuZF9yaWdodCA9XG4gICAgICAgIG1hdGNoIGxvd2VyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gZW1wdHksIHRcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxldCBtaWQsIHJpZ2h0ID1cbiAgICAgICAgbWF0Y2ggdXBwZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBtaWRfYW5kX3JpZ2h0LCBlbXB0eVxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPlxuICAgICAgICAgIHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZWZ0LCBtaWQsIHJpZ2h0KVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKHYsIGQpIC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBTb21lIGQgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkIGVsc2UgZmluZCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGRhdGEgPSBkYXRhIDo6IE9wdGlvbi52YWx1ZSAoZmluZCB0IGtleSB+Y29tcGFyZV9rZXkpIH5kZWZhdWx0OltdIGluXG4gICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB4IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGwgLT4gbFxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IGlmX25vdF9mb3VuZCBrZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIHJhaXNlIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJNYXAuZmluZF9leG46IG5vdCBmb3VuZFwiOyBzZXhwX29mX2tleSBrZXkgXSkpXG4gICAgaW5cbiAgICBsZXQgcmVjIGZpbmRfZXhuIHQgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIGQgZWxzZSBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBkIGVsc2UgZmluZF9leG4gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IHggfmNvbXBhcmVfa2V5ID0gT3B0aW9uLmlzX3NvbWUgKGZpbmQgdCB4IH5jb21wYXJlX2tleSlcblxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgZCkgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKEVtcHR5LCBrLCBkLCBfLCBfKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAobCwgXywgXywgXywgXykgLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIGQpIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChfLCBrLCBkLCBFbXB0eSwgXykgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKF8sIF8sIF8sIHIsIF8pIC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgKEVtcHR5LCBfLCBfLCByLCBfKSAtPiByXG4gICAgfCBOb2RlIChsLCB4LCBkLCByLCBfKSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHggZCByXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIG1heF9lbHQgbG93ZXJfcGFydCwgbWluX2VsdCB1cHBlcl9wYXJ0IHdpdGhcbiAgICB8IE5vbmUsIF8gLT4gYE9rIHVwcGVyX3BhcnRcbiAgICB8IF8sIE5vbmUgLT4gYE9rIGxvd2VyX3BhcnRcbiAgICB8IFNvbWUgKG1heF9sb3dlciwgXyksIFNvbWUgKG1pbl91cHBlciwgdikgd2hlbiBjb21wYXJlX2tleSBtYXhfbG93ZXIgbWluX3VwcGVyIDwgMCAtPlxuICAgICAgbGV0IHVwcGVyX3BhcnRfd2l0aG91dF9taW4gPSByZW1vdmVfbWluX2VsdCB1cHBlcl9wYXJ0IGluXG4gICAgICBgT2sgKGpvaW4gfmNvbXBhcmVfa2V5IGxvd2VyX3BhcnQgbWluX3VwcGVyIHYgdXBwZXJfcGFydF93aXRob3V0X21pbilcbiAgICB8IF8gLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgPVxuICAgICgqIFRoaXMgYXNzdW1lcyB0aGF0IG1pbiA8PSBtYXgsIHdoaWNoIGlzIGNoZWNrZWQgYnkgdGhlIG91dGVyIGZ1bmN0aW9uLiAqKVxuICAgIGxldCByZWMgZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbml0XG4gICAgICB8IExlYWYgKGssIGQpIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgbWluIDwgMCB8fCBjb21wYXJlX2tleSBrIG1heCA+IDBcbiAgICAgICAgdGhlbiAoKiBrIDwgbWluIHx8IGsgPiBtYXggKilcbiAgICAgICAgICBpbml0XG4gICAgICAgIGVsc2UgZiB+a2V5OmsgfmRhdGE6ZCBpbml0XG4gICAgICB8IE5vZGUgKGwsIGssIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjX21pbiA9IGNvbXBhcmVfa2V5IGsgbWluIGluXG4gICAgICAgIGlmIGNfbWluIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA8IG1pbiwgdGhlbiB0aGlzIG5vZGUgYW5kIGl0cyBsZWZ0IGJyYW5jaCBhcmUgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSBpZiBjX21pbiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPSBtaW4sIHRoZW4gdGhpcyBub2RlJ3MgbGVmdCBicmFuY2ggaXMgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdDooZiB+a2V5OmsgfmRhdGE6ZCBpbml0KSB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogayA+IG1pbiAqKVxuICAgICAgICAgIGxldCB6ID0gZ28gbCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgbGV0IGNfbWF4ID0gY29tcGFyZV9rZXkgayBtYXggaW5cbiAgICAgICAgICAoKiBpZiBrID4gbWF4LCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgaWYgY19tYXggPiAwXG4gICAgICAgICAgdGhlbiB6XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgeiA9IGYgfmtleTprIH5kYXRhOmQgeiBpblxuICAgICAgICAgICAgKCogaWYgayA9IG1heCwgdGhlbiB3ZSBmb2xkIGluIHRoaXMgb25lIGxhc3QgdmFsdWUgYW5kIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICAgIGlmIGNfbWF4ID0gMCB0aGVuIHogZWxzZSBnbyByIH5taW4gfm1heCB+aW5pdDp6IH5mIH5jb21wYXJlX2tleSkpXG4gICAgaW5cbiAgICBmdW4gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSBtaW4gbWF4IDw9IDAgdGhlbiBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgZWxzZSBpbml0XG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5yZXZcbiAgICAgIChmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgICAgdFxuICAgICAgICAgfm1pblxuICAgICAgICAgfm1heFxuICAgICAgICAgfmluaXQ6W11cbiAgICAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBsIC0+IChrZXksIGRhdGEpIDo6IGwpXG4gICAgICAgICB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IGNvbmNhdF91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBleGNlcHRpb24gUmVtb3ZlX25vX29wXG5cbiAgbGV0IHJlbW92ZSB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgcmVtb3ZlX2xvb3AgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wXG4gICAgICB8IExlYWYgKHYsIF8pIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IHggdiA9IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgbGVuZ3RoIC0gMVxuICAgICAgICBlbHNlIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBSZW1vdmVfbm9fb3BcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBjb25jYXRfdW5jaGVja2VkIGwgciwgbGVuZ3RoIC0gMVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSByZW1vdmVfbG9vcCBsIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gcmVtb3ZlX2xvb3AgciB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHRyeSByZW1vdmVfbG9vcCB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgUmVtb3ZlX25vX29wIC0+IHQsIGxlbmd0aFxuICA7O1xuXG4gICgqIFVzZSBleGNlcHRpb24gdG8gYXZvaWQgdHJlZS1yZWJ1aWxkIGluIG5vLW9wIGNhc2UgKilcbiAgZXhjZXB0aW9uIENoYW5nZV9ub19vcFxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgY2hhbmdlX2NvcmUgdCBrZXkgZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gcmFpc2UgQ2hhbmdlX25vX29wICgqIGVxdWl2YWxlbnQgdG8gcmV0dXJuaW5nOiBFbXB0eSAqKVxuICAgICAgICAgfCBTb21lIGRhdGEgLT4gTGVhZiAoa2V5LCBkYXRhKSwgbGVuZ3RoICsgMSlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHksIGxlbmd0aCAtIDFcbiAgICAgICAgICB8IFNvbWUgZCcgLT4gTGVhZiAodiwgZCcpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIEVtcHR5LCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBFbXB0eSB2IGQgciwgbGVuZ3RoKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXRfdW5jaGVja2VkIGwgciwgbGVuZ3RoIC0gMVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGUgKGwsIGtleSwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgbCBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSBjaGFuZ2VfY29yZSByIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHRyeSBjaGFuZ2VfY29yZSB0IGtleSBmIHdpdGhcbiAgICB8IENoYW5nZV9ub19vcCAtPiB0LCBsZW5ndGhcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIHVwZGF0ZV9jb3JlIHQga2V5IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgIGxldCBkYXRhID0gZiBOb25lIGluXG4gICAgICAgIExlYWYgKGtleSwgZGF0YSksIGxlbmd0aCArIDFcbiAgICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZCcgPSBmIChTb21lIGQpIGluXG4gICAgICAgICAgTGVhZiAodiwgZCcpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIEVtcHR5LCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSB1cGRhdGVfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBFbXB0eSB2IGQgciwgbGVuZ3RoKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBkYXRhID0gZiAoU29tZSBkKSBpblxuICAgICAgICAgIE5vZGUgKGwsIGtleSwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgbCBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSB1cGRhdGVfY29yZSByIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHVwZGF0ZV9jb3JlIHQga2V5IGZcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBjaGFuZ2UgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgfCBTb21lIChbXSB8IFsgXyBdKSAtPiBOb25lXG4gICAgICB8IFNvbWUgKF8gOjogKF8gOjogXyBhcyBub25fZW1wdHlfdGFpbCkpIC0+IFNvbWUgbm9uX2VtcHR5X3RhaWwpXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyX2tleXMgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAodiwgXykgLT4gZiB2XG4gICAgfCBOb2RlIChsLCB2LCBfLCByLCBfKSAtPlxuICAgICAgaXRlcl9rZXlzIH5mIGw7XG4gICAgICBmIHY7XG4gICAgICBpdGVyX2tleXMgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlciB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIChfLCBkKSAtPiBmIGRcbiAgICB8IE5vZGUgKGwsIF8sIGQsIHIsIF8pIC0+XG4gICAgICBpdGVyIH5mIGw7XG4gICAgICBmIGQ7XG4gICAgICBpdGVyIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBpdGVyaSB+ZiBsO1xuICAgICAgZiB+a2V5OnYgfmRhdGE6ZDtcbiAgICAgIGl0ZXJpIH5mIHJcbiAgOztcblxuICBsZXQgaXRlcmlfdW50aWwgPVxuICAgIGxldCByZWMgaXRlcmlfdW50aWxfbG9vcCB0IH5mIDogQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIChtYXRjaCBpdGVyaV91bnRpbF9sb29wIH5mIGwgd2l0aFxuICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgIHwgQ29udGludWUgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgICAgIHwgQ29udGludWUgLT4gaXRlcmlfdW50aWxfbG9vcCB+ZiByKSlcbiAgICBpblxuICAgIGZ1biB0IH5mIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQub2ZfY29udGludWVfb3Jfc3RvcCAoaXRlcmlfdW50aWxfbG9vcCB0IH5mKVxuICA7O1xuXG4gIGxldCByZWMgbWFwIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+IExlYWYgKHYsIGYgZClcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgbCcgPSBtYXAgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICBsZXQgcicgPSBtYXAgfmYgciBpblxuICAgICAgTm9kZSAobCcsIHYsIGQnLCByJywgaClcbiAgOztcblxuICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiAodiwgZCkgLT4gTGVhZiAodiwgZiB+a2V5OnYgfmRhdGE6ZClcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgbCcgPSBtYXBpIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IG1hcGkgfmYgciBpblxuICAgICAgTm9kZSAobCcsIHYsIGQnLCByJywgaClcbiAgOztcblxuICBsZXQgcmVjIGZvbGQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gZm9sZCB+ZiByIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfbG9vcCB0IH5hY2MgfmYgOiAoXywgXykgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2xvb3AgbCB+YWNjIH5mIHdpdGhcbiAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCBhY2Mgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIGZpbmFsIC0+IFN0b3AgZmluYWxcbiAgICAgICAgICAgIHwgQ29udGludWUgYWNjIC0+IGZvbGRfdW50aWxfbG9vcCByIH5hY2MgfmYpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9sb29wIHQgfmFjYzppbml0IH5mIHdpdGhcbiAgICB8IENvbnRpbnVlIGFjYyAtPiBmaW5pc2ggYWNjXG4gICAgfCBTdG9wIHN0b3AgLT4gc3RvcFxuICA7O1xuXG4gIGxldCByZWMgZm9sZF9yaWdodCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYga2V5IHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuXG4gIGxldCBmaWx0ZXIgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiBkYXRhIHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuICBsZXQgZmlsdGVyaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIH5rZXkgfmRhdGEgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIG1hdGNoIGYgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWNjdSwgbGVuZ3RoXG4gICAgICB8IFNvbWUgYiAtPiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhOmIgYWNjdSB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWNjdSwgbGVuZ3RoXG4gICAgICB8IFNvbWUgYiAtPiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhOmIgYWNjdSB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkXG4gICAgICB0XG4gICAgICB+aW5pdDooKEVtcHR5LCAwKSwgKEVtcHR5LCAwKSlcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSAocGFpcjEsIHBhaXIyKSAtPlxuICAgICAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IHggLT5cbiAgICAgICAgICBsZXQgdCwgbGVuZ3RoID0gcGFpcjEgaW5cbiAgICAgICAgICBzZXQgdCB+a2V5IH5kYXRhOnggfmNvbXBhcmVfa2V5IH5sZW5ndGgsIHBhaXIyXG4gICAgICAgIHwgU2Vjb25kIHkgLT5cbiAgICAgICAgICBsZXQgdCwgbGVuZ3RoID0gcGFpcjIgaW5cbiAgICAgICAgICBwYWlyMSwgc2V0IHQgfmtleSB+ZGF0YTp5IH5jb21wYXJlX2tleSB+bGVuZ3RoKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgaWYgZiB+a2V5IH5kYXRhIHRoZW4gRmlyc3QgZGF0YSBlbHNlIFNlY29uZCBkYXRhKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgICBpZiBmIGRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG4gIDs7XG5cbiAgbW9kdWxlIEVudW0gPSBzdHJ1Y3RcbiAgICB0eXBlIGluY3JlYXNpbmdcbiAgICB0eXBlIGRlY3JlYXNpbmdcblxuICAgIHR5cGUgKCdrLCAndiwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdrICogJ3YgKiAoJ2ssICd2KSB0cmVlICogKCdrLCAndiwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHQgKGUgOiAoXywgXywgaW5jcmVhc2luZykgdCkgOiAoXywgXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gY29ucyBsIChNb3JlICh2LCBkLCByLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb25zX3JpZ2h0IHQgKGUgOiAoXywgXywgZGVjcmVhc2luZykgdCkgOiAoXywgXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gY29uc19yaWdodCByIChNb3JlICh2LCBkLCBsLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3RyZWUgdHJlZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyB0cmVlIEVuZFxuICAgIGxldCBvZl90cmVlX3JpZ2h0IHRyZWUgOiAoXywgXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgdHJlZSBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgKHYsIGQpIC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBkLCBFbXB0eSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChfLCB2LCBfLCByLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gbG9vcCBsIChNb3JlICh2LCBkLCByLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBzdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgKHYsIGQpIC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBkLCBFbXB0eSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBfLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPiAwIC0+IGxvb3AgbCBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gbG9vcCByIChNb3JlICh2LCBkLCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2RhdGEgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgICBlbHNlIGlmIHBoeXNfZXF1YWwgcjEgcjJcbiAgICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgICAgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgZGF0YV9lcXVhbCB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IHRydWVcbiAgICAgICAgfCBFbmQsIF8gfCBfLCBFbmQgLT4gZmFsc2VcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGNvbXBhcmVfa2V5IHYxIHYyID0gMFxuICAgICAgICAgICYmIGRhdGFfZXF1YWwgZDEgZDJcbiAgICAgICAgICAmJiBpZiBwaHlzX2VxdWFsIHIxIHIyIHRoZW4gbG9vcCBlMSBlMiBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBmb2xkIH5pbml0IH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+IGluaXRcbiAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBsZXQgbmV4dCA9IGYgfmtleSB+ZGF0YSBpbml0IGluXG4gICAgICAgIGZvbGQgKGNvbnMgdHJlZSBlbnVtKSB+aW5pdDpuZXh0IH5mXG4gICAgOztcblxuICAgIGxldCBmb2xkMiBjb21wYXJlX2tleSB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgY3VyciA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gY3VyclxuICAgICAgICB8IEVuZCwgXyAtPlxuICAgICAgICAgIGZvbGQgdDIgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYFJpZ2h0IGRhdGEpIGFjYylcbiAgICAgICAgfCBfLCBFbmQgLT5cbiAgICAgICAgICBmb2xkIHQxIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBMZWZ0IGRhdGEpIGFjYylcbiAgICAgICAgfCBNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYEJvdGggKHYxLCB2MikpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYExlZnQgdjEpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyIG5leHQpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMiB+ZGF0YTooYFJpZ2h0IHYyKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIHQxIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDIgaW5pdFxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsID1cbiAgICAgIGxldCBzdGVwIHN0YXRlID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrZXksIGBSaWdodCBkYXRhKSwgKEVuZCwgY29ucyB0cmVlIGVudW0pKVxuICAgICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrZXksIGBMZWZ0IGRhdGEpLCAoY29ucyB0cmVlIGVudW0sIEVuZCkpXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICAgIHRoZW4gZW51bTEsIGVudW0yXG4gICAgICAgICAgICAgIGVsc2UgY29ucyB0cmVlMSBlbnVtMSwgY29ucyB0cmVlMiBlbnVtMlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIGRhdGFfZXF1YWwgdjEgdjJcbiAgICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Ta2lwIG5leHRfc3RhdGVcbiAgICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsxLCBgVW5lcXVhbCAodjEsIHYyKSksIG5leHRfc3RhdGUpKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazEsIGBMZWZ0IHYxKSwgKGNvbnMgdHJlZTEgZW51bTEsIHJpZ2h0KSlcbiAgICAgICAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMiwgYFJpZ2h0IHYyKSwgKGxlZnQsIGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl90cmVlIHQxLCBvZl90cmVlIHQyKSB+ZjpzdGVwXG4gICAgOztcblxuICAgIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICAgIGxldCByZWMgbG9vcCBsZWZ0IHJpZ2h0IGFjYyA9XG4gICAgICAgIG1hdGNoIGxlZnQsIHJpZ2h0IHdpdGhcbiAgICAgICAgfCBFbmQsIGVudW0gLT4gZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgZW51bSwgRW5kIC0+IGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBpZiBkYXRhX2VxdWFsIHYxIHYyIHRoZW4gYWNjIGVsc2UgZiBhY2MgKGsxLCBgVW5lcXVhbCAodjEsIHYyKSkgaW5cbiAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgIHRoZW4gbG9vcCBlbnVtMSBlbnVtMiBhY2NcbiAgICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIGFjYylcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgazEgdjEgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHJpZ2h0IGFjYylcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsyIHYyIGluXG4gICAgICAgICAgICBsb29wIGxlZnQgKGNvbnMgdHJlZTIgZW51bTIpIGFjYylcbiAgICAgIGluXG4gICAgICBsb29wIChvZl90cmVlIHQxKSAob2ZfdHJlZSB0MikgaW5pdFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrLCB2KSwgRW51bS5jb25zIHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWUgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoaywgdiksIEVudW0uY29uc19yaWdodCB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlX3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nX2tleSlcbiAgICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/a2V5c19sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfa2V5IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIChrZXksIGRhdGEpIC0+IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXlcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2xlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MilcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBFbnVtLmVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKVxuICA7O1xuXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDJcbiAgICAgIGNvbXBhcmVfa2V5XG4gICAgICAoRW51bS5vZl90cmVlIHQxKVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MilcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKCkgLT4gZiB+a2V5IH5kYXRhKVxuICA7O1xuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDIgY29tcGFyZV9rZXkgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MikgfmYgfmluaXRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAoKiBbRW51bS5mb2xkX2RpZmZzXSBpcyBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGlzIGNvbnNpZGVyYWJseVxuICAgICAgIHNsb3dlciwgYXMgd2UgaGF2ZSB0byBhbGxvY2F0ZSBxdWl0ZSBhIGxvdCBvZiBzdGF0ZSB0byB0cmFjayBlbnVtZXJhdGlvbiBvZiBhIHRyZWUuXG4gICAgICAgQXZvaWQgaWYgd2UgY2FuLlxuICAgICopXG4gICAgbGV0IHNsb3cgeCB5IH5pbml0ID0gRW51bS5mb2xkX3N5bW1ldHJpY19kaWZmIHggeSB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmYgfmluaXQgaW5cbiAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgbGV0IGRlbHRhIGFjYyBrIHYgdicgPSBpZiBkYXRhX2VxdWFsIHYgdicgdGhlbiBhY2MgZWxzZSBmIGFjYyAoaywgYFVuZXF1YWwgKHYsIHYnKSkgaW5cbiAgICAoKiBJZiB0d28gdHJlZXMgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXQgdGhlIHJvb3QgKGFuZCB0aGUgc2FtZSBrZXksIGlmIHRoZXkncmVcbiAgICAgICBbTm9kZV1zKSB3ZSBjYW4gdHJpdmlhbGx5IGRpZmYgZWFjaCBzdWJwYXJ0IGluIG9idmlvdXMgd2F5cy4gKilcbiAgICBsZXQgcmVjIGxvb3AgdCB0JyBhY2MgPVxuICAgICAgaWYgcGh5c19lcXVhbCB0IHQnXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQsIHQnIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgbmV3X3ZhbHMgLT5cbiAgICAgICAgICBmb2xkIG5ld192YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgb2xkX3ZhbHMsIEVtcHR5IC0+XG4gICAgICAgICAgZm9sZCBvbGRfdmFscyB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IExlYWYgKGssIHYpLCBMZWFmIChrJywgdicpIC0+XG4gICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IGsgaycgd2l0aFxuICAgICAgICAgICB8IHggd2hlbiB4ID0gMCAtPiBkZWx0YSBhY2MgayB2IHYnXG4gICAgICAgICAgIHwgeCB3aGVuIHggPCAwIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgayB2IGluXG4gICAgICAgICAgICAgYWRkIGFjYyBrJyB2J1xuICAgICAgICAgICB8IF8gKCogd2hlbiB4ID4gMCAqKSAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsnIHYnIGluXG4gICAgICAgICAgICAgcmVtb3ZlIGFjYyBrIHYpXG4gICAgICAgIHwgTm9kZSAobCwgaywgdiwgciwgXyksIE5vZGUgKGwnLCBrJywgdicsIHInLCBfKSB3aGVuIGNvbXBhcmVfa2V5IGsgaycgPSAwIC0+XG4gICAgICAgICAgbGV0IGFjYyA9IGxvb3AgbCBsJyBhY2MgaW5cbiAgICAgICAgICBsZXQgYWNjID0gZGVsdGEgYWNjIGsgdiB2JyBpblxuICAgICAgICAgIGxvb3AgciByJyBhY2NcbiAgICAgICAgKCogT3VyIHJvb3RzIGFyZW4ndCB0aGUgc2FtZSBrZXkuIEZhbGxiYWNrIHRvIHRoZSBzbG93IG1vZGUuIFRyZWVzIHdpdGggc21hbGxcbiAgICAgICAgICAgZGlmZnMgd2lsbCBvbmx5IGRvIHRoaXMgb24gdmVyeSBzbWFsbCBwYXJ0cyBvZiB0aGUgdHJlZSAoaG9wZWZ1bGx5IC0gaWYgdGhlXG4gICAgICAgICAgIG92ZXJhbGwgcm9vdCBpcyByZWJhbGFuY2VkLCB3ZSdsbCBlYXQgdGhlIHdob2xlIGNvc3QsIHVuZm9ydHVuYXRlbHkuKSAqKVxuICAgICAgICB8IE5vZGUgXywgTm9kZSBfIHwgTm9kZSBfLCBMZWFmIF8gfCBMZWFmIF8sIE5vZGUgXyAtPiBzbG93IHQgdCcgfmluaXQ6YWNjKVxuICAgIGluXG4gICAgbG9vcCB0MSB0MiBpbml0XG4gIDs7XG5cbiAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKGwsIF8sIF8sIHIsIF8pIC0+IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgc3RhdGUgLT4gaGFzaF9mb2xkX2RhdGEgKGhhc2hfZm9sZF9rZXkgc3RhdGUga2V5KSBkYXRhKVxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpfIGxpc3QgLT4ga2V5IDo6IGxpc3QpIHQgfmluaXQ6W11cbiAgbGV0IGRhdGEgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIHQgfmluaXQ6W11cblxuICBtb2R1bGUgdHlwZSBGb2xkYWJsZSA9IHNpZ1xuICAgIHZhbCBuYW1lIDogc3RyaW5nXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiKSAtPiAnYlxuICBlbmRcblxuICBtb2R1bGUgT2ZfZm9sZGFibGUgKE0gOiBGb2xkYWJsZSkgPSBzdHJ1Y3RcbiAgICBsZXQgb2ZfZm9sZGFibGVfZm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAoYWNjdW0sIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgbGV0IHByZXZfZGF0YSA9XG4gICAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5pdFxuICAgICAgICAgIHwgU29tZSBwcmV2IC0+IHByZXZcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGRhdGEgPSBmIHByZXZfZGF0YSBkYXRhIGluXG4gICAgICAgIHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfcmVkdWNlIGZvbGRhYmxlIH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIChhY2N1bSwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgbmV3X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YVxuICAgICAgICBpblxuICAgICAgICBzZXQgYWNjdW0gfmxlbmd0aCB+a2V5IH5kYXRhOm5ld19kYXRhIH5jb21wYXJlX2tleSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleSA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IG1hcCA9XG4gICAgICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAodCwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbGV0ICgoXywgbGVuZ3RoJykgYXMgYWNjKSA9IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgdGhlbiByLnJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSBlbHNlIGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgYE9rIG1hcClcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX29yX2Vycm9yIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IFJlc3VsdC5PayB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBPcl9lcnJvci5lcnJvclxuICAgICAgICAgIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX29yX2Vycm9yOiBkdXBsaWNhdGUga2V5XCIpXG4gICAgICAgICAga2V5XG4gICAgICAgICAgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX2V4biBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBFcnJvci5jcmVhdGUgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfZXhuOiBkdXBsaWNhdGUga2V5XCIpIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgICB8PiBFcnJvci5yYWlzZVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBPZl9hbGlzdCA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICAgIGxldCBuYW1lID0gXCJhbGlzdFwiXG5cbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IGZvbGQgPSBMaXN0LmZvbGRcbiAgICBlbmQpXG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX2FsaXN0ID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX2FsaXN0X2V4biA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2V4blxuXG4gICgqIFJldmVyc2UgdGhlIGlucHV0LCB0aGVuIGZvbGQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBUaGUgcmVzdWx0aW5nIG1hcCB1c2VzIHRoZSBmaXJzdFxuICAgICBpbnN0YW5jZSBvZiBlYWNoIGtleSBmcm9tIHRoZSBpbnB1dCBsaXN0LiBUaGUgcmVsYXRpdmUgb3JkZXJpbmcgb2YgZWxlbWVudHMgaW4gZWFjaFxuICAgICBvdXRwdXQgbGlzdCBpcyB0aGUgc2FtZSBhcyBpbiB0aGUgaW5wdXQgbGlzdC4gKilcbiAgbGV0IG9mX2ZvbGRhYmxlX211bHRpIGZvbGRhYmxlIH5mb2xkIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFsaXN0ID0gZm9sZCBmb2xkYWJsZSB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIGluXG4gICAgb2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXkgPVxuICAgIG9mX2ZvbGRhYmxlX211bHRpIGFsaXN0IH5mb2xkOkxpc3QuZm9sZCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBtb2R1bGUgT2Zfc2VxdWVuY2UgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwic2VxdWVuY2VcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBTZXF1ZW5jZS50XG5cbiAgICAgIGxldCBmb2xkID0gU2VxdWVuY2UuZm9sZFxuICAgIGVuZClcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2Zfc2VxdWVuY2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZVxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZXhuXG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHNlcXVlbmNlIH5jb21wYXJlX2tleSA9XG4gICAgb2ZfZm9sZGFibGVfbXVsdGkgc2VxdWVuY2UgfmZvbGQ6U2VxdWVuY2UuZm9sZCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgZm9yX2FsbCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgbm90IChmIGRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSlcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBub3QgKGYgfmtleSB+ZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIGYgZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gaWYgZiBkYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbiAgOztcblxuICBsZXQgdG9fYWxpc3QgPyhrZXlfb3JkZXIgPSBgSW5jcmVhc2luZykgdCA9XG4gICAgbWF0Y2gga2V5X29yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+IGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgeCAtPiAoa2V5LCBkYXRhKSA6OiB4KVxuICAgIHwgYERlY3JlYXNpbmcgLT4gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGVsdHMgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOihsZW5ndGggdDEgKyBsZW5ndGggdDIpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIyIHQxIHQyIH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXkgfmRhdGE6dmFsdWVzIC0+XG4gICAgICBtYXRjaCBmIH5rZXkgdmFsdWVzIHdpdGhcbiAgICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgICBVbmlmb3JtX2FycmF5LnNldCBlbHRzICFpIChrZXksIHZhbHVlKTtcbiAgICAgICAgaW5jciBpXG4gICAgICB8IE5vbmUgLT4gKCkpO1xuICAgIGxldCBsZW4gPSAhaSBpblxuICAgIGxldCBnZXQgaSA9IFVuaWZvcm1fYXJyYXkuZ2V0IGVsdHMgaSBpblxuICAgIGxldCB0cmVlID0gb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZjpnZXQgaW5cbiAgICB0cmVlLCBsZW5cbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkID1cbiAgICBsZXQgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoX2xhcmdlIHRfbGFyZ2UgdF9zbWFsbCB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgZm9sZCB0X3NtYWxsIH5pbml0Oih0X2xhcmdlLCBsZW5ndGhfbGFyZ2UpIH5mOihmdW4gfmtleSB+ZGF0YTpkYXRhJyAodCwgbGVuZ3RoKSAtPlxuICAgICAgICB1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGEnXG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gY2FsbCBjb21iaW5lIH5rZXkgZGF0YSBkYXRhJykpXG4gICAgaW5cbiAgICBsZXQgY2FsbCBmIH5rZXkgeCB5ID0gZiB+a2V5IHggeSBpblxuICAgIGxldCBzd2FwIGYgfmtleSB4IHkgPSBmIH5rZXkgeSB4IGluXG4gICAgZnVuIHQxIHQyIH5sZW5ndGgxIH5sZW5ndGgyIH5jb21iaW5lIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgbGVuZ3RoMiA8PSBsZW5ndGgxXG4gICAgICB0aGVuIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDEgdDEgdDIgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDIgdDIgdDEgfmNhbGw6c3dhcCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBtb2R1bGUgQ2xvc2VzdF9rZXlfaW1wbCA9IHN0cnVjdFxuICAgICgqIFttYXJrZXJdIGFuZCBbcmVwYWNrYWdlXSBhbGxvdyB1cyB0byBjcmVhdGUgXCJsb2dpY2FsXCIgb3B0aW9ucyB3aXRob3V0IGFjdHVhbGx5XG4gICAgICAgYWxsb2NhdGluZyBhbnkgb3B0aW9ucy4gUGFzc2luZyBbRm91bmQga2V5IHZhbHVlXSB0byBhIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICBwYXNzaW5nIFtTb21lIChrZXksIHZhbHVlKV07IHBhc3NpbmcgW01pc3NpbmcgKCkgKCldIGlzIGVxdWl2YWxlbnQgdG8gcGFzc2luZ1xuICAgICAgIFtOb25lXS4gKilcbiAgICB0eXBlICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXIgPVxuICAgICAgfCBNaXNzaW5nIDogKCdrLCAndiwgdW5pdCwgdW5pdCkgbWFya2VyXG4gICAgICB8IEZvdW5kIDogKCdrLCAndiwgJ2ssICd2KSBtYXJrZXJcblxuICAgIGxldCByZXBhY2thZ2VcbiAgICAgICAgICAodHlwZSBrIHYga19vcHQgdl9vcHQpXG4gICAgICAgICAgKG1hcmtlciA6IChrLCB2LCBrX29wdCwgdl9vcHQpIG1hcmtlcilcbiAgICAgICAgICAoayA6IGtfb3B0KVxuICAgICAgICAgICh2IDogdl9vcHQpXG4gICAgICA6IChrICogdikgb3B0aW9uXG4gICAgICA9XG4gICAgICBtYXRjaCBtYXJrZXIgd2l0aFxuICAgICAgfCBNaXNzaW5nIC0+IE5vbmVcbiAgICAgIHwgRm91bmQgLT4gU29tZSAoaywgdilcbiAgICA7O1xuXG4gICAgKCogVGhlIHR5cGUgc2lnbmF0dXJlIGlzIGV4cGxpY2l0IGhlcmUgdG8gYWxsb3cgcG9seW1vcnBoaWMgcmVjdXJzaW9uLiAqKVxuICAgIGxldCByZWMgbG9vcCA6XG4gICAgICAnayAndiAna19vcHQgJ3Zfb3B0LlxuICAgICAgKCdrLCAndikgdHJlZVxuICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgLT4gJ2tcbiAgICAgIC0+IGNvbXBhcmVfa2V5OignayAtPiAnayAtPiBpbnQpXG4gICAgICAtPiAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyXG4gICAgICAtPiAna19vcHRcbiAgICAgIC0+ICd2X29wdFxuICAgICAgLT4gKCdrICogJ3YpIG9wdGlvblxuICAgICAgPVxuICAgICAgZnVuIHQgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgLT5cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgfCBMZWFmIChrJywgdicpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgICAgaWYgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gLT4gYyA+PSAwXG4gICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT4gYyA+IDBcbiAgICAgICAgICAgIHwgYExlc3Nfb3JfZXF1YWxfdG8gLT4gYyA8PSAwXG4gICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT4gYyA8IDBcbiAgICAgICAgICB0aGVuIFNvbWUgKGsnLCB2JylcbiAgICAgICAgICBlbHNlIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgIHwgTm9kZSAobCwgaycsIHYnLCByLCBfKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICAgIGlmIGMgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAoKiBUaGlzIGlzIGEgYmFzZSBjYXNlIChubyByZWN1cnNpdmUgY2FsbCkuICopXG4gICAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IFNvbWUgKGsnLCB2JylcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBpc19lbXB0eSByIHRoZW4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgZWxzZSBtaW5fZWx0IHJcbiAgICAgICAgICAgIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBpc19lbXB0eSBsIHRoZW4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgZWxzZSBtYXhfZWx0IGwpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAoKiBXZSBhcmUgZ3VhcmFudGVlZCBoZXJlIHRoYXQgaycgPD4gay4gKilcbiAgICAgICAgICAgICgqIFRoaXMgaXMgdGhlIG9ubHkgcmVjdXJzaXZlIGNhc2UuICopXG4gICAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgYyA+IDBcbiAgICAgICAgICAgICAgdGhlbiBsb29wIGwgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBjIDwgMFxuICAgICAgICAgICAgICB0aGVuIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgICAgZWxzZSBsb29wIGwgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUpXG4gICAgOztcblxuICAgIGxldCBjbG9zZXN0X2tleSB0IGRpciBrIH5jb21wYXJlX2tleSA9IGxvb3AgdCBkaXIgayB+Y29tcGFyZV9rZXkgTWlzc2luZyAoKSAoKVxuICBlbmRcblxuICBsZXQgY2xvc2VzdF9rZXkgPSBDbG9zZXN0X2tleV9pbXBsLmNsb3Nlc3Rfa2V5XG5cbiAgbGV0IHJlYyByYW5rIHQgayB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaycsIF8pIC0+IGlmIGNvbXBhcmVfa2V5IGsnIGsgPSAwIHRoZW4gU29tZSAwIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaycsIF8sIHIsIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIFNvbWUgKGxlbmd0aCBsKVxuICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgdGhlbiByYW5rIGwgayB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgT3B0aW9uLm1hcCAocmFuayByIGsgfmNvbXBhcmVfa2V5KSB+ZjooZnVuIHJhbmsgLT4gcmFuayArIDEgKyBsZW5ndGggbClcbiAgOztcblxuICAoKiB0aGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtTZXF1ZW5jZV0gaW50ZXJmYWNlIGJ1dCB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgIGFsbG9jYXRlcyBvbmx5IDIgd29yZHMgYW5kIGRvZXNuJ3QgcmVxdWlyZSB3cml0ZS1iYXJyaWVyICopXG4gIGxldCByZWMgbnRoJyBudW1fdG9fc2VhcmNoID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+XG4gICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgIGVsc2UgKFxuICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgIE5vbmUpXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgKG1hdGNoIG50aCcgbnVtX3RvX3NlYXJjaCBsIHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHNvbWVcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIGlmICFudW1fdG9fc2VhcmNoID0gMFxuICAgICAgICAgdGhlbiBTb21lIChrLCB2KVxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIGRlY3IgbnVtX3RvX3NlYXJjaDtcbiAgICAgICAgICAgbnRoJyBudW1fdG9fc2VhcmNoIHIpKVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gbnRoJyAocmVmIG4pIHRcblxuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyByIH5mXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8IDApXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID4gMClcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IH5rZXkgfmRhdGEgPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB+a2V5IH5kYXRhID0gbm90IChpc19sZWZ0IH5rZXkgfmRhdGEpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRdIGZpbmRzIHRoZSBrZXkgaW4gW3RdIHdoaWNoIHNhdGlzZmllcyBbbWF5YmVfYm91bmRdXG4gICAgIGFuZCB0aGUgcmVsZXZhbnQgb25lIG9mIFtpZl9leGNsdXNpdmVdIG9yIFtpZl9pbmNsdXNpdmVdLCBhcyBqdWRnZWQgYnkgW2NvbXBhcmVdLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSB+aWZfZXhjbHVzaXZlIH5pZl9pbmNsdXNpdmUgPVxuICAgIGxldCBmaW5kX2JvdW5kIHQgaG93IGJvdW5kIH5jb21wYXJlIDogXyBNYXliZV9ib3VuZC50IG9wdGlvbiA9XG4gICAgICBtYXRjaCBiaW5hcnlfc2VhcmNoIHQgaG93IGJvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgIHwgU29tZSAoYm91bmQsIF8pIC0+IFNvbWUgKEluY2wgYm91bmQpXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggKG1heWJlX2JvdW5kIDogXyBNYXliZV9ib3VuZC50KSB3aXRoXG4gICAgfCBFeGNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9leGNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IEluY2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2luY2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgVW5ib3VuZGVkIC0+IFNvbWUgVW5ib3VuZGVkXG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kc10gZmluZHMgdGhlIChub3QgbmVjZXNzYXJpbHkgZGlzdGluY3QpIGtleXMgaW4gW3RdXG4gICAgIHdoaWNoIG1vc3QgY2xvc2VseSBhcHByb2FjaCAoYnV0IGRvIG5vdCBjcm9zcykgW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXSwgYXNcbiAgICAganVkZ2VkIGJ5IFtjb21wYXJlXS4gSXQgcmV0dXJucyBbTm9uZV0gaWYgbm8ga2V5cyBpbiBbdF0gYXJlIHdpdGhpbiB0aGF0IHJhbmdlLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGZpbmRfbG93ZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIGxldCBmaW5kX3VwcGVyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbWF0Y2ggZmluZF9sb3dlcl9ib3VuZCB0IGxvd2VyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBsb3dlcl9ib3VuZCAtPlxuICAgICAgKG1hdGNoIGZpbmRfdXBwZXJfYm91bmQgdCB1cHBlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICB8IFNvbWUgdXBwZXJfYm91bmQgLT4gU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSlcbiAgOztcblxuICB0eXBlICgnaywgJ3YpIGFjYyA9XG4gICAgeyBtdXRhYmxlIGJhZF9rZXkgOiAnayBvcHRpb25cbiAgICA7IG11dGFibGUgbWFwX2xlbmd0aCA6ICgnaywgJ3YpIHQgKiBpbnRcbiAgICB9XG5cbiAgbGV0IG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhY2MgPSB7IGJhZF9rZXkgPSBOb25lOyBtYXBfbGVuZ3RoID0gZW1wdHksIDAgfSBpblxuICAgIGl0ZXJpIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgbGV0IG1hcCwgbGVuZ3RoID0gYWNjLm1hcF9sZW5ndGggaW5cbiAgICAgIGxldCAoKF8sIGxlbmd0aCcpIGFzIHBhaXIpID0gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBtYXAgfmNvbXBhcmVfa2V5IGluXG4gICAgICBpZiBsZW5ndGggPSBsZW5ndGgnICYmIE9wdGlvbi5pc19ub25lIGFjYy5iYWRfa2V5XG4gICAgICB0aGVuIGFjYy5iYWRfa2V5IDwtIFNvbWUga2V5XG4gICAgICBlbHNlIGFjYy5tYXBfbGVuZ3RoIDwtIHBhaXIpO1xuICAgIG1hdGNoIGFjYy5iYWRfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gYE9rIGFjYy5tYXBfbGVuZ3RoXG4gICAgfCBTb21lIGtleSAtPiBgRHVwbGljYXRlX2tleSBrZXlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIG1hdGNoIG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm9mX2l0ZXJpX2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwIHNleHAgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBsZXQgYWxpc3QgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwKSBzZXhwIGluXG4gICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgbWF0Y2ggb2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAgICgqIGZpbmQgdGhlIHNleHAgb2YgYSBkdXBsaWNhdGUga2V5LCBzbyB0aGUgZXJyb3IgaXMgbmFycm93ZWQgdG8gYSBrZXkgYW5kIG5vdFxuICAgICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICAgIGxldCBmb3VuZF9maXJzdF9rID0gcmVmIGZhbHNlIGluXG4gICAgICBMaXN0Lml0ZXIyX29rIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBrMiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiTWFwLnRfb2Zfc2V4cF9kaXJlY3Q6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgICAgZWxzZSBmb3VuZF9maXJzdF9rIDo9IHRydWUpO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgIGxldCBmIH5rZXkgfmRhdGEgYWNjID0gU2V4cC5MaXN0IFsgc2V4cF9vZl9rZXkga2V5OyBzZXhwX29mX3ZhbHVlIGRhdGEgXSA6OiBhY2MgaW5cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgfmYgdCB+aW5pdDpbXSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBsZXQgb2tzLCAoZXJyb3JfdHJlZSwgXykgPSBwYXJ0aXRpb25fbWFwIHQgfmNvbXBhcmVfa2V5IH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgICBpZiBpc19lbXB0eSBlcnJvcl90cmVlXG4gICAgdGhlbiBPayBva3NcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yX3MgKHNleHBfb2ZfdCBzZXhwX29mX2tleSBFcnJvci5zZXhwX29mX3QgZXJyb3JfdHJlZSlcbiAgOztcblxuICBsZXQgbWFwX2tleXNcbiAgICAgICAgdDFcbiAgICAgICAgfmZcbiAgICAgICAgfmNvbXBhcmF0b3I6KHsgY29tcGFyZSA9IGNvbXBhcmVfa2V5OyBzZXhwX29mX3QgPSBzZXhwX29mX2tleSB9IDogXyBDb21wYXJhdG9yLnQpXG4gICAgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgYE9rXG4gICAgICAgIChmb2xkIHQxIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biB+a2V5IH5kYXRhICh0MiwgbGVuZ3RoKSAtPlxuICAgICAgICAgICBsZXQga2V5ID0gZiBrZXkgaW5cbiAgICAgICAgICAgdHJ5IGFkZF9leG5faW50ZXJuYWwgdDIgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgd2l0aFxuICAgICAgICAgICB8IER1cGxpY2F0ZSAtPiByZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkpKSlcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIHQgfmYgfmNvbXBhcmF0b3IgPVxuICAgIG1hdGNoIG1hcF9rZXlzIHQgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHJlc3VsdCAtPiByZXN1bHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgbGV0IHNleHBfb2Zfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdCBpblxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiTWFwLm1hcF9rZXlzX2V4bjogZHVwbGljYXRlIGtleVwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5lbmRcblxudHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdrLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICgnaywgJ3YpIFRyZWUwLnRcbiAgOyBsZW5ndGggOiBpbnRcbiAgfVxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuXG5sZXQgY29tcGFyZV9rZXkgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gKHRyZWUsIGxlbmd0aCkgPVxuICB7IHRyZWU7IGxlbmd0aDsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgbGlrZTIgeCAoeSwgeikgPSBsaWtlIHggeSwgbGlrZSB4IHpcblxubGV0IGxpa2VfbWF5YmVfbm9fb3AgKHsgdHJlZSA9IG9sZF90cmVlOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpICh0cmVlLCBsZW5ndGgpXG4gID1cbiAgaWYgcGh5c19lcXVhbCBvbGRfdHJlZSB0cmVlIHRoZW4gb2xkX3QgZWxzZSB7IHRyZWU7IGxlbmd0aDsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgd2l0aF9zYW1lX2xlbmd0aCB7IHRyZWUgPSBfOyBjb21wYXJhdG9yOyBsZW5ndGggfSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxubGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4oKiBFeHBvc2luZyB0aGlzIGZ1bmN0aW9uIHdvdWxkIG1ha2UgaXQgdmVyeSBlYXN5IGZvciB0aGUgaW52YXJpYW50c1xuICAgb2YgdGhpcyBtb2R1bGUgdG8gYmUgYnJva2VuLiAqKVxubGV0IG9mX3RyZWVfdW5zYWZlIH5jb21wYXJhdG9yIH5sZW5ndGggdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcblxuICBsZXQgaW52YXJpYW50cyB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQudHJlZSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpICYmIFRyZWUwLmxlbmd0aCB0LnRyZWUgPSB0Lmxlbmd0aFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5cbiAgbGV0IHNldCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2UgdCAoVHJlZTAuc2V0IHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuX2ludGVybmFsXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gICAgbWF0Y2ggYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgcmVzdWx0IC0+IGBPayByZXN1bHRcbiAgICB8IGV4Y2VwdGlvbiBEdXBsaWNhdGUgLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5ID1cbiAgICBsaWtlIHQgKFRyZWUwLnJlbW92ZV9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IGtleSA9IFRyZWUwLmZpbmRfbXVsdGkgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiA9XG4gICAgbGlrZSB0IChUcmVlMC5jaGFuZ2UgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiA9XG4gICAgbGlrZSB0IChUcmVlMC51cGRhdGUgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdC50cmVlXG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgdCBrZXkgPSBUcmVlMC5maW5kIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCByZW1vdmUgdCBrZXkgPVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIHRcbiAgICAgIChUcmVlMC5yZW1vdmUgdC50cmVlIGtleSB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IG1lbSB0IGtleSA9IFRyZWUwLm1lbSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQudHJlZSB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIHQxIHQyIH5mID0gVHJlZTAuaXRlcjIgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIGxldCBtYXAgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwIHQudHJlZSB+ZilcbiAgbGV0IG1hcGkgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwaSB0LnRyZWUgfmYpXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmYgfmluaXRcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MS50cmVlIHQyLnRyZWUgfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX2tleXMgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyaSB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyX21hcCB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX21hcGkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uaV90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+ZjoobGlrZSB0KVxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfZGF0YSB0MSB0MiA9IFRyZWUwLmVxdWFsIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICBsZXQga2V5cyB0ID0gVHJlZTAua2V5cyB0LnRyZWVcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdC50cmVlXG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHQudHJlZVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpIH5kYXRhX2VxdWFsXG4gIDs7XG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgIHQxLnRyZWVcbiAgICAgIHQyLnRyZWVcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mID1cbiAgICBsaWtlIHQxIChUcmVlMC5tZXJnZSB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCB0MSB0MiB+Y29tYmluZSA9XG4gICAgKCogVGhpcyBpcyBvbmx5IGEgbm8tb3AgaW4gdGhlIGNhc2Ugd2hlcmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBtYXBzIGlzIGVtcHR5LiAqKVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIChpZiB0Mi5sZW5ndGggPD0gdDEubGVuZ3RoIHRoZW4gdDEgZWxzZSB0MilcbiAgICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICAgIHQxLnRyZWVcbiAgICAgICAgIHQyLnRyZWVcbiAgICAgICAgIH5sZW5ndGgxOnQxLmxlbmd0aFxuICAgICAgICAgfmxlbmd0aDI6dDIubGVuZ3RoXG4gICAgICAgICB+Y29tYmluZVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQudHJlZSB+ZlxuXG4gIGxldCBzcGxpdCB0IGsgPVxuICAgIGxldCBsLCBtYXliZSwgciA9IFRyZWUwLnNwbGl0IHQudHJlZSBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgaW5cbiAgICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgdCBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgYm90aF9sZW4gPSBpZiBPcHRpb24uaXNfc29tZSBtYXliZSB0aGVuIHQubGVuZ3RoIC0gMSBlbHNlIHQubGVuZ3RoIGluXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG1heWJlLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggciksIG1heWJlLCByKVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBsZWZ0LCBtaWQsIHJpZ2h0ID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlIHQudHJlZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgb3V0ZXJfam9pbmVkX2hlaWdodCA9XG4gICAgICBsZXQgaF9sID0gVHJlZTAuaGVpZ2h0IGxlZnRcbiAgICAgIGFuZCBoX3IgPSBUcmVlMC5oZWlnaHQgcmlnaHQgaW5cbiAgICAgIGlmIGhfbCA9IGhfciB0aGVuIGhfbCArIDEgZWxzZSBtYXggaF9sIGhfclxuICAgIGluXG4gICAgaWYgb3V0ZXJfam9pbmVkX2hlaWdodCA8IFRyZWUwLmhlaWdodCBtaWRcbiAgICB0aGVuIChcbiAgICAgIGxldCBtaWRfbGVuZ3RoID0gdC5sZW5ndGggLSAoVHJlZTAubGVuZ3RoIGxlZnQgKyBUcmVlMC5sZW5ndGggcmlnaHQpIGluXG4gICAgICBvZl90cmVlX3Vuc2FmZSBtaWQgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgdCkgfmxlbmd0aDptaWRfbGVuZ3RoKVxuICAgIGVsc2Ugb2ZfdHJlZSBtaWQgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgdClcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAuYXBwZW5kXG4gICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgbG93ZXJfcGFydClcbiAgICAgICAgfmxvd2VyX3BhcnQ6bG93ZXJfcGFydC50cmVlXG4gICAgICAgIH51cHBlcl9wYXJ0OnVwcGVyX3BhcnQudHJlZVxuICAgIHdpdGhcbiAgICB8IGBPayB0cmVlIC0+XG4gICAgICBgT2tcbiAgICAgICAgKG9mX3RyZWVfdW5zYWZlXG4gICAgICAgICAgIHRyZWVcbiAgICAgICAgICAgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgbG93ZXJfcGFydClcbiAgICAgICAgICAgfmxlbmd0aDoobG93ZXJfcGFydC5sZW5ndGggKyB1cHBlcl9wYXJ0Lmxlbmd0aCkpXG4gICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiBgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc1xuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmUgdC50cmVlIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0LnRyZWUgfm1pbiB+bWF4IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0LnRyZWUgZGlyIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdC50cmVlIG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgdCBrZXkgPSBUcmVlMC5yYW5rIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICA/a2V5c19sZXNzX29yX2VxdWFsX3RvXG4gICAgICB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0LnRyZWUgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQudHJlZSB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIFRyZWUwLmhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0LnRyZWUgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IGxpa2VfbWF5YmVfbm9fb3AgdCAoRW1wdHksIDApXG4gIDs7XG5lbmRcblxuKCogWzBdIGlzIHVzZWQgYXMgdGhlIFtsZW5ndGhdIGFyZ3VtZW50IGV2ZXJ5d2hlcmUgaW4gdGhpcyBtb2R1bGUsIHNpbmNlIHRyZWVzIGRvIG5vdFxuICAgaGF2ZSB0aGVpciBsZW5ndGhzIHN0b3JlZCBhdCB0aGUgcm9vdCwgdW5saWtlIG1hcHMuIFRoZSB2YWx1ZXMgYXJlIGRpc2NhcmRlZCBhbHdheXMuICopXG5tb2R1bGUgVHJlZSA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID0gKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWVcblxuICBsZXQgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA9IFRyZWUwLmVtcHR5XG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvcjpfID0gZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvblxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvcjpfIHRyZWUgPSB0cmVlXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3I6XyBrIHYgPSBUcmVlMC5zaW5nbGV0b24gayB2XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIGZzdCAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID0gZnN0IChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9IGZzdCAoVHJlZTAub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcilcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6X3JlcXVpcmVkX2J5X2ludGYgfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjpmc3RcbiAgICAgIChUcmVlMC5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgbWF0Y2ggVHJlZTAub2Zfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3IgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID0gZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzZXEgfmluaXQgfmYgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b190cmVlIHQgPSB0XG5cbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuXG4gIGxldCBzZXQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBmc3QgKFRyZWUwLnNldCB0IH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgYWRkX2V4biB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIGZzdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHRcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+bGVuZ3RoOjBcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICB0cnkgYE9rIChhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSkgd2l0aFxuICAgIHwgXyAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIFRyZWUwLmFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHw+IGZzdFxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLnJlbW92ZV9tdWx0aSB0IGtleSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHw+IGZzdFxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX211bHRpIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGZzdCAoVHJlZTAuY2hhbmdlIHQga2V5IH5mIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB+Y29tcGFyYXRvciB0IGtleSB+ZiA9XG4gICAgY2hhbmdlIH5jb21wYXJhdG9yIHQga2V5IH5mOihmdW4gZGF0YSAtPiBTb21lIChmIGRhdGEpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHRcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAuZmluZCB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBmc3QgKFRyZWUwLnJlbW92ZSB0IGtleSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5tZW0gdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIGxldCBpdGVyX2tleXMgdCB+ZiA9IFRyZWUwLml0ZXJfa2V5cyB0IH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0IH5mXG4gIGxldCBpdGVyaV91bnRpbCB0IH5mID0gVHJlZTAuaXRlcmlfdW50aWwgdCB+ZlxuXG4gIGxldCBpdGVyMiB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgVHJlZTAuaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID0gVHJlZTAubWFwIHQgfmZcbiAgbGV0IG1hcGkgdCB+ZiA9IFRyZWUwLm1hcGkgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdCB+ZiB+aW5pdCB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcblxuICBsZXQgZm9sZDIgfmNvbXBhcmF0b3IgdDEgdDIgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9rZXlzIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXIgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfbWFwaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uaV90ZiB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB+Y29tcGFyYXRvciB0ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOmZzdFxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzXG4gICAgICAgICB0XG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuZXF1YWwgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdFxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0XG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHRcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MVxuICAgICAgdDJcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgZnN0IChUcmVlMC5tZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCB+Y29tcGFyYXRvciB0MSB0MiB+Y29tYmluZSA9XG4gICAgKCogTGVuZ3RoIGNvbXB1dGF0aW9uIG1ha2VzIHRoaXMgc2lnbmlmaWNhbnRseSBzbG93ZXIgdGhhbiBbbWVyZ2Vfc2tld2VkXSBvbiBhIG1hcFxuICAgICAgIHdpdGggYSBbbGVuZ3RoXSBmaWVsZCwgYnV0IGRvZXMgcHJlc2VydmUgYW1vdW50IG9mIGFsbG9jYXRpb24uICopXG4gICAgZnN0XG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MVxuICAgICAgICAgdDJcbiAgICAgICAgIH5sZW5ndGgxOihsZW5ndGggdDEpXG4gICAgICAgICB+bGVuZ3RoMjoobGVuZ3RoIHQyKVxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdCB+ZlxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBrID0gVHJlZTAuc3BsaXQgdCBrIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCBhcHBlbmQgfmNvbXBhcmF0b3Igfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIFRyZWUwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgXywgcmV0LCBfID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfmxvd2VyX2JvdW5kXG4gICAgICAgIH51cHBlcl9ib3VuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHJldFxuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB+Y29tcGFyYXRvciB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgIHRcbiAgICAgIH5taW5cbiAgICAgIH5tYXhcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgfmNvbXBhcmF0b3IgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0IGRpciBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdCBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAucmFuayB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHRcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIGZzdCAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gRW1wdHlcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiB3aXRoXG4gICAgfCBgT2sgKHQsIF8pIC0+IGBPayB0XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPSBmc3QgKFRyZWUwLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mKVxuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAndykgdCA9ICgnaywgJ3YpIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudFxuXG4gICAgbGV0IGVtcHR5ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5lbXB0eVxuXG4gICAgbGV0IGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSB0IHdpdGhcbiAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgIEVycm9yLnJhaXNlX3MgKFNleHAuQXRvbSBcIk1hcC5CdWlsZF9pbmNyZWFzaW5nLmFkZDogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICB8IF8gLT4gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZSB0ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgayB2ID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGsgdjsgbGVuZ3RoID0gMSB9XG4gIGxldCBvZl90cmVlMCB+Y29tcGFyYXRvciAodHJlZSwgbGVuZ3RoKSA9IHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IG9mX3RyZWUwIH5jb21wYXJhdG9yICh0cmVlLCBUcmVlMC5sZW5ndGggdHJlZSlcbiAgbGV0IHRvX3RyZWUgPSB0b190cmVlXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICB+ZjooZnVuIHRyZWUgLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIGxlbmd0aCkgLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5pdGVyaSB3aXRoXG4gICAgfCBgT2sgdHJlZV9sZW5ndGggLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlX2xlbmd0aClcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiwgbGVuKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjoob2ZfdHJlZTAgfmNvbXBhcmF0b3IpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBsZW5ndGgpIC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgdC50cmVlIH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayBwYWlyIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgcGFpcilcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm1hcF9rZXlzX2V4biB0LnRyZWUgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA9IHsgdHJlZSA9IFRyZWUwLmVtcHR5OyBjb21wYXJhdG9yID0gSy5jb21wYXJhdG9yOyBsZW5ndGggPSAwIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFRyZWUgPSBUcmVlXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxudHlwZSAoJ2ssICdjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9ICdrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCBjb21wYXJhdG9yX3MgKHR5cGUgayBjbXApIHQgOiAoaywgY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBrXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXBcblxuICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gIGVuZClcbjs7XG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGsgY21wKSAoKG1vZHVsZSBNKSA6IChrLCBjbXApIGNvbXBhcmF0b3IpID0gTS5jb21wYXJhdG9yXG5cbmxldCBvZl90cmVlICh0eXBlIGsgY21wKSAoKG1vZHVsZSBNKSA6IChrLCBjbXApIGNvbXBhcmF0b3IpIHRyZWUgPVxuICBvZl90cmVlIH5jb21wYXJhdG9yOk0uY29tcGFyYXRvciB0cmVlXG47O1xuXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdF9tdWx0aSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X2ZvbGQgbSBhIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9hbGlzdF9yZWR1Y2UgbSBhIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2l0ZXJpIG0gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcblxubGV0IG9mX2l0ZXJpX2V4biBtIH5pdGVyaSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgbSBzZXEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc2VxXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2UgbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9leG4gbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2VfbXVsdGkgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZm9sZCBtIHMgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+aW5pdCB+ZlxuOztcblxubGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBtIHMgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5mXG47O1xuXG5sZXQgbWFwX2tleXMgbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0IH5mXG5sZXQgbWFwX2tleXNfZXhuIG0gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcblxubW9kdWxlIE0gKEsgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cFxuICAgICAgKHR5cGUgayBjbXApXG4gICAgICAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICAgIHZfb2Zfc2V4cFxuICAgICAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpLLmNvbXBhcmF0b3IgSy50X29mX3NleHAgdl9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hclxuICAgICAgKHR5cGUgaylcbiAgICAgIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaylcbiAgICAgICh2X2dyYW1tYXIgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICB7IHVudHlwZWQgPVxuICAgICAgTGlzdFxuICAgICAgICAoTWFueSAoTGlzdCAoQ29ucyAoSy50X3NleHBfZ3JhbW1hci51bnR5cGVkLCBDb25zICh2X2dyYW1tYXIudW50eXBlZCwgRW1wdHkpKSkpKVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9tX190IChtb2R1bGUgXyA6IENvbXBhcmVfbSkgY29tcGFyZV92IHQxIHQyID0gY29tcGFyZV9kaXJlY3QgY29tcGFyZV92IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuXG5sZXQgaGFzaF9mb2xkX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBrKSBoYXNoX2ZvbGRfdiBzdGF0ZSA9XG4gIGhhc2hfZm9sZF9kaXJlY3QgSy5oYXNoX2ZvbGRfdCBoYXNoX2ZvbGRfdiBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9ICgnaywgJ3YsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2V4biBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZm9sZCBhIH5pbml0IH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGEgfmluaXQgfmZcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYSB+ZlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3JcbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3JcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxID0gVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcVxuICBsZXQgb2Zfc2VxdWVuY2UgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgcyB+aW5pdCB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHMgfmluaXQgfmZcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIHMgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzIH5mXG4gIGxldCBtYXBfa2V5cyB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmZcbmVuZFxuIiwib3BlbiEgSW1wb3J0MFxuXG50eXBlICdhIHQgPSAnYSBDYW1sLlF1ZXVlLnRcblxubGV0IGNyZWF0ZSA9IENhbWwuUXVldWUuY3JlYXRlXG5sZXQgY2xlYXIgPSBDYW1sLlF1ZXVlLmNsZWFyXG5sZXQgY29weSA9IENhbWwuUXVldWUuY29weVxubGV0IGlzX2VtcHR5ID0gQ2FtbC5RdWV1ZS5pc19lbXB0eVxubGV0IGxlbmd0aCA9IENhbWwuUXVldWUubGVuZ3RoXG5sZXQgcGVlayA9IENhbWwuUXVldWUucGVla1xubGV0IHBvcCA9IENhbWwuUXVldWUucG9wXG5sZXQgcHVzaCA9IENhbWwuUXVldWUucHVzaFxubGV0IHRyYW5zZmVyID0gQ2FtbC5RdWV1ZS50cmFuc2ZlclxubGV0IGl0ZXIgdCB+ZiA9IENhbWwuUXVldWUuaXRlciBmIHRcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLlF1ZXVlLmZvbGQgZiBpbml0IHRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaW5rZWRfcXVldWUwXG5cbmxldCBlbnF1ZXVlIHQgeCA9IExpbmtlZF9xdWV1ZTAucHVzaCB4IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucG9wIHQpXG5sZXQgZGVxdWV1ZV9leG4gPSBMaW5rZWRfcXVldWUwLnBvcFxubGV0IHBlZWsgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoTGlua2VkX3F1ZXVlMC5wZWVrIHQpXG5sZXQgcGVla19leG4gPSBMaW5rZWRfcXVldWUwLnBlZWtcblxubW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgICBsZXQgZm9sZGkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgICBsZXQgaXRlcmkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgY291bnRpID0gQy5jb3VudGlcbmxldCBleGlzdHNpID0gQy5leGlzdHNpXG5sZXQgZmluZF9tYXBpID0gQy5maW5kX21hcGlcbmxldCBmaW5kaSA9IEMuZmluZGlcbmxldCBmb2xkaSA9IEMuZm9sZGlcbmxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcbmxldCBpdGVyaSA9IEMuaXRlcmlcbmxldCB0cmFuc2ZlciB+c3JjIH5kc3QgPSBMaW5rZWRfcXVldWUwLnRyYW5zZmVyIHNyYyBkc3RcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBMaXN0Lml0ZXIgKGYgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBMaXN0Lml0ZXIgKGYgaSBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT5cbiAgICBtYXRjaCBmIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgcmVzIGIpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2ggZiBpIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgcmVzIGIpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGlmIGYgaSBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGVucXVldWUgcmVzIChmIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGVucXVldWUgcmVzIChmIGkgYSkpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlcmkgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbGlzdCA9IExpc3QuaXRlciBsaXN0IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeClcblxubGV0IG9mX2xpc3QgbGlzdCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIExpc3QuaXRlciBsaXN0IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBvZl9hcnJheSBhcnJheSA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIEFycmF5Lml0ZXIgYXJyYXkgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IGluaXQgbGVuIH5mID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBlbnF1ZXVlIHQgKGYgaSlcbiAgZG9uZTtcbiAgdFxuOztcblxubGV0IHRvX2FycmF5IHQgPVxuICBtYXRjaCBsZW5ndGggdCB3aXRoXG4gIHwgMCAtPiBbfHxdXG4gIHwgbGVuIC0+XG4gICAgbGV0IGFyciA9IEFycmF5LmNyZWF0ZSB+bGVuIChwZWVrX2V4biB0KSBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBpdGVyIHQgfmY6KGZ1biB2IC0+XG4gICAgICBhcnIuKCFpKSA8LSB2O1xuICAgICAgaW5jciBpKTtcbiAgICBhcnJcbjs7XG5cbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBvZl9saXN0IChsaXN0X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCBzaW5nbGV0b24gYSA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGVucXVldWUgdCBhO1xuICB0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLkludDY0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuXG4gIGxldCBjb21wYXJlID0gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxubGV0IG51bV9iaXRzID0gNjRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X29mX2JpdHMgPSBmbG9hdF9vZl9iaXRzXG5sZXQgYml0c19vZl9mbG9hdCA9IGJpdHNfb2ZfZmxvYXRcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnQ2NF9wb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBDYW1sLkludDY0Lm9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIENhbWwuSW50NjQub2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2NC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwNjQgOiB0IC0+IHQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAxNiB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDQ4XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAzMiB4ID1cbiAgKCogVGhpcyBpcyBzdHJpY3RseSBiZXR0ZXIgdGhhbiBjb2VyY2luZyB0byBhbiBpbnQzMiB0byBwZXJmb3JtIGJ5dGVzd2FwLiBDb2VyY2luZ1xuICAgICBmcm9tIGFuIGludDMyIHdpbGwgYWRkIHVubmVjZXNzYXJ5IHNoaWZ0IG9wZXJhdGlvbnMgdG8gc2lnbiBleHRlbmQgdGhlIG51bWJlclxuICAgICBhcHByb3ByaWF0ZWx5LlxuICAqKVxuICBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMzJcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXA0OCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDE2XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCBpbmNyIHIgPSByIDo9IGFkZCAhciBvbmVcbmxldCBkZWNyIHIgPSByIDo9IHN1YiAhciBvbmVcblxuZXh0ZXJuYWwgb2ZfaW50NjQgOiB0IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NFxubGV0IHRvX2ludDY0IHQgPSB0XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5leHRlcm5hbCB0b19pbnRfdHJ1bmMgOiB0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCB0b19pbnQzMl90cnVuYyA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50X3RydW5jIDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50NjRfdG9faW50X2V4blxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5JbnQ2NC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLkludDY0LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuSW50NjQucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLkludDY0LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLkludDY0LnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLkludDY0LnByZWQgeCA9IENhbWwuSW50NjQuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQ2NCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBpZiBDYW1sLkludDY0LmVxdWFsIGkgQ2FtbC5JbnQ2NC5vbmUgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuSW50NjQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDY0IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSBuZWdcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJUx4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlTHhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0XCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2FkZFwiXG4gIGV4dGVybmFsICggLSApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9zdWJcIlxuICBleHRlcm5hbCAoICogKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfbXVsXCJcbiAgZXh0ZXJuYWwgKCAvICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2RpdlwiXG4gIGV4dGVybmFsICggfi0gKSA6IHQgLT4gdCA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFicyA9IGFic1xuXG4gIGV4dGVybmFsIG5lZyA6IHQgLT4gdCA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9hbmRcIlxuICBleHRlcm5hbCAoIGxvciApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9vclwiXG4gIGV4dGVybmFsICggbHhvciApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF94b3JcIlxuXG4gIGxldCBsbm90ID0gYml0X25vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfbHNsXCJcbiAgZXh0ZXJuYWwgKCBhc3IgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9hc3JcIlxuICBleHRlcm5hbCAoIGxzciApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2xzclwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2NF0gYW5kIFtJbnQ2NC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIigqIEEgNjNiaXQgaW50ZWdlciBpcyBhIDY0Yml0IGludGVnZXIgd2l0aCBpdHMgYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICBhbmQgaXRzIGxvd2VzdCBiaXQgc2V0IHRvIDAuXG4gICBUaGlzIGlzIHRoZSBzYW1lIGtpbmQgb2YgZW5jb2RpbmcgYXMgT0NhbWwgaW50IG9uIDY0Yml0IGFyY2hpdGVjdHVyZS5cbiAgIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhlIGxvd2VzdCBiaXQgKGltbWVkaWF0ZSBiaXQpIHNldCB0byAxLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cblxubW9kdWxlIFQwID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50NjQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50NjQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQ2NF9zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmVuZFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5tb2R1bGUgVyA6IHNpZ1xuXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuICBlbmRcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIHZhbCB3cmFwX2V4biA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCB3cmFwX21vZHVsbyA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCB1bndyYXAgOiB0IC0+IENhbWwuSW50NjQudFxuXG4gICgqKiBSZXR1cm5zIGEgbm9uLW5lZ2F0aXZlIGludDY0IHRoYXQgaXMgZXF1YWwgdG8gdGhlIGlucHV0IGludDYzIG1vZHVsbyAyXjYzLiAqKVxuICB2YWwgdW53cmFwX3Vuc2lnbmVkIDogdCAtPiBDYW1sLkludDY0LnRcblxuICB2YWwgaW52YXJpYW50IDogdCAtPiB1bml0XG4gIHZhbCBhZGQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3ViIDogdCAtPiB0IC0+IHRcbiAgdmFsIG5lZyA6IHQgLT4gdFxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBzdWNjIDogdCAtPiB0XG4gIHZhbCBwcmVkIDogdCAtPiB0XG4gIHZhbCBtdWwgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG93IDogdCAtPiB0IC0+IHRcbiAgdmFsIGRpdiA6IHQgLT4gdCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuICB2YWwgcG9wY291bnQgOiB0IC0+IGludFxuICB2YWwgYml0X25vdCA6IHQgLT4gdFxuICB2YWwgYml0X3hvciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfb3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X2FuZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzaGlmdF9sZWZ0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogdCAtPiBpbnQgLT4gdFxuICB2YWwgbWluX3ZhbHVlIDogdFxuICB2YWwgbWF4X3ZhbHVlIDogdFxuICB2YWwgdG9faW50NjQgOiB0IC0+IENhbWwuSW50NjQudFxuICB2YWwgb2ZfaW50NjQgOiBDYW1sLkludDY0LnQgLT4gdCBvcHRpb25cbiAgdmFsIG9mX2ludDY0X2V4biA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCBvZl9pbnQ2NF90cnVuYyA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgY2VpbF9wb3cyIDogdCAtPiB0XG4gIHZhbCBmbG9vcl9wb3cyIDogdCAtPiB0XG4gIHZhbCBjZWlsX2xvZzIgOiB0IC0+IGludFxuICB2YWwgZmxvb3JfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBpc19wb3cyIDogdCAtPiBib29sXG4gIHZhbCBjbHogOiB0IC0+IGludFxuICB2YWwgY3R6IDogdCAtPiBpbnRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFQwXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICBsZXQgd3JhcF9leG4geCA9XG4gICAgKCogUmFpc2VzIGlmIHRoZSBpbnQ2NCB2YWx1ZSBkb2VzIG5vdCBmaXQgb24gaW50NjMuICopXG4gICAgQ29udi5pbnQ2NF9maXRfb25faW50NjNfZXhuIHg7XG4gICAgQ2FtbC5JbnQ2NC5tdWwgeCAyTFxuICA7O1xuXG4gIGxldCB3cmFwIHggPVxuICAgIGlmIENvbnYuaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gU29tZSAoQ2FtbC5JbnQ2NC5tdWwgeCAyTCkgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHdyYXBfbW9kdWxvIHggPSBDYW1sLkludDY0Lm11bCB4IDJMXG4gIGxldCB1bndyYXAgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHQgeCAxXG4gIGxldCB1bndyYXBfdW5zaWduZWQgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IDFcblxuICAoKiBUaGlzIGRvZXMgbm90IHVzZSB3cmFwIG9yIHVud3JhcCB0byBhdm9pZCBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgb3ZlcmZsb3dzLiBUaGlzIGlzIHRvIHByZXNlcnZlIHRoZSBzZW1hbnRpY3Mgb2YgaW50IHR5cGUgb24gNjQgYml0IGFyY2hpdGVjdHVyZS4gKilcbiAgbGV0IGYyIGYgYSBiID1cbiAgICBDYW1sLkludDY0Lm11bCAoZiAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBhIDEpIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSkpIDJMXG4gIDs7XG5cbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZl9mZmZmX2ZmZmVMXG4gIGxldCBtIHggPSBDYW1sLkludDY0LmxvZ2FuZCB4IG1hc2tcbiAgbGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChtIHQgPSB0KVxuICBsZXQgYWRkIHggeSA9IENhbWwuSW50NjQuYWRkIHggeVxuICBsZXQgc3ViIHggeSA9IENhbWwuSW50NjQuc3ViIHggeVxuICBsZXQgbmVnIHggPSBDYW1sLkludDY0Lm5lZyB4XG4gIGxldCBhYnMgeCA9IENhbWwuSW50NjQuYWJzIHhcbiAgbGV0IG9uZSA9IHdyYXBfZXhuIDFMXG4gIGxldCBzdWNjIGEgPSBhZGQgYSBvbmVcbiAgbGV0IHByZWQgYSA9IHN1YiBhIG9uZVxuICBsZXQgbWluX3ZhbHVlID0gbSBDYW1sLkludDY0Lm1pbl9pbnRcbiAgbGV0IG1heF92YWx1ZSA9IG0gQ2FtbC5JbnQ2NC5tYXhfaW50XG4gIGxldCBiaXRfbm90IHggPSBtIChDYW1sLkludDY0LmxvZ25vdCB4KVxuICBsZXQgYml0X2FuZCA9IENhbWwuSW50NjQubG9nYW5kXG4gIGxldCBiaXRfeG9yID0gQ2FtbC5JbnQ2NC5sb2d4b3JcbiAgbGV0IGJpdF9vciA9IENhbWwuSW50NjQubG9nb3JcbiAgbGV0IHNoaWZ0X2xlZnQgeCBpID0gQ2FtbC5JbnQ2NC5zaGlmdF9sZWZ0IHggaVxuICBsZXQgc2hpZnRfcmlnaHQgeCBpID0gbSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCB4IGkpXG4gIGxldCBzaGlmdF9yaWdodF9sb2dpY2FsIHggaSA9IG0gKENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkpXG4gIGxldCBwb3cgPSBmMiBJbnRfbWF0aC5Qcml2YXRlLmludDYzX3Bvd19vbl9pbnQ2NFxuICBsZXQgbXVsIGEgYiA9IENhbWwuSW50NjQubXVsIGEgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYiAxKVxuICBsZXQgZGl2IGEgYiA9IHdyYXBfbW9kdWxvIChDYW1sLkludDY0LmRpdiBhIGIpXG4gIGxldCByZW0gYSBiID0gQ2FtbC5JbnQ2NC5yZW0gYSBiXG4gIGxldCBwb3Bjb3VudCB4ID0gUG9wY291bnQuaW50NjRfcG9wY291bnQgeFxuICBsZXQgdG9faW50NjQgdCA9IHVud3JhcCB0XG4gIGxldCBvZl9pbnQ2NCB0ID0gd3JhcCB0XG4gIGxldCBvZl9pbnQ2NF9leG4gdCA9IHdyYXBfZXhuIHRcbiAgbGV0IG9mX2ludDY0X3RydW5jIHQgPSB3cmFwX21vZHVsbyB0XG4gIGxldCB0X29mX3NleHAgeCA9IHdyYXBfZXhuIChpbnQ2NF9vZl9zZXhwIHgpXG4gIGxldCBzZXhwX29mX3QgeCA9IHNleHBfb2ZfaW50NjQgKHVud3JhcCB4KVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgaXNfcG93MiB4ID0gSW50NjQuaXNfcG93MiAodW53cmFwIHgpXG5cbiAgbGV0IGNseiB4ID1cbiAgICAoKiBXZSBydW4gSW50NjQuY2x6IGRpcmVjdGx5IG9uIHRoZSB3cmFwcGVkIGludDYzIHZhbHVlLiBUaGlzIGlzIGNvcnJlY3QgYmVjYXVzZSB0aGVcbiAgICAgICBiaXRzIG9mIHRoZSBpbnQ2M19lbXVsIGFyZSBsZWZ0LWFsaWduZWQgaW4gdGhlIEludDY0LiAqKVxuICAgIEludDY0LmNseiB4XG4gIDs7XG5cbiAgbGV0IGN0eiB4ID0gSW50NjQuY3R6ICh1bndyYXAgeClcbiAgbGV0IGZsb29yX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgY2VpbF9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGZsb29yX2xvZzIgeCA9IEludDY0LmZsb29yX2xvZzIgKHVud3JhcCB4KVxuICBsZXQgY2VpbF9sb2cyIHggPSBJbnQ2NC5jZWlsX2xvZzIgKHVud3JhcCB4KVxuZW5kXG5cbm9wZW4gV1xuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBXLnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoVy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChXLnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBXLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFcuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBXLmNvbXBhcmF0b3JcbiAgbGV0IGNvbXBhcmUgPSBXLmNvbXBhcmVcbiAgbGV0IGludmFyaWFudCA9IFcuaW52YXJpYW50XG5cbiAgKCogV2UgZG9uJ3QgZXhwZWN0IFtoYXNoXSB0byBmb2xsb3cgdGhlIGJlaGF2aW9yIG9mIGludCBpbiA2NGJpdCBhcmNoaXRlY3R1cmUgKilcbiAgbGV0IF8gPSBoYXNoXG4gIGxldCBoYXNoICh4IDogdCkgPSBDYW1sLkhhc2h0YmwuaGFzaCB4XG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGludmFsaWRfc3RyIHggPSBQcmludGYuZmFpbHdpdGhmIFwiSW50NjMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgeCAoKVxuXG4gICgqXG4gICAgIFwic2lnblwiIHJlZmVycyB0byB3aGV0aGVyIHRoZSBudW1iZXIgc3RhcnRzIHdpdGggYSAnLSdcbiAgICAgXCJzaWduZWRuZXNzID0gZmFsc2VcIiBtZWFucyB0aGUgcmVzdCBvZiB0aGUgbnVtYmVyIGlzIHBhcnNlZCBhcyB1bnNpZ25lZCBhbmQgdGhlbiBjYXN0XG4gICAgIHRvIHNpZ25lZCB3aXRoIHdyYXAtYXJvdW5kIG1vZHVsbyAyXmlcbiAgICAgXCJzaWduZWRuZXNzID0gdHJ1ZVwiIG1lYW5zIG5vIHN1Y2ggY3JhemluZXNzIGhhcHBlbnNcblxuICAgICBUaGUgdGVybWlub2xvZ3kgYW5kIHRoZSBsb2dpYyBpcyBkdWUgdG8gdGhlIGNvZGUgaW4gYnl0ZXJ1bi9pbnRzLmMgaW4gb2NhbWwgNC4wM1xuICAgICAoW3BhcnNlX3NpZ25fYW5kX2Jhc2VdIGZ1bmN0aW9uKS5cblxuICAgICBTaWduZWRuZXNzIGVxdWFscyB0cnVlIGZvciBwbGFpbiBkZWNpbWFsIG51bWJlciAoZS5nLiAxMjM1LCAtNjc4OSlcblxuICAgICBTaWduZWRuZXNzIGVxdWFscyBmYWxzZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAtIFsweGZmZmZdLCBbLTB4ZmZmZl0gKGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswYjAxMDFdLCBbLTBiMDEwMV0gKGJpbmFyeSByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMG8xMjM3XSwgWy0wbzEyMzddIChvY3RhbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMHU5ODEyXSwgWy0wdTk4MTJdICh1bnNpZ25lZCBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIC0gYXZhaWxhYmxlIGZyb20gT0NhbWwgNC4wMykgKilcbiAgbGV0IHNpZ25fYW5kX3NpZ25lZG5lc3MgeCA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcG9zLCBzaWduID1cbiAgICAgIGlmIDAgPCBsZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCB4LlswXSB3aXRoXG4gICAgICAgIHwgJy0nIC0+IDEsIGBOZWdcbiAgICAgICAgfCAnKycgLT4gMSwgYFBvc1xuICAgICAgICB8IF8gLT4gMCwgYFBvcylcbiAgICAgIGVsc2UgMCwgYFBvc1xuICAgIGluXG4gICAgaWYgcG9zICsgMiA8IGxlblxuICAgIHRoZW4gKFxuICAgICAgbGV0IGMxID0geC5bcG9zXSBpblxuICAgICAgbGV0IGMyID0geC5bcG9zICsgMV0gaW5cbiAgICAgIG1hdGNoIGMxLCBjMiB3aXRoXG4gICAgICB8ICcwJywgJzAnIC4uICc5JyAtPiBzaWduLCB0cnVlXG4gICAgICB8ICcwJywgXyAtPiBzaWduLCBmYWxzZVxuICAgICAgfCBfIC0+IHNpZ24sIHRydWUpXG4gICAgZWxzZSBzaWduLCB0cnVlXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB4ID0gQ2FtbC5JbnQ2NC50b19zdHJpbmcgKHVud3JhcCB4KVxuXG4gIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICB0cnlcbiAgICAgIGxldCBzaWduLCBzaWduZWRuZXNzID0gc2lnbl9hbmRfc2lnbmVkbmVzcyBzdHIgaW5cbiAgICAgIGlmIHNpZ25lZG5lc3NcbiAgICAgIHRoZW4gb2ZfaW50NjRfZXhuIChDYW1sLkludDY0Lm9mX3N0cmluZyBzdHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBvc19zdHIgPVxuICAgICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICAgIHwgYE5lZyAtPiBTdHJpbmcuc3ViIHN0ciB+cG9zOjEgfmxlbjooU3RyaW5nLmxlbmd0aCBzdHIgLSAxKVxuICAgICAgICAgIHwgYFBvcyAtPiBzdHJcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGludDY0ID0gQ2FtbC5JbnQ2NC5vZl9zdHJpbmcgcG9zX3N0ciBpblxuICAgICAgICAoKiB1bnNpZ25lZCA2My1iaXQgaW50IG11c3QgcGFyc2UgYXMgYSBwb3NpdGl2ZSBzaWduZWQgNjQtYml0IGludCAqKVxuICAgICAgICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaW50NjQgMEwgdGhlbiBpbnZhbGlkX3N0ciBzdHI7XG4gICAgICAgIGxldCBpbnQ2MyA9IHdyYXBfbW9kdWxvIGludDY0IGluXG4gICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICB8IGBOZWcgLT4gbmVnIGludDYzXG4gICAgICAgIHwgYFBvcyAtPiBpbnQ2MylcbiAgICB3aXRoXG4gICAgfCBfIC0+IGludmFsaWRfc3RyIHN0clxuICA7O1xuXG4gIGxldCBic3dhcDE2IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAxNiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXAzMiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMzIgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwNDggdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDQ4ICh1bndyYXAgdCkpXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBudW1fYml0cyA9IDYzXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBiaXRfbm90XG5sZXQgYml0X3hvciA9IGJpdF94b3JcbmxldCBiaXRfb3IgPSBiaXRfb3JcbmxldCBiaXRfYW5kID0gYml0X2FuZFxubGV0IHBvcGNvdW50ID0gcG9wY291bnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWF4X3ZhbHVlID0gbWF4X3ZhbHVlXG5sZXQgbWluX3ZhbHVlID0gbWluX3ZhbHVlXG5sZXQgbWludXNfb25lID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC5taW51c19vbmVcbmxldCBvbmUgPSB3cmFwX2V4biBDYW1sLkludDY0Lm9uZVxubGV0IHplcm8gPSB3cmFwX2V4biBDYW1sLkludDY0Lnplcm9cbmxldCBpc19wb3cyID0gaXNfcG93MlxubGV0IGZsb29yX3BvdzIgPSBmbG9vcl9wb3cyXG5sZXQgY2VpbF9wb3cyID0gY2VpbF9wb3cyXG5sZXQgZmxvb3JfbG9nMiA9IGZsb29yX2xvZzJcbmxldCBjZWlsX2xvZzIgPSBjZWlsX2xvZzJcbmxldCBjbHogPSBjbHpcbmxldCBjdHogPSBjdHpcbmxldCB0b19mbG9hdCB4ID0gQ2FtbC5JbnQ2NC50b19mbG9hdCAodW53cmFwIHgpXG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkIHggPSB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5vZl9mbG9hdCB4KVxuXG5sZXQgb2ZfZmxvYXQgdCA9XG4gIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiB0ID49IGZsb2F0X2xvd2VyX2JvdW5kICYmIHQgPD0gZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5vZl9mbG9hdCB0KVxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2My5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IG9mX2ludDY0ID0gb2ZfaW50NjRcbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IG9mX2ludDY0X3RydW5jXG5sZXQgdG9faW50NjQgPSB0b19pbnQ2NFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcblxuKCogV2UgY2FuIHJldXNlIGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbS90byBpbnQ2NCBoZXJlLiAqKVxubGV0IG9mX2ludCB4ID0gd3JhcF9leG4gKENvbnYuaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfaW50X2V4biB4ID0gb2ZfaW50IHhcbmxldCB0b19pbnQgeCA9IENvbnYuaW50NjRfdG9faW50ICh1bndyYXAgeClcbmxldCB0b19pbnRfZXhuIHggPSBDb252LmludDY0X3RvX2ludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX2ludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnRfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX2ludDMyIHggPSB3cmFwX2V4biAoQ29udi5pbnQzMl90b19pbnQ2NCB4KVxubGV0IG9mX2ludDMyX2V4biB4ID0gb2ZfaW50MzIgeFxubGV0IHRvX2ludDMyIHggPSBDb252LmludDY0X3RvX2ludDMyICh1bndyYXAgeClcbmxldCB0b19pbnQzMl9leG4geCA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnQzMl90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuYyAodW53cmFwIHgpXG5sZXQgb2ZfbmF0aXZlaW50IHggPSBvZl9pbnQ2NCAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfZXhuIHggPSB3cmFwX2V4biAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgeCA9IG9mX2ludDY0X3RydW5jIChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IHRvX25hdGl2ZWludCB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnQgKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF9leG4geCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4biAodW53cmFwIHgpXG5sZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF90cnVuYyAodW53cmFwIHgpXG5cbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKFQuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBULmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IFQuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcblxuICAgIGxldCB0b19zdHJpbmcgaSA9XG4gICAgICAoKiB0aGUgdXNlIG9mIFt1bndyYXBfdW5zaWduZWRdIGhlcmUgaXMgaW1wb3J0YW50IGZvciB0aGUgY2FzZSBvZiBbbWluX3ZhbHVlXSAqKVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIlTHhcIiAodW53cmFwX3Vuc2lnbmVkIGkpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgcyA9IG9mX3N0cmluZyAoXCIweFwiIF4gcylcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjMuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyB4ID0gdG9fc3RyaW5nIHhcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjNcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDYzXSBhbmQgW0ludDYzLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgdHlwZSBlbXVsYXRlZCA9IHRcblxuICB0eXBlICgndW5kZXJseWluZ190eXBlLCAnaW50ZXJtZWRpYXRlX3R5cGUpIHQgPVxuICAgIHwgSW50IDogKGludCwgaW50KSB0XG4gICAgfCBJbnQ2NCA6IChpbnQ2NCwgZW11bGF0ZWQpIHRcbmVuZFxuXG5sZXQgcmVwciA9IFJlcHIuSW50NjRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2wgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfYm9vbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBmYWxzZTsgdHJ1ZSBdIDogdCBsaXN0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfYm9vbFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfYm9vbCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoYm9vbF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ib29sIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJvb2xfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcInRydWVcIiAtPiB0cnVlXG4gICAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgICB8IHMgLT4gaW52YWxpZF9hcmdmIFwiQm9vbC5vZl9zdHJpbmc6IGV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYnV0IGdvdCAlc1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfYm9vbFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJvb2xcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgdG9faW50IHggPSBib29sX3RvX2ludCB4XG5cbm1vZHVsZSBOb25fc2hvcnRfY2lyY3VpdGluZyA9IHN0cnVjdFxuICAoKiBXZSBkb24ndCBleHBvc2UgdGhpcywgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgaW52YXJpYW50IG1lbnRpb25lZCBiZWxvdyBvZlxuICAgICAodG9faW50IHRydWUgPSAxKSBhbmQgKHRvX2ludCBmYWxzZSA9IDApLiAqKVxuICBsZXQgdW5zYWZlX29mX2ludCAoeCA6IGludCkgOiBib29sID0gQ2FtbC5PYmoubWFnaWMgeFxuICBsZXQgKCB8fCApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxvciB0b19pbnQgYilcbiAgbGV0ICggJiYgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsYW5kIHRvX2ludCBiKVxuZW5kXG5cbigqIFdlIGRvIHRoaXMgYXMgYSBkaXJlY3QgYXNzZXJ0IG9uIHRoZSB0aGVvcnkgdGhhdCBpdCdzIGEgY2hlYXAgdGhpbmcgdG8gdGVzdCBhbmQgYVxuICAgcmVhbGx5IGNvcmUgaW52YXJpYW50IHRoYXQgd2UgbmV2ZXIgZXhwZWN0IHRvIGJyZWFrLCBhbmQgd2Ugc2hvdWxkIGJlIGhhcHB5IGZvciBhXG4gICBwcm9ncmFtIHRvIGZhaWwgaW1tZWRpYXRlbHkgaWYgdGhpcyBpcyB2aW9sYXRlZC4gKilcbmxldCAoKSA9IGFzc2VydCAoUG9seS4oID0gKSAodG9faW50IHRydWUpIDEgJiYgUG9seS4oID0gKSAodG9faW50IGZhbHNlKSAwKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5JbnQzMlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQzMl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQzMiA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQzMl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxubGV0IG51bV9iaXRzID0gMzJcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X29mX2JpdHMgPSBmbG9hdF9vZl9iaXRzXG5sZXQgYml0c19vZl9mbG9hdCA9IGJpdHNfb2ZfZmxvYXRcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCBjb21wYXJlID0gY29tcGFyZVxubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDMyLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBJbmZpeF9jb21wYXJlID0gc3RydWN0XG4gIG9wZW4gUG9seVxuXG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0geCA+PSB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0geCA8PSB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0geCA+IHlcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IHggPCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0geCA8PiB5XG5lbmRcblxubW9kdWxlIENvbXBhcmUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeF9jb21wYXJlXG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHggeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQ29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9pbnQzMiB0ID0gdFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgdCA9IHRcbmxldCB0b19pbnQzMl9leG4gPSB0b19pbnQzMlxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50MzJfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubGV0IG9mX2ludCA9IENvbnYuaW50X3RvX2ludDMyXG5sZXQgb2ZfaW50X2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludF90cnVuYyA9IENvbnYuaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50ID0gQ29udi5pbnQzMl90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5pbnQzMl90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50MzJcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludDY0ID0gQ29udi5pbnQzMl90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxubGV0IG9mX25hdGl2ZWludF90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQzMl90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5leHRlcm5hbCBic3dhcDMyIDogdCAtPiB0ID0gXCIlYnN3YXBfaW50MzJcIlxuXG5sZXQgYnN3YXAxNiB4ID0gQ2FtbC5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDMyIHgpIDE2XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuSW50MzIubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5JbnQzMi5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLkludDMyLnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgQ2FtbC5JbnQzMi5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgQ2FtbC5JbnQzMi5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5JbnQzMi5wcmVkIHggPSBDYW1sLkludDMyLnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQzMiBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIltJbnQzMi5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICAoKiBUaGUgW2kgPSAxXSBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBjbHooMCkgaXMgdW5kZWZpbmVkICopXG4gICAgaWYgQ2FtbC5JbnQzMi5lcXVhbCBpIENhbWwuSW50MzIub25lIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLkludDMyLnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQzMiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50MzJcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVseFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJWx4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzIuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMlwiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKENvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDMyXSBhbmQgW0ludDMyLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFJlcHIgPSBJbnQ2M19lbXVsLlJlcHJcblxuKCogSW4gYSB3b3JsZCB3aGVyZSB0aGUgY29tcGlsZXIgd291bGQgdW5kZXJzdGFuZCBbQEBpbW1lZGlhdGU2NF0gYXR0cmlidXRlcyBvbiB0eXBlXG4gICBkZWNsYXJhdGlvbnMsIHRoaXMgbW9kdWxlIGlzIGhvdyBvbmUgd291bGQgcHJvZHVjZSBhIFt0eXBlIHRdIHdpdGggdGhpcyBhdHRyaWJ1dGUuICopXG5tb2R1bGUgSW1tZWRpYXRlNjQgOiBzaWdcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBJbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuICBlbmRcblxuICBtb2R1bGUgTWFrZSAoSW1tZWRpYXRlIDogSW1tZWRpYXRlKSAoTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUpIDogc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZTY0XVxuXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcblxuICAgIHZhbCByZXByIDogdCByZXByXG4gIGVuZFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UgKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkgKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA9IHN0cnVjdFxuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cblxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG5cbiAgICBsZXQgcmVwciA9XG4gICAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICAgIHwgVzY0IC0+IChDYW1sLk9iai5tYWdpYyBJbW1lZGlhdGUgOiB0IHJlcHIpXG4gICAgICB8IFczMiAtPiAoQ2FtbC5PYmoubWFnaWMgTm9uX2ltbWVkaWF0ZSA6IHQgcmVwcilcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEltbWVkaWF0ZTY0Lk1ha2UgKEludCkgKEludDYzX2VtdWwpXG5cbm1vZHVsZSBCYWNrZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgSW50X2ludGYuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgdG9faW50IDogdCAtPiBpbnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50XG4gICAgdmFsIG9mX2ludDMyIDogaW50MzIgLT4gdFxuICAgIHZhbCB0b19pbnQzMiA6IHQgLT4gSW50MzIudCBvcHRpb25cbiAgICB2YWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IEludDMyLnRcbiAgICB2YWwgb2ZfaW50NjQgOiBJbnQ2NC50IC0+IHQgb3B0aW9uXG4gICAgdmFsIG9mX2ludDY0X3RydW5jIDogSW50NjQudCAtPiB0XG4gICAgdmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiB0IG9wdGlvblxuICAgIHZhbCB0b19uYXRpdmVpbnQgOiB0IC0+IG5hdGl2ZWludCBvcHRpb25cbiAgICB2YWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHRcbiAgICB2YWwgdG9fbmF0aXZlaW50X3RydW5jIDogdCAtPiBuYXRpdmVpbnRcbiAgICB2YWwgb2ZfZmxvYXRfdW5jaGVja2VkIDogZmxvYXQgLT4gdFxuICAgIHZhbCByZXByIDogKHQsIHQpIEludDYzX2VtdWwuUmVwci50XG4gICAgdmFsIGJzd2FwMTYgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXAzMiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDQ4IDogdCAtPiB0XG4gIGVuZFxuICB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgbW9kdWxlIE5hdGl2ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdG9faW50IHggPSBTb21lIHhcbiAgICBsZXQgdG9faW50X3RydW5jIHggPSB4XG5cbiAgICAoKiBbb2ZfaW50MzJfZXhuXSBpcyBhIHNhZmUgb3BlcmF0aW9uIG9uIHBsYXRmb3JtcyB3aXRoIDY0LWJpdCB3b3JkIHNpemVzLiAqKVxuICAgIGxldCBvZl9pbnQzMiA9IG9mX2ludDMyX2V4blxuICAgIGxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IHRvX25hdGl2ZWludCB4XG4gICAgbGV0IHRvX25hdGl2ZWludCB4ID0gU29tZSAodG9fbmF0aXZlaW50IHgpXG4gICAgbGV0IHJlcHIgPSBJbnQ2M19lbXVsLlJlcHIuSW50XG4gICAgbGV0IGJzd2FwMzIgdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXAzMiAoSW50NjQub2ZfaW50IHQpKVxuICAgIGxldCBic3dhcDQ4IHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwNDggKEludDY0Lm9mX2ludCB0KSlcbiAgZW5kXG5cbiAgbGV0IGltcGwgOiAobW9kdWxlIFMpID1cbiAgICBtYXRjaCByZXByIHdpdGhcbiAgICB8IEltbWVkaWF0ZSAtPiAobW9kdWxlIE5hdGl2ZSA6IFMpXG4gICAgfCBOb25faW1tZWRpYXRlIC0+IChtb2R1bGUgSW50NjNfZW11bCA6IFMpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSAodmFsIEJhY2tlbmQuaW1wbCA6IEJhY2tlbmQuUylcblxubW9kdWxlIE92ZXJmbG93X2V4biA9IHN0cnVjdFxuICBsZXQgKCArICkgdCB1ID1cbiAgICBsZXQgc3VtID0gdCArIHUgaW5cbiAgICBpZiBiaXRfb3IgKGJpdF94b3IgdCB1KSAoYml0X3hvciB0IChiaXRfbm90IHN1bSkpIDwgemVyb1xuICAgIHRoZW4gc3VtXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCArICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInN1bVwiLCBzZXhwX29mX3Qgc3VtIF0pXG4gIDs7XG5cbiAgbGV0ICggLSApIHQgdSA9XG4gICAgbGV0IGRpZmYgPSB0IC0gdSBpblxuICAgIGxldCBwb3NfZGlmZiA9IHQgPiB1IGluXG4gICAgaWYgdCA8PiB1ICYmIEJvb2wuKCA8PiApIHBvc19kaWZmIChpc19wb3NpdGl2ZSBkaWZmKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLSApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJkaWZmXCIsIHNleHBfb2ZfdCBkaWZmIF0pXG4gICAgZWxzZSBkaWZmXG4gIDs7XG5cbiAgbGV0IG5lZ2F0aXZlX29uZSA9IG9mX2ludCAoLTEpXG4gIGxldCBkaXZfd291bGRfb3ZlcmZsb3cgdCB1ID0gdCA9IG1pbl92YWx1ZSAmJiB1ID0gbmVnYXRpdmVfb25lXG5cbiAgbGV0ICggKiApIHQgdSA9XG4gICAgbGV0IHByb2R1Y3QgPSB0ICogdSBpblxuICAgIGlmIHUgPD4gemVybyAmJiAoZGl2X3dvdWxkX292ZXJmbG93IHByb2R1Y3QgdSB8fCBwcm9kdWN0IC8gdSA8PiB0KVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKiApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCBwcm9kdWN0IF0pXG4gICAgZWxzZSBwcm9kdWN0XG4gIDs7XG5cbiAgbGV0ICggLyApIHQgdSA9XG4gICAgaWYgZGl2X3dvdWxkX292ZXJmbG93IHQgdVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCAodCAvIHUpIF0pXG4gICAgZWxzZSB0IC8gdVxuICA7O1xuXG4gIGxldCBhYnMgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcImFicyBvdmVyZmxvd1wiIGVsc2UgYWJzIHRcbiAgbGV0IG5lZyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwibmVnIG92ZXJmbG93XCIgZWxzZSBuZWcgdFxuZW5kXG5cbmxldCAoKSA9IGFzc2VydCAoSW50LiggPSApIG51bV9iaXRzIDYzKVxuXG5sZXQgcmFuZG9tX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50IHN0YXRlICh0b19pbnRfZXhuIGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb21fb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0IHN0YXRlICh0b19pbnQ2NCBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX29mX2ludDY0XG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnRfaW5jbCBzdGF0ZSAodG9faW50X2V4biBsbykgKHRvX2ludF9leG4gaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NF9pbmNsIHN0YXRlICh0b19pbnQ2NCBsbykgKHRvX2ludDY0IGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21faW5jbF9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX2luY2xfb2ZfaW50NjRcbjs7XG5cbmxldCBmbG9vcl9sb2cyIHQgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gdCB8PiB0b19pbnRfZXhuIHw+IEludC5mbG9vcl9sb2cyXG4gIHwgVzMyIC0+XG4gICAgaWYgdCA8PSB6ZXJvXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKTtcbiAgICBsZXQgZmxvb3JfbG9nMiA9IHJlZiAoSW50LiggLSApIG51bV9iaXRzIDIpIGluXG4gICAgd2hpbGUgZXF1YWwgemVybyAoYml0X2FuZCB0IChzaGlmdF9sZWZ0IG9uZSAhZmxvb3JfbG9nMikpIGRvXG4gICAgICBmbG9vcl9sb2cyIDo9IEludC4oIC0gKSAhZmxvb3JfbG9nMiAxXG4gICAgZG9uZTtcbiAgICAhZmxvb3JfbG9nMlxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFJlcHIgPSBSZXByXG5cbiAgbGV0IHJlcHIgPSByZXByXG5cbiAgbW9kdWxlIEVtdWwgPSBJbnQ2M19lbXVsXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2h0YmwuS2V5ICopXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIFR3byBbdF1zIHRoYXQgW2NvbXBhcmVdIGVxdWFsIG11c3QgaGF2ZSBlcXVhbCBoYXNoZXMgZm9yIHRoZSBoYXNodGFibGVcbiAgICAgICAgdG8gYmVoYXZlIHByb3Blcmx5LiAqKVxuICAgIHZhbCBoYXNoIDogdCAtPiBpbnRcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsLk1lcmdlX2ludG9fYWN0aW9uICopXG5tb2R1bGUgTWVyZ2VfaW50b19hY3Rpb24gPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IFJlbW92ZVxuICAgIHwgU2V0X3RvIG9mICdhXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzID0gc2lnXG4gICgqKiB7MiBBY2Nlc3NvcnN9ICopXG5cbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5XG5cbiAgdmFsIHNleHBfb2Zfa2V5IDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiBTZXhwLnRcbiAgdmFsIGNsZWFyIDogKF8sIF8pIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBBdHRlbXB0aW5nIHRvIG1vZGlmeSAoW3NldF0sIFtyZW1vdmVdLCBldGMuKSB0aGUgaGFzaHRhYmxlIGR1cmluZyBpdGVyYXRpb24gKFtmb2xkXSxcbiAgICAgIFtpdGVyXSwgW2l0ZXJfa2V5c10sIFtpdGVyaV0pIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgJ2IpIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXykgdCAtPiBmOignYSBrZXkgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYikgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIG92ZXIgYm90aCBrZXlzIGFuZCB2YWx1ZXMuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBIYXNodGJsLml0ZXJpIGggfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgIHByaW50X2VuZGxpbmUgKFByaW50Zi5zcHJpbnRmIFwiJWQtJWRcIiBrZXkgZGF0YSkpOztcbiAgICAgIDEtNFxuICAgICAgNS02XG4gICAgICAtIDogdW5pdCA9ICgpXG4gICAgICB2fSAqKVxuICB2YWwgaXRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnQgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiBib29sXG4gIHZhbCByZW1vdmUgOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IC0+IHVuaXRcbiAgdmFsIGNob29zZSA6ICgnYSwgJ2IpIHQgLT4gKCdhIGtleSAqICdiKSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAqICdiXG5cbiAgKCoqIFNldHMgdGhlIGdpdmVuIFtrZXldIHRvIFtkYXRhXS4gKilcbiAgdmFsIHNldCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXRcblxuICAoKiogW2FkZF0gYW5kIFthZGRfZXhuXSBsZWF2ZSB0aGUgdGFibGUgdW5jaGFuZ2VkIGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgcHJlc2VudC4gKilcbiAgdmFsIGFkZCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IFsgYE9rIHwgYER1cGxpY2F0ZSBdXG5cbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFtjaGFuZ2UgdCBrZXkgfmZdIGNoYW5nZXMgW3RdJ3MgdmFsdWUgZm9yIFtrZXldIHRvIGJlIFtmIChmaW5kIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiB1bml0XG5cbiAgKCoqIFt1cGRhdGUgdCBrZXkgfmZdIGlzIFtjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvIC0+IFNvbWUgKGYgbykpXS4gKilcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gdW5pdFxuXG4gICgqKiBbdXBkYXRlX2FuZF9yZXR1cm4gdCBrZXkgfmZdIGlzIFt1cGRhdGVdLCBidXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIFtmIG9dLiAqKVxuICB2YWwgdXBkYXRlX2FuZF9yZXR1cm4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+ICdiXG5cbiAgKCoqIFttYXAgdCBmXSByZXR1cm5zIGEgbmV3IHRhYmxlIHdpdGggdmFsdWVzIHJlcGxhY2VkIGJ5IHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgW2ZdXG4gICAgICB0byB0aGUgY3VycmVudCB2YWx1ZXMuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBsZXQgaCcgPSBIYXNodGJsLm1hcCBoIH5mOihmdW4geCAtPiB4ICogMikgaW5cbiAgICAgIEhhc2h0YmwudG9fYWxpc3QgaCc7O1xuICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDUsIDEyKTsgKDEsIDgpXVxuICAgICAgdn0gKilcbiAgdmFsIG1hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcblxuICAoKiogTGlrZSBbbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgdGFibGUgYnkgZmlsdGVyaW5nIHRoZSBnaXZlbiB0YWJsZSdzIHZhbHVlcyBieSBbZl06IHRoZSBrZXlzIGZvciB3aGljaFxuICAgICAgW2ZdIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdmFsdWUgcmV0dXJucyBbU29tZV0gYXJlIGtlcHQsIGFuZCB0aG9zZSBmb3Igd2hpY2ggaXRcbiAgICAgIHJldHVybnMgW05vbmVdIGFyZSBkaXNjYXJkZWQuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBIYXNodGJsLmZpbHRlcl9tYXAgaCB+ZjooZnVuIHggLT4gaWYgeCA+IDUgdGhlbiBTb21lIHggZWxzZSBOb25lKVxuICAgICAgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAtIDogKGludCAqIGludCkgbGlzdCA9IFsoNSwgNildXG4gICAgICB2fSAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IpIHQgLT4gZjooJ2Ega2V5IC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogUmV0dXJucyBuZXcgdGFibGVzIHdpdGggYm91bmQgdmFsdWVzIHBhcnRpdGlvbmVkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZFxuICAgICAgdmFsdWVzLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgKCoqIExpa2UgW3BhcnRpdGlvbl9tYXBdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICAoKiogUmV0dXJucyBhIHBhaXIgb2YgdGFibGVzIFsodDEsIHQyKV0sIHdoZXJlIFt0MV0gY29udGFpbnMgYWxsIHRoZSBlbGVtZW50cyBvZiB0aGVcbiAgICAgIGluaXRpYWwgdGFibGUgd2hpY2ggc2F0aXNmeSB0aGUgcHJlZGljYXRlIFtmXSwgYW5kIFt0Ml0gY29udGFpbnMgdGhlIHJlc3QuICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgKCoqIExpa2UgW3BhcnRpdGlvbl90Zl0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcblxuICAoKiogW2ZpbmRfb3JfYWRkIHQgayB+ZGVmYXVsdF0gcmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGgga2V5IFtrXSBpZiBpdCBpcyBpbiB0aGVcbiAgICAgIHRhYmxlIFt0XSwgYW5kIG90aGVyd2lzZSBhc3NpZ25zIFtrXSB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgW2RlZmF1bHQgKCldLiAqKVxuICB2YWwgZmluZF9vcl9hZGQgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBkZWZhdWx0Oih1bml0IC0+ICdiKSAtPiAnYlxuXG4gICgqKiBMaWtlIFtmaW5kX29yX2FkZF0gYnV0IFtkZWZhdWx0XSB0YWtlcyB0aGUga2V5IGFzIGFuIGFyZ3VtZW50LiAqKVxuICB2YWwgZmluZGlfb3JfYWRkIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZGVmYXVsdDooJ2Ega2V5IC0+ICdiKSAtPiAnYlxuXG4gICgqKiBbZmluZCB0IGtdIHJldHVybnMgW1NvbWVdICh0aGUgY3VycmVudCBiaW5kaW5nKSBvZiBba10gaW4gW3RdLCBvciBbTm9uZV0gaWYgbm8gc3VjaFxuICAgICAgYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIFtmaW5kX2V4biB0IGtdIHJldHVybnMgdGhlIGN1cnJlbnQgYmluZGluZyBvZiBba10gaW4gW3RdLCBvciByYWlzZXMgW0NhbWwuTm90X2ZvdW5kXVxuICAgICAgb3IgW05vdF9mb3VuZF9zXSBpZiBubyBzdWNoIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiAnYlxuXG4gICgqKiBbZmluZF9hbmRfY2FsbCB0IGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRdXG5cbiAgICAgIGlzIGVxdWl2YWxlbnQgdG86XG5cbiAgICAgIFttYXRjaCBmaW5kIHQgayB3aXRoIFNvbWUgdiAtPiBpZl9mb3VuZCB2IHwgTm9uZSAtPiBpZl9ub3RfZm91bmQga11cblxuICAgICAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhbGxvY2F0ZSB0aGUgb3B0aW9uLiAqKVxuICB2YWwgZmluZF9hbmRfY2FsbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICAoKiogSnVzdCBsaWtlIFtmaW5kX2FuZF9jYWxsXSwgYnV0IHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50IHdoaWNoIGlzIHBhc3NlZCB0byBbaWZfZm91bmRdXG4gICAgICBhbmQgW2lmX25vdF9mb3VuZF0sIHNvIHRoYXQgdGhlIGNsaWVudCBjb2RlIGNhbiBhdm9pZCBhbGxvY2F0aW5nIGNsb3N1cmVzIG9yIHVzaW5nXG4gICAgICByZWZzIHRvIHBhc3MgdGhpcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLiAgVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWZ1bCBpbiBjb2RlXG4gICAgICB3aGljaCB0cmllcyB0byBtaW5pbWl6ZSBoZWFwIGFsbG9jYXRpb24uICopXG4gIHZhbCBmaW5kX2FuZF9jYWxsMVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdkIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRfYW5kX2NhbGwyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBiOidlXG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGwxXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdkIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gYjonZVxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICAoKiogW2ZpbmRfYW5kX3JlbW92ZSB0IGtdIHJldHVybnMgU29tZSAodGhlIGN1cnJlbnQgYmluZGluZykgb2YgayBpbiB0IGFuZCByZW1vdmVzIGl0LFxuICAgICAgb3IgTm9uZSBpcyBubyBzdWNoIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9hbmRfcmVtb3ZlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIE1lcmdlcyB0d28gaGFzaHRhYmxlcy5cblxuICAgICAgVGhlIHJlc3VsdCBvZiBbbWVyZ2UgZiBoMSBoMl0gaGFzIGFzIGtleXMgdGhlIHNldCBvZiBhbGwgW2tdIGluIHRoZSB1bmlvbiBvZiB0aGVcbiAgICAgIHNldHMgb2Yga2V5cyBvZiBbaDFdIGFuZCBbaDJdIGZvciB3aGljaCBbZChrKV0gaXMgbm90IE5vbmUsIHdoZXJlOlxuXG4gICAgICBkKGspID1cbiAgICAgIC0gW2YgfmtleTprIChgTGVmdCBkMSldXG4gICAgICAgIGlmIFtrXSBpbiBbaDFdIG1hcHMgdG8gZDEsIGFuZCBbaDJdIGRvZXMgbm90IGhhdmUgZGF0YSBmb3IgW2tdO1xuXG4gICAgICAtIFtmIH5rZXk6ayAoYFJpZ2h0IGQyKV1cbiAgICAgICAgaWYgW2tdIGluIFtoMl0gbWFwcyB0byBkMiwgYW5kIFtoMV0gZG9lcyBub3QgaGF2ZSBkYXRhIGZvciBba107XG5cbiAgICAgIC0gW2YgfmtleTprIChgQm90aCAoZDEsIGQyKSldXG4gICAgICAgIG90aGVyd2lzZSwgd2hlcmUgW2tdIGluIFtoMV0gbWFwcyB0byBbZDFdIGFuZCBba10gaW4gW2gyXSBtYXBzIHRvIFtkMl0uXG5cbiAgICAgIEVhY2gga2V5IFtrXSBpcyBtYXBwZWQgdG8gYSBzaW5nbGUgcGllY2Ugb2YgZGF0YSBbeF0sIHdoZXJlIFtkKGspID0gU29tZSB4XS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoMSA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDUpOyAoMiwgMzIzMildIGluXG4gICAgICBsZXQgaDIgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCAzKV0gaW5cbiAgICAgIEhhc2h0YmwubWVyZ2UgaDEgaDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBgTGVmdCB4IC0+IFNvbWUgKGBMZWZ0IHgpXG4gICAgICAgIHwgYFJpZ2h0IHggLT4gU29tZSAoYFJpZ2h0IHgpXG4gICAgICAgIHwgYEJvdGggKHgsIHkpIC0+IGlmIHg9eSB0aGVuIE5vbmUgZWxzZSBTb21lIChgQm90aCAoeCx5KSlcbiAgICAgICkgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAtIDogKGludCAqIFs+IGBCb3RoIG9mIGludCAqIGludCB8IGBMZWZ0IG9mIGludCB8IGBSaWdodCBvZiBpbnQgXSkgbGlzdCA9XG4gICAgICBbKDIsIGBMZWZ0IDMyMzIpOyAoMSwgYEJvdGggKDUsIDMpKV1cbiAgICAgIHZ9ICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ2EpIHRcbiAgICAtPiAoJ2ssICdiKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdiIHwgYEJvdGggb2YgJ2EgKiAnYiBdIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2ssICdjKSB0XG5cblxuICAoKiogRXZlcnkgW2tleV0gaW4gW3NyY10gd2lsbCBiZSByZW1vdmVkIG9yIHNldCBpbiBbZHN0XSBhY2NvcmRpbmcgdG8gdGhlIHJldHVybiB2YWx1ZVxuICAgICAgb2YgW2ZdLiAqKVxuICB2YWwgbWVyZ2VfaW50b1xuICAgIDogIHNyYzooJ2ssICdhKSB0XG4gICAgLT4gZHN0OignaywgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+ICdhIC0+ICdiIG9wdGlvbiAtPiAnYiBNZXJnZV9pbnRvX2FjdGlvbi50KVxuICAgIC0+IHVuaXRcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwga2V5cyBmb3IgZ2l2ZW4gaGFzaHRhYmxlLiAqKVxuICB2YWwga2V5cyA6ICgnYSwgXykgdCAtPiAnYSBrZXkgbGlzdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBkYXRhIGZvciBnaXZlbiBoYXNodGFibGUuICopXG4gIHZhbCBkYXRhIDogKF8sICdiKSB0IC0+ICdiIGxpc3RcblxuICAoKiogW2ZpbHRlcl9pbnBsYWNlIHQgfmZdIHJlbW92ZXMgYWxsIHRoZSBlbGVtZW50cyBmcm9tIFt0XSB0aGF0IGRvbid0IHNhdGlzZnkgW2ZdLiAqKVxuICB2YWwgZmlsdGVyX2tleXNfaW5wbGFjZSA6ICgnYSwgXykgdCAtPiBmOignYSBrZXkgLT4gYm9vbCkgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXJfaW5wbGFjZSA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiB1bml0XG4gIHZhbCBmaWx0ZXJpX2lucGxhY2UgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiB1bml0XG5cbiAgKCoqIFttYXBfaW5wbGFjZSB0IH5mXSBhcHBsaWVzIFtmXSB0byBhbGwgZWxlbWVudHMgaW4gW3RdLCB0cmFuc2Zvcm1pbmcgdGhlbSBpblxuICAgICAgcGxhY2UuICopXG4gIHZhbCBtYXBfaW5wbGFjZSA6IChfLCAnYikgdCAtPiBmOignYiAtPiAnYikgLT4gdW5pdFxuXG4gIHZhbCBtYXBpX2lucGxhY2UgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYikgLT4gdW5pdFxuXG4gICgqKiBbZmlsdGVyX21hcF9pbnBsYWNlXSBjb21iaW5lcyB0aGUgZWZmZWN0cyBvZiBbbWFwX2lucGxhY2VdIGFuZCBbZmlsdGVyX2lucGxhY2VdLiAqKVxuICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXJfbWFwaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2Igb3B0aW9uKSAtPiB1bml0XG5cbiAgKCoqIFtlcXVhbCBmIHQxIHQyXSBhbmQgW3NpbWlsYXIgZiB0MSB0Ml0gYm90aCByZXR1cm4gdHJ1ZSBpZmYgW3QxXSBhbmQgW3QyXSBoYXZlIHRoZVxuICAgICAgc2FtZSBrZXlzIGFuZCBmb3IgYWxsIGtleXMgW2tdLCBbZiAoZmluZF9leG4gdDEgaykgKGZpbmRfZXhuIHQyIGspXS4gIFtlcXVhbF0gYW5kXG4gICAgICBbc2ltaWxhcl0gb25seSBkaWZmZXIgaW4gdGhlaXIgdHlwZXMuICopXG4gIHZhbCBlcXVhbCA6ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuXG4gIHZhbCBzaW1pbGFyIDogKCdiMSAtPiAnYjIgLT4gYm9vbCkgLT4gKCdhLCAnYjEpIHQgLT4gKCdhLCAnYjIpIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCAoa2V5LCBkYXRhKSBwYWlycyBmb3IgZ2l2ZW4gaGFzaHRhYmxlLiAqKVxuICB2YWwgdG9fYWxpc3QgOiAoJ2EsICdiKSB0IC0+ICgnYSBrZXkgKiAnYikgbGlzdFxuXG5cbiAgKCoqIFtyZW1vdmVfaWZfemVyb10ncyBkZWZhdWx0IGlzIFtmYWxzZV0uICopXG4gIHZhbCBpbmNyIDogP2J5OmludCAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAtPiAoJ2EsIGludCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuXG4gIHZhbCBkZWNyIDogP2J5OmludCAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAtPiAoJ2EsIGludCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE11bHRpID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuXG4gICgqKiBbYWRkX211bHRpIHQgfmtleSB+ZGF0YV0gaWYgW2tleV0gaXMgcHJlc2VudCBpbiB0aGUgdGFibGUgdGhlbiBjb25zXG4gICAgICBbZGF0YV0gb24gdGhlIGxpc3QsIG90aGVyd2lzZSBhZGQgW2tleV0gd2l0aCBhIHNpbmdsZSBlbGVtZW50IGxpc3QuICopXG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXRcblxuICAoKiogW3JlbW92ZV9tdWx0aSB0IGtleV0gdXBkYXRlcyB0aGUgdGFibGUsIHJlbW92aW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0IGJvdW5kIHRvXG4gICAgICBba2V5XS4gSWYgdGhlIGxpc3QgaGFzIG9ubHkgb25lIGVsZW1lbnQgKG9yIGlzIGVtcHR5KSB0aGVuIHRoZSBiaW5kaW5nIGlzXG4gICAgICByZW1vdmVkLiAqKVxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCBfIGxpc3QpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcblxuICAoKiogW2ZpbmRfbXVsdGkgdCBrZXldIHJldHVybnMgdGhlIGVtcHR5IGxpc3QgaWYgW2tleV0gaXMgbm90IHByZXNlbnQgaW4gdGhlIHRhYmxlLFxuICAgICAgcmV0dXJucyBbdF0ncyB2YWx1ZXMgZm9yIFtrZXldIG90aGVyd2lzZS4gKilcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4gJ2Ega2V5IC0+ICdiIGxpc3RcbmVuZFxuXG50eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zID1cbiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgLT4gJ2tleSBLZXkudFxuICAtPiAnelxuXG50eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgLT4gJ3pcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBjcmVhdGUgOiAoJ2Ega2V5LCAnYiwgdW5pdCAtPiAoJ2EsICdiKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIGtleSBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICgnYSBrZXksICdiLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2Ega2V5LCAnYiwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAoJ2Ega2V5LCAnYiBsaXN0LCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gKCdhLCAnYiBsaXN0KSB0KSBjcmVhdGVfb3B0aW9uc1xuXG5cbiAgKCoqIHtbIGNyZWF0ZV9tYXBwZWQgZ2V0X2tleSBnZXRfZGF0YSBbeDEsLi4uLHhuXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgZ2V0X2RhdGEgeDE7IC4uLjsgZ2V0X2tleSB4biwgZ2V0X2RhdGEgeG5dIF19ICopXG4gIHZhbCBjcmVhdGVfbWFwcGVkXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAgICAgLT4gJ3IgbGlzdFxuICAgICAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGtleSBsaXN0IF0gKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG5cbiAgKCoqIHtbIGNyZWF0ZV93aXRoX2tleSB+Z2V0X2tleSBbeDEsLi4uLHhuXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgeDE7IC4uLjsgZ2V0X2tleSB4biwgeG5dIF19ICopXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdyXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSlcbiAgICAgICAgLT4gJ3IgbGlzdFxuICAgICAgICAtPiBbIGBPayBvZiAoJ2EsICdyKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGtleSBsaXN0IF0gKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdyXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSkgLT4gJ3IgbGlzdCAtPiAoJ2EsICdyKSB0IE9yX2Vycm9yLnQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfZXhuXG4gICAgOiAoJ2Ega2V5LCAnciwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KSAtPiAnciBsaXN0IC0+ICgnYSwgJ3IpIHQpIGNyZWF0ZV9vcHRpb25zXG5cblxuICB2YWwgZ3JvdXBcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSlcbiAgICAgICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgICAgICAtPiBjb21iaW5lOignYiAtPiAnYiAtPiAnYilcbiAgICAgICAgLT4gJ3IgbGlzdFxuICAgICAgICAtPiAoJ2EsICdiKSB0IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9ycyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICAoKiogezIgQ3JlYXRvcnN9ICopXG5cbiAgKCoqIFRoZSBtb2R1bGUgeW91IHBhc3MgdG8gW2NyZWF0ZV0gbXVzdCBoYXZlIGEgdHlwZSB0aGF0IGlzIGhhc2hhYmxlLCBzZXhwYWJsZSwgYW5kXG4gICAgICBjb21wYXJhYmxlLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIEludCk7O1xuICAgICAgICAtIDogKGludCwgJ19hKSBIYXNodGJsLnQgPSA8YWJzdHI+OztcbiAgICAgIHZ9ICopXG4gIHZhbCBjcmVhdGVcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgICBIYXNodGJsLm9mX2FsaXN0IChtb2R1bGUgSW50KSBbKDMsIFwic29tZXRoaW5nXCIpOyAoMiwgXCJ3aGF0ZXZlclwiKV1cbiAgICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5IG9mIGludCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYE9rIDxhYnN0cj5cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogV2hlcmVhcyBbb2ZfYWxpc3RdIHdpbGwgcmVwb3J0IFtEdXBsaWNhdGVfa2V5XSBubyBtYXR0ZXIgaG93IG1hbnkgZHVwcyB0aGVyZSBhcmUgaW5cbiAgICAgIHlvdXIgbGlzdCwgW29mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc10gd2lsbCByZXBvcnQgZWFjaCBhbmQgZXZlcnkgZHVwbGljYXRlIGVudHJ5LlxuXG4gICAgICBGb3IgZXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgSGFzaHRibC5vZl9hbGlzdCAobW9kdWxlIEludCkgWygxLCBcImZvb1wiKTsgKDEsIFwiYmFyXCIpOyAoMiwgXCJmb29cIik7ICgyLCBcImJhclwiKV07O1xuICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleSBvZiBpbnQgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBEdXBsaWNhdGVfa2V5IDFcblxuICAgICAgICBIYXNodGJsLm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyAobW9kdWxlIEludCkgWygxLCBcImZvb1wiKTsgKDEsIFwiYmFyXCIpOyAoMiwgXCJmb29cIik7ICgyLCBcImJhclwiKV07O1xuICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleXMgb2YgaW50IGxpc3QgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBEdXBsaWNhdGVfa2V5cyBbMTsgMl1cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSB7eyFNdWx0aX0gXCJtdWx0aVwifSBoYXNodGFibGUsIGkuZS4sIGEgaGFzaHRhYmxlIHdoZXJlIGVhY2gga2V5IHBvaW50cyB0byBhXG4gICAgICBsaXN0IHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLiBTbyBpbnN0ZWFkIG9mIHNob3J0LWNpcmN1aXRpbmcgd2l0aCBhXG4gICAgICBbYER1cGxpY2F0ZV9rZXldIHZhcmlhbnQgb24gZHVwbGljYXRlcywgYXMgaW4gW29mX2FsaXN0XSwgW29mX2FsaXN0X211bHRpXSBmb2xkc1xuICAgICAgdGhvc2UgdmFsdWVzIGludG8gYSBsaXN0IGZvciB0aGUgZ2l2ZW4ga2V5OlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X211bHRpIChtb2R1bGUgSW50KSBbKDEsIFwiYVwiKTsgKDEsIFwiYlwiKTsgKDIsIFwiY1wiKTsgKDIsIFwiZFwiKV07O1xuICAgICAgdmFsIGggOiAoaW50LCBzdHJpbmcgbGlzdCkgSGFzaHRibC50ID0gPGFic3RyPlxuXG4gICAgICBIYXNodGJsLmZpbmRfZXhuIGggMTs7XG4gICAgICAtIDogc3RyaW5nIGxpc3QgPSBbXCJiXCI7IFwiYVwiXVxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiIGxpc3QpIHRcblxuICAoKiogQXBwbGllcyB0aGUgW2dldF9rZXldIGFuZCBbZ2V0X2RhdGFdIGZ1bmN0aW9ucyB0byB0aGUgWydyIGxpc3RdIHRvIGNyZWF0ZSB0aGVcbiAgICAgIGluaXRpYWwga2V5cyBhbmQgdmFsdWVzLCByZXNwZWN0aXZlbHksIGZvciB0aGUgbmV3IGhhc2h0YWJsZS5cblxuICAgICAge1sgY3JlYXRlX21hcHBlZCBnZXRfa2V5IGdldF9kYXRhIFt4MTsuLi47eG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCBnZXRfZGF0YSB4MTsgLi4uOyBnZXRfa2V5IHhuLCBnZXRfZGF0YSB4bl1cbiAgICAgIF19XG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIGxldCBoID1cbiAgICAgICAgICBIYXNodGJsLmNyZWF0ZV9tYXBwZWQgKG1vZHVsZSBJbnQpXG4gICAgICAgICAgICB+Z2V0X2tleTooZnVuIHggLT4geClcbiAgICAgICAgICAgIH5nZXRfZGF0YTooZnVuIHggLT4geCArIDEpXG4gICAgICAgICAgIFsxOyAyOyAzXTs7XG4gICAgICAgIHZhbCBoIDogWyBgRHVwbGljYXRlX2tleXMgb2YgaW50IGxpc3QgfCBgT2sgb2YgKGludCwgaW50KSBIYXNodGJsLnQgXSA9IGBPayA8YWJzdHI+XG5cbiAgICAgICAgbGV0IGggPVxuICAgICAgICAgIG1hdGNoIGggd2l0aFxuICAgICAgICAgIHwgYE9rIHggLT4geFxuICAgICAgICAgIHwgYER1cGxpY2F0ZV9rZXlzIF8gLT4gZmFpbHdpdGggXCJcIlxuICAgICAgICBpblxuICAgICAgICBIYXNodGJsLmZpbmRfZXhuIGggMTs7XG4gICAgICAgIC0gOiBpbnQgPSAyXG4gICAgICB2fSAqKVxuICB2YWwgY3JlYXRlX21hcHBlZFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICAoKioge1sgY3JlYXRlX3dpdGhfa2V5IH5nZXRfa2V5IFt4MTsuLi47eG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCB4MTsgLi4uOyBnZXRfa2V5IHhuLCB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV93aXRoX2tleVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdyKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAncikgdCBPcl9lcnJvci50XG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9leG5cbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAncikgdFxuXG4gICgqKiBMaWtlIFtjcmVhdGVfbWFwcGVkXSwgYXBwbGllcyB0aGUgW2dldF9rZXldIGFuZCBbZ2V0X2RhdGFdIGZ1bmN0aW9ucyB0byB0aGUgWydyXG4gICAgICBsaXN0XSB0byBjcmVhdGUgdGhlIGluaXRpYWwga2V5cyBhbmQgdmFsdWVzLCByZXNwZWN0aXZlbHksIGZvciB0aGUgbmV3IGhhc2h0YWJsZSAtLVxuICAgICAgYW5kIHRoZW4sIGxpa2UgW2FkZF9tdWx0aV0sIGZvbGRzIHRvZ2V0aGVyIHZhbHVlcyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUga2V5cy4gSGVyZSxcbiAgICAgIHRob3VnaCwgdGhlIGZ1bmN0aW9uIHVzZWQgZm9yIHRoZSBmb2xkaW5nIGlzIGdpdmVuIGJ5IFtjb21iaW5lXSAoaW5zdGVhZCBvZiBqdXN0XG4gICAgICBiZWluZyBhIFtjb25zXSkuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgICBIYXNodGJsLmdyb3VwIChtb2R1bGUgSW50KVxuICAgICAgICAgICB+Z2V0X2tleTooZnVuIHggLT4geCAvIDIpXG4gICAgICAgICAgIH5nZXRfZGF0YTooZnVuIHggLT4geClcbiAgICAgICAgICAgfmNvbWJpbmU6KGZ1biB4IHkgLT4geCAqIHkpXG4gICAgICAgICAgICBbIDE7IDI7IDM7IDRdXG4gICAgICAgICB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWygyLCA0KTsgKDEsIDYpOyAoMCwgMSldXG4gICAgICAgdn0gKilcbiAgdmFsIGdyb3VwXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgIC0+IGNvbWJpbmU6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N1Ym1vZHVsZXMgPSBzaWdcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbiAgdmFsIGhhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+ICdhIC0+IGludFxuXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gICgqKiBXZSBwcm92aWRlIGEgW3NleHBfb2ZfdF0gYnV0IG5vdCBhIFt0X29mX3NleHBdIGZvciB0aGlzIHR5cGUgYmVjYXVzZSBvbmUgbmVlZHMgdG8gYmVcbiAgICAgIGV4cGxpY2l0IGFib3V0IHRoZSBoYXNoIGFuZCBjb21wYXJpc29uIGZ1bmN0aW9ucyB1c2VkIHdoZW4gY3JlYXRpbmcgYSBoYXNodGFibGUuXG4gICAgICBOb3RlIHRoYXQgW0hhc2h0YmwuUG9seS50XSBkb2VzIGhhdmUgW1tAQGRlcml2aW5nIHNleHBdXSwgYW5kIHVzZXMgT0NhbWwncyBidWlsdC1pblxuICAgICAgcG9seW1vcnBoaWMgY29tcGFyaXNvbiBhbmQgYW5kIHBvbHltb3JwaGljIGhhc2hpbmcuICopXG4gIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2IgLT4gU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHAudFxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCAoKiogQGlubGluZSAqKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA9ICdhXG4gICgqKiBAaW5saW5lICopXG5cblxuICBpbmNsdWRlIE11bHRpIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgKCoqIEBpbmxpbmUgKilcblxuICB2YWwgaGFzaGFibGVfcyA6ICgna2V5LCBfKSB0IC0+ICdrZXkgS2V5LnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hclxuICAgIDogICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgaGFzaGFibGUgOiAnYSBIYXNoYWJsZS50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAnYSBrZXkgPSAnYVxuICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBpbmNsdWRlIEFjY2Vzc29ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gIGluY2x1ZGUgTXVsdGkgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuZW5kXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnaywgJ3YpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgS2V5LlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxuICB2YWwgc2V4cF9vZl9tX190XG4gICAgOiAgKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoJ3YgLT4gU2V4cC50KVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnaywgJ3YpIHRcblxuICB2YWwgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAobW9kdWxlIE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGVxdWFsX21fX3RcbiAgICA6ICAobW9kdWxlIEVxdWFsX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBib29sXG5lbmRcblxubW9kdWxlIHR5cGUgSGFzaHRibCA9IHNpZ1xuICAoKiogQSBoYXNoIHRhYmxlIGlzIGEgbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSBpbXBsZW1lbnRpbmcgYSBtYXAgYmV0d2VlbiBrZXlzIGFuZCB2YWx1ZXMuXG4gICAgICBJdCBzdXBwb3J0cyBjb25zdGFudC10aW1lIGxvb2t1cCBhbmQgaW4tcGxhY2UgbW9kaWZpY2F0aW9uLlxuXG4gICAgICB7MSBVc2FnZX1cblxuICAgICAgQXMgYSBzaW1wbGUgZXhhbXBsZSwgd2UnbGwgY3JlYXRlIGEgaGFzaCB0YWJsZSB3aXRoIHN0cmluZyBrZXlzIHVzaW5nIHRoZVxuICAgICAge3shY3JlYXRlfVtjcmVhdGVdfSBjb25zdHJ1Y3Rvciwgd2hpY2ggZXhwZWN0cyBhIG1vZHVsZSBkZWZpbmluZyB0aGUga2V5J3MgdHlwZTpcblxuICAgICAge1tcbiAgICAgICAgbGV0IGggPSBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIFN0cmluZyk7O1xuICAgICAgICB2YWwgaCA6IChzdHJpbmcsICdfYSkgSGFzaHRibC50ID0gPGFic3RyPlxuICAgICAgXX1cblxuICAgICAgV2UgY2FuIHNldCB0aGUgdmFsdWVzIG9mIGluZGl2aWR1YWwga2V5cyB3aXRoIHt7IXNldH1bc2V0XX0uIElmIHRoZSBrZXkgYWxyZWFkeSBoYXNcbiAgICAgIGEgdmFsdWUsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG5cbiAgICAgIHt2XG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJmb29cIiB+ZGF0YTo1OztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiZm9vXCIgfmRhdGE6Njs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImJhclwiIH5kYXRhOjY7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuICAgICAgdn1cblxuICAgICAgV2UgY2FuIGFjY2VzcyB2YWx1ZXMgYnkga2V5LCBvciBkdW1wIGFsbCBvZiB0aGUgaGFzaCB0YWJsZSdzIGRhdGE6XG5cbiAgICAgIHt2XG4gICAgICBIYXNodGJsLmZpbmQgaCBcImZvb1wiOztcbiAgICAgIC0gOiBpbnQgb3B0aW9uID0gU29tZSA2XG5cbiAgICAgIEhhc2h0YmwuZmluZF9leG4gaCBcImZvb1wiOztcbiAgICAgIC0gOiBpbnQgPSA2XG5cbiAgICAgIEhhc2h0YmwudG9fYWxpc3QgaDs7XG4gICAgICAtIDogKHN0cmluZyAqIGludCkgbGlzdCA9IFsoXCJmb29cIiwgNik7IChcImJhclwiLCA2KV1cbiAgICAgIHZ9XG5cbiAgICAgIHt7IWNoYW5nZX1bY2hhbmdlXX0gbGV0cyB1cyBjaGFuZ2UgYSBrZXkncyB2YWx1ZSBieSBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb246XG5cbiAgICAgIHt2XG4gICAgICBIYXNodGJsLmNoYW5nZSBoIFwiZm9vXCIgKGZ1biB4IC0+XG4gICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gU29tZSAoeCAqIDIpXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICk7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGg7O1xuICAgICAgLSA6IChzdHJpbmcgKiBpbnQpIGxpc3QgPSBbKFwiZm9vXCIsIDEyKTsgKFwiYmFyXCIsIDYpXVxuICAgICAgdn1cblxuXG4gICAgICBXZSBjYW4gdXNlIHt7IW1lcmdlfVttZXJnZV19IHRvIG1lcmdlIHR3byBoYXNodGFibGVzIHdpdGggZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxuICAgICAgaG93IHdlIGNob29zZSB2YWx1ZXMgd2hlbiBhIGtleSBpcyBwcmVzZW50IGluIHRoZSBmaXJzdCAoXCJsZWZ0XCIpIGhhc2h0YWJsZSwgdGhlXG4gICAgICBzZWNvbmQgKFwicmlnaHRcIiksIG9yIGJvdGguIEhlcmUsIHdlJ2xsIGNvbnMgdGhlIHZhbHVlcyB3aGVuIGJvdGggaGFzaHRhYmxlcyBoYXZlIGFcbiAgICAgIGtleTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoMSA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDUpOyAoMiwgMzIzMildIGluXG4gICAgICBsZXQgaDIgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCAzKV0gaW5cbiAgICAgIEhhc2h0YmwubWVyZ2UgaDEgaDIgfmY6KGZ1biB+a2V5Ol8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBgTGVmdCB4IC0+IFNvbWUgKGBMZWZ0IHgpXG4gICAgICAgIHwgYFJpZ2h0IHggLT4gU29tZSAoYFJpZ2h0IHgpXG4gICAgICAgIHwgYEJvdGggKHgsIHkpIC0+IGlmIHg9eSB0aGVuIE5vbmUgZWxzZSBTb21lIChgQm90aCAoeCx5KSlcbiAgICAgICkgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAtIDogKGludCAqIFs+IGBCb3RoIG9mIGludCAqIGludCB8IGBMZWZ0IG9mIGludCB8IGBSaWdodCBvZiBpbnQgXSkgbGlzdCA9XG4gICAgICBbKDIsIGBMZWZ0IDMyMzIpOyAoMSwgYEJvdGggKDUsIDMpKV1cbiAgICAgIHZ9XG5cbiAgICAgIHsxIEludGVyZmFjZX0gKilcblxuICBpbmNsdWRlIFNfd2l0aG91dF9zdWJtb2R1bGVzICgqKiBAaW5saW5lICopXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzID0gQWNjZXNzb3JzXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzID0gQ3JlYXRvcnNcbiAgbW9kdWxlIHR5cGUgTXVsdGkgPSBNdWx0aVxuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgU193aXRob3V0X3N1Ym1vZHVsZXMgPSBTX3dpdGhvdXRfc3VibW9kdWxlc1xuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcblxuICBtb2R1bGUgS2V5ID0gS2V5XG4gIG1vZHVsZSBNZXJnZV9pbnRvX2FjdGlvbiA9IE1lcmdlX2ludG9fYWN0aW9uXG5cbiAgdHlwZSBub25yZWMgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnMgPSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc1xuXG4gIG1vZHVsZSBDcmVhdG9ycyAoS2V5IDogc2lnXG4gICAgICB0eXBlICdhIHRcblxuICAgICAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBLZXkudCkgLT4gKFNleHAudCAtPiAnYikgLT4gU2V4cC50IC0+ICgnYSwgJ2IpIHRfXG5cbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0X1xuICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAgICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIGVuZFxuXG4gIG1vZHVsZSBQb2x5IDogU19wb2x5IHdpdGggdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF90YWJsZSA9IGludCBIYXNodGJsLk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfdGFibGUgPSAoU3RyaW5nLnQsIGludCkgSGFzaHRibC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbaW50IEhhc2h0YmwuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmRcbiAgICAgIHN5bnRheCBkb2Vzbid0IChiZWNhdXNlIFt0X29mX3NleHBdIGRvZXNuJ3Qga25vdyB3aGF0IGNvbXBhcmlzb24vaGFzaCBmdW5jdGlvbiB0b1xuICAgICAgdXNlKS4gKilcbiAgbW9kdWxlIE0gKEsgOiBULlQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2KSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAoKiovKiopXG5cbiAgKCpfIFNlZSB0aGUgSmFuZSBTdHJlZXQgU3R5bGUgR3VpZGUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIFtQcml2YXRlXSBzdWJtb2R1bGVzOlxuXG4gICAgaHR0cHM6Ly9vcGVuc291cmNlLmphbmVzdHJlZXQuY29tL3N0YW5kYXJkcy8jcHJpdmF0ZS1zdWJtb2R1bGVzICopXG4gIG1vZHVsZSBQcml2YXRlIDogc2lnXG4gICAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcblxuICAgIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgICB2YWwgaGFzaGFibGUgOiAoJ2tleSwgXykgdCAtPiAna2V5IEhhc2hhYmxlLnRcbiAgZW5kXG5lbmRcbiIsIigqIEEgZmV3IHNtYWxsIHRoaW5ncyBjb3BpZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBCYXNlIGJlY2F1c2UgdGhleSBkZXBlbmQgb24gdXMsIHNvIHdlXG4gICBjYW4ndCB1c2UgdGhlbS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIEl0cyBpbXBvcnRhbnQgdGhhdCBFbXB0eSBoYXZlIG5vIGFyZ3MuIEl0J3MgdGVtcHRpbmcgdG8gbWFrZSB0aGlzIHR5cGUgYSByZWNvcmRcbiAgIChlLmcuIHRvIGhvbGQgdGhlIGNvbXBhcmUgZnVuY3Rpb24pLCBidXQgYSBsb3Qgb2YgbWVtb3J5IGlzIHNhdmVkIGJ5IEVtcHR5IGJlaW5nIGFuXG4gICBpbW1lZGlhdGUsIHNpbmNlIGFsbCB1bnVzZWQgYnVja2V0cyBpbiB0aGUgaGFzaHRibCBkb24ndCB1c2UgYW55IG1lbW9yeSAoYmVzaWRlcyB0aGVcbiAgIGFycmF5IGNlbGwpICopXG50eXBlICgnaywgJ3YpIHQgPVxuICB8IEVtcHR5XG4gIHwgTm9kZSBvZlxuICAgICAgeyBtdXRhYmxlIGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICA7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgOyBtdXRhYmxlIGhlaWdodCA6IGludFxuICAgICAgOyBtdXRhYmxlIHJpZ2h0IDogKCdrLCAndikgdFxuICAgICAgfVxuICB8IExlYWYgb2ZcbiAgICAgIHsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICB9XG5cbmxldCBlbXB0eSA9IEVtcHR5XG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gdHJ1ZVxuICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuOztcblxubGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IExlYWYgXyAtPiAxXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodDsgcmlnaHQgPSBfIH0gLT4gaGVpZ2h0XG47O1xuXG5sZXQgaW52YXJpYW50IGNvbXBhcmUgPVxuICBsZXQgbGVnYWxfbGVmdF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgbGVmdF9rZXkga2V5IDwgMClcbiAgaW5cbiAgbGV0IGxlZ2FsX3JpZ2h0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIHJpZ2h0X2tleSBrZXkgPiAwKVxuICBpblxuICBsZXQgcmVjIGludiA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSB8IExlYWYgXyAtPiAoKVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGs7IHZhbHVlID0gXzsgaGVpZ2h0ID0gaDsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGhsLCBociA9IGhlaWdodCBsZWZ0LCBoZWlnaHQgcmlnaHQgaW5cbiAgICAgIGludiBsZWZ0O1xuICAgICAgaW52IHJpZ2h0O1xuICAgICAgbGVnYWxfbGVmdF9rZXkgayBsZWZ0O1xuICAgICAgbGVnYWxfcmlnaHRfa2V5IGsgcmlnaHQ7XG4gICAgICBhc3NlcnQgKGggPSBJbnQubWF4IGhsIGhyICsgMSk7XG4gICAgICBhc3NlcnQgKGFicyAoaGwgLSBocikgPD0gMilcbiAgaW5cbiAgaW52XG47O1xuXG5sZXQgaW52YXJpYW50IHQgfmNvbXBhcmUgPSBpbnZhcmlhbnQgY29tcGFyZSB0XG5cbigqIEluIHRoZSBmb2xsb3dpbmcgY29tbWVudHMsXG4gICAndCBpcyBiYWxhbmNlZCcgbWVhbnMgdGhhdCAnaW52YXJpYW50IHQnIGRvZXMgbm90XG4gICByYWlzZSBhbiBleGNlcHRpb24uICBUaGlzIGltcGxpZXMgb2YgY291cnNlIHRoYXQgZWFjaCBub2RlJ3MgaGVpZ2h0IGZpZWxkIGlzXG4gICBjb3JyZWN0LlxuICAgJ3QgaXMgYmFsYW5jZWFibGUnIG1lYW5zIHRoYXQgaGVpZ2h0IG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBvZiB0XG4gICBkaWZmZXIgYnkgYXQgbW9zdCAzLiAqKVxuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBoYXZlIGNvcnJlY3QgaGVpZ2h0c1xuICAgQHBvc3Q6IG91dHB1dCBoYXMgdGhlIGNvcnJlY3QgaGVpZ2h0ICopXG5sZXQgdXBkYXRlX2hlaWdodCA9IGZ1bmN0aW9uXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IG9sZF9oZWlnaHQ7IHJpZ2h0IH0gYXMgeCkgLT5cbiAgICBsZXQgbmV3X2hlaWdodCA9IEludC5tYXggKGhlaWdodCBsZWZ0KSAoaGVpZ2h0IHJpZ2h0KSArIDEgaW5cbiAgICBpZiBuZXdfaGVpZ2h0IDw+IG9sZF9oZWlnaHQgdGhlbiB4LmhlaWdodCA8LSBuZXdfaGVpZ2h0XG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBhcmUgYmFsYW5jZWRcbiAgIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwb3N0OiBvdXRwdXQgaXMgYmFsYW5jZWQgKGluIHBhcnRpY3VsYXIsIGhlaWdodCBpcyBjb3JyZWN0KSAqKVxubGV0IGJhbGFuY2UgdHJlZSA9XG4gIG1hdGNoIHRyZWUgd2l0aFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IHRyZWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByb290X25vZGUpIC0+XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxlZnRcbiAgICBhbmQgaHIgPSBoZWlnaHQgcmlnaHQgaW5cbiAgICAoKiArIDIgaXMgY3JpdGljYWxseSBpbXBvcnRhbnQsIGxvd2VyaW5nIGl0IHRvIDEgd2lsbCBicmVhayB0aGUgTGVhZlxuICAgICAgIGFzc3VtcHRpb25zIGluIHRoZSBjb2RlIGJlbG93LCBhbmQgd2lsbCBmb3JjZSB1cyB0byBwcm9tb3RlIGxlYWYgbm9kZXMgaW5cbiAgICAgICB0aGUgYmFsYW5jZSByb3V0aW5lLiBJdCdzIGFsc28gZmFzdGVyLCBzaW5jZSBpdCB3aWxsIGJhbGFuY2UgbGVzcyBvZnRlbi5cbiAgICAgICBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBjb2RlIGlzIGRlbGljYXRlLiAgVGhlIHVwZGF0ZV9oZWlnaHQgY2FsbHMgbXVzdFxuICAgICAgIG9jY3VyIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzaW5jZSB1cGRhdGVfaGVpZ2h0IGFzc3VtZXMgaXRzIGNoaWxkcmVuIGhhdmVcbiAgICAgICB0aGUgY29ycmVjdCBoZWlnaHRzLiAgKilcbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbGVmdCB3aXRoXG4gICAgICAoKiBJdCBjYW5ub3QgYmUgYSBsZWFmLCBiZWNhdXNlIGV2ZW4gaWYgcmlnaHQgaXMgZW1wdHksIGEgbGVhZlxuICAgICAgICAgaXMgb25seSBoZWlnaHQgMSAqKVxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSBsZWZ0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyBsZWZ0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCBsZWZ0X25vZGVfbGVmdCA+PSBoZWlnaHQgbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgIGxlZnQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGlmIHJpZ2h0IGlzIGEgbGVhZiwgdGhlbiBsZWZ0IG11c3QgYmUgZW1wdHkuIFRoYXQgbWVhbnNcbiAgICAgICAgICAgICBoZWlnaHQgaXMgMi4gRXZlbiBpZiBociBpcyBlbXB0eSB3ZSBzdGlsbCBjYW4ndCBnZXQgaGVyZS4gKilcbiAgICAgICAgICBtYXRjaCBsZWZ0X25vZGVfcmlnaHQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBscl9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gbHJfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgbHJfbm9kZSkgLT5cbiAgICAgICAgICAgIGxlZnRfbm9kZS5yaWdodCA8LSBscl9sZWZ0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLmxlZnQgPC0gbHJfcmlnaHQ7XG4gICAgICAgICAgICBscl9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgICBscl9ub2RlLmxlZnQgPC0gbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdF9ub2RlX3JpZ2h0O1xuICAgICAgICAgICAgbGVmdF9ub2RlX3JpZ2h0KSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSByaWdodCBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICBtYXRjaCByaWdodCB3aXRoXG4gICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBOb2RlXG4gICAgICAgICAgKHsgbGVmdCA9IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSByaWdodF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgcmlnaHRfbm9kZSkgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJpZ2h0X25vZGVfcmlnaHQgPj0gaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgICAgICBtYXRjaCByaWdodF9ub2RlX2xlZnQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBybF9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gcmxfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgcmxfbm9kZSkgLT5cbiAgICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSBybF9yaWdodDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSBybF9sZWZ0O1xuICAgICAgICAgICAgcmxfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgICBybF9ub2RlLnJpZ2h0IDwtIHJpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgICAgcmlnaHRfbm9kZV9sZWZ0KSlcbiAgICBlbHNlIChcbiAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgIHRyZWUpXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAocmlnaHQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5sZXQgc2V0X2xlZnQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCBsZWZ0IHRyZWUgdGhlbiAoKSBlbHNlIHIubGVmdCA8LSB0cmVlO1xuICAgIHVwZGF0ZV9oZWlnaHQgbm9kZVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAobGVmdCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9yaWdodCBub2RlIHRyZWUgPVxuICBsZXQgdHJlZSA9IGJhbGFuY2UgdHJlZSBpblxuICBtYXRjaCBub2RlIHdpdGhcbiAgfCBOb2RlICh7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcikgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHJpZ2h0IHRyZWUgdGhlbiAoKSBlbHNlIHIucmlnaHQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdCBpcyBiYWxhbmNlZC5cbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWQsIHdpdGggbmV3IG5vZGUgaW5zZXJ0ZWRcbiAgIEBwb3N0OiAhYWRkZWQgPSB0cnVlIGlmZiB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IHRyZWUgY2hhbmdlZC4gICopXG5sZXQgYWRkID1cbiAgbGV0IHJlYyBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBMZWFmICh7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsnIGsgaW5cbiAgICAgICgqIFRoaXMgY29tcGFyZSBpcyByZXZlcnNlZCBvbiBwdXJwb3NlLCB3ZSBhcmUgcHJldGVuZGluZ1xuICAgICAgICAgdGhhdCB0aGUgbGVhZiB3YXMganVzdCBpbnNlcnRlZCBpbnN0ZWFkIG9mIHRoZSBvdGhlciB3YXlcbiAgICAgICAgIHJvdW5kLCB0aGF0IHdheSB3ZSBvbmx5IGFsbG9jYXRlIG9uZSBub2RlLiAqKVxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdjtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgICBpZiBjIDwgMFxuICAgICAgICB0aGVuIE5vZGUgeyBsZWZ0ID0gdDsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IEVtcHR5IH1cbiAgICAgICAgZWxzZSBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gdCB9KVxuICAgIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdilcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gc2V0X2xlZnQgdCAoYWRkIGxlZnQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdilcbiAgICAgIGVsc2Ugc2V0X3JpZ2h0IHQgKGFkZCByaWdodCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2KTtcbiAgICAgIHRcbiAgaW5cbiAgZnVuIHQgfnJlcGxhY2UgfmNvbXBhcmUgfmFkZGVkIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQgdCA9IGFkZCB0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrZXkgZGF0YSBpblxuICAgIGlmICFhZGRlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHRcbjs7XG5cbmxldCByZWMgZmlyc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IGZpcnN0IGxcbjs7XG5cbmxldCByZWMgbGFzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT4gU29tZSAoaywgdilcbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSByIH0gLT4gbGFzdCByXG47O1xuXG5cbmxldFtAaW5saW5lIGFsd2F5c10gcmVjIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMlxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9ub3RfZm91bmRcbiAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlIGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlXG4gICAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgIChpZiBjIDwgMCB0aGVuIGxlZnQgZWxzZSByaWdodClcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAga1xuICAgICAgICBhcmcxXG4gICAgICAgIGFyZzJcbiAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgIH5pZl9mb3VuZFxuICAgICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCBkYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCBkYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCBkYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtID1cbiAgbGV0IGlmX2ZvdW5kIF8gPSB0cnVlIGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IGZhbHNlIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCByZW1vdmUgPVxuICBsZXQgcmVjIG1pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiBfIC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gbWluX2VsdCBsZWZ0XG4gIGluXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IExlYWYgXyAtPiBFbXB0eSAoKiBUaGlzIG11c3QgYmUgdGhlIHJvb3QgKilcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPiByaWdodFxuICAgIHwgTm9kZSB7IGxlZnQgPSBMZWFmIF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+XG4gICAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIG5vZGUgLT5cbiAgICAgIHNldF9sZWZ0IG5vZGUgRW1wdHk7XG4gICAgICB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIChyZW1vdmVfbWluX2VsdCBsZWZ0KTtcbiAgICAgIHRyZWVcbiAgaW5cbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHRyZWUgPSBtaW5fZWx0IHQyIGluXG4gICAgICAobWF0Y2ggdHJlZSB3aXRoXG4gICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgICAgICAgbGV0IHQyID0gYmFsYW5jZSAocmVtb3ZlX21pbl9lbHQgdDIpIGluXG4gICAgICAgICBOb2RlXG4gICAgICAgICAgIHsgbGVmdCA9IHQxXG4gICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgICA7IHZhbHVlID0gdlxuICAgICAgICAgICA7IGhlaWdodCA9IEludC5tYXggKGhlaWdodCB0MSkgKGhlaWdodCB0MikgKyAxXG4gICAgICAgICAgIDsgcmlnaHQgPSB0MlxuICAgICAgICAgICB9XG4gICAgICAgfCBOb2RlIF8gYXMgbm9kZSAtPlxuICAgICAgICAgc2V0X3JpZ2h0IG5vZGUgKHJlbW92ZV9taW5fZWx0IHQyKTtcbiAgICAgICAgIHNldF9sZWZ0IG5vZGUgdDE7XG4gICAgICAgICBub2RlKVxuICBpblxuICBsZXQgcmVjIHJlbW92ZSB0IHJlbW92ZWQgY29tcGFyZSBrID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVkIDo9IHRydWU7XG4gICAgICAgIEVtcHR5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICAgIHQpXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBtZXJnZSBsZWZ0IHJpZ2h0KVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHNldF9sZWZ0IHQgKHJlbW92ZSBsZWZ0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBzZXRfcmlnaHQgdCAocmVtb3ZlIHJpZ2h0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgaW5cbiAgZnVuIHQgfnJlbW92ZWQgfmNvbXBhcmUgayAtPiBiYWxhbmNlIChyZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgaylcbjs7XG5cbmxldCByZWMgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gaW5pdFxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YSBpbml0XG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gRW1wdHlcbiAgICAgIH0gLT4gZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IEVtcHR5XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH1cbiAgICAgIH0gLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfSB9XG4gICAgLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfVxuICAgIC0+IGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdCkpIH5mXG4gIHwgTm9kZSB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgZm9sZCByaWdodCB+aW5pdDooZiB+a2V5IH5kYXRhIChmb2xkIGxlZnQgfmluaXQgfmYpKSB+ZlxuOztcblxubGV0IHJlYyBpdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGl0ZXIgbGVmdCB+ZjtcbiAgICBmIH5rZXkgfmRhdGE7XG4gICAgaXRlciByaWdodCB+ZlxuOztcblxubGV0IHJlYyBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+ICgpXG4gIHwgTGVhZiAoeyBrZXk7IHZhbHVlIH0gYXMgdCkgLT4gdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleTsgdmFsdWU7IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgdCkgLT5cbiAgICBtYXBpX2lucGxhY2UgfmYgbGVmdDtcbiAgICB0LnZhbHVlIDwtIGYgfmtleSB+ZGF0YTp2YWx1ZTtcbiAgICBtYXBpX2lucGxhY2UgfmYgcmlnaHRcbjs7XG5cbmxldCBjaG9vc2VfZXhuID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbQXZsdHJlZS5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pXG4gIHwgTGVhZiB7IGtleTsgdmFsdWU7IF8gfSB8IE5vZGUgeyBrZXk7IHZhbHVlOyBfIH0gLT4ga2V5LCB2YWx1ZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBIYXNodGJsX2ludGZcblxubW9kdWxlIHR5cGUgS2V5ID0gS2V5LlNcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cbmxldCBoYXNoX3BhcmFtID0gSGFzaGFibGUuaGFzaF9wYXJhbVxubGV0IGhhc2ggPSBIYXNoYWJsZS5oYXNoXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxudHlwZSAoJ2ssICd2KSB0ID1cbiAgeyBtdXRhYmxlIHRhYmxlIDogKCdrLCAndikgQXZsdHJlZS50IGFycmF5XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgKCogW3JlY2VudGx5X2FkZGVkXSBpcyB0aGUgcmVmZXJlbmNlIHBhc3NlZCB0byBbQXZsdHJlZS5hZGRdLiBXZSBwdXQgaXQgaW4gdGhlIGhhc2hcbiAgICAgdGFibGUgdG8gYXZvaWQgYWxsb2NhdGluZyBpdCBhdCBldmVyeSBbc2V0XS4gKilcbiAgOyByZWNlbnRseV9hZGRlZCA6IGJvb2wgcmVmXG4gIDsgZ3Jvd3RoX2FsbG93ZWQgOiBib29sXG4gIDsgaGFzaGFibGUgOiAnayBIYXNoYWJsZS50XG4gIDsgbXV0YWJsZSBtdXRhdGlvbl9hbGxvd2VkIDogYm9vbCAoKiBTZXQgZHVyaW5nIGFsbCBpdGVyYXRpb24gb3BlcmF0aW9ucyAqKVxuICB9XG5cbnR5cGUgJ2Ega2V5ID0gJ2FcblxubGV0IHNleHBfb2Zfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdFxubGV0IGNvbXBhcmVfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmVcblxubGV0IGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQgPVxuICBpZiBub3QgdC5tdXRhdGlvbl9hbGxvd2VkIHRoZW4gZmFpbHdpdGggXCJIYXNodGJsOiBtdXRhdGlvbiBub3QgYWxsb3dlZCBkdXJpbmcgaXRlcmF0aW9uXCJcbjs7XG5cbmxldCB3aXRob3V0X211dGF0aW5nIHQgZiA9XG4gIGlmIHQubXV0YXRpb25fYWxsb3dlZFxuICB0aGVuIChcbiAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgfCB4IC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgcmFpc2UgZXhuKVxuICBlbHNlIGYgKClcbjs7XG5cbigqKiBJbnRlcm5hbGx5IHVzZSBhIG1heGltdW0gc2l6ZSB0aGF0IGlzIGEgcG93ZXIgb2YgMi4gUmV2ZXJzZXMgdGhlIGFib3ZlIHRvIGZpbmQgdGhlXG4gICAgZmxvb3IgcG93ZXIgb2YgMiBiZWxvdyB0aGUgc3lzdGVtIG1heCBhcnJheSBsZW5ndGggKilcbmxldCBtYXhfdGFibGVfbGVuZ3RoID0gSW50LmZsb29yX3BvdzIgQXJyYXkubWF4X2xlbmd0aFxuXG4oKiBUaGUgZGVmYXVsdCBzaXplIGlzIGNob3NlbiB0byBiZSAwIChhcyBvcHBvc2VkIHRvIDEyOCBhcyBpdCB3YXMgYmVmb3JlKSBiZWNhdXNlOlxuICAgLSAxMjggY2FuIGNyZWF0ZSBzdWJzdGFudGlhbCBtZW1vcnkgb3ZlcmhlYWQgKHgxMCkgd2hlbiBjcmVhdGluZyBtYW55IHRhYmxlcywgbW9zdFxuICAgICBvZiB3aGljaCBhcmUgbm90IGJpZyAoc2F5LCBpZiB5b3UgaGF2ZSBhIGhhc2h0Ymwgb2YgaGFzaHRibCkuIEFuZCBtZW1vcnkgb3ZlcmhlYWQgaXNcbiAgICAgbm90IHRoYXQgZWFzeSB0byBwcm9maWxlLlxuICAgLSBpZiBhIGhhc2h0YmwgaXMgZ29pbmcgdG8gZ3JvdywgaXQncyBub3QgY2xlYXIgd2h5IDEyOCBpcyBtYXJrZWRseSBiZXR0ZXIgdGhhbiBvdGhlclxuICAgICBzaXplcyAoaWYgeW91IGdvaW5nIHRvIHN0aWNrIDEwMDAgZWxlbWVudHMsIHlvdSdyZSBnb2luZyB0byBncm93IHRoZSBoYXNodGFibGUgb25jZVxuICAgICBvciB0d2ljZSBhbnl3YXkpXG4gICAtIGluIG90aGVyIGxhbmd1YWdlcyAobGlrZSBydXN0LCBweXRob24sIGFuZCBhcHBhcmVudGx5IGdvKSwgdGhlIGRlZmF1bHQgaXMgYWxzbyBhXG4gICAgIHNtYWxsIHNpemUuICopXG5sZXQgY3JlYXRlID8oZ3Jvd3RoX2FsbG93ZWQgPSB0cnVlKSA/KHNpemUgPSAwKSB+aGFzaGFibGUgKCkgPVxuICBsZXQgc2l6ZSA9IEludC5taW4gKEludC5tYXggMSBzaXplKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gIGxldCBzaXplID0gSW50LmNlaWxfcG93MiBzaXplIGluXG4gIHsgdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpzaXplIEF2bHRyZWUuZW1wdHlcbiAgOyBsZW5ndGggPSAwXG4gIDsgZ3Jvd3RoX2FsbG93ZWRcbiAgOyByZWNlbnRseV9hZGRlZCA9IHJlZiBmYWxzZVxuICA7IGhhc2hhYmxlXG4gIDsgbXV0YXRpb25fYWxsb3dlZCA9IHRydWVcbiAgfVxuOztcblxuKCoqIFN1cHBsZW1lbnRhbCBoYXNoLiBUaGlzIG1heSBub3QgYmUgbmVjZXNzYXJ5LCBpdCBpcyBpbnRlbmRlZCBhcyBhIGRlZmVuc2UgYWdhaW5zdCBwb29yXG4gICAgaGFzaCBmdW5jdGlvbnMsIGZvciB3aGljaCB0aGUgcG93ZXIgb2YgMiBzaXplZCB0YWJsZSB3aWxsIGJlIGVzcGVjaWFsbHkgc2Vuc2l0aXZlLlxuICAgIFdpdGggc29tZSB0ZXN0aW5nIHdlIG1heSBjaG9vc2UgdG8gYWRkIGl0LCBidXQgdGhpcyB0YWJsZSBpcyBkZXNpZ25lZCB0byBiZSByb2J1c3QgdG9cbiAgICBjb2xsaXNpb25zLCBhbmQgaW4gbW9zdCBvZiBteSB0ZXN0aW5nIHRoaXMgZGVncmFkZXMgcGVyZm9ybWFuY2UuICopXG5sZXQgX3N1cHBsZW1lbnRhbF9oYXNoIGggPVxuICBsZXQgaCA9IGggbHhvciAoKGggbHNyIDIwKSBseG9yIChoIGxzciAxMikpIGluXG4gIGggbHhvciAoaCBsc3IgNykgbHhvciAoaCBsc3IgNClcbjs7XG5cbmxldCBzbG90IHQga2V5ID1cbiAgbGV0IGhhc2ggPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmhhc2gga2V5IGluXG4gICgqIHRoaXMgaXMgYWx3YXlzIG5vbi1uZWdhdGl2ZSBiZWNhdXNlIHdlIGRvIFtsYW5kXSB3aXRoIG5vbi1uZWdhdGl2ZSBudW1iZXIgKilcbiAgaGFzaCBsYW5kIChBcnJheS5sZW5ndGggdC50YWJsZSAtIDEpXG47O1xuXG5sZXQgYWRkX3dvcmtlciB0IH5yZXBsYWNlIH5rZXkgfmRhdGEgPVxuICBsZXQgaSA9IHNsb3QgdCBrZXkgaW5cbiAgbGV0IHJvb3QgPSB0LnRhYmxlLihpKSBpblxuICBsZXQgYWRkZWQgPSB0LnJlY2VudGx5X2FkZGVkIGluXG4gIGFkZGVkIDo9IGZhbHNlO1xuICBsZXQgbmV3X3Jvb3QgPVxuICAgICgqIFRoZSBhdmwgdHJlZSBtaWdodCByZXBsYWNlIHRoZSB2YWx1ZSBbcmVwbGFjZT10cnVlXSBvciBkbyBub3RoaW5nIFtyZXBsYWNlPWZhbHNlXVxuICAgICAgIHRvIHRoZSBlbnRyeSwgaW4gdGhhdCBjYXNlIHRoZSB0YWJsZSBkaWQgbm90IGdldCBiaWdnZXIsIHNvIHdlIHNob3VsZCBub3RcbiAgICAgICBpbmNyZW1lbnQgbGVuZ3RoLCB3ZSBwYXNzIGluIHRoZSBib29sIHJlZiB0LmFkZGVkIHNvIHRoYXQgaXQgY2FuIHRlbGwgdXMgd2hldGhlclxuICAgICAgIGl0IGFkZGVkIG9yIHJlcGxhY2VkLiBXZSBkbyBpdCB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uLiBTaW5jZSB0aGUgYm9vbFxuICAgICAgIGlzIGFuIGltbWVkaWF0ZSBpdCBkb2VzIG5vdCBnbyB0aHJvdWdoIHRoZSB3cml0ZSBiYXJyaWVyLiAqKVxuICAgIEF2bHRyZWUuYWRkIH5yZXBsYWNlIHJvb3QgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIH5hZGRlZCB+a2V5IH5kYXRhXG4gIGluXG4gIGlmICFhZGRlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMTtcbiAgKCogVGhpcyBsaXR0bGUgb3B0aW1pemF0aW9uIHNhdmVzIGEgY2FtbF9tb2RpZnkgd2hlbiB0aGUgdHJlZVxuICAgICBoYXNuJ3QgYmVlbiByZWJhbGFuY2VkLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgbmV3X3Jvb3Qgcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdFxuOztcblxubGV0IG1heWJlX3Jlc2l6ZV90YWJsZSB0ID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gIGxldCBzaG91bGRfZ3JvdyA9IHQubGVuZ3RoID4gbGVuIGluXG4gIGlmIHNob3VsZF9ncm93ICYmIHQuZ3Jvd3RoX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgbGV0IG5ld19hcnJheV9sZW5ndGggPSBJbnQubWluIChsZW4gKiAyKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gICAgaWYgbmV3X2FycmF5X2xlbmd0aCA+IGxlblxuICAgIHRoZW4gKFxuICAgICAgbGV0IG5ld190YWJsZSA9IEFycmF5LmNyZWF0ZSB+bGVuOm5ld19hcnJheV9sZW5ndGggQXZsdHJlZS5lbXB0eSBpblxuICAgICAgbGV0IG9sZF90YWJsZSA9IHQudGFibGUgaW5cbiAgICAgIHQudGFibGUgPC0gbmV3X3RhYmxlO1xuICAgICAgdC5sZW5ndGggPC0gMDtcbiAgICAgIGxldCBmIH5rZXkgfmRhdGEgPSBhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9sZF90YWJsZSAtIDEgZG9cbiAgICAgICAgQXZsdHJlZS5pdGVyIG9sZF90YWJsZS4oaSkgfmZcbiAgICAgIGRvbmUpKVxuOztcblxubGV0IHNldCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhO1xuICBtYXliZV9yZXNpemVfdGFibGUgdFxuOztcblxubGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBhZGRfd29ya2VyIH5yZXBsYWNlOmZhbHNlIHQgfmtleSB+ZGF0YTtcbiAgaWYgISh0LnJlY2VudGx5X2FkZGVkKVxuICB0aGVuIChcbiAgICBtYXliZV9yZXNpemVfdGFibGUgdDtcbiAgICBgT2spXG4gIGVsc2UgYER1cGxpY2F0ZVxuOztcblxubGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgbWF0Y2ggYWRkIHQgfmtleSB+ZGF0YSB3aXRoXG4gIHwgYE9rIC0+ICgpXG4gIHwgYER1cGxpY2F0ZSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jcmVhdGUgXCJIYXNodGJsLmFkZF9leG4gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBrZXkgc2V4cF9vZl9rZXkgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IGNsZWFyIHQgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgdC50YWJsZS4oaSkgPC0gQXZsdHJlZS5lbXB0eVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSAwXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMiB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwyXG4gICAgICB0cmVlXG4gICAgICB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgICAgIGtleVxuICAgICAgfmFcbiAgICAgIH5iXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCBrZXkgLT4gZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSB0IGtleSA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGZhbHNlXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSBfIH0gLT4gY29tcGFyZV9rZXkgdCBrIGtleSA9IDBcbiAgfCB0cmVlIC0+IEF2bHRyZWUubWVtIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuOztcblxubGV0IHJlbW92ZSB0IGtleSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCBhZGRlZF9vcl9yZW1vdmVkID0gdC5yZWNlbnRseV9hZGRlZCBpblxuICBhZGRlZF9vcl9yZW1vdmVkIDo9IGZhbHNlO1xuICBsZXQgbmV3X3Jvb3QgPVxuICAgIEF2bHRyZWUucmVtb3ZlIHJvb3QgfnJlbW92ZWQ6YWRkZWRfb3JfcmVtb3ZlZCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5XG4gIGluXG4gIGlmIG5vdCAocGh5c19lcXVhbCByb290IG5ld19yb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICBpZiAhYWRkZWRfb3JfcmVtb3ZlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMVxuOztcblxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGFjYyA6PSBmIH5rZXkgfmRhdGEgIWFjY1xuICAgICAgICB8IGJ1Y2tldCAtPiBhY2MgOj0gQXZsdHJlZS5mb2xkIGJ1Y2tldCB+aW5pdDohYWNjIH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgIWFjY1xuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuICgpXG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICAgICAgICB8IGJ1Y2tldCAtPiBBdmx0cmVlLml0ZXIgYnVja2V0IH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT4gdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG1cbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGl0ZXJfa2V5cyB0IH5mID0gaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IHJlYyBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgaSA9XG4gIGxldCBhdmx0cmVlID0gdGFibGUuKGkpIGluXG4gIGlmIEF2bHRyZWUuaXNfZW1wdHkgYXZsdHJlZVxuICB0aGVuIGNob29zZV9ub25lbXB0eSB0YWJsZSAoaSArIDEpXG4gIGVsc2UgQXZsdHJlZS5jaG9vc2VfZXhuIGF2bHRyZWVcbjs7XG5cbmxldCBjaG9vc2VfZXhuIHQgPVxuICBpZiB0Lmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSGFzaHRibC5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pO1xuICBjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwXG47O1xuXG5sZXQgY2hvb3NlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDApXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2tleSBpbnZhcmlhbnRfZGF0YSB0ID1cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIEF2bHRyZWUuaW52YXJpYW50IHQudGFibGUuKGkpIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICBkb25lO1xuICBsZXQgcmVhbF9sZW4gPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBpIC0+XG4gICAgICBpbnZhcmlhbnRfa2V5IGtleTtcbiAgICAgIGludmFyaWFudF9kYXRhIGRhdGE7XG4gICAgICBpICsgMSlcbiAgaW5cbiAgYXNzZXJ0IChyZWFsX2xlbiA9IHQubGVuZ3RoKVxuOztcblxubGV0IGZpbmRfZXhuID1cbiAgbGV0IGlmX2ZvdW5kIHYgXyA9IHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBrIHQgPVxuICAgIHJhaXNlXG4gICAgICAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiSGFzaHRibC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHQuaGFzaGFibGUuc2V4cF9vZl90IGsgXSkpXG4gIGluXG4gIGxldCBmaW5kX2V4biB0IGtleSA9IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hOnQgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmb3JfYWxsaSB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IG5vdCAoZiB+a2V5IH5kYXRhKSkpXG5sZXQgZm9yX2FsbCB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gbm90IChmIGRhdGEpKSlcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gaWYgZiBkYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTooZiB+a2V5IH5kYXRhKSk7XG4gIG5ld190XG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGNvcHkgdCA9IG1hcCB0IH5mOkZuLmlkXG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgU29tZSBuZXdfZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgTm9uZSAtPiAoKSk7XG4gIG5ld190XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmaWx0ZXJfa2V5cyB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KVxuXG5sZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gIGxldCB0MCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGxldCB0MSA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggKGYgfmtleSB+ZGF0YSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IG5ld19kYXRhIC0+IHNldCB0MCB+a2V5IH5kYXRhOm5ld19kYXRhXG4gICAgfCBTZWNvbmQgbmV3X2RhdGEgLT4gc2V0IHQxIH5rZXkgfmRhdGE6bmV3X2RhdGEpO1xuICB0MCwgdDFcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaW5kX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbDJcbiAgICB0XG4gICAgaWRcbiAgICB+YTp0XG4gICAgfmI6ZGVmYXVsdFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgXyBfIC0+IGRhdGEpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuIGtleSB0IGRlZmF1bHQgLT5cbiAgICAgIGxldCBkZWZhdWx0ID0gZGVmYXVsdCAoKSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdClcbjs7XG5cbmxldCBmaW5kaV9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGwyXG4gICAgdFxuICAgIGlkXG4gICAgfmE6dFxuICAgIH5iOmRlZmF1bHRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIF8gXyAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgdCBkZWZhdWx0IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQga2V5IGluXG4gICAgICBzZXQgdCB+a2V5IH5kYXRhOmRlZmF1bHQ7XG4gICAgICBkZWZhdWx0KVxuOztcblxuKCogU29tZSBoYXNodGJsIGltcGxlbWVudGF0aW9ucyBtYXkgYmUgYWJsZSB0byBwZXJmb3JtIHRoaXMgbW9yZSBlZmZpY2llbnRseSB0aGFuIHR3b1xuICAgc2VwYXJhdGUgbG9va3VwcyAqKVxubGV0IGZpbmRfYW5kX3JlbW92ZSB0IGlkID1cbiAgbGV0IHJlc3VsdCA9IGZpbmQgdCBpZCBpblxuICBpZiBPcHRpb24uaXNfc29tZSByZXN1bHQgdGhlbiByZW1vdmUgdCBpZDtcbiAgcmVzdWx0XG47O1xuXG5cbmxldCBjaGFuZ2UgdCBpZCB+ZiA9XG4gIG1hdGNoIGYgKGZpbmQgdCBpZCkgd2l0aFxuICB8IE5vbmUgLT4gcmVtb3ZlIHQgaWRcbiAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleTppZCB+ZGF0YVxuOztcblxubGV0IHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgPVxuICBsZXQgZGF0YSA9IGYgKGZpbmQgdCBpZCkgaW5cbiAgc2V0IHQgfmtleTppZCB+ZGF0YTtcbiAgZGF0YVxuOztcblxubGV0IHVwZGF0ZSB0IGlkIH5mID0gaWdub3JlICh1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mIDogXylcblxubGV0IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5ID1cbiAgaWYgcmVtb3ZlX2lmX3plcm9cbiAgdGhlblxuICAgIGNoYW5nZSB0IGtleSB+ZjooZnVuIG9wdCAtPlxuICAgICAgbWF0Y2ggYnkgKyBPcHRpb24udmFsdWUgb3B0IH5kZWZhdWx0OjAgd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgbiAtPiBTb21lIG4pXG4gIGVsc2VcbiAgICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYnlcbiAgICAgIHwgU29tZSBpIC0+IGJ5ICsgaSlcbjs7XG5cbmxldCBpbmNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnlcbmxldCBkZWNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgKC1ieSlcblxubGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFsgZGF0YSBdXG4gICAgfCBTb21lIGwgLT4gZGF0YSA6OiBsKVxuOztcblxubGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIFtdIHwgU29tZSBbIF8gXSAtPiByZW1vdmUgdCBrZXlcbiAgfCBTb21lIChfIDo6IHRsKSAtPiBzZXQgdCB+a2V5IH5kYXRhOnRsXG47O1xuXG5sZXQgZmluZF9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlIH5zaXplICgpIGluXG4gIGxldCBkdXBlcyA9IHJlZiBbXSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgaWYgbWVtIHJlcyBrZXkgdGhlbiBkdXBlcyA6PSBrZXkgOjogIWR1cGVzIGVsc2Ugc2V0IHJlcyB+a2V5IH5kYXRhKTtcbiAgbWF0Y2ggIWR1cGVzIHdpdGhcbiAgfCBbXSAtPiBgT2sgcmVzXG4gIHwga2V5cyAtPiBgRHVwbGljYXRlX2tleXMgKExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6aGFzaGFibGUuSGFzaGFibGUuY29tcGFyZSBrZXlzKVxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgfmhhc2hhYmxlICgpIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBhZGRfbXVsdGkgcmVzIH5rZXkgfmRhdGEpO1xuICByZXNcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Qgd2l0aFxuICB8IGBPayB0IC0+IGBPayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGsgLT4gYER1cGxpY2F0ZV9rZXkgKExpc3QuaGRfZXhuIGspXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IGBPayB2IC0+IFJlc3VsdC5PayB2XG4gIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3IgXCJIYXNodGJsLm9mX2FsaXN0X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBzZXhwX29mX2tleVxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBSZXN1bHQuT2sgdiAtPiB2XG4gIHwgUmVzdWx0LkVycm9yIGUgLT4gRXJyb3IucmFpc2UgZVxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IHRvX2FsaXN0IHQgPSBmb2xkIH5mOihmdW4gfmtleSB+ZGF0YSBsaXN0IC0+IChrZXksIGRhdGEpIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIHRcbiAgfD4gdG9fYWxpc3RcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKGsxLCBfKSAoazIsIF8pIC0+IHQuaGFzaGFibGUuY29tcGFyZSBrMSBrMilcbiAgfD4gc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhKVxuOztcblxubGV0IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID1cbiAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCkgc2V4cCBpblxuICBtYXRjaCBvZl9hbGlzdCB+aGFzaGFibGUgYWxpc3QgfnNpemU6KExpc3QubGVuZ3RoIGFsaXN0KSB3aXRoXG4gIHwgYE9rIHYgLT4gdlxuICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgIExpc3QuaXRlcjJfZXhuIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgIGlmIGhhc2hhYmxlLmNvbXBhcmUgayBrMiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiSGFzaHRibC50X29mX3NleHA6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hclxuICAgICAgKHR5cGUgayB2KVxuICAgICAgKGtfZ3JhbW1hciA6IGsgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgICAodl9ncmFtbWFyIDogdiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiAoaywgdikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QuQXNzb2MudF9zZXhwX2dyYW1tYXIga19ncmFtbWFyIHZfZ3JhbW1hcilcbjs7XG5cbmxldCBrZXlzIHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhOl8gYWNjIC0+IGtleSA6OiBhY2MpXG5sZXQgZGF0YSB0ID0gZm9sZCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgYWRkX3RvX2dyb3VwcyBncm91cHMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzID1cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByb3cgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByb3cgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHJvdyBpblxuICAgIGxldCBkYXRhID1cbiAgICAgIG1hdGNoIGZpbmQgZ3JvdXBzIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgfCBTb21lIG9sZCAtPiBjb21iaW5lIG9sZCBkYXRhXG4gICAgaW5cbiAgICBzZXQgZ3JvdXBzIH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgcm93cyA9XG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKSBpblxuICBhZGRfdG9fZ3JvdXBzIHJlcyB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgfnJvd3M7XG4gIHJlc1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhOkZuLmlkIHJvd3Ncbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgbWF0Y2ggY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyB3aXRoXG4gIHwgYE9rIHQgLT4gUmVzdWx0Lk9rIHRcbiAgfCBgRHVwbGljYXRlX2tleXMga2V5cyAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiSGFzaHRibC5jcmVhdGVfd2l0aF9rZXk6IGR1cGxpY2F0ZSBrZXlzXCJcbiAgICAgICAgIFsgXCJrZXlzXCIsIHNleHBfb2ZfbGlzdCBzZXhwX29mX2tleSBrZXlzIF0pXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBPcl9lcnJvci5va19leG4gKGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MpXG47O1xuXG5sZXQgbWVyZ2UgPVxuICBsZXQgbWF5YmVfc2V0IHQgfmtleSB+ZiBkID1cbiAgICBtYXRjaCBmIH5rZXkgZCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHYgLT4gc2V0IHQgfmtleSB+ZGF0YTp2XG4gIGluXG4gIGZ1biB0X2xlZnQgdF9yaWdodCB+ZiAtPlxuICAgIGlmIG5vdCAoSGFzaGFibGUuZXF1YWwgdF9sZWZ0Lmhhc2hhYmxlIHRfcmlnaHQuaGFzaGFibGUpXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIkhhc2h0YmwubWVyZ2U6IGRpZmZlcmVudCAnaGFzaGFibGUnIHZhbHVlc1wiO1xuICAgIGxldCBuZXdfdCA9XG4gICAgICBjcmVhdGVcbiAgICAgICAgfmdyb3d0aF9hbGxvd2VkOnRfbGVmdC5ncm93dGhfYWxsb3dlZFxuICAgICAgICB+aGFzaGFibGU6dF9sZWZ0Lmhhc2hhYmxlXG4gICAgICAgIH5zaXplOnRfbGVmdC5sZW5ndGhcbiAgICAgICAgKClcbiAgICBpblxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9sZWZ0IChmdW4gKCkgLT5cbiAgICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9yaWdodCAoZnVuICgpIC0+XG4gICAgICAgIGl0ZXJpIHRfbGVmdCB+ZjooZnVuIH5rZXkgfmRhdGE6bGVmdCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9yaWdodCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYExlZnQgbGVmdClcbiAgICAgICAgICB8IFNvbWUgcmlnaHQgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBCb3RoIChsZWZ0LCByaWdodCkpKTtcbiAgICAgICAgaXRlcmkgdF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6cmlnaHQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfbGVmdCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYFJpZ2h0IHJpZ2h0KVxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICAgKCogYWxyZWFkeSBkb25lIGFib3ZlICopKSkpO1xuICAgIG5ld190XG47O1xuXG5sZXQgbWVyZ2VfaW50byB+c3JjIH5kc3QgfmYgPVxuICBpdGVyaSBzcmMgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IGRzdF9kYXRhID0gZmluZCBkc3Qga2V5IGluXG4gICAgbGV0IGFjdGlvbiA9IHdpdGhvdXRfbXV0YXRpbmcgZHN0IChmdW4gKCkgLT4gZiB+a2V5IGRhdGEgZHN0X2RhdGEpIGluXG4gICAgbWF0Y2ggKGFjdGlvbiA6IF8gTWVyZ2VfaW50b19hY3Rpb24udCkgd2l0aFxuICAgIHwgUmVtb3ZlIC0+IHJlbW92ZSBkc3Qga2V5XG4gICAgfCBTZXRfdG8gZGF0YSAtPlxuICAgICAgKG1hdGNoIGRzdF9kYXRhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gc2V0IGRzdCB+a2V5IH5kYXRhXG4gICAgICAgfCBTb21lIGRzdF9kYXRhIC0+IGlmIG5vdCAocGh5c19lcXVhbCBkc3RfZGF0YSBkYXRhKSB0aGVuIHNldCBkc3QgfmtleSB+ZGF0YSkpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdG9fcmVtb3ZlID1cbiAgICBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjIGVsc2Uga2V5IDo6IGFjKVxuICBpblxuICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4ga2V5IC0+IHJlbW92ZSB0IGtleSlcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGZpbHRlcl9rZXlzX2lucGxhY2UgdCB+ZiA9IGZpbHRlcmlfaW5wbGFjZSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KVxuXG5sZXQgZmlsdGVyX21hcGlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IG1hcF9yZXN1bHRzID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiAoa2V5LCBmIH5rZXkgfmRhdGEpIDo6IGFjKSBpblxuICBMaXN0Lml0ZXIgbWFwX3Jlc3VsdHMgfmY6KGZ1biAoa2V5LCByZXN1bHQpIC0+XG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVtb3ZlIHQga2V5XG4gICAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleSB+ZGF0YSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgdCB+ZiA9IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIHdpdGhvdXRfbXV0YXRpbmcgdCAoZnVuICgpIC0+IEFycmF5Lml0ZXIgdC50YWJsZSB+ZjooQXZsdHJlZS5tYXBpX2lucGxhY2UgfmYpKVxuOztcblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPSBtYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBlcXVhbCBlcXVhbCB0IHQnID1cbiAgbGVuZ3RoIHQgPSBsZW5ndGggdCdcbiAgJiYgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgd2l0aG91dF9tdXRhdGluZyB0JyAoZnVuICgpIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBtYXRjaCBmaW5kIHQnIGtleSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByLnJldHVybiBmYWxzZVxuICAgICAgICB8IFNvbWUgZGF0YScgLT4gaWYgbm90IChlcXVhbCBkYXRhIGRhdGEnKSB0aGVuIHIucmV0dXJuIGZhbHNlKSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBzaW1pbGFyID0gZXF1YWxcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBjaG9vc2UgPSBjaG9vc2VcbiAgbGV0IGNob29zZV9leG4gPSBjaG9vc2VfZXhuXG4gIGxldCBjbGVhciA9IGNsZWFyXG4gIGxldCBjb3B5ID0gY29weVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlXG4gIGxldCBzZXQgPSBzZXRcbiAgbGV0IGFkZCA9IGFkZFxuICBsZXQgYWRkX2V4biA9IGFkZF9leG5cbiAgbGV0IGNoYW5nZSA9IGNoYW5nZVxuICBsZXQgdXBkYXRlID0gdXBkYXRlXG4gIGxldCB1cGRhdGVfYW5kX3JldHVybiA9IHVwZGF0ZV9hbmRfcmV0dXJuXG4gIGxldCBhZGRfbXVsdGkgPSBhZGRfbXVsdGlcbiAgbGV0IHJlbW92ZV9tdWx0aSA9IHJlbW92ZV9tdWx0aVxuICBsZXQgZmluZF9tdWx0aSA9IGZpbmRfbXVsdGlcbiAgbGV0IG1lbSA9IG1lbVxuICBsZXQgaXRlcl9rZXlzID0gaXRlcl9rZXlzXG4gIGxldCBpdGVyID0gaXRlclxuICBsZXQgaXRlcmkgPSBpdGVyaVxuICBsZXQgZXhpc3RzID0gZXhpc3RzXG4gIGxldCBleGlzdHNpID0gZXhpc3RzaVxuICBsZXQgZm9yX2FsbCA9IGZvcl9hbGxcbiAgbGV0IGZvcl9hbGxpID0gZm9yX2FsbGlcbiAgbGV0IGNvdW50ID0gY291bnRcbiAgbGV0IGNvdW50aSA9IGNvdW50aVxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgaXNfZW1wdHkgPSBpc19lbXB0eVxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXBpID0gbWFwaVxuICBsZXQgZmlsdGVyX21hcCA9IGZpbHRlcl9tYXBcbiAgbGV0IGZpbHRlcl9tYXBpID0gZmlsdGVyX21hcGlcbiAgbGV0IGZpbHRlcl9rZXlzID0gZmlsdGVyX2tleXNcbiAgbGV0IGZpbHRlciA9IGZpbHRlclxuICBsZXQgZmlsdGVyaSA9IGZpbHRlcmlcbiAgbGV0IHBhcnRpdGlvbl9tYXAgPSBwYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fbWFwaSA9IHBhcnRpdGlvbl9tYXBpXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBwYXJ0aXRpb25fdGZcbiAgbGV0IHBhcnRpdGlvbmlfdGYgPSBwYXJ0aXRpb25pX3RmXG4gIGxldCBmaW5kX29yX2FkZCA9IGZpbmRfb3JfYWRkXG4gIGxldCBmaW5kaV9vcl9hZGQgPSBmaW5kaV9vcl9hZGRcbiAgbGV0IGZpbmQgPSBmaW5kXG4gIGxldCBmaW5kX2V4biA9IGZpbmRfZXhuXG4gIGxldCBmaW5kX2FuZF9jYWxsID0gZmluZF9hbmRfY2FsbFxuICBsZXQgZmluZF9hbmRfY2FsbDEgPSBmaW5kX2FuZF9jYWxsMVxuICBsZXQgZmluZF9hbmRfY2FsbDIgPSBmaW5kX2FuZF9jYWxsMlxuICBsZXQgZmluZGlfYW5kX2NhbGwgPSBmaW5kaV9hbmRfY2FsbFxuICBsZXQgZmluZGlfYW5kX2NhbGwxID0gZmluZGlfYW5kX2NhbGwxXG4gIGxldCBmaW5kaV9hbmRfY2FsbDIgPSBmaW5kaV9hbmRfY2FsbDJcbiAgbGV0IGZpbmRfYW5kX3JlbW92ZSA9IGZpbmRfYW5kX3JlbW92ZVxuICBsZXQgdG9fYWxpc3QgPSB0b19hbGlzdFxuICBsZXQgbWVyZ2UgPSBtZXJnZVxuICBsZXQgbWVyZ2VfaW50byA9IG1lcmdlX2ludG9cbiAgbGV0IGtleXMgPSBrZXlzXG4gIGxldCBkYXRhID0gZGF0YVxuICBsZXQgZmlsdGVyX2tleXNfaW5wbGFjZSA9IGZpbHRlcl9rZXlzX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9pbnBsYWNlID0gZmlsdGVyX2lucGxhY2VcbiAgbGV0IGZpbHRlcmlfaW5wbGFjZSA9IGZpbHRlcmlfaW5wbGFjZVxuICBsZXQgbWFwX2lucGxhY2UgPSBtYXBfaW5wbGFjZVxuICBsZXQgbWFwaV9pbnBsYWNlID0gbWFwaV9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlXG4gIGxldCBlcXVhbCA9IGVxdWFsXG4gIGxldCBzaW1pbGFyID0gc2ltaWxhclxuICBsZXQgaW5jciA9IGluY3JcbiAgbGV0IGRlY3IgPSBkZWNyXG4gIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5XG5lbmRcblxubW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEtleS5oYXNoYWJsZVxuXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgbGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKCkgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKVxuICBsZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPSBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcblxuICBsZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBrX29mX3NleHAgZF9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cFxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICAgIGdyb3VwID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbiAgOztcbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuICB0eXBlICdhIGtleSA9ICdhXG5cbiAgbGV0IGhhc2hhYmxlID0gSGFzaGFibGUucG9seVxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHRfc2V4cF9ncmFtbWFyXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgSGFzaGFibGUgPSBIYXNoYWJsZS5IYXNoYWJsZVxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gIGxldCBoYXNoYWJsZSB0ID0gdC5oYXNoYWJsZVxuZW5kXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPVxuICBjcmVhdGUgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3Rfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9tdWx0aSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIGwgPVxuICBjcmVhdGVfbWFwcGVkIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfZXhuIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICBncm91cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbjs7XG5cbmxldCBoYXNoYWJsZV9zIHQgPSBIYXNoYWJsZS50b19rZXkgdC5oYXNoYWJsZVxuXG5tb2R1bGUgTSAoSyA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2KSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGspIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGspIHZfb2Zfc2V4cCBzZXhwID1cbiAgdF9vZl9zZXhwIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IChtb2R1bGUgSykpIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgaykgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKSB2X2dyYW1tYXIgPVxuICB0X3NleHBfZ3JhbW1hciBLLnRfc2V4cF9ncmFtbWFyIHZfZ3JhbW1hclxuOztcblxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgZXF1YWxfdiB0MSB0MiA9IGVxdWFsIGVxdWFsX3YgdDEgdDJcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBIYXNoX3NldF9pbnRmXG5cbmxldCBoYXNoYWJsZV9zID0gSGFzaHRibC5oYXNoYWJsZV9zXG5sZXQgaGFzaGFibGUgPSBIYXNodGJsLlByaXZhdGUuaGFzaGFibGVcbmxldCBwb2x5X2hhc2hhYmxlID0gSGFzaHRibC5Qb2x5Lmhhc2hhYmxlXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICdhIHQgPSAoJ2EsIHVuaXQpIEhhc2h0YmwudFxudHlwZSAnYSBoYXNoX3NldCA9ICdhIHRcbnR5cGUgJ2EgZWx0ID0gJ2FcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICBsZXQgY2xlYXIgPSBIYXNodGJsLmNsZWFyXG4gIGxldCBsZW5ndGggPSBIYXNodGJsLmxlbmd0aFxuICBsZXQgbWVtID0gSGFzaHRibC5tZW1cbiAgbGV0IGlzX2VtcHR5IHQgPSBIYXNodGJsLmlzX2VtcHR5IHRcblxuICBsZXQgZmluZF9tYXAgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBIYXNodGJsLml0ZXJfa2V5cyB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgIG1hdGNoIGYgZWx0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBfIGFzIG8gLT4gci5yZXR1cm4gbyk7XG4gICAgICBOb25lKVxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kX21hcCB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBTb21lIGEgZWxzZSBOb25lKVxuICBsZXQgYWRkIHQgayA9IEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpXG5cbiAgbGV0IHN0cmljdF9hZGQgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiBPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJlbGVtZW50IGFscmVhZHkgZXhpc3RzXCJcbiAgICBlbHNlIChcbiAgICAgIEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICA7O1xuXG4gIGxldCBzdHJpY3RfYWRkX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9hZGQgdCBrKVxuICBsZXQgcmVtb3ZlID0gSGFzaHRibC5yZW1vdmVcblxuICBsZXQgc3RyaWN0X3JlbW92ZSB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZSB0IGs7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gICAgZWxzZSBPcl9lcnJvci5lcnJvciBcImVsZW1lbnQgbm90IGluIHNldFwiIGsgKEhhc2h0Ymwuc2V4cF9vZl9rZXkgdClcbiAgOztcblxuICBsZXQgc3RyaWN0X3JlbW92ZV9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfcmVtb3ZlIHQgaylcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEhhc2h0YmwuZm9sZCB0IH5pbml0IH5mOihmdW4gfmtleSB+ZGF0YTooKSBhY2MgLT4gZiBhY2Mga2V5KVxuICBsZXQgaXRlciB0IH5mID0gSGFzaHRibC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgdG9fbGlzdCA9IEhhc2h0Ymwua2V5c1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lIHQgPVxuICAgIHNleHBfb2ZfbGlzdCBzZXhwX29mX2UgKHRvX2xpc3QgdCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KGhhc2hhYmxlIHQpLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGxldCBpbmRleCA9IHJlZiAobGVuIC0gMSkgaW5cbiAgICBmb2xkIHQgfmluaXQ6W3x8XSB+ZjooZnVuIGFjYyBrZXkgLT5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCBhY2MgPSAwXG4gICAgICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIGtleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGluZGV4IDo9ICFpbmRleCAtIDE7XG4gICAgICAgIGFjYy4oIWluZGV4KSA8LSBrZXk7XG4gICAgICAgIGFjYykpXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID0gSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KVxuICBsZXQgZm9yX2FsbCB0IH5mID0gbm90IChIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gbm90IChmIGtleSkpKVxuICBsZXQgZXF1YWwgdDEgdDIgPSBIYXNodGJsLmVxdWFsIChmdW4gKCkgKCkgLT4gdHJ1ZSkgdDEgdDJcbiAgbGV0IGNvcHkgdCA9IEhhc2h0YmwuY29weSB0XG4gIGxldCBmaWx0ZXIgdCB+ZiA9IEhhc2h0YmwuZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbiAgbGV0IHVuaW9uIHQxIHQyID0gSGFzaHRibC5tZXJnZSB0MSB0MiB+ZjooZnVuIH5rZXk6XyBfIC0+IFNvbWUgKCkpXG4gIGxldCBkaWZmIHQxIHQyID0gZmlsdGVyIHQxIH5mOihmdW4ga2V5IC0+IG5vdCAoSGFzaHRibC5tZW0gdDIga2V5KSlcblxuICBsZXQgaW50ZXIgdDEgdDIgPVxuICAgIGxldCBzbWFsbGVyLCBsYXJnZXIgPSBpZiBsZW5ndGggdDEgPiBsZW5ndGggdDIgdGhlbiB0MiwgdDEgZWxzZSB0MSwgdDIgaW5cbiAgICBIYXNodGJsLmZpbHRlcmkgc21hbGxlciB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gSGFzaHRibC5tZW0gbGFyZ2VyIGtleSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gICAgbGV0IHRvX3JlbW92ZSA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjIHggLT4gaWYgZiB4IHRoZW4gYWMgZWxzZSB4IDo6IGFjKSBpblxuICAgIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biB4IC0+IHJlbW92ZSB0IHgpXG4gIDs7XG5cbiAgbGV0IG9mX2hhc2h0Ymxfa2V5cyBoYXNodGJsID0gSGFzaHRibC5tYXAgaGFzaHRibCB+ZjppZ25vcmVcbiAgbGV0IHRvX2hhc2h0YmwgdCB+ZiA9IEhhc2h0YmwubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG1cblxubGV0IG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIGxcbiAgaW5cbiAgbGV0IHQgPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgbSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIGsgLT4gYWRkIHQgayk7XG4gIHRcbjs7XG5cbmxldCB0X29mX3NleHAgbSBlX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IFNleHAuQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJIYXNoX3NldC50X29mX3NleHAgcmVxdWlyZXMgYSBsaXN0XCIgc2V4cFxuICB8IFNleHAuTGlzdCBsaXN0IC0+XG4gICAgbGV0IHQgPSBjcmVhdGUgbSB+c2l6ZTooTGlzdC5sZW5ndGggbGlzdCkgaW5cbiAgICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHNleHAgLT5cbiAgICAgIGxldCBlID0gZV9vZl9zZXhwIHNleHAgaW5cbiAgICAgIG1hdGNoIHN0cmljdF9hZGQgdCBlIHdpdGhcbiAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgIHwgRXJyb3IgXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIGdvdCBhIGR1cGxpY2F0ZSBlbGVtZW50XCIgc2V4cCk7XG4gICAgdFxuOztcblxubW9kdWxlIENyZWF0b3JzIChFbHQgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEVsdC50KSAtPiBTZXhwLnQgLT4gJ2EgRWx0LnQgdFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgRWx0LnQgdFxuICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICB3aXRoIHR5cGUgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID1cbiAgICBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSkgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgZV9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGVfb2Zfc2V4cCBzZXhwXG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgaGFzaF9zZXRcbiAgdHlwZSAnYSBlbHQgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IHBvbHlfaGFzaGFibGVcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbmVuZFxuXG5tb2R1bGUgTSAoRWx0IDogVC5UKSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gRWx0LnQgdFxuZW5kXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IHRcbjs7XG5cbmxldCBtX190X29mX3NleHAgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCkgc2V4cCA9XG4gIHRfb2Zfc2V4cCAobW9kdWxlIEVsdCkgRWx0LnRfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gZWx0KSA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgUHJpbnRmXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbmluY2x1ZGUgRmxvYXQwXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfZmxvYXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Zsb2F0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChmbG9hdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9mbG9hdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBmbG9hdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgdG9fZmxvYXQgeCA9IHhcbmxldCBvZl9mbG9hdCB4ID0geFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICB0cnkgZmxvYXRfb2Zfc3RyaW5nIHMgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwiRmxvYXQub2Zfc3RyaW5nICVzXCIgcyAoKVxuOztcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiBTdG9sZW4gZnJvbSBbcGVydmFzaXZlcy5tbF0uICBBZGRzIGEgXCIuXCIgYXQgdGhlIGVuZCBpZiBuZWVkZWQuICBJdCBpcyBpblxuICAgW3BlcnZhc2l2ZXMubWxpXSwgYnV0IGl0IGFsc28gc2F5cyBub3QgdG8gdXNlIGl0IGRpcmVjdGx5LCBzbyB3ZSBjb3B5IGFuZCBwYXN0ZSB0aGVcbiAgIGNvZGUuIEl0IG1ha2VzIHRoZSBhc3N1bXB0aW9uIG9uIHRoZSBzdHJpbmcgcGFzc2VkIGluIGFyZ3VtZW50IHRoYXQgaXQgd2FzIHJldHVybmVkIGJ5XG4gICBbZm9ybWF0X2Zsb2F0XS4gKilcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGkgbFxuICAgIHRoZW4gcyBeIFwiLlwiXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IF8gLT4gcylcbiAgaW5cbiAgbG9vcCAwXG47O1xuXG4oKiBMZXQgW3ldIGJlIGEgcG93ZXIgb2YgMi4gIFRoZW4gdGhlIG5leHQgcmVwcmVzZW50YWJsZSBmbG9hdCBpczpcbiAgIFt6ID0geSAqICgxICsgMiAqKiAtNTIpXVxuICAgYW5kIHRoZSBwcmV2aW91cyBvbmUgaXNcbiAgIFt4ID0geSAqICgxIC0gMiAqKiAtNTMpXVxuXG4gICBJbiBnZW5lcmFsLCBldmVyeSB0d28gYWRqYWNlbnQgZmxvYXRzIGFyZSB3aXRoaW4gYSBmYWN0b3Igb2YgYmV0d2VlbiBbMSArIDIqKi01M11cbiAgIGFuZCBbMSArIDIqKi01Ml0gZnJvbSBlYWNoIG90aGVyLCB0aGF0IGlzIHdpdGhpbiBbMSArIDEuMWUtMTZdIGFuZCBbMSArIDIuM2UtMTZdLlxuXG4gICBTbyBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhIGZsb2F0IHN0YXJ0cyB3aXRoIFwiMVwiLCB0aGVuIGl0cyBhZGphY2VudCBmbG9hdHNcbiAgIHdpbGwgdXN1YWxseSBkaWZmZXIgZnJvbSBpdCBieSAxLCBhbmQgc29tZXRpbWVzIGJ5IDIsIGF0IHRoZSAxN3RoIHNpZ25pZmljYW50IGRpZ2l0XG4gICAoY291bnRpbmcgZnJvbSAxKS5cblxuICAgT24gdGhlIG90aGVyIGhhbmQsIGlmIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIHN0YXJ0cyB3aXRoIFwiOVwiLCB0aGVuIHRoZSBhZGphY2VudFxuICAgZmxvYXRzIHdpbGwgYmUgb2ZmIGJ5IG5vIG1vcmUgdGhhbiAyMyBhdCB0aGUgMTZ0aCBhbmQgMTd0aCBzaWduaWZpY2FudCBkaWdpdHMuXG5cbiAgIEUuZy46XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgKDEwMjQuICouICgxLiAtLiAyLioqICgtNTMuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1NjdcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyMy45OTk5OTk5OTk5OTk5XCJcbiAgIHZ9XG4gICBQcmludGluZyBhIGNvdXBsZSBvZiBleHRyYSBkaWdpdHMgcmV2ZWFscyB0aGF0IHRoZSBkaWZmZXJlbmNlIGluZGVlZCBpcyByb3VnaGx5IDExIGF0XG4gICBkaWdpdHMgMTd0aCBhbmQgMTh0aCAodGhhdCBpcywgMTN0aCBhbmQgMTR0aCBhZnRlciBcIi5cIik6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTlnXCIgKDEwMjQuICouICgxLiAtLiAyLioqICgtNTMuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2Nzg5XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5ODg2XCJcbiAgIHZ9XG5cbiAgIFRoZSB1bHAgKHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYWRqYWNlbnQgZmxvYXRzKSBpcyB0d2ljZSBhcyBiaWcgb24gdGhlIG90aGVyIHNpZGUgb2ZcbiAgIDEwMjQuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gKy4gMi4qKiAoLTUyLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDI0LjAwMDAwMDAwMDAwMDIyN1wiXG4gICB2fVxuXG4gICBOb3cgdGFrZSBhIHBvd2VyIG9mIDIgd2hpY2ggc3RhcnRzIHdpdGggOTk6XG5cbiAgIHt2XG4gICAgICMgMi4qKjkzLiA7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgIDEgMjM0NTY3ODkwMTIzNDU2NzhcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDIyZSsyN1xuXG4gICAgICMgMi4qKjkzLiAqLiAoMS4gKy4gMi4qKiAoLTUyLikpOztcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDQ0ZSsyN1xuXG4gICAgICMgMi4qKjkzLiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpOztcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDExZSsyN1xuICAgdn1cblxuICAgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAyKio5MyBhbmQgaXRzIHR3byBuZWlnaGJvcnMgaXMgc2xpZ2h0bHkgbW9yZSB0aGFuLCByZXNwZWN0aXZlbHksXG4gICAxIGFuZCAyIGF0IHNpZ25pZmljYW50IGRpZ2l0IDE2LlxuXG4gICBUaG9zZSBleGFtcGxlcyBzaG93IHRoYXQ6XG4gICAtIDE3IHNpZ25pZmljYW50IGRpZ2l0cyBpcyBhbHdheXMgc3VmZmljaWVudCB0byByZXByZXNlbnQgYSBmbG9hdCB3aXRob3V0IGFtYmlndWl0eVxuICAgLSAxNXRoIHNpZ25pZmljYW50IGRpZ2l0IGNhbiBhbHdheXMgYmUgcmVwcmVzZW50ZWQgYWNjdXJhdGVseVxuICAgLSBjb252ZXJ0aW5nIGEgZGVjaW1hbCBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgdG8gaXRzIG5lYXJlc3QgZmxvYXQgYW5kIGJhY2tcbiAgICAgY2FuIGNoYW5nZSB0aGUgbGFzdCBkZWNpbWFsIGRpZ2l0IGJ5IG5vIG1vcmUgdGhhbiAxXG5cbiAgIFRvIG1ha2Ugc3VyZSB0aGF0IGZsb2F0cyBvYnRhaW5lZCBieSBjb252ZXJzaW9uIGZyb20gZGVjaW1hbCBmcmFjdGlvbnMgKGUuZy4gXCIzLjE0XCIpXG4gICBhcmUgcHJpbnRlZCB3aXRob3V0IHRyYWlsaW5nIG5vbi16ZXJvIGRpZ2l0cywgb25lIHNob3VsZCBjaG9vc2UgdGhlIGZpcnN0IGFtb25nIHRoZVxuICAgJyUuMTVnJywgJyUuMTZnJywgYW5kICclLjE3ZycgcmVwcmVzZW50YXRpb25zIHdoaWNoIGRvZXMgcm91bmQtdHJpcDpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiICAgICAgICAgICAgICAgICAgICAgKCogcGljayB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0XCJcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNDAwMDAwMDAwMDAwMDAxXCIgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUgKilcblxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOFwiICAgICAgICAgICAgICAgICAgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUtLWRvZXMgbm90IHJvdW5kLXRyaXAgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAyXCIgICAgICAgICgqIHByZWZlciB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOC4wMDAwMDAwMDAwMDAwMDE4XCIgICAgICAgKCogdGhpcyBvbmUgaGFzIG9uZSBkaWdpdCBvZiBqdW5rIGF0IHRoZSBlbmQgKilcbiAgIHZ9XG5cbiAgIFNraXBwaW5nIHRoZSAnJS4xNmcnIGluIHRoZSBhYm92ZSBwcm9jZWR1cmUgc2F2ZXMgdXMgc29tZSB0aW1lLCBidXQgaXQgbWVhbnMgdGhhdCwgYXNcbiAgIHNlZW4gaW4gdGhlIHNlY29uZCBleGFtcGxlIGFib3ZlLCBvY2Nhc2lvbmFsbHkgbnVtYmVycyB3aXRoIGV4YWN0bHkgMTYgc2lnbmlmaWNhbnRcbiAgIGRpZ2l0cyB3aWxsIGhhdmUgYW4gZXJyb3IgaW50cm9kdWNlZCBhdCB0aGUgMTd0aCBkaWdpdC4gIFRoYXQgaXMgcHJvYmFibHkgT0sgZm9yXG4gICB0eXBpY2FsIHVzZSwgYmVjYXVzZSBhIG51bWJlciB3aXRoIDE2IHNpZ25pZmljYW50IGRpZ2l0cyBpcyBcInVnbHlcIiBhbHJlYWR5LiAgQWRkaW5nIG9uZVxuICAgbW9yZSBkb2Vzbid0IG1ha2UgaXQgbXVjaCB3b3JzZSBmb3IgYSBodW1hbiByZWFkZXIuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCB3ZSBjYW5ub3Qgc2tpcCAnJS4xNWcnIGFuZCBvbmx5IGxvb2sgYXQgJyUuMTZnJyBhbmQgJyUuMTdnJywgc2luY2VcbiAgIHRoZSBpbmFjY3VyYWN5IGF0IHRoZSAxNnRoIGRpZ2l0IG1pZ2h0IGludHJvZHVjZSB0aGUgbm9pc2Ugd2Ugd2FudCB0byBhdm9pZDpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyXCIgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyMDAwMDAwMDAwMDAxXCIgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1qdW5rIGF0IHRoZSBlbmQgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyMDAwMDAwMDAwMDAwOVwiXG4gICB2fVxuKilcbmxldCB0b19zdHJpbmcgeCA9XG4gIHZhbGlkX2Zsb2F0X2xleGVtXG4gICAgKGxldCB5ID0gZm9ybWF0X2Zsb2F0IFwiJS4xNWdcIiB4IGluXG4gICAgIGlmIGZsb2F0X29mX3N0cmluZyB5ID0geCB0aGVuIHkgZWxzZSBmb3JtYXRfZmxvYXQgXCIlLjE3Z1wiIHgpXG47O1xuXG5sZXQgbWF4X3ZhbHVlID0gaW5maW5pdHlcbmxldCBtaW5fdmFsdWUgPSBuZWdfaW5maW5pdHlcbmxldCBtaW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID0gMi4gKiogLTEwNzQuXG5sZXQgbWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDIyLlxubGV0IHplcm8gPSAwLlxubGV0IG9uZSA9IDEuXG5sZXQgbWludXNfb25lID0gLTEuXG5sZXQgcGkgPSAweDMuMjQzRjZBODg4NUEzMDhEMzEzMTk4QTJFMDM3MDczXG5sZXQgc3FydF9waSA9IDB4MS5DNUJGODkxQjRFRjZBQTc5QzNCMDUyMEQ1REI5MzhcbmxldCBzcXJ0XzJwaSA9IDB4Mi44MUIyNjNGRUM0RTBCMkNBRjk0ODNGNUNFNDU5RENcbmxldCBldWxlciA9IDB4MC45M0M0NjdFMzdEQjBDN0E0RDFCRTNGODEwMTUyQ0JcbmxldCBvZl9pbnQgPSBJbnQudG9fZmxvYXRcbmxldCB0b19pbnQgPSBJbnQub2ZfZmxvYXRcbmxldCBvZl9pbnQ2MyBpID0gSW50NjMudG9fZmxvYXQgaVxubGV0IG9mX2ludDY0IGkgPSBDYW1sLkludDY0LnRvX2Zsb2F0IGlcbmxldCB0b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfZmxvYXRcbmxldCBpcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcbmxldCBpcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcblxuKCogVGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBcImV4blwiIHJvdW5kaW5nIGZ1bmN0aW9ucyBpcyBpbXBvcnRhbnQsIHNvIHRoZXkgYXJlIHdyaXR0ZW5cbiAgIG91dCBzZXBhcmF0ZWx5LCBhbmQgdHVuZWQgaW5kaXZpZHVhbGx5LiAgKFdlIGNvdWxkIGhhdmUgdGhlIG9wdGlvbiB2ZXJzaW9ucyBjYWxsXG4gICB0aGUgXCJleG5cIiB2ZXJzaW9ucywgYnV0IHRoYXQgaW1wb3NlcyBhcmd1YWJseSBncmF0dWl0b3VzIG92ZXJoZWFkLS0tZXNwZWNpYWxseVxuICAgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgb2YgYmFja3RyYWNlcyBpcyBlbmFibGVkIHVwb24gXCJ3aXRoXCItLS1hbmQgdGhhdCBzZWVtc1xuICAgbm90IHdvcnRoIGl0IHdoZW4gY29tcGFyZWQgdG8gdGhlIHJlbGF0aXZlbHkgc21hbGwgYW1vdW50IG9mIGNvZGUgZHVwbGljYXRpb24uKSAqKVxuXG4oKiBFcnJvciByZXBvcnRpbmcgYmVsb3cgaXMgdmVyeSBjYXJlZnVsbHkgYXJyYW5nZWQgc28gdGhhdCwgZS5nLiwgW2lyb3VuZF9uZWFyZXN0X2V4bl1cbiAgIGl0c2VsZiBjYW4gYmUgaW5saW5lZCBpbnRvIGNhbGxlcnMgc3VjaCB0aGF0IHRoZXkgZG9uJ3QgbmVlZCB0byBhbGxvY2F0ZSBhIGJveCBmb3IgdGhlXG4gICBbZmxvYXRdIGFyZ3VtZW50LiAgVGhpcyBpcyBkb25lIHdpdGggYSBib3ggW2JveF0gZnVuY3Rpb24gY2FyZWZ1bGx5IGNob3NlbiB0byBhbGxvdyB0aGVcbiAgIGNvbXBpbGVyIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGJveCBmb3IgdGhlIGZsb2F0IG9ubHkgaW4gZXJyb3IgY2FzZXMuICBTZWUsIGUuZy4sXG4gICBbLi4vLi4vemVyby90ZXN0L3ByaWNlX3Rlc3QubWxdIGZvciBhIG1lY2hhbmljYWwgdGVzdCBvZiB0aGlzIHByb3BlcnR5IHdoZW4gYnVpbGRpbmdcbiAgIHdpdGggW1hfTElCUkFSWV9JTkxJTklORz10cnVlXS4gKilcblxubGV0IGlyb3VuZF91cCB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF91cF9leG4gdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfZG93biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlbiBpZiB0IDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpIGVsc2UgTm9uZVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX2Rvd25fZXhuIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuXG4gICAgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpKVxuOztcblxubGV0IGlyb3VuZF90b3dhcmRzX3plcm8gdCA9XG4gIGlmIHQgPj0gaXJvdW5kX2xib3VuZCAmJiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0Lmlyb3VuZF90b3dhcmRzX3plcm9fZXhuOiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKGJveCB0KVxuICAgICAgKClcbjs7XG5cbigqIE91dHNpZGUgb2YgdGhlIHJhbmdlIChyb3VuZF9uZWFyZXN0X2xiLi5yb3VuZF9uZWFyZXN0X3ViKSwgYWxsIHJlcHJlc2VudGFibGUgZG91Ymxlc1xuICAgYXJlIGludGVnZXJzIGluIHRoZSBtYXRoZW1hdGljYWwgc2Vuc2UsIGFuZCBbcm91bmRfbmVhcmVzdF0gc2hvdWxkIGJlIGlkZW50aXR5LlxuXG4gICBIb3dldmVyLCBmb3Igb2RkIG51bWJlcnMgd2l0aCB0aGUgYWJzb2x1dGUgdmFsdWUgYmV0d2VlbiAyKio1MiBhbmQgMioqNTMsIHRoZSBmb3JtdWxhXG4gICBbcm91bmRfbmVhcmVzdCB4ID0gZmxvb3IgKHggKyAwLjUpXSBkb2VzIG5vdCBob2xkOlxuXG4gICB7dlxuICAgICAjIGxldCBuYWl2ZV9yb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArLiAwLjUpOztcbiAgICAgIyBsZXQgeCA9IDIuICoqIDUyLiArLiAxLjs7XG4gICAgIHZhbCB4IDogZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk3LlxuICAgICAjIG5haXZlX3JvdW5kX25lYXJlc3QgeDs7XG4gICAgIC0gOiAgICAgZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk4LlxuICAgdn1cbiopXG5cbmxldCByb3VuZF9uZWFyZXN0X2xiID0gLS4oMi4gKiogNTIuKVxubGV0IHJvdW5kX25lYXJlc3RfdWIgPSAyLiAqKiA1Mi5cblxuKCogRm9yIFt4ID0gb25lX3VscCBgRG93biAwLjVdLCB0aGUgZm9ybXVsYSBbZmxvb3IgKHggKy4gMC41KV0gZm9yIHJvdW5kaW5nIHRvIG5lYXJlc3RcbiAgIGRvZXMgbm90IHdvcmssIGJlY2F1c2UgdGhlIGV4YWN0IHJlc3VsdCBpcyBoYWxmd2F5IGJldHdlZW4gW29uZV91bHAgYERvd24gMS5dIGFuZCBbMS5dLFxuICAgYW5kIGl0IGdldHMgcm91bmRlZCB1cCB0byBbMS5dIGR1ZSB0byB0aGUgcm91bmQtdGllcy10by1ldmVuIHJ1bGUuICopXG5sZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHAgYERvd24gMC41XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCA9XG4gIHRcbiAgKy5cbiAgaWYgdCA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgdGhlbiBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmICgqIHNpbmNlIHQgPCAwLjUsIG1ha2Ugc3VyZSB0aGUgcmVzdWx0IGlzIDwgMS4wICopXG4gIGVsc2UgMC41XG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0XzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCkpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgICBlbHNlIE5vbmVcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3QgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfMzJcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG5fMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciAodCArLiAwLjUpIGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbFwiIChib3ggdCkgKCkpXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF9uZWFyZXN0X2V4bl82NCB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuXG4gICAgaWYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG4gIHwgVzMyIC0+IGlyb3VuZF9uZWFyZXN0X2V4bl8zMlxuOztcblxuKCogVGhlIGZvbGxvd2luZyBbaXJvdW5kX2V4bl0gYW5kIFtpcm91bmRdIGZ1bmN0aW9ucyBhcmUgc2xvd2VyIHRoYW4gdGhlIG9uZXMgYWJvdmUuXG4gICBUaGVpciBlcXVpdmFsZW5jZSB0byB0aG9zZSBmdW5jdGlvbnMgaXMgdGVzdGVkIGluIHRoZSB1bml0IHRlc3RzIGJlbG93LiAqKVxuXG5sZXRbQGlubGluZV0gaXJvdW5kX2V4biA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgWmVybyAtPiBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0XG4gIHwgYE5lYXJlc3QgLT4gaXJvdW5kX25lYXJlc3RfZXhuIHRcbiAgfCBgVXAgLT4gaXJvdW5kX3VwX2V4biB0XG4gIHwgYERvd24gLT4gaXJvdW5kX2Rvd25fZXhuIHRcbjs7XG5cbmxldCBpcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIHRyeSBTb21lIChpcm91bmRfZXhuIH5kaXIgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IGlzX2luZiB0ID0gMS4gLy4gdCA9IDAuXG5sZXQgaXNfZmluaXRlIHQgPSB0IC0uIHQgPSAwLlxuXG5sZXQgbWluX2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IG1heF9pbmFuICh4IDogdCkgeSA9XG4gIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbjs7XG5cbmxldCBhZGQgPSAoICsuIClcbmxldCBzdWIgPSAoIC0uIClcbmxldCBuZWcgPSAoIH4tLiApXG5sZXQgYWJzID0gYWJzX2Zsb2F0XG5sZXQgc2NhbGUgPSAoICouIClcbmxldCBzcXVhcmUgeCA9IHggKi4geFxuXG5tb2R1bGUgUGFydHMgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGZyYWN0aW9uYWwgOiB0IC0+IGZsb2F0XG4gIHZhbCBpbnRlZ3JhbCA6IHQgLT4gZmxvYXRcbiAgdmFsIG1vZGYgOiBmbG9hdCAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgKiBmbG9hdFxuXG4gIGxldCBmcmFjdGlvbmFsIHQgPSBmc3QgdFxuICBsZXQgaW50ZWdyYWwgdCA9IHNuZCB0XG4gIGxldCBtb2RmID0gbW9kZlxuZW5kXG5cbmxldCBtb2RmID0gUGFydHMubW9kZlxubGV0IHJvdW5kX2Rvd24gPSBmbG9vclxubGV0IHJvdW5kX3VwID0gY2VpbFxubGV0IHJvdW5kX3Rvd2FyZHNfemVybyB0ID0gaWYgdCA+PSAwLiB0aGVuIHJvdW5kX2Rvd24gdCBlbHNlIHJvdW5kX3VwIHRcblxuKCogc2VlIHRoZSBjb21tZW50IGFib3ZlIFtyb3VuZF9uZWFyZXN0X2xiXSBhbmQgW3JvdW5kX25lYXJlc3RfdWJdIGZvciBhbiBleHBsYW5hdGlvbiAqKVxubGV0W0BvY2FtbC5pbmxpbmVdIHJvdW5kX25lYXJlc3RfaW5saW5lIHQgPVxuICBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYiAmJiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICB0aGVuIGZsb29yIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KVxuICBlbHNlIHQgKy4gMC5cbjs7XG5cbmxldCByb3VuZF9uZWFyZXN0IHQgPSAocm91bmRfbmVhcmVzdF9pbmxpbmUgW0BvY2FtbC5pbmxpbmVkIGFsd2F5c10pIHRcblxubGV0IHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuIHQgPVxuICBpZiB0IDw9IHJvdW5kX25lYXJlc3RfbGIgfHwgdCA+PSByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gdCArLiAwLlxuICBlbHNlIChcbiAgICBsZXQgZmxvb3IgPSBmbG9vciB0IGluXG4gICAgKCogW2NlaWxfb3Jfc3VjYyA9IGlmIHQgaXMgYW4gaW50ZWdlciB0aGVuIHQgKy4gMS4gZWxzZSBjZWlsIHRdLiAgRmFzdGVyIHRoYW4gW2NlaWxdLiAqKVxuICAgIGxldCBjZWlsX29yX3N1Y2MgPSBmbG9vciArLiAxLiBpblxuICAgIGxldCBkaWZmX2Zsb29yID0gdCAtLiBmbG9vciBpblxuICAgIGxldCBkaWZmX2NlaWwgPSBjZWlsX29yX3N1Y2MgLS4gdCBpblxuICAgIGlmIGRpZmZfZmxvb3IgPCBkaWZmX2NlaWxcbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBpZiBkaWZmX2Zsb29yID4gZGlmZl9jZWlsXG4gICAgdGhlbiBjZWlsX29yX3N1Y2NcbiAgICBlbHNlIGlmICgqIGV4YWN0IHRpZSwgcGljayB0aGUgZXZlbiAqKVxuICAgICAgbW9kX2Zsb2F0IGZsb29yIDIuID0gMC5cbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBjZWlsX29yX3N1Y2MpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xubGV0IGludDYzX3JvdW5kX3Vib3VuZCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnQgSW50NjMubnVtX2JpdHNcblxubGV0IGludDYzX3JvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbiAgZWxzZSBpZiB0ID49IGludDYzX3JvdW5kX2xib3VuZFxuICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKCkpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gdDAgPVxuICBsZXQgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdDAgaW5cbiAgaWYgdCA+IDAuXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoYm94IHQwKVxuICAgICAgICAoKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgIChib3ggdDApXG4gICAgICAoKVxuOztcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuIGYgPSBJbnQ2My5vZl9pbnQgKGlyb3VuZF9uZWFyZXN0X2V4biBmKVxuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgfCBXMzIgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbjs7XG5cbmxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IHRcbiAgfCBgRG93biAtPiByb3VuZF9kb3duIHRcbiAgfCBgVXAgLT4gcm91bmRfdXAgdFxuICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyB0XG47O1xuXG5tb2R1bGUgQ2xhc3MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEluZmluaXRlXG4gICAgfCBOYW5cbiAgICB8IE5vcm1hbFxuICAgIHwgU3Vibm9ybWFsXG4gICAgfCBaZXJvXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBJbmZpbml0ZTsgTmFuOyBOb3JtYWw7IFN1Ym5vcm1hbDsgWmVybyBdIDogdCBsaXN0KVxuXG4gIGxldCB0X29mX3NleHAgPVxuICAgIChsZXQgZXJyb3Jfc291cmNlX18wMDZfID0gXCJmbG9hdC5tbC5DbGFzcy50XCIgaW5cbiAgICAgZnVuY3Rpb25cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgLT4gSW5maW5pdGVcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSAtPiBOYW5cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSAtPiBOb3JtYWxcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwic3Vibm9ybWFsXCIgfCBcIlN1Ym5vcm1hbFwiKSAtPiBTdWJub3JtYWxcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSA6OiBfKSBhc1xuICAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwic3Vibm9ybWFsXCIgfCBcIlN1Ym5vcm1hbFwiKSA6OiBfKSBhc1xuICAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgfCBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEluZmluaXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluZmluaXRlXCJcbiAgICAgIHwgTmFuIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5hblwiXG4gICAgICB8IE5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOb3JtYWxcIlxuICAgICAgfCBTdWJub3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3Vibm9ybWFsXCJcbiAgICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkluZmluaXRlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOb3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiU3Vibm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG5lbmRcblxubGV0IGNsYXNzaWZ5IHQgPVxuICBsZXQgbW9kdWxlIEMgPSBDbGFzcyBpblxuICBtYXRjaCBjbGFzc2lmeV9mbG9hdCB0IHdpdGhcbiAgfCBGUF9ub3JtYWwgLT4gQy5Ob3JtYWxcbiAgfCBGUF9zdWJub3JtYWwgLT4gQy5TdWJub3JtYWxcbiAgfCBGUF96ZXJvIC0+IEMuWmVyb1xuICB8IEZQX2luZmluaXRlIC0+IEMuSW5maW5pdGVcbiAgfCBGUF9uYW4gLT4gQy5OYW5cbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgPyhkZWxpbWl0ZXIgPSAnXycpID8oc3RyaXBfemVybyA9IGZhbHNlKSBzdHJpbmcgPVxuICBtYXRjaCBTdHJpbmcubHNwbGl0MiBzdHJpbmcgfm9uOicuJyB3aXRoXG4gIHwgTm9uZSAtPiBJbnRfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBzdHJpbmcgfmRlbGltaXRlclxuICB8IFNvbWUgKGxlZnQsIHJpZ2h0KSAtPlxuICAgIGxldCBsZWZ0ID0gSW50X2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgbGVmdCB+ZGVsaW1pdGVyIGluXG4gICAgbGV0IHJpZ2h0ID1cbiAgICAgIGlmIHN0cmlwX3plcm8gdGhlbiBTdHJpbmcucnN0cmlwIHJpZ2h0IH5kcm9wOihmdW4gYyAtPiBDaGFyLiggPSApIGMgJzAnKSBlbHNlIHJpZ2h0XG4gICAgaW5cbiAgICAobWF0Y2ggcmlnaHQgd2l0aFxuICAgICB8IFwiXCIgLT4gbGVmdFxuICAgICB8IF8gLT4gbGVmdCBeIFwiLlwiIF4gcmlnaHQpXG47O1xuXG5sZXQgdG9fc3RyaW5nX2h1bSA/ZGVsaW1pdGVyID8oZGVjaW1hbHMgPSAzKSA/c3RyaXBfemVybyA/KGV4cGxpY2l0X3BsdXMgPSBmYWxzZSkgZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgZGVjaW1hbHMgMFxuICB0aGVuIGludmFsaWRfYXJnZiBcInRvX3N0cmluZ19odW06IGludmFsaWQgYXJndW1lbnQgfmRlY2ltYWxzPSVkXCIgZGVjaW1hbHMgKCk7XG4gIG1hdGNoIGNsYXNzaWZ5IGYgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIGYgPiAwLiB0aGVuIFwiaW5mXCIgZWxzZSBcIi1pbmZcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hblwiXG4gIHwgQ2xhc3MuTm9ybWFsIHwgQ2xhc3MuU3Vibm9ybWFsIHwgQ2xhc3MuWmVybyAtPlxuICAgIGxldCBzID1cbiAgICAgIGlmIGV4cGxpY2l0X3BsdXMgdGhlbiBzcHJpbnRmIFwiJSsuKmZcIiBkZWNpbWFscyBmIGVsc2Ugc3ByaW50ZiBcIiUuKmZcIiBkZWNpbWFscyBmXG4gICAgaW5cbiAgICBpbnNlcnRfdW5kZXJzY29yZXMgcyA/ZGVsaW1pdGVyID9zdHJpcF96ZXJvXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBsZXQgc2V4cCA9IHNleHBfb2ZfdCB0IGluXG4gIG1hdGNoICFTZXhwLm9mX2Zsb2F0X3N0eWxlIHdpdGhcbiAgfCBgTm9fdW5kZXJzY29yZXMgLT4gc2V4cFxuICB8IGBVbmRlcnNjb3JlcyAtPlxuICAgIChtYXRjaCBzZXhwIHdpdGhcbiAgICAgfCBMaXN0IF8gLT5cbiAgICAgICByYWlzZV9zXG4gICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICBcIltzZXhwX29mX2Zsb2F0XSBwcm9kdWNlZCBzdHJhbmdlIHNleHBcIlxuICAgICAgICAgICAgWyBcInNleHBcIiwgU2V4cC5zZXhwX29mX3Qgc2V4cCBdKVxuICAgICB8IEF0b20gc3RyaW5nIC0+XG4gICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHN0cmluZyAnRScgdGhlbiBzZXhwIGVsc2UgQXRvbSAoaW5zZXJ0X3VuZGVyc2NvcmVzIHN0cmluZykpXG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvbSB0ID8ocHJlZml4ID0gXCJcIikgfmtpbG8gfm1lZ2EgfmdpZ2EgfnRlcmEgP3BldGEgKCkgPVxuICAoKiBSb3VuZCBhIHJhdGlvIHRvd2FyZCB0aGUgbmVhcmVzdCBpbnRlZ2VyLCByZXNvbHZpbmcgdGllcyB0b3dhcmQgdGhlIG5lYXJlc3QgZXZlblxuICAgICBudW1iZXIuICBGb3Igc2FuZSBpbnB1dHMgKGluIHBhcnRpY3VsYXIsIHdoZW4gW2Rlbm9taW5hdG9yXSBpcyBhbiBpbnRlZ2VyIGFuZFxuICAgICBbYWJzIG51bWVyYXRvciA8IDJlNTJdKSB0aGlzIHNob3VsZCBiZSBhY2N1cmF0ZS4gIE90aGVyd2lzZSwgdGhlIHJlc3VsdCBtaWdodCBiZSBhXG4gICAgIGxpdHRsZSBiaXQgb2ZmLCBidXQgd2UgZG9uJ3QgcmVhbGx5IHVzZSB0aGF0IGNhc2UuICopXG4gIGxldCBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3IgfmRlbm9taW5hdG9yID1cbiAgICBsZXQgayA9IGZsb29yIChudW1lcmF0b3IgLy4gZGVub21pbmF0b3IpIGluXG4gICAgKCogaWYgW2FicyBrIDwgMmU1M10sIHRoZW4gYm90aCBba10gYW5kIFtrICsuIDEuXSBhcmUgYWNjdXJhdGVseSByZXByZXNlbnRlZCwgYW5kIGluXG4gICAgICAgcGFydGljdWxhciBbayArLiAxLiA+IGtdLiAgSWYgW2Rlbm9taW5hdG9yXSBpcyBhbHNvIGFuIGludGVnZXIsIGFuZFxuICAgICAgIFthYnMgKGRlbm9taW5hdG9yICouIChrICsuIDEpKSA8IDJlNTNdIChhbmQgaW4gc29tZSBvdGhlciBjYXNlcywgdG9vKSwgdGhlbiBbbG93ZXJdXG4gICAgICAgYW5kIFtoaWdoZXJdIGFyZSBhY3R1YWxseSBib3RoIGFjY3VyYXRlLiAgU2luY2UgKHJvdWdobHkpXG4gICAgICAgW251bWVyYXRvciA9IGRlbm9taW5hdG9yICouIGtdIHRoZW4gZm9yIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0gd2Ugc2hvdWxkIGJlXG4gICAgICAgZmluZS4gKilcbiAgICBsZXQgbG93ZXIgPSBkZW5vbWluYXRvciAqLiBrIGluXG4gICAgbGV0IGhpZ2hlciA9IGRlbm9taW5hdG9yICouIChrICsuIDEuKSBpblxuICAgICgqIFN1YnRyYWN0aW5nIG51bWJlcnMgd2l0aGluIGEgZmFjdG9yIG9mIHR3byBmcm9tIGVhY2ggb3RoZXIgaXMgYWNjdXJhdGUuXG4gICAgICAgU28gZWl0aGVyIHRoZSB0d28gc3VidHJhY3Rpb25zIGJlbG93IGFyZSBhY2N1cmF0ZSwgb3IgayA9IDAsIG9yIGsgPSAtMS5cbiAgICAgICBJbiBjYXNlIG9mIGEgdGllLCByb3VuZCB0byBldmVuLiAqKVxuICAgIGxldCBkaWZmX3JpZ2h0ID0gaGlnaGVyIC0uIG51bWVyYXRvciBpblxuICAgIGxldCBkaWZmX2xlZnQgPSBudW1lcmF0b3IgLS4gbG93ZXIgaW5cbiAgICBsZXQgayA9IGlyb3VuZF9uZWFyZXN0X2V4biBrIGluXG4gICAgaWYgZGlmZl9yaWdodCA8IGRpZmZfbGVmdFxuICAgIHRoZW4gayArIDFcbiAgICBlbHNlIGlmIGRpZmZfcmlnaHQgPiBkaWZmX2xlZnRcbiAgICB0aGVuIGtcbiAgICBlbHNlIGlmICgqIGEgdGllICopXG4gICAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChrIG1vZCAyKSAwXG4gICAgdGhlbiBrXG4gICAgZWxzZSBrICsgMVxuICBpblxuICBtYXRjaCBjbGFzc2lmeSB0IHdpdGhcbiAgfCBDbGFzcy5JbmZpbml0ZSAtPiBpZiB0IDwgMC4wIHRoZW4gXCItaW5mICBcIiBlbHNlIFwiaW5mICBcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hbiAgXCJcbiAgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IGdvIHQgPVxuICAgICAgbGV0IGNvbnZfb25lIHQgPVxuICAgICAgICBhc3NlcnQgKDAuIDw9IHQgJiYgdCA8IDk5OS45NSk7XG4gICAgICAgIGxldCB4ID0gcHJlZml4IF4gZm9ybWF0X2Zsb2F0IFwiJS4xZlwiIHQgaW5cbiAgICAgICAgKCogRml4IHRoZSBcIi4wXCIgc3VmZml4ICopXG4gICAgICAgIGlmIFN0cmluZy5pc19zdWZmaXggeCB+c3VmZml4OlwiLjBcIlxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgeCA9IEJ5dGVzLm9mX3N0cmluZyB4IGluXG4gICAgICAgICAgbGV0IG4gPSBCeXRlcy5sZW5ndGggeCBpblxuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMSkgJyAnO1xuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMikgJyAnO1xuICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6eClcbiAgICAgICAgZWxzZSB4XG4gICAgICBpblxuICAgICAgbGV0IGNvbnYgbWFnIHQgZGVub21pbmF0b3IgPVxuICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgIChkZW5vbWluYXRvciA9IDEwMC4gJiYgdCA+PSA5OTkuOTUpXG4gICAgICAgICAgfHwgKGRlbm9taW5hdG9yID49IDEwMF8wMDAuICYmIHQgPj0gcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOS45OTlfNSkpKTtcbiAgICAgICAgYXNzZXJ0ICh0IDwgcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOV85OTkuNSkpO1xuICAgICAgICBsZXQgaSwgZCA9XG4gICAgICAgICAgbGV0IGsgPSBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3I6dCB+ZGVub21pbmF0b3IgaW5cbiAgICAgICAgICAoKiBbbW9kXSBpcyBva2F5IGhlcmUgYmVjYXVzZSB3ZSBrbm93IGkgPj0gMC4gKilcbiAgICAgICAgICBrIC8gMTAsIGsgbW9kIDEwXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICAgICAgYXNzZXJ0ICgwIDw9IGkgJiYgaSA8IDEwMDApO1xuICAgICAgICBhc3NlcnQgKDAgPD0gZCAmJiBkIDwgMTApO1xuICAgICAgICBpZiBkID0gMFxuICAgICAgICB0aGVuIHNwcmludGYgXCIlcyVkJXMgXCIgcHJlZml4IGkgbWFnXG4gICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJWQlcyVkXCIgcHJlZml4IGkgbWFnIGRcbiAgICAgIGluXG4gICAgICAoKiBXaGlsZSB0aGUgc3RhbmRhcmQgbWV0cmljIHByZWZpeGVzIChlLmcuIGNhcGl0YWwgXCJNXCIgcmF0aGVyIHRoYW4gXCJtXCIsIFsxXSkgYXJlXG4gICAgICAgICBub21pbmFsbHkgbW9yZSBjb3JyZWN0LCB0aGlzIGhpbmRlcnMgcmVhZGFiaWxpdHkgaW4gb3VyIGNhc2UuICBFLmcuLCAxMEc2IGFuZFxuICAgICAgICAgMTA2NiBsb29rIHRvbyBzaW1pbGFyLiAgVGhhdCdzIGFuIGV4dHJlbWUgZXhhbXBsZSwgYnV0IGluIGdlbmVyYWwgayxtLGcsdCxwXG4gICAgICAgICBwcm9iYWJseSBzdGFuZCBvdXQgYmV0dGVyIHRoYW4gSyxNLEcsVCxQIHdoZW4gaW50ZXJzcGVyc2VkIHdpdGggZGlnaXRzLlxuXG4gICAgICAgICBbMV0gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRyaWNfcHJlZml4ICopXG4gICAgICAoKiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0OlxuICAgICAgICAgLSB0aGUgZmlyc3QgYm91bmRhcnkgKDk5OS45NSkgYXMgYSBmbG9hdCBpcyBzbGlnaHRseSBvdmVyLXJlcHJlc2VudGVkIChzbyBpdCBpc1xuICAgICAgICAgICBiZXR0ZXIgYXBwcm94aW1hdGVkIGFzIFwiMWtcIiB0aGFuIGFzIFwiOTk5LjlcIiksXG4gICAgICAgICAtIHRoZSBvdGhlciBib3VuZGFyaWVzIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBiZWNhdXNlIHRoZXkgYXJlIGludGVnZXJzLlxuICAgICAgICAgICBUaGF0J3Mgd2h5IHRoZSBzdHJpY3QgZXF1YWxpdGllcyBiZWxvdyBkbyBleGFjdGx5IHdoYXQgd2Ugd2FudC4gKilcbiAgICAgIGlmIHQgPCA5OTkuOTVFMFxuICAgICAgdGhlbiBjb252X29uZSB0XG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFM1xuICAgICAgdGhlbiBjb252IGtpbG8gdCAxMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFNlxuICAgICAgdGhlbiBjb252IG1lZ2EgdCAxMDBfMDAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTlcbiAgICAgIHRoZW4gY29udiBnaWdhIHQgMTAwXzAwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFMTJcbiAgICAgIHRoZW4gY29udiB0ZXJhIHQgMTAwXzAwMF8wMDBfMDAwLlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHBldGEgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0XG4gICAgICAgIHwgU29tZSBwZXRhIC0+XG4gICAgICAgICAgaWYgdCA8IDk5OS45NUUxNVxuICAgICAgICAgIHRoZW4gY29udiBwZXRhIHQgMTAwXzAwMF8wMDBfMDAwXzAwMC5cbiAgICAgICAgICBlbHNlIHNwcmludGYgXCIlcyUuMWVcIiBwcmVmaXggdClcbiAgICBpblxuICAgIGlmIHQgPj0gMC4gdGhlbiBnbyB0IGVsc2UgXCItXCIgXiBnbyB+LS50XG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIHQgPVxuICB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgfmtpbG86XCJrXCIgfm1lZ2E6XCJtXCIgfmdpZ2E6XCJnXCIgfnRlcmE6XCJ0XCIgfnBldGE6XCJwXCIgKClcbjs7XG5cbigqIFBlcmZvcm1hbmNlIG5vdGU6IEluaXRpYWxpemluZyB0aGUgYWNjdW11bGF0b3IgdG8gMSByZXN1bHRzIGluIG9uZSBleHRyYVxuICAgbXVsdGlwbHk7IGUuZy4sIHRvIGNvbXB1dGUgeCAqKiA0LCB3ZSBpbiBwcmluY2lwbGUgb25seSBuZWVkIDIgbXVsdGlwbGllcyxcbiAgIGJ1dCB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZSAzIG11bHRpcGxpZXMuICBIb3dldmVyLCBhdHRlbXB0cyB0byBhdm9pZCB0aGlzXG4gICAobGlrZSBkZWNyZW1lbnRpbmcgbiBhbmQgaW5pdGlhbGl6aW5nIGFjY3VtIHRvIGJlIHgsIG9yIGhhbmRsaW5nIHNtYWxsXG4gICBleHBvbmVudHMgYXMgYSBzcGVjaWFsIGNhc2UpIGhhdmUgbm90IHlpZWxkZWQgYW55dGhpbmcgdGhhdCBpcyBhIG5ldFxuICAgaW1wcm92ZW1lbnQuXG4qKVxubGV0IGludF9wb3cgeCBuID1cbiAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiBuID0gMFxuICB0aGVuIDEuXG4gIGVsc2UgKFxuICAgICgqIFVzaW5nIFt4ICsuICgtMC4pXSBvbiB0aGUgZm9sbG93aW5nIGxpbmUgY29udmluY2VzIHRoZSBjb21waWxlciB0byBhdm9pZCBhIGNlcnRhaW5cbiAgICAgICBib3hpbmcgKHRoYXQgd291bGQgcmVzdWx0IGluIGFsbG9jYXRpb24gaW4gZWFjaCBpdGVyYXRpb24pLiAgU29vbiwgdGhlIGNvbXBpbGVyXG4gICAgICAgc2hvdWxkbid0IG5lZWQgdGhpcyBcImhpbnRcIiB0byBhdm9pZCB0aGUgYm94aW5nLiAgVGhlIHJlYXNvbiB3ZSBhZGQgLTAgcmF0aGVyIHRoYW4gMFxuICAgICAgIGlzIHRoYXQgW3ggKy4gKC0wLildIGlzIGFwcGFyZW50bHkgYWx3YXlzIHRoZSBzYW1lIGFzIFt4XSwgd2hlcmVhcyBbeCArLiAwLl0gaXNcbiAgICAgICBub3QsIGluIHRoYXQgaXQgc2VuZHMgWy0wLl0gdG8gWzAuXS4gIFRoaXMgbWFrZXMgYSBkaWZmZXJlbmNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgIFtpbnRfcG93ICgtMC4pICgtMSldIHRvIHJldHVybiBuZWdfaW5maW5pdHkganVzdCBsaWtlIFstMC4gKiogLTEuXSB3b3VsZC4gICopXG4gICAgbGV0IHggPSByZWYgKHggKy4gLTAuKSBpblxuICAgIGxldCBuID0gcmVmIG4gaW5cbiAgICBsZXQgYWNjdW0gPSByZWYgMS4gaW5cbiAgICBpZiAhbiA8IDBcbiAgICB0aGVuIChcbiAgICAgICgqIHggKiogbiA9ICgxL3gpICoqIC1uICopXG4gICAgICB4IDo9IDEuIC8uICF4O1xuICAgICAgbiA6PSB+LSAoIW4pO1xuICAgICAgaWYgIW4gPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogbiBtdXN0IGhhdmUgYmVlbiBtaW5faW50LCBzbyBpdCBpcyBub3cgc28gYmlnIHRoYXQgaXQgaGFzIHdyYXBwZWQgYXJvdW5kLlxuICAgICAgICAgICBXZSBkZWNyZW1lbnQgaXQgc28gdGhhdCBpdCBsb29rcyBwb3NpdGl2ZSBhZ2FpbiwgYnV0IGFjY29yZGluZ2x5IGhhdmVcbiAgICAgICAgICAgdG8gcHV0IGFuIGV4dHJhIGZhY3RvciBvZiB4IGluIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgICAgKilcbiAgICAgICAgYWNjdW0gOj0gIXg7XG4gICAgICAgIGRlY3IgbikpO1xuICAgICgqIExldHRpbmcgW2FdIGRlbm90ZSAodGhlIG9yaWdpbmFsIHZhbHVlIG9mKSBbeCAqKiBuXSwgd2UgbWFpbnRhaW5cbiAgICAgICB0aGUgaW52YXJpYW50IHRoYXQgWyh4ICoqIG4pICouIGFjY3VtID0gYV0uICopXG4gICAgd2hpbGUgIW4gPiAxIGRvXG4gICAgICBpZiAhbiBsYW5kIDEgPD4gMCB0aGVuIGFjY3VtIDo9ICF4ICouICFhY2N1bTtcbiAgICAgIHggOj0gIXggKi4gIXg7XG4gICAgICBuIDo9ICFuIGxzciAxXG4gICAgZG9uZTtcbiAgICAoKiBuIGlzIG5lY2Vzc2FyaWx5IDEgYXQgdGhpcyBwb2ludCwgc28gdGhlcmUgaXMgb25lIGFkZGl0aW9uYWxcbiAgICAgICBtdWx0aXBsaWNhdGlvbiBieSB4LiAqKVxuICAgICF4ICouICFhY2N1bSlcbjs7XG5cbmxldCByb3VuZF9nZW4geCB+aG93ID1cbiAgaWYgeCA9IDAuXG4gIHRoZW4gMC5cbiAgZWxzZSBpZiBub3QgKGlzX2Zpbml0ZSB4KVxuICB0aGVuIHhcbiAgZWxzZSAoXG4gICAgKCogU2lnbmlmaWNhbnQgZGlnaXRzIGFuZCBkZWNpbWFsIGRpZ2l0cy4gKilcbiAgICBsZXQgc2QsIGRkID1cbiAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICB8IGBzaWduaWZpY2FudF9kaWdpdHMgc2QgLT5cbiAgICAgICAgbGV0IGRkID0gc2QgLSB0b19pbnQgKHJvdW5kX3VwIChsb2cxMCAoYWJzIHgpKSkgaW5cbiAgICAgICAgc2QsIGRkXG4gICAgICB8IGBkZWNpbWFsX2RpZ2l0cyBkZCAtPlxuICAgICAgICBsZXQgc2QgPSBkZCArIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBzZCA8IDBcbiAgICB0aGVuIDAuXG4gICAgZWxzZSBpZiBzZCA+PSAxN1xuICAgIHRoZW4geFxuICAgIGVsc2UgKFxuICAgICAgKCogQ2hvb3NlIHRoZSBvcmRlciB0aGF0IGlzIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LiBTbWFsbCBwb3NpdGl2ZVxuICAgICAgICAgaW50ZWdlcnMgYXJlLCBidXQgdGhlaXIgaW52ZXJzZXMgaW4gbW9zdCBjYXNlcyBhcmUgbm90LiAqKVxuICAgICAgbGV0IGFic19kZCA9IEludC5hYnMgZGQgaW5cbiAgICAgIGlmIGFic19kZCA+IDIyIHx8IHNkID49IDE2XG4gICAgICAoKiAxMCoqMjIgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIGJ1dCAxMCoqMjMgaXMgbm90LCBzbyB1c2UgdGhlIHNsb3dcbiAgICAgICAgIHBhdGguICBTaW1pbGFybHksIGlmIHdlIG5lZWQgMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGluIHRoZSByZXN1bHQsIHRoZW4gdGhlIGludGVnZXJcbiAgICAgICAgIFtyb3VuZF9uZWFyZXN0ICh4IDxvcD4gb3JkZXIpXSBtaWdodCBub3QgYmUgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIHNpbmNlXG4gICAgICAgICBmb3Igc29tZSByYW5nZXMgd2Ugb25seSBoYXZlIDE1IGRpZ2l0cyBvZiBwcmVjaXNpb24gZ3VhcmFudGVlZC5cblxuICAgICAgICAgVGhhdCBzYWlkLCB3ZSBhcmUgc3RpbGwgcm91bmRpbmcgdHdpY2UgaGVyZTpcblxuICAgICAgICAgMSkgZmlyc3QgdGltZSB3aGVuIHJvdW5kaW5nIFt4ICouIG9yZGVyXSBvciBbeCAvLiBvcmRlcl0gdG8gdGhlIG5lYXJlc3QgZmxvYXRcbiAgICAgICAgIChqdXN0IHRoZSBub3JtYWwgd2F5IGZsb2F0aW5nLXBvaW50IG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uIHdvcmtzKSxcblxuICAgICAgICAgMikgc2Vjb25kIHRpbWUgd2hlbiBhcHBseWluZyBbcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW5dIHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgICBhYm92ZSBvcGVyYXRpb25cblxuICAgICAgICAgU28gZm9yIGFyZ3VtZW50cyB3aXRoaW4gYW4gdWxwIGZyb20gYSB0aWUgd2UgbWlnaHQgc3RpbGwgcHJvZHVjZSBhbiBvZmYtYnktb25lXG4gICAgICAgICByZXN1bHQuICopXG4gICAgICB0aGVuIG9mX3N0cmluZyAoc3ByaW50ZiBcIiUuKmdcIiBzZCB4KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBvcmRlciA9IGludF9wb3cgMTAuIGFic19kZCBpblxuICAgICAgICBpZiBkZCA+PSAwXG4gICAgICAgIHRoZW4gcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggKi4gb3JkZXIpIC8uIG9yZGVyXG4gICAgICAgIGVsc2Ugcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggLy4gb3JkZXIpICouIG9yZGVyKSkpXG47O1xuXG5sZXQgcm91bmRfc2lnbmlmaWNhbnQgeCB+c2lnbmlmaWNhbnRfZGlnaXRzID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgc2lnbmlmaWNhbnRfZGlnaXRzIDBcbiAgdGhlblxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5yb3VuZF9zaWduaWZpY2FudDogaW52YWxpZCBhcmd1bWVudCBzaWduaWZpY2FudF9kaWdpdHM6JWRcIlxuICAgICAgc2lnbmlmaWNhbnRfZGlnaXRzXG4gICAgICAoKVxuICBlbHNlIHJvdW5kX2dlbiB4IH5ob3c6KGBzaWduaWZpY2FudF9kaWdpdHMgc2lnbmlmaWNhbnRfZGlnaXRzKVxuOztcblxubGV0IHJvdW5kX2RlY2ltYWwgeCB+ZGVjaW1hbF9kaWdpdHMgPSByb3VuZF9nZW4geCB+aG93OihgZGVjaW1hbF9kaWdpdHMgZGVjaW1hbF9kaWdpdHMpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gICgqIGNsYW1wX3VuY2hlY2tlZCBpcyBpbiBmbG9hdDAubWwgKilcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAoKiBBbHNvIGZhaWxzIGlmIFttaW5dIG9yIFttYXhdIGlzIG5hbiAqKVxuICBpZiBtaW4gPD0gbWF4XG4gIHRoZW4gT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgZWxzZVxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbjs7XG5cbmxldCAoICsgKSA9ICggKy4gKVxubGV0ICggLSApID0gKCAtLiApXG5sZXQgKCAqICkgPSAoICouIClcbmxldCAoICoqICkgPSAoICoqIClcbmxldCAoIC8gKSA9ICggLy4gKVxubGV0ICggJSApID0gKCAlLiApXG5sZXQgKCB+LSApID0gKCB+LS4gKVxuXG5sZXQgc2lnbl9leG4gdCA6IFNpZ24udCA9XG4gIGlmIHQgPiAwLlxuICB0aGVuIFBvc1xuICBlbHNlIGlmIHQgPCAwLlxuICB0aGVuIE5lZ1xuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuIFplcm9cbiAgZWxzZSBFcnJvci5yYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJGbG9hdC5zaWduX2V4biBvZiBOQU5cIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgc2lnbl9vcl9uYW4gdCA6IFNpZ25fb3JfbmFuLnQgPVxuICBpZiB0ID4gMC4gdGhlbiBQb3MgZWxzZSBpZiB0IDwgMC4gdGhlbiBOZWcgZWxzZSBpZiB0ID0gMC4gdGhlbiBaZXJvIGVsc2UgTmFuXG47O1xuXG5sZXQgaWVlZV9uZWdhdGl2ZSB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBQb2x5LihiaXRzIDwgQ2FtbC5JbnQ2NC56ZXJvKVxuOztcblxubGV0IGV4cG9uZW50X2JpdHMgPSAxMVxubGV0IG1hbnRpc3NhX2JpdHMgPSA1MlxubGV0IGV4cG9uZW50X21hc2s2NCA9IEludDY0LihzaGlmdF9sZWZ0IG9uZSBleHBvbmVudF9iaXRzIC0gb25lKVxubGV0IGV4cG9uZW50X21hc2sgPSBJbnQ2NC50b19pbnRfZXhuIGV4cG9uZW50X21hc2s2NFxubGV0IG1hbnRpc3NhX21hc2sgPSBJbnQ2My4oc2hpZnRfbGVmdCBvbmUgbWFudGlzc2FfYml0cyAtIG9uZSlcbmxldCBtYW50aXNzYV9tYXNrNjQgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYV9tYXNrXG5cbmxldCBpZWVlX2V4cG9uZW50IHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDY0LihiaXRfYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGJpdHMgbWFudGlzc2FfYml0cykgZXhwb25lbnRfbWFzazY0KVxuICB8PiBDYW1sLkludDY0LnRvX2ludFxuOztcblxubGV0IGllZWVfbWFudGlzc2EgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgSW50NjMub2ZfaW50NjRfZXhuIENhbWwuSW50NjQuKGxvZ2FuZCBiaXRzIG1hbnRpc3NhX21hc2s2NClcbjs7XG5cbmxldCBjcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBpZiBJbnQuKGJpdF9hbmQgZXhwb25lbnQgZXhwb25lbnRfbWFzayA8PiBleHBvbmVudClcbiAgdGhlbiBmYWlsd2l0aGYgXCJleHBvbmVudCAlZCBvdXQgb2YgcmFuZ2UgWzAsICVkXVwiIGV4cG9uZW50IGV4cG9uZW50X21hc2sgKClcbiAgZWxzZSBpZiBJbnQ2My4oYml0X2FuZCBtYW50aXNzYSBtYW50aXNzYV9tYXNrIDw+IG1hbnRpc3NhKVxuICB0aGVuXG4gICAgZmFpbHdpdGhmXG4gICAgICBcIm1hbnRpc3NhICVzIG91dCBvZiByYW5nZSBbMCwgJXNdXCJcbiAgICAgIChJbnQ2My50b19zdHJpbmcgbWFudGlzc2EpXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhX21hc2spXG4gICAgICAoKVxuICBlbHNlIChcbiAgICBsZXQgc2lnbl9iaXRzID0gaWYgbmVnYXRpdmUgdGhlbiBDYW1sLkludDY0Lm1pbl9pbnQgZWxzZSBDYW1sLkludDY0Lnplcm8gaW5cbiAgICBsZXQgZXhwdF9iaXRzID0gQ2FtbC5JbnQ2NC5zaGlmdF9sZWZ0IChDYW1sLkludDY0Lm9mX2ludCBleHBvbmVudCkgbWFudGlzc2FfYml0cyBpblxuICAgIGxldCBtYW50X2JpdHMgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYSBpblxuICAgIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC4obG9nb3Igc2lnbl9iaXRzIChsb2dvciBleHB0X2JpdHMgbWFudF9iaXRzKSkgaW5cbiAgICBDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgYml0cylcbjs7XG5cbmxldCBjcmVhdGVfaWVlZSB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSA9XG4gIE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhKVxuOztcblxubW9kdWxlIFRlcnNlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IHRfb2Zfc2V4cFxuICBsZXQgdG9fc3RyaW5nIHggPSBQcmludGYuc3ByaW50ZiBcIiUuOEdcIiB4XG4gIGxldCBzZXhwX29mX3QgeCA9IFNleHAuQXRvbSAodG9fc3RyaW5nIHgpXG4gIGxldCBvZl9zdHJpbmcgeCA9IG9mX3N0cmluZyB4XG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHRfc2V4cF9ncmFtbWFyXG5lbmRcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG4oKiBUaGVzZSBhcmUgcGFydGx5IGhlcmUgYXMgYSBwZXJmb3JtYW5jZSBoYWNrIHRvIGF2b2lkIHNvbWUgYm94aW5nIHdlJ3JlIGdldHRpbmcgd2l0aFxuICAgdGhlIHZlcnNpb25zIHdlIGdldCBmcm9tIFtXaXRoX3plcm9dLiAgVGhleSBhbHNvIG1ha2UgW0Zsb2F0LmlzX25lZ2F0aXZlIG5hbl0gYW5kXG4gICBbRmxvYXQuaXNfbm9uX3Bvc2l0aXZlIG5hbl0gcmV0dXJuIFtmYWxzZV07IHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXSByZXR1cm5cbiAgIFt0cnVlXS4gKilcbmxldCBpc19wb3NpdGl2ZSB0ID0gdCA+IDAuXG5sZXQgaXNfbm9uX25lZ2F0aXZlIHQgPSB0ID49IDAuXG5sZXQgaXNfbmVnYXRpdmUgdCA9IHQgPCAwLlxubGV0IGlzX25vbl9wb3NpdGl2ZSB0ID0gdCA8PSAwLlxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5GbG9hdFwiXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBlbmQpXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoICUgKSA9ICggJSApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50ID0gb2ZfaW50XG4gIGxldCBvZl9mbG9hdCB4ID0geFxuZW5kXG5cbm1vZHVsZSBPX2RvdCA9IHN0cnVjdFxuICBsZXQgKCAqLiApID0gKCAqIClcbiAgbGV0ICggKy4gKSA9ICggKyApXG4gIGxldCAoIC0uICkgPSAoIC0gKVxuICBsZXQgKCAvLiApID0gKCAvIClcbiAgbGV0ICggJS4gKSA9ICggJSApXG4gIGxldCAoIH4tLiApID0gKCB+LSApXG4gIGxldCAoICoqLiApID0gKCAqKiApXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGJveCA9IGJveFxuICBsZXQgY2xhbXBfdW5jaGVja2VkID0gY2xhbXBfdW5jaGVja2VkXG4gIGxldCBsb3dlcl9ib3VuZF9mb3JfaW50ID0gbG93ZXJfYm91bmRfZm9yX2ludFxuICBsZXQgdXBwZXJfYm91bmRfZm9yX2ludCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHNwZWNpYWxpemVkX2hhc2ggPSBoYXNoX2Zsb2F0XG4gIGxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICBsZXQgaXJvdW5kX25lYXJlc3RfZXhuXzY0ID0gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgc3BlY2lmaWNhbGx5IHJlcGxhY2UgZGVmYXVsdHMgaW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLlxuXG4gICBUaGUgZGVzaXJlZCBiZWhhdmlvciBoZXJlIGlzIHRvIHByb3BhZ2F0ZSBhIG5hbiBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLiBCZWNhdXNlIHRoZVxuICAgZmlyc3QgY29tcGFyaXNvbiB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbiwgaXQgc3VmZmljZXMgdG9cbiAgIGNoZWNrIGlmIHggaXMgbmFuLiBUaGVuLCB3aGVuIHggaXMgbmFuIG9yIGJvdGggeCBhbmQgeSBhcmUgbmFuLCB3ZSByZXR1cm4geCA9IG5hbjsgYW5kXG4gICB3aGVuIHkgaXMgbmFuIGJ1dCBub3QgeCwgd2UgcmV0dXJuIHkgPSBuYW4uXG5cbiAgIFRoZXJlIGFyZSB2YXJpb3VzIHdheXMgdG8gaW1wbGVtZW50IHRoZXNlIGZ1bmN0aW9ucy4gIFRoZSBiZW5jaG1hcmsgYmVsb3cgc2hvd3MgYSBmZXdcbiAgIGRpZmZlcmVudCB2ZXJzaW9ucy4gIFRoaXMgYmVuY2htYXJrIHdhcyBydW4gb3ZlciBhbiBhcnJheSBvZiByYW5kb20gZmxvYXRzIChub25lIG9mXG4gICB3aGljaCBhcmUgbmFuKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuNDJ1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDIuMDJ1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuODh1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXG4gICBUaGUgYmVuY2htYXJrIGJlbG93IHdhcyBydW4gd2hlbiB4ID4geSBpcyBhbHdheXMgdHJ1ZSAoYWdhaW4sIG5vIG5hbiB2YWx1ZXMpLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi44M3VzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS45N3VzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS41NnVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4qKVxubGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5sZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCdWZmZXJfaW50ZlxuaW5jbHVkZSBDYW1sLkJ1ZmZlclxuXG5sZXQgY29udGVudHNfYnl0ZXMgPSB0b19ieXRlc1xubGV0IGFkZF9zdWJzdHJpbmcgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJzdHJpbmcgdCBzIHBvcyBsZW5cbmxldCBhZGRfc3ViYnl0ZXMgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJieXRlcyB0IHMgcG9zIGxlblxubGV0IHNleHBfb2ZfdCB0ID0gc2V4cF9vZl9zdHJpbmcgKGNvbnRlbnRzIHQpXG5cbm1vZHVsZSBUb19ieXRlcyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQnl0ZXMudFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBCeXRlcy5jcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoXG5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgICAgIENhbWwuQnVmZmVyLmJsaXQgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG4gICAgICA7O1xuICAgIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKENhbWwuQnVmZmVyKSAoVG9fYnl0ZXMpXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbnR5cGUgdCA9IENhbWwuUHJpbnRleGMucmF3X2JhY2t0cmFjZVxuXG5sZXQgZWxpZGUgPSByZWYgZmFsc2VcbmxldCBlbGlkZWRfbWVzc2FnZSA9IFwiPGJhY2t0cmFjZSBlbGlkZWQgaW4gdGVzdD5cIlxuXG5sZXQgZ2V0ID8oYXRfbW9zdF9udW1fZnJhbWVzID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBDYW1sLlByaW50ZXhjLmdldF9jYWxsc3RhY2sgYXRfbW9zdF9udW1fZnJhbWVzXG47O1xuXG5sZXQgdG9fc3RyaW5nIHQgPVxuICBpZiAhZWxpZGUgdGhlbiBlbGlkZWRfbWVzc2FnZSBlbHNlIENhbWwuUHJpbnRleGMucmF3X2JhY2t0cmFjZV90b19zdHJpbmcgdFxuOztcblxubGV0IHRvX3N0cmluZ19saXN0IHQgPSBTdHJpbmcuc3BsaXRfbGluZXMgKHRvX3N0cmluZyB0KVxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5MaXN0IChMaXN0Lm1hcCAodG9fc3RyaW5nX2xpc3QgdCkgfmY6KGZ1biB4IC0+IFNleHAuQXRvbSB4KSlcblxubW9kdWxlIEV4biA9IHN0cnVjdFxuICBsZXQgc2V0X3JlY29yZGluZyA9IENhbWwuUHJpbnRleGMucmVjb3JkX2JhY2t0cmFjZVxuICBsZXQgYW1fcmVjb3JkaW5nID0gQ2FtbC5QcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzXG4gIGxldCBtb3N0X3JlY2VudCAoKSA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKClcblxuICBsZXQgbW9zdF9yZWNlbnRfZm9yX2V4biBleG4gPVxuICAgIGlmIEV4bi5pc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4biB0aGVuIFNvbWUgKG1vc3RfcmVjZW50ICgpKSBlbHNlIE5vbmVcbiAgOztcblxuICAoKiBXZSB0dXJuIG9uIGJhY2t0cmFjZXMgYnkgZGVmYXVsdCBpZiBPQ0FNTFJVTlBBUkFNIGRvZXNuJ3QgZXhwbGljaXRseSBtZW50aW9uIHRoZW0uICopXG4gIGxldCBtYXliZV9zZXRfcmVjb3JkaW5nICgpID1cbiAgICBsZXQgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzID1cbiAgICAgIG1hdGNoIFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aFxuICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICB8IFNvbWUgeCAtPiBMaXN0LmV4aXN0cyAoU3RyaW5nLnNwbGl0IHggfm9uOicsJykgfmY6KFN0cmluZy5pc19wcmVmaXggfnByZWZpeDpcImJcIilcbiAgICBpblxuICAgIGlmIG5vdCBvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmFjZXMgdGhlbiBzZXRfcmVjb3JkaW5nIHRydWVcbiAgOztcblxuICAoKiB0aGUgY2FsbGVyIHNldCBzb21ldGhpbmcsIHRoZXkgYXJlIHJlc3BvbnNpYmxlICopXG5cbiAgbGV0IHdpdGhfcmVjb3JkaW5nIGIgfmYgPVxuICAgIGxldCBzYXZlZCA9IGFtX3JlY29yZGluZyAoKSBpblxuICAgIHNldF9yZWNvcmRpbmcgYjtcbiAgICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHNldF9yZWNvcmRpbmcgc2F2ZWQpXG4gIDs7XG5lbmRcblxubGV0IGluaXRpYWxpemVfbW9kdWxlICgpID0gRXhuLm1heWJlX3NldF9yZWNvcmRpbmcgKClcbiIsIigqKiBUaGlzIG1vZHVsZSBpcyB0aGUgdG9wbGV2ZWwgb2YgdGhlIEJhc2UgbGlicmFyeTsgaXQncyB3aGF0IHlvdSBnZXQgd2hlbiB5b3Ugd3JpdGVcbiAgICBbb3BlbiBCYXNlXS5cblxuICAgIFRoZSBnb2FsIG9mIEJhc2UgaXMgYm90aCB0byBiZSBhIG1vcmUgY29tcGxldGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCByaWNoZXIgQVBJcyxcbiAgICBhbmQgdG8gYmUgbW9yZSBjb25zaXN0ZW50IGluIGl0cyBkZXNpZ24uIEZvciBpbnN0YW5jZSwgaW4gdGhlIHN0YW5kYXJkIGxpYnJhcnlcbiAgICBzb21lIHRoaW5ncyBoYXZlIG1vZHVsZXMgYW5kIG90aGVycyBkb24ndDsgaW4gQmFzZSwgZXZlcnl0aGluZyBpcyBhIG1vZHVsZS5cblxuICAgIEJhc2UgZXh0ZW5kcyBzb21lIG1vZHVsZXMgYW5kIGRhdGEgc3RydWN0dXJlcyBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCBsaWtlIFtBcnJheV0sXG4gICAgW0J1ZmZlcl0sIFtCeXRlc10sIFtDaGFyXSwgW0hhc2h0YmxdLCBbSW50MzJdLCBbSW50NjRdLCBbTGF6eV0sIFtMaXN0XSwgW01hcF0sXG4gICAgW05hdGl2ZWludF0sIFtQcmludGZdLCBbUmFuZG9tXSwgW1NldF0sIFtTdHJpbmddLCBbU3lzXSwgYW5kIFtVY2hhcl0uIE9uZSBrZXlcbiAgICBkaWZmZXJlbmNlIGlzIHRoYXQgQmFzZSBkb2Vzbid0IHVzZSBleGNlcHRpb25zIGFzIG11Y2ggYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkgYW5kXG4gICAgaW5zdGVhZCBtYWtlcyBoZWF2eSB1c2Ugb2YgdGhlIFtSZXN1bHRdIHR5cGUsIGFzIGluOlxuXG4gICAge1sgdHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2IgXX1cblxuICAgIEJhc2UgYWxzbyBhZGRzIGVudGlyZWx5IG5ldyBtb2R1bGVzLCBtb3N0IG5vdGFibHk6XG5cbiAgICAtIFtDb21wYXJhYmxlXSwgW0NvbXBhcmF0b3JdLCBhbmQgW0NvbXBhcmlzb25zXSBpbiBsaWV1IG9mIHBvbHltb3JwaGljIGNvbXBhcmUuXG4gICAgLSBbQ29udGFpbmVyXSwgd2hpY2ggcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgY29udGFpbmVyLWxpa2UgZGF0YVxuICAgICAgc3RydWN0dXJlcyAoYXJyYXlzLCBsaXN0cywgc3RyaW5ncykuXG4gICAgLSBbUmVzdWx0XSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0sIHN1cHBvcnRpbmcgdGhlIG9yLWVycm9yIHBhdHRlcm4uXG4qKVxuXG4oKl8gV2UgaGlkZSB0aGlzIGZyb20gdGhlIHdlYiBkb2NzIGJlY2F1c2UgdGhlIGxpbmUgd3JhcHBpbmcgaXMgYmFkLCBtYWtpbmcgaXRcbiAgcHJldHR5IG11Y2ggaW5zY3J1dGFibGUuICopXG4oKiovKiopXG5cbigqIFRoZSBpbnRlbnQgaXMgdG8gc2hhZG93IGFsbCBvZiBJTlJJQSdzIHN0YW5kYXJkIGxpYnJhcnkuICBNb2R1bGVzIGJlbG93IHdvdWxkIGNhdXNlXG4gICBjb21waWxhdGlvbiBlcnJvcnMgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb20gW1NoYWRvd19zdGRsaWJdIGJlZm9yZSBpbmNsdXNpb24uICopXG5cbmluY2x1ZGUgKFxuICBTaGFkb3dfc3RkbGliIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNoYWRvd19zdGRsaWJcbiAgZW5kXG4gICgqIE1vZHVsZXMgZGVmaW5lZCBpbiBCYXNlICopXG4gIHdpdGggbW9kdWxlIEFycmF5IDo9IFNoYWRvd19zdGRsaWIuQXJyYXlcbiAgd2l0aCBtb2R1bGUgQXRvbWljIDo9IFNoYWRvd19zdGRsaWIuQXRvbWljXG4gIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gIHdpdGggbW9kdWxlIEJ1ZmZlciA6PSBTaGFkb3dfc3RkbGliLkJ1ZmZlclxuICB3aXRoIG1vZHVsZSBCeXRlcyA6PSBTaGFkb3dfc3RkbGliLkJ5dGVzXG4gIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gIHdpdGggbW9kdWxlIEVpdGhlciA6PSBTaGFkb3dfc3RkbGliLkVpdGhlclxuICB3aXRoIG1vZHVsZSBGbG9hdCA6PSBTaGFkb3dfc3RkbGliLkZsb2F0XG4gIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gIHdpdGggbW9kdWxlIEluX2NoYW5uZWwgOj0gU2hhZG93X3N0ZGxpYi5Jbl9jaGFubmVsXG4gIHdpdGggbW9kdWxlIEludCA6PSBTaGFkb3dfc3RkbGliLkludFxuICB3aXRoIG1vZHVsZSBJbnQzMiA6PSBTaGFkb3dfc3RkbGliLkludDMyXG4gIHdpdGggbW9kdWxlIEludDY0IDo9IFNoYWRvd19zdGRsaWIuSW50NjRcbiAgd2l0aCBtb2R1bGUgTGF6eSA6PSBTaGFkb3dfc3RkbGliLkxhenlcbiAgd2l0aCBtb2R1bGUgTGlzdCA6PSBTaGFkb3dfc3RkbGliLkxpc3RcbiAgd2l0aCBtb2R1bGUgTWFwIDo9IFNoYWRvd19zdGRsaWIuTWFwXG4gIHdpdGggbW9kdWxlIE5hdGl2ZWludCA6PSBTaGFkb3dfc3RkbGliLk5hdGl2ZWludFxuICB3aXRoIG1vZHVsZSBPcHRpb24gOj0gU2hhZG93X3N0ZGxpYi5PcHRpb25cbiAgd2l0aCBtb2R1bGUgT3V0X2NoYW5uZWwgOj0gU2hhZG93X3N0ZGxpYi5PdXRfY2hhbm5lbFxuICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICB3aXRoIG1vZHVsZSBSYW5kb20gOj0gU2hhZG93X3N0ZGxpYi5SYW5kb21cbiAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICB3aXRoIG1vZHVsZSBTdGFjayA6PSBTaGFkb3dfc3RkbGliLlN0YWNrXG4gIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgd2l0aCBtb2R1bGUgVWNoYXIgOj0gU2hhZG93X3N0ZGxpYi5VY2hhclxuICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdFxuICAoKiBTdXBwb3J0IGZvciBnZW5lcmF0ZWQgbGV4ZXJzICopXG4gIHdpdGggbW9kdWxlIExleGluZyA6PSBTaGFkb3dfc3RkbGliLkxleGluZ1xuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZikgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuKCoqLyoqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBBcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlXG5tb2R1bGUgQXJyYXkgPSBBcnJheVxubW9kdWxlIEF2bHRyZWUgPSBBdmx0cmVlXG5tb2R1bGUgQmFja3RyYWNlID0gQmFja3RyYWNlXG5tb2R1bGUgQmluYXJ5X3NlYXJjaCA9IEJpbmFyeV9zZWFyY2hcbm1vZHVsZSBCaW5hcnlfc2VhcmNoYWJsZSA9IEJpbmFyeV9zZWFyY2hhYmxlXG5tb2R1bGUgQmxpdCA9IEJsaXRcbm1vZHVsZSBCb29sID0gQm9vbFxubW9kdWxlIEJ1ZmZlciA9IEJ1ZmZlclxubW9kdWxlIEJ5dGVzID0gQnl0ZXNcbm1vZHVsZSBDaGFyID0gQ2hhclxubW9kdWxlIENvbXBhcmFibGUgPSBDb21wYXJhYmxlXG5tb2R1bGUgQ29tcGFyYXRvciA9IENvbXBhcmF0b3Jcbm1vZHVsZSBDb21wYXJpc29ucyA9IENvbXBhcmlzb25zXG5tb2R1bGUgQ29udGFpbmVyID0gQ29udGFpbmVyXG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyXG5tb2R1bGUgRXF1YWwgPSBFcXVhbFxubW9kdWxlIEVycm9yID0gRXJyb3Jcbm1vZHVsZSBFeG4gPSBFeG5cbm1vZHVsZSBGaWVsZCA9IEZpZWxkXG5tb2R1bGUgRmxvYXQgPSBGbG9hdFxubW9kdWxlIEZsb2F0YWJsZSA9IEZsb2F0YWJsZVxubW9kdWxlIEZuID0gRm5cbm1vZHVsZSBGb3JtYXR0ZXIgPSBGb3JtYXR0ZXJcbm1vZHVsZSBIYXNoID0gSGFzaFxubW9kdWxlIEhhc2hfc2V0ID0gSGFzaF9zZXRcbm1vZHVsZSBIYXNoYWJsZSA9IEhhc2hhYmxlXG5tb2R1bGUgSGFzaGVyID0gSGFzaGVyXG5tb2R1bGUgSGFzaHRibCA9IEhhc2h0Ymxcbm1vZHVsZSBJZGVudGlmaWFibGUgPSBJZGVudGlmaWFibGVcbm1vZHVsZSBJbmRleGVkX2NvbnRhaW5lciA9IEluZGV4ZWRfY29udGFpbmVyXG5tb2R1bGUgSW5mbyA9IEluZm9cbm1vZHVsZSBJbnQgPSBJbnRcbm1vZHVsZSBJbnRfY29udmVyc2lvbnMgPSBJbnRfY29udmVyc2lvbnNcbm1vZHVsZSBJbnQzMiA9IEludDMyXG5tb2R1bGUgSW50NjMgPSBJbnQ2M1xubW9kdWxlIEludDY0ID0gSW50NjRcbm1vZHVsZSBJbnRhYmxlID0gSW50YWJsZVxubW9kdWxlIEludF9tYXRoID0gSW50X21hdGhcbm1vZHVsZSBJbnZhcmlhbnQgPSBJbnZhcmlhbnRcbm1vZHVsZSBMYXp5ID0gTGF6eVxubW9kdWxlIExpc3QgPSBMaXN0XG5tb2R1bGUgTWFwID0gTWFwXG5tb2R1bGUgTWF5YmVfYm91bmQgPSBNYXliZV9ib3VuZFxubW9kdWxlIE1vbmFkID0gTW9uYWRcbm1vZHVsZSBOYXRpdmVpbnQgPSBOYXRpdmVpbnRcbm1vZHVsZSBOb3RoaW5nID0gTm90aGluZ1xubW9kdWxlIE9wdGlvbiA9IE9wdGlvblxubW9kdWxlIE9wdGlvbl9hcnJheSA9IE9wdGlvbl9hcnJheVxubW9kdWxlIE9yX2Vycm9yID0gT3JfZXJyb3Jcbm1vZHVsZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uID0gT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vblxubW9kdWxlIE9yZGVyaW5nID0gT3JkZXJpbmdcbm1vZHVsZSBQb2x5ID0gUG9seVxubW9kdWxlIFBvbHltb3JwaGljX2NvbXBhcmUgPSBQb2x5IFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxOC0xMV0gdXNlIFtQb2x5XSBpbnN0ZWFkXCJdXG5cbm1vZHVsZSBQb3Bjb3VudCA9IFBvcGNvdW50XG5bQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMTBdIHVzZSBbcG9wY291bnRdIGZ1bmN0aW9ucyBpbiB0aGUgaW5kaXZpZHVhbCBpbnQgbW9kdWxlc1wiXVxuXG5tb2R1bGUgUHJldHR5X3ByaW50ZXIgPSBQcmV0dHlfcHJpbnRlclxubW9kdWxlIFByaW50ZiA9IFByaW50ZlxubW9kdWxlIExpbmtlZF9xdWV1ZSA9IExpbmtlZF9xdWV1ZVxubW9kdWxlIFF1ZXVlID0gUXVldWVcbm1vZHVsZSBSYW5kb20gPSBSYW5kb21cbm1vZHVsZSBSZWYgPSBSZWZcbm1vZHVsZSBSZXN1bHQgPSBSZXN1bHRcbm1vZHVsZSBTZXF1ZW5jZSA9IFNlcXVlbmNlXG5tb2R1bGUgU2V0ID0gU2V0XG5tb2R1bGUgU2V4cGFibGUgPSBTZXhwYWJsZVxubW9kdWxlIFNpZ24gPSBTaWduXG5tb2R1bGUgU2lnbl9vcl9uYW4gPSBTaWduX29yX25hblxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uID0gU291cmNlX2NvZGVfcG9zaXRpb25cbm1vZHVsZSBTdGFjayA9IFN0YWNrXG5tb2R1bGUgU3RhZ2VkID0gU3RhZ2VkXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nYWJsZSA9IFN0cmluZ2FibGVcbm1vZHVsZSBTeXMgPSBTeXNcbm1vZHVsZSBUID0gVFxubW9kdWxlIFR5cGVfZXF1YWwgPSBUeXBlX2VxdWFsXG5tb2R1bGUgVW5pZm9ybV9hcnJheSA9IFVuaWZvcm1fYXJyYXlcbm1vZHVsZSBVbml0ID0gVW5pdFxubW9kdWxlIFVjaGFyID0gVWNoYXJcbm1vZHVsZSBWYXJpYW50ID0gVmFyaWFudFxubW9kdWxlIFdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm5cbm1vZHVsZSBXb3JkX3NpemUgPSBXb3JkX3NpemVcblxuKCogQXZvaWQgYSBsZXZlbCBvZiBpbmRpcmVjdGlvbiBmb3IgdXNlcyBvZiB0aGUgc2lnbmF0dXJlcyBkZWZpbmVkIGluIFtUXS4gKilcbmluY2x1ZGUgVFxuXG4oKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IG9kb2MgY3JlYXRlcyBiZXR0ZXIgZG9jdW1lbnRhdGlvbi4gKilcbm1vZHVsZSBTZXhwID0gc3RydWN0XG4gIGluY2x1ZGUgU2V4cF93aXRoX2NvbXBhcmFibGUgKCoqIEBpbmxpbmUgKilcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcyA9IHN0cnVjdFxuICBtb2R1bGUgRmllbGRzbGliID0gRmllbGRzbGliXG4gIG1vZHVsZSBQcHhfaGFzaF9saWIgPSBQcHhfaGFzaF9saWJcbiAgbW9kdWxlIFZhcmlhbnRzbGliID0gVmFyaWFudHNsaWJcbiAgbW9kdWxlIFBweF9jb21wYXJlX2xpYiA9IFBweF9jb21wYXJlX2xpYlxuICBtb2R1bGUgUHB4X2VudW1lcmF0ZV9saWIgPSBQcHhfZW51bWVyYXRlX2xpYlxuXG4gIGxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZ1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiBbZGVyaXZpbmcgaGFzaF0gaXMgbWlzc2luZyBmb3IgW2FycmF5XSBhbmQgW3JlZl0gc2luY2UgdGhlc2UgdHlwZXMgYXJlIG11dGFibGUuICopXG4gIHR5cGUgJ2EgYXJyYXkgPSAnYSBBcnJheS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGludCA9IEFycmF5LmNvbXBhcmVcbiAgbGV0IGVxdWFsX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBib29sID0gQXJyYXkuZXF1YWxcblxuICBsZXQgYXJyYXlfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgYXJyYXkgPVxuICAgIEFycmF5LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2FycmF5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGFycmF5IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgQXJyYXkuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChhcnJheV9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgYXJyYXkgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IEFycmF5LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYm9vbCA9IEJvb2wudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ib29sID0gKEJvb2wuY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBlcXVhbF9ib29sID0gKEJvb2wuZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9ib29sIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQm9vbC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9ib29sIDogYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQm9vbC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGJvb2xfb2Zfc2V4cCA9IChCb29sLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBib29sKVxuICBsZXQgc2V4cF9vZl9ib29sID0gKEJvb2wuc2V4cF9vZl90IDogYm9vbCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJvb2wudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY2hhciA9IENoYXIudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9jaGFyID0gKENoYXIuY29tcGFyZSA6IGNoYXIgLT4gY2hhciAtPiBpbnQpXG4gIGxldCBlcXVhbF9jaGFyID0gKENoYXIuZXF1YWwgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9jaGFyIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQ2hhci5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9jaGFyIDogY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQ2hhci5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGNoYXJfb2Zfc2V4cCA9IChDaGFyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBjaGFyKVxuICBsZXQgc2V4cF9vZl9jaGFyID0gKENoYXIuc2V4cF9vZl90IDogY2hhciAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IENoYXIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZXhuID0gRXhuLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfZXhuID0gKEV4bi5zZXhwX29mX3QgOiBleG4gLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBmbG9hdCA9IEZsb2F0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfZmxvYXQgPSAoRmxvYXQuY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludClcbiAgbGV0IGVxdWFsX2Zsb2F0ID0gKEZsb2F0LmVxdWFsIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9mbG9hdCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBGbG9hdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9mbG9hdCA6IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBGbG9hdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGZsb2F0X29mX3NleHAgPSAoRmxvYXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGZsb2F0KVxuICBsZXQgc2V4cF9vZl9mbG9hdCA9IChGbG9hdC5zZXhwX29mX3QgOiBmbG9hdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gRmxvYXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50ID0gSW50LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50ID0gKEludC5jb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQgPSAoSW50LmVxdWFsIDogaW50IC0+IGludCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgSW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludCA6IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50X29mX3NleHAgPSAoSW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQpXG4gIGxldCBzZXhwX29mX2ludCA9IChJbnQuc2V4cF9vZl90IDogaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQzMiA9IEludDMyLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50MzIgPSAoSW50MzIuY29tcGFyZSA6IGludDMyIC0+IGludDMyIC0+IGludClcbiAgbGV0IGVxdWFsX2ludDMyID0gKEludDMyLmVxdWFsIDogaW50MzIgLT4gaW50MzIgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQzMiA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQzMi5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQzMiA6IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQzMi5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDMyX29mX3NleHAgPSAoSW50MzIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDMyKVxuICBsZXQgc2V4cF9vZl9pbnQzMiA9IChJbnQzMi5zZXhwX29mX3QgOiBpbnQzMiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50MzIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50NjQgPSBJbnQ2NC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDY0ID0gKEludDY0LmNvbXBhcmUgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQ2NCA9IChJbnQ2NC5lcXVhbCA6IGludDY0IC0+IGludDY0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50NjQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50NjQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50NjQgOiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50NjQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQ2NF9vZl9zZXhwID0gKEludDY0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQ2NClcbiAgbGV0IHNleHBfb2ZfaW50NjQgPSAoSW50NjQuc2V4cF9vZl90IDogaW50NjQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDY0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIGxpc3QgPSAnYSBMaXN0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gaW50ID0gTGlzdC5jb21wYXJlXG4gIGxldCBlcXVhbF9saXN0IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gYm9vbCA9IExpc3QuZXF1YWxcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIGxpc3RcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgTGlzdC5oYXNoX2ZvbGRfdFxuICA7O1xuXG4gIGxldCBsaXN0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGxpc3QgPVxuICAgIExpc3QudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfbGlzdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBsaXN0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgTGlzdC5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKGxpc3Rfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgbGlzdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IExpc3QudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBuYXRpdmVpbnQgPSBOYXRpdmVpbnQudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LmNvbXBhcmUgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGludClcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA9IChOYXRpdmVpbnQuZXF1YWwgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfbmF0aXZlaW50IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBOYXRpdmVpbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfb2Zfc2V4cCA9IChOYXRpdmVpbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IG5hdGl2ZWludClcbiAgbGV0IHNleHBfb2ZfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5zZXhwX29mX3QgOiBuYXRpdmVpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIGxldCAobmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIE5hdGl2ZWludC50X3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBvcHRpb24gPSAnYSBPcHRpb24udFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBib29sID1cbiAgICBPcHRpb24uZXF1YWxcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2Egb3B0aW9uXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIE9wdGlvbi5oYXNoX2ZvbGRfdFxuICA7O1xuXG4gIGxldCBvcHRpb25fb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2Egb3B0aW9uID1cbiAgICBPcHRpb24udF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2Zfb3B0aW9uIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIG9wdGlvbiAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIE9wdGlvbi5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKG9wdGlvbl9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2Egb3B0aW9uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBPcHRpb24udF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSByZWYgPSAnYSBSZWYudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPSBSZWYuY29tcGFyZVxuICBsZXQgZXF1YWxfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPSBSZWYuZXF1YWxcblxuICBsZXQgcmVmX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHJlZiA9XG4gICAgUmVmLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3JlZiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSByZWYgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBSZWYuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChyZWZfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgcmVmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVmLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgc3RyaW5nID0gU3RyaW5nLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfc3RyaW5nID0gKFN0cmluZy5jb21wYXJlIDogc3RyaW5nIC0+IHN0cmluZyAtPiBpbnQpXG4gIGxldCBlcXVhbF9zdHJpbmcgPSAoU3RyaW5nLmVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3N0cmluZyA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgU3RyaW5nLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3N0cmluZyA6IHN0cmluZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gU3RyaW5nLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc3RyaW5nX29mX3NleHAgPSAoU3RyaW5nLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBzdHJpbmcpXG4gIGxldCBzZXhwX29mX3N0cmluZyA9IChTdHJpbmcuc2V4cF9vZl90IDogc3RyaW5nIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFN0cmluZy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBieXRlcyA9IEJ5dGVzLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYnl0ZXMgPSAoQnl0ZXMuY29tcGFyZSA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGludClcbiAgbGV0IGVxdWFsX2J5dGVzID0gKEJ5dGVzLmVxdWFsIDogYnl0ZXMgLT4gYnl0ZXMgLT4gYm9vbClcbiAgbGV0IGJ5dGVzX29mX3NleHAgPSAoQnl0ZXMudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJ5dGVzKVxuICBsZXQgc2V4cF9vZl9ieXRlcyA9IChCeXRlcy5zZXhwX29mX3QgOiBieXRlcyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQnl0ZXMudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgdW5pdCA9IFVuaXQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV91bml0ID0gKFVuaXQuY29tcGFyZSA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBlcXVhbF91bml0ID0gKFVuaXQuZXF1YWwgOiB1bml0IC0+IHVuaXQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF91bml0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgVW5pdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF91bml0IDogdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVW5pdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHVuaXRfb2Zfc2V4cCA9IChVbml0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB1bml0KVxuICBsZXQgc2V4cF9vZl91bml0ID0gKFVuaXQuc2V4cF9vZl90IDogdW5pdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFVuaXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gICgqKiBGb3JtYXQgc3R1ZmYgKilcblxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuXG4gICgqKiBMaXN0IG9wZXJhdG9ycyAqKVxuXG4gIGluY2x1ZGUgTGlzdC5JbmZpeFxuXG4gICgqKiBJbnQgb3BlcmF0b3JzIGFuZCBjb21wYXJpc29ucyAqKVxuXG4gIGluY2x1ZGUgSW50Lk9cbiAgaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgKCoqIEZsb2F0IG9wZXJhdG9ycyAqKVxuXG4gIGluY2x1ZGUgRmxvYXQuT19kb3RcblxuICAoKiBUaGlzIGlzIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGJlIG9wdGltaXplZCBhd2F5IGluIG1vcmUgY29udGV4dHMuICopXG5cbiAgKCoqIFJldmVyc2UgYXBwbGljYXRpb24gb3BlcmF0b3IuIFt4IHw+IGcgfD4gZl0gaXMgZXF1aXZhbGVudCB0byBbZiAoZyAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuICAoKiogQXBwbGljYXRpb24gb3BlcmF0b3IuIFtnIEBAIGYgQEAgeF0gaXMgZXF1aXZhbGVudCB0byBbZyAoZiAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuICAoKiogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbiAgKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbiAgZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBleHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuICAoKiBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5LiAqKVxuICBleHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4gICgqKiBDb21tb24gc3RyaW5nIG9wZXJhdGlvbnMgKilcbiAgbGV0ICggXiApID0gU3RyaW5nLiggXiApXG5cbiAgKCoqIFJlZmVyZW5jZSBvcGVyYXRpb25zICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlIGFuZFxuICAgICB0byBrZWVwIHJlZmVyZW5jZSB1bmJveGluZyB3b3JraW5nICopXG4gIGV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbiAgZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuICBleHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbiAgKCoqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBmc3QgPSBmc3RcbiAgbGV0IHNuZCA9IHNuZFxuXG4gICgqKiBFeGNlcHRpb25zIHN0dWZmICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgbWF5IHJld3JpdGUgJyVyYWlzZScgYXMgJyVyZXJhaXNlJy4gKilcbiAgZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxuICBsZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuICBsZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICAoKiogTWlzYyAqKVxuXG4gIGxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG4gIGV4dGVybmFsIGZvcmNlIDogJ2EgTGF6eS50IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuaW5jbHVkZSBDb250YWluZXJfaW50Zi5FeHBvcnQgKCoqIEBpbmxpbmUgKilcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zID0gTm90X2ZvdW5kX3NcblxuKCogV2UgcGVyZm9ybSB0aGVzZSBzaWRlIGVmZmVjdHMgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdGhlbSB0byBydW4gZm9yIGFueSBjb2RlIHRoYXQgdXNlc1xuICAgW0Jhc2VdLiAgSWYgdGhpcyB3ZXJlIGluIGFub3RoZXIgbW9kdWxlIGluIFtCYXNlXSB0aGF0IHdhcyBub3QgdXNlZCBpbiBzb21lIHByb2dyYW0sXG4gICB0aGVuIHRoZSBzaWRlIGVmZmVjdHMgbWlnaHQgbm90IGJlIHJ1biBpbiB0aGF0IHByb2dyYW0uICBUaGlzIHdpbGwgcnVuIGFzIGxvbmcgYXMgdGhlXG4gICBwcm9ncmFtIHJlZmVycyB0byBhdCBsZWFzdCBvbmUgdmFsdWUgZGlyZWN0bHkgaW4gW0Jhc2VdOyByZWZlcnJpbmcgdG8gdmFsdWVzIGluXG4gICBbQmFzZS5Cb29sXSwgZm9yIGV4YW1wbGUsIGlzIG5vdCBzdWZmaWNpZW50LiAqKVxubGV0ICgpID0gQmFja3RyYWNlLmluaXRpYWxpemVfbW9kdWxlICgpXG4iXX0=
