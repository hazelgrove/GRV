// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Incr_map__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incr_map = [0];
   runtime.caml_register_global(0, Incr_map, "Incr_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map__Incr_map_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map_Incr_map_intf = "Incr_map__Incr_map_intf",
    cst_incr_map = "incr_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map_Incr_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[5][1], "src/incr_map_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map_Incr_map_intf);
   var Incr_map_Incr_map_intf = [0];
   runtime.caml_register_global
    (11, Incr_map_Incr_map_intf, cst_Incr_map_Incr_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Core, Core__Bool, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Map, Core__Maybe_bound, Core__Option, Core__Sequence, Core__Set, Core__Tuple, Expect_test_collector, Incr_map__Incr_map_intf, Incremental, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map$0 = "Incr_map",
    cst_incr_map$0 = "incr_map",
    cst_src_incr_map_ml = "src/incr_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Int = global_data.Core__Int,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Incremental = global_data.Incremental,
    Core_Option = global_data.Core__Option,
    Core_Info = global_data.Core__Info,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_List = global_data.Core__List,
    Core_Bool = global_data.Core__Bool,
    Core_Tuple = global_data.Core__Tuple,
    Assert_failure = global_data.Assert_failure,
    Core_Maybe_bound = global_data.Core__Maybe_bound,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Core_Lazy = global_data.Core__Lazy,
    Core_Set = global_data.Core__Set,
    Core_Sequence = global_data.Core__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map$0);
   caml_call1(Expect_test_collector[5][1], cst_src_incr_map_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map$0, cst);
   var
    _F_ = [0, "entries"],
    _G_ = [0, "actual_value"],
    _H_ = [0, "key"],
    _A_ = [0, "node_is_unnecessary"],
    _B_ = [0, "node_is_invalid"],
    _C_ = [0, "node_is_const"],
    _D_ = [0, "node_info"],
    _E_ = [0, "saved_value"],
    _z_ = [0, 1],
    _y_ = [0, 1],
    _x_ = [0, 1],
    _w_ = [0, 1],
    _v_ = [0, 1],
    _u_ = [0, cst_src_incr_map_ml, 1210, 6],
    _t_ = [0, cst_src_incr_map_ml, 1210, 6],
    _s_ = [0, cst_src_incr_map_ml, 1210, 6],
    _r_ = [0, cst_src_incr_map_ml, 1210, 6],
    _q_ = [0, cst_src_incr_map_ml, 1210, 6],
    _p_ = [0, cst_src_incr_map_ml, 1210, 6],
    _o_ = [0, cst_src_incr_map_ml, 1210, 6],
    _n_ = [0, cst_src_incr_map_ml, 1210, 6],
    _l_ = [0, cst_src_incr_map_ml, 1210, 6],
    _m_ = [0, [0, 0, 0]],
    _g_ = [0, "to_"],
    _h_ = [0, "from"],
    cst_Invalid_indices = "Invalid indices",
    _i_ = [0, 0, 0],
    _k_ = [0, cst_src_incr_map_ml, 1194, 10],
    _j_ = [0, cst_src_incr_map_ml, 1195, 10],
    cst_BUG_Hit_supposedly_impossi =
      "BUG: Hit supposedly impossible case in Incr_map.index_by",
    _f_ = [0, 1],
    _e_ = [0, 1],
    cst_impossible_case_BUG_in_inc =
      "impossible case: BUG in incr_map.ml subrange",
    _d_ = [0, 1],
    _c_ = [0, 1],
    _b_ = [0, cst_src_incr_map_ml, 311, 12],
    _a_ = [0, cst_src_incr_map_ml, 238, 11],
    cst_incr_map = cst_incr_map$0,
    cst_Incr_map = cst_Incr_map$0;
   function with_old(i, f){
    var old = [0, 0];
    function _ep_(a){
     var b = caml_call2(f, old[1], a);
     old[1] = [0, [0, a, b]];
     return b;
    }
    return caml_call2(Incremental[76][3][5], i, _ep_);
   }
   function unordered_fold
   (opt, update, specialized_initial, _el_, map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(_el_)
     var sth$0 = _el_[1], revert_to_init_when_empty = sth$0;
    else
     var revert_to_init_when_empty = 0;
    function default$0(key, old_data, new_data, acc){
     return caml_call3
             (add, key, new_data, caml_call3(remove, key, old_data, acc));
    }
    var update$0 = caml_call2(Core_Option[34], update, default$0);
    return with_old
            (map,
             function(old, new_in){
              if(! old){
               if(! specialized_initial)
                return caml_call3(Core_Map[55], new_in, init, add);
               var initial = specialized_initial[1];
               return caml_call2(initial, init, new_in);
              }
              var match = old[1], old_out = match[2], old_in = match[1];
              if(revert_to_init_when_empty){
               var _em_ = caml_call1(Core_Map[29], new_in);
               if(caml_call2(Core[90], _em_, 0)) return init;
              }
              function _en_(acc, param){
               var change = param[2], key = param[1], _eo_ = change[1];
               if(847852583 === _eo_){
                var old = change[2];
                return caml_call3(remove, key, old, acc);
               }
               if(1013247643 <= _eo_){
                var match = change[2], new$0 = match[2], old$0 = match[1];
                return caml_call4(update$0, key, old$0, new$0, acc);
               }
               var new$1 = change[2];
               return caml_call3(add, key, new$1, acc);
              }
              return caml_call5
                      (Core_Map[81], old_in, new_in, data_equal, old_out, _en_);
             });
   }
   function unordered_fold_nested_maps
   (opt, revert_to_init_when_empty, update, incr_map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(update)
     var update$0 = update[1], update$1 = update$0;
    else
     var
      update$1 =
        function(outer_key, inner_key, old_data, new_data, acc){
         return caml_call4
                 (add,
                  outer_key,
                  inner_key,
                  new_data,
                  caml_call4(remove, outer_key, inner_key, old_data, acc));
        };
    function _ee_(outer_key, inner_map, acc){
     function _ek_(inner_key, data, acc){
      return caml_call4(remove, outer_key, inner_key, data, acc);
     }
     return caml_call3(Core_Map[55], inner_map, acc, _ek_);
    }
    function _ef_(outer_key, inner_map, acc){
     function _ej_(inner_key, data, acc){
      return caml_call4(add, outer_key, inner_key, data, acc);
     }
     return caml_call3(Core_Map[55], inner_map, acc, _ej_);
    }
    var _eg_ = 0;
    return unordered_fold
            (0,
             [0,
              function(outer_key, old_inner_map, new_inner_map, acc){
               function _eh_(acc, param){
                var diff = param[2], inner_key = param[1], _ei_ = diff[1];
                if(847852583 === _ei_){
                 var data_removed = diff[2];
                 return caml_call4
                         (remove, outer_key, inner_key, data_removed, acc);
                }
                if(1013247643 <= _ei_){
                 var
                  match = diff[2],
                  new_data = match[2],
                  old_data = match[1];
                 return caml_call5
                         (update$1, outer_key, inner_key, old_data, new_data, acc);
                }
                var data_added = diff[2];
                return caml_call4(add, outer_key, inner_key, data_added, acc);
               }
               return caml_call2
                       (caml_call3
                         (Core_Map[81], old_inner_map, new_inner_map, data_equal),
                        acc,
                        _eh_);
              }],
             _eg_,
             revert_to_init_when_empty,
             incr_map,
             init,
             _ef_,
             _ee_);
   }
   function with_comparator(get_comparator, x, f){
    var
     _ec_ = caml_call2(Incremental[10], x, get_comparator),
     _ed_ = caml_call2(Incremental[34], 0, _ec_);
    return caml_call2(Incremental[26], _ed_, f);
   }
   function with_comparator$0(map, f){
    return with_comparator(Core_Map[2], map, f);
   }
   function of_set(set){
    function _d9_(comparator){
     var
      old_input = [0, caml_call1(Core_Set[3][1], comparator)],
      old_output = [0, caml_call1(Core_Map[110][1], comparator)];
     function _d__(new_input){
      function _d$_(output, param){
       if(0 === param[0]){
        var k = param[1];
        return caml_call2(Core_Map[41], output, k);
       }
       var k$0 = param[1];
       return caml_call3(Core_Map[31], output, k$0, 0);
      }
      var
       _ea_ = old_output[1],
       _eb_ = caml_call2(Core_Set[17], old_input[1], new_input),
       new_output = caml_call3(Core_Sequence[18], _eb_, _ea_, _d$_);
      old_input[1] = new_input;
      old_output[1] = new_output;
      return new_output;
     }
     return caml_call2(Incremental[10], set, _d__);
    }
    return with_comparator(Core_Set[5], set, _d9_);
   }
   function generic_mapi(witness, opt, map){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     return with_old
             (map,
              function(old, input){
               if(0 !== caml_call1(Core_Map[29], input) && old){
                var
                 match = old[1],
                 old_output = match[2],
                 old_input = match[1],
                 _d7_ =
                   function(output, param){
                    var change = param[2], key = param[1], _d8_ = change[1];
                    if(847852583 === _d8_)
                     return caml_call2(Core_Map[41], output, key);
                    var
                     new_data = 1013247643 <= _d8_ ? change[2][2] : change[2],
                     res = caml_call2(f, key, new_data);
                    if(! witness)
                     return caml_call3(Core_Map[32], output, key, res);
                    if(! res) return caml_call2(Core_Map[41], output, key);
                    var output_data = res[1];
                    return caml_call3(Core_Map[32], output, key, output_data);
                   };
                return caml_call5
                        (Core_Map[81],
                         old_input,
                         input,
                         data_equal,
                         old_output,
                         _d7_);
               }
               return witness
                       ? caml_call2(Core_Map[63], input, f)
                       : caml_call2(Core_Map[52], input, f);
              });};
   }
   function mapi(data_equal, map, f){
    return generic_mapi(0, data_equal, map)(f);
   }
   function filter_mapi(data_equal, map, f){
    return generic_mapi(1, data_equal, map)(f);
   }
   function map(data_equal, map, f){
    return mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map(data_equal, map, f){
    return filter_mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function with_old2(i1, i2, f){
    var old = [0, 0];
    function _d6_(a1, a2){
     var b = caml_call3(f, old[1], a1, a2);
     old[1] = [0, [0, a1, a2, b]];
     return b;
    }
    return caml_call3(Incremental[12], i1, i2, _d6_);
   }
   function mapi_count(opt, input, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     function add(new_key, acc){
      function _d5_(param){
       if(! param) return 1;
       var n = param[1];
       return n + 1 | 0;
      }
      return caml_call3(Core_Map[37], acc, new_key, _d5_);
     }
     function remove(new_key, acc){
      function _d4_(param){
       if(! param) return 0;
       var n = param[1];
       return 1 === n ? 0 : [0, n - 1 | 0];
      }
      return caml_call3(Core_Map[36], acc, new_key, _d4_);
     }
     function _dY_(key, data, acc){
      return remove(caml_call2(f, key, data), acc);
     }
     function _dZ_(key, data, acc){return add(caml_call2(f, key, data), acc);}
     var _d0_ = caml_call1(Core_Map[4], comparator), _d1_ = 0, _d2_ = 0;
     return unordered_fold
             ([0, data_equal],
              [0,
               function(key, old_data, new_data, acc){
                var
                 prev_key = caml_call2(f, key, old_data),
                 new_key = caml_call2(f, key, new_data),
                 _d3_ = caml_call2(comparator[1][1], prev_key, new_key);
                return caml_call2(Core[90], _d3_, 0)
                        ? acc
                        : add(new_key, remove(prev_key, acc));
               }],
              _d2_,
              _d1_,
              input,
              _d0_,
              _dZ_,
              _dY_);};
   }
   function map_count(data_equal, input, comparator, f){
    function _dX_(param, data){return caml_call1(f, data);}
    return mapi_count(data_equal, input, comparator)(_dX_);
   }
   function min_helper(map){
    var match = caml_call1(Core_Map[82], map);
    if(! match) return 0;
    var min = match[1][1];
    return [0, min];
   }
   function max_helper(map){
    var match = caml_call1(Core_Map[84], map);
    if(! match) return 0;
    var max = match[1][1];
    return [0, max];
   }
   function bounds_helper(map){
    var
     match = caml_call1(Core_Map[82], map),
     match$0 = caml_call1(Core_Map[84], map);
    if(match){
     if(match$0){
      var max = match$0[1][1], min = match[1][1];
      return [0, [0, min, max]];
     }
    }
    else if(! match$0) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function mapi_min(data_equal, input, comparator, f){
    var _dW_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _dW_, min_helper);
   }
   function mapi_max(data_equal, input, comparator, f){
    var _dV_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _dV_, max_helper);
   }
   function mapi_bounds(data_equal, input, comparator, f){
    var _dU_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _dU_, bounds_helper);
   }
   function mapi_mn(data_equal, input, comparator, f){
    return mapi_min
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function map_max(data_equal, input, comparator, f){
    return mapi_max
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_value(data_equal, input, comparator){
    return mapi_mn
            (data_equal, input, comparator, function(_dT_){return _dT_;});
   }
   function max_value(data_equal, input, comparator){
    return map_max
            (data_equal, input, comparator, function(_dS_){return _dS_;});
   }
   function map_bounds(data_equal, input, comparator, f){
    return mapi_bounds
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function value_bounds(data_equal, input, comparator){
    return map_bounds
            (data_equal, input, comparator, function(_dR_){return _dR_;});
   }
   function merge(opt, _dJ_, left_map, right_map, f){
    if(opt)
     var sth = opt[1], data_equal_left = sth;
    else
     var data_equal_left = Core[246];
    if(_dJ_)
     var sth$0 = _dJ_[1], data_equal_right = sth$0;
    else
     var data_equal_right = Core[246];
    return with_old2
            (left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var comparator = caml_call1(Core_Map[2], new_left_map);
              if(old)
               var
                x = old[1],
                old_output = x[3],
                old_right_map = x[2],
                old_left_map = x[1];
              else
               var
                old_left_map$0 = caml_call1(Core_Map[110][1], comparator),
                old_output = old_left_map$0,
                old_right_map = old_left_map$0,
                old_left_map = old_left_map$0;
              var
               left_diff =
                 caml_call3
                  (Core_Map[80], old_left_map, new_left_map, data_equal_left),
               right_diff =
                 caml_call3
                  (Core_Map[80],
                   old_right_map,
                   new_right_map,
                   data_equal_right);
              function _dK_(output, diff_element){
               if(2 === diff_element[0]){
                var
                 right_key = diff_element[2][1],
                 left_key = diff_element[1][1],
                 _dP_ = caml_call2(comparator[1], left_key, right_key);
                if(! caml_call2(Core[90], _dP_, 0))
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _b_], 1);
                var key$0 = left_key;
               }
               else
                var key = diff_element[1][1], key$0 = key;
               function new_data(param){
                var _dQ_ = param[1];
                if(847852583 === _dQ_) return 0;
                var x = 1013247643 <= _dQ_ ? param[2][2] : param[2];
                return [0, x];
               }
               switch(diff_element[0]){
                 case 0:
                  var
                   left_diff = diff_element[1][2],
                   right_data_opt =
                     caml_call2(Core_Map[38], new_right_map, key$0),
                   right_data_opt$0 = right_data_opt,
                   left_data_opt = new_data(left_diff);
                  break;
                 case 1:
                  var
                   right_diff = diff_element[1][2],
                   right_data_opt$1 = new_data(right_diff),
                   right_data_opt$0 = right_data_opt$1,
                   left_data_opt =
                     caml_call2(Core_Map[38], new_left_map, key$0);
                  break;
                 default:
                  var
                   right_diff$0 = diff_element[2][2],
                   left_diff$0 = diff_element[1][2],
                   right_data_opt$2 = new_data(right_diff$0),
                   left_data_opt$0 = new_data(left_diff$0),
                   right_data_opt$0 = right_data_opt$2,
                   left_data_opt = left_data_opt$0;
               }
               if(left_data_opt){
                var x = left_data_opt[1];
                if(right_data_opt$0)
                 var
                  y = right_data_opt$0[1],
                  _dO_ = caml_call2(f, key$0, [0, 737457313, [0, x, y]]);
                else
                 var _dO_ = caml_call2(f, key$0, [0, 847852583, x]);
                var output_data_opt = _dO_;
               }
               else if(right_data_opt$0)
                var
                 y$0 = right_data_opt$0[1],
                 output_data_opt = caml_call2(f, key$0, [0, -57574468, y$0]);
               else
                var output_data_opt = 0;
               if(! output_data_opt)
                return caml_call2(Core_Map[41], output, key$0);
               var data = output_data_opt[1];
               return caml_call3(Core_Map[32], output, key$0, data);
              }
              function _dL_(param, _dN_){
               var right_key = _dN_[1], left_key = param[1];
               return caml_call2(comparator[1], left_key, right_key);
              }
              var
               _dM_ =
                 caml_call3(Core_Sequence[62], left_diff, right_diff, _dL_);
              return caml_call3(Core_Sequence[18], _dM_, old_output, _dK_);
             });
   }
   function generic_mapi_with_comparator(witness, cutoff, opt, lhs){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(comparator, f){
     var
      incremental_state = caml_call1(Incremental[4], lhs),
      empty_map = caml_call1(Core_Map[110][1], comparator),
      prev_map = [0, empty_map],
      prev_nodes = [0, empty_map],
      acc = [0, empty_map];
     function _dt_(param){return acc[1];}
     var
      result = caml_call3(Incremental[79][2][2], incremental_state, 0, _dt_),
      on_inner_change =
        witness
         ? function
          (key, opt){
           var old = acc[1];
           if(opt)
            var
             data = opt[1],
             _dI_ = caml_call3(Core_Map[32], old, key, data);
           else
            var _dI_ = caml_call2(Core_Map[41], old, key);
           acc[1] = _dI_;
           return 0;
          }
         : function
          (key, data){
           acc[1] = caml_call3(Core_Map[32], acc[1], key, data);
           return 0;
          },
      lhs_change = [];
     caml_update_dummy
      (lhs_change,
       [246,
        function(_dw_){
         function _dx_(map){
          function _dy_(nodes, param){
           var changed = param[2], key = param[1], _dz_ = changed[1];
           if(847852583 === _dz_){
            var
             match = caml_call2(Core_Map[39], nodes, key),
             dep = match[2],
             node = match[1],
             nodes$0 = caml_call2(Core_Map[41], nodes, key);
            caml_call2(Incremental[79][2][7], result, dep);
            acc[1] = caml_call2(Core_Map[41], acc[1], key);
            caml_call1(Incremental[79][2][5], node);
            return nodes$0;
           }
           if(1013247643 <= _dz_){
            var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
            caml_call1(Incremental[79][2][4], node$0);
            return nodes;
           }
           function _dA_(param){
            return caml_call2(Core_Map[39], prev_map[1], key);
           }
           var
            node$1 =
              caml_call3(Incremental[79][2][2], incremental_state, 0, _dA_);
           function _dB_(c){
            var _dH_ = caml_call1(Incremental[79][2][3], node$1);
            return caml_call2(Incremental[59], _dH_, c);
           }
           caml_call2(Core_Option[41], cutoff, _dB_);
           var
            _dC_ = caml_call1(Core[237], lhs_change),
            _dD_ = caml_call2(Incremental[79][1][2], 0, _dC_);
           caml_call2(Incremental[79][2][6], node$1, _dD_);
           var
            _dE_ =
              caml_call2(f, key, caml_call1(Incremental[79][2][3], node$1)),
            _dF_ = [0, function(_dG_){return on_inner_change(key, _dG_);}],
            user_function_dep = caml_call2(Incremental[79][1][2], _dF_, _dE_);
           caml_call2(Incremental[79][2][6], result, user_function_dep);
           return caml_call3
                   (Core_Map[32], nodes, key, [0, node$1, user_function_dep]);
          }
          var
           new_nodes =
             caml_call5
              (Core_Map[81],
               prev_map[1],
               map,
               data_equal,
               prev_nodes[1],
               _dy_);
          prev_nodes[1] = new_nodes;
          prev_map[1] = map;
          return 0;
         }
         return caml_call2(Incremental[10], lhs, _dx_);
        }]);
     var
      _du_ = caml_call1(Core[237], lhs_change),
      _dv_ = caml_call2(Incremental[79][1][2], 0, _du_);
     caml_call2(Incremental[79][2][6], result, _dv_);
     return caml_call1(Incremental[79][2][3], result);};
   }
   function filter_mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(1, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(0, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function map$0(cutoff, data_equal, map, f){
    return mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map$0(cutoff, data_equal, map, f){
    return filter_mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function merge$0(cutoff, data_equal_left, data_equal_right, map1, map2, f){
    function _ds_(key, diff){return caml_call2(f, key, diff);}
    return filter_mapi$0
            (cutoff,
             0,
             merge
              (data_equal_left,
               data_equal_right,
               map1,
               map2,
               function(param, diff){return [0, diff];}),
             _ds_);
   }
   function unzip_mapi
   (data_equal, left_result_equal, right_result_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          if(left_result_equal)
           var sth$0 = left_result_equal[1], left_result_equal$0 = sth$0;
          else
           var left_result_equal$0 = Core[246];
          if(right_result_equal)
           var sth$1 = right_result_equal[1], right_result_equal$0 = sth$1;
          else
           var right_result_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           left_acc = [0, empty_map];
          function _dd_(param){return left_acc[1];}
          var
           left_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _dd_),
           right_acc = [0, empty_map];
          function _de_(param){return right_acc[1];}
          var
           right_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _de_),
           prev_map = [0, empty_map];
          function _df_(map){
           var
            match = caml_call1(Core_Map[28], prev_map[1]),
            match$0 = caml_call1(Core_Map[28], map);
           a:
           {
            if(match){
             if(! match$0){
              var
               _dk_ =
                 function(key, data){
                  var l = caml_call2(f, key, data)[1];
                  return l;
                 },
               left$0 = caml_call2(Core_Map[52], map, _dk_),
               _dl_ =
                 function(key, data){
                  var r = caml_call2(f, key, data)[2];
                  return r;
                 },
               right$0 = caml_call2(Core_Map[52], map, _dl_),
               right = right$0,
               left = left$0;
              break a;
             }
            }
            else if(! match$0){
             var
              _dm_ =
                function(param, _do_){
                 var
                  changed = _do_[2],
                  key = _do_[1],
                  right = param[2],
                  left = param[1],
                  _dp_ = changed[1];
                 if(847852583 === _dp_){
                  var _dq_ = caml_call2(Core_Map[41], right, key);
                  return [0, caml_call2(Core_Map[41], left, key), _dq_];
                 }
                 if(1013247643 <= _dp_){
                  var
                   match = changed[2],
                   new$0 = match[2],
                   prev = match[1],
                   match$0 = caml_call2(f, key, prev),
                   prev_b = match$0[2],
                   prev_a = match$0[1],
                   match$1 = caml_call2(f, key, new$0),
                   new_b = match$1[2],
                   new_a = match$1[1],
                   left$0 =
                     caml_call2(left_result_equal$0, prev_a, new_a)
                      ? left
                      : caml_call3(Core_Map[32], left, key, new_a),
                   right$0 =
                     caml_call2(right_result_equal$0, prev_b, new_b)
                      ? right
                      : caml_call3(Core_Map[32], right, key, new_b);
                  return [0, left$0, right$0];
                 }
                 var
                  element = changed[2],
                  match$2 = caml_call2(f, key, element),
                  b = match$2[2],
                  a = match$2[1],
                  _dr_ = caml_call3(Core_Map[32], right, key, b);
                 return [0, caml_call3(Core_Map[32], left, key, a), _dr_];
                },
              _dn_ =
                caml_call5
                 (Core_Map[81],
                  prev_map[1],
                  map,
                  data_equal$0,
                  [0, left_acc[1], right_acc[1]],
                  _dm_),
              right = _dn_[2],
              left = _dn_[1];
             break a;
            }
            var right = empty_map, left = empty_map;
           }
           if(1 - caml_call2(Core[246], left_acc[1], left))
            caml_call1(Incremental[79][2][4], left_result);
           if(1 - caml_call2(Core[246], right_acc[1], right))
            caml_call1(Incremental[79][2][4], right_result);
           left_acc[1] = left;
           right_acc[1] = right;
           prev_map[1] = map;
           return 0;
          }
          var
           input_change = caml_call2(Incremental[10], input, _df_),
           _dg_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], left_result, _dg_);
          var _dh_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], right_result, _dh_);
          var
           _di_ = caml_call1(Incremental[79][2][3], right_result),
           _dj_ = [0, caml_call1(Incremental[79][2][3], left_result), _di_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _dj_);
         });
    function _c__(_dc_){return _dc_[2];}
    var _c$_ = caml_call2(Incremental[10], pair, _c__);
    function _da_(_db_){return _db_[1];}
    return [0, caml_call2(Incremental[10], pair, _da_), _c$_];
   }
   function unzip(left_result_equal, right_result_equal, input){
    function _c9_(l, r){return caml_call2(Core_Tuple[1][10], l, r);}
    var
     data_equal =
       caml_call3
        (Core_Option[23], left_result_equal, right_result_equal, _c9_);
    return unzip_mapi
            (data_equal,
             left_result_equal,
             right_result_equal,
             input,
             function(param, data){return data;});
   }
   function unzip_mapi$0(cutoff, data_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           prev_map = [0, empty_map],
           prev_nodes = [0, empty_map],
           left_acc = [0, empty_map];
          function _cQ_(param){return left_acc[1];}
          var
           left_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _cQ_),
           right_acc = [0, empty_map];
          function _cR_(param){return right_acc[1];}
          var
           right_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _cR_),
           input_change = [];
          caml_update_dummy
           (input_change,
            [246,
             function(_cY_){
              function _cZ_(map){
               function _c0_(nodes, param){
                var changed = param[2], key = param[1], _c1_ = changed[1];
                if(847852583 === _c1_){
                 var
                  match = caml_call2(Core_Map[39], nodes, key),
                  right_dep = match[3],
                  left_dep = match[2],
                  node = match[1],
                  nodes$0 = caml_call2(Core_Map[41], nodes, key);
                 caml_call2(Incremental[79][2][7], left_result, left_dep);
                 caml_call2(Incremental[79][2][7], right_result, right_dep);
                 left_acc[1] = caml_call2(Core_Map[41], left_acc[1], key);
                 right_acc[1] = caml_call2(Core_Map[41], right_acc[1], key);
                 caml_call1(Incremental[79][2][5], node);
                 return nodes$0;
                }
                if(1013247643 <= _c1_){
                 var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
                 caml_call1(Incremental[79][2][4], node$0);
                 return nodes;
                }
                function _c2_(param){
                 return caml_call2(Core_Map[39], prev_map[1], key);
                }
                var
                 node$1 =
                   caml_call3
                    (Incremental[79][2][2], incremental_state, 0, _c2_);
                function _c3_(c){
                 var _c8_ = caml_call1(Incremental[79][2][3], node$1);
                 return caml_call2(Incremental[59], _c8_, c);
                }
                caml_call2(Core_Option[41], cutoff, _c3_);
                var
                 _c4_ = caml_call1(Core[237], input_change),
                 _c5_ = caml_call2(Incremental[79][1][2], 0, _c4_);
                caml_call2(Incremental[79][2][6], node$1, _c5_);
                var
                 match$0 =
                   caml_call2
                    (f, key, caml_call1(Incremental[79][2][3], node$1)),
                 right_incr = match$0[2],
                 left_incr = match$0[1],
                 _c6_ =
                   [0,
                    function(data){
                     left_acc[1] =
                      caml_call3(Core_Map[32], left_acc[1], key, data);
                     return 0;
                    }],
                 left_user_function_dep =
                   caml_call2(Incremental[79][1][2], _c6_, left_incr),
                 _c7_ =
                   [0,
                    function(data){
                     right_acc[1] =
                      caml_call3(Core_Map[32], right_acc[1], key, data);
                     return 0;
                    }],
                 right_user_function_dep =
                   caml_call2(Incremental[79][1][2], _c7_, right_incr);
                caml_call2
                 (Incremental[79][2][6], left_result, left_user_function_dep);
                caml_call2
                 (Incremental[79][2][6],
                  right_result,
                  right_user_function_dep);
                return caml_call3
                        (Core_Map[32],
                         nodes,
                         key,
                         [0, node$1, left_user_function_dep, right_user_function_dep]);
               }
               var
                new_nodes =
                  caml_call5
                   (Core_Map[81],
                    prev_map[1],
                    map,
                    data_equal$0,
                    prev_nodes[1],
                    _c0_);
               prev_nodes[1] = new_nodes;
               prev_map[1] = map;
               return 0;
              }
              return caml_call2(Incremental[10], input, _cZ_);
             }]);
          var
           _cS_ = caml_call1(Core[237], input_change),
           _cT_ = caml_call2(Incremental[79][1][2], 0, _cS_);
          caml_call2(Incremental[79][2][6], left_result, _cT_);
          var
           _cU_ = caml_call1(Core[237], input_change),
           _cV_ = caml_call2(Incremental[79][1][2], 0, _cU_);
          caml_call2(Incremental[79][2][6], right_result, _cV_);
          var
           _cW_ = caml_call1(Incremental[79][2][3], right_result),
           _cX_ = [0, caml_call1(Incremental[79][2][3], left_result), _cW_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _cX_);
         });
    function _cL_(_cP_){return _cP_[2];}
    var _cM_ = caml_call2(Incremental[10], pair, _cL_);
    function _cN_(_cO_){return _cO_[1];}
    return [0, caml_call2(Incremental[10], pair, _cN_), _cM_];
   }
   function keys(map){
    return with_comparator$0
            (map,
             function(comparator){
              function add(key, param, acc){
               return caml_call2(Core_Set[11], acc, key);
              }
              function remove(key, param, acc){
               return caml_call2(Core_Set[12], acc, key);
              }
              function data_equal(param, _cK_){return 1;}
              return unordered_fold
                      ([0, data_equal],
                       0,
                       0,
                       _c_,
                       map,
                       caml_call1(Core_Set[3][1], comparator),
                       add,
                       remove);
             });
   }
   function partition_mapi(data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              var empty = caml_call1(Core_Map[110][1], comparator);
              function _cB_(key, param, _cI_){
               var
                second = _cI_[2],
                first = _cI_[1],
                _cJ_ = caml_call2(Core_Map[41], second, key);
               return [0, caml_call2(Core_Map[41], first, key), _cJ_];
              }
              function _cC_(key, data, param){
               var
                second = param[2],
                first = param[1],
                match = caml_call2(f, key, data);
               if(0 === match[0]){
                var data$0 = match[1];
                return [0,
                        caml_call3(Core_Map[31], first, key, data$0),
                        second];
               }
               var data$1 = match[1];
               return [0,
                       first,
                       caml_call3(Core_Map[31], second, key, data$1)];
              }
              var _cD_ = [0, empty, empty], _cE_ = 0;
              return unordered_fold
                      (data_equal,
                       [0,
                        function(key, param, data, _cF_){
                         var
                          second = _cF_[2],
                          first = _cF_[1],
                          match = caml_call2(f, key, data);
                         if(0 === match[0]){
                          var
                           data$0 = match[1],
                           _cG_ = caml_call2(Core_Map[41], second, key);
                          return [0,
                                  caml_call3(Core_Map[32], first, key, data$0),
                                  _cG_];
                         }
                         var
                          data$1 = match[1],
                          _cH_ = caml_call3(Core_Map[32], second, key, data$1);
                         return [0, caml_call2(Core_Map[41], first, key), _cH_];
                        }],
                       _cE_,
                       _d_,
                       map,
                       _cD_,
                       _cC_,
                       _cB_);
             });
   }
   function flatten(state, map){
    var
     _cw_ = caml_call1(Core_Map[2], map),
     result = [0, caml_call1(Core_Map[110][1], _cw_)];
    function _cx_(param){return result[1];}
    var node = caml_call3(Incremental[79][2][2], state, 0, _cx_);
    function _cy_(key, incr){
     var
      _cz_ =
        [0,
         function(a){
          result[1] = caml_call3(Core_Map[32], result[1], key, a);
          return 0;
         }],
      _cA_ = caml_call2(Incremental[79][1][2], _cz_, incr);
     return caml_call2(Incremental[79][2][6], node, _cA_);
    }
    caml_call2(Core_Map[45], map, _cy_);
    return caml_call1(Incremental[79][2][3], node);
   }
   function join(map_incr){
    return with_comparator$0
            (map_incr,
             function(comparator){
              var
               incremental_state = caml_call1(Incremental[4], map_incr),
               empty_map = caml_call1(Core_Map[110][1], comparator),
               result_map = [0, empty_map],
               old_map_of_incrs = [0, empty_map],
               current_dependencies = [0, empty_map];
              function _cq_(param){return result_map[1];}
              var
               result =
                 caml_call3(Incremental[79][2][2], incremental_state, 0, _cq_);
              function add_subnode(current_dependencies, key, data_node){
               var
                _cv_ =
                  [0,
                   function(data){
                    result_map[1] =
                     caml_call3(Core_Map[32], result_map[1], key, data);
                    return 0;
                   }],
                new_dep = caml_call2(Incremental[79][1][2], _cv_, data_node);
               caml_call2(Incremental[79][2][6], result, new_dep);
               return caml_call3
                       (Core_Map[32], current_dependencies, key, new_dep);
              }
              function remove_subnode(current_dependencies, key){
               var dep = caml_call2(Core_Map[39], current_dependencies, key);
               caml_call2(Incremental[79][2][7], result, dep);
               result_map[1] = caml_call2(Core_Map[41], result_map[1], key);
               return caml_call2(Core_Map[41], current_dependencies, key);
              }
              function _cr_(map_of_incrs){
               function _ct_(current_dependencies, param){
                var diff = param[2], key = param[1], _cu_ = diff[1];
                if(847852583 === _cu_)
                 return remove_subnode(current_dependencies, key);
                if(1013247643 <= _cu_){
                 var data_node = diff[2][2];
                 return add_subnode
                         (remove_subnode(current_dependencies, key), key, data_node);
                }
                var data_node$0 = diff[2];
                return add_subnode(current_dependencies, key, data_node$0);
               }
               var
                new_dependency_map =
                  caml_call5
                   (Core_Map[81],
                    old_map_of_incrs[1],
                    map_of_incrs,
                    Core[246],
                    current_dependencies[1],
                    _ct_);
               current_dependencies[1] = new_dependency_map;
               old_map_of_incrs[1] = map_of_incrs;
               return 0;
              }
              var
               lhs_change = caml_call2(Incremental[10], map_incr, _cr_),
               _cs_ = caml_call2(Incremental[79][1][2], 0, lhs_change);
              caml_call2(Incremental[79][2][6], result, _cs_);
              return caml_call1(Incremental[79][2][3], result);
             });
   }
   function separate(input_map, data_equal){
    var incremental_state = caml_call1(Incremental[4], input_map);
    return with_comparator$0
            (input_map,
             function(comparator){
              var
               empty = caml_call1(Core_Map[110][1], comparator),
               state = [0, empty, empty, empty];
              function _ce_(param){return state[3];}
              var
               output_map_node =
                 caml_call3(Incremental[79][2][2], incremental_state, 0, _ce_);
              function make_node_depend_on_input_map_(node, input_map_changed){
               var
                _cp_ = caml_call1(Core_Lazy[32], input_map_changed),
                dependency = caml_call2(Incremental[79][1][2], 0, _cp_);
               return caml_call2(Incremental[79][2][6], node, dependency);
              }
              var input_map_changed = [];
              caml_update_dummy
               (input_map_changed,
                [246,
                 function(_cf_){
                  function _cg_(input_map){
                   var prev_input_map = state[1];
                   function _ch_(param, _cj_){
                    var
                     change = _cj_[2],
                     key = _cj_[1],
                     output_map = param[2],
                     expert_nodes = param[1],
                     _ck_ = change[1];
                    if(847852583 === _ck_){
                     var old_node = caml_call2(Core_Map[39], expert_nodes, key);
                     caml_call1(Incremental[79][2][5], old_node);
                     caml_call1(Incremental[79][2][4], output_map_node);
                     var _cl_ = caml_call2(Core_Map[41], output_map, key);
                     return [0,
                             caml_call2(Core_Map[41], expert_nodes, key),
                             _cl_];
                    }
                    if(1013247643 <= _ck_){
                     var _cm_ = caml_call2(Core_Map[39], expert_nodes, key);
                     caml_call1(Incremental[79][2][4], _cm_);
                     return [0, expert_nodes, output_map];
                    }
                    function _ci_(param){
                     return caml_call2(Core_Map[39], state[1], key);
                    }
                    var
                     node =
                       caml_call3
                        (Incremental[79][2][2], incremental_state, 0, _ci_);
                    make_node_depend_on_input_map_(node, input_map_changed);
                    caml_call1(Incremental[79][2][4], output_map_node);
                    var
                     _cn_ = caml_call1(Incremental[79][2][3], node),
                     _co_ = caml_call3(Core_Map[31], output_map, key, _cn_);
                    return [0,
                            caml_call3(Core_Map[31], expert_nodes, key, node),
                            _co_];
                   }
                   var
                    match =
                      caml_call5
                       (Core_Map[81],
                        prev_input_map,
                        input_map,
                        data_equal,
                        [0, state[2], state[3]],
                        _ch_),
                    output_map = match[2],
                    expert_nodes = match[1];
                   state[1] = input_map;
                   state[2] = expert_nodes;
                   state[3] = output_map;
                   return 0;
                  }
                  return caml_call2(Incremental[10], input_map, _cg_);
                 }]);
              make_node_depend_on_input_map_
               (output_map_node, input_map_changed);
              return caml_call1(Incremental[79][2][3], output_map_node);
             });
   }
   function subrange(opt, map_incr){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(range){
     return with_old2
             (map_incr,
              range,
              function(old, map, range){
               var compare = caml_call1(Core_Map[2], map)[1];
               function equal(l, r){
                var _cd_ = caml_call2(compare, l, r);
                return caml_call2(Core[90], _cd_, 0);
               }
               function maybe_bound_equal(a_002, b_003){
                if(caml_call2(Ppx_compare_lib[1], a_002, b_003)) return 1;
                if(typeof a_002 === "number"){
                 if(typeof b_003 === "number") return 1;
                 if(1 === b_003[0]) return 0;
                }
                else{
                 if(0 === a_002[0]){
                  var a_004 = a_002[1];
                  if(typeof b_003 !== "number" && 0 === b_003[0]){
                   var b_005 = b_003[1];
                   return equal(a_004, b_005);
                  }
                  return 0;
                 }
                 var a_006 = a_002[1];
                 if(typeof b_003 === "number") return 0;
                 if(0 !== b_003[0]){
                  var b_007 = b_003[1];
                  return equal(a_006, b_007);
                 }
                }
                return 0;
               }
               function range_is_empty(min, max){
                a:
                if(typeof min !== "number"){
                 if(0 === min[0]){
                  var min$0 = min[1];
                  if(typeof max === "number") break a;
                  if(0 === max[0]){
                   var
                    max$0 = max[1],
                    _ca_ = caml_call2(compare, min$0, max$0);
                   return caml_call2(Core[91], _ca_, 0);
                  }
                  var max$1 = max[1], min$1 = min$0;
                 }
                 else{
                  var _cc_ = min[1];
                  if(typeof max === "number") break a;
                  var max$1 = max[1], min$1 = _cc_;
                 }
                 var _cb_ = caml_call2(compare, min$1, max$1);
                 return caml_call2(Core[88], _cb_, 0);
                }
                return 0;
               }
               function range_includes(min, max, key){
                var
                 _b$_ = caml_call3(Core_Maybe_bound[17], min, key, compare);
                return _b$_
                        ? caml_call3(Core_Maybe_bound[18], max, key, compare)
                        : _b$_;
               }
               if(! range){
                var _b4_ = caml_call1(Core_Map[2], map);
                return caml_call1(Core_Map[110][1], _b4_);
               }
               var range$0 = range[1], max = range$0[2], min = range$0[1];
               function from_scratch(param){
                return caml_call3(Core_Map[94], map, min, max);
               }
               if(old){
                var _b2_ = old[1], match = _b2_[2];
                if(match){
                 var
                  old_range = match[1],
                  old_min = old_range[1],
                  old_map = _b2_[1],
                  old_max = old_range[2];
                 if
                  (!
                   range_is_empty(old_min, old_max)
                   &&
                    !
                    range_is_empty(min, old_max)
                    && ! range_is_empty(old_min, max)){
                  var
                   old_res = _b2_[3],
                   old_max$0 = old_range[2],
                   _b3_ =
                     function(param){
                      function apply_diff_in_intersection(param$0, _b8_){
                       var
                        data = _b8_[2],
                        key = _b8_[1],
                        map = param$0[2],
                        outside = param$0[1],
                        _b7_ = range_includes(min, max, key),
                        _b9_ = _b7_ ? range_includes(old_min, old_max$0, key) : _b7_;
                       if(! _b9_){
                        var outside$0 = outside - 1 | 0;
                        return 0 <= outside$0
                                ? [0, outside$0, caml_call2(Core_Map[41], map, key)]
                                : caml_call1(param, from_scratch(0));
                       }
                       var _b__ = data[1];
                       if(847852583 === _b__)
                        return [0, outside, caml_call2(Core_Map[41], map, key)];
                       var data$0 = 1013247643 <= _b__ ? data[2][2] : data[2];
                       return [0,
                               outside,
                               caml_call3(Core_Map[32], map, key, data$0)];
                      }
                      var
                       outside_cutoff = caml_call1(Core_Map[29], old_res) / 4 | 0,
                       with_updated_values_in_interse =
                         caml_call5
                           (Core_Map[81],
                            old_map,
                            map,
                            data_equal,
                            [0, outside_cutoff, old_res],
                            apply_diff_in_intersection)
                          [2];
                      if
                       (caml_call4
                         (Core_Tuple[1][10],
                          maybe_bound_equal,
                          maybe_bound_equal,
                          old_range,
                          range$0))
                       return with_updated_values_in_interse;
                      var
                       without_keys_out_of_range =
                         caml_call3
                          (Core_Map[94], with_updated_values_in_interse, min, max);
                      function map_append_exn(lower_part, upper_part){
                       var
                        match = caml_call2(Core_Map[93], lower_part, upper_part);
                       if(typeof match === "number")
                        return caml_call1(Core[6], cst_impossible_case_BUG_in_inc);
                       var map = match[2];
                       return map;
                      }
                      if(typeof old_min === "number")
                       var
                        _b5_ = caml_call1(Core_Map[2], map),
                        lower_part = caml_call1(Core_Map[110][1], _b5_);
                      else if(0 === old_min[0])
                       var
                        old_min$0 = old_min[1],
                        lower_part =
                          caml_call3(Core_Map[94], map, min, [1, old_min$0]);
                      else
                       var
                        old_min$1 = old_min[1],
                        lower_part =
                          caml_call3(Core_Map[94], map, min, [0, old_min$1]);
                      if(typeof old_max$0 === "number")
                       var
                        _b6_ = caml_call1(Core_Map[2], map),
                        upper_part = caml_call1(Core_Map[110][1], _b6_);
                      else if(0 === old_max$0[0])
                       var
                        old_max = old_max$0[1],
                        upper_part =
                          caml_call3(Core_Map[94], map, [1, old_max], max);
                      else
                       var
                        old_max$1 = old_max$0[1],
                        upper_part =
                          caml_call3(Core_Map[94], map, [0, old_max$1], max);
                      var
                       with_new_keys_now_in_range =
                         map_append_exn
                          (lower_part,
                           map_append_exn(without_keys_out_of_range, upper_part));
                      return with_new_keys_now_in_range;
                     };
                  return caml_call1(Core[260], _b3_);
                 }
                 return from_scratch(0);
                }
               }
               return from_scratch(0);
              });};
   }
   function rekey(data_equal, map_incr, outer_comparator, f){
    function _bU_(key, data, output){
     var _b1_ = caml_call2(f, key, data);
     return caml_call2(Core_Map[41], output, _b1_);
    }
    function _bV_(key, data, output){
     var _b0_ = caml_call2(f, key, data);
     return caml_call3(Core_Map[31], output, _b0_, data);
    }
    var _bW_ = caml_call1(Core_Map[4], outer_comparator), _bX_ = 0;
    return unordered_fold
            (data_equal,
             [0,
              function(key, old_data, new_data, output){
               var
                prev_key = caml_call2(f, key, old_data),
                new_key = caml_call2(f, key, new_data),
                _bY_ =
                  caml_call2
                   (caml_call1(Core_Map[2], output)[1], prev_key, new_key);
               if(caml_call2(Core[90], _bY_, 0))
                return caml_call3(Core_Map[32], output, new_key, new_data);
               var _bZ_ = caml_call2(Core_Map[41], output, prev_key);
               return caml_call3(Core_Map[31], _bZ_, new_key, new_data);
              }],
             _bX_,
             _e_,
             map_incr,
             _bW_,
             _bV_,
             _bU_);
   }
   function index_byi(data_equal, map_incr, outer_comparator, index){
    return with_comparator$0
            (map_incr,
             function(inner_comparator){
              function _bQ_(inner_key, data, outer_map){
               var match = caml_call2(index, inner_key, data);
               if(! match) return outer_map;
               var outer_key = match[1];
               function _bT_(param){
                if(! param)
                 return caml_call1(Core[6], cst_BUG_Hit_supposedly_impossi);
                var
                 inner_map = param[1],
                 inner_map$0 = caml_call2(Core_Map[41], inner_map, inner_key);
                return caml_call1(Core_Map[28], inner_map$0)
                        ? 0
                        : [0, inner_map$0];
               }
               return caml_call3(Core_Map[36], outer_map, outer_key, _bT_);
              }
              function _bR_(inner_key, data, outer_map){
               var match = caml_call2(index, inner_key, data);
               if(! match) return outer_map;
               var outer_key = match[1];
               function _bS_(param){
                if(! param)
                 return caml_call3
                         (Core_Map[110][2], inner_comparator, inner_key, data);
                var inner_map = param[1];
                return caml_call3(Core_Map[31], inner_map, inner_key, data);
               }
               return caml_call3(Core_Map[37], outer_map, outer_key, _bS_);
              }
              return unordered_fold
                      (data_equal,
                       0,
                       0,
                       _f_,
                       map_incr,
                       caml_call1(Core_Map[4], outer_comparator),
                       _bR_,
                       _bQ_);
             });
   }
   function index_by(data_equal, map_incr, comparator, index){
    return index_byi
            (data_equal,
             map_incr,
             comparator,
             function(param, data){return caml_call1(index, data);});
   }
   function is_known(param){
    if(typeof param === "number" && param) return 0;
    return 1;
   }
   function to_option(param){
    if(typeof param === "number") return 0;
    var k = param[1];
    return [0, k];
   }
   function find_key_range_linear(from, to, map){
    var
     len = caml_call1(Core_Map[29], map),
     begin_key = caml_call2(Core_Int[84], from, len) ? 0 : 1,
     end_key = caml_call2(Core_Int[84], to, len) ? 0 : 1;
    function find_keys(fold, start_pos, advance_pos){
     function _bO_(param){
      return caml_call3
              (fold,
               map,
               [0, begin_key, end_key, start_pos],
               function(key, param$0, _bP_){
                var
                 pos = _bP_[3],
                 end_key = _bP_[2],
                 begin_key = _bP_[1],
                 begin_key$0 =
                   caml_call2(Core_Int[86], pos, from) ? [0, key] : begin_key,
                 end_key$0 =
                   caml_call2(Core_Int[86], pos, to) ? [0, key] : end_key;
                if(is_known(begin_key$0) && is_known(end_key$0))
                 return caml_call1(param, [0, begin_key$0, end_key$0, pos]);
                return [0,
                        begin_key$0,
                        end_key$0,
                        caml_call1(advance_pos, pos)];
               });
     }
     return caml_call1(Core[260], _bO_);
    }
    if(caml_call2(Core[92], to, len - from | 0))
     var
      _bK_ = function(pos){return pos + 1 | 0;},
      match = find_keys(Core_Map[55], 0, _bK_);
    else
     var
      _bN_ = function(pos){return pos - 1 | 0;},
      match = find_keys(Core_Map[57], len - 1 | 0, _bN_);
    var end_key$0 = match[2], begin_key$0 = match[1];
    function _bL_(begin_key){return [0, begin_key, to_option(end_key$0)];}
    var _bM_ = to_option(begin_key$0);
    return caml_call2(Core_Option[29], _bM_, _bL_);
   }
   function rank(map, key){
    return with_comparator$0
            (map,
             function(comparator){
              var compare_key = comparator[1];
              function same_key(a, b){
               var _bJ_ = caml_call2(compare_key, a, b);
               return caml_call2(Core[90], _bJ_, 0);
              }
              function process(old, new_map, new_key){
               var old$0 = old;
               for(;;){
                if(! caml_call2(Core_Map[42], new_map, new_key)) return 0;
                if(old$0){
                 var
                  match = old$0[1],
                  old_rank = match[3],
                  old_key = match[2],
                  old_map = match[1];
                 if
                  (caml_call2(Core[246], new_map, old_map)
                   && same_key(old_key, new_key))
                  return old_rank;
                 if(old_rank){
                  var old_rank$0 = old_rank[1];
                  if(caml_call2(Core[246], new_map, old_map)){
                   var _bB_ = caml_call2(compare_key, new_key, old_key);
                   if(caml_call2(Core[92], _bB_, 0))
                    var
                     upper_bound = [1, old_key],
                     lower_bound = [1, new_key],
                     subrange =
                       caml_call3(Core_Map[94], new_map, lower_bound, upper_bound),
                     _bE_ =
                       (old_rank$0 - caml_call1(Core_Map[29], subrange) | 0) - 1
                       | 0;
                   else
                    var
                     upper_bound$0 = [1, new_key],
                     lower_bound$0 = [1, old_key],
                     subrange$0 =
                       caml_call3
                        (Core_Map[94], new_map, lower_bound$0, upper_bound$0),
                     _bE_ =
                       (old_rank$0 + caml_call1(Core_Map[29], subrange$0) | 0) + 1
                       | 0;
                   return [0, _bE_];
                  }
                  if(same_key(new_key, old_key)){
                   var
                    _bC_ =
                      function(acc, param){
                       var diff = param[2], diff_key = param[1];
                       if(typeof diff !== "number"){
                        var _bG_ = diff[1];
                        if(-57574468 === _bG_){
                         var _bH_ = caml_call2(compare_key, diff_key, new_key);
                         if(caml_call2(Core[92], _bH_, 0)) return acc + 1 | 0;
                        }
                        else if(847852583 === _bG_){
                         var _bI_ = caml_call2(compare_key, diff_key, new_key);
                         if(caml_call2(Core[92], _bI_, 0)) return acc - 1 | 0;
                        }
                       }
                       return acc;
                      },
                    _bD_ = function(param, _bF_){return 1;};
                   return [0,
                           caml_call5
                            (Core_Map[81], old_map, new_map, _bD_, old_rank$0, _bC_)];
                  }
                  var
                   old_rank$1 =
                     process
                      ([0, [0, old_map, old_key, [0, old_rank$0]]],
                       new_map,
                       old_key),
                   old$1 = [0, [0, new_map, old_key, old_rank$1]],
                   old$0 = old$1;
                  continue;
                 }
                }
                return caml_call2(Core_Map[100], new_map, new_key);
               }
              }
              return with_old2(map, key, process);
             });
   }
   function subrange_by_rank(data_equal, map, range){
    function find_key_range(range){
     return with_old2
             (map,
              range,
              function(old, map, param){
               var
                to = param[2],
                from = param[1],
                _bi_ = caml_call2(Core_Int[88], to, from),
                _bj_ = _bi_ || caml_call2(Core_Int[88], from, 0);
               if(_bj_){
                var
                 _bk_ =
                   [0, [1, [0, _g_, [0, caml_call1(Core[356], to), 0]]], 0],
                 _bl_ =
                   [0,
                    [1, [0, _h_, [0, caml_call1(Core[356], from), 0]]],
                    _bk_],
                 _bm_ =
                   [1,
                    [0,
                     caml_call1(Sexplib0_Sexp_conv[7], cst_Invalid_indices),
                     _bl_]];
                caml_call1(Core[253], _bm_);
               }
               if(old){
                var _bn_ = old[1], _bo_ = _bn_[3];
                if(_bo_){
                 var
                  _bp_ = _bo_[1],
                  end_key_opt$0 = _bp_[2],
                  begin_key = _bp_[1],
                  match = _bn_[2],
                  old_to = match[2],
                  old_from = match[1],
                  old_map = _bn_[1],
                  compare = caml_call1(Core_Map[2], map)[1],
                  find_offset =
                    function(key, changed_key, change){
                     var _bz_ = caml_call2(compare, changed_key, key);
                     if(! caml_call2(Core_Int[88], _bz_, 0)) return 0;
                     if(typeof change !== "number"){
                      var _bA_ = change[1];
                      if(-57574468 === _bA_) return -1;
                      if(847852583 === _bA_) return 1;
                     }
                     return 0;
                    },
                  range_offset_begin = from - old_from | 0,
                  range_offset_end = to - old_to | 0,
                  adjust_and_offset =
                    function(by$1, key$1){
                     a:
                     {
                      if
                       (caml_call2(Core[88], by$1, 0)
                        && ! caml_call2(Core_Map[42], map, key$1)){var _by_ = 1; break a;}
                      var _by_ = 0;
                     }
                     var by$2 = by$1 + _by_ | 0, key = key$1, by = by$2;
                     for(;;){
                      if(caml_call2(Core_Int[86], by, 0)) return [0, key];
                      if(caml_call2(Core_Int[88], by, 0))
                       var add = 1, closest_dir = -640801497;
                      else
                       var add = -1, closest_dir = -779285466;
                      var match = caml_call3(Core_Map[97], map, closest_dir, key);
                      if(! match) return 0;
                      var
                       key$0 = match[1][1],
                       by$0 = by + add | 0,
                       key = key$0,
                       by = by$0;
                     }
                    },
                  diff =
                    function(init, f){
                     function _bw_(param, _bx_){return 1;}
                     return caml_call5(Core_Map[81], old_map, map, _bw_, init, f);
                    };
                 if(end_key_opt$0)
                  var
                   end_key = end_key_opt$0[1],
                   match$0 =
                     diff
                      (_i_,
                       function(param, _bt_){
                        var
                         change = _bt_[2],
                         key = _bt_[1],
                         offset_end = param[2],
                         offset_begin = param[1],
                         _bu_ = offset_end + find_offset(end_key, key, change) | 0;
                        return [0,
                                offset_begin + find_offset(begin_key, key, change) | 0,
                                _bu_];
                       }),
                   map_offset_end = match$0[2],
                   map_offset_begin = match$0[1],
                   end_key_opt$1 =
                     adjust_and_offset
                      (map_offset_end + range_offset_end | 0, end_key),
                   end_key_opt$2 = end_key_opt$1,
                   begin_key_opt =
                     adjust_and_offset
                      (map_offset_begin + range_offset_begin | 0, begin_key);
                 else
                  var
                   map_offset_begin$0 =
                     diff
                      (0,
                       function(offset_begin, param){
                        var change = param[2], key = param[1];
                        return offset_begin + find_offset(begin_key, key, change)
                               | 0;
                       }),
                   _bg_ = function(_bv_){return _bv_[1];},
                   _bh_ = find_key_range_linear(to, to, map),
                   end_key_opt = caml_call2(Core_Option[29], _bh_, _bg_),
                   begin_key_opt$0 =
                     adjust_and_offset
                      (map_offset_begin$0 + range_offset_begin | 0, begin_key),
                   end_key_opt$2 = end_key_opt,
                   begin_key_opt = begin_key_opt$0;
                 var _bq_ = caml_call1(Core_Map[42], map);
                 if(! caml_call2(Core_Option[43], begin_key_opt, _bq_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _k_], 1);
                 var _br_ = caml_call1(Core_Map[42], map);
                 if(! caml_call2(Core_Option[43], end_key_opt$2, _br_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _j_], 1);
                 var
                  _bs_ =
                    function(begin_key){return [0, begin_key, end_key_opt$2];};
                 return caml_call2(Core_Option[29], begin_key_opt, _bs_);
                }
               }
               return find_key_range_linear(from, to, map);
              });
    }
    function symbol(new$0, bound){
     function _bf_(param){return new$0;}
     return caml_call2(Core_Maybe_bound[16], bound, _bf_);
    }
    var
     _aU_ = caml_call1(Incremental[4], map),
     return$0 = caml_call1(Incremental[9], _aU_);
    function _aV_(param){
     if(3 < param >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     switch(param){
       case 0:
        return caml_call1(return$0, _m_);
       case 1:
        var
         _aY_ =
           function(param){
            var _be_ = param[1];
            if(typeof _be_ !== "number"){
             var pattern_syntax_008 = _be_[1];
             if(typeof param[2] !== "number") return pattern_syntax_008;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           },
         l = caml_call2(Incremental[76][3][5], range, _aY_),
         _aZ_ =
           function(param){
            var pattern_syntax_009 = param[1];
            if
             (typeof pattern_syntax_009 !== "number"
              && typeof param[2] !== "number")
             return pattern_syntax_009;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           },
         lb = caml_call2(Incremental[76][3][5], range, _aZ_),
         _a0_ =
           function(param){
            if(typeof param[1] !== "number"){
             var match = param[2];
             if(typeof match !== "number"){
              var pattern_syntax_010 = match[1];
              return pattern_syntax_010;
             }
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
           },
         u = caml_call2(Incremental[76][3][5], range, _a0_),
         _a1_ =
           function(param){
            if(typeof param[1] !== "number"){
             var pattern_syntax_011 = param[2];
             if(typeof pattern_syntax_011 !== "number")
              return pattern_syntax_011;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
           },
         ub = caml_call2(Incremental[76][3][5], range, _a1_),
         let_syntax_016 = find_key_range(caml_call2(Incremental[40], l, u)),
         _a2_ =
           function(param){
            var
             match = param[2],
             ub = match[2],
             lb = match[1],
             key_range = param[1];
            if(! key_range) return 0;
            var _bc_ = key_range[1], match$0 = _bc_[2], begin_key = _bc_[1];
            if(! match$0) return [0, [0, symbol(begin_key, lb), 0]];
            var end_key = match$0[1], _bd_ = symbol(end_key, ub);
            return [0, [0, symbol(begin_key, lb), _bd_]];
           },
         _a3_ = caml_call2(Incremental[76][3][20], lb, ub),
         _a4_ = caml_call2(Incremental[76][3][20], let_syntax_016, _a3_);
        return caml_call2(Incremental[76][3][5], _a4_, _a2_);
       case 2:
        var
         _a5_ =
           function(param){
            var _bb_ = param[1];
            if(typeof _bb_ !== "number"){
             var pattern_syntax_012 = _bb_[1];
             if(typeof param[2] === "number") return pattern_syntax_012;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
           },
         l$0 = caml_call2(Incremental[76][3][5], range, _a5_),
         _a6_ =
           function(param){
            var pattern_syntax_013 = param[1];
            if
             (typeof pattern_syntax_013 !== "number"
              && typeof param[2] === "number")
             return pattern_syntax_013;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
           },
         lb$0 = caml_call2(Incremental[76][3][5], range, _a6_),
         let_syntax_020 =
           find_key_range(caml_call2(Incremental[40], l$0, l$0)),
         _a7_ =
           function(param){
            var lb = param[2], key_range = param[1];
            if(! key_range) return 0;
            var key = key_range[1][1];
            return [0, [0, symbol(key, lb), 0]];
           },
         _a8_ = caml_call2(Incremental[76][3][20], let_syntax_020, lb$0);
        return caml_call2(Incremental[76][3][5], _a8_, _a7_);
       default:
        var
         _a9_ =
           function(param){
            if(typeof param[1] === "number"){
             var match = param[2];
             if(typeof match !== "number"){
              var pattern_syntax_014 = match[1];
              return pattern_syntax_014;
             }
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
           },
         u$0 = caml_call2(Incremental[76][3][5], range, _a9_),
         _a__ =
           function(param){
            if(typeof param[1] === "number"){
             var pattern_syntax_015 = param[2];
             if(typeof pattern_syntax_015 !== "number")
              return pattern_syntax_015;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           },
         ub$0 = caml_call2(Incremental[76][3][5], range, _a__),
         let_syntax_023 =
           find_key_range(caml_call2(Incremental[40], u$0, u$0)),
         _a$_ =
           function(param){
            var ub = param[2], key_range = param[1];
            if(! key_range) return 0;
            var key = key_range[1][1];
            return [0, [0, 0, symbol(key, ub)]];
           },
         _ba_ = caml_call2(Incremental[76][3][20], let_syntax_023, ub$0);
        return caml_call2(Incremental[76][3][5], _ba_, _a$_);
     }
    }
    function _aW_(param){
     return typeof param[1] === "number"
             ? typeof param[2] === "number" ? 0 : 3
             : typeof param[2] === "number" ? 2 : 1;
    }
    var
     _aX_ = caml_call2(Incremental[76][3][5], range, _aW_),
     key_range = caml_call2(Incremental[76][3][1], _aX_, _aV_);
    return subrange(data_equal, map)(key_range);
   }
   function transpose(opt, k2_comparator, m){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return with_comparator$0
            (m,
             function(k1_comparator){
              function update(k1, old_data, new_data, acc){
               function _aO_(acc, param){
                var diff = param[2], k2 = param[1], _aP_ = diff[1];
                if(847852583 === _aP_)
                 var value = 0;
                else
                 var
                  x = 1013247643 <= _aP_ ? diff[2][2] : diff[2],
                  value = [0, x];
                function _aQ_(acc_inner){
                 function _aR_(param){return value;}
                 var
                  _aS_ = caml_call1(Core_Map[110][1], k1_comparator),
                  _aT_ = caml_call2(Core_Option[34], acc_inner, _aS_),
                  acc_inner$0 = caml_call3(Core_Map[36], _aT_, k1, _aR_);
                 return caml_call1(Core_Map[28], acc_inner$0)
                         ? 0
                         : [0, acc_inner$0];
                }
                return caml_call3(Core_Map[36], acc, k2, _aQ_);
               }
               return caml_call5
                       (Core_Map[81], old_data, new_data, data_equal, acc, _aO_);
              }
              function add(key, data){
               var _aM_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_aN_){return update(key, _aM_, data, _aN_);};
              }
              function remove(key, data){
               var _aK_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_aL_){return update(key, data, _aK_, _aL_);};
              }
              return unordered_fold
                      (0,
                       [0, update],
                       0,
                       _v_,
                       m,
                       caml_call1(Core_Map[4], k2_comparator),
                       add,
                       remove);
             });
   }
   function collapse_by(data_equal, map_incr, merge_keys, comparator){
    function _aE_(outer_key, inner_key, param, acc){
     var _aJ_ = caml_call2(merge_keys, outer_key, inner_key);
     return caml_call2(Core_Map[41], acc, _aJ_);
    }
    function _aF_(outer_key, inner_key, data, acc){
     var _aI_ = caml_call2(merge_keys, outer_key, inner_key);
     return caml_call3(Core_Map[31], acc, _aI_, data);
    }
    var _aG_ = caml_call1(Core_Map[4], comparator);
    return unordered_fold_nested_maps
            (data_equal,
             _w_,
             [0,
              function(outer_key, inner_key, param, new_data, acc){
               var _aH_ = caml_call2(merge_keys, outer_key, inner_key);
               return caml_call3(Core_Map[32], acc, _aH_, new_data);
              }],
             map_incr,
             _aG_,
             _aF_,
             _aE_);
   }
   function collapse(data_equal, map_incr, inner_comparator){
    return with_comparator$0
            (map_incr,
             function(outer_comparator){
              var
               inner_comparator$0 = inner_comparator[1],
               comparator =
                 caml_call2
                  (Core_Tuple[1][5], outer_comparator, inner_comparator$0);
              return collapse_by
                      (data_equal, map_incr, Core_Tuple[1][6], [0, comparator]);
             });
   }
   function expand(data_equal, map_incr, outer_comparator, inner_comparator){
    function _au_(param, _aB_, acc){
     var inner_key = param[2], outer_key = param[1];
     function _aC_(param){
      if(! param) return 0;
      var
       map = param[1],
       map$0 = caml_call2(Core_Map[41], map, inner_key),
       _aD_ = 1 - caml_call1(Core_Map[28], map$0);
      return caml_call2(Core_Option[55], _aD_, map$0);
     }
     return caml_call3(Core_Map[36], acc, outer_key, _aC_);
    }
    function _av_(param, data, acc){
     var inner_key = param[2], outer_key = param[1];
     function _aA_(param){
      if(! param)
       return caml_call3(Core_Map[5], inner_comparator, inner_key, data);
      var map = param[1];
      return caml_call3(Core_Map[31], map, inner_key, data);
     }
     return caml_call3(Core_Map[37], acc, outer_key, _aA_);
    }
    var _aw_ = caml_call1(Core_Map[4], outer_comparator), _ax_ = 0;
    return unordered_fold
            (data_equal,
             [0,
              function(param, _ay_, new_data, acc){
               var inner_key = param[2], outer_key = param[1];
               function _az_(param){
                if(! param)
                 return caml_call3
                         (Core_Map[5], inner_comparator, inner_key, new_data);
                var map = param[1];
                return caml_call3(Core_Map[32], map, inner_key, new_data);
               }
               return caml_call3(Core_Map[37], acc, outer_key, _az_);
              }],
             _ax_,
             _x_,
             map_incr,
             _aw_,
             _av_,
             _au_);
   }
   function counti(data_equal, map_incr, f){
    function _at_(key, data, count){
     return caml_call2(f, key, data) ? count - 1 | 0 : count;
    }
    return unordered_fold
            (data_equal,
             0,
             0,
             _y_,
             map_incr,
             0,
             function(key, data, count){
              return caml_call2(f, key, data) ? count + 1 | 0 : count;
             },
             _at_);
   }
   function count(data_equal, map_incr, f){
    return counti
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function existsi(data_equal, map_incr, f){
    function _ar_(count){return caml_call2(Core[93], count, 0);}
    var _as_ = counti(data_equal, map_incr, f);
    return caml_call2(Incremental[10], _as_, _ar_);
   }
   function exists(data_equal, map_incr, f){
    return existsi
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function sum(data_equal, map_incr, Group){
    return function(f){
     function _an_(param, v, acc){
      var _aq_ = caml_call1(f, v);
      return caml_call2(Group[3], acc, _aq_);
     }
     function _ao_(param, v, acc){
      var _ap_ = caml_call1(f, v);
      return caml_call2(Group[2], acc, _ap_);
     }
     return unordered_fold
             (data_equal, 0, 0, _z_, map_incr, Group[1], _ao_, _an_);};
   }
   function for_alli(data_equal, map_incr, f){
    function _al_(count){return caml_call2(Core[90], count, 0);}
    var
     _am_ =
       counti
        (data_equal,
         map_incr,
         function(key, data){return 1 - caml_call2(f, key, data);});
    return caml_call2(Incremental[10], _am_, _al_);
   }
   function for_all(data_equal, map_incr, f){
    return for_alli
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   var For_testing = [0, find_key_range_linear];
   function M(K){return [0];}
   function create(opt, input_map, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    var self = [];
    caml_update_dummy
     (self,
      [246,
       function(param){
        function _ad_(input_map){
         var _af_ = caml_obj_tag(self);
         a:
         if(250 === _af_)
          var self$0 = self[1];
         else{
          if(246 !== _af_ && 244 !== _af_){var self$0 = self; break a;}
          var self$0 = caml_call1(CamlinternalLazy[2], self);
         }
         function _ag_(param, _ah_){
          var
           changed_value = _ah_[2],
           key = _ah_[1],
           entries = caml_call2(Core_Map[35], self$0[2], key);
          function _ai_(entry){
           var _aj_ = changed_value[1];
           if(847852583 === _aj_)
            var _ak_ = 0;
           else
            var
             new_value =
               1013247643 <= _aj_ ? changed_value[2][2] : changed_value[2],
             _ak_ = [0, new_value];
           entry[1] = _ak_;
           return caml_call1(Incremental[79][2][4], entry[2]);
          }
          return caml_call2(Core_List[9], entries, _ai_);
         }
         caml_call5(Core_Map[81], self$0[1], input_map, data_equal, 0, _ag_);
         self$0[1] = input_map;
         return 0;
        }
        var
         updater_node = caml_call2(Incremental[10], input_map, _ad_),
         empty_map = caml_call1(Core_Map[110][1], comparator),
         _ae_ = caml_call1(Incremental[4], input_map);
        return [0,
                empty_map,
                empty_map,
                updater_node,
                caml_call2(Incremental[50][2], _ae_, 0)];
       }]);
    var _ac_ = caml_obj_tag(self);
    if(250 === _ac_) return self[1];
    if(246 !== _ac_ && 244 !== _ac_) return self;
    return caml_call1(CamlinternalLazy[2], self);
   }
   function find(t, key){
    var match = caml_call2(Core_Map[35], t[2], key);
    if(match){
     var entry = match[1];
     return caml_call1(Incremental[79][2][3], entry[2]);
    }
    var incremental_state = caml_call1(Incremental[4], t[3]);
    function _T_(param){
     var entry = [];
     caml_update_dummy
      (entry,
       [246,
        function(param){
         function _W_(param){return caml_call1(Core[237], entry)[1];}
         var
          _X_ =
            [0,
             function(is_now_observable){
              var _Z_ = caml_obj_tag(entry);
              a:
              if(250 === _Z_)
               var entry$0 = entry[1];
              else{
               if(246 !== _Z_ && 244 !== _Z_){var entry$0 = entry; break a;}
               var entry$0 = caml_call1(CamlinternalLazy[2], entry);
              }
              var
               current_entries = caml_call2(Core_Map[35], t[2], key),
               ___ = caml_call1(Core[246], entry$0),
               is_linked = caml_call2(Core_List[13], current_entries, ___);
              if(caml_call2(Core_Bool[27], is_linked, is_now_observable))
               return 0;
              if(is_now_observable){
               var
                _$_ =
                  function(param){
                   if(param){
                    var other_entries = param[1];
                    if(other_entries){
                     var other_entry = other_entries[1];
                     entry$0[1] = other_entry[1];
                     return [0, entry$0, other_entries];
                    }
                   }
                   entry$0[1] = caml_call2(Core_Map[38], t[1], key);
                   return [0, entry$0, 0];
                  };
               t[2] = caml_call3(Core_Map[37], t[2], key, _$_);
               return 0;
              }
              function _aa_(x){return 1 - caml_call2(Core[246], entry$0, x);}
              var
               new_entries = caml_call2(Core_List[50], current_entries, _aa_),
               _ab_ =
                 caml_call1(Core_List[8], new_entries)
                  ? caml_call2(Core_Map[41], t[2], key)
                  : caml_call3(Core_Map[32], t[2], key, new_entries);
              t[2] = _ab_;
              return 0;
             }],
          _Y_ = caml_call3(Incremental[79][2][2], incremental_state, _X_, _W_);
         return [0, caml_call2(Core_Map[38], t[1], key), _Y_];
        }]);
     var _U_ = caml_obj_tag(entry);
     a:
     if(250 === _U_)
      var entry$0 = entry[1];
     else{
      if(246 !== _U_ && 244 !== _U_){var entry$0 = entry; break a;}
      var entry$0 = caml_call1(CamlinternalLazy[2], entry);
     }
     var _V_ = caml_call2(Incremental[79][1][2], 0, t[3]);
     caml_call2(Incremental[79][2][6], entry$0[2], _V_);
     return caml_call1(Incremental[79][2][3], entry$0[2]);
    }
    return caml_call3(Incremental[50][3], incremental_state, t[4], _T_);
   }
   function sexp_of_t(sexp_of_key, sexp_of_value, t){
    function _I_(key, data){
     var _J_ = data[1];
     if(737457313 === _J_)
      var
       match = data[2],
       entries = match[2],
       x = match[1],
       actual_value = [0, x],
       entries$0 = entries,
       actual_value$0 = actual_value;
     else if(847852583 <= _J_)
      var x$0 = data[2], entries$0 = 0, actual_value$0 = [0, x$0];
     else
      var y = data[2], entries$0 = y, actual_value$0 = 0;
     var _K_ = 0, _L_ = 0;
     function _M_(entry){
      var
       saved_value = entry[1],
       node = entry[2],
       node$0 = caml_call1(Incremental[79][2][3], node),
       match = caml_call1(Incremental[67], node$0),
       _O_ = caml_call1(Incremental[5], node$0),
       match$0 = caml_call2(Core_Option[55], _O_, 0),
       _P_ = 1 - caml_call1(Incremental[6], node$0),
       match$1 = caml_call2(Core_Option[55], _P_, 0),
       _Q_ = 1 - caml_call1(Incremental[7], node$0),
       _R_ = caml_call2(Core_Option[55], _Q_, 0),
       match$2 = 0;
      if(_R_)
       var
        v = _R_[1],
        match$3 =
          [0, [1, [0, _A_, [0, caml_call1(Core[518], v), 0]]], match$2];
      else
       var match$3 = match$2;
      if(match$1)
       var
        v$0 = match$1[1],
        match$4 =
          [0, [1, [0, _B_, [0, caml_call1(Core[518], v$0), 0]]], match$3];
      else
       var match$4 = match$3;
      if(match$0)
       var
        v$1 = match$0[1],
        match$5 =
          [0, [1, [0, _C_, [0, caml_call1(Core[518], v$1), 0]]], match$4];
      else
       var match$5 = match$4;
      if(match)
       var
        v$2 = match[1],
        _S_ =
          [0, [1, [0, _D_, [0, caml_call1(Core_Info[6], v$2), 0]]], match$5];
      else
       var _S_ = match$5;
      return [1,
              [0,
               [1,
                [0,
                 _E_,
                 [0, caml_call2(Core[454], sexp_of_value, saved_value), 0]]],
               _S_]];
     }
     var
      match$0 =
        [0,
         [1, [0, _F_, [0, caml_call2(Core[421], _M_, entries$0), _L_]]],
         _K_];
     if(actual_value$0)
      var
       v = actual_value$0[1],
       _N_ = [0, [1, [0, _G_, [0, caml_call1(sexp_of_value, v), 0]]], match$0];
     else
      var _N_ = match$0;
     return [0,
             [1,
              [0, [1, [0, _H_, [0, caml_call1(sexp_of_key, key), 0]]], _N_]]];
    }
    var info_per_key = caml_call3(Core_Map[77], t[1], t[2], _I_);
    return [1, caml_call1(Core_Map[73], info_per_key)];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map);
   var
    Incr_map =
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       unordered_fold,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       mapi_mn,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       [0, create, find, M, [0, sexp_of_t]],
       For_testing,
       function(Incr){
        function flatten$0(x){return flatten(Incr[2][3], x);}
        function M(K){return [0];}
        return [0,
                of_set,
                filter_mapi,
                mapi,
                filter_map,
                map,
                filter_mapi$0,
                mapi$0,
                filter_map$0,
                map$0,
                partition_mapi,
                unordered_fold,
                mapi_count,
                map_count,
                mapi_min,
                mapi_max,
                mapi_mn,
                map_max,
                min_value,
                max_value,
                mapi_bounds,
                map_bounds,
                value_bounds,
                merge,
                unzip,
                unzip_mapi,
                unzip_mapi$0,
                merge$0,
                flatten$0,
                join,
                separate,
                keys,
                rank,
                subrange,
                subrange_by_rank,
                rekey,
                index_byi,
                index_by,
                unordered_fold_nested_maps,
                transpose,
                collapse,
                collapse_by,
                expand,
                counti,
                count,
                for_alli,
                for_all,
                existsi,
                exists,
                sum,
                [0, create, find, M, [0, sexp_of_t]],
                For_testing];
       }];
   runtime.caml_register_global(65, Incr_map, cst_Incr_map$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsid2l0aF9vbGQiLCJpIiwiZiIsIm9sZCIsImEiLCJiIiwidW5vcmRlcmVkX2ZvbGQiLCJvcHQiLCJ1cGRhdGUiLCJzcGVjaWFsaXplZF9pbml0aWFsIiwibWFwIiwiaW5pdCIsImFkZCIsInJlbW92ZSIsInN0aCIsImRhdGFfZXF1YWwiLCJzdGgkMCIsInJldmVydF90b19pbml0X3doZW5fZW1wdHkiLCJkZWZhdWx0JDAiLCJrZXkiLCJvbGRfZGF0YSIsIm5ld19kYXRhIiwiYWNjIiwidXBkYXRlJDAiLCJuZXdfaW4iLCJpbml0aWFsIiwib2xkX291dCIsIm9sZF9pbiIsImNoYW5nZSIsIm5ldyQwIiwib2xkJDAiLCJuZXckMSIsInVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzIiwiaW5jcl9tYXAiLCJ1cGRhdGUkMSIsIm91dGVyX2tleSIsImlubmVyX2tleSIsImlubmVyX21hcCIsImRhdGEiLCJvbGRfaW5uZXJfbWFwIiwibmV3X2lubmVyX21hcCIsImRpZmYiLCJkYXRhX3JlbW92ZWQiLCJkYXRhX2FkZGVkIiwid2l0aF9jb21wYXJhdG9yIiwiZ2V0X2NvbXBhcmF0b3IiLCJ4Iiwid2l0aF9jb21wYXJhdG9yJDAiLCJvZl9zZXQiLCJzZXQiLCJjb21wYXJhdG9yIiwib2xkX2lucHV0Iiwib2xkX291dHB1dCIsIm5ld19pbnB1dCIsIm91dHB1dCIsImsiLCJrJDAiLCJuZXdfb3V0cHV0IiwiZ2VuZXJpY19tYXBpIiwid2l0bmVzcyIsImlucHV0IiwicmVzIiwib3V0cHV0X2RhdGEiLCJtYXBpIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwIiwid2l0aF9vbGQyIiwiaTEiLCJpMiIsImExIiwiYTIiLCJtYXBpX2NvdW50IiwibmV3X2tleSIsIm4iLCJwcmV2X2tleSIsIm1hcF9jb3VudCIsIm1pbl9oZWxwZXIiLCJtaW4iLCJtYXhfaGVscGVyIiwibWF4IiwiYm91bmRzX2hlbHBlciIsIm1hcGlfbWluIiwibWFwaV9tYXgiLCJtYXBpX2JvdW5kcyIsIm1hcGlfbW4iLCJtYXBfbWF4IiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwibWFwX2JvdW5kcyIsInZhbHVlX2JvdW5kcyIsIm1lcmdlIiwibGVmdF9tYXAiLCJyaWdodF9tYXAiLCJkYXRhX2VxdWFsX2xlZnQiLCJkYXRhX2VxdWFsX3JpZ2h0IiwibmV3X2xlZnRfbWFwIiwibmV3X3JpZ2h0X21hcCIsIm9sZF9yaWdodF9tYXAiLCJvbGRfbGVmdF9tYXAiLCJvbGRfbGVmdF9tYXAkMCIsImxlZnRfZGlmZiIsInJpZ2h0X2RpZmYiLCJkaWZmX2VsZW1lbnQiLCJyaWdodF9rZXkiLCJsZWZ0X2tleSIsImtleSQwIiwicmlnaHRfZGF0YV9vcHQkMCIsImxlZnRfZGF0YV9vcHQiLCJyaWdodF9kaWZmJDAiLCJsZWZ0X2RpZmYkMCIsInJpZ2h0X2RhdGFfb3B0JDIiLCJsZWZ0X2RhdGFfb3B0JDAiLCJ5Iiwib3V0cHV0X2RhdGFfb3B0IiwieSQwIiwiZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvciIsImN1dG9mZiIsImluY3JlbWVudGFsX3N0YXRlIiwiZW1wdHlfbWFwIiwicHJldl9tYXAiLCJwcmV2X25vZGVzIiwicmVzdWx0Iiwib25faW5uZXJfY2hhbmdlIiwibGhzX2NoYW5nZSIsIm5vZGVzIiwiY2hhbmdlZCIsImRlcCIsIm5vZGUiLCJub2RlcyQwIiwibm9kZSQwIiwibm9kZSQxIiwiYyIsInVzZXJfZnVuY3Rpb25fZGVwIiwibmV3X25vZGVzIiwiZmlsdGVyX21hcGkkMCIsIm1hcGkkMCIsIm1hcCQwIiwiZmlsdGVyX21hcCQwIiwibWVyZ2UkMCIsIm1hcDEiLCJtYXAyIiwidW56aXBfbWFwaSIsImxlZnRfcmVzdWx0X2VxdWFsIiwicmlnaHRfcmVzdWx0X2VxdWFsIiwicGFpciIsImRhdGFfZXF1YWwkMCIsImxlZnRfcmVzdWx0X2VxdWFsJDAiLCJzdGgkMSIsInJpZ2h0X3Jlc3VsdF9lcXVhbCQwIiwibGVmdF9hY2MiLCJsZWZ0X3Jlc3VsdCIsInJpZ2h0X2FjYyIsInJpZ2h0X3Jlc3VsdCIsImwiLCJsZWZ0JDAiLCJyIiwicmlnaHQkMCIsInJpZ2h0IiwibGVmdCIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsImlucHV0X2NoYW5nZSIsInVuemlwIiwidW56aXBfbWFwaSQwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwiZW1wdHkiLCJzZWNvbmQiLCJmaXJzdCIsImRhdGEkMCIsImRhdGEkMSIsImZsYXR0ZW4iLCJzdGF0ZSIsImluY3IiLCJqb2luIiwibWFwX2luY3IiLCJyZXN1bHRfbWFwIiwib2xkX21hcF9vZl9pbmNycyIsImN1cnJlbnRfZGVwZW5kZW5jaWVzIiwiYWRkX3N1Ym5vZGUiLCJkYXRhX25vZGUiLCJuZXdfZGVwIiwicmVtb3ZlX3N1Ym5vZGUiLCJtYXBfb2ZfaW5jcnMiLCJkYXRhX25vZGUkMCIsIm5ld19kZXBlbmRlbmN5X21hcCIsInNlcGFyYXRlIiwiaW5wdXRfbWFwIiwib3V0cHV0X21hcF9ub2RlIiwibWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfIiwiaW5wdXRfbWFwX2NoYW5nZWQiLCJkZXBlbmRlbmN5IiwicHJldl9pbnB1dF9tYXAiLCJvdXRwdXRfbWFwIiwiZXhwZXJ0X25vZGVzIiwib2xkX25vZGUiLCJzdWJyYW5nZSIsInJhbmdlIiwiY29tcGFyZSIsImVxdWFsIiwibWF5YmVfYm91bmRfZXF1YWwiLCJhXzAwMiIsImJfMDAzIiwiYV8wMDQiLCJiXzAwNSIsImFfMDA2IiwiYl8wMDciLCJyYW5nZV9pc19lbXB0eSIsIm1pbiQwIiwibWF4JDAiLCJtYXgkMSIsIm1pbiQxIiwicmFuZ2VfaW5jbHVkZXMiLCJyYW5nZSQwIiwiZnJvbV9zY3JhdGNoIiwib2xkX3JhbmdlIiwib2xkX21pbiIsIm9sZF9tYXAiLCJvbGRfbWF4Iiwib2xkX3JlcyIsIm9sZF9tYXgkMCIsInBhcmFtIiwiYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24iLCJvdXRzaWRlIiwib3V0c2lkZSQwIiwib3V0c2lkZV9jdXRvZmYiLCJ3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2UiLCJ3aXRob3V0X2tleXNfb3V0X29mX3JhbmdlIiwibWFwX2FwcGVuZF9leG4iLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm9sZF9taW4kMCIsIm9sZF9taW4kMSIsIm9sZF9tYXgkMSIsIndpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlIiwicmVrZXkiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5kZXhfYnlpIiwiaW5kZXgiLCJpbm5lcl9jb21wYXJhdG9yIiwib3V0ZXJfbWFwIiwiaW5uZXJfbWFwJDAiLCJpbmRleF9ieSIsImlzX2tub3duIiwidG9fb3B0aW9uIiwiZmluZF9rZXlfcmFuZ2VfbGluZWFyIiwiZnJvbSIsInRvIiwibGVuIiwiYmVnaW5fa2V5IiwiZW5kX2tleSIsImZpbmRfa2V5cyIsImZvbGQiLCJzdGFydF9wb3MiLCJhZHZhbmNlX3BvcyIsInBvcyIsImJlZ2luX2tleSQwIiwiZW5kX2tleSQwIiwicmFuayIsImNvbXBhcmVfa2V5Iiwic2FtZV9rZXkiLCJwcm9jZXNzIiwibmV3X21hcCIsIm9sZF9yYW5rIiwib2xkX2tleSIsIm9sZF9yYW5rJDAiLCJ1cHBlcl9ib3VuZCIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQkMCIsImxvd2VyX2JvdW5kJDAiLCJzdWJyYW5nZSQwIiwiZGlmZl9rZXkiLCJvbGRfcmFuayQxIiwib2xkJDEiLCJzdWJyYW5nZV9ieV9yYW5rIiwiZmluZF9rZXlfcmFuZ2UiLCJlbmRfa2V5X29wdCQwIiwib2xkX3RvIiwib2xkX2Zyb20iLCJmaW5kX29mZnNldCIsImNoYW5nZWRfa2V5IiwicmFuZ2Vfb2Zmc2V0X2JlZ2luIiwicmFuZ2Vfb2Zmc2V0X2VuZCIsImFkanVzdF9hbmRfb2Zmc2V0IiwiYnkkMSIsImtleSQxIiwiYnkkMiIsImJ5IiwiY2xvc2VzdF9kaXIiLCJieSQwIiwib2Zmc2V0X2VuZCIsIm9mZnNldF9iZWdpbiIsIm1hcF9vZmZzZXRfZW5kIiwibWFwX29mZnNldF9iZWdpbiIsImVuZF9rZXlfb3B0JDIiLCJiZWdpbl9rZXlfb3B0IiwibWFwX29mZnNldF9iZWdpbiQwIiwiZW5kX2tleV9vcHQiLCJiZWdpbl9rZXlfb3B0JDAiLCJzeW1ib2wiLCJib3VuZCIsInJldHVybiQwIiwicGF0dGVybl9zeW50YXhfMDA4IiwicGF0dGVybl9zeW50YXhfMDA5IiwibGIiLCJwYXR0ZXJuX3N5bnRheF8wMTAiLCJ1IiwicGF0dGVybl9zeW50YXhfMDExIiwidWIiLCJsZXRfc3ludGF4XzAxNiIsImtleV9yYW5nZSIsInBhdHRlcm5fc3ludGF4XzAxMiIsImwkMCIsInBhdHRlcm5fc3ludGF4XzAxMyIsImxiJDAiLCJsZXRfc3ludGF4XzAyMCIsInBhdHRlcm5fc3ludGF4XzAxNCIsInUkMCIsInBhdHRlcm5fc3ludGF4XzAxNSIsInViJDAiLCJsZXRfc3ludGF4XzAyMyIsInRyYW5zcG9zZSIsImsyX2NvbXBhcmF0b3IiLCJtIiwiazFfY29tcGFyYXRvciIsImsxIiwiazIiLCJ2YWx1ZSIsImFjY19pbm5lciIsImFjY19pbm5lciQwIiwiY29sbGFwc2VfYnkiLCJtZXJnZV9rZXlzIiwiY29sbGFwc2UiLCJpbm5lcl9jb21wYXJhdG9yJDAiLCJleHBhbmQiLCJjb3VudGkiLCJjb3VudCIsImV4aXN0c2kiLCJleGlzdHMiLCJzdW0iLCJHcm91cCIsInYiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJjcmVhdGUiLCJzZWxmIiwic2VsZiQwIiwiY2hhbmdlZF92YWx1ZSIsImVudHJpZXMiLCJlbnRyeSIsIm5ld192YWx1ZSIsInVwZGF0ZXJfbm9kZSIsImZpbmQiLCJ0IiwiaXNfbm93X29ic2VydmFibGUiLCJlbnRyeSQwIiwiY3VycmVudF9lbnRyaWVzIiwiaXNfbGlua2VkIiwib3RoZXJfZW50cmllcyIsIm90aGVyX2VudHJ5IiwibmV3X2VudHJpZXMiLCJzZXhwX29mX3QiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsdWUiLCJhY3R1YWxfdmFsdWUiLCJlbnRyaWVzJDAiLCJhY3R1YWxfdmFsdWUkMCIsIngkMCIsInNhdmVkX3ZhbHVlIiwibWF0Y2gkMiIsIm1hdGNoJDMiLCJ2JDAiLCJtYXRjaCQ0IiwidiQxIiwibWF0Y2gkNSIsInYkMiIsIm1hdGNoJDAiLCJpbmZvX3Blcl9rZXkiLCJmbGF0dGVuJDAiXSwic291cmNlcyI6WyIvVXNlcnMvc3Zpc2hudXMvLm9wYW0vZ3J2LXRlc3QvbGliL2luY3JfbWFwL2luY3JfbWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQW1CTUEsU0FBU0MsR0FBR0M7SUFFSixJQUFOQztrQkFDSUM7S0FDQSxJQUFKQyxJQUFJLFdBSk1ILEdBRVZDLFFBQ0lDO0tBREpELGlCQUNJQyxHQUNKQztLQUVKLE9BRklBO0lBRUg7NkNBTlVKO0dBTVY7WUFHQ0s7SUFDSUMsS0FDREMsUUFDQUMsMkJBRURDLEtBQ0NDLE1BQ0FDLEtBQ0FDO0lBRUwsR0FUTU47U0FBYU8sTUFBYlAsUUFBQVEsYUFBYUQ7O1NBQWJDO0lBU047U0FOa0NDLGlCQUE1QkMsNEJBQTRCRDs7U0FBNUJDO2FBT0FDLFVBQVNDLEtBQUtDLFVBQVVDLFVBQVNDO0tBQ25DLE9BQXdCO2NBTHZCVixLQUlVTyxLQUFlRSxVQUNGLFdBSnZCUixRQUdVTSxLQUFLQyxVQUFtQkU7SUFDcUI7SUFFMUQsSUFKRUMsV0FJRiw0QkFaR2YsUUFTQ1U7SUFLVSxPQXpCZGxC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QXFCQVk7Z0JBL0dBdEI7Z0JBa2JBOEY7Z0JBaFFBOUQ7Z0JBcVVBOEU7Z0JBeE1BdkM7Z0JBZ0JBRTtnQkE4QkFLO2dCQTU1QkE1TjtnQkFtcENBMlM7Z0JBeUVBVztnQkFyQkFGO2dCQWlEQUk7Z0JBc0JBQztnQkFVQUM7Z0JBNEJBTTtnQkFNQUM7Z0JBOUJBTjtnQkFJQUM7Z0JBSUFDO29CQXFERUssUUErRUFRLGFBd0JTUzs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbmluY2x1ZGUgSW5jcl9tYXBfaW50ZlxuXG4oKiogVGhpcyB0eXBlIGxldHMgdXMgY2FwdHVyZSB0aGUga2luZCBvZiBtYXAgZnVuY3Rpb24gYmVpbmcgcGVyZm9ybWVkLCBzbyB3ZSBjYW4gd2l0aFxuICAgIG9uZSBpbXBsZW1lbnRhdGlvbiBwZXJmb3JtIG1hcCBhbmQgZmlsdGVyLW1hcCBvcGVyYXRpb25zLlxuXG4gICAgSGVyZSwgWydpbnB1dF9kYXRhXSBpcyB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBpbnB1dCBtYXAsIFsnb3V0cHV0X2RhdGFdIGlzIHRoZSB0eXBlXG4gICAgb2YgZGF0YSBpbiB0aGUgb3V0cHV0IG1hcCwgYW5kIFsnZl9vdXRwdXRdIGlzIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgW35mXSBmdW5jdGlvblxuICAgIHBhc3NlZCB0byB0aGUgbWFwcGluZyBmdW5jdGlvbi4gKilcbm1vZHVsZSBNYXBfdHlwZSA9IHN0cnVjdFxuICB0eXBlICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnZl9vdXRwdXQpIHQgPVxuICAgIHwgTWFwIDogKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSkgdFxuICAgIHwgRmlsdGVyX21hcCA6ICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnb3V0cHV0X2RhdGEgb3B0aW9uKSB0XG5cbiAgKCogVGhlIGV4dHJhIHR5cGUgdmFyaWFibGUgJ2EgaXMgdG8gYWxsb3cgaW4gZnV0dXJlOlxuICAgICB8IEZpbHRlciA6ICgnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgYm9vbCkgdCAqKVxuZW5kXG5cbm1vZHVsZSBHZW5lcmljID0gc3RydWN0XG4gIGxldCB3aXRoX29sZCBpIH5mID1cbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgbGV0JW1hcCBhID0gaSBpblxuICAgIGxldCBiID0gZiB+b2xkOiFvbGQgYSBpblxuICAgIG9sZCA6PSBTb21lIChhLCBiKTtcbiAgICBiXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID91cGRhdGVcbiAgICAgICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICAgICAgPyhyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5ID0gZmFsc2UpXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBsZXQgZGVmYXVsdCB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjID1cbiAgICAgICAgYWRkIH5rZXkgfmRhdGE6bmV3X2RhdGEgKHJlbW92ZSB+a2V5IH5kYXRhOm9sZF9kYXRhIGFjYylcbiAgICAgIGluXG4gICAgICBPcHRpb24udmFsdWUgdXBkYXRlIH5kZWZhdWx0XG4gICAgaW5cbiAgICB3aXRoX29sZCBtYXAgfmY6KGZ1biB+b2xkIG5ld19pbiAtPlxuICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAobWF0Y2ggc3BlY2lhbGl6ZWRfaW5pdGlhbCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gTWFwLmZvbGQgfmluaXQgfmY6YWRkIG5ld19pblxuICAgICAgICAgfCBTb21lIGluaXRpYWwgLT4gaW5pdGlhbCB+aW5pdCBuZXdfaW4pXG4gICAgICB8IFNvbWUgKG9sZF9pbiwgb2xkX291dCkgLT5cbiAgICAgICAgaWYgcmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSAmJiBNYXAubGVuZ3RoIG5ld19pbiA9IDBcbiAgICAgICAgdGhlbiBpbml0XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgfmluaXQ6b2xkX291dFxuICAgICAgICAgICAgb2xkX2luXG4gICAgICAgICAgICBuZXdfaW5cbiAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICB+ZjooZnVuIGFjYyAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgb2xkIC0+IHJlbW92ZSB+a2V5IH5kYXRhOm9sZCBhY2NcbiAgICAgICAgICAgICAgfCBgUmlnaHQgbmV3XyAtPiBhZGQgfmtleSB+ZGF0YTpuZXdfIGFjY1xuICAgICAgICAgICAgICB8IGBVbmVxdWFsIChvbGQsIG5ld18pIC0+IHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTpvbGQgfm5ld19kYXRhOm5ld18gYWNjKSlcbiAgOztcblxuICBsZXQgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgICAgP3VwZGF0ZVxuICAgICAgICBpbmNyX21hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBtYXRjaCB1cGRhdGUgd2l0aFxuICAgICAgfCBTb21lIHVwZGF0ZSAtPiB1cGRhdGVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgICAgYWRkXG4gICAgICAgICAgICB+b3V0ZXJfa2V5XG4gICAgICAgICAgICB+aW5uZXJfa2V5XG4gICAgICAgICAgICB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICAgICAgKHJlbW92ZSB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6b2xkX2RhdGEgYWNjKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIGluY3JfbWFwXG4gICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgfmluaXRcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5Om91dGVyX2tleSB+b2xkX2RhdGE6b2xkX2lubmVyX21hcCB+bmV3X2RhdGE6bmV3X2lubmVyX21hcCBhY2MgLT5cbiAgICAgICAgKE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmIG9sZF9pbm5lcl9tYXAgbmV3X2lubmVyX21hcCB+ZGF0YV9lcXVhbClcbiAgICAgICAgICB+aW5pdDphY2NcbiAgICAgICAgICB+ZjooZnVuIGFjYyAoaW5uZXJfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IGRhdGFfcmVtb3ZlZCAtPiByZW1vdmUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOmRhdGFfcmVtb3ZlZCBhY2NcbiAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfYWRkZWQgLT4gYWRkIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX2FkZGVkIGFjY1xuICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkX2RhdGEsIG5ld19kYXRhKSAtPlxuICAgICAgICAgICAgICB1cGRhdGUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjKSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIE1hcC5mb2xkIGlubmVyX21hcCB+aW5pdDphY2MgfmY6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYykpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICA7O1xuXG4gIGxldCB3aXRoX2NvbXBhcmF0b3InIGdldF9jb21wYXJhdG9yIHggZiA9XG4gICAgSW5jcmVtZW50YWwuYmluZCAoSW5jcmVtZW50YWwuZnJlZXplIChJbmNyZW1lbnRhbC5tYXAgeCB+ZjpnZXRfY29tcGFyYXRvcikpIH5mXG4gIDs7XG5cbiAgKCoqIENhcHR1cmVzIHRoZSBjb21wYXJhdG9yICh3aGljaCBjYW4ndCBjaGFuZ2UgYW55d2F5LCBzaW5jZSB0aGUgdHlwZSBkZXRlcm1pbmVzIHRoZVxuICAgICAgY29tcGFyYXRvcikgYnkgZnJlZXppbmcgdGhlIGNvcnJlc3BvbmRpbmcgbWFwLiAgTm90ZSB0aGF0IGJ5IGZpcnN0IHVzaW5nIEluY3JlbWVudGFsLm1hcCB0b1xuICAgICAgZ2V0IHRoZSBjb21wYXJhdG9yIG91dCBvZiB0aGUgbWFwLCB3ZSBhbGxvdyB0aGUgaW5pdGlhbCBtYXAgaXRzZWxmIHRvIGJlIGdhcmJhZ2VcbiAgICAgIGNvbGxlY3RlZCAqKVxuICBsZXQgd2l0aF9jb21wYXJhdG9yIG1hcCBmID0gd2l0aF9jb21wYXJhdG9yJyBNYXAuY29tcGFyYXRvciBtYXAgZlxuXG4gIGxldCBvZl9zZXQgc2V0ID1cbiAgICB3aXRoX2NvbXBhcmF0b3InIFNldC5jb21wYXJhdG9yIHNldCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBvbGRfaW5wdXQgPSByZWYgKFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgbGV0IG9sZF9vdXRwdXQgPSByZWYgKE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgSW5jcmVtZW50YWwubWFwIHNldCB+ZjooZnVuIG5ld19pbnB1dCAtPlxuICAgICAgICBsZXQgbmV3X291dHB1dCA9XG4gICAgICAgICAgU2VxdWVuY2UuZm9sZFxuICAgICAgICAgICAgKFNldC5zeW1tZXRyaWNfZGlmZiAhb2xkX2lucHV0IG5ld19pbnB1dClcbiAgICAgICAgICAgIH5pbml0OiFvbGRfb3V0cHV0XG4gICAgICAgICAgICB+ZjooZnVuIG91dHB1dCAtPiBmdW5jdGlvblxuICAgICAgICAgICAgICB8IEZpcnN0IGsgLT4gTWFwLnJlbW92ZSBvdXRwdXQga1xuICAgICAgICAgICAgICB8IFNlY29uZCBrIC0+IE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5OmsgfmRhdGE6KCkpXG4gICAgICAgIGluXG4gICAgICAgIG9sZF9pbnB1dCA6PSBuZXdfaW5wdXQ7XG4gICAgICAgIG9sZF9vdXRwdXQgOj0gbmV3X291dHB1dDtcbiAgICAgICAgbmV3X291dHB1dCkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaVxuICAgICAgICAodHlwZSBpbnB1dF9kYXRhIG91dHB1dF9kYXRhIGZfb3V0cHV0IHN0YXRlX3dpdG5lc3MpXG4gICAgICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKG1hcCA6ICgoJ2tleSwgaW5wdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oZiA6IGtleTona2V5IC0+IGRhdGE6aW5wdXRfZGF0YSAtPiBmX291dHB1dClcbiAgICA9XG4gICAgd2l0aF9vbGQgbWFwIH5mOihmdW4gfm9sZCBpbnB1dCAtPlxuICAgICAgbWF0Y2ggb2xkLCBNYXAubGVuZ3RoIGlucHV0IHdpdGhcbiAgICAgIHwgXywgMCB8IE5vbmUsIF8gLT5cbiAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gKE1hcC5tYXBpIGlucHV0IH5mIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudClcbiAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPiBNYXAuZmlsdGVyX21hcGkgaW5wdXQgfmYpXG4gICAgICB8IFNvbWUgKG9sZF9pbnB1dCwgb2xkX291dHB1dCksIF8gLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICBvbGRfaW5wdXRcbiAgICAgICAgICBpbnB1dFxuICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgfmluaXQ6b2xkX291dHB1dFxuICAgICAgICAgIH5mOihmdW4gb3V0cHV0IChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5XG4gICAgICAgICAgICB8IGBSaWdodCBuZXdfZGF0YSB8IGBVbmVxdWFsIChfLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgICAgbGV0IHJlcyA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICAgICAgICAobWF0Y2ggd2l0bmVzcyB3aXRoXG4gICAgICAgICAgICAgICB8IE1hcF90eXBlLk1hcCAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOnJlc1xuICAgICAgICAgICAgICAgfCBNYXBfdHlwZS5GaWx0ZXJfbWFwIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCByZXMgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgICAgICAgfCBTb21lIG91dHB1dF9kYXRhIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGE6b3V0cHV0X2RhdGEpKSkpXG4gIDs7XG5cbiAgbGV0IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID0gZ2VuZXJpY19tYXBpIE1hcCA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgbGV0IGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZiA9IGdlbmVyaWNfbWFwaSBGaWx0ZXJfbWFwID9kYXRhX2VxdWFsIG1hcCB+ZlxuICBsZXQgbWFwID9kYXRhX2VxdWFsIG1hcCB+ZiA9IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxuICBsZXQgZmlsdGVyX21hcCA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHdpdGhfb2xkMiBpMSBpMiB+ZiA9XG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgSW5jcmVtZW50YWwubWFwMiBpMSBpMiB+ZjooZnVuIGExIGEyIC0+XG4gICAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGExIGEyIGluXG4gICAgICBvbGQgOj0gU29tZSAoYTEsIGEyLCBiKTtcbiAgICAgIGIpXG4gIDs7XG5cbiAgbGV0IG1hcGlfY291bnRcbiAgICAgICAgKHR5cGUgYSBjbXApXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGlucHV0XG4gICAgICAgIH4oY29tcGFyYXRvciA6XG4gICAgICAgICAgICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGEgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKSlcbiAgICAgICAgfmZcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBNID0gKHZhbCBjb21wYXJhdG9yKSBpblxuICAgIGxldCBhZGQgbmV3X2tleSBhY2MgPVxuICAgICAgTWFwLnVwZGF0ZSBhY2MgbmV3X2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgfCBTb21lIG4gLT4gbiArIDEpXG4gICAgaW5cbiAgICBsZXQgcmVtb3ZlIG5ld19rZXkgYWNjID1cbiAgICAgIE1hcC5jaGFuZ2UgYWNjIG5ld19rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSAxIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIG4gLT4gU29tZSAobiAtIDEpKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIE0pKVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCAoZiB+a2V5IH5kYXRhKSBhY2MpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIChmIH5rZXkgfmRhdGEpIGFjYylcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIGxldCBwcmV2X2tleSA9IGYgfmtleSB+ZGF0YTpvbGRfZGF0YSBpblxuICAgICAgICBsZXQgbmV3X2tleSA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICBpZiBNLmNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIGFjY1xuICAgICAgICBlbHNlIGFjYyB8PiByZW1vdmUgcHJldl9rZXkgfD4gYWRkIG5ld19rZXkpXG4gIDs7XG5cbiAgbGV0IG1hcF9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1pbl9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtaW4sIF8pIC0+IFNvbWUgbWluXG4gIDs7XG5cbiAgbGV0IG1heF9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWF4X2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtYXgsIF8pIC0+IFNvbWUgbWF4XG4gIDs7XG5cbiAgbGV0IGJvdW5kc19oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAsIE1hcC5tYXhfZWx0IG1hcCB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKG1pbiwgXyksIFNvbWUgKG1heCwgXykgLT4gU29tZSAobWluLCBtYXgpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwIH5mOm1pbl9oZWxwZXIgKG1hcGlfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6bWF4X2hlbHBlciAobWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwaV9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpib3VuZHNfaGVscGVyIChtYXBpX2NvdW50ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1hcF9tYXggP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgbWluX3ZhbHVlID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yID1cbiAgICBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1heF92YWx1ZSA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX21heCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtYXBfYm91bmRzID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtZXJnZVxuICAgICAgICA/KGRhdGFfZXF1YWxfbGVmdCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8oZGF0YV9lcXVhbF9yaWdodCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGxlZnRfbWFwXG4gICAgICAgIHJpZ2h0X21hcFxuICAgICAgICB+ZlxuICAgID1cbiAgICB3aXRoX29sZDIgbGVmdF9tYXAgcmlnaHRfbWFwIH5mOihmdW4gfm9sZCBuZXdfbGVmdF9tYXAgbmV3X3JpZ2h0X21hcCAtPlxuICAgICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBuZXdfbGVmdF9tYXAgaW5cbiAgICAgIGxldCBvbGRfbGVmdF9tYXAsIG9sZF9yaWdodF9tYXAsIG9sZF9vdXRwdXQgPVxuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICAgICAgfCBTb21lIHggLT4geFxuICAgICAgaW5cbiAgICAgIGxldCBsZWZ0X2RpZmYgPVxuICAgICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX2xlZnRfbWFwIG5ld19sZWZ0X21hcCB+ZGF0YV9lcXVhbDpkYXRhX2VxdWFsX2xlZnRcbiAgICAgIGluXG4gICAgICBsZXQgcmlnaHRfZGlmZiA9XG4gICAgICAgIE1hcC5zeW1tZXRyaWNfZGlmZiBvbGRfcmlnaHRfbWFwIG5ld19yaWdodF9tYXAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgaW5cbiAgICAgICgqIFdlIG1lcmdlIHRoZSB0d28gc2lkZXMgb2YgdGhlIGRpZmZzIHRvZ2V0aGVyIHNvIHdlIGNhbiBtYWtlIHN1cmUgdG8gaGFuZGxlIGVhY2hcbiAgICAgICAgIGtleSBleGFjdGx5IG9uY2UuIFRoaXMgcmVsaWVzIG9uIHN5bW1ldHJpYyBkaWZmIGdpdmluZyBzb3J0ZWQgb3V0cHV0LiAqKVxuICAgICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAgIGxlZnRfZGlmZlxuICAgICAgICByaWdodF9kaWZmXG4gICAgICAgIH5jb21wYXJlOihmdW4gKGxlZnRfa2V5LCBfKSAocmlnaHRfa2V5LCBfKSAtPlxuICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZSBsZWZ0X2tleSByaWdodF9rZXkpXG4gICAgICB8PiBTZXF1ZW5jZS5mb2xkIH5pbml0Om9sZF9vdXRwdXQgfmY6KGZ1biBvdXRwdXQgZGlmZl9lbGVtZW50IC0+XG4gICAgICAgIGxldCBrZXkgPVxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBMZWZ0IChrZXksIF8pIHwgUmlnaHQgKGtleSwgXykgLT4ga2V5XG4gICAgICAgICAgfCBCb3RoICgobGVmdF9rZXksIF8pLCAocmlnaHRfa2V5LCBfKSkgLT5cbiAgICAgICAgICAgIGFzc2VydCAoY29tcGFyYXRvci5jb21wYXJlIGxlZnRfa2V5IHJpZ2h0X2tleSA9IDApO1xuICAgICAgICAgICAgbGVmdF9rZXlcbiAgICAgICAgaW5cbiAgICAgICAgKCogVGhlc2UgdmFsdWVzIHJlcHJlc2VudCB3aGV0aGVyIHRoZXJlIGlzIGRhdGEgZm9yIHRoZSBnaXZlbiBrZXkgaW4gdGhlIG5ld1xuICAgICAgICAgICBpbnB1dCBpbiB0aGUgbGVmdCBhbmQgcmlnaHQgbWFwLiAqKVxuICAgICAgICBsZXQgbGVmdF9kYXRhX29wdCwgcmlnaHRfZGF0YV9vcHQgPVxuICAgICAgICAgIGxldCBuZXdfZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBCb3RoICgoXywgbGVmdF9kaWZmKSwgKF8sIHJpZ2h0X2RpZmYpKSAtPlxuICAgICAgICAgICAgbmV3X2RhdGEgbGVmdF9kaWZmLCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgICAgfCBMZWZ0IChfLCBsZWZ0X2RpZmYpIC0+IG5ld19kYXRhIGxlZnRfZGlmZiwgTWFwLmZpbmQgbmV3X3JpZ2h0X21hcCBrZXlcbiAgICAgICAgICB8IFJpZ2h0IChfLCByaWdodF9kaWZmKSAtPiBNYXAuZmluZCBuZXdfbGVmdF9tYXAga2V5LCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvdXRwdXRfZGF0YV9vcHQgPVxuICAgICAgICAgIG1hdGNoIGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0IHdpdGhcbiAgICAgICAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSB4LCBOb25lIC0+IGYgfmtleSAoYExlZnQgeClcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgeSAtPiBmIH5rZXkgKGBSaWdodCB5KVxuICAgICAgICAgIHwgU29tZSB4LCBTb21lIHkgLT4gZiB+a2V5IChgQm90aCAoeCwgeSkpXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIG91dHB1dF9kYXRhX29wdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIGlucHV0X2RhdGEgb3V0cHV0X2RhdGEgZl9vdXRwdXQgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgKHdpdG5lc3MgOiAoaW5wdXRfZGF0YSwgb3V0cHV0X2RhdGEsIGZfb3V0cHV0KSBNYXBfdHlwZS50KVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChsaHMgOiAoKCdrZXksIGlucHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KGNvbXBhcmF0b3IgOiAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50KVxuICAgICAgICB+KGYgOlxuICAgICAgICAgICAga2V5OidrZXlcbiAgICAgICAgICAtPiBkYXRhOihpbnB1dF9kYXRhLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgICAgLT4gKGZfb3V0cHV0LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgIDogKCgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgbGhzIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBwcmV2X25vZGVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBhY2MgOiAoJ2tleSwgb3V0cHV0X2RhdGEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFhY2MpIGluXG4gICAgbGV0IChvbl9pbm5lcl9jaGFuZ2UgOiBrZXk6J2tleSAtPiBmX291dHB1dCAtPiB1bml0KSA9XG4gICAgICBtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgIHwgTWFwX3R5cGUuTWFwIC0+IGZ1biB+a2V5IGRhdGEgLT4gYWNjIDo9IE1hcC5zZXQgIWFjYyB+a2V5IH5kYXRhXG4gICAgICB8IE1hcF90eXBlLkZpbHRlcl9tYXAgLT5cbiAgICAgICAgZnVuIH5rZXkgb3B0IC0+XG4gICAgICAgICAgbGV0IG9sZCA9ICFhY2MgaW5cbiAgICAgICAgICBhY2NcbiAgICAgICAgICA6PSAobWF0Y2ggb3B0IHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG9sZCBrZXlcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE1hcC5zZXQgb2xkIH5rZXkgfmRhdGEpXG4gICAgaW5cbiAgICBsZXQgcmVjIGxoc19jaGFuZ2UgPVxuICAgICAgbGF6eVxuICAgICAgICAoSW5jcmVtZW50YWwubWFwIGxocyB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9kZXAgPSBNYXAuZmluZF9leG4gbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IHJlc3VsdCBkZXA7XG4gICAgICAgICAgICAgICAgICAgYWNjIDo9IE1hcC5yZW1vdmUgIWFjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgT3B0aW9uLml0ZXIgY3V0b2ZmIH5mOihmdW4gYyAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBsaHNfY2hhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgbGV0IHVzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgKGYgfmtleSB+ZGF0YTooRS5Ob2RlLndhdGNoIG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihvbl9pbm5lcl9jaGFuZ2UgfmtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgTWFwLnNldCBub2RlcyB+a2V5IH5kYXRhOihub2RlLCB1c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByZXZfbm9kZXMgOj0gbmV3X25vZGVzO1xuICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgbGhzX2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCByZXN1bHRcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgTWFwX3R5cGUuRmlsdGVyX21hcFxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwaScgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJyBNYXBfdHlwZS5NYXAgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIG1hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1lcmdlJyA/Y3V0b2ZmID9kYXRhX2VxdWFsX2xlZnQgP2RhdGFfZXF1YWxfcmlnaHQgbWFwMSBtYXAyIH5mID1cbiAgICBtZXJnZSA/ZGF0YV9lcXVhbF9sZWZ0ID9kYXRhX2VxdWFsX3JpZ2h0IG1hcDEgbWFwMiB+ZjooZnVuIH5rZXk6XyBkaWZmIC0+IFNvbWUgZGlmZilcbiAgICB8PiBmaWx0ZXJfbWFwaScgP2N1dG9mZiB+ZjooZnVuIH5rZXkgfmRhdGE6ZGlmZiAtPiBmIH5rZXkgZGlmZilcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaV93aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgOiB2IC0+IHYgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8obGVmdF9yZXN1bHRfZXF1YWwgOiB2MSAtPiB2MSAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgPyhyaWdodF9yZXN1bHRfZXF1YWwgOiB2MiAtPiB2MiAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgKGlucHV0IDogKCgna2V5LCB2LCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICAgICAgfihmIDoga2V5OidrZXkgLT4gZGF0YTp2IC0+IHYxICogdjIpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBsZWZ0X2FjYyA6ICgna2V5LCB2MSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhbGVmdF9hY2MpIGluXG4gICAgbGV0IHJpZ2h0X2FjYyA6ICgna2V5LCB2MiwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByaWdodF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJpZ2h0X2FjYykgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGlucHV0X2NoYW5nZSA9XG4gICAgICBJbmNyZW1lbnRhbC5tYXAgaW5wdXQgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgbGV0IGxlZnQsIHJpZ2h0ID1cbiAgICAgICAgICBtYXRjaCBNYXAuaXNfZW1wdHkgIXByZXZfbWFwLCBNYXAuaXNfZW1wdHkgbWFwIHdpdGhcbiAgICAgICAgICB8IHRydWUsIHRydWUgfCBmYWxzZSwgdHJ1ZSAtPiBlbXB0eV9tYXAsIGVtcHR5X21hcFxuICAgICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgICAgICgqIE1hcHBpbmcgb24gYSBtYXAgaXMgd2F5IGZhc3RlciB0aGFuIHN5bW1ldHJpYyBkaWZmaW5nIGFuZCB0aGVuXG4gICAgICAgICAgICAgICBidWlsZGluZyB0aGUgbWFwcyB1cCBwaWVjZSBieSBwaWVjZSwgc28gd2UgZG8gdGhpcyB3aGVuZXZlciB3ZVxuICAgICAgICAgICAgICAgdHJhbnNpdGlvbiBmcm9tIFwiZW1wdHlcIiB0byBcInNvbWV0aGluZ1wiLCB3aGljaCB3aWxsIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgIGhhcHBlbiBvbiB0aGUgZmlyc3Qgc3RhYmlsaXphdGlvbi4gKilcbiAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgIGxldCBsLCBfID0gZiB+a2V5IH5kYXRhIGluXG4gICAgICAgICAgICAgICAgbClcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgcmlnaHQgPVxuICAgICAgICAgICAgICBNYXAubWFwaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICAgICAgbGV0IF8sIHIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICAgICAgICByKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgfCBmYWxzZSwgZmFsc2UgLT5cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgfmluaXQ6KCFsZWZ0X2FjYywgIXJpZ2h0X2FjYylcbiAgICAgICAgICAgICAgfmY6KGZ1biAobGVmdCwgcmlnaHQpIChrZXksIGNoYW5nZWQpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAocHJldiwgbmV3XykgLT5cbiAgICAgICAgICAgICAgICAgIGxldCBwcmV2X2EsIHByZXZfYiA9IGYgfmtleSB+ZGF0YTpwcmV2IGluXG4gICAgICAgICAgICAgICAgICBsZXQgbmV3X2EsIG5ld19iID0gZiB+a2V5IH5kYXRhOm5ld18gaW5cbiAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgbGVmdF9yZXN1bHRfZXF1YWwgcHJldl9hIG5ld19hXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gbGVmdFxuICAgICAgICAgICAgICAgICAgICBlbHNlIE1hcC5zZXQgbGVmdCB+a2V5IH5kYXRhOm5ld19hXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgcmlnaHRfcmVzdWx0X2VxdWFsIHByZXZfYiBuZXdfYlxuICAgICAgICAgICAgICAgICAgICB0aGVuIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCByaWdodCB+a2V5IH5kYXRhOm5ld19iXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHRcbiAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBsZWZ0IGtleSwgTWFwLnJlbW92ZSByaWdodCBrZXlcbiAgICAgICAgICAgICAgICB8IGBSaWdodCBlbGVtZW50IC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYSwgYiA9IGYgfmtleSB+ZGF0YTplbGVtZW50IGluXG4gICAgICAgICAgICAgICAgICBNYXAuc2V0IGxlZnQgfmtleSB+ZGF0YTphLCBNYXAuc2V0IHJpZ2h0IH5rZXkgfmRhdGE6YilcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsICFsZWZ0X2FjYyBsZWZ0KSB0aGVuIEUuTm9kZS5tYWtlX3N0YWxlIGxlZnRfcmVzdWx0O1xuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgIXJpZ2h0X2FjYyByaWdodCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSByaWdodF9yZXN1bHQ7XG4gICAgICAgIGxlZnRfYWNjIDo9IGxlZnQ7XG4gICAgICAgIHJpZ2h0X2FjYyA6PSByaWdodDtcbiAgICAgICAgcHJldl9tYXAgOj0gbWFwKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIGlucHV0X2NoYW5nZSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpID9kYXRhX2VxdWFsID9sZWZ0X3Jlc3VsdF9lcXVhbCA/cmlnaHRfcmVzdWx0X2VxdWFsIGlucHV0IH5mID1cbiAgICBsZXQgcGFpciA9XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICAgIGlucHV0XG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgICAgICAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgICAgICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICAgICAgICB+ZlxuICAgICAgICB8PiBUdXBsZTIudW5jdXJyeSBJbmNyZW1lbnRhbC5ib3RoKVxuICAgIGluXG4gICAgSW5jcmVtZW50YWwubWFwIH5mOmZzdCBwYWlyLCBJbmNyZW1lbnRhbC5tYXAgfmY6c25kIHBhaXJcbiAgOztcblxuICBsZXQgdW56aXAgP2xlZnRfcmVzdWx0X2VxdWFsID9yaWdodF9yZXN1bHRfZXF1YWwgaW5wdXQgPVxuICAgIGxldCBkYXRhX2VxdWFsID1cbiAgICAgIE9wdGlvbi5tYXAyIGxlZnRfcmVzdWx0X2VxdWFsIHJpZ2h0X3Jlc3VsdF9lcXVhbCB+ZjooZnVuIGwgciAtPlxuICAgICAgICBUdXBsZTIuZXF1YWwgfmVxMTpsIH5lcTI6cilcbiAgICBpblxuICAgIHVuemlwX21hcGlcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgIGlucHV0XG4gICAgICB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBkYXRhKVxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6XG4gICAgICAgICAgICBrZXk6J2tleVxuICAgICAgICAgIC0+IGRhdGE6KHYsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAodjEsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQgKiAodjIsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IGxlZnRfYWNjIDo9IE1hcC5zZXQgIWxlZnRfYWNjIH5rZXkgfmRhdGEgaW5cbiAgICBsZXQgcmlnaHRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IHJpZ2h0X2FjYyA6PSBNYXAuc2V0ICFyaWdodF9hY2MgfmtleSB+ZGF0YSBpblxuICAgIGxldCByZWMgaW5wdXRfY2hhbmdlID1cbiAgICAgIGxhenlcbiAgICAgICAgKEluY3JlbWVudGFsLm1hcCBpbnB1dCB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9sZWZ0X2RlcCwgX3JpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBFLk5vZGUubWFrZV9zdGFsZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBsZWZ0X2RlcCwgcmlnaHRfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfZGVwO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgcmlnaHRfZGVwO1xuICAgICAgICAgICAgICAgICAgIGxlZnRfYWNjIDo9IE1hcC5yZW1vdmUgIWxlZnRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICByaWdodF9hY2MgOj0gTWFwLnJlbW92ZSAhcmlnaHRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuaW52YWxpZGF0ZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgTWFwLmZpbmRfZXhuICFwcmV2X21hcCBrZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBPcHRpb24uaXRlciBjdXRvZmYgfmY6KGZ1biBjIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5zZXRfY3V0b2ZmIChFLk5vZGUud2F0Y2ggbm9kZSkgYyk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X2luY3IsIHJpZ2h0X2luY3IgPSBmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRfdXNlcl9mdW5jdGlvbl9kZXAgPVxuICAgICAgICAgICAgICAgICAgICAgRS5EZXBlbmRlbmN5LmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICByaWdodF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KHJpZ2h0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcDtcbiAgICAgICAgICAgICAgICAgICBNYXAuc2V0XG4gICAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgICAgICAgfmRhdGE6KG5vZGUsIGxlZnRfdXNlcl9mdW5jdGlvbl9kZXAsIHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwKSlcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgcHJldl9ub2RlcyA6PSBuZXdfbm9kZXM7XG4gICAgICAgICAgIHByZXZfbWFwIDo9IG1hcCkpXG4gICAgaW5cbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgbGVmdF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgICAgbWFwXG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIH5jb21wYXJhdG9yIH5mXG4gICAgICAgIHw+IFR1cGxlMi51bmN1cnJ5IEluY3JlbWVudGFsLmJvdGgpXG4gICAgaW5cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6ZnN0IHBhaXIsIEluY3JlbWVudGFsLm1hcCB+ZjpzbmQgcGFpclxuICA7O1xuXG4gIGxldCBrZXlzIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBhZGQgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5hZGQgYWNjIGtleSBpblxuICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhOl8gYWNjID0gU2V0LnJlbW92ZSBhY2Mga2V5IGluXG4gICAgICBsZXQgZGF0YV9lcXVhbCBfIF8gPSB0cnVlIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICBtYXBcbiAgICAgICAgfmluaXQ6KFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdDooZW1wdHksIGVtcHR5KVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YTpfIH5uZXdfZGF0YTpkYXRhIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBGaXJzdCBkYXRhIC0+IE1hcC5zZXQgZmlyc3QgfmtleSB+ZGF0YSwgTWFwLnJlbW92ZSBzZWNvbmQga2V5XG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBNYXAucmVtb3ZlIGZpcnN0IGtleSwgTWFwLnNldCBzZWNvbmQgfmtleSB+ZGF0YSlcbiAgICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IGRhdGEgLT4gTWFwLmFkZF9leG4gZmlyc3QgfmtleSB+ZGF0YSwgc2Vjb25kXG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBmaXJzdCwgTWFwLmFkZF9leG4gc2Vjb25kIH5rZXkgfmRhdGEpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhOl8gKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgTWFwLnJlbW92ZSBmaXJzdCBrZXksIE1hcC5yZW1vdmUgc2Vjb25kIGtleSkpXG4gIDs7XG5cbiAgbGV0IGZsYXR0ZW4gc3RhdGUgbWFwID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgcmVzdWx0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKSkgaW5cbiAgICBsZXQgbm9kZSA9IEUuTm9kZS5jcmVhdGUgc3RhdGUgKGZ1biAoKSAtPiAhcmVzdWx0KSBpblxuICAgIE1hcC5pdGVyaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhOmluY3IgLT5cbiAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeVxuICAgICAgICBub2RlXG4gICAgICAgIChFLkRlcGVuZGVuY3kuY3JlYXRlIGluY3Igfm9uX2NoYW5nZTooZnVuIGEgLT5cbiAgICAgICAgICAgcmVzdWx0IDo9IE1hcC5zZXQgIXJlc3VsdCB+a2V5IH5kYXRhOmEpKSk7XG4gICAgRS5Ob2RlLndhdGNoIG5vZGVcbiAgOztcblxuICBsZXQgam9pbl93aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgfmNvbXBhcmF0b3IgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIG1hcF9pbmNyIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHJlc3VsdF9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IG9sZF9tYXBfb2ZfaW5jcnMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGN1cnJlbnRfZGVwZW5kZW5jaWVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJlc3VsdF9tYXApIGluXG4gICAgbGV0IGFkZF9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGFfbm9kZSA9XG4gICAgICBsZXQgbmV3X2RlcCA9XG4gICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGUgZGF0YV9ub2RlIH5vbl9jaGFuZ2U6KGZ1biBkYXRhIC0+XG4gICAgICAgICAgcmVzdWx0X21hcCA6PSBNYXAuc2V0ICFyZXN1bHRfbWFwIH5rZXkgfmRhdGEpXG4gICAgICBpblxuICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCBuZXdfZGVwO1xuICAgICAgTWFwLnNldCBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhOm5ld19kZXBcbiAgICBpblxuICAgIGxldCByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5ID1cbiAgICAgIGxldCBkZXAgPSBNYXAuZmluZF9leG4gY3VycmVudF9kZXBlbmRlbmNpZXMga2V5IGluXG4gICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmVzdWx0IGRlcDtcbiAgICAgIHJlc3VsdF9tYXAgOj0gTWFwLnJlbW92ZSAhcmVzdWx0X21hcCBrZXk7XG4gICAgICBNYXAucmVtb3ZlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIGtleVxuICAgIGluXG4gICAgbGV0IGxoc19jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIG1hcF9pbmNyIH5mOihmdW4gbWFwX29mX2luY3JzIC0+XG4gICAgICAgIGxldCBuZXdfZGVwZW5kZW5jeV9tYXAgPVxuICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICB+ZGF0YV9lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAhb2xkX21hcF9vZl9pbmNyc1xuICAgICAgICAgICAgbWFwX29mX2luY3JzXG4gICAgICAgICAgICB+aW5pdDohY3VycmVudF9kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIH5mOihmdW4gY3VycmVudF9kZXBlbmRlbmNpZXMgKGtleSwgZGlmZikgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgXyAtPiByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5XG4gICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfbm9kZSAtPiBhZGRfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhX25vZGVcbiAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoXywgZGF0YV9ub2RlKSAtPlxuICAgICAgICAgICAgICAgIHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfD4gYWRkX3N1Ym5vZGUgfmtleSB+ZGF0YV9ub2RlKVxuICAgICAgICBpblxuICAgICAgICBjdXJyZW50X2RlcGVuZGVuY2llcyA6PSBuZXdfZGVwZW5kZW5jeV9tYXA7XG4gICAgICAgIG9sZF9tYXBfb2ZfaW5jcnMgOj0gbWFwX29mX2luY3JzKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBsaHNfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGpvaW4gbWFwID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPiBqb2luX3dpdGhfY29tcGFyYXRvciBtYXAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbW9kdWxlIFNlcGFyYXRlX3N0YXRlID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdCA9XG4gICAgICB7IG11dGFibGUgaW5wdXRfbWFwIDogKCdrLCAndiwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgbXV0YWJsZSBleHBlcnRfbm9kZXMgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnQsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgb3V0cHV0X21hcCA6ICgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnRcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgY29tcGFyYXRvciA9XG4gICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgeyBpbnB1dF9tYXAgPSBlbXB0eTsgZXhwZXJ0X25vZGVzID0gZW1wdHk7IG91dHB1dF9tYXAgPSBlbXB0eSB9XG4gICAgOztcblxuICAgIGxldCBjcmVhdGVfbG9va3VwX25vZGUgc3RhdGUgdCBrZXkgPVxuICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT4gTWFwLmZpbmRfZXhuIHQuaW5wdXRfbWFwIGtleSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2VwYXJhdGUgaW5wdXRfbWFwIH5kYXRhX2VxdWFsID1cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXAgaW5cbiAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXRfbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IHN0YXRlID0gU2VwYXJhdGVfc3RhdGUuY3JlYXRlIGNvbXBhcmF0b3IgaW5cbiAgICAgIGxldCBvdXRwdXRfbWFwX25vZGUgPVxuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiBzdGF0ZS5vdXRwdXRfbWFwKVxuICAgICAgaW5cbiAgICAgIGxldCBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG5vZGUgfmlucHV0X21hcF9jaGFuZ2VkID1cbiAgICAgICAgbGV0IGRlcGVuZGVuY3kgPVxuICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSAoTGF6eS5mb3JjZV92YWwgaW5wdXRfbWFwX2NoYW5nZWQpXG4gICAgICAgIGluXG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgZGVwZW5kZW5jeVxuICAgICAgaW5cbiAgICAgICgqIFdlIHdhbnQgdG8gbWFrZSBub2RlcyBkZXBlbmQgb24gW2lucHV0X21hcF9jaGFuZ2VkXSBzbyB0aGF0IFtpbnB1dF9tYXBfY2hhbmdlZF1cbiAgICAgICAgIGlzIGFsbG93ZWQgdG8gbWFrZSB0aGVtIHN0YWxlLCBidXQgd2UgZG8gbm90IHdhbnQgdGhlbSB0byBiZSByZWNvbXB1dGVkIGZvciBhbnlcbiAgICAgICAgIG90aGVyIHJlYXNvbi4gU28gd2UgbWFrZSBbaW5wdXRfbWFwX2NoYW5nZWRdIGEgdW5pdCBpbmNyZW1lbnRhbCAodGhhdCB0aGVyZWZvcmVcbiAgICAgICAgIG5ldmVyIGNoYW5nZXMpIGFuZCB0aGlzIHdheSBbb3V0cHV0X21hcF9ub2RlXSBhbmQgdGhlIGxvb2t1cCBub2RlcyB3aWxsIG9ubHkgYmVcbiAgICAgICAgIHJlY29tcHV0ZWQgd2hlbiB0aGV5IGFyZSBleHBsaWNpdGx5IG1hZGUgc3RhbGUuXG4gICAgICAqKVxuICAgICAgbGV0IHJlYyBpbnB1dF9tYXBfY2hhbmdlZCA9XG4gICAgICAgIGxhenlcbiAgICAgICAgICAoSW5jcmVtZW50YWwubWFwIGlucHV0X21hcCB+ZjooZnVuIGlucHV0X21hcCAtPlxuICAgICAgICAgICAgIGxldCBwcmV2X2lucHV0X21hcCA9IHN0YXRlLmlucHV0X21hcCBpblxuICAgICAgICAgICAgIGxldCBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXAgPVxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgcHJldl9pbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgaW5wdXRfbWFwXG4gICAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAgIH5pbml0OihzdGF0ZS5leHBlcnRfbm9kZXMsIHN0YXRlLm91dHB1dF9tYXApXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gKGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfb2xkX3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgb2xkX25vZGUgPSBNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuaW52YWxpZGF0ZSBvbGRfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgTWFwLnJlbW92ZSBleHBlcnRfbm9kZXMga2V5LCBNYXAucmVtb3ZlIG91dHB1dF9tYXAga2V5XG4gICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgX25ld192YWx1ZSAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICBTZXBhcmF0ZV9zdGF0ZS5jcmVhdGVfbG9va3VwX25vZGUgaW5jcmVtZW50YWxfc3RhdGUgc3RhdGUga2V5XG4gICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBub2RlIH5pbnB1dF9tYXBfY2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgKCBNYXAuYWRkX2V4biBleHBlcnRfbm9kZXMgfmtleSB+ZGF0YTpub2RlXG4gICAgICAgICAgICAgICAgICAgICAsIE1hcC5hZGRfZXhuXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X21hcFxuICAgICAgICAgICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGF0YTooSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggbm9kZSkgKVxuICAgICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgKF9vbGRfdmFsdWUsIF9uZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5tYWtlX3N0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgIChNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXApXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBzdGF0ZS5pbnB1dF9tYXAgPC0gaW5wdXRfbWFwO1xuICAgICAgICAgICAgIHN0YXRlLmV4cGVydF9ub2RlcyA8LSBleHBlcnRfbm9kZXM7XG4gICAgICAgICAgICAgc3RhdGUub3V0cHV0X21hcCA8LSBvdXRwdXRfbWFwKSlcbiAgICAgIGluXG4gICAgICBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG91dHB1dF9tYXBfbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQ7XG4gICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBvdXRwdXRfbWFwX25vZGUpXG4gIDs7XG5cbiAgKCogSnVzdCBmb3IgZGVyaXZpbmcgc3RydWN0dXJhbCBlcXVhbGl0eS4gKilcbiAgdHlwZSAnYSBtYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgPSAnYSBNYXliZV9ib3VuZC50ID1cbiAgICB8IEluY2wgb2YgJ2FcbiAgICB8IEV4Y2wgb2YgJ2FcbiAgICB8IFVuYm91bmRlZFxuICBbQEBkZXJpdmluZyBlcXVhbF1cblxuICBsZXQgc3VicmFuZ2VcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAobWFwX2luY3IgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIHJhbmdlXG4gICAgPVxuICAgIHdpdGhfb2xkMiBtYXBfaW5jciByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIHJhbmdlIC0+XG4gICAgICBsZXQgY29tcGFyZSA9IChNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgIGxldCBlcXVhbCBsIHIgPSBjb21wYXJlIGwgciA9IDAgaW5cbiAgICAgIGxldCAoID4gKSBhIGIgPSBjb21wYXJlIGEgYiA+IDBcbiAgICAgIGFuZCAoID49ICkgYSBiID0gY29tcGFyZSBhIGIgPj0gMCBpblxuICAgICAgbGV0IG1heWJlX2JvdW5kX2VxdWFsIGEgYiA6IGJvb2wgPSBlcXVhbF9tYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgZXF1YWwgYSBiIGluXG4gICAgICBsZXQgcmFuZ2VfaXNfZW1wdHkgfm1pbiB+bWF4IDogYm9vbCA9XG4gICAgICAgIG1hdGNoIG1pbiwgbWF4IHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQsIChVbmJvdW5kZWQgfCBFeGNsIF8gfCBJbmNsIF8pIHwgKEV4Y2wgXyB8IEluY2wgXyksIFVuYm91bmRlZCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIHwgSW5jbCBtaW4sIEluY2wgbWF4IC0+IG1pbiA+IG1heFxuICAgICAgICB8IEV4Y2wgbWluLCBFeGNsIG1heCB8IEluY2wgbWluLCBFeGNsIG1heCB8IEV4Y2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPj0gbWF4XG4gICAgICBpblxuICAgICAgbGV0IHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXkgOiBib29sID1cbiAgICAgICAgTWF5YmVfYm91bmQuaXNfbG93ZXJfYm91bmQgbWluIH5vZl86a2V5IH5jb21wYXJlXG4gICAgICAgICYmIE1heWJlX2JvdW5kLmlzX3VwcGVyX2JvdW5kIG1heCB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHJhbmdlIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAoKiBFbXB0eSBuZXcgcmFuZ2UgbWVhbnMgZW1wdHkgbWFwICopXG4gICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICB8IFNvbWUgKChtaW4sIG1heCkgYXMgcmFuZ2UpIC0+XG4gICAgICAgIGxldCBmcm9tX3NjcmF0Y2ggKCkgPSBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZDptaW4gfnVwcGVyX2JvdW5kOm1heCBpblxuICAgICAgICAobWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIE5vbmUsIF8pIC0+XG4gICAgICAgICAgICgqIG5vIG9sZCByYW5nZSAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAoXywgU29tZSAob2xkX21pbiwgb2xkX21heCksIF8pXG4gICAgICAgICAgIHdoZW4gcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW4gfm1heDpvbGRfbWF4XG4gICAgICAgICAgICAgfHwgcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXggLT5cbiAgICAgICAgICAgKCogZW1wdHkgb2xkIHJhbmdlIG9yIG9sZCByYW5nZSBkaXNqb2ludCB3aXRoIG5ldyAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAob2xkX21hcCwgU29tZSAoKG9sZF9taW4sIG9sZF9tYXgpIGFzIG9sZF9yYW5nZSksIG9sZF9yZXMpIC0+XG4gICAgICAgICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgICAgICAgICgqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGtleSBpcyBpbiBib3RoIG5ldyBhbmQgb2xkIHJhbmdlcyAqKVxuICAgICAgICAgICAgIGxldCBpbl9yYW5nZV9pbnRlcnNlY3Rpb24ga2V5ID1cbiAgICAgICAgICAgICAgIHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXlcbiAgICAgICAgICAgICAgICYmIHJhbmdlX2luY2x1ZGVzIH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXgga2V5XG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBBcHBseSBjaGFuZ2VzIHRvIGtleXMgd2hpY2ggYXJlIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgYm90aCByYW5nZXMuXG5cbiAgICAgICAgICAgICAgICBbb3V0c2lkZV0gaXMgdGhlIG51bWJlciBvZiB1cGRhdGVzIG91dHNpZGUgdGhlIHJhbmdlIGludGVyc2VjdGlvbiB0aGF0IHdlXG4gICAgICAgICAgICAgICAgdG9sZXJhdGUgYmVmb3JlIGdpdmluZyB1cCBhbmQgcmVjb25zdHJ1Y3RpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZS4gVGhpc1xuICAgICAgICAgICAgICAgIGlzIGFuIG9wdGltaXNhdGlvbiBpbiB0aGUgY2FzZSB0aGF0IHRoZSBtYXAgY2hhbmdlcyBpbiBhIHZlcnkgYmlnIHdheSwgYXRcbiAgICAgICAgICAgICAgICB3aGljaCBwb2ludCBjb21wdXRpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZSBpcyBjaGVhcGVyLiAgKilcbiAgICAgICAgICAgICBsZXQgYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24gKG91dHNpZGUsIG1hcCkgKGtleSwgZGF0YSkgPVxuICAgICAgICAgICAgICAgaWYgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleVxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5XG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGEgfCBgVW5lcXVhbCAoXywgZGF0YSkgLT4gb3V0c2lkZSwgTWFwLnNldCBtYXAgfmtleSB+ZGF0YSlcbiAgICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgICBsZXQgb3V0c2lkZSA9IG91dHNpZGUgLSAxIGluXG4gICAgICAgICAgICAgICAgIGlmIEludC5PLihvdXRzaWRlIDwgMClcbiAgICAgICAgICAgICAgICAgdGhlbiByZXR1cm4gKGZyb21fc2NyYXRjaCAoKSlcbiAgICAgICAgICAgICAgICAgZWxzZSBvdXRzaWRlLCBNYXAucmVtb3ZlIG1hcCBrZXkpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBGaXJzdCB1cGRhdGUgdGhlIGtleXMgaW4gL2JvdGgvIHRoZSBvbGQgYW5kIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgbGV0IHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uID1cbiAgICAgICAgICAgICAgICgqIEN1dG9mZiB0aGUgYmlnIGRpZmYgY29tcHV0YXRpb24gaWYgd2UgcmVhY2ggTyh8c3VibWFwfCkgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHJhbmdlICopXG4gICAgICAgICAgICAgICBsZXQgb3V0c2lkZV9jdXRvZmYgPSBNYXAubGVuZ3RoIG9sZF9yZXMgLyA0IGluXG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgICB+aW5pdDoob3V0c2lkZV9jdXRvZmYsIG9sZF9yZXMpXG4gICAgICAgICAgICAgICAgIH5mOmFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICB8PiBzbmRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIFR1cGxlMi5lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMTptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMjptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgb2xkX3JhbmdlXG4gICAgICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIFRoZXJlIGFyZSBubyBrZXlzIHRvIHJlbW92ZSBhbmQgZXZlcnl0aGluZyBpbiByYW5nZSBpcyB1cGRhdGVkLiAqKVxuICAgICAgICAgICAgICAgd2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICgqIFJlbW92ZSBhbnkga2V5cyB3aGljaCBhcmUgbm90IGluIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgICBsZXQgd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZVxuICAgICAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgfmxvd2VyX2JvdW5kOm1pblxuICAgICAgICAgICAgICAgICAgIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoKiBBZGQgaW4gYW55IGtleXMgd2hpY2ggYXJlIGluIHRoZSBuZXcgcmFuZ2UgYnV0IG5vdCB0aGUgb2xkIHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlID1cbiAgICAgICAgICAgICAgICAgbGV0IG1hcF9hcHBlbmRfZXhuIGxvd2VyX3BhcnQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICAgICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiaW1wb3NzaWJsZSBjYXNlOiBCVUcgaW4gaW5jcl9tYXAubWwgc3VicmFuZ2VcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21pbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEluY2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21pbiAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDooRXhjbCBvbGRfbWluKVxuICAgICAgICAgICAgICAgICBhbmQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21heCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihJbmNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21heCAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6KEV4Y2wgb2xkX21heCkgfnVwcGVyX2JvdW5kOm1heFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBtYXBfYXBwZW5kX2V4blxuICAgICAgICAgICAgICAgICAgIGxvd2VyX3BhcnRcbiAgICAgICAgICAgICAgICAgICAobWFwX2FwcGVuZF9leG4gd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSB1cHBlcl9wYXJ0KVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlKSkpKVxuICA7O1xuXG4gIGxldCByZWtleSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5mID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgbWFwX2luY3JcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLmFkZF9leG4gb3V0cHV0IH5rZXk6KGYgfmtleSB+ZGF0YSkgfmRhdGEpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLnJlbW92ZSBvdXRwdXQgKGYgfmtleSB+ZGF0YSkpXG4gICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIG91dHB1dCAtPlxuICAgICAgICBsZXQgcHJldl9rZXkgPSBmIH5rZXkgfmRhdGE6b2xkX2RhdGEgaW5cbiAgICAgICAgbGV0IG5ld19rZXkgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgaWYgKE1hcC5jb21wYXJhdG9yIG91dHB1dCkuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIE1hcC5zZXQgb3V0cHV0IH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICBlbHNlIE1hcC5yZW1vdmUgb3V0cHV0IHByZXZfa2V5IHw+IE1hcC5hZGRfZXhuIH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YSlcbiAgOztcblxuICBsZXQgaW5kZXhfYnlpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3IgfmluZGV4ID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgKGZ1biBpbm5lcl9jb21wYXJhdG9yIC0+XG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfmFkZDooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIG91dGVyX21hcCAtPlxuICAgICAgICAgIG1hdGNoIGluZGV4IH5rZXk6aW5uZXJfa2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gb3V0ZXJfbWFwXG4gICAgICAgICAgfCBTb21lIG91dGVyX2tleSAtPlxuICAgICAgICAgICAgTWFwLnVwZGF0ZSBvdXRlcl9tYXAgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b25cbiAgICAgICAgICAgICAgICAgIGlubmVyX2tleVxuICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+IE1hcC5hZGRfZXhuIGlubmVyX21hcCB+a2V5OmlubmVyX2tleSB+ZGF0YSkpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC5jaGFuZ2Ugb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZmFpbHdpdGggXCJCVUc6IEhpdCBzdXBwb3NlZGx5IGltcG9zc2libGUgY2FzZSBpbiBJbmNyX21hcC5pbmRleF9ieVwiXG4gICAgICAgICAgICAgIHwgU29tZSBpbm5lcl9tYXAgLT5cbiAgICAgICAgICAgICAgICBsZXQgaW5uZXJfbWFwID0gTWFwLnJlbW92ZSBpbm5lcl9tYXAgaW5uZXJfa2V5IGluXG4gICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGlubmVyX21hcCB0aGVuIE5vbmUgZWxzZSBTb21lIGlubmVyX21hcCkpKVxuICA7O1xuXG4gIGxldCBpbmRleF9ieSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgIGluZGV4X2J5aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXg6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gaW5kZXggZGF0YSlcbiAgOztcblxuXG4gICgqKiBGaW5kIHR3byBrZXlzIGluIG1hcCBieSBpbmRleCwgTyhuKS4gV2UgdXNlIGp1c3Qgb25lIGZvbGQgKHR3byBNYXAubnRoIHdvdWxkIHVzZSB0d28pXG4gICAgICBhbmQgb3B0aW1pemUgZm9yIGtleXMgY2xvc2UgdG8gZWl0aGVyIGJlZ2lubmluZyBvciBlbmQgYnkgdXNpbmcgZWl0aGVyIGZvbGQgb3JcbiAgICAgIGZvbGRfcmlnaHQuXG4gICopXG4gIG1vZHVsZSBLZXlfc3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAnayB0ID1cbiAgICAgIHwgS25vd24gb2YgJ2tcbiAgICAgIHwgS25vd25fbm9uZVxuICAgICAgfCBVbmtub3duXG5cbiAgICBsZXQgaXNfa25vd24gPSBmdW5jdGlvblxuICAgICAgfCBVbmtub3duIC0+IGZhbHNlXG4gICAgICB8IF8gLT4gdHJ1ZVxuICAgIDs7XG5cbiAgICBsZXQgdG9fb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biB8IEtub3duX25vbmUgLT4gTm9uZVxuICAgICAgfCBLbm93biBrIC0+IFNvbWUga1xuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBmaW5kX2tleV9yYW5nZV9saW5lYXIgKHR5cGUgaykgfmZyb20gfnRvXyAobWFwIDogKGssIF8sIF8pIE1hcC50KVxuICAgIDogKGsgKiBrIG9wdGlvbikgb3B0aW9uXG4gICAgPVxuICAgIGxldCBvcGVuIEtleV9zdGF0dXMgaW5cbiAgICBsZXQgbGVuID0gTWFwLmxlbmd0aCBtYXAgaW5cbiAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPj0gKSBmcm9tIGxlbiB0aGVuIEtub3duX25vbmUgZWxzZSBVbmtub3duIGluXG4gICAgbGV0IGVuZF9rZXkgPSBpZiBJbnQuKCA+PSApIHRvXyBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBmaW5kX2tleXMgZm9sZCB+c3RhcnRfcG9zIH5hZHZhbmNlX3BvcyA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgZm9sZFxuICAgICAgICAgIG1hcFxuICAgICAgICAgIH5pbml0OihiZWdpbl9rZXksIGVuZF9rZXksIHN0YXJ0X3BvcylcbiAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6XyAoYmVnaW5fa2V5LCBlbmRfa2V5LCBwb3MpIC0+XG4gICAgICAgICAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPSApIHBvcyBmcm9tIHRoZW4gS25vd24ga2V5IGVsc2UgYmVnaW5fa2V5IGluXG4gICAgICAgICAgICBsZXQgZW5kX2tleSA9IGlmIEludC4oID0gKSBwb3MgdG9fIHRoZW4gS25vd24ga2V5IGVsc2UgZW5kX2tleSBpblxuICAgICAgICAgICAgaWYgaXNfa25vd24gYmVnaW5fa2V5ICYmIGlzX2tub3duIGVuZF9rZXlcbiAgICAgICAgICAgIHRoZW4gcmV0dXJuIChiZWdpbl9rZXksIGVuZF9rZXksIHBvcylcbiAgICAgICAgICAgIGVsc2UgYmVnaW5fa2V5LCBlbmRfa2V5LCBhZHZhbmNlX3BvcyBwb3MpKVxuICAgIGluXG4gICAgbGV0IGJlZ2luX2tleSwgZW5kX2tleSwgXyA9XG4gICAgICAoKiBTZWFyY2hpbmcgZnJvbSBsZWZ0IHRha2VzIE8odG9fKSwgZnJvbSByaWdodCAtIE8obGVuIC0gZnJvbSksIHNvIHNlbGVjdCB0aGVcbiAgICAgICAgIHNtYWxsZXIgb25lLiAqKVxuICAgICAgaWYgdG9fIDwgbGVuIC0gZnJvbVxuICAgICAgdGhlbiBmaW5kX2tleXMgTWFwLmZvbGQgfnN0YXJ0X3BvczowIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgKyAxKVxuICAgICAgZWxzZSBmaW5kX2tleXMgTWFwLmZvbGRfcmlnaHQgfnN0YXJ0X3BvczoobGVuIC0gMSkgfmFkdmFuY2VfcG9zOihmdW4gcG9zIC0+IHBvcyAtIDEpXG4gICAgaW5cbiAgICBPcHRpb24ubWFwIChLZXlfc3RhdHVzLnRvX29wdGlvbiBiZWdpbl9rZXkpIH5mOihmdW4gYmVnaW5fa2V5IC0+XG4gICAgICBiZWdpbl9rZXksIEtleV9zdGF0dXMudG9fb3B0aW9uIGVuZF9rZXkpXG4gIDs7XG5cbiAgbGV0IG50aF9mcm9tX2VpdGhlcl9zaWRlICh0eXBlIGspIG4gKG1hcCA6IChrLCBfLCBfKSBNYXAudCkgOiBrIG9wdGlvbiA9XG4gICAgT3B0aW9uLm1hcCB+Zjpmc3QgKGZpbmRfa2V5X3JhbmdlX2xpbmVhciB+ZnJvbTpuIH50b186biBtYXApXG4gIDs7XG5cbiAgKCoqIEZpbmQga2V5IFtieV0gcG9zaXRpb25zIGVhcmxpZXIvbGF0ZXIgaW4gYSBtYXAuIFJldHVybnMgbm9uZSBpZiBvdXQgb2YgYm91bmRzLiAqKVxuICBsZXQgcmVjIG9mZnNldCAoa2V5IDogJ2spIChtYXAgOiAoJ2ssIF8sIF8pIE1hcC50KSB+YnkgOiAnayBvcHRpb24gPVxuICAgIGlmIEludC4oID0gKSBieSAwXG4gICAgdGhlbiBTb21lIGtleVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNsb3Nlc3RfZGlyLCBhZGQgPVxuICAgICAgICBpZiBJbnQuKCA8ICkgYnkgMCB0aGVuIGBMZXNzX3RoYW4sIDEgZWxzZSBgR3JlYXRlcl90aGFuLCAtMVxuICAgICAgaW5cbiAgICAgIG1hdGNoIE1hcC5jbG9zZXN0X2tleSBtYXAgY2xvc2VzdF9kaXIga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKGtleSwgXykgLT4gb2Zmc2V0IGtleSBtYXAgfmJ5OihieSArIGFkZCkpXG4gIDs7XG5cbiAgKCoqIEZpbmQgaG93IHdlIG5lZWQgdG8gbW92ZSBba2V5XSBpZiBbY2hhbmdlZF9rZXldIGNoYW5nZWQgaW4gdGhlIGdpdmVuXG4gICAgICB3YXkgKilcbiAgbGV0IGZpbmRfb2Zmc2V0IH5jb21wYXJlIH5rZXkgfmNoYW5nZWRfa2V5IGNoYW5nZSA9XG4gICAgaWYgSW50LiggPCApIChjb21wYXJlIGNoYW5nZWRfa2V5IGtleSkgMFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgIHwgYExlZnQgXyAtPiAxXG4gICAgICB8IGBSaWdodCBfIC0+IC0xXG4gICAgICB8IF8gLT4gMClcbiAgICBlbHNlIDBcbiAgOztcblxuICBsZXQgcmFua1xuICAgICAgICAodHlwZSBrIHYgY21wIHN0YXRlX3dpdG5lc3MpXG4gICAgICAgIChtYXAgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChrZXkgOiAoaywgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IHNhbWVfa2V5IGEgYiA9IGNvbXBhcmVfa2V5IGEgYiA9IDAgaW5cbiAgICAgIGxldCB3aGVuX2tleV9jaGFuZ2VkIH5tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rID1cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgbmV3X2tleSBvbGRfa2V5IDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBJZiB0aGUgbmV3IGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG9sZCBrZXksIGZpbmQgdGhlIHNpemUgb2YgdGhlIG1hcCBzdWJyYW5nZVxuICAgICAgICAgICAgIGJldHdlZW4gdGhlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcHJldmlvdXMgcmFuayAqKVxuICAgICAgICAgIGxldCBsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQgPSBFeGNsIG5ld19rZXksIEV4Y2wgb2xkX2tleSBpblxuICAgICAgICAgIGxldCBzdWJyYW5nZSA9IE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCBpblxuICAgICAgICAgIG9sZF9yYW5rIC0gTWFwLmxlbmd0aCBzdWJyYW5nZSAtIDEpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIE90aGVyd2lzZSwgdGhlIG5ldyBrZXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG9sZCBrZXksIHNvIGZpbmQgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgICAgICAgbWFwIHN1YnJhbmdlIGJldHdlZW4gdGhlbSBhbmQgYWRkIGl0IHRvIHRoZSBwcmV2aW91cyByYW5rICopXG4gICAgICAgICAgbGV0IGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IEV4Y2wgb2xkX2tleSwgRXhjbCBuZXdfa2V5IGluXG4gICAgICAgICAgbGV0IHN1YnJhbmdlID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIGluXG4gICAgICAgICAgb2xkX3JhbmsgKyBNYXAubGVuZ3RoIHN1YnJhbmdlICsgMSlcbiAgICAgIGluXG4gICAgICBsZXQgd2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5IH5vbGRfcmFuayA9XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgKCogV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZGF0YSwgc28gb3B0aW1pemUgdGhlc2UgY2hlY2tzICopXG4gICAgICAgICAgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSlcbiAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgbmV3X21hcFxuICAgICAgICAgIH5pbml0Om9sZF9yYW5rXG4gICAgICAgICAgfmY6KGZ1biBhY2MgKGRpZmZfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyAtIDFcbiAgICAgICAgICAgIHwgYFJpZ2h0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyArIDFcbiAgICAgICAgICAgIHwgXyAtPiBhY2MpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBwcm9jZXNzIH4ob2xkIDogKChrLCB2LCBfKSBNYXAudCAqIF8gKiBfKSBvcHRpb24pIG5ld19tYXAgKG5ld19rZXkgOiBrKSA9XG4gICAgICAgIGlmIG5vdCAoTWFwLm1lbSBuZXdfbWFwIG5ld19rZXkpXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICAgICgqIElmIHRoZSBtYXAgYW5kIGtleSBhcmUgdGhlIHNhbWUsIGp1c3QgcmV1c2UgdGhlIG9sZCByYW5rICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBvbGRfcmFuaylcbiAgICAgICAgICAgIHdoZW4gcGh5c19lcXVhbCBuZXdfbWFwIG9sZF9tYXAgJiYgc2FtZV9rZXkgb2xkX2tleSBuZXdfa2V5IC0+IG9sZF9yYW5rXG4gICAgICAgICAgKCogSWYgdGhlIG1hcCBpcyB0aGUgc2FtZSBidXQgdGhlIGtleSBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHBoeXNfZXF1YWwgbmV3X21hcCBvbGRfbWFwIC0+XG4gICAgICAgICAgICBTb21lICh3aGVuX2tleV9jaGFuZ2VkIH5tYXA6bmV3X21hcCB+b2xkX2tleSB+bmV3X2tleSB+b2xkX3JhbmspXG4gICAgICAgICAgKCogSWYgdGhlIGtleSBpcyB0aGUgc2FtZSBidXQgdGhlIG1hcCBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHNhbWVfa2V5IG5ld19rZXkgb2xkX2tleSAtPlxuICAgICAgICAgICAgU29tZSAod2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5Om5ld19rZXkgfm9sZF9yYW5rKVxuICAgICAgICAgICgqIElmIGJvdGggdGhlIG1hcCBhbmQgdGhlIGtleSBjaGFuZ2VkLCB0aGlzIGNhbiBiZSBzaW11bGF0ZWQgYXMgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5naW5nIGZvbGxvd2VkIGJ5IHRoZSBrZXkgY2hhbmdpbmcgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspIC0+XG4gICAgICAgICAgICAoKiBXZSBjYWxsIFtwcm9jZXNzXSByZWN1cnNpdmVseSBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmdcbiAgICAgICAgICAgICAgIFt3aGVuX21hcF9jaGFuZ2VkXSBmb2xsb3dlZCBieSBbd2hlbl9rZXlfY2hhbmdlZF0gc2luY2UgaXQgbWlnaHQgYmUgdGhlXG4gICAgICAgICAgICAgICBjYXNlIHRoYXQgW29sZF9rZXldIGlzIGluIFtvbGRfbWFwXSBhbmQgW25ld19rZXldIGlzIGluIFtuZXdfbWFwXSwgYnV0XG4gICAgICAgICAgICAgICBbb2xkX2tleV0gaXMgbm90IGluIFtuZXdfbWFwXS4gKilcbiAgICAgICAgICAgIGxldCBvbGRfcmFuayA9XG4gICAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykpIG5ld19tYXAgb2xkX2tleVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAobmV3X21hcCwgb2xkX2tleSwgb2xkX3JhbmspKSBuZXdfbWFwIG5ld19rZXlcbiAgICAgICAgICAoKiBJZiB0aGUgcHJldmlvdXMga2V5IHdhcyBub3QgaW4gdGhlIG1hcCBvciB0aGlzIGlzIHRoZSBmaXJzdCBzdGFiaWxpemF0aW9uLFxuICAgICAgICAgICAgIGNvbXB1dGUgdGhlIHJhbmsgZnJvbSBzY3JhdGNoICopXG4gICAgICAgICAgfCBTb21lIChfLCBfLCBOb25lKSB8IE5vbmUgLT4gTWFwLnJhbmsgbmV3X21hcCBuZXdfa2V5KVxuICAgICAgaW5cbiAgICAgIHdpdGhfb2xkMiBtYXAga2V5IH5mOnByb2Nlc3MpXG4gIDs7XG5cbiAgKCoqIFJhbmdlIG1hcCBieSBpbmRpY2VzICopXG4gIGxldCBzdWJyYW5nZV9ieV9yYW5rXG4gICAgICAgICh0eXBlIGsgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcCA6ICgoaywgXywgXykgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChyYW5nZSA6IChpbnQgTWF5YmVfYm91bmQudCAqIGludCBNYXliZV9ib3VuZC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgID1cbiAgICBsZXQgZmluZF9rZXlfcmFuZ2UgKHJhbmdlIDogKGludCAqIGludCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgIDogKChrICogayBvcHRpb24pIG9wdGlvbiwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgPVxuICAgICAgd2l0aF9vbGQyIG1hcCByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIChmcm9tLCB0b18pIC0+XG4gICAgICAgICgqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBubyBrZXlzLCBvbmx5IGJlZ2luIGtleSwgb3IgYmVnaW4gYW5kIGVuZCBrZXlzLlxuICAgICAgICAgICBUaGVzZSBhcmUgdGhlIGtleXMgYXQgW2Zyb21dIGFuZCBbdG9fXSBwb3NpdGlvbnMgaW4gdGhlIG1hcCwgb3IgTm9uZSBpZiB0aGVcbiAgICAgICAgICAgaW5kaWNlcyBhcmUgdG9vIGJpZy4gQXMgYWx3YXlzIFswIDw9IGZyb20gJiYgZnJvbSA8PSB0b19dLCB0aGVyZSBpcyBub1xuICAgICAgICAgICBwb3NzaWJpbGl0eSBvZiBvbmx5IFt0b19dIGJlaW5nIGEgdmFsaWQgcG9zaXRpb24uXG4gICAgICAgICopXG4gICAgICAgIGlmIEludC4oIDwgKSB0b18gZnJvbSB8fCBJbnQuKCA8ICkgZnJvbSAwXG4gICAgICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJJbnZhbGlkIGluZGljZXNcIiAoZnJvbSA6IGludCkgKHRvXyA6IGludCldO1xuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIChvbGRfZnJvbSwgb2xkX3RvKSwgU29tZSAoYmVnaW5fa2V5LCBlbmRfa2V5X29wdCkpIC0+XG4gICAgICAgICAgbGV0IGZpbmRfb2Zmc2V0ID0gZmluZF9vZmZzZXQgfmNvbXBhcmU6KE1hcC5jb21wYXJhdG9yIG1hcCkuY29tcGFyZSBpblxuICAgICAgICAgIGxldCByYW5nZV9vZmZzZXRfYmVnaW4gPSBmcm9tIC0gb2xkX2Zyb20gaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2VuZCA9IHRvXyAtIG9sZF90byBpblxuICAgICAgICAgIGxldCBhZGp1c3RfYW5kX29mZnNldCB+Ynkga2V5ID1cbiAgICAgICAgICAgIGxldCBieSA9IGJ5ICsgaWYgYnkgPj0gMCAmJiBub3QgKE1hcC5tZW0gbWFwIGtleSkgdGhlbiAxIGVsc2UgMCBpblxuICAgICAgICAgICAgb2Zmc2V0IGtleSBtYXAgfmJ5XG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGtleXMgY2hhbmdpbmcgYW5kIG5vdCB0aGUgZGF0YSwgc28gW2RhdGFfZXF1YWxdIGhlcmVcbiAgICAgICAgICAgICBjYW4gYmUgYWx3YXlzIHRydWUgKilcbiAgICAgICAgICBsZXQgZGlmZiB+aW5pdCB+ZiA9XG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZiB+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiB0cnVlKSBvbGRfbWFwIG1hcCB+aW5pdCB+ZlxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IGJlZ2luX2tleV9vcHQsIGVuZF9rZXlfb3B0ID1cbiAgICAgICAgICAgIG1hdGNoIGVuZF9rZXlfb3B0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBlbmRfa2V5IC0+XG4gICAgICAgICAgICAgIGxldCBtYXBfb2Zmc2V0X2JlZ2luLCBtYXBfb2Zmc2V0X2VuZCA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDooMCwgMCkgfmY6KGZ1biAob2Zmc2V0X2JlZ2luLCBvZmZzZXRfZW5kKSAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICAoIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAsIG9mZnNldF9lbmQgKyBmaW5kX29mZnNldCB+a2V5OmVuZF9rZXkgfmNoYW5nZWRfa2V5OmtleSBjaGFuZ2UgKSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIGFkanVzdF9hbmRfb2Zmc2V0IGVuZF9rZXkgfmJ5OihtYXBfb2Zmc2V0X2VuZCArIHJhbmdlX29mZnNldF9lbmQpIClcbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDowIH5mOihmdW4gb2Zmc2V0X2JlZ2luIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgICAgIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAoIGFkanVzdF9hbmRfb2Zmc2V0IGJlZ2luX2tleSB+Ynk6KG1hcF9vZmZzZXRfYmVnaW4gKyByYW5nZV9vZmZzZXRfYmVnaW4pXG4gICAgICAgICAgICAgICwgbnRoX2Zyb21fZWl0aGVyX3NpZGUgdG9fIG1hcCApXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhc3NlcnQgKE9wdGlvbi5mb3JfYWxsIH5mOihNYXAubWVtIG1hcCkgYmVnaW5fa2V5X29wdCk7XG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGVuZF9rZXlfb3B0KTtcbiAgICAgICAgICBPcHRpb24ubWFwIGJlZ2luX2tleV9vcHQgfmY6KGZ1biBiZWdpbl9rZXkgLT4gYmVnaW5fa2V5LCBlbmRfa2V5X29wdClcbiAgICAgICAgfCBOb25lIHwgU29tZSAoXywgXywgTm9uZSkgLT5cbiAgICAgICAgICAoKiBPbiBmaXJzdCBydW4gKHdoZW4gd2UgaGF2ZSB0bykgb3Igd2hlbiBib3RoIHRoZSBrZXlzIGFyZSBub25lLCBydW4gTyhuKVxuICAgICAgICAgICAgIHNjYW4uIFRoaXMgaXMgZmluZSBmb3Iga2V5cy1hcmUtbm9uZSBjYXNlIGFzIGl0IGhhcHBlbnMgd2hlbiB0aGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgYXJlIHBhc3QgZW5kIG9mIHRoZSBtYXAsIHNvIHRoZXkgc2hvdWxkbid0IGJlIHRvbyBmYXIgZnJvbSBlbmQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5nZXMsIGFuZCBbZmluZF9rZXlfcmFuZ2VfbGluZWFyXSBpcyBmYXN0IGluIHN1Y2ggY2FzZS4gKilcbiAgICAgICAgICBmaW5kX2tleV9yYW5nZV9saW5lYXIgbWFwIH5mcm9tIH50b18pXG4gICAgaW5cbiAgICAoKiBIYW5kbGUgZGlmZmVyZW50IE1heWJlX2JvdW5kIGNhc2VzIGFuZCBjYWxsIGZpbmRfa2V5X3JhbmdlIGlmIG5lY2Vzc2FyeS4gSXQnc1xuICAgICAgIG5pY2VyIHRvIGRvIHRoaXMgaGVyZSBhcyBvcHBvc2VkIHRvIG1ha2luZyBmaW5kX2tleV9yYW5nZSBldmVuIG1vcmUgY29tcGxpY2F0ZWQgKilcbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0ICggPj4+ICkgbmV3XyBib3VuZCA9IE1heWJlX2JvdW5kLm1hcCB+ZjooZnVuIF8gLT4gbmV3XykgYm91bmQgaW5cbiAgICBsZXQgcmV0dXJuID0gSW5jcmVtZW50YWwucmV0dXJuIChJbmNyZW1lbnRhbC5zdGF0ZSBtYXApIGluXG4gICAgbGV0IGtleV9yYW5nZSA9XG4gICAgICBtYXRjaCVwYXR0ZXJuX2JpbmQgcmFuZ2Ugd2l0aFxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCAtPlxuICAgICAgICByZXR1cm4gKFNvbWUgKE1heWJlX2JvdW5kLlVuYm91bmRlZCwgTWF5YmVfYm91bmQuVW5ib3VuZGVkKSlcbiAgICAgIHwgKCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpXG4gICAgICAgICwgKChNYXliZV9ib3VuZC5JbmNsIHUgfCBNYXliZV9ib3VuZC5FeGNsIHUpIGFzIHViKSApIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCB1KVxuICAgICAgICBhbmQgbGIgPSBsYlxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBTb21lIGVuZF9rZXkpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIGVuZF9rZXkgPj4+IHViKVxuICAgICAgICAgfCBTb21lIChiZWdpbl9rZXksIE5vbmUpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCBsIGwpXG4gICAgICAgIGFuZCBsYiA9IGxiIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKGtleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCB1IHUpXG4gICAgICAgIGFuZCB1YiA9IHViIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKFVuYm91bmRlZCwga2V5ID4+PiB1YilcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIGluXG4gICAgc3VicmFuZ2UgP2RhdGFfZXF1YWwgbWFwIGtleV9yYW5nZVxuICA7O1xuXG4gIGxldCB0cmFuc3Bvc2VcbiAgICA6IHR5cGUgazEgazIgdiBrMV9jbXAgazJfY21wIHN0YXRlX3dpdG5lc3MuXG4gICAgICA/ZGF0YV9lcXVhbDoodiAtPiB2IC0+IGJvb2wpXG4gICAgICAtPiAoazIsIGsyX2NtcCkgTWFwLmNvbXBhcmF0b3JcbiAgICAgIC0+ICgoazEsIChrMiwgdiwgazJfY21wKSBNYXAudCwgazFfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgLT4gKChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGZ1biA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKSBrMl9jb21wYXJhdG9yIG0gLT5cbiAgICAgIHdpdGhfY29tcGFyYXRvciBtIChmdW4gazFfY29tcGFyYXRvciAtPlxuICAgICAgICBsZXQgdXBkYXRlXG4gICAgICAgICAgOiAga2V5OmsxIC0+IG9sZF9kYXRhOihrMiwgdiwgazJfY21wKSBNYXAudCAtPiBuZXdfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnRcbiAgICAgICAgICAgIC0+IChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50XG4gICAgICAgICAgICAtPiAoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudFxuICAgICAgICAgID1cbiAgICAgICAgICBmdW4gfmtleTprMSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgb2xkX2RhdGFcbiAgICAgICAgICAgICAgbmV3X2RhdGFcbiAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIChrMiwgZGlmZikgLT5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIE1hcC5jaGFuZ2UgYWNjIGsyIH5mOihmdW4gYWNjX2lubmVyIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYWNjX2lubmVyID1cbiAgICAgICAgICAgICAgICAgICAgTWFwLmNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgIChPcHRpb24udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGVmYXVsdDooTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6azFfY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgICAgICAgazFcbiAgICAgICAgICAgICAgICAgICAgICB+ZjooZnVuIF8gLT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGFjY19pbm5lciB0aGVuIE5vbmUgZWxzZSBTb21lIGFjY19pbm5lcikpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBhZGQgfmtleSB+ZGF0YSA9XG4gICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcikgfm5ld19kYXRhOmRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhID1cbiAgICAgICAgICB1cGRhdGUgfmtleSB+b2xkX2RhdGE6ZGF0YSB+bmV3X2RhdGE6KE1hcC5lbXB0eSBrMl9jb21wYXJhdG9yKVxuICAgICAgICBpblxuICAgICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICAgIG1cbiAgICAgICAgICB+aW5pdDooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpXG4gICAgICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgICAgIH51cGRhdGVcbiAgICAgICAgICB+YWRkXG4gICAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgY29sbGFwc2VfYnlcbiAgICAgICAgKHR5cGUgb3V0ZXJfa2V5IG91dGVyX2NtcCBpbm5lcl9rZXkgaW5uZXJfY21wIGNvbWJpbmVkX2tleSBjb21iaW5lZF9jbXApXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KG1lcmdlX2tleXMgOiBvdXRlcl9rZXkgLT4gaW5uZXJfa2V5IC0+IGNvbWJpbmVkX2tleSlcbiAgICAgICAgfihjb21wYXJhdG9yIDogKGNvbWJpbmVkX2tleSwgY29tYmluZWRfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBjb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfnVwZGF0ZTooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGE6XyB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIE1hcC5zZXQgYWNjIH5rZXk6KG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkgfmRhdGE6bmV3X2RhdGEpXG4gICAgICB+YWRkOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAuYWRkX2V4biBhY2MgfmtleToobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSB+ZGF0YSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLnJlbW92ZSBhY2MgKG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkpXG4gIDs7XG5cbiAgbGV0IGNvbGxhcHNlXG4gICAgICAgICh0eXBlIG91dGVyX2tleSBvdXRlcl9jbXAgaW5uZXJfa2V5IGlubmVyX2NtcClcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcF9pbmNyIDpcbiAgICAgICAgICAgKChvdXRlcl9rZXksIChpbm5lcl9rZXksIF8sIGlubmVyX2NtcCkgTWFwLnQsIG91dGVyX2NtcCkgTWFwLnQsIF8pIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH5jb21wYXJhdG9yOihpbm5lcl9jb21wYXJhdG9yIDogKGlubmVyX2tleSwgaW5uZXJfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gb3V0ZXJfY29tcGFyYXRvciAtPlxuICAgICAgbGV0IG1vZHVsZSBDbXAgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gb3V0ZXJfa2V5ICogaW5uZXJfa2V5XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gKG91dGVyX2NtcCwgaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPVxuICAgICAgICAgIGxldCBpbm5lcl9jb21wYXJhdG9yID1cbiAgICAgICAgICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgaW5uZXJfY29tcGFyYXRvcikgaW5cbiAgICAgICAgICAgIE0uY29tcGFyYXRvclxuICAgICAgICAgIGluXG4gICAgICAgICAgVHVwbGUyLmNvbXBhcmF0b3Igb3V0ZXJfY29tcGFyYXRvciBpbm5lcl9jb21wYXJhdG9yXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICBjb2xsYXBzZV9ieVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+bWVyZ2Vfa2V5czpUdXBsZTIuY3JlYXRlXG4gICAgICAgIH5jb21wYXJhdG9yOihtb2R1bGUgQ21wKSlcbiAgOztcblxuICBsZXQgZXhwYW5kID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+dXBkYXRlOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5vbGRfZGF0YTpfIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBNYXAuc2luZ2xldG9uIGlubmVyX2NvbXBhcmF0b3IgaW5uZXJfa2V5IG5ld19kYXRhXG4gICAgICAgICAgfCBTb21lIG1hcCAtPiBNYXAuc2V0IG1hcCB+a2V5OmlubmVyX2tleSB+ZGF0YTpuZXdfZGF0YSkpXG4gICAgICB+YWRkOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAudXBkYXRlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE1hcC5zaW5nbGV0b24gaW5uZXJfY29tcGFyYXRvciBpbm5lcl9rZXkgZGF0YVxuICAgICAgICAgIHwgU29tZSBtYXAgLT4gTWFwLmFkZF9leG4gbWFwIH5rZXk6aW5uZXJfa2V5IH5kYXRhKSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLmNoYW5nZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIG1hcCAtPlxuICAgICAgICAgICAgbGV0IG1hcCA9IE1hcC5yZW1vdmUgbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgT3B0aW9uLnNvbWVfaWYgKG5vdCAoTWFwLmlzX2VtcHR5IG1hcCkpIG1hcCkpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6MFxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBjb3VudCAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBjb3VudCAtIDEgZWxzZSBjb3VudClcbiAgOztcblxuICBsZXQgY291bnQgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mKSB+ZjooZnVuIGNvdW50IC0+IGNvdW50IDw+IDApXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgZXhpc3RzaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHN1bVxuICAgICAgICAodHlwZSB1KVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAobWFwX2luY3IgOiAoKF8sIF8sIF8pIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICAobW9kdWxlIEdyb3VwIDogQWJzdHJhY3RfYWxnZWJyYS5Db21tdXRhdGl2ZV9ncm91cC5XaXRob3V0X3NleHAgd2l0aCB0eXBlIHQgPSB1KVxuICAgICAgICB+ZlxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDpHcm91cC56ZXJvXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleTpfIH5kYXRhOnYgYWNjIC0+IEdyb3VwLiggKyApIGFjYyAoZiB2KSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5Ol8gfmRhdGE6diBhY2MgLT4gR3JvdXAuKCAtICkgYWNjIChmIHYpKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxuICAgICAgfmY6KGZ1biBjb3VudCAtPiBjb3VudCA9IDApXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGZvcl9hbGxpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyID0gZmluZF9rZXlfcmFuZ2VfbGluZWFyXG4gIGVuZFxuXG4gIG1vZHVsZSBMb29rdXAgPSBzdHJ1Y3RcbiAgICB0eXBlICgndiwgJ3cpIGVudHJ5ID1cbiAgICAgIHsgbXV0YWJsZSBzYXZlZF92YWx1ZSA6ICd2IG9wdGlvblxuICAgICAgOyBub2RlIDogKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnRcbiAgICAgIH1cblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIHNhdmVkX21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICAoKiBXZSBtYXkgaGF2ZSBtdWx0aXBsZSBlbnRyaWVzIHBlciBrZXkgaWYgbm9kZXMgYmVjb21lIG5lY2Vzc2FyeSBhZ2FpbiBhZnRlciBiZWluZ1xuICAgICAgICAgcmVtb3ZlZC4gKilcbiAgICAgIDsgbXV0YWJsZSBsb29rdXBfZW50cmllcyA6ICgnaywgKCd2LCAndykgZW50cnkgbGlzdCwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgdXBkYXRlcl9ub2RlIDogKHVuaXQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICA7IHNjb3BlIDogJ3cgSW5jcmVtZW50YWwuU2NvcGUudFxuICAgICAgfVxuXG4gICAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgICAgdHlwZSB0XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICBlbmQpID1cbiAgICBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgndiwgJ3cpIHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MsICd3KSB0XG4gICAgZW5kXG5cbiAgICBsZXQgY3JlYXRlID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpIGlucHV0X21hcCB+Y29tcGFyYXRvciA9XG4gICAgICBsZXQgcmVjIHNlbGYgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKGxldCB1cGRhdGVyX25vZGUgPVxuICAgICAgICAgICAgIEluY3JlbWVudGFsLm1hcCBpbnB1dF9tYXAgfmY6KGZ1biBpbnB1dF9tYXAgLT5cbiAgICAgICAgICAgICAgIGxldCAobGF6eSBzZWxmKSA9IHNlbGYgaW5cbiAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgIHNlbGYuc2F2ZWRfbWFwXG4gICAgICAgICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICB+aW5pdDooKVxuICAgICAgICAgICAgICAgICB+ZjooZnVuICgpIChrZXksIGNoYW5nZWRfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBNYXAuZmluZF9tdWx0aSBzZWxmLmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIExpc3QuaXRlciBlbnRyaWVzIH5mOihmdW4gZW50cnkgLT5cbiAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICA8LSAobWF0Y2ggY2hhbmdlZF92YWx1ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld192YWx1ZSB8IGBVbmVxdWFsIChfLCBuZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgU29tZSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBlbnRyeS5ub2RlKSk7XG4gICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcCA8LSBpbnB1dF9tYXApXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgICB7IHNhdmVkX21hcCA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IGxvb2t1cF9lbnRyaWVzID0gZW1wdHlfbWFwXG4gICAgICAgICAgIDsgdXBkYXRlcl9ub2RlXG4gICAgICAgICAgIDsgc2NvcGUgPSBJbmNyZW1lbnRhbC5TY29wZS5jdXJyZW50IChJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXApICgpXG4gICAgICAgICAgIH0pXG4gICAgICBpblxuICAgICAgTGF6eS5mb3JjZSBzZWxmXG4gICAgOztcblxuICAgIGxldFtAY29sZF0gc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5IH5pc19ub3dfb2JzZXJ2YWJsZSA9XG4gICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgIGxldCBjdXJyZW50X2VudHJpZXMgPSBNYXAuZmluZF9tdWx0aSB0Lmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgbGV0IGlzX2xpbmtlZCA9IExpc3QuZXhpc3RzIGN1cnJlbnRfZW50cmllcyB+ZjoocGh5c19lcXVhbCBlbnRyeSkgaW5cbiAgICAgIGlmIEJvb2wuZXF1YWwgaXNfbGlua2VkIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuXG4gICAgICAgIHQubG9va3VwX2VudHJpZXNcbiAgICAgICAgPC0gTWFwLnVwZGF0ZSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgKG90aGVyX2VudHJ5IDo6IF8gYXMgb3RoZXJfZW50cmllcykgLT5cbiAgICAgICAgICAgICgqIFVwZGF0ZSB0aGlzIGVudHJ5J3MgdmFsdWUgdG8gYmUgY3VycmVudC4gKilcbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIG90aGVyX2VudHJ5LnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgZW50cnkgOjogb3RoZXJfZW50cmllc1xuICAgICAgICAgIHwgTm9uZSB8IFNvbWUgW10gLT5cbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleTtcbiAgICAgICAgICAgIFsgZW50cnkgXSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV3X2VudHJpZXMgPVxuICAgICAgICAgIExpc3QuZmlsdGVyIGN1cnJlbnRfZW50cmllcyB+ZjooZnVuIHggLT4gbm90IChwaHlzX2VxdWFsIGVudHJ5IHgpKVxuICAgICAgICBpblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgIDwtIChpZiBMaXN0LmlzX2VtcHR5IG5ld19lbnRyaWVzXG4gICAgICAgICAgICB0aGVuIE1hcC5yZW1vdmUgdC5sb29rdXBfZW50cmllcyBrZXlcbiAgICAgICAgICAgIGVsc2UgTWFwLnNldCB0Lmxvb2t1cF9lbnRyaWVzIH5rZXkgfmRhdGE6bmV3X2VudHJpZXMpKVxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleSA9XG4gICAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSB0LnVwZGF0ZXJfbm9kZSBpblxuICAgICAgSW5jcmVtZW50YWwuU2NvcGUud2l0aGluIGluY3JlbWVudGFsX3N0YXRlIHQuc2NvcGUgfmY6KGZ1biAoKSAtPlxuICAgICAgICBsZXQgcmVjIGVudHJ5ID1cbiAgICAgICAgICBsYXp5XG4gICAgICAgICAgICB7IHNhdmVkX3ZhbHVlID0gTWFwLmZpbmQgdC5zYXZlZF9tYXAga2V5XG4gICAgICAgICAgICA7IG5vZGUgPVxuICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgaW5jcmVtZW50YWxfc3RhdGVcbiAgICAgICAgICAgICAgICAgIChmdW4gKCkgLT4gKGZvcmNlIGVudHJ5KS5zYXZlZF92YWx1ZSlcbiAgICAgICAgICAgICAgICAgIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZTooc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5KVxuICAgICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgICBlbnRyeS5ub2RlXG4gICAgICAgICAgKEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSB0LnVwZGF0ZXJfbm9kZSk7XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIGVudHJ5Lm5vZGUpXG4gICAgOztcblxuICAgIGxldCBmaW5kIHQga2V5ID1cbiAgICAgIG1hdGNoIE1hcC5maW5kX211bHRpIHQubG9va3VwX2VudHJpZXMga2V5IHdpdGhcbiAgICAgIHwgZW50cnkgOjogXyAtPiBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBlbnRyeS5ub2RlXG4gICAgICB8IFtdIC0+IHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnID0gc3RydWN0XG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfZW50cnkgc2V4cF9vZl92YWx1ZSBlbnRyeSA9XG4gICAgICAgIGxldCB7IHNhdmVkX3ZhbHVlOyBub2RlIH0gPSBlbnRyeSBpblxuICAgICAgICBsZXQgbm9kZSA9IEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG5vZGUgaW5cbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgeyBzYXZlZF92YWx1ZSA6IHZhbHVlIG9wdGlvblxuICAgICAgICAgIDsgbm9kZV9pbmZvID0gKEluY3JlbWVudGFsLnVzZXJfaW5mbyBub2RlIDogKEluZm8udCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2NvbnN0ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChJbmNyZW1lbnRhbC5pc19jb25zdCBub2RlKSAoKSA6ICh1bml0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICA7IG5vZGVfaXNfaW52YWxpZCA9XG4gICAgICAgICAgICAgIChPcHRpb24uc29tZV9pZiAobm90IChJbmNyZW1lbnRhbC5pc192YWxpZCBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX3VubmVjZXNzYXJ5ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChub3QgKEluY3JlbWVudGFsLmlzX25lY2Vzc2FyeSBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgIH1dXG4gICAgICA7O1xuXG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgICAgICBsZXQgaW5mb19wZXJfa2V5ID1cbiAgICAgICAgICBNYXAubWVyZ2UgdC5zYXZlZF9tYXAgdC5sb29rdXBfZW50cmllcyB+ZjooZnVuIH5rZXkgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IGFjdHVhbF92YWx1ZSwgZW50cmllcyA9XG4gICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSB4LCBbXVxuICAgICAgICAgICAgICB8IGBSaWdodCB5IC0+IE5vbmUsIHlcbiAgICAgICAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gU29tZSB4LCB5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICBbJXNleHBcbiAgICAgICAgICAgICAgICB7IGtleSA6IGtleVxuICAgICAgICAgICAgICAgIDsgYWN0dWFsX3ZhbHVlIDogKHZhbHVlIG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgICAgICAgICAgICAgIDsgZW50cmllcyA6IHZhbHVlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB9XSlcbiAgICAgICAgaW5cbiAgICAgICAgU2V4cC5MaXN0IChNYXAuZGF0YSBpbmZvX3Blcl9rZXkpXG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgc3RhdGVfd2l0bmVzc1xuXG4gIGluY2x1ZGVcbiAgICBTX2dlblxuICAgIHdpdGggdHlwZSAnYSBJbmNyLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgYW5kIHR5cGUgJ2EgSW5jci5DdXRvZmYudCA9ICdhIEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgIGFuZCB0eXBlICgnaywgJ3YsICdjbXApIExvb2t1cC50ID0gKCdrLCAndiwgJ2NtcCwgc3RhdGVfd2l0bmVzcykgR2VuZXJpYy5Mb29rdXAudFxuZW5kXG5cbm1vZHVsZSBNYWtlIChJbmNyIDogSW5jcmVtZW50YWwuUykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IGZsYXR0ZW4geCA9IGZsYXR0ZW4gSW5jci5TdGF0ZS50IHhcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgaW5jbHVkZSBMb29rdXBcblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXAsIEluY3Iuc3RhdGVfd2l0bmVzcykgTG9va3VwLnRcblxuICAgIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICAgIHR5cGUgdFxuICAgICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgZW5kKSA6IHNpZ1xuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEdlbmVyaWNcbiJdfQ==
